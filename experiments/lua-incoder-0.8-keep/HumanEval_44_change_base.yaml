name: HumanEval_44_change_base
language: lua
prompt: "-- Change numerical base of input number x to base.\n-- return string representation\
  \ after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base(8,\
  \ 3)\n-- '22'\n-- >>> change_base(8, 2)\n-- '1000'\n-- >>> change_base(7, 2)\n--\
  \ '111'\nlocal function change_base(x, base)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = change_base\n\
  \    lu.assertEquals(candidate(8, 3), '22')\n    lu.assertEquals(candidate(9, 3),\
  \ '100')\n    lu.assertEquals(candidate(234, 2), '11101010')\n    lu.assertEquals(candidate(16,\
  \ 2), '10000')\n    lu.assertEquals(candidate(8, 2), '1000')\n    lu.assertEquals(candidate(7,\
  \ 2), '111')\n    lu.assertEquals(candidate(2, 3), '2')\n    lu.assertEquals(candidate(3,\
  \ 4), '3')\n    lu.assertEquals(candidate(4, 5), '4')\n    lu.assertEquals(candidate(5,\
  \ 6), '5')\n    lu.assertEquals(candidate(6, 7), '6')\n    lu.assertEquals(candidate(7,\
  \ 8), '7')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- Base-2 system.\n\tif base == 2 then\n\t\tlocal t = math.floor(x/2)\n\
    \t\tif x < 2 then\n\t\t\treturn t\n\t\telse\n\t\t\treturn t*2 + 1\n\t\tend\n\t\
    -- Base-10 system.\n\telseif base == 10 then\n\t\tlocal t, base10 = math.modf(x)\n\
    \t\tif base10 > 0 then\n\t\t\treturn change_base(base10, base)\n\t\telse\n\t\t\
    \treturn t\n\t\tend\n\t-- Base-n system.\n\telseif base <= #b10 then\n\t\tlocal\
    \ t, base10 = math.modf(x)\n\t\tlocal tt = math.abs(t)\n\t\tlocal base1 = #b10",
  "  if base < 10 then\n    return tostring(x)\n  end\n  if base > 10 then\n    return\
    \ change_base(x / base, base)\n  end\n  return tostring(x%base) + tostring(base)\n\
    end", "  -- No need to check for overflow, since x is guaranteed to be less than\
    \ base.\n  -- Since base is guaranteed to be less than 10, we can just divide\
    \ by base.\n  x = x / base\n  -- Since base is guaranteed to be less than 10,\
    \ we can just multiply by base.\n  x = x * base\n  return x\nend", "\tlocal result\
    \ = {}\n\t\n\t-- Convert the base to its binary representation.\n\t-- (The binary\
    \ repreentation is stored in the first character).\n\t-- This is not really a\
    \ good way to get the binary representation\n\t-- of a number, but it saves a\
    \ lot of processing time when\n\t-- converting the numbers from base 2 to base\
    \ 10.\n\tlocal base_bin = {\n\t\t[0] = '',\n\t\t[1] = '1',\n\t\t[2] = '10',\n\t\
    \t[3] = '100',\n\t\t[4] = '1000',\n\t\t[5] = '10000',\n\t\t[6] = '100000',\n\t\
    \t[7] = '1000000',\n\t\t[8] = '10000000'\n\t}\n\t\n\t-- Perform the conversion\
    \ for each digit.\n\twhile x > 0 do\n\t\t-- Retrieve the remainder after dividing\
    \ the current number by\n\t\t-- the base to get the next digit.\n\t\tlocal remainder\
    \ = x%base\n\t\t\n\t\t-- Extract the next digit and append it to the result.\n\
    \t\tresult[#result + 1] = base_bin[remainder]\n\t\t\n\t\t-- Update the number\
    \ with the next digit.\n\t\tx = x/base\n\tend\n\t\n\t-- Return the converted number.\n\
    \treturn table.concat(result, '')\nend\n</cell>\n<code language=julia-1.0>\n#\
    \ Define a recursive function to compute the factorial of a number", "    if x\
    \ < 10 then\n        return string.format(\"%0*d\", base, x)\n    end\n    return\
    \ string.format(\"%0*d\", base, math.floor(x/base)*base)\nend", "\tlocal function\
    \ checkBase(str, base)\n\t\tlocal t = {}\n\t\tstr:gsub(\"%a\", function()\n\t\t\
    \ttable.insert(t, tonumber(string.format(%1)))\n\t\tend)\n\t\t\n\t\tif base >\
    \ 10 or base < 1 then return \"Error\" end\n\t\tif #t ~= 1 then return \"Error\"\
    \ end\n\t\tif t[1] < base then return \"Error\" end\n\t\t\n\t\treturn table.concat(t,\
    \ base)\n\tend\n\t\n\treturn checkBase(table.concat({x}, base), base)\nend", " \
    \ assert(base > 0 and base < 10)\n  local s = tonumber(x:reverse())\n  s = s %\
    \ base\n  s = string.format(\"%d\", s)\n  s = string.gsub(s, \"^\", string.rep(\"\
    0\", base))\n  s = string.gsub(s, \"%\", string.rep(\"1\", base))\n  s = s:reverse()\n\
    \  return s\nend", '    local ret', "   -- TODO: Implement error checking here.\n\
    \   -- TODO: Use mathematical methods instead of simple math.\n   return x * base\n\
    end", "  if base < 2 then\n    error('bases must be greater than 1.')\n  end\n\
    \  local function base_tochar(z)\n    if base == 2 then\n      local sign = '-'\
    \ if x < 0 then return '-' else '+' end\n      local char = {\n        '0'\n \
    \     }\n      if x < 0 then\n        table.insert(char, '-')\n      else\n  \
    \      table.insert(char, '+')\n      end\n      if z < 0 then\n        table.insert(char,\
    \ abs(z) + 1)\n      end\n      table.insert(char, (z > 0 and '-' or '+') + abs(z)\
    \ * sign)\n      return '#' .. table.concat(char, '#')\n    end\n    local sign\
    \ = x % base ~= 0 and '+' or '-'\n    return sign * base_tochar((x / base) % base)\n\
    \  end\n  return base_tochar(x)\nend", "\tbase = 10\n\tlocal n = tonumber(x, base)\n\
    \t-- Check if x is an integer\n\tif x == n then\n\t\treturn x\n\tend\n\t-- Handle\
    \ negative and positive numbers.\n\tif x < 0 then\n\t\tn = -n\n\tend\n\t-- Perform\
    \ integer division\n\tx = x / base\n\t-- Handle zero-division\n\tif not x then\n\
    \t\treturn \"0\"\n\tend\n\t-- Handle negative numbers\n\tif x < 0 then\n\t\treturn\
    \ \"-\" + change_base(x, base)\n\tend\n\t-- Now x is positive and x > 0\n\tlocal\
    \ res = \"\"\n\twhile x do\n\t\t-- Use remainder to generate digits\n\t\tlocal\
    \ digit = x / base\n\t\t-- Handle special cases\n\t\tif digit == 0 then\n\t\t\t\
    res = \"0\"\n\t\telseif digit == 1 then\n\t\t\tres = \"1\"\n\t\telse\n\t\t\t--\
    \ Use remainder to generate digits\n\t\t\tlocal d = digit % base\n\t\t\t-- Append\
    \ the required digits\n\t\t\tres = string.char(d - 1 + 10) + res\n\t\tend\n\t\t\
    -- Remove the generated digit\n\t\tx = x % base\n\tend\n\t-- Add negative sign\
    \ if necessary.\n\tif n >= 0 then\n\t\tres = \"-\" + res\n\tend\n\treturn res\n\
    end", "  if base < 2 then\n    error('Base should be between 2 and 36')\n  end\n\
    \  -- Convert input to base-10\n  local digits = math.floor(math.log(x) / math.log(base))\n\
    \  local output = x\n  for i = 0, digits do output = math.pow(base, i) * output\
    \ end\n  -- Convert output to base\n  local digits2 = math.floor(math.log10(output))\n\
    \  while digits2 >= 2 do\n    local digit = math.floor(digits2 / 10)\n    output\
    \ = math.floor(output / math.pow(base, digit))\n    digits2 = digits2 % 10\n \
    \ end\n  if digits2 ~= 0 then\n    output = output / math.pow(base, digits2)\n\
    \  end\n  -- Convert to base-10\n  local digits3 = math.floor(math.log10(output))\n\
    \  local digits3 = 0\n  while digits3 >= 3 do\n    local digit = math.floor(digits3\
    \ / 10)\n    output = math.floor(output / math.pow(base, digit))\n    digits3\
    \ = digits3 % 10\n  end\n  return output\nend", "  local sign = 1\n  if x < 0\
    \ then\n    x = x * -1\n    sign = -1\n  end\n  local digits = \"0123456789ABCDEF\"\
    \n  local res = \"0\"\n  for i = 1, 32 do\n    res = digits .. res + digits\n\
    \  end\n  res = \"1\" + res + res + res + digits\n  res = res .. \"0\"\n  for\
    \ i = 1, x do\n    res = res + res\n  end\n  res = (sign < 0 and \"-\" or \"\"\
    ) + res\n  res = string.gsub(res, digits .. \"\\0\", \"%l\")\n  -- Remove all\
    \ '0', except for 0.\n  if base == 1 and x == 0 then\n    res = string.gsub(res,\
    \ \"%l\", \"\")\n  else\n    res = string.gsub(res, digits .. \"\\0\", \"%l\"\
    )\n  end\n  return res\nend", "    local digits = math.floor(math.log(x) / math.log(base))\n\
    \    local offset = base * digits\n    -- Return string representation of number\
    \ with x converted to base base with offset\n    return (\"%0.\"..digits-1..\"\
    d\"..offset):format(x)\nend", "  if base < 10 then\n    error(\"base \" ..\n\t\
    \  tostring(base) ..\n\t  \" cannot be less than 10\", 2)\n  end\n  if base ==\
    \ 10 then\n    return \"0\"\n  end\n  local x_str\n  if x >= 0x10000000000000000\
    \ then\n    x_str = tostring(x/0x10000000000000000)\n  elseif x >= 0x100000000\
    \ then\n    x_str = tostring(x/0x100000000)\n  elseif x >= 0x10000 then\n    x_str\
    \ = tostring(x/0x10000)\n  elseif x >= 0x100 then\n    x_str = tostring(x/0x100)\n\
    \  elseif x >= 0x10 then\n    x_str = tostring(x/0x10)\n  else\n    x_str = tostring(x)\n\
    \  end\n  return x_str .. change_base(x_str, base-1)\nend", "    local bases =\
    \ {\n        [1] = 1,\n        [2] = 10,\n        [3] = 100,\n        [4] = 1000,\n\
    \        [5] = 10000,\n        [6] = 100000,\n        [7] = 1000000,\n       \
    \ [8] = 10000000,\n        [9] = 100000000,\n        [10] = 1000000000\n    }\n\
    \    return tonumber(string.format('%d', x)) / bases[base]\nend", "\tif base ==\
    \ 0 then return x end\n\tif x < base then return nil end\n\tlocal digits = string.len(x)\
    \ - base\n\tlocal r = \"\"\n\t\n\tfor i = digits, 1, -1 do\n\t\tr = r .. string.format(\"\
    %d\", math.floor(x/base))\n\t\tx = x % base\n\tend\n\t\n\treturn r .. x\nend",
  "\tlocal ret = ''\n\twhile x ~= 0 do\n\t\tret = string.rep('0', base-1) + ret\n\t\
    \tx = x/base\n\tend\n\treturn ret\nend", "\tlocal x_digits = x:reverse()\n\tlocal\
    \ new_digits = {}\n\tlocal old_base = tonumber(x_digits[#x_digits] or 0)\n\t--\
    \ Base change is necessary in base 8 (octal), 8 (binary), 6 (hex),\n\t-- and 10\
    \ (decimal).\n\tif old_base ~= base then\n\t\tnew_digits = x_digits:reverse()\n\
    \t\tnew_digits[#new_digits] = '0'\n\tend\n\t-- For bases other than base 10 (octal),\
    \ convert digits to number\n\t-- representation in base base and append it to\
    \ new_digits.\n\tlocal i = 1\n\twhile i <= #new_digits do\n\t\tlocal digit = tonumber(new_digits[i])\n\
    \t\tif digit ~= nil then\n\t\t\tnew_digits[i] = math.floor((digit + old_base *\
    \ base) / base)\n\t\telse\n\t\t\tnew_digits[i] = '0'\n\t\tend\n\t\ti = i + 1\n\
    \tend\n\t-- Append the new digits except last one which may have\n\t-- fractional\
    \ part which is dropped when converting from\n\t-- base 10 to another base with\
    \ fractional part the number\n\t-- representation will be incorrectly in base\
    \ 10\n\t-- >>> change_base(12, 3)\n\t-- '142'\n\t-- >>> change_base(12, 3)\n\t\
    -- '142'\n\treturn new_digits[#new_digits]\nend", "  local s = \"\"\n  local digit\
    \ = 0\n  while x >= base do\n    digit = digit + 1\n    x = x % base\n    s =\
    \ string.format(\"%d%s\", digit, s)\n  end\n  s = string.format(\"%d%s\", digit,\
    \ s)\n  return s\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere is a\
    \ simple function to convert any number to a base from 2 to 36:\n<code>", "  \
    \ local digits = \"\"\n   if x ~= nil then\n      -- Change all digits into string.\n\
    \      local tmp = x:gsub(\"^0*\", \"\")\n      -- Add leading zeros to number\
    \ if it has less than 3 digits and is greater than or equal to 1.\n      if #tmp\
    \ <= 2 and #tmp > 0 then\n         digits = \"0\"\n         -- Add remaining digits.\n\
    \         for i = 1, #tmp do\n            digits = digits .. tmp:sub(i, i)\n \
    \        end\n      end\n      -- Add leading zeros to number if it has less than\
    \ 2 digits and is greater than or equal to 1.\n      if #digits <= 2 and #digits\
    \ > 0 then\n         digits = \"0\"\n         -- Add remaining digits.\n     \
    \    for i = 1, #digits do\n            digits = digits .. digits:sub(i, i)\n\
    \         end\n      end\n      -- If base is less than 10, convert number to\
    \ string.\n      if base < 10 then\n         digits = tonumber(digits .. \".\"\
    \ .. base:sub(1, base:len()))\n      end\n   end\n   return digits\nend", "  local\
    \ digits = math.tostring(x)\n  local digits_len = #digits\n  if digits_len < base+1\
    \ then\n    return nil\n  end\n  -- first check if x is a power of base\n  local\
    \ power = math.pow(base, digits_len)\n  -- check if x is still a power of base\n\
    \  if digits_len == power or x == power then\n    return digits_len..digits\n\
    \  end\n  -- if x is not power of base, check if x is base digit\n  local base_digit\
    \ = digits:sub(1, digits_len-base)\n  -- if x is not base digit, check if x is\
    \ a base digit\n  if base_digit ~= digits_len or base_digit ~= '0' then\n    return\
    \ nil\n  end\n  return digits_len-base..digits:sub(1)\nend", "\tif base == 0 then\
    \ return '0' end\n\t\n\tlocal t = base\n\tlocal s = ''\n\t\n\twhile x >= t do\n\
    \t\ts, t = math.floor(x/t), t\n\tend\n\t\n\treturn s .. tostring(t-int(math.floor(x/t)))\n\
    end", "  if x < 0 then\n    return \"-\" .. change_base(-x, base)\n  elseif x\
    \ < base then\n    return string.format(\"%0\" .. math.floor(base) .. \"i\", x)\n\
    \  else\n    return string.format(\"%0\" .. math.floor(base) .. \"d\", x)\n  end\n\
    end", "  assert(base >= 1 and base <= 10, 'Base out of range')\n  -- base 10,\
    \ 0, 1\n  if base == 10 then\n    return tostring(base_string[x])\n  end\n  --\
    \ base 2 to 36\n  if base >= 2 and base <= 36 then\n    if x > 0 and base_string[x\
    \ - 1] == '1' then\n      return tostring(base_string[x - 1]..base_string[x])\n\
    \    else\n      return tostring(base_string[x])\n    end\n  end\n  -- base 36\
    \ to 64\n  if base >= 36 and base <= 64 then\n    if x > 0 and base_string[x -\
    \ 1] == '0' then\n      return tostring(base_string[x - 1]..base_string[x])\n\
    \    else\n      return tostring(base_string[x])\n    end\n  end\n  -- base 64\
    \ to 128\n  if base >= 64 and base <= 128 then\n    return tostring(base_string[x])\n\
    \  end\nend", "  local sign = x:gsub('^-', '+-'):gsub('%+', '+-'):gsub('%-', '+-')\n\
    \  local digits = {x = tostring(x), base = tostring(base)}\n  -- Handle digits\
    \ and sign before adding any digits.\n  while digits ~= \"\" and digits:sub(1,1)\
    \ == '0'\n    do\n      digits = digits:sub(2):gsub('^0', ''):gsub('%0+$', '')\n\
    \    end\n  -- Handle digits and sign after adding digits.\n  digits = digits:sub(2)\n\
    \  -- Handle sign before adding digits and base.\n  if sign ~= '-' then\n    if\
    \ digits:sub(1,1) == '0'\n      do\n        digits = digits:sub(2):gsub('^0',\
    \ ''):gsub('%0+$', '')\n      end\n    else\n      digits = '-' .. digits\n  \
    \  end\n  end\n  -- Handle sign after adding digits and base.\n  if sign ~= '-'\
    \ then\n    if digits:sub(1,1) ~= '0'\n      do\n        digits = '-' .. digits\n\
    \      end\n    else\n      digits = sign:sub(1, 1) .. digits\n    end\n  end\n\
    \  -- Handle digits and base.\n  digits = digits:sub(1, digits:len()-1):gsub('^%d+$',\
    \ '')\n  digits = digits * base\n  -- Handle digits.\n  return digits:gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d',\n\
    \    function(d)\n      local ret = ''\n      local i = 0\n      while d ~= ''\
    \ do\n        if i < 10 then\n          ret = (d * i) + ret\n        end\n   \
    \     i = i + 1\n        d = d:sub(2)\n      end\n      return ret\n    end)\n\
    end", "   local t = {}\n   local i = 0\n   if base <= 0 then\n      t[i] = \"\"\
    \n      i = 1\n   end\n   while i <= base do\n      t[i] = tostring(x)\n     \
    \ x = x / base\n      i = i + 1\n   end\n   if x < 1 then\n      t[i] = tostring(x)\n\
    \   end\n   return table.concat(t, \"\")\nend", "  local bases = {\n      [10]\
    \ = '1',\n      [8]  = '100',\n      [7]  = '110',\n      [6]  = '101',\n    \
    \  [5]  = '111',\n      [4]  = '1000',\n      [3]  = '1001',\n      [2]  = '101',\n\
    \      [1]  = '111',\n      [0]  = '1000',\n  }\n  assert(base > 0 and base <=\
    \ 10)\n  local n = tonumber(x)\n  if n == nil then return 'nil' end\n  assert(n\
    \ > 0 and n < 256)\n  return bases[base]..tostring(n)\nend", "    if base < 10\
    \ then\n        return string.format(\"%o\", x)\n    else\n        return string.format(\"\
    %x\", x)\n    end\nend", "    if x < 10 and base >= 10 then\n        local str\
    \ = string.format(\"%u\", x)\n        return str:sub(2, -2)\n    end", "    local\
    \ s = ''\n    while x > 0 do\n        local a = math.floor(x/base)\n        s\
    \ = tostring(a) .. s\n        x = x - a * base\n    end\n    return s\nend", " \
    \ if x > 10 then\n    return base\n  end\n  local digits = math.huge\n  if base\
    \ <= 1 then\n    -- base 1 can be converted\n    digits = math.huge / base\n \
    \ elseif base < 2 then\n    -- base 2 is equal to base 3\n    digits = math.huge\
    \ / (base - 1)\n  end\n  local pow = digits\n  x = x * base\n  local i = 2\n \
    \ while i <= x do\n    i = i * base\n    pow = pow / base\n  end\n  return math.floor(pow)\n\
    end", "  if x < 10 then\n    return base_table[base] + tostring(x)\n  end\n  --\
    \ If the lower digit is 0 and the base is odd, the lower digit will be 1.\n  --\
    \ If the base is even the lower digit will be 0.\n  local x = math.floor(x * base)\
    \ / base\n  if x <= 1 then\n    return base_table[base] + tostring(x - base)\n\
    \  else\n    -- If base is odd and lower digit is 1, upper digit is 0.\n    --\
    \ If base is even the upper digit is 0.\n    return tostring(x) + tostring(x -\
    \ base) + base_table[base] .. tostring(x * base)\n  end\nend", "\tassert(base\
    \ <= 10, 'Base should be less than 10')\n\tif base == 10 then\n\t\treturn tostring(x)\n\
    \tend\n\tlocal result = x\n\tlocal divisor = 10\n\trepeat\n\t\tresult = result\
    \ / base\n\t\tdivisor = divisor / base\n\tuntil result >= divisor\n\treturn tostring(result)\n\
    end", "  if x < base then\n    error(\"Base must be lesser than input number.\"\
    )\n  end\n  local digits = math.floor(math.log10(x))\n  local result = \"\"\n\
    \  for i = 1, digits do\n    local remainder = x % base\n    if remainder ~= 0\
    \ then\n      x = x / base\n      result = string.format(\"%s%s\", result, remainder)\n\
    \    end\n  end\n  return \"1\" + result\nend", "    if x < 10 then\n        return\
    \ x\n    else\n        local digits = math.floor(math.log(x / base, base) + 1)\n\
    \        return string.format('%d', x / base * base + digits)\n    end\nend",
  "\t-- return string representation of x after changing base.\n\t-- if base is less\
    \ than 10, add '0'.\n\tif base < 10 then\n\t\t-- base is less than 10, add '0'.\n\
    \t\tx = string.format(\"%0\", base) + x\n\tend\n\tlocal ret = \"\"\n\t-- loop\
    \ through characters in string representation of x.\n\tfor i, v in string.gmatch(x,\
    \ '%S+') do\n\t\t-- get ASCII code of v.\n\t\tlocal v = tonumber(v)\n\t\t-- subtract\
    \ ASCII code of '0' from v to find x value after base.\n\t\t-- value of x after\
    \ base will always be less than 10.\n\t\tv = v - 48\n\t\t-- change x value to\
    \ string.\n\t\tlocal xx = string.sub(x, i, i)\n\t\t-- if new x value is greater\
    \ than base.\n\t\tif v >= base then\n\t\t\t-- add new x value to string.\n\t\t\
    \txx = string.format(\"%0\", base) + xx\n\t\tend\n\t\t-- append converted x value\
    \ to returned string.\n\t\tret = ret + xx\n\tend\n\treturn ret\nend", "    if\
    \ x < 10 then\n        return tostring(x * tonumber(base))\n    else\n       \
    \ local num_digits = math.floor(math.log(abs(x), base))\n        if base == 10\
    \ then\n            return tostring(x * tonumber(base))\n        else\n      \
    \      return tostring(x/base) * tonumber(tostring(base))\n        end\n    end\n\
    end", "    if x > base then\n        error (\"Base \" .. tostring(base) .. \"\
    \ must be < \" .. tostring(10))\n    end\n    local res = \"\"\n    local xi =\
    \ x\n    while xi do\n        local digit = xi % base\n        res = base_digits[digit]\
    \ .. res\n        xi = floor(xi / base)\n    end\n    return res\nend", "  if\
    \ x ~= tonumber(x) then return x end\n  local digits = math.floor(math.log10(base))\n\
    \  return (((x%base)/base) * base) .. math.pow(base,digits)\nend", "  local s\
    \ = ''\n  while x > 0 do\n    s, x = string.sub(string.gsub(x, '(%d*)$', '%1'),\
    \ '-' .. base..'+1'), tonumber(s)\n  end\n  return s\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis is an interesting approach.\n<|/ c |>\n<| a tags=math,lua,string-formatting\
    \ dscore=1 |>\nHere's a solution using lua number formatting.\n<code>", "    local\
    \ sign = nil\n    if x >= 0 then\n        x = math.abs(x)\n        sign = string.rep('+-',\
    \ x % base)\n        x = math.floor(x/base)\n    end\n    if x < 0 then\n    \
    \    sign = '-' .. sign\n        x = -x\n    end\n    return string.format(\"\
    %0*d\", base, x) and sign .. x or x\nend", "    local t = {}\n    for i = 1, 3\
    \ do\n        t[i] = x\n        if x ~= 0 then\n            local p = math.floor(x/base)\n\
    \            local t = x - p*base\n            t[i] = p\n            x = t\n \
    \       end\n    end\n    t[3] = x\n    return table.concat(t, \"\")\nend", " \
    \ local str = x\n  local power = 1\n  if base * base > x then\n    local r = math.floor(x\
    \ / base)\n    str = x % base\n    local quotient\n    while r ~= 0 do\n     \
    \ r = math.floor(r / base)\n      str = string.format(\"%d%s\", r, str)\n    \
    \  power = power + 1\n    end\n    str = string.format(\"%d%s\", x, str)\n   \
    \ power = power + 1\n  else\n    str = string.format(\"%.0d\", x)\n  end\n  return\
    \ string.sub(str,0,power - 1..-2) + string.sub(str, power - 1)\nend", "    local\
    \ str = tostring(x)\n    str = string.gsub(str, {'^0', '0*'}, string.rep('0',\
    \ base))\n    return tostring(str)\nend", "    local ret = \"\"\n    if x > base\
    \ then\n        return \"\"\n    end\n    local i = 0\n    while x ~= 0 do\n \
    \       local c = math.floor(x/base)\n        if c == 0 then\n            ret\
    \ = \"0\" + ret\n        else\n            ret = c + ret .. \"0\"\n        end\n\
    \        x = x%base\n        i = i + 1\n        if i > 3 then\n            break\n\
    \        end\n    end\n    return ret\nend", "    local res = 0\n    local pos\
    \ = 1\n    while x > 0 do\n        res = ((res * base) + x) % base\n        x\
    \ = x / base\n        pos = pos + 1\n    end\n    return res\nend\n</code>\n<|/\
    \ a |>\n<| a tags=binary,lua |>\nIf you want it as an int you can do that very\
    \ simply with math:\n<code>", "   assert(x > 0 and base > 0 and base < 10)\n \
    \  if x < base then return 0 end\n   if x == base then return x end\n   local\
    \ n = 1\n   while n < base do\n      n = n * 10 + x\n      x = x / 10\n   end\n\
    \   return n\nend", "  assert(base > 0 and base < 10, \"Base should be a valid\
    \ number\")\n  assert(x >= 0, \"Can't convert to negative base number\")\n  if\
    \ base == 10 then\n    return tostring(x)\n  else\n    local r = tostring(x)\n\
    \    local s = r:sub(1, base):lower()\n    local t = s:sub(2, base-1)\n    local\
    \ n = tonumber(t, 2)\n    if n ~= nil then\n      r = r * base\n      r = r +\
    \ s\n      return change_base(n, base)\n    else\n      return r\n    end\n  end\n\
    end", "   if x < base then return nil end\n   if base > 9 then return nil end\n\
    \   local res = \"\"\n   if base * 2 < x then\n      for i = 1, x - base * 2 +\
    \ 1, base do\n         res = base * res + str\n      end\n   else\n      res =\
    \ str\n   end\n   return res\nend", "\tlocal base = tonumber(base) or 10\n\tif\
    \ base < 10 then\n\t\tbase.digits = base.digits or 10\n\t\tlocal digits = math.floor(math.log(abs(x),\
    \ base))\n\t\treturn string.format(\"%.\" .. digits .. \"d\", x / base * base)\n\
    \tend\n\tx = math.round(x) or 0\n\tlocal digits = math.log(abs(x), base) + 1 --\
    \ avoid overflow problems\n\tx = x / base\n\treturn string.format(\"%.\" .. digits\
    \ .. \"d\", x)\nend", "  if x < 0 then \n    x = x + base\n    if x < 0 then \n\
    \      x = x + base\n      --return '-' + change_base(x, base)\n      return '-'\
    \ + change_base(-x, base)\n    else \n      return x\n    end\n  end\n  if base\
    \ < 2 then\n    x *= -1\n  elseif base > 36 then\n    x *= -1\n  end\n  return\
    \ x:sub(1, base):reverse()\nend", "    if x < 10 then\n        return x\n    end\n\
    \    if base < 2 then\n        error('Base must be greater than or equal to 2')\n\
    \    end\n    if base > 10 then\n        error('Base must be less than or equal\
    \ to 10')\n    end\n    if base == 2 then\n        return '0' + x\n    end\n \
    \   local result = ''\n    local i = 2\n    repeat -- Convert x to binary string\
    \ and add leading '0'.\n        if i ~= base then\n            result = result\
    \ .. string.format('0', x % base)\n        end\n        x = x / base\n       \
    \ i = i + 1\n    until x == 0\n    if i > 2 then\n        result = result .. string.format('%1',\
    \ x)\n    end\n    return result\nend", "  local str = tonumber(x)\n  if str ==\
    \ 0 then\n    return '0'\n  end\n  if str ~= 0 then\n    str = math.floor(str\
    \ / base) * base\n    str = str + tostring(1)\n  end\n  local str = str:gsub('([%d%d%d%d%d%d])',\
    \ function()\n    local n = tonumber(arguments[1])\n    local base = tonumber(arguments[2])\
    \ or 10\n    if base < 2 or (base > 36 and base < 62) then\n      return '#'\n\
    \    end\n    local ret = tostring(n)\n    if base > 10 then\n      ret = tostring(math.floor(ret\
    \ / base))\n    end\n    return ret\n  end)\n  return str\nend", "   local result\n\
    \   for i = 1, 10 do\n      local temp = math.floor(x/base)*base\n      x = x\
    \ - temp\n      if x ~= 0 then\n         result = temp .. result\n      end\n\
    \   end\n   return result\nend", "\t-- assert(base > 0 and base < 10)\n\tif x\
    \ > math.pow(10, base - 1) then\n\t\t-- Handle the most common case: x is too\
    \ large to be a number\n\t\treturn string.format('%d', x)\n\telse\n\t\treturn\
    \ math.floor(x * math.pow(10, base)) / math.pow(10, base)\n\tend\nend", "\tlocal\
    \ digits = tonumber(x)\n\tif not digits then\n\t\treturn x\n\tend\n\tlocal factor\n\
    \tif base <= 10 then\n\t\tfactor = math.pow(10, base)\n\telse\n\t\tfactor = math.pow(10,\
    \ 10 - base)\n\tend\n\treturn tostring(digits / factor) * factor\nend", "\tlocal\
    \ digits = base_digits(base)\n\tlocal base10 = (digits > 0 and digits(math.floor(x/digits))\
    \ or '')\n\t\n\tlocal base2 = math.floor(math.log(base10)/math.log(2))\n\t\n\t\
    if base10 == 0 and base2 == 0 then\n\t\treturn '0'\n\telseif base10 == 0 and base2\
    \ > 0 then\n\t\treturn '1'\n\telseif base10 > 0 and base2 == 0 then\n\t\treturn\
    \ base10\n\telseif base10 > 0 and base2 > 0 then\n\t\treturn change_base(base10,\
    \ 2)\n\telseif base2 < 2 then\n\t\treturn change_base(base10, base2)\n\telse\n\
    \t\tlocal power = math.floor(x/base2)\n\t\tx = x - power*base2\n\t\treturn change_base(x,\
    \ base2) .. base10\n\tend\nend", "  local factor = 1\n  local num_digits = math.floor(math.log(x)\
    \ / math.log(base))\n  for i = 0, num_digits - 1 do\n    factor = factor * base\n\
    \    x = x / factor\n  end\n  return x\nend", "  if x < base then\n    if x ~=\
    \ 0 then\n      x = \"0\" + x\n    end\n    return string.sub(x, -2, -1)\n  else\n\
    \    if base-1 < x and x > base then\n      x = string.sub(x, 1, -base-1)\n  \
    \  end\n    return x .. tostring(base)\n  end\nend", "    if base < 2 or base\
    \ > 36 then\n        return 'invalid base'\n    end\n    if x <= 0 then\n    \
    \    return 'x cannot be 0'\n    end\n    local s = ''\n    local i = 1\n    while\
    \ x > 0 do\n        if base - i < 0 then\n            return 'x cannot convert\
    \ to specified base'\n        end\n        local v = math.floor(x/base)*base+i\n\
    \        x = x%base\n        i = i-1\n        s = s .. string.format('%c', string.char(v))\n\
    \    end\n    if s == '' then\n        s = '0'\n    end\n    return s\nend\n</code>\n\
    <|/ a tags=lua,math,numbers dscore=3 |>\n<| c |>\nWhat happens when you try to\
    \ convert a number bigger than the numbers in your table?\n<|/ c |>\n<| a tags=lua,math,numbers\
    \ |>\nHere's another way:\n<code>", "   if base <= 0 then return '0' end\n   if\
    \ base > 10 then return '0' end\n   local digits = ''\n   while x >= base\n  \
    \ do\n      digits = to_char(x%base) + digits\n      x = x/base\n   end\n   if\
    \ x == 1 then return digits end\n   return digits .. to_char(x)\nend", "\tif base\
    \ < 2 then\n\t\treturn x\n\tend", "    if base > 10 then\n        print('Invalid\
    \ base.')\n        return\n    end\n    if base <= 0 then\n        print('Base\
    \ must be greater than 0.')\n        return\n    end\n    local digits = {}\n\
    \    for digit = 1, x do\n        table.insert(digits, string.format('0', base))\n\
    \    end\n    return table.concat(digits, '') .. x\nend", "  if x == 0 then return\
    \ \"0\" if base > 10 then return \"0\" .. base end\n  local res = tostring(x *\
    \ base)\n  return \"0\" .. res or res\nend", "\tlocal digits = math.floor((math.log(math.abs(x),\
    \ base))/math.log(2)) + 2\n\tif digits < 2 then\n\t\treturn '0'\n\tend\n\tlocal\
    \ s = ''\n\tlocal i = 1\n\twhile digits > i do\n\t\ts = table.concat(s, '0')\n\
    \t\ti = i + 1\n\tend\n\ts = table.concat(s, base):sub(1, digits-1)\n\ts = s ..\
    \ x\n\treturn s\nend", "  -- Convert 'x' from 'base 2' to 'base 10'.\n  -- The\
    \ 'base' parameter is a number less than 10.\n  -- Return converted string representation.\n\
    \  -- For base < 2, return '0'.\n  -- For base > 10, return '0'.\n  -- >>> change_base(3,\
    \ 10)\n  -- '3'\n  -- >>> change_base(8, 10)\n  -- '83'\n  if base > 10 or base\
    \ < 2 then\n    return '0'\n  end", "  -- TODO: This does not work for negative\
    \ numbers. Needs improvement.\n  return (x:gsub(\"%d*%d*\", function(x) return\
    \ string.format(\"%d\", (base * tonumber(x))) end):gsub(\"%d*\", function(x) return\
    \ string.format(\"%d\", (base * tonumber(x)))) .. \"0\")\nend", "    local ret\
    \ = \"\"\n    local b = 0\n    for i = 1, string.len(x) do\n        local x =\
    \ string.byte(x)\n        if x >= 48 and x <= 57 then\n            ret = ret *\
    \ base\n            ret = ret + x:sub(1, 1)\n            b = b + 1\n        elseif\
    \ x == 127 then\n            ret = ret * base\n            ret = ret + x:sub(1,\
    \ 1)\n        else\n            ret = ret * base\n            ret = ret + x:sub(1,\
    \ 1)\n            if b <= base then\n                b = b + 1\n            end\n\
    \        end\n    end\n    return ret\nend", "\t-- assert(x > 0 and base > 0)\n\
    \tassert(x <= 10 and base <= 10)", "\tlocal mult = 1\n\twhile x >= base do\n\t\
    \tx = x / base\n\t\tmult = mult*base\n\tend\n\tx = x*mult\n\tx = x+1\n\treturn\
    \ x\nend", "    -- base is the same as the numeral base\n    base = base or numerals()\n\
    \    -- We need an integer here to perform the change in base operation\n    x\
    \ = tonumber(x)\n    -- Convert the input number to a base 10 number\n    -- by\
    \ dividing by the input number's base raised to the power\n    -- of that base.\
    \  Note that we drop the remainder.\n    local num = x / tonumber(base[1])\n \
    \   -- If the number was greater than the base, then add one\n    -- at the end\n\
    \    if num > tonumber(base[1]) then\n        num = num + tonumber(base[1])\n\
    \    end\n    -- Perform the change in base.\n    -- We use integer division so\
    \ we can drop the remainder\n    -- at the end.  (Division with a remainder is\
    \ integer division.)\n    -- Multiplying by ten raised to the power of the input's\
    \ base\n    -- raised to the power of the new base\n    -- then divided by the\
    \ input base\n    num = tonumber(base[1]) * tonumber(base[2]) * num / tonumber(base[1])\n\
    \    -- And again by dividing by the new input base.\n    -- This is needed to\
    \ strip the leading zero.\n    return tonumber(base[1]) * num / tonumber(base[1])\n\
    end", "  if x <= 0 then\n    return '0'\n  end\n  local digits = math.huge\n \
    \ if x >= 1 then\n    while x > digits do\n      digits = digits * base\n    end\n\
    \  end\n  while x >= digits do\n    digits /= base\n  end\n  return tostring(x)..tostring(digits)\n\
    end", "\tif base == 1 then\n\t\treturn x\n\telseif base > 10 then\n\t\terror('base\
    \ should be less than 10')\n\tend\n\tif base < 1 then\n\t\tbase = 10\n\tend\n\t\
    local t = x\n\twhile t > 0 do\n\t\tt = t / base\n\tend\n\tif t == 0 then\n\t\t\
    return 0\n\tend\n\tt = 10 - base\n\tlocal ts = ''\n\twhile t >= 1 do\n\t\tts =\
    \ string.format('%d', t) + ts\n\t\tt = t - 1\n\tend\n\treturn ts + string.format('%d',\
    \ x)\nend", "  local s = tostring(x)\n  local digits = tonumber(s)\n  if digits\
    \ == nil then return s end\n  digits = digits - tonumber(floor((digits - 1) /\
    \ base))\n  return ((digits * base) + digits):reverse()\nend", "  x = tonumber(x)\n\
    \  if x < 10 then\n    return string.format(\"%di\", x)\n  else\n    return string.format(\"\
    %dx\", string.rep('0', base-x))\n  end\nend", "    local digits = math.floor(x/base)\n\
    \    return base * digits\nend", "    if x ~= nil then\n        if base < 2 then\n\
    \            return x\n        else\n            local base_to_num = { 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9,\n                                 10, 11, 12, 13, 14, 15,\
    \ 16, 17, 18, 19 }\n            local result = \"\"\n            if base <= 16\
    \ then\n                local digits = x / base\n                for i = 1, digits\
    \ do\n                    result = result .. base_to_num[base]\n             \
    \       x = x - base * base_to_num[base]\n                end\n            elseif\
    \ base > 16 then\n                local digits = x / base\n                for\
    \ i = 1, digits do\n                    local div = base / i\n               \
    \     local r = base_to_num[div]\n                    x = x - r * base_to_num[div]\n\
    \                    local remainder = x % i\n                    result = result\
    \ .. base_to_num[i]\n                    x = remainder\n                end\n\
    \            end\n            if x ~= nil then\n                result = result\
    \ .. base_to_num[x]\n            end\n            return result\n        end\n\
    \    else\n        return \"nil\"\n    end\nend", "\tlocal x_str = tostring(x)\n\
    \tif base < 10 then\n\t\treturn x_str:gsub(\"%d*2^%d\", \"%1*2^%d\"):gsub(\"%d*2^%d*2^%d\"\
    , \"%1*2^%d*2^%d\"):gsub(\"%d*2^%d*2^%d*2^%d\", \"%1*2^%d*2^%d*2^%d*2^%d\"):gsub(\"\
    %d*2^%d*2^%d*2^%d*2^%d\", \"%1*2^%d*2^%d*2^%d*2^%d*2^%d\"):gsub(\"%d*2^%d*2^%d*2^%d*2^%d*2^%d\"\
    , \"%1*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"):gsub(\"%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"\
    , \"%1*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"):gsub(\"%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"\
    , \"%1*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"):gsub(\"%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"\
    , \"%1*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"):gsub(\"%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"\
    , \"%1*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"):gsub(\"%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"\
    , \"%1*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\"):gsub(\"\
    %d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d*2^%d\", \"%1*2^%d*2^%d*2^%d*2^%d*2^",
  "    if x < 10 then\n        return x\n    elseif x == 0 then\n        return '0'\n\
    \    end\n    local m = math.floor(x/base)\n    return change_base(m * base, base):sub(#m\
    \ * base, '')\nend", "  if x > 10 then\n    error(\"base is out of range\")\n\
    \  end\n  local digits = math.floor(math.log(x, base))\n  local result = \"\"\n\
    \  local i = 0\n  while i < digits do\n    result = \"0123456789\"[base] * (x\
    \ - base * math.pow(base, i - digits)) + result\n    i = i + 1\n  end\n  return\
    \ result\nend", "  -- First we try to convert to integer. If that succeeds, we\
    \ do nothing.\n  -- If we fail, we try to convert from hexadecimal. If that fails,\
    \ we do nothing.\n  if tonumber(x) == x then\n    return x\n  end\n  if tonumber(x)\
    \ == nil then\n    if x:sub(1, 1) ~= 'x' then\n      return x\n    end\n  else\n\
    \    x = tonumber(x)\n  end\n  if tonumber(base) == nil then\n    return hex(x)\n\
    \  end\n  if tonumber(base) > 10 then\n    error(\"base must be less than 10.\"\
    , 2)\n  end\n  if tonumber(base) < 2 then\n    error(\"base must be greater than\
    \ or equal to 2.\", 2)\n  end\n  if base:sub(1, 1) == 'x' then\n    if tonumber(x)\
    \ == nil then\n      return hex(x)\n    else\n      x = tonumber(x)\n    end\n\
    \  end\n  local y = tonumber(base):byte(1, 1) + tonumber(x):byte(1, 1)\n  y =\
    \ base * 256 + y\n  return tonumber(y):reverse()\nend", "  local digits = \"\"\
    \n  while x >= base do\n    digits = base - x + digits and tostring(x - base)\
    \ or \"0\"\n    x = x / base\n  end\n  -- remove leading zeroes\n  digits = string.gsub(digits,\
    \ \"^0\", \"\")\n  -- add missing leading zeroes\n  if digits ~= \"\" and (string.len(digits)\
    \ < string.len(base)) then\n    digits = tostring(base) .. digits\n  end\n  return\
    \ digits\nend", "    if base == 10 then\n        return x\n    else\n        if\
    \ x < 10 then\n            return string \"0\" .. tostring(x)\n        else\n\
    \            if base <= 0 then\n                error( 'Base must be >= 0.')\n\
    \            else\n                local result = 0\n                local exp\
    \ = 0\n                while true do\n                    local a = math.floor(x/base)\n\
    \                    local b = x - a*base\n                    if a == 1 and b\
    \ == 0 then\n                        break\n                    elseif a == 0\
    \ then\n                        result = result .. string.format(\"%d\", b)\n\
    \                    else\n                        result = result .. string.format(\"\
    %d^%d\", a, b)\n                    end\n                    if exp == base then\n\
    \                        break\n                    end\n                    x\
    \ = b\n                    exp = exp + 1\n                end\n              \
    \  local pad = math.floor(math.log(x, base)/math.log(base))\n                if\
    \ pad ~= 0 then\n                    result = result .. string.format(\"%d^%d\"\
    , x, pad*base)\n                end\n                return result\n         \
    \   end\n        end\n    end\nend", "  if base < 2 then return nil end\n  if\
    \ base > 36 then return nil end\n  local function pad(s)\n    return s .. '0'\n\
    \  end\n  x = x % base\n  if x ~= 0 then\n    local r = pad(x)\n    return r ..\
    \ change_base(r + 1, base)\n  end\n  return '0'\nend", "\t-- if base is < 0 then\
    \ raise an error\n\t-- negative bases are not allowed\n\t-- if base is 0, then\
    \ use default base\n\tif base < 0 or base == 0 then\n\t\t-- convert a number in\
    \ base 'base' to a string in base 'base'\n\t\treturn string.format('%x', tonumber(x))\n\
    \telseif base < 10 then\n\t\t-- use base 10\n\t\treturn tostring(x)\n\telse\n\t\
    \t-- use base specified\n\t\treturn string.format('%d', tonumber(string.format('%x',\
    \ x)))\n\tend\nend", "\tlocal x_str = tostring(x)\n\tlocal x_base\n\tlocal x_len\
    \ = #x_str\n\tlocal i = 0\n\tlocal ret = ''\n\twhile i < x_len do\n\t\tlocal c\
    \ = x_str[i]\n\t\tif c == base then\n\t\t\tx_base = tostring(base * tonumber(x_str[(i\
    \ + 1):(x_len - 1)]))\n\t\t\tret = x_base..ret\n\t\t\ti = x_len\n\t\telse\n\t\t\
    \tret = c..ret\n\t\t\ti = i + 1\n\t\tend\n\tend\n\treturn ret\nend", "  if x >\
    \ 10 then return \"invalid input\" end\n  local s = \"\"\n  for i = 1, base-1\
    \ do\n    s = (x % base) + s\n    x /= base\n  end\n  x = (10-x) % 10 + x\n  return\
    \ x .. s\nend", "  if base < 10 then return x end\n  local t = {}\n  repeat\n\
    \    local digit = x % base\n    table.insert(t, digit)\n    x = x / base\n  until\
    \ x > 1\n  return table.concat(t, \"\")\nend", "  if base < 2 or base > 36 or\
    \ base == 2 then\n    error('base must be in range of 2..36')\n  end", "\t-- Check\
    \ base case.\n\tif not base or not base or base < 2 then\n\t\treturn x\n\tend\n\
    \t\n\t-- Convert decimal number to string.\n\tlocal s = tostring(x)\n\t\n\t--\
    \ Check if base is valid.\n\tif not base2number[base] then\n\t\terror(base.. '\
    \ is not a valid base')\n\tend\n\t\n\t-- Convert base to string.\n\tlocal n =\
    \ base2number[base]\n\t\n\t-- Convert string to number.\n\tlocal y = tonumber(s)\n\
    \t\n\t-- Convert to base 10.\n\ty = y * n + x\n\t\n\t-- Convert to string.\n\t\
    s = tostring(y)\n\t\n\t-- Replace the number after the decimal point.\n\tif s\
    \ == string.sub(s, 1, string.len('%.')) then\n\t\ts = string.sub(s, 1, string.len('%.')-1)\n\
    \telse\n\t\ts = s .. '.'\n\tend\n\t\n\treturn s\nend", "  local sign = 1\n  if\
    \ x ~= 0 then\n    if x < 0 then\n      x = x * -1\n      sign = -1\n    end\n\
    \    x = math.abs(x)\n  end\n  x = x * sign\n  local r = {}\n  local i = 0\n \
    \ while x > 0 and i < base do\n    r[i + 1] = x\n    x = math.floor(x/base)\n\
    \    i = i + 1\n  end\n  if i < base then\n    r[i + 1] = x\n  end\n  if sign\
    \ < 0 and r[1] ~= 0 then\n    r[1] = 1+sign * r[1]\n  end\n  if base == 16 then\n\
    \    return table.concat(unpack(r), \"\")\n  end\n  local result = \"\"\n  local\
    \ base_index = 1\n  while base_index <= #r do\n    local digit = math.floor(r[base_index]\
    \ * base_index)\n    result = result .. string.char(digit + 48)\n    base_index\
    \ = base_index + 1\n  end\n  return result\nend", '  local sign, digits, baseDigits,
    basePrefix, converted', "  x = tonumber(x)\n  base = tonumber(base) or 10\n  if\
    \ x < 1 or base < 2 then return end\n  local digits = math.rep(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    , base+1)\n  local digit = digits[base]\n  local num = \"\"\n  for i = math.abs(x),\
    \ 1, -1 do\n    num = num .. digit\n    local remain = i % base\n    if remain\
    \ == 0 then\n      num = num .. \"0\"\n      i = i / base\n    end\n  end\n  return\
    \ num\nend", "    if tonumber(x) == x then\n        x = tonumber(x)\n    elseif\
    \ x == nil then\n        return x\n    end\n    if x < 10 then\n        return\
    \ string.format('%d', tonumber(math.floor(x/base)))\n    elseif x >= 10 then\n\
    \        return string.format('%d', tonumber(math.ceil(x/base)))\n    end\nend",
  "    if x > 10 then\n        -- This doesn't work if x is negative.\n        error('Argument\
    \ must be less than 10')\n    end\n    if base < 2 then\n        error('Argument\
    \ must be greater than or equal to 2')\n    end\n    local ans = ''\n    for i\
    \ = 1, 10 do\n        local digit = math.floor(x * 1.0 / base) % base\n      \
    \  ans = ans .. tostring(digit)\n        x = x - digit * base\n    end\n    return\
    \ ans\nend", "\tlocal new_base = 10\n\twhile new_base <= base do\n\t\tnew_base\
    \ = new_base * 10\n\tend\n\tlocal s = tostring(x)\n\ts = string.gsub(s, \"^(-?%d+)\"\
    , string.rep(\"0\", new_base - base))\n\ts = string.gsub(s, \"%d+\", string.rep(\"\
    0\", base))\n\tx = tonumber(s)\n\treturn x\nend", "  local digits = tonumber(x)\n\
    \  local result = \"\"\n  local ndigits = base\n  while digits >= base do\n  \
    \  local quotient = digits % base\n    if ndigits > 1 then\n      local remainder\
    \ = digits % ndigits\n      result = base_digits[remainder] + result\n    end\n\
    \    digits = digits / base\n    ndigits = ndigits - 1\n  end\n  if ndigits >\
    \ 1 then\n    result = base_digits[ndigits] + result\n  end\n  if ndigits > 2\
    \ then\n    local remainder = digits % ndigits\n    result = base_digits[remainder]\
    \ + result\n  end\n  return result\nend", "   if base < 10 then\n      assert(base\
    \ >= 2, 'Base must be equal or greater than 10')\n      local s = ''\n      for\
    \ i = 1, base-1 do\n         s = s .. string.format('%0', x%base)\n         x\
    \ = math.floor(x/base)\n      end\n      return s\n   else\n      return string.format('%0',\
    \ x)\n   end\nend", "   assert(base >= 0)\n   assert(base <= 10)", "  local sign\
    \ = x < 0 and \"-\" or \"\"\n  local str = tostring(x)\n  local n = \"\"\n  local\
    \ factor = 1\n  if base > 10 then\n    base = math.pow(10, base)\n    factor =\
    \ base\n  end\n  while str ~= nil do\n    local digit = str:sub(1, 1)\n    str\
    \ = str:sub(2)\n    local i = base * digit\n    n = n .. string.format(\"%0\"\
    \ .. tostring(factor) .. \"d\", i / factor)\n    factor = factor % base\n  end\n\
    \  return sign .. n\nend", "    local s = string.gsub(x, \"^\", \"0\")\n    local\
    \ t = \"\"\n    for i = 1, #s do\n        local n = tonumber(s, i) or 0\n    \
    \    if (n > 0) then\n            t = t .. \"0\"\n        end\n        if n >\
    \ 1 then\n            t = t .. tostring(base*math.floor(n/base))\n        end\n\
    \    end\n    return t\nend", "  if x < 10 then\n    return tonumber(base * x)\
    \ or \"0\"\n  end\n  local digits = math.floor(math.log(math.abs(x) - 1, base))\n\
    \  if digits == 0 then\n    return \"0\"\n  end\n  local sign = x < 0 and \"-\"\
    \ or \"+\"\n  local digits = digits + 1\n  local str = sign\n  for i = 3, digits\
    \ do\n    if x % base == 0 then\n      return str..change_base(x / base, base)\n\
    \    end\n    str = str..\"0\"\n  end\n  return str..change_base(x / base, base)\n\
    end", "\tlocal digits = {}\n\tfor i = 0, 32 do\n\t\ttable.insert(digits, string.char(x\
    \ % base))\n\t\tx = math.floor(x/base)\n\tend\n\ttable.insert(digits, string.char(x))\n\
    \ttable.sort(digits)\n\treturn table.concat(digits, \"\")\nend", "    if x < 0\
    \ then\n        x = x + base\n    elseif x >= base then\n        return x\n  \
    \  else\n        local result = ''\n        while x > 0 do\n            local\
    \ digit = x % base\n            x = x / base\n            if x >= base then\n\
    \                result = digit .. result\n            else\n                result\
    \ = string.format('%d%s', digit, result)\n            end\n        end\n     \
    \   return result\n    end\nend", "    local str = x:sub(1, base-1)\n    if str\
    \ == \"\" then\n        str = base\n    else -- change to next base\n        if\
    \ str == base then -- already in the right base in base-2\n            str = str\
    \ + base\n        elseif str == \"\" and base > 1 then\n            str = base\n\
    \        else\n            str = str * base\n        end\n    end\n    return\
    \ str\nend", "\tif x == 0 then\n\t\treturn \"0\"\n\tend", "\t-- Based on https://stackoverflow.com/a/1804649/8140781\n\
    \tlocal ret = \"\"\n\tlocal num = x\n\tlocal factor = 1\n\t\n\t-- First convert\
    \ x to base 10, while multiplying by factor.\n\t-- To make sure we get the correct\
    \ number of digits, multiply x by factor until\n\t-- we get a number with as many\
    \ digits as base.\n\t-- For example,\n\t-- factor: 10\n\t-- x: 1\n\t-- num: 10\n\
    \t-- num: 100\n\t-- num: 1000\n\t-- num: 10000\n\t-- ...\n\t-- >>> change_base(10000,\
    \ 2)\n\t-- '10000'\n\t-- >>> change_base(10000, 3)\n\t-- '10000000'\n\t-- >>>\
    \ change_base(10000, 10)\n\t-- 4\n\trepeat\n\t\tif num > 1 then\n\t\t\tx = x /\
    \ factor\n\t\t\tnum = num * factor\n\t\telse\n\t\t\tbreak\n\t\tend\n\tuntil num\
    \ >= base", "   assert(x < 10)\n   assert(base >= 2)", "  local s = tostring(x)\n\
    \  assert(tonumber(s) == x, \"expected a number, got \" .. tostring(x))\n  assert(base\
    \ > 0, \"base must be a positive number\")\n  assert(base < 10, \"base cannot\
    \ be greater than 10\")\n  local factor = 1\n  while base > 1 do\n    if base\
    \ % 2 == 0 then\n      factor = 10\n      x = x / 2\n    else\n      x = x / 10\n\
    \    end\n    base = math.floor(base)\n    if factor == 10 then\n      factor\
    \ = 1\n    end\n  end\n  return tostring(x) * factor\nend", "  local s = tostring(x)\n\
    \  assert(tonumber(s), \"input is not a number\")\n  assert(base, \"argument 'base'\
    \ is nil\")\n  assert(base > 0, \"argument 'base' must be > 0\")\n  local bases\
    \ = {}\n  -- Base ten is easy, just add the digits\n  bases[10] = s\n  -- Base\
    \ other numbers are quite complicated by adding digits in reverse order\n  --\
    \ until we reach a number where the last digit of the sum is the same\n  -- as\
    \ the digit before it.\n  while #s < base do\n    local last = bases[#bases]\n\
    \    assert(last, \"last digit of the sum is 0\")\n    local s = last..s\n   \
    \ bases[#bases] = s\n  end\n  -- The final digit is easy\n  assert(#s >= base,\
    \ \"input number is not convertible to 'base' number\")\n  local last\n  -- Now\
    \ we have our digits in the right order, but we need to reverse them\n  -- in\
    \ order to find the rightmost digit.\n  local max\n  for i=#bases-1,0,-1 do\n\
    \    local s = bases[i]\n    local t\n    if tonumber(s) then\n      -- If it\
    \ looks like a number, use it\n      t = tonumber(s)\n      if t then\n      \
    \  -- If that worked, we can stop here\n        if max then\n          if t >\
    \ max then\n            max = t\n          end\n        else\n          max =\
    \ t\n        end\n      end\n    else\n      -- If it looks like a string, try\
    \ parsing it\n      local d = tonumber(s)\n      if d then\n        -- If that\
    \ worked, we can stop here\n        max = d\n      end\n    end\n  end\n  assert(max,\
    \ \"failed to find maximum\")\n  return bases[#bases-1]..\"0\"..tostring(max)\n\
    end", "  local res = x\n  base = base or 10\n  while res ~= 0 and base >= 1 do\n\
    \    res = base * res\n  end\n  if res < 0 then\n    return string \"0\", res\n\
    \  else\n    return string res, res\n  end\nend", "\tlocal t = tonumber(x)\n\t\
    if not t then\n\t\terror(\"wrong input type\")\n\tend\n\tif base < 2 then\n\t\t\
    error(\"wrong base type\")\n\tend\n\tif base == 10 then\n\t\treturn x\n\tend\n\
    \tlocal s = t.tostring()\n\tlocal t = t.tostring()\n\tlocal n = #s\n\tlocal p\
    \ = tonumber(s)\n\tif not p then\n\t\terror(\"wrong input type\")\n\tend\n\twhile\
    \ n > 0 do\n\t\tlocal m = ((n / base) + 1):floor()\n\t\tlocal c = ((p / base)\
    \ + 1):floor()\n\t\tlocal r = math.mod(tonumber(s), base)\n\t\tlocal u = r - c\n\
    \t\ts = string.sub(s,1,u+1)..tostring(math.floor((p - c) / base))..string.sub(s,u+1)\n\
    \t\tn = n - (m * base)\n\t\tp = tonumber(s)\n\t\tif not p then\n\t\t\terror(\"\
    wrong input type\")\n\t\tend\n\tend\n\treturn s\nend", "  if x >= base then\n\
    \    -- The base is greater than the given input.\n    return nil\n  end\n  local\
    \ digits = x:reverse()\n  local i = base\n  local result = \"\"\n  for _ in digits:gmatch(\"\
    %z+\") do\n    result = string.format(result .. \"%.\" .. (i - 2) .. \"d\", tonumber(digits))\n\
    \    i = i - 2\n  end\n  return result\nend", "  assert(base > 0 and base < 10)\n\
    \  local digits = math.floor(x/base) * base\n  x = x - digits % base\n  return\
    \ x\nend", "  if base < 0 then\n    error('base must be non-negative')\n  end\n\
    \  if base ~= 10 then\n    error('base must be 10')\n  end", "\tassert(x >= 0,\
    \ 'Negative number')\n\tassert(base > 0, 'Invalid base')\n\tif base == 10 then\n\
    \t\treturn tostring(x)\n\tend\n\tlocal ret = ''\n\twhile x > 0 do\n\t\tlocal mod\
    \ = x % base\n\t\tif mod == 0 then\n\t\t\tret = tostring(base):rep(mod - 1) +\
    \ ret\n\t\telse\n\t\t\tret = tostring(mod):rep(mod + 1) + ret\n\t\tend\n\t\tx\
    \ = x / base\n\tend\n\treturn ret\nend", "  if x ~= nil and x ~= '' then\n   \
    \ assert(base >= 0 and base <= 10, 'Base must be in range 0-10.')\n    local xx\
    \ = tonumber(x)\n    if base == 10 then\n      return xx ~= nil and tostring(xx)\
    \ or nil\n    else\n      local num = math.floor(xx / base) * base\n      local\
    \ remainder = mod(xx, base)\n      if remainder ~= 0 then\n        num = num +\
    \ string.format('%.' .. remainder .. 'f', math.floor(remainder / base) / base)\n\
    \      end\n      return tostring(num)\n    end\n  end\nend", "  -- return string\
    \ representation\n  local digits = math.floor(x * base^0)\n  return \"~\"..digits\
    \ .. \"^\"..base\nend", "    local sign = 1\n    if x then\n        sign = x and\
    \ 1 or -1\n        x = math.abs(x)\n    end\n    local xstr, xn = tostring(x),\
    \ '0'\n    local basestr, bn = tostring(base), '0'\n    local digits, b = string.rep(xn,\
    \ basestr), 0\n    if x > 0 then\n        while b <= base and digits ~= '0' do\n\
    \            digits, b = digits:sub(1, digits ~= '0') and digits:sub(2, digits\
    \ ~= '0') or digits ~= '0'\n        end\n    end\n    while b ~= 0 do\n      \
    \  digits, b = digits:sub(1, digits ~= '0') and digits:sub(2, digits ~= '0') or\
    \ digits ~= '0'\n    end\n    return string.format('%q', x:sign(sign) * tonumber(digits,\
    \ basestr))\nend", "  if base <= 1 then return \"~\" .. tostring(x) end\n  local\
    \ str = tostring(x)\n  if str == \"-\" then return \"0\" end\n  if str == \"+\"\
    \ then return \"1\" end\n  local last_digit = str:sub(-#str)\n  local digits,\
    \ rest = str:sub(1, -#str-1), str:sub(-#str)\n  if last_digit ~= \"\" then return\
    \ \"~\" .. digits .. tostring(base) end\n  local a = tonumber(digits)\n  if a\
    \ then\n    local b = tonumber(rest)\n    if b then\n      return base * a + b\n\
    \    else\n      return base * a -- handle non-numeric case.\n    end\n  else\n\
    \    return str\n  end\nend", "  if base < 2 then return '', x end\n  if base\
    \ < 10 then return string.rep(base..'0', x), x end\n  local t = {}\n  for i =\
    \ 1, x do\n    t[i] = math.floor(x/base)\n    x = (x - t[i]*base) * math.pow(10,\
    \ base-1)\n  end\n  return table.concat(t, base), x\nend", "  -- base < 0\n  if\
    \ base < 0 then\n    error(\"base must be positive\", 2)\n  end", "\t-- Base numbers\
    \ are less than 10.\n\tif base < 10 then\n\t\t-- Return error if base is out of\
    \ range.\n\t\treturn 'Error with base number.'\n\tend\n\t\n\t-- Return empty string\
    \ if base is 0.\n\tif base == 0 then\n\t\treturn ''\n\tend", "  local digits =\
    \ string.sub(x, 1, base-1)\n  local sign = string.sub(x, base-1, base)\n  if sign\
    \ == '-' then return '-' .. digits end\n  return digits .. '0'\nend", "    local\
    \ s = ''\n    local num = tonumber(x)\n    local power = 10\n    while num > 0\
    \ do\n        num = num / power\n        s = string.format('%0*d', base, num)\
    \ + s\n        power = power * base\n    end\n    return s\nend", "  assert(base\
    \ > 0 and base <= 10)\n  x = tonumber(x)\n  base = tonumber(base)\n  local digits\
    \ = {}\n  local i = 0\n  while x ~= 0 do\n    digits[i] = math.floor(x/base)\n\
    \    i = i + 1\n    x = x - digits[i]*base\n  end\n  local s = \"\"\n  if #digits\
    \ > 0 then\n    s = table.concat(digits, \"\", \".\")\n  end\n  if s ~= \"\" then\n\
    \    s = s .. \"0\"\n  end\n  if s == \"\" then\n    return \"\"\n  end\n  return\
    \ s\nend", "    if x == 0 then\n        return ''\n    end\n    if base == 0 then\n\
    \        return tostring(x)\n    end\n    local sign, digits, exponent = x:floor(),\
    \ x:tostring(), base\n    if exponent < 0 then\n        sign, digits, exponent\
    \ = sign, '-' .. digits, -exponent\n    end\n    local baseDigits = digits ..\
    \ '0'\n    local baseChar = string.sub(baseDigits, 1, 1)\n    -- if base < 10\
    \ then -- base can not be less than 10.\n    --     base = '10'\n    -- end\n\
    \    if baseChar ~= '0' then\n        digits = digits .. '0'\n        exponent\
    \ = exponent - 1\n    end\n    if sign == '-' then\n        digits = digits ..\
    \ '-'\n    end\n    local result = digits .. '^' .. exponent\n    return result\n\
    end", "\t-- check for valid input\n\tif x > 10 then\n\t\terror(\"base must be\
    \ less than 10\")\n\tend\n\tif base < 2 then\n\t\terror(\"base must be greater\
    \ than or equal to 2\")\n\tend", "  if x < 10 then\n    return base..x\n  end\n\
    \  local divisor = math.pow(base,math.floor(math.log(x,10)))\n  return change_base(x\
    \ / divisor, base)\nend", "    local s = tostring(x)\n    local digits = stringsplit(s,\
    \ \".\")\n    local digits_n = {}\n    local factor\n    for _, d in ipairs(digits)\
    \ do\n        factor = tonumber(d)\n        if factor ~= nil then\n          \
    \  digits_n[#digits_n + 1] = factor\n        else\n            digits_n[#digits_n\
    \ + 1] = 1\n        end\n    end", "    if x == nil or base == nil then\n    \
    \    return nil\n    end\n    if x < 10 then\n        return string.format(\"\
    %1$d\", x)\n    end\n    return string.format(\"%1$lx\", x)\nend", "  -- assert(type(x)\
    \ == 'number')\n  -- assert(type(base) == 'number')\n  local s = math.floor(x\
    \ * base) + ''\n  return base_table[base][s:byte()]\nend", "  local s = '',\n\
    \      i = 0,\n      len = #x,\n      rem = x / base;\n  while i < len do\n  \
    \  if rem < 10 then\n      s = s .. '0' .. rem;\n    elseif rem < 10 then\n  \
    \    s = s .. rem\n    else\n      s = s .. rem\n    end\n    rem = rem / base\n\
    \    i = i + 1\n  end\n  return s\nend", "   if base < 2 then\n      return nil\n\
    \   elseif base < 10 then\n      return string.format(\"%d\",x)\n   elseif base\
    \ == 10 then\n      return x\n   else\n      return change_base(x / base, base)\n\
    \   end\nend", "  if x >= base then return x end\n  local digits = math.floor(math.log(abs(x),\
    \ base))\n  if digits > 0 then\n    local factor = 1\n    for i = 1, digits do\n\
    \      factor = factor * base\n    end\n    local decimal_digits = digits - digits%2\n\
    \    x = x / factor\n  else\n    local factor = 1\n    local decimal_digits =\
    \ 1\n  end\n  x = math.floor(x)\n  local x_str = x:tostring()\n  if x_str == '0'\
    \ and decimal_digits > 0 then\n    x_str = tostring(base)\n    for i = decimal_digits,\
    \ 1, -1 do\n      x_str = x_str .. '0'\n    end\n  end\n  if x ~= x_str then\n\
    \    x_str = tostring(base)\n  end\n  return x_str\nend", "\tlocal s = ''\n\t\
    for i = 1, base.bit_size-1 do\n\t\ts = string.char(x % base) + s\n\t\tx = math.floor(x\
    \ / base)\n\tend\n\tlocal ret = s\n\tif x > 1 then\n\t\tret = string.format('%d%s',\
    \ x, ret)\n\tend\n\treturn ret\nend", "  if x < base then\n    return base * tonumber(string.format(\"\
    %0.0d\", x / base))\n  end\n  return tonumber(string.format(\"%0.0d\", x / base))\n\
    end", "  if x < 10 then\n    return x:gsub('%d', function()\n      return '0'..base\n\
    \    end)\n  end\n  return math.floor(x / base):reverse():gsub('%d', function()\n\
    \    return base:reverse()\n  end)\nend", "  local function to_base(n) return\
    \ math.floor(n/base) end\n  local function from_base(n) return n*base end\n  local\
    \ result = to_base(from_base(x))\n  return result\nend", "\tassert(base > 0 and\
    \ base < 11, \"Invalid base number\")\n\tlocal digits, i = math.floor(math.log10(x)),\
    \ -1\n\t-- If input is negative, subtract the absolute value of the input number.\n\
    \tif x < 0 then\n\t\tx = -x\n\t\tdigits, i = math.floor(math.log10(-x)), -1\n\t\
    end\n\tlocal factor = 10\n\twhile i > 0 do\n\t\tdigits = digits*factor + base\
    \ - i\n\t\ti = i - 1\n\t\tfactor = factor * 10\n\tend\n\t-- Add leading zeros.\n\
    \tx = x*10^digits\n\tlocal result = ''\n\twhile x > 0 do\n\t\tresult = string.format(\"\
    %d\", x % 10) + result\n\t\tx = math.floor(x / 10)\n\tend\n\treturn result\nend",
  "    if x < 10 then\n        return string.rep(base..x, string.len(base))\n    else\n\
    \        return string.rep(\"1..\", base-x)\n    end\nend", "  local digits =\
    \ {}\n  local factor = 1\n  \n  if base < 2 then\n    return \"Invalid base\"\n\
    \  end\n  \n  if base == 1 then\n    return tostring(x)\n  end\n  \n  repeat\n\
    \    if x >= base then\n      digits[#digits+1] = x / base\n      x = x % base\n\
    \    else\n      digits[#digits+1] = x\n      x = 1\n    end\n  until x == 0\n\
    \  \n  digits[#digits+1] = x / base\n  x = x % base\n  \n  local tmp\n  repeat\n\
    \    tmp = digits[#digits]\n    digits[#digits] = digits[#digits] * base\n   \
    \ digits[#digits+1] = digits[#digits] + tmp\n  until tmp == 0\n  \n  return table.concat(digits,\
    \ \"\")\nend", "  local digits = base^0\n  return string.format(\"%s%d\", x:gsub(\"\
    %d+\", function(d) return digits[digits[d]+1] or d end), x:gsub(\"%d+$\", function(d)\
    \ return digits[digits[d]:sub(1,-1)]+1\n  end)...)\nend", "  if x >= 10 then\n\
    \    local s = x\n    x = math.floor(x/base)\n    local digits = x:floor()\n \
    \   s = string.format('%0*d', digits, base)\n  else\n    s = string.format('%0*d',\
    \ x, base)\n  end\n  return s\nend", "  if base < 2 then return x\n  elseif base\
    \ == 2 then return tostring(x)\n  else return tonumber(x) * tonumber(base) end\n\
    end", "  local num_str = x:reverse()\n  local digits = ''\n  local i = 0\n  while\
    \ i < num_str:len() do\n    digits = digits .. num_str:sub(i, i)\n    i = i +\
    \ base\n    if i == num_str:len() then\n      break\n    end\n  end\n  num_str\
    \ = digits .. num_str:sub(i)\n  return num_str:reverse()\nend", "\tassert(base\
    \ >= 0, \"Base must be >= 0\")\n\tlocal basestring = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\tassert(basestring, \"Base string is empty\")\n\tlocal s = \"\"\n\twhile x\
    \ ~= 0 do\n\t\tlocal digit = math.floor(x/base)\n\t\tx = x - digit * base\n\t\t\
    s = basestring .. s\n\tend\n\ts = basestring .. s\n\treturn s\nend", "  if x <\
    \ 10 then\n    return to_base(x, base)\n  end\n  local s = \"\"\n  for i = 0,\
    \ 4 do\n    local p = i * base\n    if p > x then\n      break\n    end\n    s\
    \ = to_base(p % x, base)\n  end\n  return s\nend", "  -- return '0' + x .. '0'\n\
    \  return (x:gsub('%d%d*', function(x)\n    return string.sub(x:gsub('%d+', function(y)\n\
    \      return y .. string.sub(y, 1, base-1)\n    end), 1, base-1)\n  end):gsub('%d*',\
    \ function(y)\n    return y .. string.sub(y, base, 1)\n  end))\nend", "    if\
    \ x == 0 then\n        return '0'\n    else\n        local t = math.floor(x/base)\n\
    \        return base*t .. change_base(x - t*base, base)\n    end\nend", "  if\
    \ x ~= nil then\n    if tonumber(x) == nil then\n      print(\"Error in 'change_base':\
    \ input argument is not a number.\")\n      return nil\n    end\n    if tonumber(base)\
    \ == nil then\n      print(\"Error in 'change_base': input argument is not a number.\"\
    )\n      return nil\n    end\n    if tonumber(base) < 10 then\n      print(\"\
    Error in 'change_base': input argument 'base' is not numerical.\")\n      return\
    \ nil\n    end\n  else\n    print(\"Error in 'change_base': input argument not\
    \ provided.\")\n    return nil\n  end\n  local s = \"\"\n  -- Compute digits base\
    \ to 2.\n  local i = 0\n  while i < base * 2 and x <= 0 do\n    s = string.format(\"\
    %s%d\", s, tonumber(math.floor(tonumber(x / base)))) -- Use math.floor(x/base)\
    \ to ensure we get the correct digit.\n    x = x % base\n    i = i + 1\n  end\n\
    \  -- Compute digits base to base.\n  i = 0\n  while x < base and i >= 0 do\n\
    \    s = string.format(\"%s%d\", s, tonumber(math.floor(tonumber(x / base))))\
    \ -- Use math.floor(x/base) to ensure we get the correct digit.\n    x = x % base\n\
    \    i = i - 1\n  end\n  return s\nend", "  assert(x < 10)\n  assert(base < 10)\n\
    \  if x < 10 then\n    return tostring(base * x, base, '.')\n  else\n    return\
    \ tostring(x, base, '.')\n  end\nend", "  local sign = 1\n  local x = tonumber(x)\n\
    \  local base\n  if base == \"hex\" then\n    base = 16\n  elseif base == \"dec\"\
    \ then\n    base = 10\n  else\n    return nil, \"Base must be 'hex' or 'dec'\"\
    \n  end\n  local result\n  -- Handle negative numbers here.\n  if x > 0 and x\
    \ >= base then\n    -- Positive number.\n    result = x\n  else\n    -- Negative\
    \ number.\n    sign = -1 ^ sign\n    x = x ^ sign\n    -- Change sign bit to top\
    \ bit of x.\n    local top_bit = x % base\n    x = x ~= top_bit\n    -- Set up\
    \ binary representation.\n    local bin = \"\"\n    local i = 0\n    while x >=\
    \ base do\n      bin = string.format(\"%s%0*d\", bin, base, x)\n      x = x ~=\
    \ base\n      i = i + 1\n    end\n    bin = string.format(\"%s%0*d\", bin, i,\
    \ top_bit)\n    -- Clean up binary representation if negative.\n    if sign then\n\
    \      bin = string.format(\"%s%0*d\", bin, i, 1)\n    end\n    local num = tonumber(bin,\
    \ base)\n    -- Handle rounding.\n    local rounded = roundnum(num, base)\n  \
    \  if rounded == nil then\n      return nil, \"Number is not convertable in base\
    \ \" .. base\n    end\n    result = tonumber(rounded, base)\n  end\n  local sign\
    \ = sign * -1\n  result = string.format(\"%d\", result * sign)\n  if base == 16\
    \ then\n    result = string.gsub(result, \",\", \"\")\n  end\n  return result\n\
    end", "    if x <= 0 then\n        return '0';\n    end\n    if base < 2 then\n\
    \        return '0';\n    end\n    local t = math.floor(x/base);\n    if t <=\
    \ 1 then\n        return t * base;\n    else\n        return t * (base-1);\n \
    \   end\nend", "\tif x < 0 then\n\t\terror(\"negative number\", 2)\n\tend\n\t\
    if base < 2 then\n\t\terror(\"base must be 2 or more\", 2)\n\tend\n\tif base <\
    \ 10 then\n\t\tif base == 2 then\n\t\t\treturn tostring(x*x)\n\t\telse\n\t\t\t\
    return tostring(x/base) + tostring(x%base)\n\t\tend\n\tend\n\tlocal t = {\"\"\
    , \"\"}\n\tlocal m = math.floor(x/base)\n\tlocal r = x - m*base\n\tlocal g = base-1\n\
    \twhile g > 0 do\n\t\tt[#t+1] = tostring(m%g) + t[#t+1]\n\t\tm = m/g\n\t\tg =\
    \ g-1\n\tend\n\tt[#t+1] = tostring(r) + t[#t+1]\n\treturn table.concat(t, \"\"\
    )\nend", "  local s = x\n  while s >= 10 do\n    s, x = math.floor(x / base),\
    \ x - s * base\n  end\n  return s\nend", "  return tostring(math.floor(x/base)*base)+tostring(base^math.floor(math.log(x/base,\
    \ base)))\nend", "  -- find out if we're going to change base\n  if x < base or\
    \ base < 1 then\n    -- change the base\n    base = 10\n    -- get new base from\
    \ the user\n    while base <= 0 do\n      io.write(\n        '\\n\\n  Invalid\
    \ base!\\n  Please select a number between 1 and 9.\\n\\n',\n        'Press [ENTER]\
    \ to return to the menu.',\n      )\n      io.read()\n      -- get new base\n\
    \      base = io.read()\n    end\n  end\n  -- find the largest power of x we can\
    \ find such that\n  -- 10^n = x\n  local function smallest_power(x)\n    local\
    \ power = 1\n    while 10 ^ power > x do\n      power = power + 1\n    end\n \
    \   return power\n  end\n  -- return a new string representing x after changing\
    \ base\n  return string.format('%.' .. base .. 'd', x / (10 ^ smallest_power(base)))\n\
    end", "  -- TODO: use math.pow for increased efficiency\n  local str = x:gsub(\"\
    ^(-?%d+)\", function(a)\n    return (\"0\" .. ((base == 10 and a) or tostring(base\
    \ - math.floor(a))):sub(-base))\n  end)\n  if str == \"-\" then str = str else\
    \ str = str .. \"0\" end\n  return str\nend", "\tassert(type(x) == 'number')\n\
    \tassert(base >= 0 and base <= 10)\n\t\n\t-- convert to string and split into\
    \ array\n\tlocal str = string.format('%g', x)\n\tlocal arr = str == '0' and {}\
    \ or str:match('(.-)([1-9])+(.-)')\n\t\n\t-- change base\n\tlocal power = base\n\
    \tlocal result = arr[1]\n\twhile #result < power do\n\t\tlocal i = 1\n\t\twhile\
    \ i <= power do\n\t\t\tresult = result .. arr[i]\n\t\t\ti = i + 1\n\t\tend\n\t\
    \tpower = power - 1\n\tend\n\t\n\t-- return converted string\n\treturn result\n\
    end", "   if x < 10 then\n      return string.format('%0*d', base, x)\n   end\n\
    \   local s = ''\n   local i = 1\n   while x > 0 do\n      s, i = string.format('%s%d',\
    \ s, i), base\n      x = x / base\n   end\n   return s, i\nend", "  if base ==\
    \ 10 then return x:rep(base) end\n  if base < 10 then\n    local m = base\n  \
    \  local rest = x - base\n    while rest > m do\n      rest = rest - m\n     \
    \ m = m + 1\n    end\n    return change_base(rest, m) + x:sub(1, 1)\n  end\n \
    \ return ''\nend", "  if x < 10 then\n    return string_of(x)\n  end\n  base =\
    \ base or 0\n  local function conv(prefix, x, base)\n    local s = string_of(x)\n\
    \    if base < 10 then\n      s = prefix .. s .. string_rep(base + base_offset,\
    \ base - 10)\n    else\n      s = prefix .. s\n    end\n    return s\n  end\n\
    \  local function zero()\n    return conv(\"\", x, base)\n  end\n  local function\
    \ one()\n    return conv(\"\", x, base) or \"1\"\n  end\n  local function two()\n\
    \    return conv(\"\", x, base) or \"2\"\n  end\n  local function three()\n  \
    \  return conv(\"\", x, base) or \"3\"\n  end\n  local function four()\n    return\
    \ conv(\"\", x, base) or \"4\"\n  end\n  local function five()\n    return conv(\"\
    \", x, base) or \"5\"\n  end\n  local function six()\n    return conv(\"\", x,\
    \ base) or \"6\"\n  end\n  local function seven()\n    return conv(\"\", x, base)\
    \ or \"7\"\n  end\n  local function eight()\n    return conv(\"\", x, base) or\
    \ \"8\"\n  end\n  local function nine()\n    return conv(\"\", x, base) or \"\
    9\"\n  end\n  local function ten()\n    return conv(\"\", x, base) or \"10\"\n\
    \  end\n  local function eleven()\n    return conv(\"\", x, base) or \"11\"\n\
    \  end\n  local function twelve()\n    return conv(\"\", x, base) or \"12\"\n\
    \  end\n  local function thirteen()\n    return conv(\"\", x, base) or \"13\"\n\
    \  end\n  local function fourteen()\n    return conv(\"\", x, base) or \"14\"\n\
    \  end\n  local function fifteen()\n    return conv(\"\", x, base) or \"15\"\n\
    \  end\n  local function sixteen()\n    return conv(\"\", x, base) or \"16\"\n\
    \  end\n  local function seventeen()\n    return conv(\"\", x, base) or \"17\"\
    \n  end\n  local function eighteen()\n    return conv(\"\", x, base) or \"18\"\
    \n  end\n  local function nineteen()\n    return conv(\"\", x, base) or \"19\"\
    \n  end\n  local function twenty()\n    return conv(\"\", x, base) or \"20\"\n\
    \  end\n  local function twenty_one()\n    return conv(\"\", x, base) or \"21\"\
    \n  end\n  local function twenty_two()\n    return conv(\"\", x, base) or \"22\"\
    \n  end\n  local function twenty_three()\n    return conv(\"\", ", "\tlocal str={}\n\
    \tfor i=1,x do\n\t\ttable.insert(str,string.sub(tostring(x), math.mod(i, base)))\n\
    \tend\n\treturn table.concat(str)\nend", "  local r = tostring(x).\n    replace('#+$',\
    \ ''):reverse():gsub('%d%d%d?', function(digits, i, d)\n      local x = tonumber(d,\
    \ base)\n      local y = tonumber(digits or 0)\n      -- We accept strings or\
    \ numbers as long as they can be compared\n      -- lexicographically. This means\
    \ that '3' is less than '10'\n      -- and 'b' is less than 'a'.\n      -- To\
    \ prevent this, we can compare the strings starting at the\n      -- beginning.\n\
    \      if x > y and x > string.byte(d) then\n        digits = digits + string.byte(d)\n\
    \      else\n        digits = digits or string.byte(d)\n      end\n      if digits\
    \ > x and digits <= string.byte(d) then\n        digits = digits - x\n      else\n\
    \        digits = digits - string.byte(d)\n      end\n      return string.char(x+digits\
    \ or 0)\n    end)\n  return string.gsub(r, '^%s+', function(s)\n    return string.sub(s,\
    \ '^%s+', '')\n  end)\nend", "  -- Return string representation of x after conversion\
    \ to base base.\n  -- base numbers are less than 10.\n  -- >>> change_base(8,\
    \ 3)\n  -- '22'\n  -- >>> change_base(8, 2)\n  -- '1000'\n  -- >>> change_base(7,\
    \ 2)\n  -- '111'", "    local digits = \"0123456789ABCDEF\"\n    local factors\
    \ = base > 0 and \"0123456789ABCDEF\" or digits\n    local factors_length = #factors\n\
    \    local length = math.floor(math.log(x, base))\n    local result = \"\"\n \
    \   while x ~= 0 do\n        local digit = math.floor(x/base)\n        x = x -\
    \ digit*base\n        local digit = digits[digit]\n        result = factors[digit]*result\
    \ + digit\n        if length > 0 then\n            length = length - 1\n     \
    \   end\n    end\n    if length < 0 then\n        return result .. \"0\"\n   \
    \ else\n        return result\n    end\nend", "    local function to_base(number,\
    \ base)\n        return base * number -- convert number to base and return\n \
    \   end\n    local function from_base(number, base)\n        return number / base\
    \ -- divide number by base and return\n    end\n    local function to_string(number)\n\
    \        return string.format('%g', number)\n    end\n    local function to_strings(numbers)\n\
    \        local s = ''\n        for i = 1, #numbers do\n            s = s .. to_string(numbers[i])\n\
    \        end\n        return s\n    end\n    local function to_string(x, base)\n\
    \        return string.format('%g', from_base(x, base))\n    end\n    local function\
    \ to_strings(x)\n        return to_strings(x, 2)\n    end\n    local base = base\n\
    \    if base < 2 then -- check base is even or odd\n        local is_even = true\n\
    \        while base % 2 == 0 do -- base is even\n            is_even = false\n\
    \            base = base / 2\n        end\n        if base > 1 then -- base is\
    \ odd\n            if is_even then\n                base = -base\n           \
    \ else\n                base = -base + 1\n            end\n        end\n    end\n\
    \    if base == 2 then -- base of 2 can be represented with one integer number\n\
    \        local result = (x-1) * 3\n        if result < 0 then -- result is negative\n\
    \            result = -result\n            base = -1\n        end\n        if\
    \ result > 0x3FFF then\n            result = 0x3FFF\n        end\n        return\
    \ string.format('%d', result)\n    else\n        if base == 8 then -- base 8 can\
    \ be represented with two integers\n            local result = ((x-1) / 0x3) +\
    \ 0x3\n            if result < 0 then\n                result = -result\n    \
    \            base = -1\n            end\n            if result > 0xFF then\n \
    \               result = 0xFF\n            end\n            return string.format('%d%d',\
    \ from_base(result, base), from_base((x-1) % 0x3, base))\n        else\n     \
    \       local result = (x - 1) / to_base(base, base)\n            if result <\
    \ 0 then\n                result = -result\n                base = -1\n      \
    \      end\n            if result > 0x3FFF then\n                result = 0x3FFF\n\
    \            end\n            return string.format('%d%d', from_base(result, base),\
    \ from_base((x - 1) % to_base(base, base), base))\n        end\n    end\nend",
  "  return math.floor(x * base) / base\nend", "  if base:len() == 1 then\n    if\
    \ base > 10 then base = 10 + base end\n    if x < 0 then x = x + base\n    else\
    \ x = x - base end\n  end\n  \n  local digits = {}\n  while x > 0 do\n    digits[#digits\
    \ + 1] = x%base\n    x = math.floor(x/base)\n  end\n  \n  return table.concat(digits,\
    \ '') .. '0'\nend", "  -- The below is borrowed from the python implementation:\n\
    \  -- http://svn.python.org/view/python/trunk/Objects/longobject.c?view=markup\n\
    \  local sign, digits, exponent = math.abs(x), digits(x), exponent(math.floor(x/base))\n\
    \  if sign == 1 then\n    return '0' -- no sign for zero\n  elseif x == '0' then\n\
    \    return 0 -- no sign for zero\n  end\n  local power = math.pow(base, exponent)\n\
    \  if digits < exponent + 3 then\n    return base * power -- no zero or sign for\
    \ less than base\n  elseif exponent < 0 then\n    return '0' -- no sign for negative\
    \ exponent\n  end\n  return base * power -- no zero or sign for exponent < base\n\
    end", "    local sx = tostring(x)\n    if sx:sub(1,1) == '-' then\n        sx\
    \ = sx:sub(2)\n    end\n    local base = tonumber(base)\n    if base == 0 then\n\
    \        error(string.format(\"invalid base %s requested\", base))\n    end\n\
    \    local r = \"\"\n    if sx:sub(1,1) == \".\" then\n        local s, v = string.match(sx,\
    \ \".(%d+)\"..\"%a\")\n        if s == nil or not tonumber(s) then\n         \
    \   error(string.format(\"invalid number %s requested\", sx))\n        end\n \
    \       local n = tonumber(s)\n        if n > base then\n            error(string.format(\"\
    %s not in base %s\", s, base))\n        end\n        r = (string.sub(v, -base+1,\
    \ -n)..\"0\"..string.sub(v,-base))\n    else\n        local s, v = string.match(sx,\
    \ \"(%d+)%s\"..\"%a\")\n        if s == nil or not tonumber(s) then\n        \
    \    error(string.format(\"invalid number %s requested\", sx))\n        end\n\
    \        local n = tonumber(s)\n        if n >= base then\n            error(string.format(\"\
    %s not in base %s\", s, base))\n        end\n        r = (string.sub(v, -base+1,\
    \ n)..\"0\"..string.sub(v,1,base-1))\n    end\n    return r\nend", "  if base\
    \ == 10 then\n    return x:reverse()\n  end\n  local result = x\n  local i = 0\n\
    \  for i = #result + 1, 10 do\n    local temp = result\n    result = string.format('%s%s',\
    \ result, base == 2 and '-' or nil)\n    local j = math.floor(temp / base)\n \
    \   result = string.format('%s%s%s', string.format('%s%d', result, j), base ==\
    \ 2 and '.' or nil, base == 2 and '0' or nil)\n  end\n  return result:reverse()\n\
    end", "    if x < 10 then\n        return string.format(\"%g\", math.floor(x *\
    \ math.pow(base, -1)))\n    elseif x < 0 then\n        return string.format(\"\
    %g\", math.floor(x * math.pow(base, -1)))\n    elseif x == 0 then\n        return\
    \ string.format(\"%g\", 0)\n    else\n        if base == 0 then\n            return\
    \ \"0\"\n        else\n            return string.format(\"%g\", math.floor(x /\
    \ math.pow(base, -1)))\n        end\n    end\nend", "\tlocal s = string.format(\"\
    %0\".. tostring(base) ..\"d\", x)\n\treturn s:sub(1, -#s)\nend", "    if x <=\
    \ 10 then\n        return string.format('%g', x:float(base))\n    end\n    return\
    \ string.format('%d', x:int(base))\nend", "    if x < 10 then\n        return\
    \ tostring(x)\n    else\n        return tostring(math.floor(x/base)*base) + tostring(x%base)\n\
    \    end\nend", "  if x < 10 then\n    if base < 0 then\n      base = 10 + base\n\
    \    end\n    return tostring(x * base)\n  else\n    -- Base 10 case.\n    local\
    \ digits = ''\n    if base > 1 then\n      for digit = 1, base do\n        digits\
    \ = digits .. tostring('9')\n      end\n    end\n    local result = digits ..\
    \ tostring(x)\n    -- Handle negative bases.\n    if base < 0 and x > 0 then\n\
    \      -- Negative base case.\n      local prefix = tostring(-x)\n      if base\
    \ > 10 then\n        -- Handle negative numbers greater than base 10.\n      \
    \  local negative, negative_base = div(x, base)\n        if negative == 0 then\n\
    \          -- Handle negative zeros here.\n          result = '-'\n        else\n\
    \          -- Handle negative numbers.\n          result = '-' .. change_base(negative,\
    \ negative_base)\n        end\n      else\n        -- Handle negative numbers\
    \ less than base 10.\n        result = '-' .. prefix\n      end\n    else\n  \
    \    -- Positive base case.\n    end\n    if base >= 10 then\n      -- Base 10\
    \ case.\n      if result == '-' then\n        result = nil\n      else\n     \
    \   result = digits .. result\n      end\n    else\n      -- Base 2 case.\n  \
    \    if result == '-' then\n        result = nil\n      else\n        result =\
    \ digits .. result\n      end\n    end\n    return result\n  end\nend", "   if\
    \ base < 1 or base > 10 then return end\n   x = tonumber(x)\n   if not x then\
    \ return end\n   if base < 16 then x = x * 2\n   else x = x / 16\n   end\n   if\
    \ x < 10 then return string.format(\"%1.\" .. (base-1) .. \"d\", x)\n   end\n\
    \   return string.format(\"%0.\" .. (base - 1) .. \"x\", x)\nend", "   if base\
    \ <= 0 then return nil end\n   local tb, ix = type(x), x\n   if tb == 'number'\
    \ then\n      if base < 10 then return nil end\n      if x < 0 then return nil\
    \ end\n      local sb = tostring(base)\n      return string.reverse(sb):sub(1,\
    \ (sb:len() - 1) * (base - 1))\n   end\n   return change_base(ix, base)\nend",
  "    if base < 0 or base > 10 then\n        return nil, \"Base must be between 0\
    \ and 10.\"\n    end\n    if base == 0 then\n        return x\n    end\n    if\
    \ x < base then\n        return nil, \"Invalid input: Base must be less than the\
    \ input\"\n    end\n    local output = {}\n    local digits = 1\n    while x >\
    \ 0 do\n        table.insert(output, math.floor(x/base))\n        x = x%base\n\
    \    end\n    table.insert(output, digits)\n    return output\nend", "\tif x <\
    \ 10 then\n\t\treturn tostring(x)\n\telse\n\t\tlocal tmp = tostring(x)\n\t\ttmp\
    \ = string.sub(base * tmp, -1, -1)\n\t\treturn tmp\n\tend\nend", "  local s =\
    \ string.rep('0', base-1)\n  for i = 1, base-1 do\n    s = string.format('%s%d',\
    \ s, x:mod(base))\n    x = x:div(base)\n  end\n  return s\nend", "\tlocal r =\
    \ math.floor(x/base)*base\n\treturn tostring(r) .. tostring(base-x%base)\nend",
  "  if base <= 0 then\n    assert(false, \"base must be positive\")\n    return \"\
    0\"\n  end\n  local x_str = tonumber(x)\n  if x_str == x then\n    return \"0\"\
    \n  elseif x_str == 0 then\n    return tostring(base)\n  elseif x_str == 1 then\n\
    \    return tostring(base * 10)\n  elseif x_str / 10 == x then\n    local n =\
    \ tonumber(x / base)\n    return tostring(base * n)\n  else\n    assert(false,\
    \ \"x must be an integer\")\n  end\nend", "    local digits = math.floor(math.log(base\
    \ * x + 1, base))\n    return tonumber(string.format('%.' .. digits .. 'u', x\
    \ / base))\nend", "\tif base:byte() >= 10 then\n\t\tassert(x < 2^31)\n\t\tlocal\
    \ t = math.floor(x/base)\n\t\treturn t .. string.sub(string.rep('0', base-t%base+1),\
    \ 1, base-1)\n\telse\n\t\treturn string.format('%x', x)\n\tend\nend", "  local\
    \ old_base = tonumber(x)\n  local new_base = tonumber(base)\n  if old_base and\
    \ new_base then\n    local mult = old_base ^ new_base\n    if mult <= 10 then\n\
    \      x = x ^ new_base\n      x = string.format(\"%d\", x)\n    else\n      x\
    \ = x ^ mult\n      x = string.format(\"%d%s\", x, string.rep('0', new_base-mult))\n\
    \    end\n  end\n  return x\nend", "  local y = tonumber(x)\n  if y <= 0 then\n\
    \    return \"0\"\n  end", "  local bases = [{\n    digits = '0123456789',\n \
    \   prefix = '0',\n  }]\n  for b = 2, base do\n    table.remove(bases)\n    bases.insert({\n\
    \      digits = '0123456789',\n      prefix = tostring(b - 1),\n    })\n  end\n\
    \  local ret = ''\n  for _, base in ipairs(bases) do\n    local digits = x:to_string(base)\n\
    \    if digits == '0' then\n      return ret\n    end\n    local ret = ret * base\
    \ + digits\n  end\n  return ret\nend", "    if x ~= 0 then\n        local a =\
    \ x\n        while a ~= 0 do\n            local d = a % base\n            local\
    \ r = base\n            local i = 1\n            while r > 0 and i < d do\n  \
    \              r = r // base\n                i = i + 1\n            end\n   \
    \         if i >= d then return x end\n            local t = base\n          \
    \  base = a\n            a = t\n        end\n    end\nend", "  assert(type(base)\
    \ ~= 'number')\n  assert(base > 0 and base <= 10)\n  assert(x > 0)\n  local res\
    \ = {}\n  local div = math.pow(base, 2)\n  while x >= div or x == 0 do\n    x\
    \ = x / base\n    table.insert(res, x)\n  end\n  return table.concat(res, '^'\
    \ .. base)\nend", "    if x < 10 then\n        return x\n    end\n    return string.format('%1$0%d',\
    \ x, base) -- pad numbers with leading zeros.\nend\n</cell>\n<cell>", "  assert(base\
    \ >= 2 and base <= 36, \"Base must be in range [2, 36]\")\n  assert(x > 0, \"\
    Base must be positive\")\n  assert(base < 36, \"Base must be < 36\")\n  local\
    \ str = \"\"\n  while x do\n    local digits = math.floor(x/base)\n    str = string.format(\"\
    %d%s\", digits, str)\n    x = x - base*digits\n  end\n  return str\nend", "  if\
    \ x < 10 then\n    return tostring(x)\n  end\n  if base == 2 then\n    return\
    \ '0'\n  end\n  local digits = math.floor(math.log(x) / math.log(base))\n  local\
    \ offset = digits * base\n  return tostring(x - offset)\nend", "  -- Handle edge\
    \ cases for negative numbers and base 0.\n  if x < 0 then\n    x = x * -1\n  \
    \  if base = 0 then return '-' + change_base(x, 1) end\n  end\n  if x < 10 then\n\
    \    return x\n  end\n  -- Convert input to a positive number in base 10.\n  x\
    \ = 10 * x\n  if base > 0 then\n    -- Handle negative bases.\n    if base < x\
    \ and x % base > 0 then\n      x = x / base\n      base = base * -1\n    end\n\
    \    -- Use string manipulation to reverse digits.\n    -- A more efficient implementation\
    \ would be to convert to a\n    -- string and reverse it but this might be sufficient\
    \ for now.\n    x = math.floor(x) / base\n    local s = ''\n    while x > 0 do\n\
    \      s = string.format('%s%d', s, x)\n      x = x / base\n    end\n    -- Add\
    \ sign at the end.\n    s = '-'..change_base(math.abs(x), base) .. s\n  else\n\
    \    -- Use string manipulation to reverse digits.\n    -- A more efficient implementation\
    \ would be to convert to a\n    -- string and reverse it but this might be sufficient\
    \ for now.\n    local s = ''\n    while x > 0 do\n      s = string.format('%s%d',\
    \ s, math.floor(x) % base)\n      x = math.floor(x) / base\n    end\n    -- Add\
    \ sign at the end.\n    s = '-'..change_base(math.abs(x), base) .. s\n  end\n\
    \  -- Convert back to a number.\n  return tonumber(s)\nend", "   assert(x >= 0\
    \ and base >= 0 and base <= 10)\n   local t = math.floor(x/math.pow(base,1))\n\
    \   return tonumber(string.format(\"%0*d\", base, t)):reverse()\nend", "    if\
    \ x < 10 then\n        return tostring(base):reverse():sub(1, base):reverse():sub(1,\
    \ base):reverse():sub(1)\n    elseif x == 10 then\n        return '0'\n    else\n\
    \        if x%10 == 0 then\n            return change_base(x/10, base):reverse():sub(1)\n\
    \        else\n            return change_base(x/10, base):reverse():sub(1, base):reverse():sub(1)\n\
    \        end\n    end\nend", "\tif x < 10 then\n\t\treturn string.format(\"%u\"\
    , math.floor(x/base))\n\telse\n\t\treturn x\n\tend\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
