name: HumanEval_153_Strongest_Extension
language: lua
prompt: "-- You will be given the name of a class (a string) and a list of extensions.\n\
  -- The extensions are to be used to load additional classes to the class. The\n\
  -- strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  -- letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n-- in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n-- You should find the strongest extension and return a string in this \n--\
  \ format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions\
  \ with the same strength, you should\n-- choose the one that comes first in the\
  \ list.\n-- For example, if you are given \"Slices\" as the class and a list of\
  \ the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n--\
  \ return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n-- (its strength is -1).\n-- Example:\n-- for Strongest_Extension('my_class',\
  \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nlocal function Strongest_Extension(class_name,\
  \ extensions)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = Strongest_Extension\n\
  \    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')\n\
  \    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}),\
  \ 'Boku123.YEs.WeCaNe')\n    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY',\
  \ 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')\n    lu.assertEquals(candidate('K',\
  \ {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')\n    lu.assertEquals(candidate('__HAHA',\
  \ {'Tab', '123', '781345', '-_-'}), '__HAHA.123')\n    lu.assertEquals(candidate('YameRore',\
  \ {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')\n\
  \    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')\n\
  \    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')\n    lu.assertEquals(candidate('Sp',\
  \ {'671235', 'Bb'}), 'Sp.671235')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local strongest = {}\n    for i = 1, #extensions do\n        local\
    \ cap = string.upper(extensions[i])\n        local sm = string.lower(extensions[i])\n\
    \        if cap-sm ~= 0 then\n            strongest[extensions[i]] = -(cap-sm)\n\
    \        end\n    end\n    local sorted_extensions = table.sort(strongest, function(a,\
    \ b) return a > b end)\n    return class_name .. sorted_extensions[1]\nend", " \
    \ if #extensions == 0 then\n    return nil\n  elseif #extensions == 1 then\n \
    \   return extensions.[0]\n  else\n    local max_str = ''\n    local max_index\
    \ = -1\n    local i = 0\n    for i = 1, #extensions do\n      local strongest\
    \ = extensions.[i]\n      local index = #strongest - 1\n      local caps = string.format('%%%%s',\
    \ index:lower():upper())\n      local sm = string.format('%%%%s', caps:lower())\n\
    \      local frac = string.format('%.*f', caps - sm, caps - caps)\n      if frac\
    \ > 1.0 then\n        frac = 1.0\n      elseif frac < -1.0 then\n        frac\
    \ = -1.0\n      end\n      if frac > max_str then\n        max_str = strongest\n\
    \        max_index = index\n      end\n    end\n    return max_str .. '.' .. class_name\
    \ .. extensions[max_index]\n  end\nend", "   \n   -- Your code here\n   local\
    \ strongest_extension = extensions[1]\n   local strength = 1\n   for i = 2, #extensions\
    \ do\n       local cap = string.upper(extensions[i])\n       local sm = string.lower(extensions[i])\n\
    \       local strength_delta = math.abs(cap-sm)\n       if strength_delta > strength\
    \ then\n           strongest_extension = extensions[i]\n           strength =\
    \ strength_delta\n       end\n   end\n   return class_name .. '.' .. strongest_extension\n\
    end\n</cell>\n<text>\n(3a) Load and Run the Classifier\nTo test your implementation\
    \ you should write unit tests that load your model, your dataset, and your test\
    \ dataset.", "   -- Write your code here\n   return class_name\nend", "    local\
    \ max\n    local max_index\n    for index, extension in ipairs(extensions) do\n\
    \        local ext\n        ext = extension:gsub(\"%W\", \"\"):upper()\n     \
    \   if max and max > ext:match(\"%W\"):upper() then\n            max = ext:match(\"\
    %W\"):upper()\n            max_index = index\n        end\n    end", "   if #extensions\
    \ == 1 then\n      return class_name .. '.' .. extensions[1]\n   end\n   local\
    \ strongest = {}\n   local max = 0\n   for i=1, #extensions do\n      local str\
    \ = class_name .. '.' .. extensions[i]\n      if max == 0 then\n         max =\
    \ 1\n      end\n      if max > #str then\n         max = #str\n      end\n   \
    \   table.insert(strongest, str)\n   end\n   local min = #extensions - 1\n   for\
    \ i=1, #extensions do\n      local str = class_name .. '.' .. extensions[i]\n\
    \      if min > #str then\n         min = #str\n      end\n   end\n   return strongest[math.min(max,\
    \ min)]\nend", "  local caps_total = 0\n  local caps_count = 0\n  local caps_last\
    \ = 0\n  local sms_total = 0\n  local sms_count = 0\n  local sms_last = 0\n  for\
    \ _, extension in ipairs(extensions) do\n    local caps = string.upper(extension):sub(1,1)\n\
    \    local sms = string.lower(extension):sub(1,1)\n    local caps_new = (caps\
    \ - caps_last)*100/caps_last\n    local sms_new = (sms - sms_last)*100/sms_last\n\
    \    caps_total = caps_total + caps_new\n    caps_count = caps_count + 1\n   \
    \ caps_last = caps\n    sms_total = sms_total + sms_new\n    sms_count = sms_count\
    \ + 1\n    sms_last = sms\n  end", "  -- Only works for letters A-Z.\n  local\
    \ upper = 0\n  local lower = 0\n  for _, extension in ipairs(extensions) do\n\
    \    local cap, sm = string.match(extension, '%w[%C%]') \n    upper = upper +\
    \ cap - sm\n    lower = lower + sm\n  end\n  return class_name .. '.' .. table.concat(extensions,\
    \ '')\nend", "\t-- Write your code here.\n\tlocal max_strength = -1\n\tlocal max_extension\
    \ = nil\n\tfor _, extension in ipairs(extensions) do\n\t\tlocal cap = string.upper(extension)\n\
    \t\tlocal sm = string.lower(extension)\n\t\tif cap:len() > sm then\n\t\t\tlocal\
    \ strength = cap:len() - sm\n\t\t\tif strength > max_strength then\n\t\t\t\tmax_strength\
    \ = strength\n\t\t\t\tmax_extension = extension\n\t\t\tend\n\t\telseif cap ==\
    \ sm then\n\t\t\tlocal strength = cap:len()\n\t\t\tif strength > max_strength\
    \ then\n\t\t\t\tmax_strength = strength\n\t\t\t\tmax_extension = extension\n\t\
    \t\tend\n\t\tend\n\tend\n\treturn \"string.\" .. class_name .. \".\" .. max_extension\n\
    end", "    assert(type(extensions) == 'table')\n    assert(#extensions > 0)\n\
    \    for i = 1, #extensions do\n        local extension_upper = uppercase(extensions[i])\n\
    \        local extension_lower = lowercase(extensions[i])\n        if extension_upper\
    \ == extension_lower then\n            if extension_upper ~= extension_lower[1]\
    \ then\n                return nil\n            end\n        elseif extension_upper\
    \ < extension_lower[1] then\n            return nil\n        else\n          \
    \  return class_name .. '.' .. extensions[i]\n        end\n    end\nend", "  \
    \ assert(class_name ~= nil, 'class_name should not be nil')\n   assert(extensions\
    \ ~= nil, 'extensions should not be nil')\n   \n   local max_strength = -1\n \
    \  local min_strength = math.min(#extensions)\n   local extension = nil\n   \n\
    \   for i = min_strength, #extensions do\n      local cap = string.upper(class_name[i])\n\
    \      local sm = string.lower(class_name[i])\n      local strength = cap - sm\n\
    \      \n      if strength > max_strength then\n         max_strength = strength\n\
    \         extension = extensions[i]\n      end\n   end\n   \n   return extension\n\
    end\n</cell>\n<text>\nPart III: Extension Management", "    local strongest_extension\
    \ = nil\n    local strongest_extension_strength = -1\n    local current_extension\
    \ = nil\n    local current_strength = -1\n    local counter = 0", "    assert(type(class_name)\
    \ == 'string')\n    assert(#extensions > 0)\n    local strong_extensions = {}\n\
    \    for _, extension_name in ipairs(extensions) do\n        local extension =\
    \ Extension(extension_name)\n        if extension:HasStrength() then\n       \
    \     table.insert(strong_extensions, extension_name)\n        end\n    end\n\
    \    local max_strength = -1\n    local max_extension = ''\n    for _, extension_name\
    \ in ipairs(strong_extensions) do\n        local extension = Extension(extension_name)\n\
    \        local strength = extension:GetStrength()\n        if strength > max_strength\
    \ then\n            max_strength = strength\n            max_extension = extension_name\n\
    \        end\n    end\n    return class_name .. '.' .. max_extension\nend", " \
    \ local strongest_extension = nil\n  local extension_strength = -1\n  for _, extension\
    \ in pairs(extensions) do\n    local cap = string.upper(extension:sub(1, #extension))\n\
    \    local sm = string.lower(extension:sub((#extension) + 1, #extension))\n  \
    \  local cap_count = table.remove({[cap]:gsub(\"%W\", \"\"):gsub(\"[^\"..cap..\"\
    ]\", \"\")}, \"\")\n    local sm_count = table.remove({[sm]:gsub(\"%W\", \"\"\
    ):gsub(\"[^\"..sm..\"]\", \"\")}, \"\")\n    local cap_sub = string.sub(cap, 1,\
    \ #cap - 1)\n    local sm_sub = string.sub(sm , 1, #sm - 1)\n    local strength\
    \ = cap_count - sm_count\n    if strength > 0 then\n      if extension_strength\
    \ == -1 then\n        extension_strength = strength\n      else\n        if extension_strength\
    \ > strength then\n          extension_strength = strength\n        end\n    \
    \  end\n    end\n  end\n  if extension_strength == -1 then\n    return class_name\n\
    \  else\n    return string.sub(class_name, 1, #class_name - (#extension_strength\
    \ + 2))\n  end\nend", "\tlocal max_extension_strength = -1 -- Initialize to min\n\
    \tlocal max_extension_name = ''", "  assert(type(class_name) == 'string', 'class_name\
    \ must be a string.')\n  assert(type(extensions) == 'table', 'extensions must\
    \ be a table.')\n  \n  local max_strength = -1\n  local max_name = ''\n  \n  for\
    \ _, extension_name in ipairs(extensions) do\n    assert(type(extension_name)\
    \ == 'string', 'extension name must be a string.')\n    local extension_cap =\
    \ string.upper(extension_name:sub(1, #extension_name))\n    local extension_sm\
    \  = #extension_name - extension_cap + 1\n    local extension_strength = extension_cap\
    \ - extension_sm\n    \n    if extension_strength > max_strength then\n      max_strength\
    \ = extension_strength\n      max_name = extension_name\n    end\n  end\n  \n\
    \  return class_name .. '.' .. max_name\nend\n</textarea></form>", "\tlocal strength\
    \ = nil\n\tlocal max = 0\n\tlocal ext = nil\n\tfor _,e in ipairs(extensions) do\n\
    \t\tlocal c = string.match(class_name, \"%W(%a+)\")\n\t\tif c then\n\t\t\tlocal\
    \ sm = string.match(c, \"%W(%a+)\")\n\t\t\tif sm:sub(1, 1) == sm:sub(1, 1) then\n\
    \t\t\t\tlocal ca, cb = string.match(c, \"%W(%a%a+)\")\n\t\t\t\tif sm:sub(1, 1)\
    \ == sm:sub(1, 1) then\n\t\t\t\t\tlocal ca, cb = string.match(c, \"%W(%a%a%a+)\"\
    )\n\t\t\t\t\tlocal sc = (ca-cb)/(cb-ca)\n\t\t\t\t\tif sc > strength then\n\t\t\
    \t\t\t\tstrength = sc\n\t\t\t\t\t\tmax = sc\n\t\t\t\t\t\text = c\n\t\t\t\t\tend\n\
    \t\t\t\telse\n\t\t\t\t\tlocal ca, cb = string.match(c, \"%W(%a%a%a%a+)\")\n\t\t\
    \t\t\tlocal sc = (ca-cb)/(cb-ca)\n\t\t\t\t\tif sc > strength then\n\t\t\t\t\t\t\
    strength = sc\n\t\t\t\t\t\tmax = sc\n\t\t\t\t\t\text = c\n\t\t\t\t\tend\n\t\t\t\
    \tend\n\t\t\telse\n\t\t\t\tlocal ca, cb = string.match(c, \"%W(%a%a%a%a%a+)\"\
    )\n\t\t\t\tlocal sc = (ca-cb)/(cb-ca)\n\t\t\t\tif sc > strength then\n\t\t\t\t\
    \tstrength = sc\n\t\t\t\t\tmax = sc\n\t\t\t\t\text = c\n\t\t\t\tend\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn string.gsub(class_name, \"^%W\", \"%1\".. ext .. \".\"\
    )\nend", "\tlocal strongest_extension = {}\n\tlocal max_extension_strength = -1\n\
    \tfor _, extension in pairs(extensions) do\n\t\tif string.match(extension, \"\
    ^%s*%%(%d+):(.-?)$\")\n\t\t\tand tonumber(string.sub(extension, 2))\n\t\t\t< max_extension_strength\n\
    \t\tthen\n\t\t\tstrongest_extension = extension\n\t\t\tmax_extension_strength\
    \ = tonumber(string.sub(extension, 2))\n\t\tend\n\tend\n\tif max_extension_strength\
    \ >= 0 then\n\t\treturn string.format(class_name .. \".%s\", strongest_extension)\n\
    \telse\n\t\treturn nil\n\tend\nend", "\t-- your code\n\t\n\t-- The code below\
    \ is based on the code from my course in CS and CS105 \n\t-- so please feel free\
    \ to look over it\n\t\n\t-- The first two characters of the extensions are the\
    \ length of the extension\n\tlocal extension_length = table.getn(extensions)\n\
    \t-- if there are no extensions we return the same name\n\tif extension_length\
    \ == 1 then\n\t\treturn class_name\n\telseif extension_length == 0 then\n\t\t\
    return class_name\n\telseif extension_length > 1 then\n\t\t-- we compare the first\
    \ two characters, this will be the strength\n\t\tlocal strength = extensions[1]:sub(1,2):upper()\
    \ - extensions[1]:sub(1,1):lower()\n\t\t\n\t\t-- we return the first extension\
    \ with the lowest strength\n\t\tfor i,extension in pairs(extensions) do\n\t\t\t\
    if extension:sub(1,2):upper() == strength then\n\t\t\t\treturn class_name .. '.'\
    \ .. extension[1]\n\t\t\tend\n\t\tend\n\tend\nend", "    local CAP = 0\n    local\
    \ SM = 0\n    for i,v in pairs(extensions) do\n        if v:match(\"^[A-Z]\")\
    \ then CAP = CAP + 1 end\n        if v:match(\"^[a-z]\") then SM = SM + 1 end\n\
    \    end\n    return class_name..\".\"..extensions[#extensions]..\".\"..(math.round(CAP\
    \ - SM))\nend", "  local max_strength = 0\n  local strongest_name = class_name\n\
    \  for i = 1, #extensions do\n    local name = extensions[i]\n    local strength\
    \ = string.find(name:upper(), \"^([A-Z]+)%l\", 1):sub(2)\n    local num_letters\
    \ = #name\n    local capital_letters = string.find(name:upper(), \"^([A-Z]+)\"\
    , 1):sub(1)\n    local num_cap_letters = #capital_letters\n    local num_sm =\
    \ #name", "\tlocal max = 0\n\tlocal strongest = \"\"\n\tfor _, extension in pairs(extensions)\
    \ do\n\t\tlocal cap = #extension:upper()\n\t\tlocal sm = #extension:lower()\n\t\
    \tlocal s = cap - sm\n\t\tif max < s then\n\t\t\tmax = s\n\t\t\tstrongest = extension\n\
    \t\tend\n\tend\n\treturn class_name .. \".\" .. strongest\nend", "  local result\
    \ = {}\n  local n = #extensions\n  for i = 1, n do \n    local c = extensions[i]\n\
    \    local cap = #c:upper()\n    local sm = #c:lower()\n    local strength = cap\
    \ - sm\n    if strength == 0 then \n      break \n    end\n    if result[strength]\
    \ ~= nil then\n      local temp = result[strength]\n      while #temp > 1 do\n\
    \        local tmp = temp[1]\n        if tmp < c then\n          temp = tmp\n\
    \        elseif tmp == c then\n          temp[1] = c\n          result[strength]\
    \ = temp\n          break \n        end\n        temp = tmp \n      end\n    \
    \  if temp == nil then\n        result[strength] = {c} \n      else\n        temp[1]\
    \ = c\n      end\n    else\n      result[strength] = {c} \n    end\n  end\n  \n\
    \  for i = 1, #result do \n    if i == 1 then \n      return class_name .. '.'\
    \ .. result[i].[1]\n    end\n    local j = i - 1\n    local s = result[i].[1]\n\
    \    for k = 1, j do \n      if #s == 1 then \n        return class_name .. '.'\
    \ .. s \n      end\n      local t = s \n      s = result[k].[1]\n      result[k]\
    \ = t\n    end\n  end\n  return nil \nend", "\tlocal strength_table = { }\n\t\
    for _, extension in pairs(extensions) do\n\t\tlocal cap = string.upper(extension:sub(1,\
    \ 2))\n\t\tlocal sm = string.lower(extension:sub(2, 2))\n\t\tlocal strength =\
    \ cap - sm\n\t\ttable.insert(strength_table, strength)\n\tend\n\tlocal max_strength\
    \ = #strength_table\n\tif max_strength == 0 then\n\t\tmax_strength = 1\n\tend\n\
    \tlocal max_strength_extension = nil\n\tfor i = 1, max_strength do\n\t\tif max_strength_extension\
    \ == nil then\n\t\t\tmax_strength_extension = i\n\t\t\tbreak\n\t\tend\n\t\tif\
    \ strength_table[i] > strength_table[max_strength_extension] then\n\t\t\tmax_strength_extension\
    \ = i\n\t\tend\n\tend\n\treturn class_name .. '.' .. extensions[max_strength_extension\
    \ + 1]\nend", "    local strengths = {}\n    for i,extension in ipairs(extensions)\
    \ do\n        local c = string.lower(string.sub(class_name,1, string.len(extension)-1))\n\
    \        local e = string.lower(string.sub(extension,1, string.len(extension)-1))\n\
    \        local sc = c+e\n        if not strengths[sc] then\n            strengths[sc]\
    \ = -1\n        elseif strengths[sc] > i then\n            strengths[sc] = i\n\
    \        end\n    end\n    local maxValue = -1\n    local maxStrongest = ''\n\
    \    for i,value in pairs(strengths) do\n        if value == maxValue then\n \
    \           maxStrongest = string.sub(class_name,1, string.len(extensions[i])-1)\n\
    \        else\n            maxValue = value\n            maxStrongest = string.sub(class_name,1,\
    \ string.len(extensions[i])-1)\n        end\n    end\n    return maxStrongest\n\
    end", "   local max_extension_strength = -1\n   for i=1,#extensions do\n     \
    \  local extension = extensions[i]\n       local upper_cap = string.upper(extension:sub(1,CAP))\n\
    \       local lower_cap = string.lower(extension:sub(CAP))\n       local strength\
    \ = upper_cap - lower_cap\n       if max_extension_strength == -1 or strength\
    \ > max_extension_strength then\n           max_extension_strength = strength\n\
    \           return class_name .. \".\" .. extension\n       end\n   end\n   return\
    \ nil\nend", "  local max_extension = extensions[1]\n  for _, extension in ipairs(extensions)\
    \ do\n    if extension > max_extension then\n      max_extension = extension\n\
    \    end\n  end\n  return class_name .. '.' .. max_extension\nend", "  -- Your\
    \ code here\nend", "    assert(type(extensions) ~= 'table', \"'extensions' should\
    \ be passed as a table\")\n    local strongest = extensions[1]\n    for i = 2,\
    \ #extensions do\n        local cap = string.upper(string.sub(extensions[i], 1,\
    \ 1))\n        local sm = string.lower(string.sub(extensions[i], 2, 2))\n    \
    \    if (cap - sm) >= 0 then\n            strongest = extensions[i]\n        else\n\
    \            break\n        end\n    end\n    return class_name .. '.' .. strongest\n\
    end", "\tlocal strongest_extension = nil\n\tfor _,extension_name in ipairs(extensions)\
    \ do\n\t\tlocal num_upper = string.gsub(extension_name, '[A-Z]', '').length\n\t\
    \tlocal num_lower = string.gsub(extension_name, '[a-z]', '').length\n\t\tif num_upper\
    \ > num_lower then\n\t\t\tstrongest_extension = class_name..'.'..extension_name\n\
    \t\t\tbreak\n\t\tend\n\tend\n\treturn strongest_extension\nend\n\t", "\tlocal\
    \ function f(name, ext)\n\t\tlocal cap, sm = name:lower():upper():sub(1, -1),\
    \ name:lower():sub(2):lower() \n\t\treturn (cap - sm)/cap * 100 < ext:upper():sub(1,\
    \ 1) / 100 \n\tend\n\tlocal s = string.format('%s.%s', class_name, extensions[1])\n\
    \tfor i = 2, #extensions do\n\t\tif f(class_name, extensions[i]) then\n\t\t\t\
    s = string.format('%s.%s', s, extensions[i])\n\t\tend\n\tend\n\treturn s\nend",
  "    local class_hash = class_name:hash()\n    local best_extension = {}\n    for\
    \ _, extension in pairs(extensions) do\n        local extension_hash = extension:hash()\n\
    \        local strength = extension_hash - class_hash\n        if strength > 0\
    \ then\n            if best_extension[strength] == nil then\n                best_extension[strength]\
    \ = extension\n            else\n                if extension_hash < best_extension[strength]:hash()\
    \ then\n                    best_extension[strength] = extension\n           \
    \     end\n            end\n        end\n    end\n    \n    local best_strength\
    \ = nil\n    for _, strength in pairs(best_extension) do\n        if best_strength\
    \ == nil then\n            best_strength = strength\n        else\n          \
    \  if strength > best_strength then\n                best_strength = strength\n\
    \            end\n        end\n    end\n    return class_name .. '.' .. best_extension[best_strength]:hash()\n\
    end", "    assert(extensions, \"Extensions cannot be nil\")\n    for _, extension\
    \ in pairs(extensions) do\n        assert(type(extension) == \"string\", \"Extensions\
    \ list must contain only strings\")\n        local cap = string.upper(extension):sub(1,\
    \ 1)\n        local sm = string.lower(extension):sub(1, 1)\n        if cap - sm\
    \ >= 0 then\n            return string.format(\"%s.%s\", class_name, extension)\n\
    \        end\n    end\nend\n</cell>\n<text>\nReturn to task 1.5 of the Course\
    \ Content Exercise", "    local best_extension\n    local best_strength = -1\n\
    \    for _, extension in pairs(extensions) do\n        local strength = class_name:sub(1,\
    \ class_name:len()-#extension)\n        if strength > best_strength then\n   \
    \         best_strength = strength\n            best_extension = extension\n \
    \       end\n    end\n    return best_extension\nend", "\tlocal bestExtension\
    \ = nil\n\tlocal bestExtensionStrength = -1\n\tfor _, extension in ipairs(extensions)\
    \ do\n\t\tlocal splittedName = extension:match('^([^A-Z]*[A-Z])(.*)$')\n\t\tlocal\
    \ capitals = splittedName:sub(1,capitalsLength)\n\t\tlocal lowers = splittedName:sub(capitalsLength+1)\n\
    \t\tlocal splittedNameCapital = capitals:match('^(.-)(.-)$')\n\t\tlocal splittedNameLower\
    \ = lowers:match('^(.-)(.-)$')\n\t\tlocal splittedNameCapitalStrength = capitals:match('^(.-)(.-)$')\n\
    \t\tlocal splittedNameLowerStrength = lowers:match('^(.-)(.-)$')\n\t\tlocal capitalStrongest\
    \ = splittedNameCapitalStrength and splittedNameCapitalStrength:sub(1,2)\n\t\t\
    local lowerStrongest = splittedNameLowerStrength and splittedNameLowerStrength:sub(1,2)\n\
    \t\tlocal strength = (capitalStrongest and capitalStrongest:gsub(\"(.)\", \"%1\
    \ \")) .. (lowerStrongest and lowerStrongest:gsub(\"(.)\", \"%1 \")) \n\t\tif\
    \ strength > bestExtensionStrength then\n\t\t\tbestExtension = extension\n\t\t\
    \tbestExtensionStrength = strength\n\t\tend\n\tend\n\treturn (class_name .. '.'\
    \ .. bestExtension)\nend", "\tlocal str_ext = {}\n\tlocal max = 0\n\tfor _, ext\
    \ in ipairs(extensions) do\n\t\tlocal cnt = string.gsub(ext, \"[^A-Z]\", \"\"\
    )\n\t\tstr_ext[ext] = cnt\n\t\tif cnt > max then\n\t\t\tmax = cnt\n\t\tend\n\t\
    end\n\tfor ext, cnt in pairs(str_ext) do\n\t\tif cnt > 0 then\n\t\t\treturn class_name\
    \ .. '.' .. ext .. '(' .. cnt .. ')'\n\t\tend\n\tend\n\treturn nil\nend", "  \
    \  local max_strength = -1 -- The maximal strength\n    local max_extension_name\
    \ -- The extension with the highest strength\n    for _, extension in ipairs(extensions)\
    \ do\n        local capitals = string.gsub(extension, \"[A-Z]\", \"\")\n     \
    \   local lowercases = string.gsub(extension, \"[a-z]\", \"\")\n        if capitals\
    \ == 0 then\n            capitals = 1\n        end\n        if lowercases == 0\
    \ then\n            lowercases = 1\n        end\n        local strength = capitals\
    \ - lowercases\n        if strength > max_strength then\n            max_strength\
    \ = strength\n            max_extension_name = extension\n        end\n    end\n\
    \    return string.gsub(class_name, \"%.\", max_extension_name)\nend", "   local\
    \ max_strength = -1\n   for _, e in pairs(extensions) do\n       local cap = string.upper(e:match('^%l'))\n\
    \       local sm = string.lower(e:match('^%s'))\n       local strength = cap -\
    \ sm\n       if strength > max_strength then\n          max_strength = strength\n\
    \          max_class = class_name\n       end\n   end\n   return max_class ..\
    \ '.'..max_strength\nend\n</cell>\n<text>\nQuiz Question 10\nWrite a function,\
    \ Extension, that takes in a list of strings and returns a list of\nthe extensions\
    \ of the string. The function should only use the standard Lua functions\nstring.match,\
    \ string.upper, and string.lower.", "   local strength_map = {}\n   for _, extension\
    \ in ipairs(extensions) do\n      table.insert(strength_map, extension:gsub(\"\
    %l\", \"\") - extension:gsub(\"%L\", \"\"))\n   end\n   for key, value in ipairs(strength_map)\
    \ do\n      local num_cap = #key:upper() - 1\n      local num_low = #key:lower()\
    \ - 1\n      if num_cap - num_low <= 0 then\n         return string.format(class_name\
    \ .. '.' .. key)\n      end\n   end\nend", "\tif extensions == nil or #extensions\
    \ == 0 then\n\t\treturn nil\n\tend", "    local max = 0\n    local max_extension\
    \ = \"\"\n    for index, extension_name in pairs(extensions) do\n        local\
    \ extension_class = string.sub(class_name, 1, string.len(class_name) - string.len(extension_name))\n\
    \        local extension_strength = string.len(extension_name)\n        if string.find(extension_class,\
    \ extension_name) == nil then\n            extension_strength = -1\n        end\n\
    \        local new_max = math.max(extension_strength, max)\n        if new_max\
    \ == max then\n            max_extension = extension_name\n        end\n     \
    \   max = new_max\n    end\n    return max_extension\nend", "    local num_upper,\
    \ num_lower =\n        extensions:map(function(ext)\n            return string.gsub(ext,\
    \ '[^A-Z]'):reverse():match('(.-)%s')\n        end)\n    return class_name ..\
    \ '.' .. extensions[math.max(num_upper, num_lower):min(#extensions)]\nend", " \
    \  local streng = 0\n   local max_streng = 0 \n   local max_class_name = class_name\n\
    \   for _, e in pairs(extensions) do\n      local cap, sm, streng = #e, #e, #e\
    \ \n      for i = 1, cap do\n         streng = (streng * cap + cap - sm) * (cap\
    \ - i - 1)\n         streng = streng / (cap - i + 1)\n      end\n      streng\
    \ = (streng + sm) / cap\n      if streng > max_streng then\n         max_streng\
    \ = streng\n         max_class_name = class_name\n      end\n   end\n   return\
    \ max_class_name\nend", "  local strongest_extension = {}\n  for i = 1, #extensions\
    \ do\n    local class = extensions[i]\n    local cap = string.upper(class:sub(-1))\n\
    \    local sm = string.lower(class:sub(1, class:len() - cap))\n    if cap - sm\
    \ ~= 0 then\n      table.insert(strongest_extension, class)\n    end\n  end\n\
    \  if #strongest_extension > 1 then\n    -- choose the one that comes first in\
    \ the list\n    local first_element = table.remove(strongest_extension, 1)\n \
    \   table.insert(strongest_extension, first_element)\n  end\n  -- pick the strongest\
    \ extension from the list\n  for i = 1, #strongest_extension do\n    local class_extension\
    \ = strongest_extension[i]\n    if class_extension == class_name then\n      return\
    \ class_extension\n    end\n  end\n  return nil\nend", "    if extensions.count\
    \ == 0 then\n        error('Extension list is empty')\n    end\n    local strength\
    \ = extensions[1]\n    for i = 2, #extensions do\n        local cap = upper(extensions[i])\n\
    \        local sm = lower(extensions[i])\n        local c = cap - sm\n       \
    \ if strength <= 0 then\n            strength = c\n        elseif strength > c\
    \ then\n            strength = c\n        end\n    end\n    return class_name\
    \ .. '.' .. upper(extensions[1]) .. '.' .. lower(extensions[#extensions])\nend",
  "  -- your code here\n  local n = #extensions\n  local cap = #uppercase_letters(class_name)\n\
    \  local sm = #lowercase_letters(class_name)\n  if cap - sm < 0 then\n    return\
    \ class_name\n  elseif cap - sm == 0 then\n    return class_name\n  elseif cap\
    \ - sm == 1 then\n    return class_name .. \".\" .. extensions[1]\n  else\n  \
    \  local max_strength = -1\n    local extension_index = 1\n    while extension_index\
    \ <= n do\n      local s = extensions[extension_index] -- extensions[extension_index]\
    \ ~= 'a'\n      local cap_s = #uppercase_letters(s)\n      local sm_s = #lowercase_letters(s)\n\
    \      local str_s = cap_s - sm_s\n      -- print(class_name, extensions[extension_index],\
    \ cap_s, sm_s, str_s) \n      if max_strength < str_s\n      or max_strength ==\
    \ -1 and str_s > max_strength then\n        max_strength = str_s\n        extension_index\
    \ = extension_index\n      elseif max_strength == str_s and max_strength == -1\
    \ then\n        return class_name .. \".\" .. extensions[extension_index]\n  \
    \    end\n      extension_index = extension_index + 1\n    end\n    return class_name\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nYou reminded me of the `Strong()` function,\
    \ I missed it the first time around, and it was a fun problem.\n<|/ c |>\n<| a\
    \ dscore=2 tags=lua-patterns,lua-5.2,lua |>\nHere's a solution that is almost\
    \ exactly the same as the original, but it does have a couple of minor differences:",
  "    -- start by sorting the extensions\n    extensions = extensions:map(function(extension)\n\
    \        -- split extension into name and extension\n        local name, ext =\
    \ string.match(extension, '^(.)(.)')\n        -- convert to upper case\n     \
    \   local name = string.upper(name):lower()\n        -- convert to lower case\n\
    \        local ext = string.lower(ext)\n        -- return name and extension\n\
    \        return name, ext\n    end)\n    -- sort extensions\n    extensions =\
    \ extensions:map(function(pair)\n        -- return pair if name is lower case\n\
    \        return pair[1] <  pair[2] and pair or pair[2]..pair[1]\n    end)\n  \
    \  -- find highest extension\n    local extension = extensions[1][1]\n    -- iterate\
    \ over extensions and find if any pair is bigger\n    for i=2,#extensions do\n\
    \        local e = extensions[i][1]\n        if extension > e then\n         \
    \   extension = e\n        end\n    end\n    -- return class name, highest extension\n\
    \    return class_name..extension\nend", "  return extensions[1]..'.'..extensions[2]..'.'..extensions[#extensions]\n\
    end", "    local class_strength = class_name .. '.'\n    local extension_strengths\
    \ = {}\n    for _,extension in pairs(extensions) do\n        local _,ext = string.gsub(extension,\
    \ '_','')\n        local strength = string.match(class_strength .. ext, '%u')\n\
    \        if strength == nil then\n            return nil -- No extension of this\
    \ name, or no extension at all\n        elseif extension_strengths[strength] ==\
    \ nil then\n            extension_strengths[strength] = extension\n        else\n\
    \            if extension_strengths[strength] < extension then\n             \
    \   -- Swap them\n                extension_strengths[strength], extension_strengths[extension_strengths[strength]]\
    \  = extension_strengths[extension_strengths[strength]], extension_strengths[strength]\n\
    \            end\n        end\n    end\n    local strongest_extension = nil\n\
    \    for strength,extension in pairs(extension_strengths) do\n        if strongest_extension\
    \ == nil then\n            strongest_extension = extension\n        elseif extension_strengths[strength]\
    \ < strongest_extension then\n            strongest_extension = extension\n  \
    \      end\n    end\n    return class_name .. '.' .. strongest_extension\nend",
  "\tassert(class_name)\n\tassert(extensions)\n\tlocal strengths = {} -- A table of\
    \ { class_name -> strength }\n\tlocal extensions_count = {}\n\tfor _, extension\
    \ in ipairs(extensions) do\n\t\tlocal cap = #extension\n\t\tlocal sm = #(extension)\
    \ - cap\n\t\tif cap == 0 then -- If the extension's name has no upper case letters,\
    \ it has no strongest extension\n\t\t\treturn\n\t\tend\n\t\tif not strengths[extension]\
    \ or strengths[extension] < sm * -1 then\n\t\t\tstrengths[extension] = sm * -1\n\
    \t\t\textensions_count[extension] = true\n\t\tend\n\tend\n\t-- Sort extensions\
    \ by strength\n\ttable.sort(extensions, function(a, b)\n\t\tif extensions_count[b]\
    \ < extensions_count[a] then\n\t\t\treturn 1\n\t\telseif extensions_count[b] >\
    \ extensions_count[a] then\n\t\t\treturn -1\n\t\telse\n\t\t\treturn 0\n\t\tend\n\
    \tend)\n\t-- Return the strongest extension\n\treturn class_name .. '_' .. table.concat(extensions,\
    \ '.')\nend", "    local cap = {}\n    local sm = {}\n    for _, item in pairs(extensions)\
    \ do\n        cap[#cap + 1] = item:upper()\n        sm[#sm + 1] = item:lower()\n\
    \    end", "  if #extensions == 0 then\n    return class_name\n  end\n  local\
    \ cap, sm = 0, 0\n  for _, e in ipairs(extensions) do\n    if string.find(class_name,\
    \ e, 'all') then\n      cap = cap + 1\n    elseif string.find(class_name, e, 'any')\
    \ then\n      sm = sm + 1\n    end\n  end\n  return string.sub(class_name, 1,\
    \ cap - sm + 1)\nend", "    local StrongestExtensionName = nil\n    local StrongestExtensionStrength\
    \ = -1\n    for _, extension in ipairs(extensions) do\n        local cap, sm =\
    \ string.match(extension, \"(%[%aA-z]%.)([%aA-z]%)\")\n        if cap and sm then\n\
    \            local cap_str = string.upper(string.sub(cap, 1, 1))\n           \
    \ local sm_str = string.lower(string.sub(sm, 1, 1))\n            local strength\
    \ = cap_str - sm_str\n            if strength > StrongestExtensionStrength then\n\
    \                StrongestExtensionName = extension\n                StrongestExtensionStrength\
    \ = strength\n            end\n        end\n    end\n    return string.sub(class_name,\
    \ 1, string.len(class_name) - 1) .. StrongestExtensionName\nend", "  -- Your code\
    \ here\nend", "   -- Only use uppercase letters\n   for i,v in pairs(extensions)\
    \ do\n      extensions[i] = v:upper()\n   end\n   local strengths = {}\n   --\
    \ Count the number of each extension\n   for i,v in pairs(extensions) do\n   \
    \   table.insert(strengths, v) -- Use v as the key to the table\n      strengths[v]\
    \ = tonumber(strengths[v]) + 1\n   end\n   -- Sort by strength\n   table.sort(strengths)\n\
    \   -- Look for the strongest extension\n   local max_strength = -1\n   local\
    \ max_extension = ''\n   for k,v in pairs(strengths) do\n      if v > max_strength\
    \ then\n         max_strength = v\n         max_extension = k\n      end\n   end\n\
    \   -- Reset the extension name to the name of the class\n   max_extension = max_extension\
    \ .. '.' .. class_name\n   return max_extension\nend", "  local function Strongest(s)\n\
    \    local n = #s\n    local c = 1\n    local strongest = ''\n    for i = 1, n\
    \ do\n      local c = c * (CAP_TO_STRONG[s:sub(i,i)] - SM_TO_STRONG[s:sub(i,i)])\n\
    \      if c > strongest then\n        strongest = c\n      end\n    end\n    return\
    \ class_name .. '.' .. strongest\n  end\n  return extensions.sort(function(a,\
    \ b) return Strongest(a) > Strongest(b) end):reverse()[1]\nend", "  if #extensions\
    \ == 0 then\n    return nil\n  end", "  assert(type(extensions) == 'table')\n\
    \  local results = {}\n  for i = 1, #extensions do\n    local ext = extensions[i]\n\
    \    assert(type(ext) == 'string')\n    local cap = #ext:upper()\n    local sm\
    \ = #ext:lower()\n    local cname = class_name .. '_' .. ext\n    local score\
    \ = -1\n    if cap > sm then\n      score = cap - sm\n    elseif cap < sm then\n\
    \      score = sm\n    else\n      score = cap - sm * 2\n    end\n    table.insert(results,\
    \ {cname, score})\n  end\n  table.sort(results, function(a, b) return a.score\
    \ > b.score end)\n  if #results == 1 then\n    return results[1].cname\n  elseif\
    \ #results > 1 then\n    return results[1].cname\n  end\n  return nil\nend", "\t\
    local num_upper, num_lower = 0, 0\n\tfor _, e in pairs(extensions) do\n\t\tlocal\
    \ c = string.sub(e, 1, 1)\n\t\tlocal n = string.sub(e, 2, 2)\n\t\tif c~= c  then\
    \ num_upper = num_upper+1 end\n\t\tif n~= n  then num_lower = num_lower+1 end\n\
    \tend\n\t\n\treturn string.format(class_name, num_upper/num_lower)\nend", "  \
    \  local strongest = 0\n    local i = 1\n    while i <= #extensions do\n     \
    \   local index = string.find(class_name, extensions[i])\n        if index ==\
    \ nil then break end\n        if strongest < index then\n            strongest\
    \ = index\n        end\n        i = i + 1\n    end\n    return string.remove(class_name,\
    \ strongest+1, #class_name-strongest-1)\nend", "   assert(type(class_name)==\"\
    string\" and #extensions>0)\n   local strengths = {}\n   local num_extensions\
    \ = #extensions\n   for i=1,num_extensions do\n      local extension = extensions[i]\n\
    \      local c1 = string.sub(class_name,1,string.find(class_name,\"[A-Z]\"))\n\
    \      local c2 = string.sub(extension,1,string.find(extension,\"[A-Z]\"))\n \
    \     local c3 = string.sub(class_name,string.find(class_name,\"[A-Z]\"),string.find(class_name,\"\
    [\"))\n      local c4 = string.sub(extension,string.find(extension,\"[A-Z]\"),string.find(extension,\"\
    [\"))\n      local c5 = string.sub(class_name,string.find(class_name,\"[\"))\n\
    \      local c6 = string.sub(class_name,string.find(class_name,\"[\"))\n     \
    \ if c1 == c2 then\n         if strengths[c1] == nil then\n            strengths[c1]\
    \ = c5\n         else\n            if c1 == c3 then\n               if strengths[c1]\
    \ == nil then\n                  strengths[c1] = c6\n               else\n   \
    \               if c1 == c4 then\n                     if strengths[c1] == nil\
    \ then\n                        strengths[c1] = c5\n                     else\n\
    \                        strengths[c1] = c4\n                     end\n      \
    \            else\n                     strengths[c1] = c5\n                 \
    \ end\n               end\n            else\n               strengths[c1] = c5\n\
    \            end\n         end\n      elseif c1 != c2 then\n         if strengths[c1]\
    \ == nil then\n            strengths[c1] = c5\n         else\n            strengths[c1]\
    \ = c6\n         end\n      end\n   end\n   local maxStrength = #strengths\n \
    \  if maxStrength == 1 then\n      return \"%s.%s\"%{class_name, extensions[maxStrength]}\n\
    \   else\n      for i=1,maxStrength do\n         local stren = strengths[i]\n\
    \         if stren ~= nil then\n            if stren > maxStrength then\n    \
    \           maxStrength = stren\n            end\n         end\n      end\n  \
    \    return \"%s.%s\"..string.sub({class_name, extensions[maxStrength+1]}, #class_name)\n\
    \   end\nend", "  if #extensions == 0 then \n    return '' \n  elseif #extensions\
    \ == 1 then\n    return class_name .. '.' .. extensions[1]\n  else\n    -- Find\
    \ the strongest extension\n    local max_strength = -1\n    local max_extension\
    \ = nil", "  local exts = {}\n  for i = 1, #extensions do\n    local extname =\
    \ extensions[i]\n    local cap_length = extname:upper():len()\n    local sml_length\
    \ = extname:lower():len()\n    local ext_strength = cap_length - sml_length\n\
    \    table.insert(exts, ext_strength, extname)\n  end\n  table.sort(exts)\n  local\
    \ strongest_ext = exts[1][2]\n  if #exts > 1 then\n    strongest_ext = exts[2][2]\n\
    \  end\n  return string.format('%s.%s', class_name, strongest_ext)\nend", "  \
    \ local class_index = #class_name\n   for i = 1, #extensions do\n      local extension_index\
    \ = #extensions[i]\n      local cap = extension_index - class_index\n      local\
    \ sm = extension_index + class_index\n      local strength = cap - sm\n      if\
    \ strength == 0 then\n         return class_name..extensions[i]\n      elseif\
    \ strength > 0 then\n         return class_name..extensions[i]\n      else\n \
    \        local tmp = class_name\n         while true do\n            local new_class\
    \ = tmp:sub(1, tmp:len()-#extensions[i])\n            if new_class ~= class_name\
    \ then\n               return tmp..extensions[i]\n            end\n         end\n\
    \      end\n   end\nend\n</code>\n<|/ a tags=lua dscore=2 |>\n<| c |>\nThank you\
    \ very much, this is what I needed!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "\t\
    local extensions_count = #extensions\n\tlocal extensions_name_length = #class_name\n\
    \tlocal strength = {}\n\t\n\tfor i = 1, extensions_count do\n\t\tlocal ext = extensions[i]\n\
    \t\tlocal len = #ext\n\t\t\n\t\t-- Find the extension's starting point\n\t\tlocal\
    \ idx = 1\n\t\twhile idx <= extensions_name_length do\n\t\t\tif (ext:sub(1, idx):lower()\
    \ == class_name:sub(1, idx):lower()) then\n\t\t\t\t-- The extension's starting\
    \ point is at the index\n\t\t\t\t-- immediately before the first lowercase letter\n\
    \t\t\t\t-- that is equal to the starting point of the class\n\t\t\t\tidx = idx\
    \ - 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tidx = idx + 1\n\t\tend\n\t\t\n\t\t-- Find\
    \ the extension's ending point\n\t\tlocal end_idx = 1\n\t\twhile end_idx <= len\
    \ do\n\t\t\tif (ext:sub(end_idx, end_idx):upper() == class_name:sub(end_idx, end_idx):upper())\
    \ then\n\t\t\t\t-- The extension's ending point is at the index\n\t\t\t\t-- immediately\
    \ after the last uppercase letter\n\t\t\t\t-- that is equal to the starting point\
    \ of the class\n\t\t\t\tend_idx = end_idx + 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t\
    end_idx = end_idx + 1\n\t\tend\n\t\t\n\t\t-- Calculate the strength\n\t\tlocal\
    \ cap = #ext:sub(end_idx, len):upper()\n\t\tlocal sm = #ext:sub(1, idx):lower()\n\
    \t\tlocal strength_score = (cap - sm) / cap\n\t\tlocal strongest_extension = class_name:sub(1,\
    \ idx)..ext:sub(end_idx, len)\n\t\t\n\t\ttable.insert(strength, strength_score)\n\
    \tend\n\t\n\ttable.sort(strength)\n\t\n\tlocal strongest_extension\n\t\n\tif #strength\
    \ == 1 then\n\t\tstrongest_extension = class_name .. extensions[1]\n\telse\n\t\
    \tstrongest_extension = class_name\n\t\tfor i = 1, #strength do\n\t\t\tif strength[i]\
    \ > strength[i-1] then\n\t\t\t\tstrongest_extension = class_name .. extensions[i]\n\
    \t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn strongest_extension\nend",
  "\tlocal max_index = -1\n\tlocal max_strongest = ''", "    -- Based on the following\
    \ implementation details:\n    -- 1. A class's name is given as string.\n    --\
    \ 2. A list of extensions is given as string.\n    -- 3. The strength of a extension\
    \ is given as positive integer.\n    local cap_counter = { }\n    local sm_counter\
    \ = { }\n    for _, extension in ipairs(extensions) do\n        cap_counter[extension:upper()]\
    \ = cap_counter[extension:upper()] + 1\n        sm_counter[extension:lower()]\
    \ = sm_counter[extension:lower()] + 1\n    end\n    local total_counter = cap_counter\
    \ + sm_counter\n    local max_strength = -1\n    local max_extension = \"\"\n\
    \    for k, v in pairs(cap_counter) do\n        if max_strength < v - sm_counter[k]\
    \ then\n            max_strength = v - sm_counter[k]\n            max_extension\
    \ = k\n        end\n    end\n    return class_name .. \".\" .. max_extension\n\
    end", "    local num_upper = #class_name#/#string.gsub(class_name, \"[A-Z]\",\
    \ \"\") -- (CAP)\n    local num_lower = #class_name#/#string.gsub(class_name,\
    \ \"[a-z]\", \"\") -- (SM)\n    local extension_strength = num_upper - num_lower\
    \ -- (SR)\n    for _, extension in ipairs(extensions) do\n        local num_upper\
    \ = #extension#/#string.gsub(extension, \"[A-Z]\", \"\")\n        local num_lower\
    \ = #extension#/#string.gsub(extension, \"[a-z]\", \"\")\n        local extension_strength_i\
    \ = num_upper - num_lower\n        if extension_strength_i > extension_strength\
    \ then\n            extension_strength = extension_strength_i\n        end\n \
    \   end\n    return class_name..\".\"..extensions[#extensions]\nend", "    local\
    \ caps = string.gmatch(class_name, '%a([A-Z])')\n    local sms = string.gmatch(class_name,\
    \ '%a([a-z])')\n    local sm, cap\n    local max_sm = caps - sms\n    for _, cap\
    \ in pairs(caps) do\n        for _, sm in pairs(sms) do\n            if cap -\
    \ sm > max_sm then\n                max_sm = cap - sm\n                cap = sm\n\
    \            end\n        end\n    end\n    max_sm = caps - sms\n    local strongest\
    \ = ''\n    for _, e in pairs(extensions) do\n        if caps - string.gmatch(class_name,\
    \ '%a('..e..')') == max_sm then\n            strongest = class_name..'.'..e\n\
    \        end\n    end\n    return strongest\nend", "    assert(type(class_name)\
    \ == \"string\")\n    assert(type(extensions) == \"table\")\n    assert(#extensions\
    \ > 0)", "\t-- Write your code here\n\t\n\treturn nil\nend", "    -- your code\
    \ here\nend", "    local function Strongest(key)\n        local cap_len = #key\n\
    \        local sm_len = #key:lower():lower()\n        return cap_len - sm_len\n\
    \    end\n    local max_strength = extensions:map(function (extension)\n     \
    \   return Strongest(extension)\n    end):max()\n    local max_extension_index\
    \ = extensions:map(function (extension)\n        return Strongest(extension):byte()\n\
    \    end):max()\n    local extension = extensions[max_extension_index]\n    return\
    \ class_name .. '.' .. extension\nend", "  -- your code here\nend", "  -- Write\
    \ your code here\nend", "    assert(type(class_name) == \"string\")\n    assert(type(extensions)\
    \ == 'table')\n    local cap = #class_name\n    local sm = #class_name\n    for\
    \ _, ext in pairs(extensions) do\n        cap = cap - #ext\n        sm = sm -\
    \ #ext\n    end\n    if cap == 0 or sm == 0 then\n        return '' -- error\n\
    \    end\n    local strongest_extension = nil\n    for _, ext in pairs(extensions)\
    \ do\n        if ext == class_name then\n            strongest_extension = ext\n\
    \        end\n    end\n    if not strongest_extension then\n        return ''\
    \ -- error\n    end\n    return strongest_extension\nend", "    local CAP = #class_name\n\
    \    local SM = #class_name:lower() - 1\n    local strengths = {}\n    for _,\
    \ extension in ipairs(extensions) do\n        local CAP_extension = #extension:upper()\n\
    \        local SM_extension = #extension:lower()\n        local strength = CAP_extension\
    \ - SM_extension\n        if not strengths[strength] then strengths[strength]\
    \ = extension end\n    end\n    local strength = #extensions[#strengths]\n   \
    \ if strength > 0 then\n        return class_name .. \".\" .. strengths[strength]\n\
    \    else\n        return class_name\n    end\nend", "  local strength = -1000\n\
    \  local i = 1\n  local s = string.lower(class_name)\n  -- Slightly modify Shikh's\
    \ algorithm\n  while i <= #extensions do\n    local e = string.lower(extensions[i])\n\
    \    local cap_len = string.len(string.sub(e, 1, 1))\n    local sm_len = string.len(string.sub(e,\
    \ 2, #e))\n    local score = math.min(cap_len - sm_len, 1)\n    if score > strength\
    \ then\n      strength = score\n    end\n    i = i + 1\n  end\n  return s .. '.'\
    \ .. extensions[#extensions]\nend", '    local strongest_extension = {}', "\t\
    -- Base Case\n\tif extensions == nil then\n\t\treturn class_name\n\tend", "  local\
    \ str = class_name\n  local max_strength = -1\n  local max_strength_extension\n\
    \  for _, extension in ipairs(extensions) do\n    local strength = tonumber(string.match(extension,\
    \ \"^%l\"))\n    if strength >= 0 then\n      if strength > max_strength then\n\
    \        max_strength = strength\n        max_strength_extension = extension\n\
    \      end\n    end\n  end\n  return string.sub(str,1,string.len(max_strength_extension))..max_strength_extension\n\
    end", "   -- Your code here\nend", "  local capitals = #class_name\n  local smatters\
    \ = #class_name\n  for _, extension in ipairs(extensions) do\n    capitals = capitals\
    \ - #extension\n    smatters = smatters - #extension\n  end\n  if capitals < smatters\
    \ then\n    return class_name..'.'..extensions.slice(1, capitals).join('.')\n\
    \  else\n    return class_name..'.'..extensions.slice(1, smatters).join('.')\n\
    \  end\nend\n</code>\n<|/ a dscore=1 tags=lua |>\n<| c |>\nThanks so much for\
    \ your answer. I think I understand what you're trying to do, but I'm running\
    \ into a problem implementing it. I think I understand it very well for the most\
    \ part, but when I implement it into the code, I receive an error saying \"attempt\
    \ to index a nil value\". I'm also unsure if I'm putting it in the right place\
    \ - should I be putting it into the function? My function is called strongest,\
    \ but I'm unsure how to implement that into the function. Again, thank you!\n\
    <|/ c |>\n<| c |>\nOkay, so I implemented it into my code, but I still receive\
    \ an error saying \"attempt to index a nil value\". I'm not sure if I'm placing\
    \ it in the right place. Should I be placing it into the function? My function\
    \ is called strongest, but I'm unsure how to implement that into the function.\
    \ Again, thank you for your help!\n<|/ c |>\n<| c |>\nI figured it out! Thank\
    \ you so much for your help! I appreciate it.\n<|/ c |>\n<| c |>\nGreat. By the\
    \ way, you can find more information about the function [here](http://www.lua.org/pil/3.3.html)\
    \ and [here](http://www.lua.org/pil/3.3.2.html).\n<|/ c |>\n<| c |>\nOkay, I implemented\
    \ it into my code, but I still receive an error saying \"attempt to index a nil\
    \ value\". I'm not sure if I'm placing it in the right place. Should I be placing\
    \ it into the function? My function is called strongest, but I'm unsure how to\
    \ implement that into the function. Again, thank you for your help!\n<|/ c |>\n\
    <| a tags=lua dscore=0 |>\nThis is my solution in Python. It works.\n<code>\n\
    class Slice(object):\n    def __init__(self, value, name, *extensions):\n    \
    \    self.value = value\n        self.name = name\n        self.extensions = extensions",
  "   local strongest = ''\n   local extension_map = {}\n   for _, extension in ipairs(extensions)\
    \ do\n      local strength = GetClassExtensionStrength(class_name, extension)\n\
    \      if not extension_map[strength] then\n         extension_map[strength] =\
    \ extension\n      else\n         if extension_map[strength] > extension then\n\
    \            extension_map[strength] = extension\n         end\n      end\n  \
    \ end\n   local extension_strengths = {\n      -1\n   }\n   for _, extension in\
    \ ipairs(extensions) do\n      local strength = GetClassExtensionStrength(class_name,\
    \ extension)\n      extension_strengths[strength] = true\n   end\n   for _, extension\
    \ in ipairs(extensions) do\n      local strength = GetClassExtensionStrength(class_name,\
    \ extension)\n      if not extension_strengths[strength] then\n         strongest\
    \ = extension\n      end\n   end\n   return strongest\nend", "\tlocal strongest_strength\
    \ = -1 -- Initializing strength to -1\n\tlocal extension_name -- Initializing\
    \ extension's name to ''\n\tlocal count -- Initializing extension's count to 0",
  "   local function get_strength(extension)\n      local count, letters = 1, {}\n\
    \      for _,c in ipairs(extension) do \n         letters[#letters+1] = c\n  \
    \       count = count + 1\n      end\n      return count / #letters, letters\n\
    \   end\n   local min_strength, strongest_extension = 1, ''\n   for _, extension\
    \ in ipairs(extensions) do\n      local strength, letters = get_strength(extension)\n\
    \      if strength >= min_strength then\n         if strength < min_strength then\n\
    \            min_strength = strength\n            strongest_extension = extension\n\
    \         end\n      elseif strength == min_strength then\n         if #letters\
    \ > 0 then\n            min_strength = strength\n            strongest_extension\
    \ = extension\n         end\n      end\n   end\n   return class_name .. '_' ..\
    \ strongest_extension\nend", "   if #extensions == 0 then \n      return nil \n\
    \   end", "\tlocal class_count = 0\n\tlocal extension_count = 0\n\tlocal class_strongest\
    \ = ''\n\tlocal extension_strongest = ''\n\tlocal strongest = -1\n\tlocal extension_strength\
    \ = -1", "\tlocal highest_strongest_extension = nil\n\tfor _, extension in ipairs(extensions)\
    \ do\n\t\tif StrongestExtension(extension) == class_name then\n\t\t\tif highest_strongest_extension\
    \ ~= nil then\n\t\t\t\treturn nil\n\t\t\tend\n\t\t\thighest_strongest_extension\
    \ = extension\n\t\tend\n\tend\n\treturn highest_strongest_extension\nend", " \
    \   local strongest = {}\n    for _, extension in ipairs(extensions) do\n    \
    \    local strongest[extension] = false\n    end\n    for _, extension in ipairs(extensions)\
    \ do\n        local count, capitals = extension:gsub(\"([A-Z]+)([A-Z]+)\", \"\
    %1-%2\"):gsub(\"([a-z]+)([A-Z]+)\", \"%1-%2\")\n        if (capitals - capitals\
    \ ~= 0) then\n            local strength = math.floor((capitals - capitals + 1)\
    \ / count)\n            strongest[extension] = true\n            strongest[extension:sub(1,\
    \ (strength - 1) % #extension)..capitals] = true\n        end\n    end\n    local\
    \ max = 0 \n    local maxExtension\n    for extension, strongest in pairs(strongest)\
    \ do\n        if strongest ~= false and strongest and max < strongest then\n \
    \           max = strongest\n            maxExtension = extension\n        end\n\
    \    end\n    return class_name..maxExtension\nend", "  local extension_strength\
    \ = nil\n  local current_strength = -1\n  for _, extension_name in ipairs(extensions)\
    \ do\n    local ext = extension_name:lower()\n    local cap_ext = cap_first(ext)\n\
    \    local cap_extension_count = count(extension_name:gsub('^[^' .. cap_ext ..\
    \ ']', ''))\n    local sml_extension_count = count(extension_name:gsub('^[' ..\
    \ cap_ext .. ']', ''))\n    if cap_extension_count > 0 and cap_extension_count\
    \ > sml_extension_count then\n      current_strength = cap_extension_count\n \
    \     extension_strength = cap_ext\n    elseif sml_extension_count > 0 and sml_extension_count\
    \ > cap_extension_count then\n      current_strength = sml_extension_count\n \
    \     extension_strength = ext\n    end\n  end\n  return class_name .. '.' ..\
    \ extension_strength\nend", "    -- Your code here\n    local Strongest = ''\n\
    \    local Strength = 0\n    for _, ext in pairs(extensions) do\n        local\
    \ Cap, SM = string.match(ext, '^([A-Z]+)([^A-Z]*)$') or {}, 0\n        if Cap:len()\
    \ > SM:len() then\n            SM, Cap = Cap, SM\n        end\n        local Strongest\
    \ = string.gsub(class_name .. '.' .. ext, '^%s+', '') or ''\n        if Cap:len()\
    \ - SM:len() > Strrength then\n            Strongest = Cap:sub(1, Cap:len()-SM:len())\
    \ .. Strongest .. SM:sub(1, SM:len())\n            Strongest = string.gsub(Strongest,\
    \ '^(.-)(.-)$', '\\1\\2') or Strongest\n        end\n        local Strongest =\
    \ string.gsub(Strongest, '([A-Z]+)([^A-Z]+)$', '\\1\\2') or Strongest\n      \
    \  Strrength = Cap:len() - SM:len() + Strrength\n    end\n    return Strongest\n\
    end", "  local strong_extensions = {}\n  for _, extension in ipairs(extensions)\
    \ do\n    local letters = string.gsub(extension, \"[A-Z]\", \"\")\n    local numbers\
    \ = string.gsub(extension, \"[a-z]\", \"\")\n    local cap = string.len(letters)\n\
    \    local sm = string.len(numbers)\n    local strength = math.max(0, cap - sm)\n\
    \    if string.sub(extension, 1, 1) ~= string.sub(class_name, 1, 1) then\n   \
    \   table.insert(strong_extensions, {letters, numbers, strength})\n    end\n \
    \ end\n  if #strong_extensions > 1 then\n    table.sort(strong_extensions, function(a,\
    \ b)\n      return a.strength > b.strength\n    end\n    function(_, _) return\
    \ strong_extensions[1].letters end\n  else\n    return strong_extensions[1].letters\n\
    \  end\nend", "  local strongest_extensions = { }\n  local number_of_extensions\
    \ = #extensions\n  local number_of_upper_case_letters = 0\n  local number_of_lower_case_letters\
    \ = 0", "\tlocal caps = #class_name:gsub('%W','')\n\tlocal sms = #class_name:gsub('%w','')\n\
    \tlocal cap,sm,strength\n\tlocal max = 0\n\tfor i,e in ipairs(extensions) do\n\
    \t\tcap = #e:gsub('%W','')\n\t\tsm = #e:gsub('%w','')\n\t\tstrength = cap-sm\n\
    \t\tif strength > max then\n\t\t\tmax = strength\n\t\t\tcap = caps\n\t\t\tsm =\
    \ sms\n\t\tend\n\tend\n\treturn class_name .. '.' .. extensions[#extensions]\n\
    end", "    if not extensions then\n        return 'my_class'\n    end", "   local\
    \ strongest_extension = nil\n   local extension_strength = -1\n   for i, extension_name\
    \ in ipairs(extensions) do\n      local extension_strength_found = false\n   \
    \   for i, extension_name in ipairs(extensions) do\n         if extension_strength_found\
    \ == true then\n            break\n         end\n         if extension_strength_found\
    \ == false then\n            if extension_strength == -1 then\n              \
    \ extension_strength = extension_strength_found\n               strongest_extension\
    \ = extension_name\n               break\n            elseif extension_strength\
    \ == 0 then\n               extension_strength = extension_strength_found\n  \
    \             strongest_extension = extension_name\n               break\n   \
    \         else\n               extension_strength = extension_strength_found\n\
    \               strongest_extension = extension_name\n               break\n \
    \           end\n         end\n         extension_strength_found = i==#extensions\n\
    \      end\n   end\n   return (class_name .. '.' .. strongest_extension)\nend\n\
    </cell>\n<text>\nPart 2 - The Autoroller Interface", "  local class = class_name:upper():gsub(\"\
    .\", \"\")\n  for _, extension in pairs(extensions) do\n    local length = #extension\n\
    \    local cap = #extension:upper()\n    local sm = #extension:lower()\n    if\
    \ length == cap then\n      -- Same length\n      if cap - sm > 0 then\n     \
    \   return string.format('%s.%s', class, extension)\n      else\n        return\
    \ string.format('%s.%s', class, extension:sub(1, cap - sm))\n      end\n    elseif\
    \ length < cap then\n      -- Smaller length\n      if cap - sm > 0 then\n   \
    \     return string.format('%s.%s', class, extension:sub(1, cap - sm))\n     \
    \ else\n        return string.format('%s.%s', class, extension)\n      end\n \
    \   end\n  end\n  return nil\nend", "  local StrongestExtensionName = class_name\
    \ .. '.' .. extensions[1]\n  for i=2,#extensions do\n    if (StrongestExtensionName\
    \ == class_name .. '.' .. extensions[i]) then \n      StrongestExtensionName =\
    \ class_name .. '.' .. extensions[i]\n    elseif (StrongestExtensionName == class_name\
    \ .. '.' .. extensions[#extensions]) then\n      -- The class has already been\
    \ chosen. \n      return\n    else\n      -- Add up the contribution of the extensions.\n\
    \      StrongestExtensionName = StrongestExtensionName .. '.' .. extensions[i]\n\
    \    end\n  end\n  -- If there are no more extensions, return the class name with\
    \ \n  -- all letters uppercase if the class is empty.\n  if #extensions == 0 then\
    \ \n    return class_name .. '.' .. string.upper(string.sub(class_name, 1, #class_name))\n\
    \  end\n  -- Return the class name with all the letters uppercase if the class\n\
    \  -- name has more than 1 extension.\n  if #extensions > 1 then\n    return class_name\
    \ .. '.' .. string.upper(string.sub(class_name, 1, #class_name))\n  end\n  return\
    \ StrongestExtensionName\nend", "\tlocal capitals = 0\n\tlocal smalls = 0\n\t\
    local strength = -1\n\tlocal extensions_lower = {}\n\tfor _, extension in pairs(extensions)\
    \ do\n\t\tlocal lower = string.lower(extension)\n\t\tif lower ~= \"\" then\n\t\
    \t\ttable.insert(extensions_lower, lower)\n\t\tend\n\tend\n\tlocal extensions_upper\
    \ = {}\n\tfor _, extension in pairs(extensions) do\n\t\tlocal upper = string.upper(extension)\n\
    \t\tif upper ~= \"\" then\n\t\t\ttable.insert(extensions_upper, upper)\n\t\tend\n\
    \tend\n\tlocal lowest_extension = nil\n\tfor _, extension in pairs(extensions_lower)\
    \ do\n\t\tif lowest_extension == nil then\n\t\t\tlowest_extension = extension\n\
    \t\t\tcontinue\n\t\telse\n\t\t\tif lowest_extension < extension then\n\t\t\t\t\
    lowest_extension = extension\n\t\t\tend\n\t\tend\n\tend\n\tfor _, extension in\
    \ pairs(extensions_upper) do\n\t\tif lowest_extension == nil then\n\t\t\tlowest_extension\
    \ = extension\n\t\t\tcontinue\n\t\telse\n\t\t\tif lowest_extension < extension\
    \ then\n\t\t\t\tlowest_extension = extension\n\t\t\tend\n\t\tend\n\tend\n\tlocal\
    \ total_capitals = 0\n\tlocal total_smalls = 0\n\tfor _, extension in pairs(extensions)\
    \ do\n\t\tlocal lower = string.lower(extension)\n\t\tif lower ~= \"\" then\n\t\
    \t\ttotal_capitals = total_capitals + #lower\n\t\tend\n\t\tlocal upper = string.upper(extension)\n\
    \t\tif upper ~= \"\" then\n\t\t\ttotal_smalls = total_smalls + #upper\n\t\tend\n\
    \tend\n\tlocal cap = total_capitals / #extensions_lower\n\tlocal sm = total_smalls\
    \ / #extensions_upper\n\tif cap - sm == 0 then\n\t\t-- The list has no duplicates\n\
    \t\t-- Return all extensions in sorted order\n\t\tlocal extensions_sorted = {}\n\
    \t\tfor _, extension in pairs(extensions) do\n\t\t\ttable.insert(extensions_sorted,\
    \ extension)\n\t\tend\n\t\ttable.sort(extensions_sorted)\n\t\treturn class_name\
    \ .. '_' .. table.concat(extensions_sorted, '.')\n\telse\n\t\tlocal cap_diff =\
    \ cap - sm\n\t\t-- The list has duplicates\n\t\t-- Return all extensions in sorted\
    \ order and choose the one that comes first\n\t\tlocal extensions_sorted = {}\n\
    \t\tlocal cap_extensions_sorted = {}\n\t\tfor _, extension in pairs(extensions)\
    \ do\n\t\t\tlocal lower = string.lower(extension)\n\t\t\tif lower ~= \"\" then",
  "   local strongest_extension = {}\n   local total = 0\n   local max_extension_strength\
    \ = -1\n   local max_extension_strongest = \"\"\n   for _, extension in ipairs(extensions)\
    \ do\n      local ext = string.lower(extension)\n      local cap = #ext:upper()\
    \ - 1\n      local sm = #ext:lower() - 1\n      local score = math.abs(cap - sm)\n\
    \      if score > max_extension_strength then\n         max_extension_strength\
    \ = score\n      end\n      if score == max_extension_strength then\n        \
    \ local idx = #strongest_extension\n         local strongest_extension_str = class_name\
    \ .. '.' .. ext\n         strongest_extension[idx] = strongest_extension_str\n\
    \         total = total + 1\n      end\n   end\n   if total > 0 then\n      max_extension_strongest\
    \ = max_extension_strongest .. '.' .. string.reverse(string.rep('.', #strongest_extension))\n\
    \   end\n   return strongest_extension[max_extension_strength]\nend\n</code>\n\
    <|/ a dscore=2 tags=lua |>\n<| c |>\nThat's a really interesting solution. +1\
    \ from me.\n<|/ c |>\n<| a tags=lua |>\nThis is my attempt of doing it. I only\
    \ tested it on English text, so I'm not sure about how it will work on other languages.\n\
    <code>", "  -- Write your code here.\n  local max_strength = -1 -- The highest\
    \ strength of the extensions\n  local max_extension = nil -- The extension with\
    \ the highest strength\n  for _, extension in ipairs(extensions) do -- For each\
    \ extension in the list\n    local extension_strength = string.lower(extension:sub(1,\
    \ 1))  -- Get the first letter\n    local extension_class = class_name .. \".\"\
    \ .. extension -- Add the extension\n    local extension_strength_str = extension_strength\
    \ .. string.lower(extension:sub(2)) -- Get the second letter\n    if max_strength\
    \ == -1 or extension_strength_str > max_strength then\n      max_strength = extension_strength_str\
    \ -- The extension is better than before\n      max_extension = extension_class\
    \ -- The extension is better than the previous one\n    end\n  end\n  return max_extension\n\
    end", "  assert(type(extensions) ~= 'table', 'Argument should be a table')\n \
    \ local strongest_extension = nil\n  for _, extension in ipairs(extensions) do\n\
    \    assert(type(extension) ~= 'string', 'Extension should be a string')\n   \
    \ -- Strength of extension\n    local count = #extension:gsub('[A-Z]', ''):match('^(.-)..')\n\
    \    if strongest_extension == nil or count == 0 then\n      -- If the first extension\
    \ has a zero strength, set strongest_extension to the extension itself\n     \
    \ strongest_extension = extension\n    elseif count == 1 then\n      -- If there\
    \ are two or more extensions with the same strength, choose the one that comes\
    \ first in the list\n      strongest_extension = extensions[1]\n      break\n\
    \    else\n      -- Otherwise, choose the extension with the greater strength\n\
    \      if count > strongest_extension:match('^(.-)..') then\n        strongest_extension\
    \ = extension\n      end\n    end\n  end\n  return string.format(class_name..'.%s',\
    \ strongest_extension)\nend", "    -- Add your code here\n    local max_strength\
    \ = -1\n    local max_extension = ''\n    for i,ext in ipairs(extensions) do\n\
    \        local cap, sm = string.match(ext, \"%c?(%w+)\")\n        local strength\
    \ = cap - sm\n        if strength > max_strength then\n            max_extension\
    \ = ext\n            max_strength = strength\n        end\n    end\n    return\
    \ string.sub(class_name,1,string.len(class_name)-string.len(max_extension))..max_extension\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a simple solution without\
    \ using additional libraries.\n<code>", "  local strongest = {}\n  local ext\n\
    \  for _, ext in ipairs(extensions) do\n    local count = tonumber( string.match(class_name,\
    \ ext:sub(1, -2)) )\n    if count > 0 then\n      if strongest[count] then\n \
    \       strongest[count] =  strongest[count] .. '.' .. ext\n      else\n     \
    \   strongest[count] =  ext\n      end\n    end\n  end\n  -- sort by descending\
    \ strength\n  table.sort(strongest, function(a, b)\n    if a:sub(-2) == b:sub(-2)\
    \ then\n      return -1\n    else\n      return b:sub(-2) - a:sub(-2)\n    end\n\
    \  end)\n  return strongest[1]\nend", "   \n   if extensions.count == 0 then\n\
    \      print(\"No extensions to load\")\n      return nil\n   end\n   \n   local\
    \ str_extension = {}\n   \n   for i,ext,extension_count in ipairs(extensions)\
    \ do\n      if class_name == ext:gsub(\".\",\"\") then\n         table.insert(str_extension,ext)\n\
    \      end\n      if extension_count == 2 then\n         if str_extension[1] <\
    \ str_extension[2] then\n            table.insert(str_extension,ext)\n       \
    \  end\n      end\n      if extension_count == 3 then\n         if str_extension[1]\
    \ < str_extension[2] and str_extension[2] < str_extension[3] then\n          \
    \  table.insert(str_extension,ext)\n         end\n      end\n   end\n   \n   if\
    \ #str_extension == 1 then\n      return str_extension[1]\n   else\n      return\
    \ nil\n   end\nend", "  local max_strength = -1 -- The maximum strength of the\
    \ extension\n  local best_extension -- The extension with the maximum strength\n\
    \  for _, extension in ipairs(extensions) do\n    -- Get the strength of the extension\n\
    \    local extension_strength = string.gsub(extension, \"[A-Z]\", \"1\")\n   \
    \ -- If the extension's strength is greater than the maximum strength, \n    --\
    \ then update the maximum strength and the best extension\n    if extension_strength\
    \ > max_strength then\n      max_strength = extension_strength\n      best_extension\
    \ = extension\n    end\n  end\n  return class_name .. \".\" .. best_extension\n\
    end", "   local max_strength = extensions[1] - extensions[0] + 1\n   for i = 2,\
    \ #extensions do\n      if max_strength > extensions[i] - extensions[i-1] then\n\
    \         max_strength = extensions[i] - extensions[i-1]\n      end\n   end\n\
    \   return class_name .. '.' .. extensions[#extensions]\nend", "   for i = 1,\
    \ #extensions do\n       local name_part = extensions[i]:match('^([A-Z]*)$')\n\
    \       local name_part_upper = name_part:upper()\n       local name_part_lower\
    \ = name_part:lower()\n       if name_part_upper == name_part_lower then\n   \
    \        return class_name .. '.' .. name_part\n       else\n           local\
    \ strength_upper = #name_part_upper\n           local strength_lower = #name_part_lower\n\
    \           if strength_upper > strength_lower then\n               return class_name\
    \ .. '.' .. name_part\n           else\n               return class_name .. '.'\
    \ .. name_part .. '_' .. name_part_upper:sub(0, strength_lower)\n           end\n\
    \       end\n   end\nend", "  local exts = {}\n  for _, b in pairs(extensions)\
    \ do\n    table.insert(exts, b)\n  end\n  table.sort(exts, function(a, b) return\
    \ a:upper() - b:upper() end)\n  local strength = -1\n  for i=1,#exts do\n    if\
    \ exts[i] == class_name then\n      strength = i - 1\n    end\n  end\n  if strength\
    \ == -1 then strength = #extensions end\n  return class_name .. '.' .. extensions[strength]\n\
    end", "  if #extensions == 0 then\n    return class_name\n  end\n  local max =\
    \ -1\n  local max_extension = \"\"\n  for _, extension in ipairs(extensions) do\n\
    \    local cap = str:upper(extension:sub(1, #extension))\n    local sm = str:lower(extension:sub((#extension\
    \ + 1), #extension))\n    local strongest_extension = class_name .. \".\" .. extension\
    \ .. \n      str:lower(cap - sm)\n    if max < str:len(strongest_extension) then\n\
    \      max = str:len(strongest_extension)\n      max_extension = strongest_extension\n\
    \    end\n  end\n  return max_extension\nend", "\tlocal caps = 0\n\tlocal sm =\
    \ 0\n\tfor _, extension in pairs(extensions) do\n\t\tcaps = caps + math.floor(#extension:upper())\n\
    \t\tsm = sm + math.floor(#extension:lower())\n\tend\n\treturn (class_name .. \"\
    .\" .. extensions[1]):match(\"%.\"..(caps-sm)..\"([A-Z])\")\nend", "  local max_strength\
    \ = -math.inf\n  local max_class = nil\n  for _, extension in ipairs(extensions)\
    \ do\n    local class_index = string.find(class_name, extension)\n    if class_index\
    \ ~= nil then\n      local strength = string.sub(class_name, class_index+1)\n\
    \      if strength > max_strength then\n\tmax_strength = strength\n\tmax_class\
    \ = class_index\n      end\n    end\n  end\n  return string.sub(class_name, 1,\
    \ max_class + 1)\nend", "  -- Write your code here.\nend", "    local strongest\
    \ = nil\n    local count = nil\n    for _,e in ipairs(extensions) do\n       \
    \ local cap = string.upper(e:sub(1, 1))\n        local sm = string.lower(e:sub(2,\
    \ 2))\n        if cap-sm > 0 then\n            count = cap-sm\n            if\
    \ strongest == nil or count > strongest.count then\n                strongest\
    \ = class_name..'.'..e\n            end\n        end\n    end\n    return strongest\n\
    end", "\tlocal counter = {}\n\tfor _,extension in ipairs(extensions) do\n\t\t\
    local cap = extension:gsub('%^..', ''):match('%A..')\n\t\tlocal sm = extension:gsub('%%.',\
    \ ''):match('%a..')\n\t\tcounter[(cap - sm) * -1] = extension\n\tend\n\tlocal\
    \ result = ''\n\tlocal max = 1\n\tfor k,v in pairs(counter) do\n\t\tif max < v\
    \ then\n\t\t\tmax = v\n\t\t\tresult = k\n\t\tend\n\tend\n\treturn result .. '.'\
    \ .. class_name\nend", "  return assert(load(class_name, \"return \" .. class_name\
    \ .. \".\" .. extensions[math.random(#extensions)])())\nend", "\tlocal strongest_extensions\
    \ = {}\n\tfor _, extension in ipairs(extensions) do\n\t\tlocal cap = string.upper(extension):byte()\n\
    \t\tlocal sm = string.lower(extension):byte()\n\t\tlocal strength = cap-sm\n\t\
    \tif strength > 0 then\n\t\t\ttable.insert(strongest_extensions, {cap, extension,\
    \ strength})\n\t\tend\n\tend\n\ttable.sort(strongest_extensions, function(a,b)\
    \ return a.strength < b.strength end)\n\tfor _, extension in ipairs(strongest_extensions)\
    \ do\n\t\tif string.sub(class_name, 1, string.len(extension.extension))==extension.extension\
    \ then\n\t\t\treturn string.sub(class_name, string.len(extension.extension)+1)\n\
    \t\tend\n\tend\n\treturn false\nend", "  local strongest = 0\n  local extension_classes\
    \ = {}\n  for _, extension in ipairs(extensions) do\n    if string.find(extension,\
    \ \"[A-Z]\") ~= nil then\n      local extension_class = class_name .. \".\" ..\
    \ extension\n      table.insert(extension_classes, extension_class)\n    end\n\
    \  end\n  for _, extension_class in ipairs(extension_classes) do\n    local count\
    \ = #string.gsub(extension_class, \"[A-Z]\", \"\")\n    if count > strongest then\n\
    \      strongest = count\n    end\n  end\n  return class_name .. \".\" .. extensions[strongest]\n\
    end", "   local max_strength = #extensions\n   local extensions_map = {}\n   for\
    \ _, extension in pairs(extensions) do\n      local extension_class = string.sub\
    \ (extension, 1, 2)\n      local extension_strength = string.sub (extension, 3,\
    \ 4)\n      if not (extension_class in extensions_map) then\n         extensions_map[extension_class]\
    \ = {}\n      end\n      if not (extension_strength in extensions_map[extension_class])\
    \ then\n         extensions_map[extension_class][extension_strength] = 1\n   \
    \   else\n         extensions_map[extension_class][extension_strength] = extensions_map[extension_class][extension_strength]\
    \ + 1\n      end\n   end\n   -- sort by strength\n   for _, map in pairs(extensions_map)\
    \ do\n      table.sort (map, function(a, b) return a[2] > b[2] end)\n   end\n\
    \   -- return the extension with the highest strength\n   if max_strength == 1\
    \ then\n      return false\n   elseif max_strength == 2 then\n      return false\n\
    \   elseif max_strength == 3 then\n      return true\n   else\n      for _, map\
    \ in pairs(extensions_map) do\n         if map[1] == max_strength then\n     \
    \       return string.sub (class_name, 1, string.len (class_name)-1) .. map[2]\n\
    \         end\n      end\n   end\nend", "\tlocal class_name_len = #class_name\n\
    \tlocal max_extension_strength = -1\n\tlocal max_extension_extension = 'UNKNOWN'\n\
    \t\n\tfor _, extension in ipairs(extensions) do\n\t\tlocal class_extension_len\
    \ = #extension\n\t\tlocal class_extension = extension:upper()", "  local class\
    \ = class_name -- Copy class name.\n  local extension_count = #extensions -- Count\
    \ the number of extensions.\n  local extension_strengths -- Keep track of extension\
    \ strengths.\n  extension_strengths = {}\n  for _, extension in ipairs(extensions)\
    \ do -- For each extension.\n    local strength = string.sub(extension, 1, 1):upper()\
    \ - string.sub(extension, 2, 1):lower() + 1 -- Get extension's strength.\n   \
    \ if not extension_strengths[strength] then\n      extension_strengths[strength]\
    \ = {} -- Initialize extension_strengths with new strength.\n    end\n    table.insert(extension_strengths[strength],\
    \ extension)\n  end\n  local best_strength = -1 -- Initialize best_strength with\
    \ -1.\n  -- For each strength:\n  for _, strength in ipairs(extension_strengths)\
    \ do -- For each strength.\n    -- If the current strength is better than best_strength:\n\
    \    if strength > best_strength then\n      -- Set the best strength:\n     \
    \ best_strength = strength\n      -- Set the class with the highest strength:\n\
    \      class = class_name .. '.' .. table.concat(extension_strengths[strength],\
    \ '.')\n    end\n  end\n  return class\nend", "\tlocal num_capitals = {}\n\tlocal\
    \ num_lowercases = {}\n\tfor _, extension in ipairs(extensions) do\n\t\tfor i,\
    \ c in ipairs(extension) do\n\t\t\t-- Ignore capital letters.\n\t\t\tif c == 'A'\
    \ or c == 'B' or c == 'C' then\n\t\t\t\tnum_capitals[i] = num_capitals[i] + 1\n\
    \t\t\telse\n\t\t\t\tnum_lowercases[i] = num_lowercases[i] + 1\n\t\t\tend\n\t\t\
    end\n\tend\n\t-- Count the number of times a certain number of letters appear\
    \ in the class.\n\tlocal c = {}\n\tfor i = 1, #extensions do\n\t\tc[i] = #(extensions[i])\n\
    \tend\n\t-- Calculate the strength of the extension.\n\tlocal min_length = #class_name\
    \ \n\tfor i = 1, #extensions do\n\t\tmin_length = math.min(min_length, #(extensions[i]))\
    \ \n\tend\n\t-- Find the longest extension that is equal or greater than min_length.\n\
    \tlocal max_strength = -1\n\tfor i = 1, #extensions do\n\t\tif c[i] >= min_length\
    \ then\n\t\t\tif c[i] >= max_strength then\n\t\t\t\tmax_strength = c[i]\n\t\t\t\
    end\n\t\tend\n\tend\n\t-- Select the extension with the highest strength.\n\t\
    local max_extension = {}\n\tfor i = 1, #extensions do\n\t\tif c[i] > max_strength\
    \ then\n\t\t\tmax_extension = {max_extension, extensions[i]}\n\t\tend\n\tend\n\
    \treturn (class_name .. '_' .. max_strength) .. table.concat(max_extension, '.')\n\
    end", "   if #extensions <= 0 then \n      return \"\"\n   end\n   local cap_table\
    \ = {}\n   for i=1,#extensions do\n      cap_table[ tolower(extensions[i]) ] =\
    \ i\n   end\n   local strongest_extension = nil\n   local max_strength = -1\n\
    \   for i=1,#extensions do\n      if cap_table[extensions[i]] > max_strength then\n\
    \         max_strength = cap_table[extensions[i]]\n         strongest_extension\
    \ = extensions[i]\n      end\n   end\n   return string.sub(class_name,1,#class_name)..\"\
    .\"..strongest_extension\nend", "    assert(type(extensions) == \"table\", \"\
    Extensions should be a table.\")\n    assert(type(class_name) == \"string\", \"\
    class_name should be a string.\")\n    for i = 1, #extensions do\n        if extensions[i]\
    \ == '' then\n            extensions[i] = extensions[i+1]\n        end\n    end\n\
    \    local cap_ext = extensions:map(function(x) return x:find('[A-Z]')-1 end):sum()\n\
    \    local sm_ext = extensions:map(function(x) return x:find('[a-z]')-1 end):sum()\n\
    \    local strength = cap_ext - sm_ext\n    for i = 1, #extensions do\n      \
    \  if extensions[i] == '' then\n            extensions[i] = extensions[i+1]\n\
    \        end\n    end\n    local index = 1\n    local max_str = \"\"\n    local\
    \ max_strength = -1\n    while true do\n        index = index +1\n        if index\
    \ > #extensions then\n            break\n        end\n        local extension\
    \ = extensions[index]\n        if extension:find('[A-Z]') == -1 then\n       \
    \     index = index - 1\n        else\n            if extension:find('[a-z]')\
    \ == -1 then\n                index = index - 1\n            end\n        end\n\
    \        if extension:find('[A-Z]') == -1 then\n            index = index - 1\n\
    \        else\n            if extension:find('[a-z]') == -1 then\n           \
    \     index = index - 1\n            end\n        end\n    end\n    for i = 1,\
    \ #extensions do\n        if extensions[i] == '' then\n            extensions[i]\
    \ = extensions[i+1]\n        end\n    end\n    extensions[index] = extensions[index+1]\n\
    \    local strongest_extension = class_name .. \"_\" .. extensions[index]\n  \
    \  if max_strength > strength then\n        max_str = \"\"\n        max_strength\
    \ = -1\n    end\n    if max_strength == -1 then\n        max_str = strongest_extension\n\
    \    else\n        if max_strength < 0 then\n            max_str = class_name\
    \ .. \".\" .. max_str\n        else\n            max_str = class_name .. \".\"\
    \ .. strongest_extension\n        end\n    end\n    return max_str\nend", "  \
    \  local caps = {}\n    local sms = {}\n    \n    for _, extension in ipairs(extensions)\
    \ do\n        local cap = string.sub(extension, 1, string.len(extension) - 2)\n\
    \        local sm = string.sub(extension, string.len(extension) - 1, string.len(extension))\n\
    \        \n        table.insert(caps, cap)\n        table.insert(sms, sm)\n  \
    \  end\n    \n    if #caps == 0 then\n        return nil\n    end\n    \n    local\
    \ strong_extension_strength = caps[#caps]\n    \n    for _, extension in ipairs(extensions)\
    \ do\n        local cap = string.sub(extension, 1, string.len(extension) - 2)\n\
    \        local sm = string.sub(extension, string.len(extension) - 1, string.len(extension))\n\
    \        \n        local cap_strength = caps[#caps]\n        local sm_strength\
    \ = sms[#sms]\n        \n        if cap_strength < strong_extension_strength then\n\
    \            strong_extension_strength = cap_strength\n        end\n        if\
    \ sm_strength < strong_extension_strength then\n            strong_extension_strength\
    \ = sm_strength\n        end\n    end\n    \n    return string.format(class_name\
    \ .. '.%s', strong_extension_strength)\nend", "  local strongest = nil\n  local\
    \ max_strength = -1\n  for _, extension in ipairs(extensions) do\n    local capitals\
    \ = string.sub(s, 1, string.len(extension))\n    local lowercases = string.sub(s,\
    \ string.len(extension))\n    local strength = capitals - lowercases\n    if strength\
    \ > max_strength then\n      max_strength = strength\n      strongest = extension\n\
    \    end\n  end\n  return class_name .. '.' .. strongest\nend", "   local cap_extensions\
    \ = {}\n   for _, extension in ipairs(extensions) do\n      cap_extensions[#cap_extensions\
    \ + 1] = cap_extensions[#cap_extensions] ..\n         string.upper(extension:sub(1,\
    \ 1)) - string.lower(extension:sub(1, 1)) .. \n         extension:sub(2)\n   end\n\
    \   local sm, strength = 1, 0\n   for _, extension in ipairs(extensions) do\n\
    \      local cap = string.upper(extension:sub(1, 1)) -\n         string.lower(extension:sub(1,\
    \ 1))\n      local sm = cap - string.upper(extension:sub(1, 1))\n      if sm *\
    \ strength < cap * strength then\n         strength = sm * strength\n        \
    \ cap_extensions[#cap_extensions+1] = extension\n      end\n   end\n   local index\
    \ = #cap_extensions + 1\n   return (class_name .. '.' .. cap_extensions[index]\
    \ .. '.' .. \n            cap_extensions[#cap_extensions])\nend", "  local max_strength\
    \ = 0\n  local max_index = 0\n  for i, e in ipairs(extensions) do\n    local strength\
    \ = string.upper(class_name):find(string.upper(e):gsub(\"%a\", \"\"))\n    if\
    \ strength == nil then\n      return nil\n    end\n    if strength > 0 then\n\
    \      if strength > max_strength then\n        max_strength = strength\n    \
    \    max_index = i\n      end\n    end\n  end\n  return string.sub(class_name,\
    \ max_index + 1, string.len(class_name))\nend", "   local Strength = -math.inf\n\
    \   local Strong_extension = nil\n   for _, extension in ipairs(extensions) do\n\
    \      local count, letters = count_letters(extension)\n      if not Strong_extension\
    \ or (letters - Strength > letters - count_letters(Strong_extension)) then\n \
    \        Strong_extension = extension\n         Strength = letters\n      end\n\
    \   end\n   return class_name .. '.' .. Strong_extension\nend\n</cell>\n<cell>",
  "\tlocal extension_strengths = {}\n\tfor i, extension in ipairs(extensions) do\n\
    \t\tlocal c = table.remove(extension)\n\t\tlocal cap = #c + 1\n\t\tlocal sm =\
    \ #c + 2\n\t\tlocal p = cap - sm\n\t\textension_strengths[extension] = p\n\tend\n\
    \tlocal max_strength = -1\n\tlocal max_extension = ''\n\tfor ext, strength in\
    \ pairs(extension_strengths) do\n\t\tif strength > max_strength then\n\t\t\tmax_strength\
    \ = strength\n\t\t\tmax_extension = ext\n\t\tend\n\tend\n\treturn (class_name\
    \ .. '.' .. max_extension)\nend", "    local cap_class_name, cap_extensions =\
    \ string.match(class_name, '^(..?)(..?)(.*)$'), '%2'.. string.gsub(extensions,\
    \ '%.', '%s%2')\n    return cap_class_name .. '.' .. cap_extensions[(cap_extensions:match('.-'):gsub('.',''))..'']\n\
    end", "  -- Your code here\nend", "    local map = {}\n    for _, ext in ipairs(extensions)\
    \ do\n        local cap = string.match(ext, \"^[A-Z]\")\n        local sm = string.match(ext,\
    \ \"^[a-z]\")\n        if not map[cap - sm] then\n            map[cap - sm] =\
    \ ext\n        end\n    end\n    return map[#map]\nend", "    if #extensions ==\
    \ 0 then return nil end\n    local strongest_extension = nil\n    local strength\
    \ = nil\n    for _, extension in pairs(extensions) do\n        if extension:sub(1,\
    \ 1):upper() ~= extension:sub(1, 1):lower() then\n            -- TODO: Return\
    \ strongest extension\n            -- strongest_extension = extension\n      \
    \      -- strength = -1\n        end\n    end\n    -- TODO: Return strongest extension\n\
    \    return strongest_extension\nend", "\tassert(class_name)\n\tassert(extensions)\n\
    \tlocal max = 0\n\tfor _, extension in ipairs(extensions) do\n\t\tlocal _, count\
    \ = get_count_by_upper(extension)\n\t\tif count > max then\n\t\t\tmax = count\n\
    \t\t\tlocal _, _, extension_name = splitn(extension, ' ')\n\t\t\tlocal new_extension\
    \ = class_name .. \".\" .. extension_name\n\t\t\tassert(new_extension)\n\t\t\t\
    assert(new_extension ~= extension)\n\t\t\tassert(count >= 0)\n\t\tend\n\tend\n\
    \treturn max == 0 and extensions[0] or nil\nend", "    local strengths = {}\n\
    \    for _, extension in ipairs(extensions) do\n        local c = class_name:sub(1,-#extension)\n\
    \        local s = strengths[c]\n        local i = #extension \n        while\
    \ i > 1 do\n            if s:sub(1,-1) < strengths[extension:sub(1,-i)]:sub(1,-1)\
    \ then\n                s = s:sub(1,-1) + strengths[extension:sub(1,-i)]\n   \
    \         else\n                s = s:sub(1,-1) + extension:sub(1,-i)\n      \
    \      end\n            i = i - 1\n        end\n        if s:sub(1,-1) > 0 then\n\
    \            table.insert(strengths, s)\n        end\n    end\n    table.sort(strengths,\
    \ function(a,b) return a:sub(1,-1) < b:sub(1,-1) end)\n    return class_name:sub(1,-#strengths[#strengths]-1)\n\
    end", "  local extensions_count = #extensions\n  local extension_classes = {}",
  "\tlocal strength = nil\n\tlocal strongest = nil\n\tfor _, extension in ipairs(extensions)\
    \ do\n\t\tlocal c = string.lower(extension)\n\t\tlocal cap = string.upper(c):byte()\n\
    \t\tlocal sm = string.lower():byte()\n\t\tlocal diff = cap - sm\n\t\tif strongest\
    \ == nil or diff < 0 then\n\t\t\tstrongest = extension\n\t\t\tstrength = -1\n\t\
    \telseif diff == 0 then\n\t\t\tassert(cap >= sm)\n\t\t\tstrength = cap - sm\n\t\
    \telse\n\t\t\tassert(cap >= sm)\n\t\t\tstrength = diff + (cap - sm)\n\t\tend\n\
    \tend\n\treturn string.sub(class_name, 1, string.len(class_name)-#strongest) +\
    \ strongest .. '.'\nend", "  local max_extension = nil\n  local max_strongest\
    \ = nil\n  for _, extension in pairs(extensions) do\n    if max_strongest == nil\
    \ or (extension_strength(extension) > max_strongest.strength) then\n      max_extension\
    \ = extension\n      max_strongest = {name = extension, strength = extension_strength(extension)}\n\
    \    end\n  end\n  return class_name .. '.' .. max_strongest.name\nend\n</code>\n\
    If you run your example code again you'll see that it does what you expect. Here's\
    \ an example output from your code:\n<code>\n> print(Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']))\nmy_class.Be\n> print(Strongest_Extension('my_class', ['AB',\
    \ 'be', 'cc']))\nmy_class.AB\n</code>\nAnd here's an example output from the code\
    \ I wrote (using the same input):\n<code>\n> print(Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']))\nmy_class.Be\n> print(Strongest_Extension('my_class', ['AB',\
    \ 'be', 'cc']))\nmy_class.AB\n</code>\n<|/ a |>\n<| c |>\nThanks for the detailed\
    \ answer. I did notice that you return max_strongest.name not max_strongest -\
    \ but I am not sure I understand why that would make a difference?\n<|/ c |>\n\
    <| c |>\nI believe the difference is because I used max_strongest as the strongest\
    \ extension before I had a chance to look at what it contained so I chose to return\
    \ that instead of max_strongest.name since name would be an empty string.\n<|/\
    \ c |>\n<| c |>\nThanks for your explanation, I understand it now. I think you\
    \ also could have used max_strongest.name instead of max_strongest and just returned\
    \ it since name would be an empty string anyway.\n<|/ c |>\n<| c |>\nI guess one\
    \ difference is `max_strongest.name` allows you to do something like `print(Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']).name)`, whereas you can't do that with `max_strongest` (i.e.\
    \ `print(max_strongest.name)`). Hmm, that's a bit tricky since both `max_strongest`\
    \ and `max_strongest.name` point to the same object :)\n<|/ c |>\n<| c |>\nHmm,\
    \ thats true. I thought that if you call max_strongest and try to call .name you\
    \ would get an error but that isn't the case. So that makes sense to me.\n<|/\
    \ c ", "    local function Sort_Extensions(extensions)\n        local temp = {}\n\
    \        for _, extension in pairs(extensions) do\n            table.insert(temp,\
    \ extension)\n        end\n        table.sort(temp)\n        return temp\n   \
    \ end\n    local strongest = 0\n    local strongest_name = \"\"\n    for _, extension\
    \ in pairs(extensions) do\n        local strength = string.match(extension, '^(.)..(%[A-z])(%[A-z])(%[A-z])(%[A-z])(%[A-z])$')\n\
    \        if strength then\n            if strongest < strength then\n        \
    \        strongest = strength\n                strongest_name = extension\n  \
    \          end\n        end\n    end\n    if strongest == 0 then\n        return\
    \ class_name\n    else\n        return class_name .. \".\" .. strongest_name\n\
    \    end\nend", "    local cap_strength, sm_strength = extension_strength(extensions)\n\
    \    if cap_strength == nil or sm_strength == nil then\n        return nil\n \
    \   end\n    if cap_strength == -1 and sm_strength == 1 then\n        return class_name\n\
    \    end\n    if cap_strength == -1 and sm_strength == 2 then\n        return\
    \ class_name .. '.' .. extensions[1]\n    end\n    if cap_strength == 1 and sm_strength\
    \ == 1 then\n        return class_name .. '.' .. extensions[1]\n    end\n    return\
    \ class_name .. '.' .. extensions[math.max(cap_strength,sm_strength)]\nend", " \
    \   local caps = #class_name\n    local sms = #class_name:lower():byte()\n   \
    \ return class_name:sub(1, caps-sms+1).\n\t\t  \tconcat('_'..extensions[#extensions]..'_').\n\
    \t\t  \tconcat(caps:byte() - sms:byte())\nend", "  local strength_sum = 0\n  local\
    \ highest_strength = -1\n  for _, extension in pairs(extensions) do\n    local\
    \ letter_count = extension:sub(1,1)\n    local letter_count_in_name = class_name:sub(1,letter_count)\n\
    \    local letter_count_in_extension = extension:sub(2)\n    local strength =\
    \ letter_count_in_extension:upper() - letter_count_in_name\n    local strength_percent\
    \ = ((strength + 0.0) / letter_count_in_name):float()\n    \n    if strength >\
    \ highest_strength or strength_percent > 0.9 then\n      highest_strength = strength\n\
    \    end\n  end\n  return class_name .. '.' .. extensions[#extensions]\nend",
  "\tlocal extension = extensions[1]\n\tfor i = 2, #extensions do\n\t\tlocal cap =\
    \ #extension:match('^[ABCDEFGHIJKLMNOPQRSTUVWXYZ]+$')\n\t\tlocal sm = #extension:match('^[abcdefghijklmnopqrstuvwxyz]+$')\n\
    \t\tif cap - sm == 0 then\n\t\t\textension = extensions[i]\n\t\t\tbreak\n\t\t\
    end\n\tend\n\tif extension == nil then\n\t\treturn nil\n\tend\n\tlocal cap = #extension:match('^[ABCDEFGHIJKLMNOPQRSTUVWXYZ]+$')\n\
    \tlocal sm = #extension:match('^[abcdefghijklmnopqrstuvwxyz]+$')\n\treturn string.format(class_name\
    \ .. '.%s%s', class_name:sub(1, cap), extension:sub(1, sm))\nend", "   local max\
    \ = 0\n   local strongest = 0\n   for i=1,#extensions do\n      local c = extensions[i]\n\
    \      local cap = c:sub(1, #c-1)\n      local sm = c:sub(cap+1, #c)\n      if\
    \ cap>sm then\n         max = cap-sm\n         strongest = i\n      end\n   end\n\
    \   return class_name .. '.' .. extensions[strongest] .. '\\n'\nend\n</cell>\n\
    <text>\nStronger Extensions\nWrite a function that returns the stronger extension\
    \ of a class.", "  -- BASE CASE: class name is empty\n  if #extensions == 0 then\n\
    \    return ''\n  end\n  -- BASE CASE: class name is not empty and contains only\
    \ uppercase letters\n  if not class_name:upper():match('^[A-Z]*$') then\n    return\
    \ ''\n  end\n  -- BASE CASE: class name is not empty and contains only lowercase\
    \ letters\n  if not class_name:lower():match('^[a-z]*$') then\n    return ''\n\
    \  end\n  -- BASE CASE: class name is not empty and contains only uppercase letters\
    \ and lowercase letters\n  if not class_name:upper():match('^[A-Z][a-z]*$') then\n\
    \    return ''\n  end\n  -- BASE CASE: class name is not empty and contains only\
    \ lowercase letters and uppercase letters\n  if not class_name:lower():match('^[a-z][A-Z]*$')\
    \ then\n    return ''\n  end\n  -- BASE CASE: class name is not empty and contains\
    \ only uppercase letters, lowercase letters\n  if not class_name:upper():match('^[A-Z][a-z]$')\
    \ then\n    return ''\n  end\n  -- BASE CASE: class name is not empty and contains\
    \ only lowercase letters, uppercase letters\n  if not class_name:lower():match('^[a-z][A-Z]$')\
    \ then\n    return ''\n  end\n  -- BASE CASE: class name is not empty and contains\
    \ only uppercase letters and lowercase letters\n  if not class_name:upper():match('^[A-Z][a-z]$')\
    \ then\n    return ''\n  end\n  -- BASE CASE: class name is not empty and contains\
    \ only lowercase letters, uppercase letters\n  if not class_name:lower():match('^[a-z][A-Z]$')\
    \ then\n    return ''\n  end\n  -- BASE CASE: class name is not empty and contains\
    \ only lowercase letters, uppercase letters and numbers\n  if not class_name:lower():match('^[a-z][A-Z][0-9]*$')\
    \ then\n    return ''\n  end\n  -- BASE CASE: class name is not empty and contains\
    \ only uppercase letters and lowercase letters\n  if not class_name:upper():match('^[A-Z][a-z]$')\
    \ then\n    return ''\n  end\n  -- BASE CASE: class name is not empty and contains\
    \ only uppercase letters and lowercase letters\n  if not class_name:upper():match('^[A-Z][a-z][0-9]*$')\
    \ then\n    return ''\n  end\n  -- BASE CASE: class name is not empty and contains\
    \ only uppercase letters, lowercase letters and numbers\n  if not class_name:upper():match('^[A-Z][0-9][a-z]*$')\
    \ then\n    return ''\n  end\n  -- BASE", "    local best_extension = nil\n  \
    \  local best_strength = nil\n    for _, extension in ipairs(extensions) do\n\
    \        local extension_strength = strongest(extension:lower():gsub(\"%l\",\"\
    \"))\n        if extension_strength ~= nil then\n            if best_extension\
    \ == nil or extension_strength > best_strength then\n                best_extension\
    \ = extension\n                best_strength = extension_strength\n          \
    \  end\n        end\n    end\n    return class_name .. '.' .. best_extension\n\
    end", "\tlocal max_strength = -1\n\tlocal max_extension = \"\"\n\tlocal max_count\
    \ = 0\n\tfor _, extension in ipairs(extensions) do\n\t\tlocal extension_upper\
    \ = upper(extension)\n\t\tlocal extension_lower = lower(extension)\n\t\tlocal\
    \ extension_diff = extension_upper - extension_lower\n\t\tlocal strength_of_extension\
    \ = math.abs(extension_diff)\n\t\tif strength_of_extension > max_strength then\n\
    \t\t\tmax_strength = strength_of_extension\n\t\t\tmax_extension = extension\n\t\
    \t\tmax_count = #extension\n\t\telseif strength_of_extension == max_strength then\n\
    \t\t\tmax_count = max_count + 1\n\t\tend\n\tend\n\t\n\tif max_count > 1 then\n\
    \t\treturn class_name .. \".\" .. max_extension\n\tend\n\treturn max_extension\n\
    end", "    local cap = {}\n    local sm = 0\n    for _,e in ipairs(extensions)\
    \ do\n        cap[#cap + 1] = e:upper()\n        sm = #cap + 1\n    end\n    \n\
    \    local strength = cap - sm\n    \n    for _,e in ipairs(extensions) do\n \
    \       local cap = #cap + 1\n        local sm = #cap + 1\n        local sc =\
    \ cap - sm\n        if sc < strength then\n            strength = sc\n       \
    \ end\n    end\n    return class_name .. '.' .. extensions[math.min(strength,#extensions)]\n\
    end", "  assert(type(extensions) == \"table\")\n  local min_strength = -1\n  local\
    \ max_extension = \"\"\n  for i = 1,#extensions do\n    local extension = GetExtension(class_name,\
    \ extensions[i])\n    if extension.strength == nil then\n      extension.strength\
    \ = -1\n    end\n    if extension.strength >= min_strength then\n      if extension.strength\
    \ > max_strength then\n        max_extension = extensions[i]\n      end\n    elseif\
    \ extension.strength < min_strength then\n      min_strength = extension.strength\n\
    \      if extension.strength < min_strength then\n        max_extension = extensions[i]\n\
    \      end\n    end\n  end\n  return GetExtension(class_name, max_extension)\n\
    end", "  local StrongestExtension = {}\n  for _, extension in ipairs(extensions)\
    \ do\n    if extension:match(\"^[A-Z]\") then\n      local n = #(extension)\n\
    \      local c = extension:sub(1, n-1)\n      local m = extension:sub(n-1, n)\n\
    \      local strength = -1\n      for _, c in pairs(classes) do\n        if c['Name']\
    \ == class_name then\n          local cap = #c['Extension']\n          local sm\
    \ = #c['Extension']\n          local p = (cap - sm)/cap\n          local s = (p\
    \ + c['Extension'][cap-1])^m\n          if s == strength then\n            strength\
    \ = s\n            StrongestExtension = c['Name'] .. '.' .. c['Extension']\n \
    \         end\n        end\n      end\n    end\n  end\n  return StrongestExtension\n\
    end", "    local caps = 0\n    local sms = 0\n    local max_caps = -99999\n  \
    \  local max_sms = -99999\n    for _, extension in ipairs(extensions) do\n   \
    \     local cap = #extension:match(\"%u\")\n        local sm = #extension:match(\"\
    %l\")\n        if cap > max_caps then max_caps = cap end\n        if sm > max_sms\
    \ then max_sms = sm end\n        caps = caps + cap\n        sms = sms + sm\n \
    \   end\n    return class_name .. \".\" .. extensions[caps - sms + 1]\nend\n</cell>\n\
    <text>\nExercise 3\nIn the function below write a function called Split_Lines()\
    \ that receives one argument -- a line as string, splits it into words, and returns\
    \ a list of words. \nYour function should return a list of words. If a word does\
    \ not contain any non-alphabetic characters, \nit is considered a word. \nIf it\
    \ contains multiple non-alphabetic characters, return a list of words with the\
    \ \nalphabetically first letter as its first element in the list. \nIf it contains\
    \ only alphabetic characters, return a list of words with the alphabetically first\
    \ letter as its first \nelement in the list.\nThe function should throw an error\
    \ if the input string is not a string.\nIn the cell below use the function defined\
    \ above to split and print a list of words of the input string\n'Hello World!'\
    \ and the print them in the cell below using an internal function called Print()\
    \ defined above. ", "  local strongest_extensions = {}\n  for _, extension in\
    \ ipairs(extensions) do\n    local cap = string.upper(extension)\n    local sm\
    \ = string.lower(extension)\n    local cap_cnt = string.count(cap, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    local sm_cnt = string.count(sm, \"abcdefghijklmnopqrstuvwxyz\")\n    local\
    \ cap_diff = (cap_cnt - sm_cnt) / cap_cnt\n    local strength = cap_diff / sm_cnt\n\
    \    if strength > 0 then\n      table.insert(strongest_extensions, {cap, strength})\n\
    \    end\n  end\n  table.sort(strongest_extensions, function(a, b)\n    return\
    \ b.strength - a.strength\n  end)\n  return string.format(\"%s.%s\", class_name,\
    \ strongest_extensions[1].cap)\nend", "   \n   -- Write your code below this comment.\n\
    \   \n   -- You will need a map from string extensions to integers representing\
    \ their \n   -- strength. To do this, sort the extensions list in descending order\
    \ of \n   -- strength and then construct a map from extensions to their strengths.\n\
    \   -- You will then return the class name and the strongest extension.\n   \n\
    \   -- Don't forget to convert the list of extensions to lower case\n   local\
    \ extension_map = {}\n   for _, extension in pairs(extensions) do\n      local\
    \ strength = extension:lower():gsub('%W','')\n      table.insert(extension_map,\
    \ extension, strength)\n   end", "\tlocal strongest_extension = ''\n\tlocal strength\
    \ = nil\n\tfor i=1,#extensions do\n\t\tlocal c = tonumber(extensions[i])\n\t\t\
    local cap = string.upper(extensions[i])\n\t\tlocal sm = string.lower(extensions[i])\n\
    \t\tlocal diff = math.abs(cap - sm)\n\t\tif diff > strength then\n\t\t\tstrength\
    \ = diff\n\t\t\tstrongest_extension = class_name\n\t\tend\n\tend\n\treturn strongest_extension\n\
    end", "  local capitals = {}\n  local lowercases = {}\n  for _, e in ipairs(extensions)\
    \ do\n    local cap = string.upper(e)\n    local low = string.lower(e)\n    capitals[cap]\
    \ = capitals[cap] or {}\n    capitals[cap][low] = capitals[cap][low] or {}\n \
    \   capitals[cap][low][e] = capitals[cap][low][e] or -1\n    lowercases[low] =\
    \ lowercases[low] or {}\n    lowercases[low][e] = lowercases[low][e] or -1\n \
    \ end\n  local strength = nil\n  for cap, caps in pairs(capitals) do\n    for\
    \ low, lows in pairs(caps) do\n      local sum = 0\n      for _, e in pairs(extensions)\
    \ do\n        local cap_i = capitals[cap][low][e]\n        local low_i = lowercases[low][e]\n\
    \        sum = sum + cap_i + low_i\n      end\n      if sum > strength then\n\
    \        strength = sum\n        class_name = cap .. \".\" .. low\n      end\n\
    \    end\n  end\n  return class_name\nend", "  if #extensions == 0 then\n    return\
    \ class_name\n  else\n    local strength = #extensions - 1\n    for _, extension\
    \ in ipairs(extensions) do\n      if strength > 1 then\n        local cap = string.upper(extension)\n\
    \        local sm = string.lower(extension)\n        local frac = cap - sm\n \
    \       if frac ~= 0 then\n          strength = math.max(strength, frac)\n   \
    \     end\n      end\n    end\n    return class_name .. '.' .. extensions[strength\
    \ + 1]\n  end\nend", "  -- Write your code here.\n  return nil\nend", "  -- Your\
    \ code here\nend", "  local str = className\n  for _, extensionName in ipairs(extensions)\
    \ do\n    local extension = string.sub(extensionName, 1, 1)\n    local capitalLetters\
    \ = #string.gsub(extensionName, \"[A-Z]\", \"\")\n    local lowercaseLetters =\
    \ #string.gsub(extensionName, \"[a-z]\", \"\")\n    local strongestExtension =\
    \ capitalLetters - lowercaseLetters\n    local extensionStrength = extension -\
    \ str\n    if extensionStrength == 0 then\n      break -- Extension name has at\
    \ least one lowercase letter, use it\n    elseif extensionStrength < 0 then\n\
    \      break -- Extension name has at least one capital letter, use it\n    else\n\
    \      if extensionStrength > strongestExtension then\n        str = extensionName\n\
    \        strongestExtension = extensionStrength\n      end\n    end\n  end\n \
    \ return str\nend\n  ", "   -- Your code here!\n   return {class_name, extensions[1],\
    \ extensions[2]}\nend\n</code>\n<|/ a tags=lua |>\n<| c |>\nI tried to implement\
    \ your solution to my code and it's not working out for me :/ \nhttp://pastebin.com/vVfRwU7R\n\
    <|/ c |>\n<| c |>\nThe only problem with this code is that your function does\
    \ not return `nil` if the class name isn't found, it always returns `'nil'` when\
    \ the function finds it. And if you use something like `'Slices.SErviNGSliCes'`\
    \ as the class name then `'Slices.SErviNGSliCes'` will never be found because\
    \ of the missing `'CC'` extension.\n<|/ c |>\n<| c |>\nThanks for your reply!\
    \ I modified the code to this and it seems to be working now:\n<|/ c |>\n<| c\
    \ |>", "\tlocal strength = nil\n\tfor i, extension_name in ipairs(extensions)\
    \ do\n\t\tlocal cap = string.upper(extension_name)\n\t\tlocal sm = string.lower(extension_name)\n\
    \t\tif cap > sm then\n\t\t\tlocal difference = math.abs(cap - sm)\n\t\t\tif strength\
    \ == nil or strength > difference then\n\t\t\t\tstrength = difference\n\t\t\t\
    end\n\t\tend\n\tend\n\tif strength == nil then\n\t\terror('No extension with a\
    \ strength')\n\tend\n\treturn (class_name .. '.' .. extensions[#extensions]) ..\
    \ string.upper(string.sub(class_name, 1, strength))\nend", "   local result =\
    \ \"\"\n   local cap = #class_name\n   local sm = #class_name:lower() - cap\n\
    \   local cap_ext = #extensions\n   local sm_ext = cap_ext - sm\n   for i,e in\
    \ ipairs(extensions) do\n      if cap - sm == i then\n         result = result\
    \ .. e .. \".\" .. class_name\n      elseif cap - sm < i then\n         result\
    \ = result .. e .. \".\" .. class_name:sub(cap_ext - sm)\n      elseif cap - sm\
    \ > i then\n         result = result .. e .. \".\" .. class_name:sub(i)\n    \
    \  end\n   end\n   return result\nend", "  local caps = #class_name:gsub(\"[A-Z]+$\"\
    , \"\"):gsub(\"^%-\", \"\"):gsub(\"%-$\", \"\")\n  local sms = #class_name:gsub(\"\
    [a-z]+$\", \"\"):gsub(\"^%-\", \"\"):gsub(\"%-$\", \"\")\n  return class_name\
    \ .. caps:sub(1, caps - sms) .. '.' .. extensions[1]\nend", "\tlocal sorted_extensions\
    \ = table.sort(extensions, function(a,b) return string.len(a) .. string.len(b)\
    \ end)\n\tlocal index = sorted_extensions[1]\n\tlocal strongest = string.sub(class_name,\
    \ -#index)\n\tfor i = 2, #sorted_extensions do\n\t\tlocal index = sorted_extensions[i]\n\
    \t\tlocal cap = string.sub(class_name, -#index-1)\n\t\tlocal sm = string.sub(class_name,\
    \ -#index)\n\t\tlocal fract = string.format(\"%.*f\", cap-sm)\n\t\tif fract ~=\
    \ \"\" then fract = fract:lower() end\n\t\tif fract == \"\" then\n\t\t\tprint(string.format(\"\
    WARNING! The extensions '%s' have no strength.\", sorted_extensions))\n\t\t\t\
    index = sorted_extensions[1]\n\t\tend\n\t\tif string.sub(sorted_extensions[i],\
    \ -#index) == strongest then\n\t\t\tindex = i\n\t\telse\n\t\t\tindex = sorted_extensions[1]\n\
    \t\tend\n\t\tstrongest = string.sub(class_name, -#index)\n\tend\n\treturn string.format(\"\
    %s.%s\", class_name, strongest)\nend", "    local strength = -1\n    local class_name\
    \ = class_name or 'Slices'\n    local extensions = extensions or {}\n    local\
    \ extensions_count = #extensions", "  local extension_len = #extensions\n  local\
    \ strongest_extension\n  for i=1,extension_len do\n    if extension_strength(extensions[i])\
    \ > extension_strength(strongest_extension) then\n      strongest_extension =\
    \ extensions[i]\n    end\n  end\n  return class_name .. '.' .. strongest_extension\n\
    end\n</code>\n<|/ a tags=lua,lua-table,arrays dscore=3 |>\n<| c |>\nYep, this\
    \ is it! It works well, thanks! Only thing that could be improved is that the\
    \ function would return an error if there were no extensions (but you can fix\
    \ that by wrapping the return line in a `try` block). And I also like the function\
    \ naming style which helped me understand it better :)\n<|/ c |>\n<| a tags=lua,lua-table,arrays\
    \ |>\nYou can find your extension with this function:\n<code>", "\tlocal max_extension\
    \ = nil\n\tlocal max_extension_strength = nil\n\tfor _, extension in pairs(extensions)\
    \ do\n\t\tlocal cap = upper(extension:sub(1, upper(extension:len()) - 1))\n\t\t\
    local sm = lower((extension:sub((upper(extension:len()) + 1), upper(extension:len()))):lower())\n\
    \t\tlocal c = string.sub(class_name, 1, cap)\n\t\tlocal s = string.sub(class_name,\
    \ cap + 1, upper(class_name:len()))\n\t\tif ((c == '' or s == '') and cap == 0)\
    \ then\n\t\t\ttable.insert(extensions, extension)\n\t\t\textensions[#extensions][1]\
    \ = extension\n\t\tend\n\t\tlocal c = string.sub(s, 1, cap)\n\t\tlocal s = string.sub(s,\
    \ cap + 1, upper(s:len()))\n\t\tif ((c == '' or s == '') and cap == 0) then\n\t\
    \t\ttable.insert(extensions, extension)\n\t\t\textensions[#extensions][1] = extension\n\
    \t\tend\n\t\tlocal c = string.sub(s, 1, cap)\n\t\tlocal s = string.sub(s, cap\
    \ + 1, upper(s:len()))\n\t\tif ((c == '' or s == '') and cap == 0) then\n\t\t\t\
    table.insert(extensions, extension)\n\t\t\textensions[#extensions][1] = extension\n\
    \t\tend\n\t\tlocal c = string.sub(s, 1, cap)\n\t\tlocal s = string.sub(s, cap\
    \ + 1, upper(s:len()))\n\t\tif ((c == '' or s == '') and cap == 0) then\n\t\t\t\
    table.insert(extensions, extension)\n\t\t\textensions[#extensions][1] = extension\n\
    \t\tend\n\t\tlocal c = string.sub(s, 1, cap)\n\t\tlocal s = string.sub(s, cap\
    \ + 1, upper(s:len()))\n\t\tif ((c == '' or s == '') and cap == 0) then\n\t\t\t\
    table.insert(extensions, extension)\n\t\t\textensions[#extensions][1] = extension\n\
    \t\tend\n\t\tif cap > max_extension_strength then\n\t\t\tmax_extension_strength\
    \ = cap\n\t\t\tmax_extension = extension\n\t\tend\n\t\tif cap > max_extension_strength\
    \ then\n\t\t\tmax_extension_strength = cap\n\t\t\tmax_extension = extension\n\t\
    \tend\n\t\tif cap > max_extension_strength then\n\t\t\tmax_extension_strength\
    \ = cap\n\t\t\tmax_extension = extension\n\t\tend\n\tend\n\tif #extensions ==\
    \ 0 then\n\t\treturn nil\n\telseif #extensions == 1 then\n\t\treturn max_extension\n\
    \telse\n\t\treturn max_extension:sub(1, upper(max_extension:len()) - 1):sub(1,\
    \ lower((max_extension:sub((upper(max_extension:len()) + 1), upper(max_extension:len()))):lower()))\n\
    \tend\n", "  local cap_length = table_len(extensions)\n  local sm = 0\n  for i\
    \ = 1, cap_length do\n    local c = extensions[i]\n    local cap = string.upper(c:sub(1,\
    \ cap_length))\n    local sm1 = string.lower(c:sub(cap + 1, cap_length))\n   \
    \ local s = cap - sm\n    if cap == sm1 then\n      s = -1\n    end\n    if s\
    \ > sm then\n      sm = s\n      extensions[i] = c\n    end\n  end\n  local length2\
    \ = cap_length - sm\n  if length2 == 0 then\n    return class_name\n  elseif length2\
    \ == 1 then\n    return class_name .. \".\" .. extensions[length2]\n  else\n \
    \   local extension1 = extensions[1]\n    local extension2 = extensions[length2]\n\
    \    return class_name .. \".\" .. extension1 .. \".\" .. extension2\n  end\n\
    end", "  for _, extension in ipairs(extensions) do\n    local cap = string.upper(extension:sub(1,\
    \ cap))\n    local sm = string.lower(extension:sub(cap + 1, cap + cap))\n    local\
    \ strength = cap - sm\n    if strength == 0 then\n      table.insert(extensions,\
    \ extension)\n    elseif strength > 0 then\n      return string.format(class_name\
    \ .. \".\" .. string.upper(extension:sub(1, cap)) .. \".\" .. string.lower(extension:sub(cap\
    \ + 1, cap + cap)), strength)\n    end\n  end\nend", "    local max_strength =\
    \ -1\n    for _, extension in ipairs(extensions) do\n        local cap = string.upper(extension)\n\
    \        local sm = string.lower(extension)\n        local strength = cap - sm\n\
    \        if strength > max_strength then\n            max_strength = strength\n\
    \        end\n    end\n    if max_strength == -1 then return nil end\n    return\
    \ class_name .. string.sub(class_name, 1, string.find(class_name, '.', 1) + 1)\
    \ .. \"_\" .. max_strength\nend", "\tlocal extensions_length = #extensions\n\t\
    local str_extensions = {}\n\tlocal str_extensions_length = 0\n\tlocal extension_strengths\
    \ = {}\n\tlocal extension_strengths_length = #extensions\n\tlocal class_strength\
    \ = string.lower(class_name:sub(1, string.len(class_name)-1))\n\tlocal class_strength_length\
    \ = #class_strength\n\tlocal extension_counter = 0\n\tlocal extension_counter_length\
    \ = 0\n\tlocal class_counter = 0\n\tlocal class_counter_length = 0\n\tlocal str_extension\
    \ = class_name\n\tlocal str_extension_length = #str_extension", "  local max =\
    \ 0\n  local extension = \"\"\n  for i=1,#extensions do\n    local m = string.find(class_name,\
    \ \"%a..\", 1, true)\n    if m then\n      local class_name = string.sub( class_name,\
    \ m-1, m )\n    end\n    local strength = string.find( extensions[i], \"[^A-Z]+\"\
    , 1, true)\n    if strength then\n      local s = string.len( string.sub( extensions[i],1,strength-1\
    \ ) )\n      -- print(\"Strongest Extension of \"..class_name..\" with \"..extensions[i]..\"\
    \ is \"..extension..\" with strength \"..strength)\n      if strength > max then\n\
    \        max = strength\n        extension = extensions[i]\n      end\n    end\n\
    \  end\n  if max then\n    local s = string.len( string.sub( extension, 1, max\
    \ ) )\n    -- print(\"Strongest Extension of \"..class_name..\" with \"..extension..\"\
    \ is \"..extension..\" with strength \"..strength)\n    return class_name..\"\
    .\"..extension\n  else\n    return class_name..\".???\"\n  end\nend", "  -- The\
    \ strength of a given extension is given by the fraction CAP - SM.\n  -- Example:\n\
    \  -- CAP = 3, SM =2: SM/CAP = 0.66. Thus, you get 66% of the extension's \n \
    \ -- (SM/CAP) as your strength.\n  local cap = #class_name:gsub(\".\", \"\"):upper()\n\
    \  local sm = #class_name:gsub(\".\", \"\"):lower()\n  return class_name:sub(cap\
    \ - sm, cap) .. extensions.sort():sub(1)\nend", "  local max_strength = -100\n\
    \  local best_extension = ''\n  for i = 1,#extensions do\n    local extension_length\
    \ = extension:len()\n    local class_length = class_name:len()\n    local strength\
    \ = math.abs(extension_length - class_length)\n    if strength > max_strength\
    \ then\n      max_strength = strength\n      best_extension = extensions[i]\n\
    \    end\n  end\n  return '%s.%s' .. class_name .. best_extension\nend", "  local\
    \ best_strength = -1\n  local best_extension\n  for _, extension in ipairs(extensions)\
    \ do\n    local strength = GetExtensionStrength(class_name, extension)\n    if\
    \ strength > best_strength then\n      best_strength = strength\n      best_extension\
    \ = extension\n    end\n  end\n  return best_extension\nend", "    local strongest_extension\
    \ = nil\n    for _, extension in ipairs(extensions) do\n        local cap = string.upper(extension)\n\
    \        local sm = string.lower(extension)\n        if cap - sm > 0 then\n  \
    \          -- Strength of extension is less than the maximum, \n            --\
    \ so continue with the next extension\n            strongest_extension = extension\n\
    \        end\n    end\n    return string.sub(class_name, 1, string.len(class_name)-string.len(strongest_extension))..strongest_extension\n\
    end", "  -- Your code here\n  local strongest = nil\n  for _, extension in ipairs(extensions)\
    \ do\n    if string.find(class_name, extension) == 1 then\n      if strongest\
    \ == nil then\n        strongest = extension\n      elseif strongest == extension\
    \ then\n        strongest = extension\n      else\n        local strength = string.gsub(class_name,\
    \ '.', \"\")\n        local upper = string.gsub(extension, '.', \"\")\n      \
    \  local lower = string.gsub(extension, '.', '')\n        local cap = string.sub(upper,\
    \ 1, 1)\n        local sm = string.sub(lower, 1, 1)\n        local s = math.max(0,\
    \ (math.abs(cap - sm) / cap) * strength)\n        if strength > s then\n     \
    \     strongest = extension\n        end\n      end\n    end\n  end\n  return\
    \ \"%s.%s\" .. class_name, strongest\nend", "   assert(type(extensions) == \"\
    table\")\n   local total = 0\n   for _, extension in pairs(extensions) do\n  \
    \    if string.sub(full_lower(extension), 1, 1) == string.sub(full_lower(extension),\
    \ 1, 1) then\n         total = total + 1\n      else\n         total = total +\
    \ 1\n         break\n      end\n   end\n   local max_extension_index = 0\n   local\
    \ max_extension_strength = -1\n   local max_extension_length = -1\n   for _, extension\
    \ in pairs(extensions) do\n      local str_len = string.len(full_lower(extension))\n\
    \      if str_len > max_extension_length then\n         max_extension_length =\
    \ str_len\n         max_extension_index = #extensions\n      end\n      local\
    \ str_strength = string.sub(full_lower(extension), 1, string.find(full_lower(extension),\
    \ \":\")) - string.find(full_lower(extension), \":\")\n      if str_strength >\
    \ max_extension_strength then\n         max_extension_strength = str_strength\n\
    \         max_extension_length = -1\n      elseif str_strength == max_extension_strength\
    \ and str_len > max_extension_length then\n         max_extension_strength = str_strength\n\
    \         max_extension_index = #extensions\n      end\n   end\n   return string.format(class_name\
    \ .. \".%s\", full_lower(extensions[max_extension_index]))\nend", "  return assert(assert(table.remove({extensions},\
    \ \n    function(extension)\n      local cap = string.upper(extension:sub(1, 1))\n\
    \      local sm = string.lower(extension:sub(2, 2))\n      return cap - sm\n \
    \   end), ''))\nend", "    assert(type(class_name) == 'string' and type(extensions)\
    \ == 'table')\n    local max = 0\n    for _, extension in ipairs(extensions) do\n\
    \        local s = string.gsub(extension, \"[A-Z]\", \"\") -- CAP\n        local\
    \ e = string.gsub(extension, \"[a-z]\", \"\") -- SM\n        if s > max then\n\
    \            max = s\n        end\n        if e > max then\n            max =\
    \ e\n        end\n    end\n    return class_name .. string.sub(class_name,1,max\
    \ - math.ceil(max/2))\nend", "    local function Extension_Strength(class_name)\n\
    \        local result = {}\n        for _, extension in ipairs(extensions) do\n\
    \            local capitals = string.sub(extension, 1, 1)\n            local lowercases\
    \ = string.sub(extension, 2, 1)\n            if capitals == lowercases then\n\
    \                result[extension] = -1\n            else\n                local\
    \ caps = tonumber(capitals)\n                local lows = tonumber(lowercases)\n\
    \                if caps == lows then\n                    result[extension] =\
    \ caps - lows\n                else\n                    result[extension] = caps\
    \ - lows + 1\n                end\n            end\n        end\n        table.sort(result,\
    \ function(a,b) return a[b] or b[a] end)\n        local i = 0\n        for extension,\
    \ _ in pairs(result) do\n            i = i + 1\n            if i == 1 then\n \
    \               local result = string.gsub(class_name, '([A-Z])', extension)\n\
    \                return string.gsub(class_name, extension, '_', result)\n    \
    \        end\n        end\n        return nil\n    end\n    local strongest_ext\
    \ = {}\n    local class = string.gsub(class_name, '([A-Z])', '\\1_')\n    local\
    \ class_capitals = string.gsub(class_name, '([A-Z])', '\\1_')\n    for _, extension\
    \ in ipairs(extensions) do\n        local capitals = string.sub(extension, 1,\
    \ 1)\n        local lowercases = string.sub(extension, 2, 1)\n        if capitals\
    \ == lowercases then\n            strongest_ext[extension] = -1\n        else\n\
    \            local caps = tonumber(capitals)\n            local lows = tonumber(lowercases)\n\
    \            local new_lows = caps - lows + 1\n            local new_caps = caps\
    \ - lows\n            local new_cap = caps - lows\n            local strongest_cap\
    \ = new_cap - lows + 1\n            if new_lows > strongest_ext[extension] or\
    \ new_caps > strongest_ext[extension] or new_cap > strongest_ext[extension] then\n\
    \                if new_lows > strongest_ext[extension] then\n               \
    \     strongest_ext[extension] = new_lows\n                elseif new_caps > strongest_ext[extension]\
    \ then\n                    strongest_ext[extension] = new_caps\n            \
    \    elseif new_cap > strongest_ext[extension] then\n                    strongest_ext[extension]\
    \ = new_cap\n                end\n            else\n                if capitals\
    \ == class_capitals then\n                    strongest_ext[extension] = new_lows\n\
    \                elseif lowercases == class_capitals then", "  local max = 0\n\
    \  local max_strongest = ''\n  for _, ext in ipairs(extensions) do\n    if string.sub(class_name,\
    \ 1, string.len(class_name)-string.len(ext))==ext then\n      local cap = string.upper(ext:sub(1,\
    \ ext:find(string.upper(ext))-1)) \n      local sm = string.lower(ext:sub((ext:find(string.lower(ext))\
    \ + 1), \n          string.len(ext)))\n      local s = math.floor((cap - sm) *\
    \ 100 / 100)\n      if s > max then\n        max = s\n        max_strongest =\
    \ class_name\n      end\n    end\n  end\n  return max_strongest\nend", "\tlocal\
    \ strongest_extension, strongest_extension_strength = nil, nil -- Initialize variables.\n\
    \t\n\tfor i=1,#extensions do\n\t\tlocal c = string.lower(extensions[i])\n\t\t\
    local n = string.upper(extensions[i])\n\t\t\n\t\tlocal ca, sm = #c, #n -- Count\
    \ capital letters, lower case letters.\n\t\t\n\t\tlocal c = string.sub(c, 1,cap)\
    \ -- Select characters from 1-cap length.\n\t\tlocal n = string.sub(n, 1,sm) --\
    \ Select characters from 1-sm length.\n\t\t\n\t\tlocal c_strength, s_strength\
    \ = string.upper(c), string.upper(n) -- Find strenghts.\n\t\t\n\t\tif c_strength\
    \ == s_strength then\n\t\t\tstrongest_extension = string.sub (class_name, 1, cap)\
    \ -- select class name from 1-cap length\n\t\t\tstrongest_extension_strength =\
    \ -1 -- Set strongest extension strength to -1.\n\t\telse\n\t\t\tstrongest_extension\
    \ = string.sub (class_name, 1, cap) -- select class name from 1-cap length\n\t\
    \t\tstrongest_extension_strength = c_strength - s_strength -- Set strongest extension\
    \ strength to c_strength - s_strength\n\t\tend\n\tend\n\t\n\treturn strongest_extension,\
    \ strongest_extension_strength\nend", '   local strongest_extension = nil', " \
    \   -- Your code here\nend", "    assert(type(extensions) == 'table')\n    assert(#extensions\
    \ > 0)", "  if #extensions == 0 then return nil end\n  local max = 0\n  local\
    \ best = \"\"\n  for _, ext in ipairs(extensions) do\n    local ext = string.upper(ext)\n\
    \    local cap = #ext\n    local sm = #ext\n    local score = math.abs(cap - sm)\n\
    \    if score > max then max = score end\n    best = ext .. \".\" .. best\n  end\n\
    \  return class_name .. \".\" .. best\nend", "  -- Write your code below this\
    \ line\n  local strongest = -1\n  for _, extension in ipairs(extensions) do\n\
    \    if extension:gsub('%w', function()\n        local caps = string.upper(string.sub(self.name,\
    \ 1, cap))\n        local sms = string.lower(string.sub(self.name, cap + 1, cap))\n\
    \        return string.format('%c%c%c', caps, sms, cap) == self.name\n      end)\
    \ >= 0 then\n      local str = string.format('%s.%s', class_name, extension)\n\
    \      if strongest == -1 or strongest > str then\n        strongest = str\n \
    \     end\n    end\n  end\n  -- Write your code above this line\n  return strongest\n\
    end\n</cell>\n<cell>", "  -- your code here\nend", "  if #extensions == 0 then\n\
    \    return \"Error: empty list of extensions\"\n  end", "\tlocal maxStrength\
    \ = -1\n\tlocal maxExtension = nil\n\tfor k,extension in pairs(extensions) do\n\
    \t\tlocal ext = string.lower(extension)\n\t\tlocal len = #ext\n\t\tif len > 0\
    \ then\n\t\t\tlocal c = string.upper(ext[1])\n\t\t\tlocal s = string.upper(ext[len-1])\n\
    \t\t\tlocal c = string.sub(c, 1,1)\n\t\t\tlocal s = string.sub(s,1,1)\n\t\t\t\
    local p = string.format('%s%d%c', c, s)\n\t\t\tlocal s = string.len(p)\n\t\t\t\
    if s > 0 then\n\t\t\t\tlocal strength = #(#ext) - s\n\t\t\t\tif strength > maxStrength\
    \ then\n\t\t\t\t\tmaxStrength = strength\n\t\t\t\t\tmaxExtension = extension\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn string.format(class_name .. '.%s',\
    \ maxExtension)\nend", "\tlocal extension_strength = -1 -- default\n\tlocal extension_names\
    \ = {}\n\tfor _, extension in pairs(extensions) do \n\t\tlocal name, strength\
    \ = string.match(extension, \"^%a:(%w+)%.(%w+)\")\n\t\tif not name then \n\t\t\
    \terror(\"Bad extension name: \" .. extension)\n\t\tend\n\t\textension_strength\
    \ = extension_strength or strength\n\t\ttable.insert(extension_names, name)\n\t\
    end\n\tlocal index = 1 \n\tfor index, name in ipairs(extension_names) do \n\t\t\
    if extension_strength > index then \n\t\t\treturn class_name .. '.' .. name ..\
    \ '(' .. extension_strength - index .. ')'\n\t\tend\n\tend\n\treturn class_name\n\
    end", "\tlocal strongest = ''\n\tfor i = 1, #extensions do\n\t\tlocal strongest_extension\
    \ = extensions[i]\n\t\tlocal index = str:find('^' .. extensions[i] .. '$', 1,\
    \ true, true)\n\t\tlocal strength = str:len(extensions[i]) - str:len(extensions[index])\
    \ + index - 1\n\t\tif strength > 0 then\n\t\t\tif strongest == '' then\n\t\t\t\
    \tstrongest = class_name\n\t\t\tend\n\t\t\tlocal extension_str = str:sub(1, index)\n\
    \t\t\tif strongest == extension_str then\n\t\t\t\tstrongest = class_name\n\t\t\
    \t\tbreak\n\t\t\telse\n\t\t\t\tstrongest = strongest .. '.' .. extension_str\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn strongest\nend", "   local extension_strengths\
    \ = {}\n   for _, extension_name in pairs(extensions) do\n      extension_strengths[extension_name]\
    \ = -1\n   end\n   for _, extension_name in pairs(extensions) do\n      for _,\
    \ class_name in pairs(extensions) do\n         if extension_name ~= class_name\
    \ and extension_strengths[extension_name] < 0 then\n            extension_strengths[extension_name]\
    \ = -1\n         end\n      end\n   end\n   local strongest = -1\n   for _, extension_name\
    \ in pairs(extensions) do\n      if extension_strengths[extension_name] > strongest\
    \ then\n         strongest = extension_strengths[extension_name]\n      end\n\
    \   end\n   if strongest == -1 then\n      error(\"There are no extensions with\
    \ the strongest strength.\")\n   end\n   return class_name .. '.' .. strongest\n\
    end", "   local strengths = {}\n   for _, extension in pairs(extensions) do\n\
    \      local uppercase_count = 0\n      local lowercase_count = 0\n      for c\
    \ in extension:gmatch(\"%u\") do\n         uppercase_count = uppercase_count +\
    \ 1\n         if c:upper() ~= c then\n            uppercase_count = uppercase_count\
    \ - 1\n         end\n      end\n      for c in extension:gmatch(\"%l\") do\n \
    \        lowercase_count = lowercase_count + 1\n         if c:upper() ~= c then\n\
    \            lowercase_count = lowercase_count - 1\n         end\n      end\n\
    \      local cap = uppercase_count - lowercase_count\n      if cap == 0 then\n\
    \         strengths[extension] = -1\n      else\n         strengths[extension]\
    \ = cap\n      end\n   end\n   for _, value in pairs(strengths) do\n      if value\
    \ > 0 then\n         return class_name .. '.' .. tostring(value)\n      end\n\
    \   end\nend", "\tassert(type(extensions) ~= 'table', 'Extensions must be in a\
    \ table.')\n\tlocal strongest_extension = nil\n\tfor _,extension in ipairs(extensions)\
    \ do\n\t\tlocal strength, extension = string_split(extension, '_')\n\t\tif strength\
    \ then\n\t\t\tif strongest_extension == nil then\n\t\t\t\tstrongest_extension\
    \ = '.' .. class_name .. '.' .. extension\n\t\t\telseif strength > string_split(strongest_extension,\
    \ '_')[1] then\n\t\t\t\tstrongest_extension = '.' .. class_name .. '.' .. extension\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn strongest_extension\nend", "    local capitals\
    \ = {}\n    local lowercases = {}\n    for k,v in pairs(extensions) do\n     \
    \   capitals[#capitals+1] = k:match(\"%u\")\n        lowercases[#lowercases+1]\
    \ = k:match(\"%l\")\n    end\n    local max = 0\n    for i=1,#capitals do\n  \
    \      if capitals[i]>lowercases[i] then\n            max = capitals[i]-lowercases[i]\n\
    \        else\n            max = lowercases[i]-capitals[i]\n        end\n    end\n\
    \    if max > 0 then\n        return class_name .. \".\" .. table.concat({capitals,\
    \ lowercases, extensions}, \".\")\n    end\n    return class_name .. \".\" ..\
    \ table.concat({capitals, lowercases}, \".\")\nend", "    if not extensions then\
    \ return nil end\n    local max = 0\n    local max_strength = -1\n    local index\
    \ = nil\n    for i, extension in ipairs(extensions) do\n        local strength\
    \ = string.upper(extension):gsub('%W'):reverse():reverse():gsub('%d'):reverse():reverse():gsub('%p'):reverse():reverse():gsub('%C'):reverse():reverse():gsub('%s'):reverse():reverse():gsub('%x'):reverse():reverse():gsub('%f'):reverse():reverse():gsub('%+'):reverse():reverse():gsub('%-'):reverse():reverse():gsub('%_'):reverse():reverse():gsub('%^'):reverse():reverse():gsub('%:'):reverse():reverse():gsub('%#'):reverse():reverse():gsub('%x'):reverse():reverse():gsub('%#'):reverse():reverse():gsub('%f'):reverse():reverse():gsub('%x'):reverse():reverse():gsub('%+'):reverse():reverse():gsub('%#'):reverse():reverse():gsub('%^'):reverse():reverse():gsub('%-'):reverse():reverse():gsub('%*'):reverse():reverse():gsub('%_'):reverse():reverse():gsub('%+'):reverse():reverse():gsub('%:'):reverse():reverse():gsub('%x'):reverse():reverse():gsub('%f'):reverse():reverse():gsub('%x'):reverse():reverse():gsub('%f'):reverse():reverse():gsub('%_'):reverse():reverse():gsub('%+'):reverse():reverse():gsub('%x'):reverse():reverse():gsub('%f'):reverse():reverse():gsub('%+'):reverse():reverse():gsub('%#'):reverse():reverse():gsub('%^'):reverse():reverse():gsub('%_'):reverse():reverse():gsub('%+'):reverse():reverse():gsub('%:'):reverse():reverse():gsub('%#'):reverse():reverse():gsub('%f'):reverse():reverse():gsub('%_'):reverse():reverse():gsub('%+'):reverse():reverse():gsub('%^'):reverse():reverse():gsub('%:'):reverse():reverse():gsub('%_'):reverse():reverse():gsub('%f'):reverse():reverse():gsub('%f'):reverse():"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
