name: HumanEval_10_make_palindrome
language: lua
results:
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local prefix = string.sub(string,\
    \ 1, string.len(string) - 2)\n    local suffix = string.reverse(string.sub(string,\
    \ 1, string.len(string) - 1))\n    return prefix .. suffix\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwxhnza3l.lua:22:\
    \ expected: \"xyzyx\"\nactual: \"xyx\"\nstack traceback:\n\t/tmp/tmpwxhnza3l.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- No palindromes found\
    \ in these cases.\n   if string == nil then\n      return string\n   end\n   local\
    \ longest, prefix, postfix, suffix\n   if #string < 2 then\n      return string\n\
    \   end\n   local length\n   local i, ii = 1, #string\n   while i < ii do\n  \
    \    -- Find the longest postfix of supplied string that is a palindrome.\n  \
    \    length = ii - 1\n      while length > 0 do\n         if string[length] ~=\
    \ string.byte(string) then\n            length = length - 1\n         else\n \
    \           -- Found a postfix of a palindrome so break from the loop.\n     \
    \       break\n         end\n      end\n      -- Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n     \
    \ prefix = string.sub(string, 1, length)\n      postfix = string.byte(string)\n\
    \      suffix = string.sub(string, length)\n      prefix = string.subreverse(prefix)\n\
    \      postfix = string.reverse(postfix)\n      postfix = string.subreverse(postfix)\n\
    \      if prefix ~= suffix then\n         string = string .. prefix .. postfix\
    \ .. suffix\n      end\n      i = i + 1\n   end\n   return string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp806hop1v.lua:37:\
    \ attempt to call a nil value (field 'subreverse')\nstack traceback:\n\t/tmp/tmp806hop1v.lua:37:\
    \ in local 'candidate'\n\t/tmp/tmp806hop1v.lua:53: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Find a longest palindrome\
    \ that starts with a string.\n    local longest_palindrome = string\n    local\
    \ longest_palindrome_len = string.len(longest_palindrome)\n    for i = 1, longest_palindrome_len\
    \ - 1 do\n        local palindrome = string.sub(longest_palindrome, 0, i) + string.sub(longest_palindrome,\
    \ i, longest_palindrome_len)\n        local reversed_palindrome = string.sub(palindrome,\
    \ 1) .. palindrome\n        if string == reversed_palindrome then\n          \
    \  -- This is a palindrome.\n            longest_palindrome = palindrome\n   \
    \         longest_palindrome = palindrome\n        end\n    end\n    return longest_palindrome\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqdr1a2xy.lua:16:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmpqdr1a2xy.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpqdr1a2xy.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix_palindrome\
    \ = string.gsub(string.gsub(string, '(.-)$', '%1'..string.reverse(string..'$1')),\
    \ '(.-)$', '%1'..string.reverse(string..'$1'))\n    return string..'$1'..postfix_palindrome\n\
    end\n</code>\n<|/ a tags=lua,functional-programming,string |>\n<| a tags=lua,functional-programming,string\
    \ |>\nMy solution is:\n<code>\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpmz40z3wn.lua:15: unexpected symbol near '<'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\t-- Find longest postfix\
    \ that is palindrome\n\tlocal postfix = string:reverse()\n\t-- Find prefix that\
    \ comes before postfix\n\tlocal prefix = string\n\t-- Go through all the characters\
    \ until a palindrome is found\n\tfor i = 1, #string do\n\t\tlocal character\n\t\
    \t-- Look for the longest prefix that is palindrome\n\t\tif i > 1 then\n\t\t\t\
    -- Look for the longest postfix that is palindrome\n\t\t\tcharacter = postfix:sub(1,\
    \ i - 1)\n\t\t\t-- Check if character is palindrome\n\t\t\tif string:sub(i) ==\
    \ character then\n\t\t\t\t-- Found the palindrome\n\t\t\t\t-- Append the reverse\
    \ of the prefix to the postfix and exit the loop\n\t\t\t\tpostfix = postfix ..\
    \ string(i) .. character:reverse()\n\t\t\t\tbreak -- Exit the loop\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn prefix\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp29v2cwwg.lua:40:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmp29v2cwwg.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- The 'string' argument\
    \ 'string' must be a string\n   -- The 'string' argument 'string' must not be\
    \ nil\n   -- The 'string' argument 'string' must be > 1\n   assert(type(string)\
    \ == 'string')\n   assert(not string ~= nil)\n   assert(string.len(string) > 1)\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpatxgtnzi.lua:29: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then string\
    \ = '' end\n  local longest_postfix = string\n  while true do\n    local postfix_length\
    \ = longest_postfix:len()\n    if longest_postfix ~= string then\n      longest_postfix\
    \ = longest_postfix:sub(1,(longest_postfix:len()-1))\n    else\n      longest_postfix\
    \ = longest_postfix:sub(1,longest_postfix:len()-1)\n      break\n    end\n   \
    \ local reversed = reverse(longest_postfix)\n    if reversed == string then break\
    \ end\n    longest_postfix = longest_postfix .. reversed\n  end\n  return longest_postfix\
    \ .. reverse(longest_postfix)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph_7esxgj.lua:26:\
    \ attempt to call a nil value (global 'reverse')\nstack traceback:\n\t/tmp/tmph_7esxgj.lua:26:\
    \ in local 'candidate'\n\t/tmp/tmph_7esxgj.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Start with longest postfix\
    \ that is a palindrome.\n  local longest_palindrome = tonumber(string)\n  -- Append\
    \ to the end of the string reverse of a string prefix that comes before the longest\
    \ palindromic suffix.\n  for i = string.len(), 1, -1 do\n    local prefix = string.sub(string,\
    \ 1, i)\n    longest_palindrome = tonumber(prefix .. longest_palindrome .. string.sub(string,\
    \ i, string.len()))\n  end\n  return longest_palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmjcefh9m.lua:15:\
    \ bad argument #1 to 'len' (string expected, got no value)\nstack traceback:\n\
    \t/tmp/tmpmjcefh9m.lua:15: in local 'candidate'\n\t/tmp/tmpmjcefh9m.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local prefix = string.sub(string,\
    \ 1, string.len(string) - 2)\n    local suffix\n    local reversed_prefix = string.sub(reverse(prefix),\
    \ 0, string.len(prefix))\n    if suffix then\n        -- The palindrome was made\
    \ by appending a palindromic prefix to the suffix\n        -- To find the longest\
    \ postfix that is palindrome:\n        -- - Find the longest postfix that is also\
    \ a palindrome\n        -- - Find the longest postfix that is longer\n       \
    \ -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n    \
    \    -- >>> make_palindrome('ab')\n        -- >>> make_palindrome('a')\n     \
    \   -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n  \
    \      -- >>> make_palindrome('ab')\n        -- >>> make_palindrome('a')\n   \
    \     -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n\
    \        -- >>> make_palindrome('ab')\n        -- >>> make_palindrome('a')\n \
    \       -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n\
    \        -- >>> make_palindrome('ab')\n        -- >>> make_palindrome('a')\n \
    \       -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n\
    \        -- >>> make_palindrome('ab')\n        -- >>> make_palindrome('a')\n \
    \       -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n\
    \        -- >>> make_palindrome('ab')\n        -- >>> make_palindrome('a')\n \
    \       -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n\
    \        -- >>> make_palindrome('ab')\n        -- >>> make_palindrome('a')\n \
    \       -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n\
    \        -- >>> make_palindrome('ab')\n        -- >>> make_palindrome('a')\n \
    \       -- >>> make_palindrome('abba')\n        -- >>> make_palindrome('abb')\n\
    \        -- \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp26lr3dw2.lua:66: 'end' expected (to close 'if' at line 15)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then return\
    \ string end\n    local start = string\n    local end\n    local length = string.len(string)\n\
    \    for i = 1, length do\n        local char = string.sub(string, i, i)\n   \
    \     local reverse = string.reverse(char)\n        local prefix = string.sub(string,\
    \ 1, i - 1)\n        local suffix = string.reverse(string.sub(string, i))\n  \
    \      local result = prefix..reverse..suffix\n        -- If the current iteration\
    \ is a palindrome then store that\n        if start == result then\n         \
    \   start = end\n            end = result\n        end\n    end\n    return end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpj4habmjk.lua:14: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find longest palindromic\
    \ suffix that starts with the supplied string.\n  --\n  -- The longest palindromic\
    \ suffix is one that contains every character from the supplied string.\n  --\
    \ The longest palindromic suffix may have many characters, but the length of the\
    \ prefix of\n  -- the longest palindromic suffix is also the length of the longest\
    \ palindromic suffix.\n  local suffix = ''\n  for i = string.len() - 1, 1, -1\
    \ do\n    local suffix = string.sub(string, i, i + 1)\n    if suffix == reverse(string)\
    \ then\n      return string\n    end\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpasxyj7v6.lua:35: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- We are going to be appending\
    \ reversed version of prefix and postfix string\n   -- So lets initialize our\
    \ search string with empty and reversed.\n   -- This will avoid us from reverse\
    \ it again later.\n   local search_str = ''\n   for i = 1, #string do\n      search_str\
    \ = search_str..string[i]\n   end\n   search_str = search_str..reverse(search_str)\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpomv2dv1l.lua:31: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local prefix_length =\
    \ #string\n    if prefix_length == 0 then\n        return ''\n    end\n    local\
    \ longest_postfix_postfix = string\n    local longest_postfix_postfix_reverse\
    \ = ''\n    for i = #string, 1, -1 do\n        if longest_postfix_postfix:sub(-i)\
    \ == string then\n            longest_postfix_postfix_reverse = longest_postfix_postfix:sub(-i,\
    \ -i)\n        end\n    end\n    return longest_postfix_postfix_reverse .. longest_postfix_postfix\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4es2y3pd.lua:30:\
    \ expected: \"x\"\nactual: \"xx\"\nstack traceback:\n\t/tmp/tmp4es2y3pd.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tstring = string or''\n\t\
    local prefix = ''\n\tlocal suffix = ''\n\tlocal longest_postfix_is_palindrome\
    \ = true\n\tlocal longest_postfix_length = 0\n\tlocal max_length = 0\n\twhile\
    \ true do\n\t\tlocal postfix = string\n\t\tif longest_postfix_length < 0 then\n\
    \t\t\tpostfix = prefix .. string\n\t\t\tlongest_postfix_length = #postfix\n\t\t\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpj0pozq2y.lua:35: 'end' expected (to close 'while' at line\
    \ 18) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal prefix = string.sub(string,1,string.len(string)-1)\n\
    \tlocal suffix_len = string.len(prefix) .. string.len(string)\n\tlocal reversed_suffix\
    \ = string.sub(prefix,1,suffix_len-1)\n\treturn prefix .. reversed_suffix\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp38pq86db.lua:22:\
    \ expected: \"x\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmp38pq86db.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Find longest palindromic\
    \ substring.\n    local suffix = ''\n    local longest_palindrome = ''\n    while\
    \ string.sub(string, 1, #string) == string.reverse(string.sub(string, 1, #string))\
    \ do\n        suffix = string.sub(string, 1, #string) .. suffix\n        string\
    \ = string.reverse(string.sub(string, 1, #string))\n    end\n    -- Reverse longest\
    \ palindromic substring.\n    longest_palindrome = string.sub(string, 1, #string)\
    \ .. suffix\n    return longest_palindrome\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local prefix\n    local\
    \ suffix\n    local reversed\n    local longest_postfix = 0\n    local is_palindrome\n\
    \    for prefix, suffix in pairs(string) do\n        -- reverse the suffix.\n\
    \        reversed = suffix:reverse()\n        -- see if reversed string is a palindrome.\n\
    \        is_palindrome = prefix:sub(1, prefix:len() - suffix:len() - 1):reverse()\
    \ == suffix:reverse()\n        if is_palindrome then\n            -- check if\
    \ prefix is longer than longest postfix and if it is a palindrome.\n         \
    \   if longest_postfix < prefix:len() then\n                longest_postfix =\
    \ prefix:len()\n            end\n        end\n    end\n    -- append the longest\
    \ postfix to the original string.\n    local append = string\n    if longest_postfix\
    \ ~= 0 then\n        append = string .. string[longest_postfix:len() + 1]\n  \
    \  end\n    return append\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpskze7lmw.lua:17:\
    \ bad argument #1 to 'for iterator' (table expected, got string)\nstack traceback:\n\
    \t/tmp/tmpskze7lmw.lua:17: in local 'candidate'\n\t/tmp/tmpskze7lmw.lua:40: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local s, len, longest, pal\n\
    \  s, len = string.gsub(\n    string, '([^'..string.char(0xFFFF)..']+)', '%1'\n\
    \  ), #string\n  longest, longest = s:sub(0, len / 2), s:sub(len / 2, len)\n \
    \ pal = s:sub(len / 2 + longest:len() / 2) .. s[len - 1] .. s[len / 2 - longest:len()\
    \ / 2 - 1]\n  return string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzxy54hcd.lua:14:\
    \ bad argument #1 to 'char' (value out of range)\nstack traceback:\n\t/tmp/tmpzxy54hcd.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpzxy54hcd.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local reversed_string =\
    \ string\n  local palindrome_suffix = reversed_string:sub(1,reversed_string:len()-1)\n\
    \  local palindrome_prefix = string:sub(1,reversed_string:find(palindrome_suffix))\n\
    \  return reversed_string .. palindrome_prefix .. palindrome_suffix\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphkmavmzf.lua:22:\
    \ expected: \"x\"\nactual: \"xx\"\nstack traceback:\n\t/tmp/tmphkmavmzf.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal string = string\n\t\
    local max = 0\n\tlocal index = string\n\tlocal index2 = 0\n\twhile string.sub(string,index,index)\
    \ ~= string.sub(string,index+1,index) do\n\t\tmax = max + 1\n\t\tindex = string.sub(index,1,index+1)\n\
    \tend\n\tindex = string\n\tindex2 = string\n\twhile string.sub(string,index,index)\
    \ ~= string.sub(string,index+1,index) do\n\t\tmax = max + 1\n\t\tindex2 = string.sub(index2,1,index2)\n\
    \tend\n\tlocal palindrome = string.sub(string,index,index2)\n\tpalindrome = string.sub(palindrome,1,max)\n\
    \treturn palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpa7kjtsgn.lua:16:\
    \ bad argument #2 to 'sub' (number expected, got string)\nstack traceback:\n\t\
    /tmp/tmpa7kjtsgn.lua:16: in local 'candidate'\n\t/tmp/tmpa7kjtsgn.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find largest suffix that\
    \ is a palindrome.\n  local suffix = nil\n  for i = #string, 1, -1 do\n    local\
    \ substring = string.sub(string, 1, i)\n    if suffix ~= nil then\n      local\
    \ suffix_reverse = string.gsub(suffix, \"^[%z?]+\", \"\")\n      if suffix_reverse\
    \ ~= suffix then\n        suffix = suffix_reverse\n      end\n    else\n     \
    \ suffix = substring\n    end\n    if suffix ~= \"\" then\n      local suffix_reverse\
    \ = string.gsub(suffix, \"^[%z?]+\", \"\")\n      if suffix_reverse ~= suffix\
    \ then\n        suffix = suffix_reverse\n      end\n      break\n    end\n  end\n\
    \  if suffix == nil then\n    return string\n  end\n  local palindrome_start =\
    \ string.find(suffix, '^')\n  local palindrome_end = string.find(suffix, '$',\
    \ palindrome_start + 1)\n  if palindrome_start == nil or palindrome_end == nil\
    \ then\n    return string\n  end\n  -- Build palindrome string\n  local reverse\
    \ = string.sub(suffix, palindrome_end + 1)\n  local start = string.sub(suffix,\
    \ palindrome_start - 1)\n  if reverse ~= suffix then\n    local reverse = reverse\n\
    \  else\n    local reverse = string.reverse(start)\n  end\n  local end = string.sub(suffix,\
    \ palindrome_start + 1)\n  if end ~= suffix then\n    local end = end\n  else\n\
    \    local end = string.reverse(reverse)\n  end\n  return string.reverse(end..reverse)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpu9gotoi9.lua:48: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then\n\
    \    return ''\n  end\n  local reversed = string.gsub(string, '[%z\\1-\\127]')\
    \ -- Remove all control characters\n  if reverse ~= string then\n    return string\
    \ .. reversed\n  end\n  reversed = string.gsub(reversed, '[%z\\1-\\127]')\n  if\
    \ reverse ~= string then\n    return string .. reversed\n  end\n  return string\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpniy7uiu_.lua:15:\
    \ bad argument #3 to 'gsub' (string/function/table expected)\nstack traceback:\n\
    \t/tmp/tmpniy7uiu_.lua:15: in local 'candidate'\n\t/tmp/tmpniy7uiu_.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local len_string = #string\n    local len_str = len_string\n    if len_string%2\
    \ == 0 then\n        len_string = len_string/2\n        len_str = len_str/2\n\
    \    end\n    local reverse = string\n    local reverse_len = 0\n    if len_str\
    \ < len_string then\n        reverse = reverse..string.sub(string, 1, len_string)\n\
    \        reverse_len = len_string\n    end\n    if reverse_len < len_str then\n\
    \        -- append the reverse of the string\n        reverse = reverse..string..string.sub(reverse,\
    \ len_string+1, len_string+reverse_len)\n    end\n    if reverse ~= string then\n\
    \        palindrome = palindrome..reverse\n    end\n    return palindrome\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyzcdj1h7.lua:39:\
    \ expected: \"x\"\nactual: \"xxx\"\nstack traceback:\n\t/tmp/tmpyzcdj1h7.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal prefix = string.match('.?([^'..string..'\\\
    s]+)$', '.+$') \n\tlocal suffix = string.match('(.+)'..string..'$', '.+$')\n\t\
    local reverse = string.sub(suffix, 2, -1)\n\treturn string.sub(prefix..reverse,\
    \ 1, -1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvbccj2_2.lua:12: invalid escape sequence near ''\\s'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local len = #string\n\
    \    local max_postfix, min_prefix\n    if len <= 1 then\n        return string\n\
    \    end\n    -- Find the longest postfix of string that is a palindrome\n   \
    \ max_postfix = string\n    min_prefix = ''\n    for i = 1, len-1 do\n       \
    \ local prefix, postfix\n        prefix, postfix = string:sub(1,i), string:sub(i+1,len)\n\
    \        if string.reverse then\n            max_postfix = max_postfix .. string.reverse(postfix)\n\
    \        else\n            max_postfix = max_postfix .. postfix\n        end\n\
    \        min_prefix = prefix .. min_prefix\n    end\n    -- Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix\n\
    \    max_postfix = max_postfix .. string.reverse(min_prefix)\n    return max_postfix\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3ip2w9ya.lua:40:\
    \ expected: \"xyzyx\"\nactual: \"xyzzyzxyx\"\nstack traceback:\n\t/tmp/tmp3ip2w9ya.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string.find(string,\
    \ \"%\") then\n        return string\n    end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6qadz2q3.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local length = #string\n\
    \    if length < 2 then return string end\n    local max_palindrome = string\n\
    \    local max_reversed_palindrome = string\n    for i = 1, length - 1 do\n  \
    \      local reversed_palindrome = reverse(max_palindrome)\n        if max_palindrome\
    \ == reversed_palindrome then\n            max_palindrome = max_palindrome ..\
    \ string[i]\n        else\n            max_reversed_palindrome = max_reversed_palindrome\
    \ .. string[i]\n        end\n    end\n    return max_palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppnkhp4ik.lua:17:\
    \ attempt to call a nil value (global 'reverse')\nstack traceback:\n\t/tmp/tmppnkhp4ik.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmppnkhp4ik.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string ~= string.gsub(string,\
    \ \"[^\"..string.char(0x20) .. \"]\", \"\")\n  then\n    return string\n  end\n\
    \  local index = string..'c'..string..string\n  local longest_palindrome = \"\"\
    \n  local longest_palindrome_index = 0\n  while true do\n    local longest_palindrome_length\
    \ = string.len(longest_palindrome)\n    local longest_palindrome_end_index = string.find(index,\
    \ longest_palindrome)\n    if longest_palindrome_end_index > 0 then\n      longest_palindrome_index\
    \ = longest_palindrome_end_index\n      longest_palindrome = string.sub(index,\
    \ longest_palindrome_index - longest_palindrome_length + 1, longest_palindrome_index)\n\
    \    end\n    if longest_palindrome_end_index == 0 then\n      break\n    end\n\
    \  end\n  longest_palindrome = string.sub(longest_palindrome, 1)\n  if string.len(longest_palindrome)\
    \ > string.len(string) then\n    return string\n  end\n  local reversed_string\
    \ = string\n  for i = 1, string.len(string) do\n    reversed_string = reversed_string..string[i]\n\
    \  end\n  reversed_string = reversed_string..string.sub(longest_palindrome, string.len(longest_palindrome))\n\
    \  return string..reversed_string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local prefix_len = #string\n\
    \  local postfix_len = string.len\n  local palindrome = string\n  local suffix_len\
    \ = 1\n  while suffix_len <= postfix_len do\n    local reversed_suffix = string.sub(string.reverse(string,\
    \ suffix_len, suffix_len + 1), 1)\n    palindrome = palindrome .. reversed_suffix\n\
    \    suffix_len = suffix_len + 1\n  end\n  return string.reverse(palindrome, 1)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpowr3ak40.lua:16:\
    \ attempt to compare number with function\nstack traceback:\n\t/tmp/tmpowr3ak40.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpowr3ak40.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string == '' or string\
    \ == '???' then\n        string = '???'\n    end\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpnxwlqoyp.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local reverse, i, pal\
    \ = string_reverse(string), 0, string\n    while reverse ~= string do\n      \
    \  if reverse:sub(i) == string then\n            -- Found a palindrome\n     \
    \       pal = pal .. reverse:sub(i) .. reverse:sub(0, i) .. string\n         \
    \   break\n        end\n        i = i + 1 -- Increment index\n        reverse\
    \ = string_reverse(string, i) -- Reverse the substring\n    end\n    return pal\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph2ohz4o2.lua:12:\
    \ attempt to call a nil value (global 'string_reverse')\nstack traceback:\n\t\
    /tmp/tmph2ohz4o2.lua:12: in local 'candidate'\n\t/tmp/tmph2ohz4o2.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local length = #string\
    \ + 1\n    local result = ''\n    local start = 0\n    while start < length do\n\
    \        local end = string.find(string, start, length - 1, true) + start\n  \
    \      if end == length then\n            result = result .. (string[start + 1]\
    \ or '')\n        else\n            result = result .. (string[start + 1] or '')\n\
    \            local suffix = string[end - 1] or ''\n            local reverse =\
    \ ''\n            local i = start\n            while i < end do\n            \
    \    reverse = reverse .. string[i]\n                i = i + 1\n            end\n\
    \            result = result .. reverse\n        end\n        start = end + 1\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9_w58iub.lua:16: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local reverse = string.sub(reverse(string),\
    \ 1, string.length)\n  return string .. reverse\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6zakl3z8.lua:12:\
    \ attempt to call a nil value (global 'reverse')\nstack traceback:\n\t/tmp/tmp6zakl3z8.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmp6zakl3z8.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local reversed_prefix = string\n    local prefix_length = 1\n    local postfix_length\
    \ = 1\n    local palindromic\n    while true do\n        local postfix = string\n\
    \        postfix_length = postfix_length + 1\n        while postfix_length > 1\
    \ do\n            postfix = string..postfix_length\n            postfix_length\
    \ = postfix_length - 1\n        end\n        reversed_prefix = string..prefix_length\n\
    \        prefix_length = prefix_length + 1\n        if palindrome ~= reversed_prefix\
    \ then\n            palindromic = postfix..reversed_prefix\n        end\n    \
    \    if palindrome ~= postfix then\n            break\n        end\n    end\n\
    \    return palindromic\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyntes_8z.lua:39:\
    \ expected: \"\"\nactual: \"21\"\nstack traceback:\n\t/tmp/tmpyntes_8z.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Optimization: if the\
    \ string is already palindrome no need to find longest postfix of it again.\n\
    \    if string == palindromes[string] then return string end\n    -- Find the\
    \ longest postfix that is a palindrome.\n    local postfix, longest, longestLength\
    \ = string.find(string, '^')\n    while postfix do\n        longest = string\n\
    \        longestLength = string.len(longest)\n        postfix, longest, longestLength\
    \ = string.find(string, longest, longestLength - 1)\n    end\n    -- Append the\
    \ reverse of the longest postfix to the original string.\n    local middle, middleLength\
    \ = string.find(longest, '.')\n    if middle and middleLength > longestLength\
    \ then\n        return string..palindromes[string.sub(longest, middleLength +\
    \ 1, longestLength)]\n    end\n    return string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpsz_giqc6.lua:13:\
    \ attempt to index a nil value (global 'palindromes')\nstack traceback:\n\t/tmp/tmpsz_giqc6.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpsz_giqc6.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal length = 0\n\tfor\
    \ i=1,#string do\n\t\tlength = length+1\n\t\tstring = string.gsub(string,\"%%%d\"\
    ,\"\")\n\tend\n\tlocal postfix = string\n\tlocal i = length\n\twhile i>0 do\n\t\
    \tpostfix = string.sub(1,i)..postfix..string.reverse(string.sub(1,i))\n\t\ti =\
    \ i-1\n\tend\n\tpostfix = string..postfix\n\treturn postfix\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw1yszg_8.lua:31:\
    \ expected: \"x\"\nactual: \"x1x1\"\nstack traceback:\n\t/tmp/tmpw1yszg_8.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if not string then return\
    \ '' end\n  local reverse = reverse(string.sub(1, string.len))\n  return string.sub(string\
    \ .. reverse, 1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6br7rimh.lua:13:\
    \ bad argument #2 to 'sub' (number expected, got function)\nstack traceback:\n\
    \t/tmp/tmp6br7rimh.lua:13: in local 'candidate'\n\t/tmp/tmp6br7rimh.lua:20: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = ''\n\
    \    local start = 0\n    local end = 1\n    while start < #string do\n      \
    \  local prefix = string\n        local suffix = string\n        local len = #suffix\n\
    \        while end <= len - 1 do\n            prefix = prefix .. suffix[end -\
    \ 1]\n            suffix = suffix[end - 1]\n            end = end + 1\n      \
    \  end\n        -- If the string is longer than the palindrome then stop.\n  \
    \      if #prefix > #suffix then\n            palindrome = prefix .. suffix\n\
    \            break\n        end\n        -- Find the longest postfix that is a\
    \ palindrome.\n        local max_length = 0\n        local index = start\n   \
    \     while index+1 < end do\n            max_length = math.max(max_length, #prefix+#suffix+2)\n\
    \            index = index + 1\n        end\n        -- Append to the suffix reverse\
    \ the string prefix.\n        suffix = prefix\n        for i = 1, max_length do\n\
    \            suffix = suffix .. suffix[i]\n        end\n        palindrome = palindrome\
    \ .. suffix\n        start = end\n    end\n    return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpc5hgg8k3.lua:14: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal longest_postfix, suffix_postfix\
    \ = {}, {}\n\tfor i = 1, #string do\n\t\tlocal prefix = string:sub(1, i)\n\t\t\
    local suffix = string:sub(i+1)\n\t\tlocal reversed_suffix\n\t\tif suffix:sub(1,\
    \ #suffix) = suffix:sub(-#suffix) then\n\t\t\treversed_suffix = '' .. suffix:reverse()\n\
    \t\telse\n\t\t\treversed_suffix = suffix\n\t\tend\n\t\tlongest_postfix[i] = prefix\
    \ .. reversed_suffix\n\t\tsuffix_postfix[reversed_suffix] = prefix\n\tend\n\t\
    local longest_postfix = table.concat(longest_postfix, \"\", \"\")\n\treturn longest_postfix\
    \ .. suffix_postfix[longest_postfix]\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8c1n2ljb.lua:17: 'then' expected near '='\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then\n \
    \       error('string required')\n    end\n    local postfix = {string}\n    local\
    \ palindrome = string\n    local index = 1\n    while index > 0 do\n        postfix\
    \ = {postfix:sub(1, index - 1):reverse()}\n        if postfix:sub(1, index) ==\
    \ palindrome then\n            palindrome = palindrome:sub(1, index - 1) + string\n\
    \        end\n        index = index + 1\n    end\n    return palindrome\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1c3z9ion.lua:19:\
    \ attempt to call a nil value (method 'sub')\nstack traceback:\n\t/tmp/tmp1c3z9ion.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmp1c3z9ion.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then return\
    \ '' end\n    local postfix = string.match(reverse(string), '%d+')\n    if postfix\
    \ then\n        if string.len(postfix) < string.len(string) then\n           \
    \ local prefix = string.sub(string, 1, string.len(postfix))\n            return\
    \ string.format('%s%s%s%s%s',\n                prefix,\n                string,\n\
    \                string.sub(postfix, 1, string.len(string) - string.len(postfix)),\n\
    \                string.sub(postfix, string.len(string) - string.len(postfix)\
    \ + 1))\n        end\n    end\n    return string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdhtfd9so.lua:13:\
    \ attempt to call a nil value (global 'reverse')\nstack traceback:\n\t/tmp/tmpdhtfd9so.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpdhtfd9so.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string.match(rev_string(string),\
    \ \"%S\")\n    if string.len(postfix .. string) < string.len(string .. postfix)\
    \ then\n        return string .. postfix .. reverse(string:sub(1, string.len(postfix\
    \ .. string) - 1) .. postfix)\n    else\n        return string\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp55iuhex1.lua:12:\
    \ attempt to call a nil value (global 'rev_string')\nstack traceback:\n\t/tmp/tmp55iuhex1.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmp55iuhex1.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if not string then return\
    \ '' end\n  local s = string\n  local slen = #string\n  while slen > 0 do\n  \
    \  slen = slen - 1 -- -1 because of '\\0' at the end\n    -- The longest postfix\
    \ of supplied string that is a palindrome.\n    -- Example: cata --> ctac\n  \
    \  local postfix = string.sub(s, slen + 1, slen)\n    -- The reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    -- Example: catac -->\
    \ acat\n    local reverse = string.sub(s, 1, slen - 1)\n    -- Example: catac\
    \ --> ctac\n    local reverse_palindrome = string.reverse(postfix)\n    -- Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    -- Example: catac --> acatc\n    s = s .. reverse_palindrome ..\
    \ reverse\n  end\n  return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7si_vcid.lua:36:\
    \ expected: \"x\"\nactual: \"xx\"\nstack traceback:\n\t/tmp/tmp7si_vcid.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local prefix_end_index\
    \ = string.len(string) - math.floor(string.len(string) / 2)\n    local prefix_reverse\
    \ = string.sub(string, prefix_end_index, prefix_end_index + 1)\n    local end_index\
    \ = prefix_end_index + 1\n    local palindrome\n    local start_index\n    --\
    \ TODO: Make it better\n    while end_index > 0 do\n        if string.sub(string,\
    \ end_index, end_index) == prefix_reverse then\n            start_index = end_index\n\
    \            palindrome = string[start_index:end_index]\n            -- TODO:\
    \ Make it better\n            return string[start_index:end_index]:reverse()\n\
    \        elseif string.sub(string, end_index, end_index) ~= prefix_reverse then\n\
    \            end_index = end_index - 1\n        else\n            end_index =\
    \ end_index - 1\n        end\n    end\n    return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsql9fg11.lua:21: function arguments expected near ']'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    while string.len(postfix) ~= 0 do\n        postfix = string.sub(postfix,\
    \ 1, string.len(postfix) - 1) + postfix\n    end\n    \n    local palindrome =\
    \ string.sub(postfix, 0, string.len(postfix) - 1)\n    \n    -- Reverse the string\
    \ prefix\n    palindrome = string.sub(palindrome, 1, string.len(palindrome) -\
    \ 1)\n    \n    -- Append reverse of string prefix\n    palindrome = string.sub(palindrome,\
    \ 1, string.len(palindrome))\n    palindrome = string.sub(palindrome, 1) + palindrome\n\
    \    \n    -- Return palindrome\n    return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpifen09un.lua:24:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmpifen09un.lua:24:\
    \ in local 'candidate'\n\t/tmp/tmpifen09un.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- First find longest postfix\
    \ that is a palindrome.\n   -- This is not quite enough, since it only deals with\
    \ postfixes that contain at least one letter. Reverse is not necessary in such\
    \ cases.\n   -- Example: postfix 'cata' -> 'catac' -> 'atcata'\n   local longest_postfix\
    \ = string\n   for i=string.len()-1, 1, -1 do\n      local suffix = string.sub(string,1,i)\n\
    \      if suffix ~= suffix then\n         local reverse = reverse(string,1,i-1)\n\
    \         if reverse ~= suffix then\n            longest_postfix = string.sub(longest_postfix,1,i-1)\
    \ .. reverse .. suffix\n         end\n      end\n   end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpm3kn8lnu.lua:36: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal prefix = string\n\t\
    local suffix = string\n\t-- reverse suffix\n\twhile true\n\t\tdo\n\t\t\tlocal\
    \ i = suffix:len()\n\t\t\tif i == 0 then break end\n\t\t\t-- if prefix and suffix\
    \ are the same the reverse the suffix\n\t\t\tif prefix:sub(i, i) == suffix then\
    \ suffix = suffix:reverse() end\n\t\t\t-- if the suffix is not the reverse the\
    \ prefix to the suffix\n\t\t\tif not suffix:sub(i, i) == prefix then prefix =\
    \ prefix:reverse() end\n\t\tend\n\treturn prefix .. suffix .. string\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Return an empty string\
    \ if an empty string was supplied.\n    if string == nil or string == '' then\n\
    \        return ''\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpz8yvqjym.lua:27: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffix_length =\
    \ #string + 1 -- +1 for the last char\n    local prefix = string:sub(1, suffix_length)\n\
    \    local suffix_reversed = prefix:reverse()\n    local palindrome = string\n\
    \    while suffix_length > 0 do\n        if palindrome:sub(1, suffix_length) ==\
    \ suffix_reversed then\n            return palindrome\n        end\n        suffix_length\
    \ = suffix_length - 1\n        suffix = suffix_reversed:sub(1, suffix_length)\n\
    \        suffix_reversed = suffix:reverse()\n    end\n    return palindrome\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp87g0i8fq.lua:32:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmp87g0i8fq.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   local reverse = string.char()\n\
    \   local prefix = \"\"\n   for i = 1, #string do\n      reverse = string.sub(reverse,\
    \ 1, #reverse) .. string.sub(string, i, i)\n      if reverse == string then\n\
    \         prefix = string.sub(string, i)\n      end\n   end\n   return prefix\
    \ .. reverse\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5bbziybb.lua:27:\
    \ expected: \"x\"\nactual: \"xx\"\nstack traceback:\n\t/tmp/tmp5bbziybb.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tif string == nil then\n\t\
    \treturn nil\n\tend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpq3igdzda.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- If the string is zero\
    \ or one, then the string is a palindrome.\n  if string == '' then return '' end\n\
    \  if string == '1' then return '1' end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpr6ax3qyy.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then\n\
    \    string = \"\"\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgmjr8ovh.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tif string == nil then\n\t\
    \treturn ''\n\telse\n\t\tlocal start, end = 0, -1\n\t\twhile true do\n\t\t\t--\
    \ find longest postfix palindrome\n\t\t\tlocal max = #string\n\t\t\tfor i = 1,\
    \ max do\n\t\t\t\tlocal substring = string.sub(i, i)\n\t\t\t\t-- if it's not the\
    \ same as a suffix\n\t\t\t\tif substring ~= string[end - 1] or substring:len()\
    \ > #string then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\t-- remove it from the\
    \ string\n\t\t\t\tstring = string.sub(i, i - 1)\n\t\t\t\t-- see if it's a palindrome\n\
    \t\t\t\tif string.sub(1, 1) == string.sub(string:len() - 1, string:len() - 1)\
    \ then\n\t\t\t\t\t-- if so remove it from the start and end\n\t\t\t\t\tstart =\
    \ string.find(string, \"^\") + 1\n\t\t\t\t\tend = string.find(string, \"$\") -\
    \ 1\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- if none left\n\t\t\tif\
    \ start == end then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t-- if found longest postfix\
    \ palindrome\n\t\t\tif start < end then\n\t\t\t\tlocal substring = string.sub(start,\
    \ end)\n\t\t\t\tlocal reverse = string.gsub(substring, function() return string.char(tonumber(string:sub(1,\
    \ 1)):byte()) end)\n\t\t\t\t-- add it to the original string\n\t\t\t\tstring =\
    \ string.sub(start .. reverse, end)\n\t\t\tend\n\t\tend\n\t\treturn string\n\t\
    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpp2z56hve.lua:15: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix_length =\
    \ #string - (string.find(string, \"#\") + 1)\n    local prefix_length = #(string.sub(string,\
    \ 1, string.find(string, \"#\")) - 1)\n    local palindrome = string.sub(string,\
    \ 1, string.find(string, \"#\"))\n    local reversed_palindrome = string.gsub(palindrome,\
    \ \"#\", string.reverse(palindrome))\n    return string.reverse(string.sub(string,\
    \ 1, string.find(string, \"#\")) + reversed_palindrome + string.sub(string, string.find(string,\
    \ \"#\") + 1, #string))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv4dv22lp.lua:12:\
    \ attempt to perform arithmetic on a nil value\nstack traceback:\n\t/tmp/tmpv4dv22lp.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmpv4dv22lp.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then\n \
    \       return string\n    end\n    local index = #string\n    if #string < 2\
    \ then\n        return string\n    end\n    local first = string.sub(string, 0,\
    \ index)\n    local rest = string.sub(string, index)\n    local reverse = make_palindrome(first)\n\
    \    return first .. reverse .. rest\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8l5c60on.lua:19:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmp8l5c60on.lua:19: in upvalue 'make_palindrome'\n\
    \t/tmp/tmp8l5c60on.lua:21: in upvalue 'make_palindrome'\n\t/tmp/tmp8l5c60on.lua:21:\
    \ in upvalue 'make_palindrome'\n\t/tmp/tmp8l5c60on.lua:21: in upvalue 'make_palindrome'\n\
    \t/tmp/tmp8l5c60on.lua:21: in upvalue 'make_palindrome'\n\t/tmp/tmp8l5c60on.lua:21:\
    \ in upvalue 'make_palindrome'\n\t/tmp/tmp8l5c60on.lua:21: in upvalue 'make_palindrome'\n\
    \t/tmp/tmp8l5c60on.lua:21: in upvalue 'make_palindrome'\n\t/tmp/tmp8l5c60on.lua:21:\
    \ in upvalue 'make_palindrome'\n\t...\n\t/tmp/tmp8l5c60on.lua:21: in local 'candidate'\n\
    \t/tmp/tmp8l5c60on.lua:30: in function 'test_humaneval'\n\nRan 1 tests in 0.100\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffix = ''\n  \
    \  local i, j = string.len(), string.len(string)\n    while i > 0 do\n       \
    \ if string[j] == string[i] then\n            j = j - 1\n        elseif i == j\
    \ - 1 then\n            suffix = suffix .. string[i]\n            i = i - 1\n\
    \        else\n            suffix = suffix .. string[i] .. string[j]\n       \
    \     i = i - 1\n            j = j - 1\n        end\n    end\n    return string.sub(string,\
    \ 1, i) .. suffix .. string.sub(string, (i, j))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgc29jmv3.lua:26: ')' expected near ','\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Find length of longest\
    \ palindrome\n    local max_len = #string\n    local max_len_palindrome = 0\n\
    \    local max_len_palindrome_end = 0\n    local palindrome = ''\n    local index\
    \ = 1\n    while index <= #string do\n        local char = string[index:index]\n\
    \        if char ~= string[max_len_palindrome_end] then\n            -- Reverse\
    \ string\n            palindrome = palindrome..string[max_len_palindrome_end]:reverse()\n\
    \        end\n        -- Check palindrome\n        local ok, offset = palindrome:find(char)\n\
    \        if ok and offset > max_len_palindrome_end then\n            max_len_palindrome_end\
    \ = offset\n            -- Find longest palindrome\n            if max_len_palindrome\
    \ ~= 0 and max_len_palindrome_end > max_len_palindrome then\n                max_len\
    \ = max_len_palindrome_end\n            end\n            max_len_palindrome =\
    \ max_len_palindrome_end\n        end\n        -- Increment index\n        index\
    \ = index + max_len_palindrome_end\n    end\n    -- Add postfix\n    return string..palindrome:reverse()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpobr7ndet.lua:19: function arguments expected near ']'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local max_len = string.len(string)\
    \ - 2\n    local reverse_string\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpu6etmovb.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = \"\"\
    \n    local longest_postfix_palindrome = 0\n    for i = 0, string do\n       \
    \ if i >= string then\n            break\n        end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpo19b0kor.lua:29: 'end' expected (to close 'for' at line 14)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == '' then\n \
    \   return string\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdywyarbg.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then return\
    \ '' end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4rgyxzi3.lua:24: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = ''\n\
    \    local suffix = ''\n    local prefix = string.sub(string, 1, string.len(string))\n\
    \    local prefixLength = 0\n    -- Find the longest postfix of supplied string\
    \ that is a palindrome.\n    -- Algorithm idea is simple:\n    -- - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    -- - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    while suffix:len() > 0 do\n        if suffix:len() > prefix:len() then\n\
    \            prefix = prefix:reverse()\n            prefixLength = prefix:len()\n\
    \        else\n            suffix = suffix:reverse()\n        end\n        local\
    \ palindromeLength = suffix:len() + prefixLength\n        palindrome = palindrome..string.sub(string,\
    \ 1, palindromeLength)\n        string = string.sub(string,palindromeLength+1)\n\
    \    end\n    return palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_p4yu746.lua:38:\
    \ expected: \"x\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmp_p4yu746.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal postfix = string\n\
    \tlocal reverse\n\tfor postfix = string.Reverse(postfix) do\n\t\tlocal palindrome\
    \ = string.Sub(postfix, 1, string.Len(postfix)-1) == string.Reverse(string.Sub(postfix,\
    \ 1, string.Len(postfix)-1))\n\t\tif palindrome then break end\n\tend\n\t-- Reverse\
    \ of string that comes before the palindromic suffix\n\treverse = string.Sub(postfix,\
    \ 0, string.Len(postfix)-1)\n\treturn string..reverse\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp96ey76cd.lua:14: ',' expected near 'do'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string:len()\n\
    \    local suffix\n    local max_index = 0\n    for i = 1, postfix do\n      \
    \  suffix = string:sub(i):reverse():sub(1, i - 1)\n        if suffix:sub(1, 1)\
    \ == suffix:sub(#suffix, 1) then\n            max_index = i\n        end\n   \
    \ end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpf1434s7m.lua:32: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string == '' then\n\
    \        return ''\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpg9_oap3f.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then return\
    \ end\n  local longest_postfix = 0\n  while true do\n    local postfix, _, count\
    \ = string.find(string, \"%a%a\", longest_postfix, true, nil)\n    if string.len(string)\
    \ >= 2 then\n      -- Found a palindrome suffix.\n      longest_postfix = longest_postfix\
    \ + (count - 1) -- +1 to include the postfix of string that ends the palindrome.\n\
    \      -- Add the postfix of the string that comes before the longest postfix\
    \ to the end of the palindrome\n      string.gsub(string, \"%a%a\", function(str)\n\
    \        if str == longest_postfix then\n          local reverse = string.gsub(string,\
    \ longest_postfix, longest_postfix:reverse()) -- Reverse of the longest postfix\
    \ of string\n          -- Add the postfix of string that comes before the longest\
    \ postfix to end of the palindrome\n          string.gsub(reverse, \"%a%a\", function(str)\n\
    \            -- Find palindromic prefix of the reversed string\n            local\
    \ prefix, _, count = string.find(reverse, str, true, nil)\n            -- If the\
    \ longest postfix is greater than the length of the reversed string, no palindrome\
    \ can be found\n            if longest_postfix > count then\n              return\
    \ nil\n            else\n              return prefix .. str\n            end\n\
    \          end)\n        end\n      end)\n      return string\n    end\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find the longest postfix\
    \ that is a palindrome.\n  local suffix = ''\n  local longest_postfix = 1\n  for\
    \ i = 1,#string do\n    suffix = string\n    longest_postfix = longest_postfix\
    \ + 1\n    local suffix_len = #suffix\n    if suffix_len > 0 then\n      local\
    \ suffix_reversed = reverse(suffix)\n      if suffix_reversed ~= suffix then\n\
    \        suffix = '' -- Reverse of the reverse of this string is a palindromic\
    \ suffix.\n      end\n    end\n    if longest_postfix > suffix_len then\n    \
    \  longest_postfix = suffix_len\n    end\n  end\n  -- Append the reverse of the\
    \ string prefix that comes before this suffix.\n  local start = string\n  local\
    \ reversed = ''\n  -- Remove last character, if palindromic suffix is already\
    \ the last character.\n  if longest_postfix > 1 then\n    start = start:sub(1,\
    \ end - 1)\n    local last_character = string.sub(start, end - 1)\n    local reversed_last_character\
    \ = reverse(last_character)\n    if last_character == reversed_last_character\
    \ then\n      start = start:sub(1, end - 2)\n    end\n  end\n  if start ~= string\
    \ then\n    local reversed_start = reverse(start)\n    start = string:sub(1, #string\
    \ - 1)\n    local reversed_start = reverse(reversed_start)\n    if reversed_start\
    \ == start then\n      local reversed_end = reverse(string.sub(string:len(), #string))\n\
    \      start = string.sub(string:len(), #string - 1)\n      local reversed_end\
    \ = reverse(reversed_end)\n      if reversed_end == end then\n        start =\
    \ string.sub(1, #string - 1)\n        -- Append the reverse of the longest postfix\
    \ that comes before this suffix.\n        reversed = start .. reversed_start ..\
    \ suffix\n      end\n    end\n  end\n  return reversed\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdowatpsu.lua:34: unexpected symbol near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local prefix = string\n  local postfix = string\n  local reverse_prefix = string\n\
    \  local reversed_string = string\n  while true do\n    local len = 1\n    while\
    \ prefix and prefix:len() > len do\n      len = prefix:len()\n    end\n    if\
    \ len == 0 then\n      return palindrome\n    end\n    local postfix = string\n\
    \    for j = 1, len - 1 do\n      postfix = postfix..reverse_prefix:sub(1, reverse_prefix:len()-1)\n\
    \    end\n    local reverse_postfix = string\n    for j = 1, len - 1 do\n    \
    \  reverse_postfix = reverse_postfix..postfix:sub(1, postfix:len()-1)\n    end\n\
    \    reverse_prefix = prefix:sub(1, len)\n    reversed_string = reversed_string..reverse_postfix\n\
    \    prefix = string\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local string = string.gsub(string,\
    \ \"[()]+\", \"\")\n    local postfix, suffix = string.match(string, \"(.-)$\"\
    ) -- Split string on last character\n    local reversed = reverse(string:sub(1,\
    \ #string)) -- Reverse the prefix\n    local result = postfix + reversed + suffix\
    \ -- Concat to complete palindrome and return it.\n    return result:sub(1, #result)\
    \ -- Remove the extra padding we added.\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpkb4nnl61.lua:14:\
    \ attempt to call a nil value (global 'reverse')\nstack traceback:\n\t/tmp/tmpkb4nnl61.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpkb4nnl61.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local reversed_string\
    \ = reverse(string)\n    if string.sub(reversed_string, 1, 1) ~= reverse(string)\
    \ then\n        return string\n    elseif reversed_string == string then\n   \
    \     return string\n    elseif string.sub(reversed_string, 1, 1) ~= string.sub(reversed_string,\
    \ string.len(string) - 1, string.len(string)) then\n        return string\n  \
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdwr8_179.lua:31: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local suffix = string.sub(string,\
    \ -1, string.len(string))\n  local prefix = string.sub(string, 0, string.len(string))\n\
    \  return string.sub(prefix, 1, string.len(prefix)) + string.reverse_suffix(string.sub(suffix,\
    \ 1, string.len(suffix)))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9gfehsrz.lua:14:\
    \ attempt to call a nil value (field 'reverse_suffix')\nstack traceback:\n\t/tmp/tmp9gfehsrz.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmp9gfehsrz.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = '' --\
    \ The palindrome that begins with supplied string\n  local prefix_len = 0 -- Length\
    \ of the longest postfix of supplied string\n  for i = 1, (string:len()) do\n\
    \    prefix_len = prefix_len + 1 -- Append the reverse of the reverse of supplied\
    \ string\n    local postfix = string:sub(i, i)\n    local postfix_reverse = postfix:reverse()\n\
    \    postfix = postfix_reverse .. postfix\n    local postfix_len = #postfix\n\
    \    if postfix_len > prefix_len then\n      palindrome = palindrome .. postfix:sub(1,\
    \ prefix_len) .. postfix_reverse .. postfix:sub(prefix_len + 1, #postfix)\n  \
    \    break\n    end\n  end\n  return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7214y97d.lua:32:\
    \ expected: \"x\"\nactual: \"xxx\"\nstack traceback:\n\t/tmp/tmp7214y97d.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   if string == nil then string\
    \ = '' end\n   if #string <= 1 then return string end\n   local pre = string.sub(string,1,-1)\n\
    \   local suf = string.sub(string,string.len(string),string.len(string))\n   return\
    \ pre .. string.reverse_suffix(suf)\nend\n</code>\n<|/ a |>\n<| a |>\n<code>\n\
    string make_palindrome(string str) {\n    string revstr = str;\n    int i = 0;\n\
    \    while (i < str.length()) {\n        revstr = str.substr(i, 1) + (revstr !=\
    \ str and str[revstr.length()-1] == str[i] and revstr .. str[i] or \"\");\n  \
    \      i++;\n    }\n    return revstr;\n}\n</code>\n<|/ a tags=string,palindrome,algorithm,substring,lua\
    \ dscore=3 |>\n<| c |>\nIt would be good to add a short description of this code\
    \ snippet to the answer to make up for the lack of readability.\n<|/ c |>\n<|\
    \ a |>\nHere is my implementation of Rufus L's solution in Lua:\n<code>\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgmhc8oyn.lua:18: unexpected symbol near '<'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string\n\
    \  local reverse = ''\n  for i = #postfix, 1, -1 do\n    if string.sub(reverse,\
    \ 1, i) == string.sub(reverse, #reverse, 1, i) then\n      -- Found a palindrome.\n\
    \      reverse = string.sub(reverse, #reverse, 1, #reverse) + i\n    elseif #reverse\
    \ == 0 then\n      -- The string is a palindrome if and only if the postfix of\
    \ the reverse of the string ends with a palindrome.\n      return string.sub(reverse,\
    \ #reverse, #postfix, #postfix) == string.sub(postfix, #postfix, #reverse, #reverse)\
    \ and reverse or ''\n    end\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn6a4gc2r.lua:28:\
    \ expected: \"\"\nactual: nil\nstack traceback:\n\t/tmp/tmpn6a4gc2r.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome_start,\
    \ palindrome_len = string.find(string, \"([^\" .. reverse(string) .. \"])\", 1,\
    \ true):find(\")\")\n  if palindrome_start == nil then\n    return string\n  elseif\
    \ string.sub(palindrome_start, palindrome_len - 1) == reverse(string) then\n \
    \   return string\n  else\n    return string.sub(palindrome_start, palindrome_len\
    \ + 1)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpwh80avs5.lua:12:\
    \ attempt to call a nil value (global 'reverse')\nstack traceback:\n\t/tmp/tmpwh80avs5.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmpwh80avs5.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Make string of palindrome\n\
    \  local pal = string\n  local longest_postfix = string\n  local postfix_length\
    \ = #string\n  -- Go through all characters\n  for i = 1, postfix_length do\n\
    \    -- If character is equal to postfix from end\n    if string[i] == string[postfix_length\
    \ - i] then\n      -- Increase length of postfix by 1\n      postfix_length =\
    \ postfix_length - i + 1\n      -- Add postfix to end of longest palindrome string\n\
    \      longest_postfix = longest_postfix .. string[i]\n    else\n      -- If postfix\
    \ isn't a palindrome then append the character that comes before it.\n      longest_postfix\
    \ = longest_postfix .. string[postfix_length - i - 1]\n      -- If the character\
    \ before isn't a palindrome then append the character that comes before it.\n\
    \      longest_postfix = longest_postfix .. string[i - 1]\n      -- Increase length\
    \ of longest palindrome by 1\n      postfix_length = postfix_length - 1\n    end\n\
    \  end\n  return longest_postfix .. string[postfix_length]\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplcdxj8bs.lua:33:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmplcdxj8bs.lua:33:\
    \ in local 'candidate'\n\t/tmp/tmplcdxj8bs.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = ''\n\
    \    local prefix_end = 0\n    local last_index = 0\n    local last_char = string[#string]\n\
    \    -- TODO: optimise this and avoid extra scan\n    for i = 1, #string do\n\
    \        if string[i] ~= last_char then\n            local index = 1\n       \
    \     while index + 1 <= #string and string[i + index] == string[i + index + 1]\
    \ do\n                index = index + 1\n            end\n            prefix_end\
    \ = i + index - 1\n        end\n        if prefix_end > 0 then\n            local\
    \ index = prefix_end\n            while index + 1 <= #string and string[prefix_end\
    \ + index] == string[prefix_end + index + 1] do\n                index = index\
    \ + 1\n            end\n            palindrome = palindrome .. string[prefix_end\
    \ + index..last_index]\n            last_index = prefix_end + index - 1\n    \
    \        last_char = string[prefix_end + index..last_index]\n        end\n   \
    \ end\n    if #string > 0 then\n        palindrome = palindrome .. string[last_index..#string]\n\
    \    end\n    return palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp75nc2zr1.lua:36:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmp75nc2zr1.lua:36:\
    \ in local 'candidate'\n\t/tmp/tmp75nc2zr1.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == '' then\n \
    \   return ''\n  end\n  local palindrome, suffix = string.gsub(string, '^%s*(.-)%s*$',\
    \ '\\2'), ''\n  local length = #string\n  while length > 1 do\n    local mid =\
    \ math.floor((length-1) / 2)\n    local suffix = string.sub(string, mid+1)\n \
    \   if suffix == suffix then\n      suffix = suffix:reverse()\n      palindrome\
    \ = string.sub(palindrome, 0, mid-1) .. suffix\n      length = length - 1\n  \
    \  else\n      length = length/2\n    end\n  end\n  return palindrome\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvcttp_uh.lua:35:\
    \ expected: \"x\"\nactual: \"\x02\"\nstack traceback:\n\t/tmp/tmpvcttp_uh.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local start = 0\n    local\
    \ reverse = ''\n    local longest = 0\n    while string.sub(string,start+1,start+1)~=string.sub(string,-start,-start)\
    \ do\n        start = start+1\n        local max = 1\n        for i=1, #string+1\
    \ do\n            local len = string.len(string+reverse+string.sub(string,start,start+1))\n\
    \            if len ~= max then\n                longest = len\n             \
    \   reverse = string+string.sub(string,-start,start+1)\n            end\n    \
    \        max = len\n        end\n    end\n    return reverse+string.sub(string,start,start+1)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpi4iwla_s.lua:27:\
    \ attempt to perform arithmetic on a string value (local 'reverse')\nstack traceback:\n\
    \t/tmp/tmpi4iwla_s.lua:27: in local 'candidate'\n\t/tmp/tmpi4iwla_s.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal length = #string\n\
    \tlocal suffix\n\tlocal i = 1\n\tlocal temp\n\tlocal reversed\n\twhile i < length\
    \ do\n\t\ttemp, suffix = string.sub(string,i,i+1), suffix..temp\n\t\treversed\
    \ = temp..reversed\n\t\ti = i+1\n\tend\n\treturn reversed..suffix\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7fh2o5fa.lua:22:\
    \ attempt to concatenate a nil value (local 'reversed')\nstack traceback:\n\t\
    /tmp/tmp7fh2o5fa.lua:22: in local 'candidate'\n\t/tmp/tmp7fh2o5fa.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local prefix = string\n\
    \    local suffix = string\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpl7vry47h.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local string = string\
    \ or 'a'\n    local length = string#0\n    local postfix = \"\"\n    local prefix\
    \ = ''\n    while length > 0 do\n        postfix = string..postfix\n        if\
    \ string.len(postfix, 1, length) == string.len(postfix, 1, length):reverse()\n\
    \        end \n        length = length - 1\n    end\n    return string..postfix\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6kzg02jf.lua:13: unexpected symbol near '#'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  assert(type(string) == 'string')\n\
    \  string = string.gsub(string.lower(), '([^a-z])', '')\n  assert(string.len()\
    \ >= 2)\n  local start, finish, middle\n  for start = 1, string.len() do\n   \
    \ middle = string.sub(string,start, start + 1)\n    finish = middle .. string.sub(string,string.len()\
    \ - start, string.len() - 1)\n    if middle == string.rev(finish) then\n     \
    \ return middle\n    end\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8u3216u3.lua:13:\
    \ bad argument #1 to 'lower' (string expected, got no value)\nstack traceback:\n\
    \t/tmp/tmp8u3216u3.lua:13: in local 'candidate'\n\t/tmp/tmp8u3216u3.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  assert(type(string) == 'string')\n\
    \  local longest_postfix = find_longest_postfix_with_prefix(string)\n  local reversed_longest_prefix\
    \ = reverse(string:sub(1, longest_postfix))\n  local palindromic_suffix\n  for\
    \ i = 1, longest_postfix do\n    local start = string:sub(1 + i, i + longest_postfix)\n\
    \    local end = string:sub(i + longest_postfix, string.length)\n    palindromic_suffix\
    \ = string.reverse(end):sub(1, start + 1)\n    string = string .. reversed_longest_prefix\
    \ .. palindromic_suffix\n  end\n  return string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp5t35gz5_.lua:18: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- Base case is that the\
    \ supplied string is a palindrome.\n   if string and string.len then\n      return\
    \ string\n   end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpjz1ixeme.lua:27: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local length\n  local postfix\
    \ = string.sub(string, 1, string.len(string))\n  if string.len(postfix) <= 1 then\n\
    \    return string\n  else\n    length = string.len(postfix, 2)\n    if string.len(string)\
    \ >= length then\n      return string\n    else\n      local prefix = string.sub(string,\
    \ 0, length)\n      return prefix .. string.reverse(string.sub(postfix, 1, string.len(postfix,\
    \ 2)))\n    end\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmple3jlfuw.lua:32:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmple3jlfuw.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Find the longest postfix\
    \ that is a palindrome.\n    local max_len = string.len(string) + 1\n    local\
    \ max_len_pal = 0\n    local max_len_rpl = 0\n    for i = 1, string.len(string),\
    \ 1 do\n        local prefix = string.sub(string, 0, i)\n        local suffix\
    \ = string.sub(string, i)\n        if suffix ~= suffix:reverse() then\n      \
    \      continue\n        end\n        max_len = max_len\n        max_len_pal =\
    \ i\n        max_len_rpl = string.len(suffix)\n        break\n    end\n    if\
    \ max_len_pal <= max_len + 1 then\n        return string\n    end\n    local mid\
    \ = (max_len_pal + max_len_rpl) / 2\n    local mid_pal = string.sub(string, 0,\
    \ mid + 1) -- Find the longest palindromic suffix that comes before the mid.\n\
    \    local mid_rpl = string.sub(string, (mid + 1), string.len(string)) -- Find\
    \ the longest palindromic prefix that comes after the mid.\n    if mid_pal ~=\
    \ mid_rpl:reverse() then\n        return string\n    end\n    -- Now that we have\
    \ the mid we can combine both parts of the palindromes.\n    -- The longest suffix\
    \ of the prefix is a palindrome, append to it reverse of the longest suffix.\n\
    \    local combined_rpl = make_palindrome(string.sub(mid_rpl, 0, max_len_rpl))\n\
    \    -- The longest prefix is a palindrome, append to it the reverse of the longest\
    \ prefix.\n    local combined_pal = make_palindrome(string.sub(mid_pal, 1, max_len_pal))\n\
    \    return combined_pal .. combined_rpl\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdcqrd7aw.lua:21: syntax error near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- Reverse string\n   local\
    \ reverse = string\n      for i = #string .. 1, 1, -1 do\n         reverse = reverse\
    \ .. string[i]\n      end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpceyzm4z9.lua:28: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   local lens = string.gmatch(\"\
    %w+\", \"\") or {}\n   lens = lens or {string.len(string)}\n   local max_len =\
    \ lens[#lens]\n   if max_len == 0 then\n      return string\n   end\n   local\
    \ suffixes = string.gmatch(\"%w+$\", \"\") or {}\n   suffixes = suffixes or {\"\
    \"}\n   local pal_len = 0\n   local max_suffixes = suffixes[#suffixes]\n   local\
    \ max_len2 = max_len - max_len + max_suffixes + 1\n   local string2 = string\n\
    \   for i = 1, max_len2 do\n      local string3 = string.sub(string2, 1, i)\n\
    \      local string4 = string3:reverse()\n      local pal_string = string4 ..\
    \ string3\n      local pal_string2 = string3:reverse()\n      if pal_string ==\
    \ pal_string2 then\n         pal_len = pal_len + 1\n      elseif pal_len > 0 then\n\
    \         string2 = string2..string3..suffixes[i]\n      else\n         string2\
    \ = string2..string3\n      end\n   end\n   return string2..suffixes[max_len]\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2w1_p6bc.lua:14:\
    \ attempt to get length of a function value (local 'lens')\nstack traceback:\n\
    \t/tmp/tmp2w1_p6bc.lua:14: in local 'candidate'\n\t/tmp/tmp2w1_p6bc.lua:43: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = ''\n\
    \    local longest_palindrome = 0\n    local longest_palindrome_index = 0\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpr88y0sl3.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find the longest postfix\
    \ that is a palindrome\n  -- Algorithm idea is simple:\n  -- - Find the longest\
    \ postfix of supplied string that is a palindrome.\n  -- - Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \  local palindrome = ''\n  while string do\n    local reversed_prefix, postfix\
    \ = string.gsub(string, '^(.-)$', '\\2\\1$'), string\n    for i = #reversed_prefix,\
    \ 1, -1 do\n      if i ~= 0 then\n        -- If reverse string contains i\n  \
    \      if string.find(reversed_prefix, i, 1, true) then\n          -- We found\
    \ palindrome prefix\n          -- Append the reversed prefix\n          palindrome\
    \ = palindrome .. reversed_prefix\n          -- Exit the loop\n          break\n\
    \        end\n      end\n    end\n    -- If found a palindrome suffix\n    if\
    \ palindrome ~= '' then\n      -- Append the reversed suffix\n      palindrome\
    \ = palindrome .. reversed_postfix\n      -- Exit the loop\n      break\n    end\n\
    \    string = string.sub(string, 1)\n  end\n  return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- We don't care about\
    \ empty strings, return empty string.\n   if string == nil then\n      return\
    \ \"\"\n   end\n   -- Find the longest postfix of supplied string that is a palindrome.\n\
    \   local longest\n   local longest_length\n   for i = #string, 1, -1 do\n   \
    \   local reverse\n      local reverse_length\n      local j = i\n      while\
    \ j > 1 do\n         reverse = reverse .. string[j]\n         j = j - 1\n    \
    \  end\n      reverse = reverse .. string[i]\n      -- Find the length of the\
    \ postfix, and compare it to the length of its reversal\n      -- We want to find\
    \ the longest postfix in reversed postfix form\n      reverse_length = #reverse\n\
    \      if reverse_length > longest_length then\n         longest = reverse\n \
    \        longest_length = reverse_length\n      end\n   end\n   return longest\
    \ .. longest .. longest .. reverse\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpw8f800tw.lua:36:\
    \ attempt to concatenate a nil value (local 'longest')\nstack traceback:\n\t/tmp/tmpw8f800tw.lua:36:\
    \ in local 'candidate'\n\t/tmp/tmpw8f800tw.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  assert(type(string) == 'string')\n\
    \  local reversed = string:reverse()\n  local palindrome = reversed:sub(1, reversed:len()\
    \ - 1) + string\n  return palindrome\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9ajr67fp.lua:14:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmp9ajr67fp.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmp9ajr67fp.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffix = string\n\
    \    local suffix_len = #string\n    local prefix = string\n    local prefix_len\
    \ = #string\n    while suffix_len > 0 and prefix_len > 0 do\n        suffix =\
    \ string\n        suffix_len = #string\n        prefix = string\n        prefix_len\
    \ = #string\n        if suffix_len > prefix_len then\n            suffix = string[suffix_len+prefix_len+#string]\n\
    \            suffix_len = #suffix_len-1\n        else\n            prefix = string\n\
    \            prefix_len = #string\n        end\n        if palindrome_contains_prefix(suffix,\
    \ prefix, prefix_len) then\n            return prefix .. reverse(prefix, suffix_len)\n\
    \        end\n    end\n    return \"\"\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6hz7ch04.lua:28:\
    \ attempt to call a nil value (global 'palindrome_contains_prefix')\nstack traceback:\n\
    \t/tmp/tmp6hz7ch04.lua:28: in local 'candidate'\n\t/tmp/tmp6hz7ch04.lua:39: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string.match\
    \ string, \"([^\"..string.upper(string.sub(string, 1, string.len(string)))..\"\
    ]*)\"\n    local prefix = string.sub(string, 1, string.len(string) - string.len(postfix))\n\
    \    local reversed_prefix = string.sub(reverse(prefix), 1, -string.len(postfix))\n\
    \    return string..reversed_prefix..postfix\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_tzoaxh9.lua:12: unexpected symbol near '\"([^\"'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local longest = ''\n  local\
    \ suffix = ''\n  for i = #string, 1, -1 do\n    suffix = suffix .. string[i]\n\
    \    if suffix == string.reverse(suffix) then\n      longest = suffix .. longest\n\
    \    end\n  end\n  return longest\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpp0kz3zom.lua:15:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpp0kz3zom.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpp0kz3zom.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local index = string.len()\n\
    \    local max_index = index\n    while index do\n        local current = string[index]\n\
    \        local max_current = string.sub(string, index, max_index - 1)\n      \
    \  if current ~= max_current then\n            return string[max_index:index]\
    \ .. string.reverse_prefix(max_current) .. current\n        end\n        index\
    \ = math.max(0, index - 1)\n    end\n    return ''\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpn_9gy7is.lua:18: function arguments expected near ']'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Find longest palindromic\
    \ postfix of string.\n    local prefix_length = #string + 1\n    local max_postfix_length\
    \ = #string + 1\n    local postfix = string\n    while postfix ~= '' do\n    \
    \    postfix = postfix:reverse()\n        local postfix_length = #postfix + 1\n\
    \        if postfix_length >= max_postfix_length then\n            max_postfix_length\
    \ = postfix_length\n        end\n    end\n    if max_postfix_length < prefix_length\
    \ then\n        return string\n    end\n    -- Prepend the reverse of the string\
    \ prefix of length prefix_length that comes before max_postfix_length.\n    local\
    \ reversed_prefix_length = max_postfix_length\n    while reversed_prefix_length\
    \ < prefix_length do\n        -- Append the reverse of supplied string prefix\
    \ of length prefix_length that comes before max_postfix_length.\n        reversed_prefix_length\
    \ = reversed_prefix_length * 2 + 1\n    end\n    return reversed_prefix_length\
    \ .. string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sfadiaz.lua:38:\
    \ expected: \"\"\nactual: \"1\"\nstack traceback:\n\t/tmp/tmp2sfadiaz.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Find longest palindrome\
    \ in string.\n    local suffix_postfix = string.match('^([^' .. string.char(126,\
    \ 126, 126) .. ']+)' .. string, '%..?%') or ''\n    local longest_postfix = ''\n\
    \    for i = 1, string.len(string) - 1 do\n        local postfix = string.sub(s,\
    \ i, i + 1)\n        if string.match(postfix, suffix) then\n            longest_postfix\
    \ = longest_postfix .. postfix\n        else\n            break\n        end\n\
    \    end\n    -- Append to longest postfix, reverse string prefix before longest\
    \ postfix.\n    return longest_postfix .. string.reverse_apply(string.sub(s, 1,\
    \ i - 1)) .. string.sub(suffix_postfix, string.len(longest_postfix), 1)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpvs0irqqe.lua:24:\
    \ attempt to perform arithmetic on a nil value (global 'i')\nstack traceback:\n\
    \t/tmp/tmpvs0irqqe.lua:24: in local 'candidate'\n\t/tmp/tmpvs0irqqe.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find longest palindromic\
    \ suffix:\n  local longest_suffix = longest_postfix_substring_reverse(string,\
    \ true)\n  -- If there are no palindromic suffixes, then we do not need to do\
    \ anything:\n  if longest_suffix == nil then\n    return string\n  else\n    --\
    \ Add longest palindromic suffix to the end of the string reverse:\n    local\
    \ new_string = string .. longest_suffix\n    -- Prepend longest palindromic suffix\
    \ to the beginning of the string reverse:\n    new_string = longest_suffix ..\
    \ string\n    return new_string\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpsi8bksw2.lua:13:\
    \ attempt to call a nil value (global 'longest_postfix_substring_reverse')\nstack\
    \ traceback:\n\t/tmp/tmpsi8bksw2.lua:13: in local 'candidate'\n\t/tmp/tmpsi8bksw2.lua:29:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string == nil then\n\
    \        return 'nil'\n    end\n    if string == '' then\n        return ''\n\
    \    end\n    if string == 'nil' then\n        return nil\n    end\n    local\
    \ string2 = string\n    local longest, p1 = find_longest_postfix_of_string_palindrome(string)\n\
    \    if p1 ~= nil then\n        local p2 = string.sub(p1, string.len(p1))\n  \
    \      string2 = string2 .. p2 .. p2\n    end\n    if longest ~= nil then\n  \
    \      local p3 = string.sub(longest, longest, string.len(longest))\n        string2\
    \ = string2 .. p3 .. p3\n    end\n    return string2\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfpxcuyni.lua:22:\
    \ attempt to call a nil value (global 'find_longest_postfix_of_string_palindrome')\n\
    stack traceback:\n\t/tmp/tmpfpxcuyni.lua:22: in local 'candidate'\n\t/tmp/tmpfpxcuyni.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local start, end = string.find(string,\
    \ '^(.-)$')\n    if start == nil then return string end\n    local palindrome\
    \ = string.sub(string, start, end)\n    local reversed_start, end_reversed = string.find(string,\
    \ '^..' .. palindrome, '^.$')\n    if end_reversed == nil then\n        return\
    \ string\n    end\n    local reversed_end = end_reversed + 2\n    local reversed\
    \ = string.sub(string, end, reversed_end)\n    return string.rep(palindrome, 1,\
    \ #string + 1) .. reversed .. reversed\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfv9nr1f2.lua:12: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- No string\n    if string\
    \ == nil then\n        return string\n    end\n    -- The empty string\n    if\
    \ string == '' then\n        return string\n    end\n    -- The supplied string\
    \ is not the empty string\n    if string ~= '' and string ~= nil and string ~=\
    \ '(null)' then\n        -- Convert the string to lowercase\n        string =\
    \ string.lower()\n        -- Reverse the string\n        local function reverse(string)\n\
    \            -- Reverse the string\n            local function reverse_recur(string,\
    \ i, temp)\n                if i ~= 0 then\n                    temp = string[i]\n\
    \                    string[i] = string[-i]\n                    string[-i] =\
    \ temp\n                    reverse_recur(string, i - 1, temp)\n             \
    \   end\n            end\n            reverse_recur(string, #string, string)\n\
    \        end\n        -- Find the longest postfix of supplied string that is a\
    \ palindrome\n        local function postfix_length(string)\n            -- If\
    \ no postfix is found or if the supplied string is too short\n            if #string\
    \ <= 0 then\n                return nil\n            end\n            -- The length\
    \ of a postfix is equal to the length of the string - 1\n            local function\
    \ length_of(string)\n                -- If no postfix is found or if the supplied\
    \ string is too short\n                if #string <= 0 then\n                \
    \    return nil\n                end\n                return #string - 1\n   \
    \         end\n            -- Start with the longest postfix of supplied string\
    \ that is a palindrome\n            local postfix = string[#string]\n        \
    \    -- Stop if the postfix is too long\n            while postfix ~= nil do\n\
    \                -- Add the prefix to the string\n                string = string..postfix\n\
    \                -- Reverse the string\n                reverse(string, 1, #string\
    \ + 1)\n                -- Stop if the length of the postfix is equal to the length\
    \ of the string - 1\n                while length_of(postfix - 1) ~= length_of(#string)\
    \ do\n                    -- Add two characters to the end of the string\n   \
    \                 string = string..string[#string]\n                    -- Reverse\
    \ the string\n                    reverse(string, 1, #string + 1)\n          \
    \      end\n                -- Stop if the length of the postfix is equal to the\
    \ length of the string - 1\n                while length_of(postfix) ~= length_of(#string)\
    \ do\n                    -- Add one character to the end of the string\n    \
    \                string = string..string[#string]\n                    -- Reverse\
    \ the string\n                    reverse(string, 1, #string + 1)\n          \
    \      end\n                -- Stop if the length of the postfix is equal to the\
    \ length of the string - 1\n                while length_of(postfix) ~= length_of(#string)\
    \ do\n                    -- Add one character to the end of the string\n    \
    \                string = string\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpwtci9hw9.lua:88: 'end' expected (to close 'while' at line\
    \ 74) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local max_len = tonumber(string):reverse():len()\n\
    \    return string..string.reverse()\n            :gsub('^'..string..'$', function(postfix,\
    \ idx)\n                return postfix .. string[idx:max_len+idx]\n          \
    \  end)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8wos9ucu.lua:15: function arguments expected near '+'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  assert(type(string) == 'string',\
    \ 'make_palindrome() arg 1 must be a string')\n  local prefix_palindrome = string\n\
    \  local suffix_palindrome = string\n  local max_prefix = string\n  local max_suffix\
    \ = string\n  local prefix_suffix = string\n  local suffix_prefix = string\n \
    \ -- Keep shrinking prefix until we hit a palindromic suffix, then stop shrinking\
    \ suffix.\n  -- This works because prefix and suffix are substrings of strings.\n\
    \  while not suffix_prefix:find(string, '^[%a%d]+$') do\n    prefix_palindrome\
    \ = string\n    suffix_prefix = string\n    suffix_prefix = suffix_prefix:gsub(string:reverse(),\
    \ '^[%a%d]+$')\n    suffix_prefix = string.sub(suffix_prefix, 1, -2)\n    -- Update\
    \ the max prefix and suffix.\n    max_prefix = string.sub(prefix_palindrome, 1,\
    \ -string.len(suffix_prefix))\n    if prefix_palindrome > max_prefix then\n  \
    \    max_prefix = prefix_palindrome\n    end\n    max_suffix = string.sub(suffix_prefix,\
    \ 1, -string.len(suffix_prefix))\n    if suffix_prefix > max_suffix then\n   \
    \   max_suffix = suffix_prefix\n    end\n  end\n  -- Build the palindrome by concatenating\
    \ the prefix\n  -- and suffix of the max palindrome.\n  local palindrome = max_prefix\
    \ .. string.sub(suffix_prefix, 1, -string.len(max_suffix))\n  return palindrome\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1x_pgbq5.lua:21:\
    \ bad argument #2 to 'find' (number expected, got string)\nstack traceback:\n\t\
    /tmp/tmp1x_pgbq5.lua:21: in local 'candidate'\n\t/tmp/tmp1x_pgbq5.lua:45: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome_prefix\n\
    \    local palindrome_suffix\n    local palindrome_length = 0\n    local longest_postfix_length\n\
    \    local longest_postfix_string\n    local longest_postfix_start_index\n   \
    \ local longest_postfix_end_index\n    local longest_postfix_string_reversed\n\
    \    local longest_postfix_start_index_reversed\n    local longest_postfix_end_index_reversed\n\
    \    -- Find the longest postfix of supplied string that is a palindrome.\n  \
    \  local palindrome_prefix_length = 0\n    local longest_postfix_start_index_for_longest_postfix_string\n\
    \    local longest_postfix_end_index_for_longest_postfix_string\n    for i = 1,\
    \ #string do\n        -- Get longest postfix that is a palindrome.\n        longest_postfix_start_index\
    \ = 1\n        longest_postfix_end_index = i\n        longest_postfix_start_index_for_longest_postfix_string\
    \ = longest_postfix_start_index\n        longest_postfix_end_index_for_longest_postfix_string\
    \ = longest_postfix_end_index\n        longest_postfix_start_index_reversed =\
    \ longest_postfix_start_index\n        longest_postfix_end_index_reversed = longest_postfix_end_index\n\
    \        longest_postfix_string = \"\"\n        while i < longest_postfix_end_index\
    \ do\n            longest_postfix_string = longest_postfix_string .. string[i]\n\
    \            i = i + 1\n        end\n        -- Reverse the longest postfix that\
    \ is a palindrome.\n        longest_postfix_string_reversed = longest_postfix_string\n\
    \        while 1 do\n            longest_postfix_string_reversed = longest_postfix_string_reversed:reverse()\n\
    \            longest_postfix_string_reversed = longest_postfix_string_reversed:reverse()\n\
    \            if longest_postfix_string_reversed == longest_postfix_string then\n\
    \                break\n            end\n        end\n        -- Compare longest\
    \ postfix that is a palindrome to string prefix.\n        longest_postfix_length\
    \ = #longest_postfix_string\n        if longest_postfix_length < palindrome_prefix_length\
    \ then\n            palindrome_prefix = longest_postfix_string\n            palindrome_prefix_length\
    \ = longest_postfix_length\n        end\n        -- Compare longest postfix that\
    \ is a palindrome to string suffix.\n        if longest_postfix_length < palindrome_suffix\
    \ then\n            palindrome_suffix = longest_postfix_string\n        end\n\
    \    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdkyn889k.lua:70: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  assert(type(string) == 'string',\
    \ 'make_palindrome(string) - string expected')\n  local length\n  local suffix\n\
    \  local stringPrefix\n  local stringSuffix\n  local stringReversePrefix\n  local\
    \ stringReverseSuffix\n  local stringPrefixReverse\n  local stringSuffixReverse\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8ym6oxdu.lua:32: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find the longest postfix\
    \ palindrome.\n  local longest_palindrome = string.gsub(string, '(%.*)$', \"\\\
    \\1\")\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpl4mhnkou.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string == '' or string\
    \ == nil then\n        return string\n    end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmptm15hmkc.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local reversed_string\n\
    \  local length\n  if string == nil then\n    string = ''\n  elseif string.sub\
    \ or string.gsub then\n    local sub_length = string.sub or string.gsub\n    --\
    \ Hack: Lua 5.2 doesn't support string.gsub on tables.\n    local prefix_table\
    \ = {}\n    prefix_table[sub_length] = '^' .. string\n    prefix_table['^.'] =\
    \ '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table['^.']\
    \ = '^' .. string\n    prefix_table['^.'] = '^' .. string\n    prefix_table\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpm38427fk.lua:58: syntax error near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local result = string\n\
    \    local longest = ''\n    local longestlength = 0\n    local islongest = false\n\
    \    for i = 1, #string do\n        local substring = string[i:(i+1)]\n      \
    \  local reverse = substring .. reverse(string:sub(1, i-1))\n        if substring\
    \ == reverse then\n            if #substring > longestlength then\n          \
    \      longest = substring\n                longestlength = #substring\n     \
    \           islongest = true\n            end\n        end\n    end\n    if islongest\
    \ then\n        result = result .. reverse .. longest\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppi5uwmx4.lua:17: <name> expected near '('\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then\n \
    \       return string\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpv2rvktpi.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- base case -- palindromes\
    \ always begin with supplied string\n  if string == '' then\n    return string\n\
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpangl56i_.lua:27: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local longest_postfix_len\
    \ = #string + 1\n    local string_prefix = string\n    for i = 1, longest_postfix_len\
    \ % 2 do\n        string_prefix = string_prefix .. string[i]\n    end\n    local\
    \ prefix_length = longest_postfix_len / 2 - 1\n    local palindromic_suffix =\
    \ string_prefix[prefix_length]\n    return string..palindromic_suffix\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpp30o3csq.lua:15:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpp30o3csq.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpp30o3csq.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  assert(string ~= nil, \"\
    'string' cannot be nil\")\n  assert(string ~= \"\", \"'string' cannot be empty\"\
    )\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphup4pfd9.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffix = ''\n  \
    \  local longest = 0\n    for i=1,#string do\n        local character = string[i]\n\
    \        local postfix = character\n        for j=1,i do\n            postfix\
    \ = postfix + string[j]\n        end\n        longest = longest > #postfix and\
    \ #postfix or longest\n        if longest == #postfix then\n            suffix\
    \ = postfix .. suffix\n        end\n    end\n    return suffix .. string:sub(1,longest:end)\
    \ .. reverse(string:sub((longest+1):end))\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpe8gojsii.lua:25: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string == '' then\n\
    \        return string\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpovbq7s8m.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   assert(type(string) ==\
    \ 'string')\n   local reversed_string = string\n   local prefix = ''\n   while\
    \ string ~= reversed_string do\n      reversed_string = reversed_string .. string.sub(string,\
    \ 1, #string - 1)\n      prefix = prefix .. string\n      string = string.sub(string)\n\
    \   end\n   assert(prefix ~= reversed_string)\n   return prefix .. reversed_string\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdaf1bbvh.lua:20:\
    \ assertion failed!\nstack traceback:\n\t/tmp/tmpdaf1bbvh.lua:20: in local 'candidate'\n\
    \t/tmp/tmpdaf1bbvh.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- If no string is supplied\
    \ or the string is empty, return the empty string.\n  if not string or string\
    \ == '' then return '' end\n  -- If string is 1 character or longer, return the\
    \ string\n  if string[1] or #string <= 1 then return string end\n  -- Split the\
    \ string into two parts: the front of the string and the\n  -- the back of the\
    \ string.\n  local prefix, suffix = string:gsub(\"(.)([^\" .. string.char(0x20)\
    \ .. \"]+)\\\\1+\", \"%2\")\n  -- If the supplied string is exactly half, return\
    \ the half of the string\n  if #suffix % 2 == 1 and suffix[#suffix] ~= '\\' then\
    \ return suffix end\n  -- Find the length of the longest palindromic suffix.\n\
    \  local longest_suffix = 0\n  local suffix_length = #suffix\n  while suffix_length\
    \ > 1 do\n    longest_suffix = suffix[#suffix]\n    suffix_length = suffix_length\
    \ - 1\n  end\n  -- Create a reversed copy of the front of the string.\n  local\
    \ reversed_prefix = prefix:reverse()\n  -- Create the palindrome from the reversed\
    \ prefix, the postfix of\n  -- string, and finally the reversed suffix.\n  local\
    \ palindrome = reversed_prefix .. suffix[#suffix:reverse()] .. reversed_prefix\n\
    \  return palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpbzf307n4.lua:20: unfinished string near ''' then return suffix\
    \ end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- If string is empty or\
    \ null, return empty string.\n  if string == nil or string == '' then\n    return\
    \ string\n  end -- if string == nil or string == '' then\n  -- Create reversed\
    \ string.\n  local reversed_string = string\n  reversed_string:reverse()\n  --\
    \ Create palindromic prefix.\n  local palindromic_prefix = reversed_string\n \
    \ -- Create reverse of palindromic prefix.\n  local reverse_of_palindromic_prefix\
    \ = reversed_string:reverse()\n  -- If there is no reverse of palindromic prefix,\
    \ return empty string.\n  -- This is because there is no way to determine if original\
    \ string is a palindrome.\n  if reverse_of_palindromic_prefix == nil then\n  \
    \  return string\n  end -- if reverse_of_palindromic_prefix == nil then\n  --\
    \ If original string is not a palindrome, return string.\n  if palindromic_prefix\
    \ ~= reverse_of_palindromic_prefix then\n    return string\n  end -- if palindromic_prefix\
    \ ~= reverse_of_palindromic_prefix then\n  -- If string is empty or null, return\
    \ empty string.\n  if string == nil or string == '' then\n    return string\n\
    \  end -- if string == nil or string == '' then\n  -- If there is no way to determine\
    \ if original string is a palindrome, return string.\n  return string\nend --\
    \ make_palindrome(string)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqldqrfht.lua:45:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmpqldqrfht.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Base case: the string\
    \ is empty or contains only one char\n  if string == '' or string == 'c' or string\
    \ == 'a' then return '' end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpjid9s5lz.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == '' then return\
    \ '' end\n  local longest, longestLength = palindrome(string.sub(1, string.len(string)))\n\
    \  local result = string\n  -- Now append the palindrome suffix.\n  for i = 1,\
    \ longestLength do\n    result = result .. string.sub(string, longestLength -\
    \ i - 1, longestLength - i)\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpvtx5_xvk.lua:13:\
    \ attempt to call a nil value (global 'palindrome')\nstack traceback:\n\t/tmp/tmpvtx5_xvk.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpvtx5_xvk.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == '' then return\
    \ '' end\n  -- Find the longest postfix that is a palindrome.\n  local function\
    \ postfix_is_palindrome(string, index)\n    local prefix_end = index + string.len()\n\
    \    local suffix_start = string.len() - index\n    local substring = string.sub(string,\
    \ index, prefix_end)\n    local reversed_substring = string.sub(string, suffix_start,\
    \ reverse(string.len()))\n    return substring == reversed_substring\n  end\n\
    \  local longest_postfix = longest(postfix_is_palindrome)\n  -- Append to the\
    \ end of the string reverse of a string prefix that comes before the longest postfix\
    \ that is a palindrome.\n  local function append_to_palindrome(string, suffix_start)\n\
    \    local prefix_end = suffix_start - longest_postfix + 1\n    local substring\
    \ = string.sub(string, prefix_end, string.len() - 1)\n    local reversed_substring\
    \ = string.sub(string, prefix_end, reverse(string.len() - prefix_end))\n    return\
    \ reversed_substring .. substring\n  end\n  return append_to_palindrome(string,\
    \ string.len() - longest_postfix - 1)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpm1e4jkx8.lua:21:\
    \ attempt to call a nil value (global 'longest')\nstack traceback:\n\t/tmp/tmpm1e4jkx8.lua:21:\
    \ in local 'candidate'\n\t/tmp/tmpm1e4jkx8.lua:36: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then return\
    \ string end\n    local index = string.find(string.gsub(string, '(.)(.)', '\\\
    2*'), '.', true)\n    local palindrome = string\n    while index and string.sub(palindrome,\
    \ 0, index) ~= reverse(string:sub(index, index)) do\n        index = string.find(string.gsub(string,\
    \ '(.)(.)', '\\2*'), '.', true)\n    end\n    return palindrome .. string\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_utcqqho.lua:13:\
    \ bad argument #3 to 'find' (number expected, got boolean)\nstack traceback:\n\
    \t/tmp/tmp_utcqqho.lua:13: in local 'candidate'\n\t/tmp/tmp_utcqqho.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then\n \
    \       return nil\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3qr2hoid.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Create a string with\
    \ only the characters we want to keep\n    -- (so we'll just end up with one character)\n\
    \    local palindrome = ''\n    local suffix = ''\n    local prefix = ''\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1s77my4g.lua:28: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == '' then\n \
    \   return ''\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpu10dnv6u.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tassert(type(string) == 'string')\n\
    \tassert(string~='' and string~='\\0')\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpwm6pvafj.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local rev_string = ''\n\
    \    local is_palindrome = true\n    for idx = 1, #string do\n        rev_string\
    \ = string.sub(rev_string, 1, #rev_string - 1)\n        rev_string = string.sub(rev_string,\
    \ 1, #string + idx)\n        if string == rev_string then\n            is_palindrome\
    \ = true\n            break\n        end\n        if #rev_string < #string then\n\
    \            is_palindrome = false\n            break\n        end\n    end\n\
    \    if is_palindrome then\n        return string\n    else\n        return string.sub(string,\
    \ 1, #string - 1)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpii6fymqh.lua:37:\
    \ expected: \"x\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpii6fymqh.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local length = #string\n\
    \  local index = string.find('^..$')\n  if index == -1 then return string end\n\
    \  local start = string.sub(string, 1, index)\n  local end = string.sub(string,\
    \ index+1)\n  local reverse = end\n  reverse:gsub(\"(.)(.)\", function(c) return\
    \ reverse:sub(1, reverse.len()) .. c end)\n  return reverse .. start\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfxkpk7zv.lua:16: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then return\
    \ '' end\n  local result = string\n  local i = 0\n  while i <= #result-1 do\n\
    \    if #result > i-1 then\n      if result[#result-i] == result[#result-i-1]\
    \ then\n        local substring = string.sub(result,i,#result)\n        result\
    \ = (string.sub(result,1,#result-1)),(string.sub(result,#result+1)),substring\n\
    \      else\n        local substring = string.sub(result,i,#result-1)\n      \
    \  result = (string.sub(result,1,#result-1)),substring,(string.sub(result,#result))\n\
    \      end\n    end\n    i = i+1\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe1jdf8iq.lua:34:\
    \ expected: \"x\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpe1jdf8iq.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffix = ''\n  \
    \  local longest_palindrome = ''\n    for i = 1, #string do\n        suffix =\
    \ string:sub(i, i) or ''\n        if suffix:sub(1, #suffix ~= #longest_palindrome)\
    \ then\n            longest_palindrome = suffix:reverse():gsub('%A+', '') and\
    \ longest_palindrome\n        end\n    end\n    return longest_palindrome .. string\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpb3ajmvt3.lua:16:\
    \ bad argument #2 to 'sub' (number expected, got boolean)\nstack traceback:\n\t\
    /tmp/tmpb3ajmvt3.lua:16: in local 'candidate'\n\t/tmp/tmpb3ajmvt3.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string == nil then\n\
    \        string = '(nil)'\n    end\n    local length = 0\n    for i = 1, #string\
    \ do\n        length = length + 1\n    end\n    local stringprefix = string:sub(0,\
    \ length)\n    local stringsuffix = string:sub(length)\n    local reversestringprefix\
    \ = stringprefix:reverse()\n    local palindrome = stringprefix .. stringsuffix\
    \ .. reversestringprefix\n    return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9psjul11.lua:30:\
    \ expected: \"x\"\nactual: \"xxx\"\nstack traceback:\n\t/tmp/tmp9psjul11.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local post_palindrome_length\
    \ = 1 + string.sub(string, 1, string).reverse():bytes()\n    local prefix = 'a'\n\
    \    local suffix = 'z'\n    local palindrome = string\n    for i=1, post_palindrome_length\
    \ do\n        local palindrome_postfix = string.sub(string, string.len(prefix)\
    \ + i, string.len(string))\n        local palindrome_prefix = palindrome_postfix:reverse()\n\
    \        local palindrome_suffix = palindrome_prefix:sub(1, palindrome_prefix:len()\
    \ - 1)\n        local reversed_palindrome_postfix = string.sub(palindrome_postfix,\
    \ 1, palindrome_postfix:len() - 1)\n        local reversed_palindrome_prefix =\
    \ reversed_palindrome_postfix:reverse()\n        local reversed_palindrome_suffix\
    \ = reversed_palindrome_prefix:sub(1, reversed_palindrome_prefix:len() - 1)\n\
    \        local new_palindrome = reversed_palindrome_prefix .. prefix .. palindrome_suffix\n\
    \        if new_palindrome == palindrome then\n            return new_palindrome\n\
    \        end\n        prefix = palindrome_prefix\n        suffix = palindrome_suffix\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_o2um348.lua:12:\
    \ bad argument #3 to 'sub' (number expected, got string)\nstack traceback:\n\t\
    /tmp/tmp_o2um348.lua:12: in local 'candidate'\n\t/tmp/tmp_o2um348.lua:35: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local length = #string\n\
    \    local max_len = length\n    if length > 1 then\n        for i = 1, length\
    \ do\n            local j = length - i\n            local substring = string..string[j:j+j]\n\
    \            if substring == substring:reverse then\n                max_len =\
    \ j\n                string = string.sub(1, j)\n                break\n      \
    \      end\n        end\n    end\n    return string..string[max_len]\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7acdwsl5.lua:17: function arguments expected near '+'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  assert(string, \"bad string\"\
    )\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpq7ayfto4.lua:24: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- Return palindrome\n\
    \   if string == nil then return end\n   -- Get palindrome\n   local palindrome\
    \ = string\n   -- Reverse string to find longest postfix with palindromic suffix.\n\
    \   local prefix_len, suffix_len = string.len(string), string.len(string) * string.len(string)\
    \ - 1\n   while suffix_len ~= 0 do\n      -- Get postfix of supplied string.\n\
    \      local postfix = string.sub(palindrome, 1, prefix_len) + string.sub(palindrome,\
    \ prefix_len + 1, suffix_len)\n      -- Check if supplied postfix is a palindrome.\n\
    \      if string.reverse(postfix) == palindrome then\n         -- Store postfix\
    \ of supplied string.\n         palindrome = postfix\n         -- Reverse postfix\
    \ to get postfix of supplied string.\n         prefix_len, suffix_len = string.len(string),\
    \ string.len(string) * string.len(string) - 1\n      else\n         -- Get longest\
    \ postfix of supplied string.\n         prefix_len, suffix_len = string.len(string),\
    \ string.len(string) - string.len(postfix) - 1\n      end\n   end\n   -- Return\
    \ palindrome\n   return palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0u275h4c.lua:20:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmp0u275h4c.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmp0u275h4c.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- First, find the longest\
    \ palindrome that has non-alphanumeric chars.\n  local longest_palindrome_pattern_start\
    \ = string.len()\n  local longest_palindrome_pattern\n  repeat\n    local palindrome_start\
    \ = string.find(string, string.rep(\"[^a-zA-Z0-9]\"))\n    -- No more palindromes.\n\
    \    if palindrome_start == nil then\n      break\n    end\n    -- Find the palindrome\
    \ starting at longest palindrome pattern.\n    local palindrome_pattern = string.sub(string,\
    \ longest_palindrome_pattern_start, palindrome_start)\n    -- Reverse palindrome\
    \ pattern.\n    palindrome_pattern = string.gsub(palindrome_pattern, \"[\" ..\
    \ string.reverse(palindrome_pattern) .. \"]\", \"\")\n    -- Check if palindrome\
    \ pattern has non-alphanumeric chars.\n    if palindrome_pattern:match(\"[^a-zA-Z0-9]\"\
    ) then\n      longest_palindrome_pattern = palindrome_pattern\n    end\n    longest_palindrome_pattern_start\
    \ = palindrome_start + 1\n  until longest_palindrome_pattern == nil\n  -- Append\
    \ reverse of the palindrome pattern to the end of the string.\n  return string.sub(string,\
    \ longest_palindrome_pattern_start, string.len() + longest_palindrome_pattern.len())\
    \ .. string.reverse(longest_palindrome_pattern)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpi7gykzo_.lua:13:\
    \ bad argument #1 to 'len' (string expected, got no value)\nstack traceback:\n\
    \t/tmp/tmpi7gykzo_.lua:13: in local 'candidate'\n\t/tmp/tmpi7gykzo_.lua:38: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Find the length of\
    \ the original palindromic suffix\n    local suffix_length = len(string) - string[#string]\
    \ ~= string\n    -- Find longest postfix that is a palindrome\n    local postfix,\
    \ max_length = find_longest_palindrome(string)\n    -- Append to the end of the\
    \ original palindromic suffix the reverse of the postfix that comes before the\
    \ palindromic suffix.\n    return string..string.rev(string.sub(string, 1, max_length\
    \ + suffix_length))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4blo21q4.lua:13:\
    \ attempt to call a nil value (global 'len')\nstack traceback:\n\t/tmp/tmp4blo21q4.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmp4blo21q4.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- If the string isn't\
    \ a palindrome, return empty.\n   -- >>> make_palindrome('racecar')\n   -- ''\n\
    \   -- >>> make_palindrome('racecar')\n   -- 'racecar'\n   if string ~= string.gsub(string,\
    \ '[%a][%a]', function(c) return c:lower() end) then\n      return string\n  \
    \ end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpjru7tlhf.lua:31: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local string = string\n\
    \        -- remove all spaces from the string\n        -- this way 'ca ta' becomes\
    \ 'cat'\n        -- and 'cata' becomes 'catac'\n        -- and 'cat' becomes 'catac'\n\
    \        -- this way 'a cata' becomes 'acat'\n        -- and 'a cat' becomes 'acat'\n\
    \        -- this way 'a cata a' becomes 'acat'\n        -- this way 'a cat' becomes\
    \ 'acat'\n        -- this way 'cat cata a' becomes 'cat'\n        -- this way\
    \ 'c a t a' becomes 'cat'\n        -- this way 'c a ta' becomes 'cat'\n      \
    \  -- this way 'ca' becomes 'ca'\n        -- this way 'cata' becomes 'catac'\n\
    \        -- this way 'cataca' becomes 'catac'\n        -- this way 'catacaa' becomes\
    \ 'catacaa'\n        -- this way 'cat' becomes 'catac'\n        -- this way 'catcata'\
    \ becomes 'catcatac'\n        -- this way 'catcataca' becomes 'catcatacaa'\n \
    \       -- this way 'catcatacaa' becomes 'catcatacaa'\n        -- this way 'catacaa'\
    \ becomes 'catacaa'\n    string = string.gsub(' ', '', string)\n    local longest\n\
    \    for i = 1, string.lenght do\n        longest = longest .. string[i]\n   \
    \ end\n    longest = longest\n    longest = longest\n    longest = longest\n \
    \   longest = longest\n    longest = longest\n    longest = longest\n    longest\
    \ = longest\n    longest = longest\n    longest = longest\n    longest = longest\n\
    \    longest = longest\n    longest = longest\n    longest = longest\n    longest\
    \ = longest\n    longest = longest\n    longest = longest\n    longest = longest\n\
    \    longest = longest\n    longest = longest\n    longest = longest\n    longest\
    \ = longest\n    longest = longest\n    longest = longest\n    longest = longest\n\
    \    longest = longest\n    longest = longest\n    longest = longest\n    longest\
    \ = longest\n    longest = longest\n    longest = longest\n    longest = longest\n\
    \    longest = longest\n    longest = longest\n    longest = longest\n    longest\
    \ = longest\n    longest = longest\n    longest = longest\n    \nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmptauy3xrf.lua:87: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local result = string\n\
    \    local max_len = 0\n    for i = 1, #string do\n        local j = string:len()\n\
    \        while j > 0 do\n            if string[j] == string[j-1] then\n      \
    \          j--\n            else\n                local len = j - i + 1\n    \
    \            if len > max_len then\n                    result = string\n    \
    \                max_len = len\n                end\n                break\n \
    \           end\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp47e4i3pf.lua:19: syntax error near 'else'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local result = string\n\
    \    local postfix = string.len(string) - string.len(string:reverse())\n    while\
    \ postfix:len() > 1 do\n        local postfix = string.sub(string, postfix, postfix)\n\
    \        local prefix = string.sub(string, 1, string.len(string) - postfix - 1)\n\
    \        local reversed_prefix = string.reverse(prefix)\n        result = prefix..reversed_prefix..result\n\
    \    end\n    return string.reverse(result)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0i1aymcx.lua:14:\
    \ attempt to index a number value (local 'postfix')\nstack traceback:\n\t/tmp/tmp0i1aymcx.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmp0i1aymcx.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   if string.len() == 0 then\n\
    \      return string\n   end\n   local prefix = string.sub(string, 1, string.len(string)\
    \ - 1)\n   local suffix\n   if string.len(string) == 1 then\n      suffix = ''\n\
    \   else\n      suffix = string.sub(string)\n   end\n   local reversed_prefix\n\
    \   local reversed_suffix\n   if suffix == prefix then\n      reversed_prefix\
    \ = ''\n      reversed_suffix = suffix\n   else\n      reversed_prefix = reverse(prefix)\n\
    \      reversed_suffix = reverse(suffix)\n   end\n   local palindrome = string.sub(prefix,\
    \ 1, string.len(prefix) - 1) .. reversed_prefix .. reversed_suffix\n   return\
    \ palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprx1x7p54.lua:12:\
    \ bad argument #1 to 'len' (string expected, got no value)\nstack traceback:\n\
    \t/tmp/tmprx1x7p54.lua:12: in local 'candidate'\n\t/tmp/tmprx1x7p54.lua:38: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffix = ''\n  \
    \  local longest_palindrome = string.gsub(string, \"%.%.\")\n    local prefix\
    \ = ''\n    for i = 1, #longest_palindrome do\n        local substring = longest_palindrome:sub(1,\
    \ i)\n        prefix = prefix..substring.gsub(string, \"%.%.\")\n    end\n   \
    \ local reversed_prefix = prefix:reverse()\n    return string..reversed_prefix..suffix\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpw2_3gqyu.lua:13:\
    \ bad argument #3 to 'gsub' (string/function/table expected)\nstack traceback:\n\
    \t/tmp/tmpw2_3gqyu.lua:13: in local 'candidate'\n\t/tmp/tmpw2_3gqyu.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if not string then return\
    \ '' end\n  local reverse, prefix\n  reverse = \"\"\n  prefix = \"\"\n  local\
    \ max_prefix_len = -1\n  local max_suffix_len = -1\n  for i=1, #string do\n  \
    \  local char = string.sub(char, i, i)\n    -- We found a palindrome suffix.\n\
    \    if reverse:sub(#reverse - 1, #reverse) == char then\n      reverse = reverse..char\n\
    \      -- We found a palindrome prefix.\n      if prefix:sub(#prefix - 1, #prefix)\
    \ == char then\n        prefix = prefix..char\n      else\n        -- Reset prefix\
    \ to its current value.\n        prefix = char\n      end\n      -- We found a\
    \ palindrome suffix.\n      elseif prefix:sub(#prefix - 1, #prefix) == char then\n\
    \        prefix = prefix..char\n      end\n    else\n      reverse = reverse..char\n\
    \      prefix = prefix..char\n    end\n    -- Find the longest palindrome prefix\
    \ that ends with the longest palindrome suffix.\n    if max_suffix_len < #reverse\
    \ then\n      max_suffix_len = #reverse\n    end\n    if max_prefix_len < #prefix\
    \ then\n      max_prefix_len = #prefix\n    end\n  end\n  if max_prefix_len >\
    \ max_suffix_len then\n    -- No palindrome suffix found.\n    return ''\n  end\n\
    \  local palindrome = prefix\n  local j = 1\n  for i=1, #reverse do\n    if reverse:sub(i,\
    \ #reverse) == string.sub(palindrome, j, #palindrome) then\n      j = j + 1\n\
    \    end\n  end\n  -- We are at the end of the longest palindrome suffix.\n  --\
    \ Reverse its suffix.\n  for i=#palindrome, #palindrome+#reverse do\n    palindrome\
    \ = palindrome..reverse:sub(i, i)\n  end\n  return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpm9z4fs29.lua:34: 'end' expected (to close 'for' at line 18)\
    \ near 'else'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string == nil then\n\
    \        error('nil string')\n    end\n    local maxlen = 1\n    local result\
    \ = string\n    for i = 1, #string do\n        if string.sub(i, i) ~= string.sub(string.sub(i,\
    \ i, i + 1), i, i + 1) then\n            local l = string.len(string.sub(i, 1,\
    \ i))\n            local l2 = string.len(string.sub(i, i + 1, i + 1))\n      \
    \      if l > maxlen then\n                maxlen = l\n                result\
    \ = string.sub(string, 1, i)\n            elseif l2 == maxlen then\n         \
    \       result = result .. string.reverse(string.sub(i, 1, i))\n            else\n\
    \                maxlen = l2\n                result = string.sub(string, 1, i)\
    \ .. string.reverse(string.sub(i, 1, i + 1))\n            end\n        else\n\
    \            result = result .. string\n        end\n    end\n    if string.sub(result:sub(1,\
    \ #result)) ~= string.sub(result:sub(#result), #result) then\n        result =\
    \ result .. string.reverse(string.sub(result:sub(#result), #result))\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpe825arb1.lua:34:\
    \ bad argument #2 to 'sub' (number expected, got no value)\nstack traceback:\n\
    \t/tmp/tmpe825arb1.lua:34: in local 'candidate'\n\t/tmp/tmpe825arb1.lua:43: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- If there is nothing\
    \ to make, then return the empty string.\n   if string == '' then\n      return\
    \ string\n   end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp23q8vbaj.lua:27: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then\n\
    \    return ''\n  end\n  -- Make a copy of original string\n  local suffix = ''\
    \ .. string\n  -- Make two copies of the string\n  local suffixFirst  = '' ..\
    \ string\n  local suffixFirst2 = suffixFirst .. suffix\n  -- Search for longest\
    \ palindromic substring (with length equal to or greater than 1) and remove it\
    \ from original string\n  for i = 1, #string do\n    local substring = suffixFirst2\n\
    \    -- Check if string is longer than i or if length of current string is smaller\
    \ than i\n    -- If length is less than i, set suffixFirst and suffixFirst2 to\
    \ \"\"\n    -- If length is more than i, set suffixFirst and suffixFirst2 to substring\
    \ and make suffixFirst2 be suffixFirst concatenated with substring.\n    if i\
    \ < #string or #string < i then\n      suffixFirst = \"\"\n      suffixFirst2\
    \ = substring\n    else\n      suffixFirst = suffixFirst .. substring\n      suffixFirst2\
    \ = suffixFirst2 .. substring\n    end\n    -- Check if suffixFirst is a palindrome\n\
    \    local palindrome = suffixFirst .. suffixFirst2\n    -- If it is, remove suffixFirst\
    \ from original string\n    if suffixFirst ~= palindrome then\n      string =\
    \ suffixFirst .. string\n      suffixFirst = \"\"\n    end\n    -- Check if suffixFirst2\
    \ is a palindrome\n    local palindrome2 = suffixFirst2 .. suffixFirst\n    --\
    \ If it is, remove suffixFirst2 from original string\n    if suffixFirst2 ~= palindrome2\
    \ then\n      string = suffixFirst2 .. string\n      suffixFirst2 = \"\"\n   \
    \ end\n  end\n  return string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpalzhp6k4.lua:55:\
    \ expected: \"x\"\nactual: \"xxxx\"\nstack traceback:\n\t/tmp/tmpalzhp6k4.lua:55:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   if string == nil then return\
    \ '' end\n   local function reverse(s)\n      local tmp = ''\n      for i = #s,\
    \ 1, -1 do\n         tmp = tmp .. string.sub(s,i,i)\n      end\n      return tmp\n\
    \   end\n   local palindrome = ''\n   for i = 1, #string, 1 do\n      local prefix\
    \ = string\n      if i ~= 1 then prefix = prefix .. ' ' end\n      palindrome\
    \ = palindrome .. reverse(string:sub(i-1, i))\n   end\n   return prefix .. string\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplvnxd5y1.lua:26:\
    \ attempt to concatenate a nil value (global 'prefix')\nstack traceback:\n\t/tmp/tmplvnxd5y1.lua:26:\
    \ in local 'candidate'\n\t/tmp/tmplvnxd5y1.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   if string == nil then\n\
    \      string = 'nil'\n   end\n   local length = 1\n   local index = string\n\
    \   while string.sub(string,index) ~= '' do\n      local new_index = string.find(string.sub(string,index),\
    \ '')\n      string = string.sub(string,index) .. string.sub(string.sub(string,index),1,new_index)\
    \ .. string.sub(string,index+new_index) .. string.sub(string,index+1)\n      length\
    \ = length + new_index - index - 1\n      index = index + new_index\n   end\n\
    \   if length < 2 then\n      return string\n   end\n   local new_index\n   for\
    \ new_index = 1,length/2 do\n      local substring = string.sub(string,index,index+new_index)\n\
    \      string = string.sub(string,index+1,index+new_index+2) .. substring .. string.sub(string,index+new_index+2,string.len(string))\n\
    \      index = index+new_index+2\n   end\n   return string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpyfz4jl5k.lua:17:\
    \ bad argument #2 to 'sub' (number expected, got string)\nstack traceback:\n\t\
    /tmp/tmpyfz4jl5k.lua:17: in local 'candidate'\n\t/tmp/tmpyfz4jl5k.lua:38: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then return\
    \ '' end\n    if string.lower() == string.gsub(string.lower(string), '.', { '\\\
    n' })[#string.lower(string)] then return string end\n    local postfix = string.gsub(string.lower(string),\
    \ '.', { '\\n' }):reverse()\n    return string..postfix\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6o4ki56p.lua:13:\
    \ bad argument #1 to 'lower' (string expected, got no value)\nstack traceback:\n\
    \t/tmp/tmp6o4ki56p.lua:13: in local 'candidate'\n\t/tmp/tmp6o4ki56p.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then return\
    \ end\n    local longest, longestPrefix = 0, {}\n    for i = 1, #string do\n \
    \       longestPrefix = string[i - longest] .. longestPrefix\n        if string[i]\
    \ == string[#string] then\n            longest = i\n        else\n           \
    \ break\n        end\n    end\n    return string[#string] .. longestPrefix ..\
    \ string[longest]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppiaozfef.lua:22:\
    \ attempt to concatenate a table value (local 'longestPrefix')\nstack traceback:\n\
    \t/tmp/tmppiaozfef.lua:22: in local 'candidate'\n\t/tmp/tmppiaozfef.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local result = \"\"\n\
    \    local prefix = \"\"\n    local suffix_length\n    local suffix_start\n  \
    \  local suffix_end\n    local suffix_reverse\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpmlrm4l5e.lua:29: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then return\
    \ '' end\n    local prefix = string\n    local postfix = string\n    while #prefix\
    \ - 1 < #postfix do\n        postfix = prefix .. reverse(postfix)\n        prefix\
    \ = prefix .. postfix..string\n    end\n    return prefix .. postfix\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprdxqs1dq.lua:16:\
    \ attempt to call a nil value (global 'reverse')\nstack traceback:\n\t/tmp/tmprdxqs1dq.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmprdxqs1dq.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local function find_palindrome_reverse(string,\
    \ start, end)\n    if start > end then return string end return find_palindrome_reverse(string:sub(start,\
    \ end - start + 1), start + 1, end - 1) end\n    if start == end then return string\
    \ end\n    local prefix = string:sub(start, end)\n    local palindrome = find_palindrome_reverse(string:sub(start\
    \ + 1, end), start + 1, end - 1)\n    return string..prefix..palindrome\n  end\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpq7_0dga0.lua:12: <name> or '...' expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   if string == nil then string\
    \ = '' end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpinm2k3ig.lua:24: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  string = string.gsub(string,\
    \ \"([%a])\", function(c) return string.char(tonumber(c)) end)\n  local longest\
    \ = string.gsub(string, \"^([%a])\", string.upper)\n  return string.gsub(longest,\
    \ \"([%a])\", function(c) return string.char(tonumber(c)) end)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6hz58ttd.lua:12:\
    \ bad argument #1 to 'char' (number expected, got nil)\nstack traceback:\n\t/tmp/tmp6hz58ttd.lua:12:\
    \ in function </tmp/tmp6hz58ttd.lua:12>\n\t[C]: in function 'string.gsub'\n\t\
    /tmp/tmp6hz58ttd.lua:12: in local 'candidate'\n\t/tmp/tmp6hz58ttd.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tstring = string.gsub(string.gsub(string.gsub(string.gsub(string,\
    \ '-', ''), '^', ''), '.', ''), '\\%?([^.])', '$1')\n\treturn string\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpm92_x_i_.lua:12: invalid escape sequence near ''\\%'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  assert(type(string) == 'string',\
    \ 'string parameter must be a string')\n  assert(#string > 0, 'string parameter\
    \ must not be empty')\n  local suffix = '' -- Suffix to reverse the prefix.\n\
    \  for i = #string - 1, 1, -1 do\n    suffix = string[#string+i]:reverse() + suffix\n\
    \  end\n  suffix = suffix:reverse()\n  return string..suffix\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpc0uj2zi_.lua:13:\
    \ string parameter must not be empty\nstack traceback:\n\t/tmp/tmpc0uj2zi_.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpc0uj2zi_.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal palindrome = string\n\
    \twhile true do\n\t\tlocal index = 1\n\t\tfor i = 1, string.len(string) - 1 do\n\
    \t\t\tif string.sub(palindrome, 1, i) == string.sub(palindrome, i + 1, i) then\n\
    \t\t\t\tindex = i\n\t\t\tend\n\t\tend\n\t\tpalindrome = string.sub(palindrome,\
    \ 1, index) .. string.rep(\"a\", string.len(palindrome) - index) .. string.sub(palindrome,\
    \ index + 1)\n\t\tif palindrome ~= string then\n\t\t\treturn palindrome\n\t\t\
    end\n\tend\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local result = string\n\
    \  for i = 1, #string do\n    if string.sub(string,i,i) ~= string.sub(string,i,i)\
    \ or string[i] ~= string[i]\n    then break\n    end\n    local j = #string -\
    \ i - 1\n    if string[j] == string[j] and string.sub(string,i,i) ~= string.sub(string,i,i)\
    \ and string[j]~=string[j]\n    then result = string..string.sub(string,i,i)..string.sub(string,j,j)\n\
    \    break\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3uugfv4s.lua:31:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmp3uugfv4s.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local length = 0\n   \
    \ local index = string.len()\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpn5srmqia.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local prefix = string\n\
    \    local suffix = ''\n    local is_palindrome = 1\n    while 1 do\n        suffix\
    \ = string.sub(prefix, 1, string.len(prefix))\n        if suffix:reverse() ~=\
    \ suffix then\n            prefix = prefix..suffix\n        else\n           \
    \ is_palindrome = 0\n        end\n        if not is_palindrome then\n        \
    \    break\n        end\n    end\n    return prefix..suffix\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then return\
    \ '' end\n  local max_len = #string - 1\n  local length = 0\n  local index = 1\n\
    \  local is_palindrome = true\n  while index <= max_len and not is_palindrome\
    \ do\n    local char = string.sub(string,index,index+1)\n    local reversed_char\
    \ = string.sub(string.Reverse(string.sub(string,index,max_len)), 0, -1)\n    if\
    \ char == reversed_char then\n      index = index + 1\n      length = length +\
    \ 1\n    else\n      index = index + 1\n      is_palindrome = false\n    end\n\
    \  end\n  if is_palindrome then\n    local sub_string = string.sub(string,1,index-1)\n\
    \    return sub_string .. string.rep(string.sub(string,1,max_len), length)\n \
    \ else\n    return ''\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt7hkizga.lua:40:\
    \ expected: \"x\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpt7hkizga.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\t-- The longest palindrome\
    \ that begins with supplied string is longest postfix,\n\t-- and it must be made\
    \ of same length string.\n\tlocal longest_postfix, longest_postfix_length = longest_postfix(string,\
    \ false)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmplfb2cshl.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local suffix = \"-\"\n \
    \ local max_length, prefix, suffix, reverse, i, p\n  local is_palindrome = false\n\
    \  for i = 1, #string do\n    local p\n    local suffix = (suffix .. string[i])\n\
    \    max_length, prefix, reverse, i, p = max_prefix_suffix_reverse(suffix, max_length,\
    \ prefix, reverse, i, p)\n    if reverse == prefix then\n      is_palindrome =\
    \ true\n    end\n  end\n  if is_palindrome then\n    return prefix .. reverse\n\
    \  end\n  return string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpd70it6xi.lua:17:\
    \ attempt to concatenate a nil value (local 'suffix')\nstack traceback:\n\t/tmp/tmpd70it6xi.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmpd70it6xi.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local prefix_postfix = get_longest_postfix_string(string,\
    \ '', true, true)\n  local reversed_prefix_postfix = get_longest_postfix_string(reverse(string),\
    \ prefix_postfix, true, true)\n  return string.reverse(reversed_prefix_postfix)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis is wrong.\n<|/ c |>\n<| c |>\n- What is\
    \ wrong? The code was tested and works. I pointed out that not all solutions here\
    \ are optimal (for speed, memory-wise) and that this code will need to make two\
    \ passes on the string and that it will need to scan the string twice. However,\
    \ if the OP doesn't care about these things, then this could be an optimal solution\
    \ for the particular problem at hand (or at least good enough)\n<|/ c |>\n<| c\
    \ |>\nFor example 'cat' and 'atac'\n<|/ c |>\n<| c |>\n- My apologies, I misread\
    \ the question. I've updated the answer, but the original algorithm used would\
    \ still be valid (assuming I understood the problem correctly). For example 'cat'\
    \ and 'cat'\n<|/ c |>\n<| a dscore=2 |>\nIf your string length is limited, then\
    \ you can use binary search to find the longest palindrome string in your string.\
    \ \n<code>\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp2csiffq2.lua:16: unexpected symbol near '<'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == '' then\n \
    \   return string\n  elseif string == 'c' then\n    return 'c'\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdb9myicv.lua:28: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == '' then return\
    \ '' end\n  if string ~= string.gsub(string, '[^' .. string.char(97, 111, 109)\
    \ .. ']') then return '' end\n  local prefix_length = string.len(string) - string.len(string.gsub(string,\
    \ '.', ''))\n  local postfix_length = string.len(string.gsub(string, '.', ''))\n\
    \  local suffix = ''\n  while postfix_length >= prefix_length do\n    local sub\
    \ = string.sub(string, 1, prefix_length)\n    if string.sub(reverse(sub), 1, prefix_length)\
    \ ~= sub then\n      prefix = sub\n      suffix = string.sub(reverse(sub), prefix_length,\
    \ postfix_length)\n    end\n    prefix_length = prefix_length - 1\n    postfix_length\
    \ = postfix_length - 1\n  end\n  return string\n    ..string.sub(string, 1, prefix_length\
    \ + 1) .. suffix .. string\n    ..string.sub(string, prefix_length + 1, postfix_length\
    \ + 1)\nend\nreturn {\n  make_palindrome = make_palindrome,\n}\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6qbevdxy.lua:33: <eof> expected near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = ''\n\
    \  local max = 0\n  local length = 0\n  for i = 1, #string do\n    length = length\
    \ + 1\n    local postfix = string:sub(i, i)\n    local palindromic = string:sub(1,\
    \ i):reverse()\n    if postfix ~= palindromic then\n      max = max + length\n\
    \      palindrome = palindrome .. postfix\n    end\n  end\n  return string\n \
    \ .. string:sub(1, max - length)\n  .. palindrome:reverse()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp35diundz.lua:33:\
    \ expected: \"x\"\nactual: \"xx\"\nstack traceback:\n\t/tmp/tmp35diundz.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local start = 0\n    local\
    \ reverse = \"\"\n    while start < #string do\n        local palindrome = string.sub(string,start,start+math.ceil(math.log10(#string)))\n\
    \        reverse = reverse .. string.sub(string, #string, #string-1) .. palindrome\n\
    \        start = start + math.ceil(math.log10(#string))\n    end\n    return string\
    \ .. reverse .. string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffixes = find_suffixes(string)\n\
    \    local longest = max_length(suffixes)\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpyfd95w5s.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tif string == '' then return\
    \ '' end\n\tif string[0] == 'c' then\n\t\treturn string\n\tend\n\tlocal max_len\
    \ = #string - 2\n\tlocal max_end = 0\n\tlocal palindrome_end = 1\n\tlocal prefix\
    \ = string\n\trepeat\n\t\tlocal c = string[max_end - 1]\n\t\tlocal palindrome\
    \ = string\n\t\trepeat\n\t\t\tif palindrome[palindrome_end] == c then\n\t\t\t\t\
    palindrome_end = palindrome_end + 1\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\t\
    until palindrome_end == max_len\n\t\tif palindrome_end == max_len then\n\t\t\t\
    return prefix .. string\n\t\tend\n\t\tprefix = prefix .. string[palindrome_end\
    \ - 1]\n\t\tmax_len = max_len - 1\n\t\tmax_end = palindrome_end - 1\n\tuntil true\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    -- Find length of longest\
    \ palindromic suffix that starts with given string.\n    local _, longest = string.gsub(function()\
    \ return reverse(string.sub(string)) end, '%a^%z')\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp2ykt_xzo.lua:25: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal longest_postfix_len\
    \ = string.len\n\t\t\t\t\t(string.gsub(string, \"[^\" .. longest_postfix_len-1\
    \ .. string.rep(longest_postfix_len, string.len) .. \"^\" .. longest_postfix_len,\
    \ \"$1\"))\n\tlocal suffix_len = string.len(string) - longest_postfix_len\n\t\
    local prefix_len = longest_postfix_len - suffix_len\n\treturn string.gsub(string,\
    \ \"([\" .. longest_postfix_len-1 .. string.rep(longest_postfix_len, string.len)\
    \ .. \"])\",\n\t\t\t\t\tfunction(x)\n\t\t\t\t\t\treturn string.sub(x, prefix_len,\
    \ -suffix_len) .. string.sub(x, string.len-prefix_len)\n\t\t\t\t\tend)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpp9v6ldoy.lua:13:\
    \ attempt to perform arithmetic on a nil value (global 'longest_postfix_len')\n\
    stack traceback:\n\t/tmp/tmpp9v6ldoy.lua:13: in local 'candidate'\n\t/tmp/tmpp9v6ldoy.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local suffix_len = string.len()\n\
    \  if suffix_len ~= string.len(string:sub(1, suffix_len)) then\n    return string\n\
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpo6l_8mn4.lua:27: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then\n\
    \    return nil\n  end\n  local is_palindrome = false\n  local last_char = string.sub(string,\
    \ #string, 1)\n  if last_char == nil then\n    return string\n  end\n  local palindrome\
    \ = string\n  while last_char == string.sub(string, #string, 1) do\n    local\
    \ palindrome_start = #palindrome - 1\n    local palindrome_end = #palindrome +\
    \ 1\n    local palindrome_reverse = string.reverse(string.sub(palindrome, palindrome_start,\
    \ palindrome_end))\n    local palindrome_substring = string.sub(palindrome, #string,\
    \ #palindrome)\n    if palindrome_substring == palindrome_reverse then\n     \
    \ palindrome = palindrome_start .. palindrome_end .. string\n      is_palindrome\
    \ = true\n      break\n    end\n    last_char = string.sub(string, #string, 1)\n\
    \  end\n  return is_palindrome and palindrome or nil\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1duy9j5n.lua:39:\
    \ expected: \"\"\nactual: \"-11\"\nstack traceback:\n\t/tmp/tmp1duy9j5n.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local max_suffix = 0\n \
    \ local suffix_len = string.len\n  for i=1,string.len do\n    max_suffix = max_suffix\
    \ or string.sub(string,i,i) == string.sub(string,i,i)\n    if max_suffix then\n\
    \      break\n    end\n  end\n  if max_suffix then\n    local suffix_len = string.len(string)\
    \ - string.len(string) - max_suffix\n  end\n  local string_prep = string.sub(string,1,max_suffix\
    \ + 1)\n  local palindromic_string = string_pre .. string.rev(string.sub(string_pre,1,string.len(string)\
    \ - suffix_len - max_suffix))\n  return palindromic_string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2tquil56.lua:14:\
    \ 'for' limit must be a number\nstack traceback:\n\t/tmp/tmp2tquil56.lua:14: in\
    \ local 'candidate'\n\t/tmp/tmp2tquil56.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\t-- Return empty string if\
    \ the string is empty.\n\tif string == '' then\n\t\treturn string\n\tend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpoy90ob_t.lua:27: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix, palindrome,\
    \ longest, longestString\n    longest = string.find(string, \"([^\"..string.gsub(string,\
    \ \"[%z\\1-\\040\\177-\\377]\", \"%x%1\").\"]*)\")\n    longestString = string.sub(string,\
    \ 0, longest)\n    longestString = (string.gsub(longestString, \"[^\" .. string.gsub(longestString,\
    \ \"%z\", \"%0\") .. \"]\", \"\"))\n    longestString = (string.gsub(longestString,\
    \ \"[\" .. string.gsub(longestString, \"%z\", \"%0\") .. \"]\", \"\"))\n    longestString\
    \ = string.gsub(longestString, \":\", \"%x\")\n    longestString = string.gsub(longestString,\
    \ \"\\1\", \"%0\")\n    longestString = string.gsub(longestString, \"\\0\", \"\
    %0\")\n    palindrome = longestString .. (longestString and reverseString(longestString)\
    \ or \"\")\n    postfix = string.gsub(string, \"^..\", longestString and reverseString(longestString)\
    \ or \"\")\n    return string.gsub(postfix .. palindrome, \":\", \"%x\") .. palindrome\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp0rtj5ntu.lua:13: decimal escape too large near '\"[%z\x01\
    -(-\\377]'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   if string.match('^%s+$',\
    \ '') then\n      return string\n   end\n   local start_offset = string.len(string)\
    \ - string.len(string.gsub(string, '%.'))\n   if string.sub(string, 0, string.len(string)/2)\
    \ ~= string.sub(string, 1, string.len(string)/2) then\n      return string\n \
    \  end\n   local end_offset = start_offset + string.len(string.gsub(string, '%.'))\n\
    \   if start_offset < end_offset then\n      return string\n   end\n   local reversed_string\
    \ = string.sub(string.sub(string, 1, end_offset), 2, string.len(string))\n   return\
    \ string .. reversed_string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpql7k6l27.lua:32:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmpql7k6l27.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local reversed = ''\n    repeat\n        reversed = reversed .. postfix\n\
    \        postfix = string.sub(postfix, 2, string.len(postfix))\n    until not\
    \ string.find(postfix, reversed, 1, true)\n    return reversed .. string.sub(postfix,\
    \ 1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find the longest postfix\
    \ that is a palindrome.\n  local function find_longest_postfix(str, i, j)\n  \
    \  j = j or #str\n    while j > i do\n      local t = str:sub(i, j)\n      if\
    \ t:sub(1, 1) == 'c' then\n        j = j - 1\n      else\n        j = j - 1\n\
    \        i = i + 1\n      end\n    end\n    return i, i - 1\n  end\n  -- Find\
    \ the reverse of the supplied string prefix that comes before palindromic suffix.\n\
    \  local function reverse(str, i, j)\n    j = j or #str\n    while j > i do\n\
    \      local t = str:sub(i, j)\n      i = i - 1\n      j = j - 1\n      str =\
    \ str .. t:sub(1, 1) .. t:sub(2, 2)\n    end\n    return str\n  end\n  local function\
    \ palindrome(str, i, j)\n    local prefix\n    j = j or #str\n    -- A palindrome\
    \ ends with a palindromic suffix.\n    if j > i then\n      prefix = str:sub(i,\
    \ j)\n      j = j - 1\n      i = i + 1\n    else\n      prefix = ''\n    end\n\
    \    -- Find all palindromic suffixes beginning with palindromic prefix.\n   \
    \ local suffix_start, suffix_end\n    local function find_suffixes(str, i, j)\n\
    \      j = j or #str\n      -- Skip any suffix.\n      while j > i do\n      \
    \  local t = str:sub(i, j)\n        i = i - 1\n        j = j - 1\n        if t:sub(1,\
    \ 1) == 'c' then\n          j = j - 1\n        else\n          j = j - 1\n   \
    \       i = i + 1\n        end\n      end\n      -- Check suffixes beginning with\
    \ prefix.\n      local suffix_start = i + 1\n      j = suffix_start\n      while\
    \ j < j do\n        local t = str:sub(i, j)\n        i = i + 1\n        j = j\
    \ + 1\n        if t ~= t then\n          suffix_end = i\n        end\n      end\n\
    \      return suffix_start, suffix_end\n    end\n    suffix_start, suffix_end\
    \ = find_suffixes(str, i, j)\n    -- Reverse the suffix that comes before palindromic\
    \ suffix.\n    local suffix_reversed = reverse(str:sub(suffix_start, suffix_end),\
    \ suffix_start, suffix_end)\n    -- Add reversed suffix to beginning of palindrome\
    \ prefix.\n    local palindrome_start = i\n    j = suffix_start - 1\n    while\
    \ j >= i do\n      local t = str:sub(i, j)\n      i = i - \nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpz3nvksc_.lua:86: unexpected symbol near '='\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if string == nil then\n\
    \        error('make_palindrome() called with nil')\n    end\n    -- The longest\
    \ postfix of the string that is a palindrome.\n    local longest_postfix = ''\n\
    \    -- The string prefix that comes before the longest postfix that is a palindrome.\n\
    \    local longest_prefix = ''\n    local longest_prefix_size = 0\n    -- The\
    \ reverse of the longest postfix string that is a palindrome.\n    local longest_reverse\
    \ = ''\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3n35zw5y.lua:33: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string then return\
    \ '' end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfd0ecw9z.lua:24: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Return empty string if\
    \ provided string is empty.\n  if not string then\n    return ''\n  end\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpm1pjdq5f.lua:27: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  if string == nil then return\
    \ string end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3bd1ba9d.lua:24: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal length = string.len(string)\n\
    \tlocal suffix = ''\n\tlocal prefix = string\n\twhile length >= 2 do\n\t\tlocal\
    \ idx = string.find(prefix, '$', 1, length-1)\n\t\tif idx == nil then break end\n\
    \t\tsuffix = string[idx:length]\n\t\tprefix = prefix[idx+1:]\n\t\tlength = length\
    \ - 1\n\tend\n\t-- Sadly, there is no string.rfind for Lua\n\tlocal idx = string.find(prefix,\
    \ '$', 1, length)\n\tif idx == nil then return '' end\n\tprefix = prefix[idx+1:length]\n\
    \tlength = length - 1\n\twhile length ~= 0 do\n\t\tidx = string.find(prefix, '$',\
    \ 1, length)\n\t\tif idx == nil then break end\n\t\tsuffix = string[idx:length]\n\
    \t\tprefix = prefix[idx+1:]\n\t\tlength = length - 1\n\tend\n\tprefix = prefix\
    \ .. suffix\n\treturn prefix\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvcszn31x.lua:18: function arguments expected near ']'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local strings = string.gmatch(string,\
    \ '[^%s]+') -- get all substrings\n  local longest, shortest\n  for i = #strings,\
    \ 1, -1 do\n    local substring = string.sub(string, 1, i)\n    longest, shortest\
    \ = longest or substring, substring or longest\n    if not shortest or string.sub(shortest,\
    \ #shortest - 1, #longest) == string.rev(shortest) then\n      break\n    end\n\
    \  end\n  return strings[#strings]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzkxhuamk.lua:14:\
    \ attempt to get length of a function value (local 'strings')\nstack traceback:\n\
    \t/tmp/tmpzkxhuamk.lua:14: in local 'candidate'\n\t/tmp/tmpzkxhuamk.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local longest_postfix\
    \ = string\n    local reversed_postfix = string\n    local start = 1\n    local\
    \ start2 = 1\n    for i = 1, string.len(string) do\n        local postfix = string.sub(string,\
    \ start, start + 1)\n        local reversed_postfix = string.reverse(reversed_postfix)\n\
    \        -- Check if there is palindrome\n        if postfix ~= reversed_postfix\
    \ then\n            longest_postfix = postfix\n            start = string.len(string)\n\
    \            reversed_postfix = string\n        end\n        reversed_postfix\
    \ = string.reverse(reversed_postfix)\n        if reversed_postfix ~= postfix then\n\
    \            start = i + 1\n            longest_postfix = postfix\n          \
    \  reversed_postfix = string\n        end\n    end\n    -- Append the reverse\
    \ of string that comes before longest postfix\n    return string.reverse(string.sub(string,\
    \ start + 1, string.len(string)))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpod6rd1tg.lua:40:\
    \ expected: \"x\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpod6rd1tg.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffix = ''\n  \
    \  local max_len = string.len(string) + 1\n    while max_len > 1 do\n        local\
    \ postfix = string\n        for i = 1, max_len do\n            postfix = string.sub(postfix,\
    \ 1, i) + suffix\n            if suffix == string.sub(postfix, 1, i) and string.sub(postfix,\
    \ i) == suffix then\n                return string.sub(postfix, 1, i) + suffix\
    \ -- Palindrome found.\n            end\n        end\n        max_len = max_len\
    \ - 1\n    end\n    return string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxpiy1fag.lua:17:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmpxpiy1fag.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmpxpiy1fag.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n\tlocal postfix = string\n\
    \twhile postfix ~= string.gsub(postfix, '(.)..$', '\\1') do postfix = string.sub(postfix,\
    \ 1, -1); end\n\treturn string.sub(postfix, 0, -1) + string.reverse(string.sub(postfix,\
    \ 1, string.len(postfix)))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4dql8rty.lua:14:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmp4dql8rty.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmp4dql8rty.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Use local variable for\
    \ faster access of the string value.\n  local suffix = string\n  local prefix\
    \ = string\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmph4xuakf2.lua:26: 'end' expected (to close 'function' at line\
    \ 11) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    if not string or #string\
    \ == 0 then\n        return string\n    end\n    local index = #string\n    local\
    \ suffix_length = index - 1\n    local palindrome = ''\n    while suffix_length\
    \ > 0 do\n        local suffix_start = suffix_length - 1\n        local suffix_end\
    \ = #string\n        while suffix_end > suffix_start do\n            local char\
    \ = string.sub(string, suffix_start, suffix_end)\n            if char:reverse():sub(1,\
    \ #char) == char then\n                palindrome = palindrome .. char\n     \
    \           suffix_start = suffix_start - 1\n                suffix_end = suffix_end\
    \ - 1\n            else\n                suffix_start = suffix_start - 1\n   \
    \             suffix_end = suffix_end - 1\n            end\n        end\n    \
    \    index = index - 1\n        suffix_length = suffix_length - 1\n    end\n \
    \   return palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppiyuqtti.lua:42:\
    \ expected: \"x\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmppiyuqtti.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local postfix = string\n  local reverse = string\n  while string.find(postfix,\
    \ reverse) do\n    postfix = string.sub(postfix, 1, string.len(postfix) - 1) ..\
    \ reverse\n  end\n  return string.reverse(postfix)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local suffix\n    local\
    \ length = #string\n    for index = 1, (length / 2) do\n        suffix = string[(index+1):(length)]\n\
    \        string = string..(string.len(suffix):reverse())\n    end\n    return\
    \ string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdugreh_d.lua:15: <name> expected near '('\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local start = #string\n\
    \  while start > 0 do\n    local end = #string - start\n    if string[end] ==\
    \ string[end - 1] then\n      end = end - 1\n    end\n    start = start - 1\n\
    \    if start == 0 then\n      string = string..string[end..end]\n    end\n  end\n\
    \  return string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpk0i2v94t.lua:14: <name> expected near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n   -- Find the longest postfix\
    \ of supplied string that is a palindrome.\n   local longest = palindromes(string)\n\
    \   if #longest == 0 then\n      return string\n   end\n   local reversed_prefix\
    \ = string.sub(string, 1, longest.len - 1)\n   -- Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n   return\
    \ string..reversed_prefix..string.reverse(longest.suffix)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpj93ktpk9.lua:13:\
    \ attempt to call a nil value (global 'palindromes')\nstack traceback:\n\t/tmp/tmpj93ktpk9.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpj93ktpk9.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
