name: HumanEval_26_remove_duplicates
language: lua
prompt: "-- From a list of integers, remove all elements that occur more than once.\n\
  -- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n-- [1, 3, 4]\nlocal function remove_duplicates(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = remove_duplicates\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3,\
  \ 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({1, 2, 3, 2, 4, 3, 5}), {1,\
  \ 4, 5})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return setmetatable(numbers, {__index = function() return numbers;\
    \ end})\nend", "   if #numbers == 0 then\n      return nil\n   end\n   local result\
    \ = {}\n   for i = 1, #numbers do\n      local found = false\n      for j = 1,\
    \ #result do\n         if result[j] == numbers[i] then\n            found = true\n\
    \            break\n         end\n      end\n      if found then\n         table.insert(result,\
    \ numbers[i])\n      else\n         result[#result+1] = numbers[i]\n      end\n\
    \   end\n   return result\nend", "  local seen = {}\n  local output = {}\n  for\
    \ _, value in pairs(numbers) do\n    if seen[value] then\n      output[#output\
    \ + 1] = value\n    else\n      seen[value] = true\n    end\n  end\n  return output\n\
    end", "  local hash = {}\n  for i = 1, #numbers do\n    if hash[numbers[i]] then\n\
    \      table.remove(numbers, i)\n    else\n      hash[numbers[i]] = true\n   \
    \ end\n  end\n  return numbers\nend", "  for i = 1, #numbers do\n    for j = 1,\
    \ #numbers do\n      if numbers[i] == numbers[j] then\n        table.insert(numbers,\
    \ numbers[i])\n      end\n    end\n  end\n  return numbers\nend", "    local num_map\
    \ = {}\n    local num_count = 1\n    for _, value in ipairs(numbers) do\n    \
    \    if num_map[value] == nil then\n            num_map[value] = num_count\n \
    \           num_count = num_count + 1\n        else\n            num_count = num_map[value]\n\
    \        end\n    end\n    for _, value in pairs(num_map) do\n        table.insert(numbers,\
    \ value)\n    end\n    return numbers\nend", "    local seen = {}\n    for _,\
    \ number in ipairs(numbers) do\n        if seen[number] == nil then\n        \
    \    seen[number] = true\n            return number\n        end\n    end\nend",
  "    -- Handle empty list\n    if #numbers <= 1 then\n        return numbers", "\t\
    local new = {}\n\tlocal last_el", "  local result = {}\n  for _, v in ipairs(numbers)\
    \ do\n    if result[v] ~= nil then\n      result[v] = true\n    else\n      result[v]\
    \ = true\n      table.insert(result, v)\n    end\n  end\n  return result\nend",
  "  local sorted_numbers = table.sort(numbers)\n  local unique_numbers = {}\n  for\
    \ _, value in ipairs(sorted_numbers) do\n    table.insert(unique_numbers, value)\n\
    \  end\n  return table.sort(unique_numbers)\nend", "  local result = {}\n  for\
    \ _, value in ipairs(numbers) do\n    if result[value] then\n      result[value]\
    \ = true\n    else\n      result[value] = true\n      result[value] = true\n \
    \     result[value] = true\n      result[value] = true\n      result[value] =\
    \ true\n      result[value] = true\n    end\n  end\n  return result\nend", "\t\
    local unique_numbers = {}\n\tlocal index\n\tfor index, number in ipairs(numbers)\
    \ do\n\t\tif unique_numbers[number] == nil then\n\t\t\tunique_numbers[number]\
    \ = true\n\t\tend\n\tend\n\treturn unique_numbers, index\nend", "  local last_seen\
    \ = {}\n  local last_seen_so_far = {}\n  for _, item in pairs(numbers) do\n  \
    \  if last_seen[item] then\n      last_seen_so_far[#last_seen_so_far + 1] = item\n\
    \    else\n      last_seen[item] = true\n      last_seen_so_far[#last_seen_so_far\
    \ + 1] = item\n    end\n  end\n  return last_seen_so_far\nend", "\tlocal new_numbers\
    \ = {}\n\tfor i, n in ipairs(numbers) do\n\t\tif new_numbers[n] == nil then\n\t\
    \t\tnew_numbers[#new_numbers + 1] = n\n\t\telse\n\t\t\tnew_numbers[#new_numbers]\n\
    \t\tend\n\tend\n\treturn new_numbers\nend", "  local function count(x)\n    return\
    \ x == nil or x == 0 or #numbers + 1 -- count of x\n  end", "    local seen =\
    \ {}\n    for _, elem in ipairs(numbers) do\n        if seen[elem] == nil then\n\
    \            seen[elem] = 1\n        else\n            seen[elem] = seen[elem]\
    \ + 1\n        end\n    end\n    return pairs(seen)\nend", "  return torch.sort(numbers)\n\
    end", "    local unique = {}\n    for k, v in pairs(numbers) do\n        unique[k]\
    \ = true\n    end\n    return numbers[#numbers]\nend", "  if #numbers == 0 then\n\
    \    return {}\n  end\n  local output = {}\n  for i = 1, #numbers do\n    local\
    \ key = numbers[i]\n    if output[key] then\n      output[key] = output[key] or\
    \ {}\n      table.insert(output[key], i)\n    end\n  end\n  local count = #output\n\
    \  output[count] = nil\n  -- Reverse output to get rid of unused elements\n  for\
    \ i = #output, 1, -1 do\n    output[i - 1] = output[i]\n  end\n  return output\n\
    end", "  if #numbers <= 1 then\n    return numbers\n  else\n    local result =\
    \ {}\n    for i = 1, #numbers, 1 do\n      if result[numbers[i]] ~= nil then\n\
    \        -- Element is in result already so remove it from result and continue.\n\
    \        table.insert(result, numbers[i])\n      else\n        -- Element is not\
    \ in result so add it.\n        table.insert(result, numbers[i])\n      end\n\
    \    end\n    -- Add the remaining elements to the result list which are not in\
    \ the result list.\n    for i = #numbers, 1, -1 do\n      table.insert(result,\
    \ numbers[i])\n    end\n    return result\n  end\nend", "  return sort(\n    table.concat(\n\
    \      select(\n        numbers,\n        function(x) return table.remove_by_ref(x,\
    \ 1) end,\n      ),\n      0,\n    ),\n    1,\n  )\nend", "  local result = {}\n\
    \  for _, value in ipairs(numbers) do\n    if not result[value] then\n      result[value]\
    \ = true\n    end\n  end\n  return result\nend", "  if numbers == nil then\n \
    \   return nil\n  end\n  local hash = {}\n  local output = {}\n  for _, number\
    \ in pairs(numbers) do\n    if numbers[number] ~= number then\n      table.insert(output,\
    \ number)\n    end\n    hash[number] = number\n  end\n  for _, number in pairs(output)\
    \ do\n    hash[number] = number\n  end\n  return output\nend", "  local result\
    \ = {}\n  local last_number = nil\n  for _, number in ipairs(numbers) do\n   \
    \ if last_number == number then\n      table.insert(result, number)\n    else\n\
    \      last_number = number\n    end\n  end\n  return result\nend", "  local new_numbers\
    \ = {}\n  for i = 1, #numbers do\n    local number = numbers[i]\n    if not new_numbers[number]\
    \ then\n      table.insert(new_numbers, number)\n    end\n  end\n  return new_numbers\n\
    end", "  local new_numbers = {}\n  for _, number in pairs(numbers) do\n    if\
    \ not new_numbers[number] then\n      new_numbers[number] = true\n    else\n \
    \     new_numbers[number] = nil\n    end\n  end\n  return new_numbers\nend", " \
    \   local result = {}\n    for _, value in pairs(numbers) do\n        if #result[value]\
    \ > 0 then\n            table.insert(result, value)\n        end\n    end\n  \
    \  return result\nend", "  assert(type(numbers) ~= 'table' or #numbers == 0, 'Input\
    \ must be a list of integers')\n  local results = {}\n  for i = 1, #numbers do\n\
    \    if numbers[i] ~= nil then\n      table.insert(results, numbers[i])\n    end\n\
    \  end\n  return results\nend", "    local unique_elements = {}\n    for _, number\
    \ in ipairs(numbers) do\n        if unique_elements[number] ~= nil then\n    \
    \        unique_elements[number] = nil\n        else\n            unique_elements[number]\
    \ = true\n        end\n    end\n    return table.sort(unique_elements)\nend",
  "  local result\n  local numbers_size = #numbers\n  if numbers_size == 0 then\n\
    \    result ={}\n  else\n    result = {}\n    table.sort(numbers)\n    for i =\
    \ 1, #numbers do\n      local current_value = numbers[i]\n      if result[current_value]\
    \ ~= nil then\n        table.insert(result, current_value)\n      else\n     \
    \   table.insert(result, current_value)\n      end\n    end\n  end\n  return result\n\
    end", "    if #numbers == 0 then\n        return nil\n    end", "\tlocal new_numbers\
    \ = {}\n\tlocal seen = {}", "  local new_numbers = {}\n  local new_order = {}\n\
    \  for _, number in ipairs(numbers) do\n    table.insert(new_numbers, number)\n\
    \    table.insert(new_order, number)\n  end\n  -- First find out how many times\
    \ each element appears in the list.\n  for _, number in ipairs(new_order) do\n\
    \    local num_occurrences = 1\n    for _, number_2 in ipairs(new_order) do\n\
    \      if number == number_2 then\n        num_occurrences = num_occurrences +\
    \ 1\n      end\n    end\n    -- We want to keep the original order of the elements.\n\
    \    if num_occurrences > 1 then\n      table.insert(new_order, number)\n    end\n\
    \  end\n  return new_order, new_numbers\nend", "\tlocal seen = {}\n\tfor _, number\
    \ in ipairs(numbers) do\n\t\tif seen[number] then\n\t\t\ttable.insert(numbers,\
    \ seen[number])\n\t\telse\n\t\t\ttable.insert(numbers, number)\n\t\t\tseen[number]\
    \ = true\n\t\tend\n\tend\n\treturn numbers\nend", "  local new_list = terralib.newlist()\n\
    \  for _, elem in ipairs(numbers) do\n    if new_list == nil then\n      new_list\
    \ = terralib.newlist({elem})\n    else\n      new_list:insert(elem)\n    end\n\
    \  end\n  return new_list\nend", "  for _, v in ipairs(numbers) do\n    if numbers[v]\
    \ == v then -- skip if already in the list\n      table.remove(numbers, v)\n \
    \   end\n  end\n  return numbers\nend", "  local output = {}\n  for _, value in\
    \ pairs(numbers) do\n    if output[value] == nil then\n      output[value] = 1\n\
    \    else\n      output[value] = output[value] + 1\n    end\n  end\n  return output\n\
    end", "  local new_numbers = {}\n  for _, number in ipairs(numbers) do\n    if\
    \ new_numbers[number] then\n      table.insert(new_numbers, number)\n    else\n\
    \      table.insert(new_numbers, number)\n    end\n  end\n  return new_numbers\n\
    end", "  for i = 1, #numbers do\n    local found = false\n    for j = 1, #numbers\
    \ do\n      if numbers[i] == numbers[j] then\n        found = true\n        break\n\
    \      end\n    end\n    if not found then\n      table.insert(numbers, numbers[i])\n\
    \    end\n  end\n  return numbers\nend", '  if #numbers == 0 then return numbers
    end', "  assert(type(numbers) == \"table\", \"numbers should be a table\")\n \
    \ -- For small tables, use an iterator instead.\n  if #numbers < 100 then\n  \
    \  return { numbers[i] for i in range(#numbers) }\n  end\n  return setmetatable({\
    \ numbers = numbers }, { __index = sets })\nend", "  local num_seen = setmetatable(0,\
    \ { __mode = \"v\" })\n  for _, num in pairs(numbers) do\n    num_seen[num] =\
    \ true\n  end", "    local new_numbers = {}\n    for i, n in pairs(numbers) do\n\
    \        if new_numbers[n] == nil then\n            new_numbers[n] = true\n  \
    \      else\n            table.remove(new_numbers, n)\n        end\n    end\n\
    \    return new_numbers\nend", "  local seen = {}\n  local i = 1\n  for _, number\
    \ in pairs(numbers) do\n    if seen[number] then\n      i = i + 1\n    else\n\
    \      seen[number] = true\n    end\n  end\n  return numbers[i]:concat()\nend",
  "  return setmetatable(numbers, { __index = function(t, i)\n      local seen = {}\n\
    \      for j = 1, #t do\n        seen[t[j]] = true\n      end\n      local new_t\
    \ = {}\n      for j = 1, #t do\n        if seen[t[j]] then\n          table.insert(new_t,\
    \ t[j])\n        end\n      end\n      return new_t\n    end })\nend", "    local\
    \ seen = {}\n    local new_numbers = {}\n    for i,v in ipairs(numbers) do\n \
    \       if seen[v] then\n            new_numbers[#new_numbers+1] = v\n       \
    \ else\n            seen[v] = true\n        end\n    end\n    return new_numbers\n\
    end", "    local new_numbers = {}\n    local current_number = 1", "  if #numbers\
    \ <= 0 then return numbers end\n  local counts = {}\n  for i = 1, #numbers do\n\
    \    counts[numbers[i]] = (counts[numbers[i]] or 0) + 1\n    if counts[numbers[i]]\
    \ > 1 then\n      table.remove(numbers, i)\n      i = i - 1\n    end\n  end\n\
    \  return numbers\nend", "    local new_numbers = {}\n    for _, number in pairs(numbers)\
    \ do\n        if new_numbers[number] == nil then\n            new_numbers[number]\
    \ = true\n        else\n            return nil\n        end\n    end\n    return\
    \ new_numbers\nend", "    local result = {}\n    local index = 1\n    for i =\
    \ 1, #numbers do\n        if numbers[i] ~= numbers[index] then\n            result[#result\
    \ + 1] = numbers[i]\n            index = i\n        end\n    end\n    return result:map(function(x)\
    \ return x end):reverse()\nend", "    local seen = {}\n    return table.unpack(numbers,\
    \ 1, #numbers) -- the second argument is \"how many elements to return\"\nend",
  "  local result = {}\n  local seen = {}\n  for _, num in ipairs(numbers) do\n  \
    \  if seen[num] == nil then\n      result[#result + 1] = num\n      seen[num]\
    \ = true\n    end\n  end\n  return result\nend", "  local hash = {}\n  for i =\
    \ 1, #numbers do\n    hash[numbers[i]] = true\n  end\n  local result = {}\n  for\
    \ i = 1, #numbers do\n    if hash[numbers[i]] then\n      result[#result + 1]\
    \ = numbers[i]\n      hash[numbers[i]] = nil\n    end\n  end\n  return result\n\
    end", "  local num_map = {}\n  for i = 1, #numbers do\n    table.insert(num_map,\
    \ numbers[i])\n  end\n  local result = {}\n  for i = 1, #numbers do\n    if num_map[numbers[i]]\
    \ == nil then\n      result[#result + 1] = numbers[i]\n    end\n  end\n  return\
    \ result\nend", "  -- Create a dictionary by indexing the input list.  O(1).\n\
    \  local counts = {}\n  for _, value in ipairs(numbers) do\n    counts[value]\
    \ = counts[value] or 1\n  end", "  local function count(x)\n    return setmetatable(x,\
    \ {__index = _G})\n  end\n  local function remove(x)\n    local i, count = count(x)\n\
    \    if not count then\n      x[i] = nil\n      true\n    end\n  end\n  return\
    \ set:from_list(numbers):map(remove)\nend", "  return table.sort(table.uniq(numbers))\
    \ or numbers\nend", "    if numbers == nil then return nil end\n    -- Return\
    \ true if we haven't reached the end of the input yet.\n    if #numbers == 0 then\
    \ return true end\n    -- Keep a list of numbers that we already saw.\n    local\
    \ seen = {}\n    -- Iterate through the numbers.\n    for i = 1, #numbers do\n\
    \        -- Check to see if the current number we've seen is in our seen list.\n\
    \        if seen[numbers[i]] ~= nil then\n            -- We have seen this number\
    \ before, so just remove it.\n            numbers[i] = nil\n        else\n   \
    \         -- We have not seen this number before, so keep it.\n            seen[numbers[i]]\
    \ = true\n        end\n    end\n    -- Return the updated list.\n    return numbers\n\
    end", "  assert(type(numbers) ~= 'table')\n  local new_numbers = {}\n  local seen\
    \ = {}", "  local seen = {}\n  local result = {\n    [1] = numbers[1],\n  }\n\
    \  for i = 2, #numbers do\n    if seen[numbers[i]] ~= nil then\n      seen[numbers[i]]\
    \ = nil\n    else\n      table.insert(result, numbers[i])\n      seen[numbers[i]]\
    \ = numbers[i]\n    end\n  end\n  return result\nend", "  local unique_numbers\
    \ = {}\n  for _, value in pairs(numbers) do\n    if not find_index(unique_numbers,\
    \ value) then\n      table.insert(unique_numbers, value)\n    end\n  end\n  return\
    \ unique_numbers\nend", "  if numbers == nil then return end\n  local new_list\
    \ = terralib.newlist()\n  for i, elem in ipairs(numbers) do\n    if new_list[i]\
    \ ~= elem then\n      table.insert(new_list, elem)\n    end\n  end\n  return new_list\n\
    end", "    local seen = {}\n    local output = {}\n    for i=1, #numbers do\n\
    \        if seen[numbers[i]] then\n            table.insert(output, numbers[i])\n\
    \        else\n            table.insert(seen, numbers[i])\n        end\n    end\n\
    \    return output\nend", '    local result = {}', "  if #numbers == 0 then return\
    \ nil end\n  local counts = {}\n  local new_numbers = {}\n  local last_index =\
    \ {}\n  for i = 1, #numbers do\n    local element = numbers[i]\n    if not counts[element]\
    \ then\n      counts[element] = 1\n      new_numbers[element] = element\n    \
    \  last_index[element] = i\n    else\n      counts[element] = counts[element]\
    \ + 1\n    end\n  end\n  local i = #new_numbers\n  while i > 0 do\n    if not\
    \ counts[new_numbers[i]] then\n      table.remove(new_numbers, i)\n      last_index[new_numbers[i]]\
    \ = i - 1\n    else\n      counts[new_numbers[i]] = counts[new_numbers[i]] + 1\n\
    \    end\n    i = i - 1\n  end\n  return new_numbers\nend", "  assert(type(numbers)\
    \ == 'table')", "  local i = 0\n  local j = 1\n  while i < #numbers and j < #numbers\
    \ do\n    if numbers[i] ~= numbers[j] then\n      numbers[#numbers + 1] = numbers[i]\n\
    \      i = i + 1\n    end\n    j = j + 1\n  end\n  return numbers:sub(1, i - 1)\n\
    end", "    -- Set up list to hold result\n    local new_numbers = {}\n    -- Iterate\
    \ through list and add element if it doesn't occur more than once\n    for _,\
    \ number in ipairs(numbers) do\n        if not (new_numbers[number] or 0) > 1\
    \ then\n            new_numbers[number] = true\n        end\n    end\n    -- Return\
    \ new list\n    return new_numbers\nend", "  local new_numbers = {}\n  local i\
    \ = 1\n  while i < #numbers and i <= #numbers do\n    local found = false\n  \
    \  for j = i; j < #numbers do\n      if numbers[i] == numbers[j] then\n      \
    \  found = true\n        break\n      end\n    end\n    if not found then\n  \
    \    new_numbers[#new_numbers + 1] = numbers[i]\n    end\n    i = i + 1\n  end\n\
    \  return new_numbers\nend", "    local new_list = {}\n    for _, i in pairs(numbers)\
    \ do\n        table.insert(new_list, i)\n    end\n    return new_list\nend", " \
    \ local new_numbers = {}\n  for _, number in ipairs(numbers) do\n    if new_numbers[number]\
    \ == nil then\n      new_numbers[number] = true\n    else\n      new_numbers[number]\
    \ = false\n    end\n  end\n  return new_numbers\nend", "  if #numbers == 1 then\n\
    \    return numbers\n  else\n    local sorted_numbers = numbers.sorted()\n   \
    \ local unique_numbers = {}\n    local count = 0\n    for index = 1, #sorted_numbers\
    \ do\n      local current_number = sorted_numbers[index]\n      if not unique_numbers[current_number]\
    \ then\n        unique_numbers[current_number] = count\n        count = count\
    \ + 1\n      end\n    end\n    return table.sortedinsert(unique_numbers, #unique_numbers)\n\
    \  end\nend", "    local result = {}\n    local counts = {}\n    for _, value\
    \ in pairs(numbers) do\n        if counts[value] ~= nil then\n            counts[value]\
    \ = counts[value] + 1\n        else\n            counts[value] = 1\n        end\n\
    \    end\n    for value, count in pairs(counts) do\n        if value ~= nil then\n\
    \            if count > 1 then\n                table.insert(result, value)\n\
    \            end\n        end\n    end\n    return result\nend", "  -- Store in\
    \ memory and use a dictionary to remove dupes\n  local seen = {}\n  for _, item\
    \ in ipairs(numbers) do\n    seen[item] = nil\n  end", "  return list:foldl(\n\
    \    function(a, b) assert(type(b) == 'number') then\n        if (a[b] == nil)\
    \ then\n          a[b] = true\n        else\n          a[b] = false\n        end\n\
    \        return a\n    end,\n    {},\n    numbers\n  )\nend", "  local new_numbers\
    \ = {}\n  for _, number in ipairs(numbers) do\n    table.insert(new_numbers, number)\n\
    \  end\n  return new_numbers\nend", "    local result = {}\n    for _, num in\
    \ pairs(numbers) do\n        local count = result[num] or 0\n        result[num]\
    \ = count + 1\n    end\n    for _, num in pairs(result) do\n        if num ==\
    \ 1 then\n            table.remove(numbers, num)\n        end\n    end\n    return\
    \ table.remove(numbers)\nend", "  assert(#numbers ~= 0, 'remove_duplicates: numbers\
    \ list cannot be empty')\n  local removed = {}\n  local index = 1\n  while true\
    \ do\n    local value = numbers[index]\n    index = index + 1\n    if value in\
    \ removed then -- Already processed this number\n      index = index - 1\n   \
    \   -- If the number isn't in the remaining elements, try the next one\n     \
    \ if index <= #numbers then\n        local next_value = numbers[index]\n     \
    \   index = index + 1\n        removed[value] = true\n        removed[next_value]\
    \ = true\n      end\n    else -- First time seeing this number\n      removed[value]\
    \ = true\n    end\n    if #removed == #numbers or #removed == 0 then\n      break\n\
    \    end\n  end\n  -- Sort removed numbers in order of appearance in the input\
    \ list\n  table.sort(removed)\n  -- Remove elements that occur more than once\n\
    \  local new_numbers = {}\n  for i = 1, #numbers do\n    if removed[numbers[i]]\
    \ then\n      table.insert(new_numbers, numbers[i])\n    end\n  end\n  return\
    \ new_numbers\nend", '  local results = {}', "  local seen = {}\n  for _, num\
    \ in pairs(numbers) do\n    if not seen[num] then\n      seen[num] = true\n  \
    \    return true\n    end\n  end\n  return false\nend", "    local hash = {}\n\
    \    for _, v in ipairs(numbers) do\n        hash[v] = hash[v] or 1\n    end\n\
    \    local output = {}\n    for k, v in pairs(hash) do\n        table.insert(output,\
    \ v)\n    end\n    return output\nend", "  local output = {}\n  local seen = {}\n\
    \  for _, num in ipairs(numbers) do\n    if seen[num] then\n      table.insert(output,\
    \ num)\n    else\n      seen[num] = true\n    end\n  end\n  return output\nend",
  "  -- Copy the numbers into a table.\n  local copy_numbers = {}\n  for i, number\
    \ in ipairs(numbers) do\n    copy_numbers[number] = true\n  end\n  -- Now remove\
    \ dupes from the original table.\n  local last_number = numbers[1]\n  numbers\
    \ = {}\n  for i, number in ipairs(copy_numbers) do\n    if number ~= last_number\
    \ then\n      table.insert(numbers, last_number)\n    end\n    last_number = number\n\
    \  end\n  return numbers\nend", "  local seen = {}\n  local new_numbers = terralib.newlist()\n\
    \  local N = #numbers\n  for i = 1, N do\n    if seen[numbers[i]] then\n     \
    \ new_numbers:insert(numbers[i])\n      seen[numbers[i]] = nil\n    else\n   \
    \   seen[numbers[i]] = true\n    end\n  end\n  return new_numbers\nend", "  for\
    \ i, v in pairs(numbers) do\n    table.insert(numbers, v)\n  end\n  table.sort(numbers,\
    \ function(a,b) return a < b end)\n  local unique_numbers = {}\n  for i = 1, #numbers\
    \ do\n    if numbers[i] ~= unique_numbers[numbers[i]] then\n      unique_numbers[numbers[i]]\
    \ = numbers[i]\n    end\n  end\n  return unique_numbers\nend", "  if #numbers\
    \ == 0 then\n    return {}\n  end\n  local counts = {}\n  local unique_numbers\
    \ = {}\n  for i = 1, #numbers do\n    counts[numbers[i]] = (counts[numbers[i]]\
    \ or 0) + 1\n    if counts[numbers[i]] > 1 then\n      unique_numbers[numbers[i]]\
    \ = 1\n    end\n  end\n  table.sort(unique_numbers)\n  for i = 1, #unique_numbers\
    \ do\n    table.insert(numbers, unique_numbers[i])\n  end\n  return numbers\n\
    end", "  local result = {}\n  local keys = {}\n  for i = 1, #numbers do\n    if\
    \ keys[numbers[i]] then\n      table.insert(result, numbers[i])\n      table.insert(result,\
    \ numbers[i])\n    else\n      keys[numbers[i]] = true\n    end\n  end\n  return\
    \ result\nend", "  for i = 1, #numbers, 1 do\n    local last = numbers[i]\n  \
    \  for j = i + 1, #numbers, 1 do\n      if numbers[j] == last then\n        numbers[i]\
    \ = nil\n        numbers[j] = nil\n      end\n    end\n  end\n  return numbers\n\
    end", "    -- Make an iterable to iterate over and return an iterator that has\
    \ already been exhausted.\n    local iterator = toiter(numbers)\n    return function()\
    \ return next(iterator) end\nend", "    local uniques = {}\n    for _, num in\
    \ pairs(numbers) do\n        if uniques[num] == nil then\n            uniques[num]\
    \ = true\n        end\n    end\n    for _, num in pairs(uniques) do\n        table.insert(numbers,\
    \ num)\n    end\n    return numbers\nend", "    local new_list = {}\n    local\
    \ unique_nums = setmetatable({}, { __mode = \"v\" })", "    if #numbers == 0 then\n\
    \        return numbers\n    end\n    local old_array = numbers\n    local old_hash\
    \ = setmetatable({}, {__mode=\"v\"})\n    for i, v in ipairs(old_array) do\n \
    \       old_hash[v] = true\n    end\n    local new_array = old_array\n    for\
    \ i = #old_array, 1, -1 do\n        local v = old_array[i]\n        if not old_hash[v]\
    \ then\n            new_array = new_array:remove(v)\n        end\n    end\n  \
    \  return new_array\nend", "    local seen = {}\n    for _, v in ipairs(numbers)\
    \ do\n        if seen[v] then\n            for _, v2 in ipairs(seen) do\n    \
    \            if v == v2 then\n                    seen[v] = nil\n            \
    \    end\n            end\n        else\n            seen[v] = true\n        end\n\
    \    end\n    return table.concat(seen)\nend", "  if #numbers == 0 then\n    return\
    \ numbers\n  end\n  local result = {}\n  local index = true\n  for i = 1, #numbers\
    \ do\n    if not index then\n      index = numbers[i] == numbers[i - 1]\n    end\n\
    \    if index then\n      result[#result + 1] = numbers[i]\n    end\n  end\n \
    \ return result\nend", "  local map = {}\n  local uniques = {}\n  for i = 1, #numbers\
    \ do\n    local element = numbers[i]\n    if not map[element] then\n      map[element]\
    \ = true\n      uniques[#uniques + 1] = element\n    end\n  end", "  local new_numbers\
    \ = {}\n  for _, number in ipairs(numbers) do\n    if new_numbers[number] then\n\
    \      table.insert(new_numbers, number)\n    end\n    new_numbers[number] = true\n\
    \  end\n  return new_numbers\nend", "  assert(type(numbers) == 'table')", "  local\
    \ output = {}\n  for _, num in ipairs(numbers) do\n    table.insert(output, num)\n\
    \  end\n  for i, num in ipairs(output) do\n    local old = output[i]\n    output[i]\
    \ = num\n    for _, val in ipairs(output) do\n      if val == old then\n     \
    \   table.insert(output, val)\n      end\n    end\n  end\n  return output\nend",
  "    local seen = {}\n    for _, num in ipairs(numbers) do\n        if seen[num]\
    \ == 1 then continue end\n        seen[num] = 1\n        table.insert(numbers,\
    \ num)\n    end\n    return numbers\nend", "  local nums = {}\n  for _, num in\
    \ pairs(numbers) do\n    if nums[num] == nil then\n      nums[num] = 1\n    else\n\
    \      nums[num] = nums[num] + 1\n    end\n  end\n  local result = {}\n  for _,\
    \ num in pairs(nums) do\n    if nums[num] > 1 then\n      result[#result + 1]\
    \ = num\n    end\n  end\n  return result\nend", "  local results = {}\n  for _,\
    \ num in pairs(numbers) do\n    results[num] = true\n  end", "  return table.sort(\n\
    \      table.unpack(\n          table.map_pairs(\n              function(value)\
    \ return value end, numbers\n          )\n      )\n  )\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nI have used the code below to remove duplicates in table of strings.\
    \ Hope it helps someone.\n<code>", "   -- Create a list to store the numbers that\
    \ occur more than once.\n   -- Also initialize a list to store the result. \n\
    \   local occur = {}\n   local result = {}\n   -- Traverse numbers once.\n   for\
    \ _, number in pairs(numbers) do\n      -- If the number is not in occur, add\
    \ it to result and add 1 to occur.\n      if occur[number] == nil then\n     \
    \    result[#result + 1] = number\n         occur[number] = 1\n      -- If it\
    \ does occur, add one to occur.\n      else\n         occur[number] = occur[number]\
    \ + 1\n      end\n   end\n   return result\nend", "  local result = {}\n  local\
    \ uniques = {}\n  for _, number in ipairs(numbers) do\n    if uniques[number]\
    \ then\n      result[uniques[number]] = number\n    else\n      uniques[number]\
    \ = true\n      result[number] = number\n    end\n  end\n  return result\nend",
  "  for i, v in ipairs(numbers) do\n    if numbers.count(v) == 1 then\n      table.remove(numbers,\
    \ v)\n    end\n  end\n  return numbers\nend", "    -- Using an accumulator to\
    \ store the unique values.\n    local unique_numbers = {}\n    for _, number in\
    \ pairs(numbers) do\n        if unique_numbers[number] ~= nil then\n         \
    \   unique_numbers[number] = unique_numbers[number] + 1\n        else\n      \
    \      unique_numbers[number] = 1\n        end\n    end\n    -- Return the unique\
    \ values only.\n    return unique_numbers\nend", "  if #numbers == 0 then return\
    \ {} end\n  local new_numbers = {}\n  for i = 1, #numbers do\n    if not new_numbers[i]\
    \ then new_numbers[i] = numbers[i] end\n  end\n  local uniques = {}\n  for i =\
    \ 1, #new_numbers do\n    local n = new_numbers[i]\n    if #uniques == 0 then\n\
    \      uniques = {n}\n    else\n      for j = 1, #uniques do\n        if uniques[j]\
    \ == n then\n          uniques[j] = nil\n        end\n      end\n    end\n  end\n\
    \  if #uniques > 1 then\n    for i = 1, #uniques do\n      table.insert(new_numbers,\
    \ uniques[i])\n    end\n  end\n  return new_numbers\nend", "    if #numbers ==\
    \ 0 then\n        return nil\n    end\n    if #numbers == 1 then\n        return\
    \ numbers\n    end", "  local last_seen = {}\n  for i = 1, #numbers do\n    local\
    \ value = numbers[i]\n    if last_seen[value] == nil then\n      last_seen[value]\
    \ = true\n    else\n      numbers[#numbers + 1] = value\n    end\n  end\n  return\
    \ numbers\nend", "  assert(numbers:size() >= 1, 'remove_duplicates:numbers:size()\
    \ < 1')", "    local new_numbers = {}\n    local i = 1\n    while i <= #numbers\
    \ do\n        if new_numbers[numbers[i]] == nil then\n            new_numbers[numbers[i]]\
    \ = numbers[i]\n        else\n            i = i + 1\n        end\n    end\n  \
    \  return new_numbers\nend", "  if #numbers <= 1 then return numbers end\n  local\
    \ counts = {}\n  for _, x in ipairs(numbers) do counts[x] = 1 + counts[x] end\n\
    \  -- Reverse the table to keep the same order.\n  local reversed = {}\n  for\
    \ key, value in pairs(counts) do\n    reversed[key] = math.max(value, reversed[key])\n\
    \  end\n  -- Make a new list with only unique elements.\n  local ret = {}\n  for\
    \ key, value in pairs(reversed) do\n    table.insert(ret, key)\n  end\n  return\
    \ ret\nend", "   local seen = nil\n   for _, value in ipairs(numbers) do\n   \
    \   if seen then\n         if seen == value then\n            seen = nil\n   \
    \      else\n            table.insert(numbers, seen)\n         end\n      else\n\
    \         seen = value\n      end\n   end\n   return numbers\nend", "  assert(#numbers\
    \ > 0, 'List cannot be empty')\n  local i = 0\n  local j = 1\n  local newarray\
    \ = {}\n  while i <= #numbers do\n    while j <= #numbers do\n      if numbers[i]\
    \ == numbers[j] then\n        table.insert(newarray, numbers[i])\n        i =\
    \ i + 1\n      else\n        j = j + 1\n      end\n    end\n  end\n  return newarray\n\
    end", "  if numbers == nil then return nil end\n  local counts = {}\n  for i =\
    \ 1, #numbers do\n    table.insert(counts, numbers[i])\n  end\n  local new_numbers\
    \ = {}\n  for i = 1, #counts do\n    if counts[i] == 1 then\n      table.insert(new_numbers,\
    \ numbers[i])\n    end\n  end\n  return new_numbers\nend", "    local seen = {}\n\
    \    for i=1,#numbers do\n        seen[numbers[i]] = true\n    end\n    local\
    \ result = {}\n    for i=1,#numbers do\n        if not seen[numbers[i]] then\n\
    \            result[#result + 1] = numbers[i]\n        end\n    end\n    return\
    \ result\nend", "  local result = {}\n  for _, value in pairs(numbers) do\n  \
    \  if result[value] == nil then\n      result[value] = true\n    else\n      result[value]\
    \ = false\n    end\n  end\n  return setmetatable(result, list)\nend", "  if #numbers\
    \ == 0 then\n    return nil\n  end", "    -- start with the numbers that are not\
    \ repeated, remove them from the remaining\n    -- numbers, return the result.\n\
    \    -- This requires O(n) memory and O(n) time.", "  local result = {}\n  for\
    \ i = 1, #numbers do\n    if result[numbers[i]] ~= nil then\n      result[numbers[i]]\
    \ = true\n    else\n      result[numbers[i]] = i\n    end\n  end\n  local keys\
    \ = pairs(result)\n  table.sort(keys)\n  for i = 1, #keys do\n    numbers[tonumber(keys[i])]\
    \ = nil\n  end\n  return numbers\nend", "   local output = {}\n   for _, x in\
    \ ipairs(numbers) do\n      output[#output + 1] = x\n   end\n   return output\n\
    end", "  for i, value in ipairs(numbers) do\n    local count = numbers[i]\n  \
    \  for j = i+1, #numbers do\n      count = count and numbers[j] or 0\n      count\
    \ = count - 1\n      if count == 0 then\n        table.insert(numbers, j)\n  \
    \    end\n    end\n  end\n  return numbers\nend", "  local result = {}\n  for\
    \ _, value in ipairs(numbers) do\n    if result[value] == nil then\n      result[value]\
    \ = value\n    end\n  end\n  return result\nend", "  local seen = {}\n  local\
    \ new_numbers = {}\n  for _, i in pairs(numbers) do\n    table.insert(seen, i)\n\
    \    table.insert(new_numbers, i)\n  end\n  return new_numbers\nend", "  if numbers\
    \ == nil then\n    return nil\n  end\n  local removed = {}\n  local current_idx\
    \ = 1\n  local result = {}\n  for i = 1, #numbers do\n    local j = current_idx\n\
    \    if numbers[i] ~= numbers[j] then\n      removed[numbers[j]] = true\n    \
    \  result[current_idx] = numbers[j]\n      current_idx = current_idx + 1\n   \
    \ end\n  end\n  table.insert(result, current_idx)\n  return result\nend", "  for\
    \ i = #numbers, 1, -1 do\n    if numbers[i] ~= numbers[i - 1]  then\n      table.insert(numbers,\
    \ numbers[i - 1])\n    end\n  end\n  return numbers\nend", "\tlocal new_list =\
    \ []\n\tfor _, x in ipairs(numbers) do\n\t\tif new_list[x] == nil then\n\t\t\t\
    table.insert(new_list, x)\n\t\tend\n\tend\n\treturn new_list\nend", "  if numbers\
    \ == nil then return end\n  if #numbers == 1 then return numbers end", "    local\
    \ result = {}\n    for i, number in ipairs(numbers) do\n        local n = result[number]\n\
    \        if n == nil then\n            n = 1\n        else\n            n = n\
    \ + 1\n        end\n        result[number] = n\n    end\n    for k, number in\
    \ ipairs(result) do\n        if number == 1 then\n            table.remove(numbers,\
    \ k)\n        end\n    end\n    return numbers\nend", "  local removed = {}\n\
    \  for i, v in ipairs(numbers) do\n    if not removed[v] then\n      removed[v]\
    \ = true\n      numbers[i] = v\n    end\n  end\n  return numbers\nend", "  local\
    \ new_numbers = {}\n  local i = 0\n  for _, num in pairs(numbers) do\n    if new_numbers[i]\
    \ ~= nil then\n      table.insert(new_numbers, num)\n    else\n      new_numbers[i]\
    \ = num\n    end\n    i = i + 1\n  end\n  return new_numbers\nend", "  assert(#numbers\
    \ > 0)\n  local counts = {}\n  local output = {}\n  for i = 1, #numbers do\n \
    \   if counts[numbers[i]] == nil then\n      output[#output + 1] = numbers[i]\n\
    \      counts[numbers[i]] = 1\n    end\n  end\n  return output\nend", "    local\
    \ seen = {}\n    for _, num in pairs(numbers) do\n        if seen[num] then\n\
    \            return numbers[#numbers]:reverse()\n        end\n        seen[num]\
    \ = true\n    end\n    return numbers\nend", "    local result = {}\n    for _,\
    \ x in ipairs(numbers) do\n        if x ~= nil and #result < x then\n        \
    \    result[#result+1] = x\n        end\n    end\n    return result\nend", " \
    \ local result = {}\n  for _, v in ipairs(numbers) do\n    if result[#result +\
    \ 1] == v then\n      result[#result + 1] = nil\n    else\n      result[#result\
    \ + 1] = v\n    end\n  end", "  -- Use list comprehension to avoid using \"for\"\
    \ loops.\n  return setmetatable(\n    numbers,\n    {__index = function(self,\
    \ index)\n      -- Don't include numbers more than once.\n      if index < self.count\
    \ then\n        return self[index]\n      end", "  if #numbers == 1 then\n   \
    \ return numbers\n  end", "\tlocal hash = {}\n\tlocal i = 1\n\tfor _,n in ipairs(numbers)\
    \ do\n\t\thash[n] = hash[n] or i\n\t\ti = i + 1\n\tend\n\tfor _,n in ipairs(numbers)\
    \ do\n\t\tnumbers[hash[n]] = nil\n\tend\n\treturn numbers\nend", "    local seen\
    \ = {}\n    local n = 0\n    local new_numbers = {}\n    for _, v in pairs(numbers)\
    \ do\n        if seen[v] then\n            new_numbers[n] = v\n            n =\
    \ n + 1\n        else\n            seen[v] = true\n        end\n    end\n    if\
    \ n > 0 then\n        new_numbers[n + 1] = nil\n    end\n    return new_numbers\n\
    end", "  local seen = {}\n  local new_numbers = {}\n  local last_number = nil\n\
    \  for i = 1, #numbers do\n    if not seen[numbers[i]] then\n      seen[numbers[i]]\
    \ = true\n      new_numbers[#new_numbers + 1] = numbers[i]\n    end\n  end\n \
    \ return new_numbers\nend", "    local hash = {}\n    for _, value in ipairs(numbers)\
    \ do\n        if hash[value] == nil then\n            hash[value] = true\n   \
    \         table.insert(numbers, value)\n        end\n    end\n    return numbers\n\
    end", "  local seen = {}\n  for _, value in ipairs(numbers) do\n    if seen[value]\
    \ then\n      table.insert(numbers, seen[value])\n    else\n      seen[value]\
    \ = true\n    end\n  end", "\tlocal new_numbers = {}\n\tlocal counts = {}", " \
    \ local visited = {}\n  local new_numbers = {}\n  local i = 1\n  while i < #numbers\
    \ and i <= #visited do\n    visited[#visited + 1] = numbers[i]\n    i = i + 1\n\
    \  end\n  if i < #numbers - 1 then\n    new_numbers = {}\n  else\n    new_numbers\
    \ = numbers\n  end\n  i = 1\n  while i < #visited do\n    if visited[#visited\
    \ + 1] == visited[i] then\n      i = i + 1\n    else\n      new_numbers[i] = visited[#visited\
    \ + 1]\n      i = i + 1\n    end\n  end\n  return new_numbers\nend", "  -- Sort\
    \ list\n  table.sort(numbers)", "    local seen = {}\n    for _, item in ipairs(numbers)\
    \ do\n        if seen[item] then\n            numbers[#numbers+1] = item\n   \
    \     else\n            seen[item] = true\n        end\n    end\n    return numbers\n\
    end", "    local map = {}\n    local new_numbers = {}\n    for _, number in ipairs(numbers)\
    \ do\n        map[number] = true\n        new_numbers[#new_numbers + 1] = number\n\
    \    end\n    return new_numbers\nend", "    local seen = {}\n    for _, value\
    \ in ipairs(numbers) do\n        if seen[value] ~= nil then\n            table.remove(numbers,\
    \ seen[value])\n        else\n            seen[value] = true\n        end\n  \
    \  end\n    return numbers\nend\n</cell>\n<cell>\nprint(remove_duplicates([1,\
    \ 2, 3, 2, 4]))\n</cell>\n<text>\nExercise 1: Remove Duplicates\nWrite a function\
    \ that takes a table of numbers and returns another table with all the numbers\
    \ removed from the first table. Make sure you remove numbers that occur more than\
    \ once.", "  return setmetatable(numbers, {\n    __index = function(t, k)\n  \
    \    local value = rawget(t, k)\n      if value ~= nil then\n        if value\
    \ ~= t then\n          -- Found an entry for key 'k' that is different than 'value'\n\
    \          -- so we remove 'value' from the set.\n          rawset(t, k, nil)\n\
    \        end\n      else\n        -- There was no entry for the key 'k' so add\
    \ 'value' to the set.\n        rawset(t, k, true)\n      end\n      return value\n\
    \    end\n  })\nend", "  local seen = {}\n  for _, number in ipairs(numbers) do\n\
    \    if seen[number] then\n      table.insert(numbers, seen[number])\n    end\n\
    \    seen[number] = number\n  end\n  return numbers\nend", "    local seen = {}\n\
    \    for _, x in pairs(numbers) do\n        if seen[x] then\n            numbers[#numbers]\
    \ = x\n        else\n            seen[x] = true\n        end\n    end\n    return\
    \ numbers\nend", "  local result = {}\n  for i = 1, #numbers do\n    if result[numbers[i]]\
    \ == nil then\n      result[numbers[i]] = true\n    else\n      table.insert(result,\
    \ numbers[i])\n    end\n  end\n  table.sort(result)\n  return result\nend", " \
    \   local seen = {}\n    for _, num in pairs(numbers) do\n        if not seen[num]\
    \ then\n            seen[num] = true\n            table.insert(numbers, num)\n\
    \        end\n    end\n    return numbers\nend", "  local map = {}\n  for _, number\
    \ in pairs(numbers) do\n    map[number] = true\n  end\n  table.sort(numbers, true)\n\
    \  local index = 1\n  local results = {}\n  for _, number in pairs(numbers) do\n\
    \    if map[number] then\n      table.insert(results, number)\n      index = index\
    \ + 1\n      map[number] = nil\n    end\n  end\n  return results\nend", "  local\
    \ unique_numbers = terralib.newlist()\n  local unique_number_i = 0\n  for i =\
    \ 1, #numbers do\n    if i > unique_number_i then\n      unique_numbers:insert(numbers[i])\n\
    \      unique_number_i = i + 1\n    end\n  end", "  if #numbers == 0 then\n  \
    \  return numbers\n  end", "  local table = {}\n  for _, value in ipairs(numbers)\
    \ do\n    if not table[value] then\n      table.insert(table, value)\n    end\n\
    \  end\n  return table\nend", "  local new_numbers = {}\n  for _, v in ipairs(numbers)\
    \ do\n    local k = new_numbers[v]\n    new_numbers[v] = k or 1\n  end\n  new_numbers[1]\
    \ = nil\n  return new_numbers\nend", "  assert(#numbers > 0, \"remove_duplicates:\
    \ empty list\")\n  local seen = {}\n  local output = {}\n  local i = 1\n  for\
    \ v in numbers do\n    if seen[v] then\n      output[#output + 1] = v\n    else\n\
    \      seen[v] = true\n      output[#output + 1] = v\n    end\n  end\n  return\
    \ output\nend", "    local sorted_numbers = table.sort(numbers)\n    local result\
    \ = {}\n    local i = 1\n    for j = 1, #sorted_numbers do\n        if sorted_numbers[i\
    \ - 1] == sorted_numbers[j] then\n            table.remove(result, i - 1)\n  \
    \      else\n            i = i + 1\n        end\n    end\n    return table.remove(result,\
    \ i - 1)\nend", "  local result = {}\n  for _, number in pairs(numbers) do\n \
    \   if result[number] ~= nil then\n      result[number] = true\n    else\n   \
    \   result[number] = number\n    end\n  end", "    local result = {}\n    local\
    \ i = 1\n    while i <= #numbers do\n        if table.getn(result) < table.getn(numbers)\
    \ then\n            table.insert(result, numbers[i])\n        else\n         \
    \   i = i + 1\n        end\n    end\n    return result\nend", "  return table.sort(numbers)\
    \ -- Orders elements left the same\nend", "    local seen = {}\n    for _, number\
    \ in pairs(numbers) do\n        if seen[number] == 1 then\n            numbers[#numbers]\
    \ = nil\n        else\n            seen[number] = 1\n        end\n    end\n  \
    \  return numbers\nend", "    local seen = {}\n    for _, x in pairs(numbers)\
    \ do\n        if seen[x] then\n            for j = 1, #numbers do\n          \
    \      if numbers[j] == x then\n                    table.remove(numbers, j)\n\
    \                    break\n                end\n            end\n        else\n\
    \            table.insert(seen, x)\n        end\n    end\n    return numbers\n\
    end", "  local result = {}\n  local last_number = nil\n  for _, number in pairs(numbers)\
    \ do\n    if number ~= last_number then\n      result[#result + 1] = number\n\
    \      last_number = number\n    end\n  end\n  return result\nend", "  for i =\
    \ 1, #numbers do\n    local element = numbers[i]\n    local j = 1\n    while j\
    \ < i do\n      local found = true\n      local k = j + 1\n      while k < #numbers\
    \ do\n        found = found and numbers[k] == element\n        k = k + 1\n   \
    \   end\n      if found then\n        numbers[j] = nil\n      else\n        j\
    \ = j + 1\n      end\n    end\n  end\n  table.sort(numbers, function(a, b) return\
    \ a < b end)\n  table.insert(numbers, nil)\n  return numbers\nend", "  local new_numbers\
    \ = {}\n  local num_seen = {}\n  local current_value = nil\n  for i, v in ipairs(numbers)\
    \ do\n    if num_seen[v] then\n      current_value = current_value .. \", \" ..\
    \ v\n    else\n      new_numbers[i] = v\n      num_seen[v] = true\n    end\n \
    \ end\n  return new_numbers\nend", "  assert(type.islist(numbers))\n  local new_numbers\
    \ = {}\n  for _, number in ipairs(numbers) do\n    if #new_numbers ~= 0 then\n\
    \      table.insert(new_numbers, number)\n      table.insert(new_numbers, number)\n\
    \    else\n      table.insert(new_numbers, number)\n    end\n  end", "  local\
    \ unique = {}\n  for _, value in ipairs(numbers) do\n    if not table.includes(unique,\
    \ value) then\n      table.insert(unique, value)\n    end\n  end\n  return table.concat(unique)\n\
    end", "  local seen = {}\n  for _, v in pairs(numbers) do\n    if seen[v] == 1\
    \ then\n      table.remove(numbers, v)\n    end\n    seen[v] = 1\n  end\n  return\
    \ numbers\nend", "  -- Create a list of unique elements.\n  local unique_numbers\
    \ = {}\n  for i = 1, #numbers do\n    -- If an element is not unique, then add\
    \ it to the unique_numbers list with the associated index.\n    if not find_unique_index(unique_numbers,\
    \ numbers[i]) then\n      unique_numbers[#unique_numbers+1] = numbers[i]\n   \
    \ end\n  end", "   local seen = {}\n   for _, value in ipairs(numbers) do\n  \
    \    if seen[value] then\n         table.remove(numbers, value)\n      else\n\
    \         seen[value] = true\n      end\n   end\n   return numbers\nend", "  local\
    \ new = {}\n  for _, v in ipairs(numbers) do\n    if not rawcontains(new, v) then\n\
    \      table.insert(new, v)\n    end\n  end\n  return new\nend", "  if #numbers\
    \ == 1 then\n    return numbers\n  end\n  local seen = {}\n  for i = 1, #numbers\
    \ do\n    if seen[numbers[i]] then\n      table.remove(numbers, i)\n    else\n\
    \      seen[numbers[i]] = true\n    end\n  end\n  return numbers\nend", "  local\
    \ new_numbers = {}\n  for _, value in pairs(numbers) do\n    if new_numbers[value]\
    \ == nil then\n      table.insert(new_numbers, value)\n    end\n  end\n  return\
    \ new_numbers\nend", "    local set = setmetatable({}, { __mode = \"v\" })\n \
    \   for _, value in ipairs(numbers) do\n        if set[value] == nil then\n  \
    \          set[value] = 1\n        else\n            set[value] = set[value] +\
    \ 1\n        end\n    end\n    return setmetatable(set, { __mode = \"k\" })\n\
    end", "  local t = {}\n  table.sort(numbers)\n  for _, number in ipairs(numbers)\
    \ do\n    if #t[number] == 1 then\n      t[number] = number\n    else\n      t[number]\
    \ = t[number]\n    end\n  end\n  return t\nend", "   local result = {}\n   for\
    \ _, number in ipairs(numbers) do\n      result[number] = true\n   end\n   return\
    \ ipairs(result) and result[true]\nend", "  local t = {}\n  for _, v in ipairs(numbers)\
    \ do\n    table.insert(t, v)\n  end\n  table.sort(t)\n  table.insert(t, 1, table.max(t))\n\
    \  for i = 2, #t do\n    table.insert(t, t[i - 2])\n  end\n  return t\nend", " \
    \ local results = {}\n  for i, number in ipairs(numbers) do\n    if results[number]\
    \ then\n      results[number] = nil\n    else\n      table.insert(results, number)\n\
    \    end\n  end\n  return table.concat(results)\nend", "    local new = {}\n \
    \   for _, item in ipairs(numbers) do\n        if next(new) == item then\n   \
    \         continue\n        end\n        table.insert(new, item)\n    end\n  \
    \  return new\nend", "  local removed = {}\n  for i = 1, #numbers do\n    if removed[numbers[i]]\
    \ then\n      numbers[i] = nil\n    else\n      removed[numbers[i]] = true\n \
    \   end\n  end\n  return table.concat(numbers)\nend", '  local hash_table = {}',
  "   local res = {}\n   for _, v in pairs(numbers) do\n      if res.includes(v) then\
    \ continue end\n      table.insert(res, v)\n   end\n   return res\nend", "  assert(#numbers\
    \ > 0, 'remove_duplicates: empty list of numbers')\n  local new_numbers = {}\n\
    \  for _, value in ipairs(numbers) do\n    if new_numbers[value] == nil then\n\
    \      new_numbers[value] = 1\n    else\n      new_numbers[value] = new_numbers[value]\
    \ + 1\n    end\n  end\n  for i = 1, #numbers do\n    if new_numbers[numbers[i]]\
    \ > 1 then\n      table.remove(new_numbers, numbers[i])\n    end\n  end\n  return\
    \ new_numbers\nend", "  local result = {}\n  for _, number in ipairs(numbers)\
    \ do\n    result[number] = number\n  end\n  return result\nend", "  return table.unpack(table.sort(numbers))\n\
    end", "   if #numbers == 0 then return nil end\n   local removed = {}\n   for\
    \ i = 1, #numbers do\n      removed[numbers[i]] = true\n   end\n   local new_numbers\
    \ = {}\n   for i = 1, #numbers do\n      if removed[i] then\n         new_numbers[#new_numbers\
    \ + 1] = numbers[i]\n      end\n   end\n   return new_numbers\nend", "  if 0 ==\
    \ #numbers then return numbers end\n  local seen = {}\n  local res = {}\n  local\
    \ i = 0\n  while i < #numbers and numbers[i] ~= nil do\n    if seen[numbers[i]]\
    \ then\n      -- keep element\n      i = i + 1\n    else\n      -- add element\n\
    \      table.insert(res, numbers[i])\n      seen[numbers[i]] = true\n    end\n\
    \  end\n  table.sort(res)\n  return res\nend", "  local seen = {}\n  local ret\
    \ = {}\n  for i = 1, #numbers do\n    if seen[numbers[i]] then -- Already encountered\
    \ this number\n      -- Reuse last seen number\n      ret[i] = seen[numbers[i]]\n\
    \    else\n      -- Remember new number, including order\n      seen[numbers[i]]\
    \ = i\n      ret[i] = numbers[i]\n    end\n  end\n  return ret\nend", "  local\
    \ result = {}\n  local i = 0\n  for n in numbers do\n    if result[i] == nil then\n\
    \      result[i] = n\n    else\n      i = i + 1\n      result[i] = n\n    end\n\
    \  end", "    if #numbers == 0 then\n        return nil\n    end\n    local seen\
    \ = {}\n    local output = {}\n    for _, num in ipairs(numbers) do\n        if\
    \ seen[num] then\n            return output\n        end\n        output[#output+1]\
    \ = num\n        seen[num] = true\n    end\n    return output\nend", "\tlocal\
    \ result = {}\n\tlocal hash = {}", "  assert(type(numbers) == 'table', 'remove_duplicates\
    \ needs a table')\n  local result = {}\n  local num_seen = {}\n  for _, num in\
    \ pairs(numbers) do\n    if not num_seen[num] then\n      result[#result + 1]\
    \ = num\n      num_seen[num] = true\n    end\n  end\n  return result\nend", " \
    \ return table.unpack(\n    table.sort(\n      table.unique(\n        table.map(\n\
    \          function(self, num)\n            return self:find(num) ~= nil\n   \
    \       end,\n          numbers\n        )\n      )\n    )\n  )\nend", "  local\
    \ result = {}\n  for _, value in ipairs(numbers) do\n    if not result[value]\
    \ then\n      result[value] = value\n    end\n  end\n  return result\nend", " \
    \   local result = {}\n    for i = 1, #numbers do\n        local number = numbers[i]\n\
    \        if table.contains(result, number) then\n            for j = 1, #result\
    \ do\n                if result[j] == number then\n                    table.remove(result,\
    \ j)\n                    break\n                end\n            end\n      \
    \  else\n            table.insert(result, number)\n        end\n    end\n    return\
    \ result\nend\n</code>\nNow you can just copy your example code to this new function\
    \ and everything will work just fine.\n<|/ a dscore=2 |>\n<| c |>\nThank you very\
    \ much. This is really good solution. I know that this is not the best approach\
    \ in terms of speed, however I just want to learn some basics about Lua and I\
    \ wanted to make something with it (just for fun) and this is what I needed.\n\
    <|/ c |>\n<| a |>\nThe other answers make good points that you should probably\
    \ try to avoid, but if you really want to do this here's a modified version of\
    \ your current solution that doesn't require a loop:\n<code>", "    local output\
    \ = {}\n    for _, v in ipairs(numbers) do\n        table.insert(output, v)\n\
    \    end\n    return output\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
