name: HumanEval_154_cycpattern_check
language: lua
prompt: "-- You are given 2 words. You need to return True if the second word or any\
  \ of its rotations is a substring in the first word\n-- cycpattern_check(\"abcd\"\
  ,\"abd\") => False\n-- cycpattern_check(\"hello\",\"ell\") => True\n-- cycpattern_check(\"\
  whassup\",\"psus\") => False\n-- cycpattern_check(\"abab\",\"baa\") => True\n--\
  \ cycpattern_check(\"efef\",\"eeff\") => False\n-- cycpattern_check(\"himenss\"\
  ,\"simen\") => True\nlocal function cycpattern_check(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = cycpattern_check\n\
  \    lu.assertEquals(candidate('xyzw', 'xyw'), false)\n    lu.assertEquals(candidate('yello',\
  \ 'ell'), true)\n    lu.assertEquals(candidate('whattup', 'ptut'), false)\n    lu.assertEquals(candidate('efef',\
  \ 'fee'), true)\n    lu.assertEquals(candidate('abab', 'aabb'), false)\n    lu.assertEquals(candidate('winemtt',\
  \ 'tinem'), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    for i=1,#a do\n        local b = b..a\n        local t = false\n\
    \        for j = 1,#b do\n            local c = a\n            for k = 1,#c do\n\
    \                c = c..c\n            end\n            if sub(a,b,j,#b) == 1\
    \ then\n                t = true\n            end\n        end\n        if t then\
    \ return true end\n    end\n    return false\nend", "  return #b > 0 and #a ==\
    \ 0 or (#b == 0 and #a == #b and #a == 0 or #b == 0 and #a <= #b and #b - #a <=\
    \ #a)\nend", "    local pattern = a\n    local patternlength = #a\n    for i =\
    \ 1, #b do\n        pattern = pattern:gsub(b[i])\n    end\n    return pattern\
    \ == pattern\nend\n</cell>\n<text>\nCycle Detector", "  -- return true if the\
    \ second word is a substring in the first word\n  local function check(c)\n  \
    \  local sub = string.sub(a, b, 1, 1)\n    if sub == c then\n      -- return true\
    \ if sub is a rotation of c\n      local n = string.len(sub)\n      if string.len(c)\
    \ > n then return false end\n      local m = string.len(c)\n      for i=1,n do\n\
    \        if string.byte(sub, i) ~= string.byte(c, i) return false end\n      end\n\
    \      return true\n    end\n    return false\n  end\n  local words = string.gmatch(a,\
    \ \"[^%s]+\")\n  for word in words do\n    if not check(word) then return false\
    \ end\n  end\n  return true\nend", "  a = a:lower()\n  b = b:lower()\n  local\
    \ match = a:find(b)\n  if match then\n    local offset = 1\n    while offset <=\
    \ match do\n      if a:sub(match, offset + 1) in b then\n        return true\n\
    \      end\n      offset = offset + #b + 1\n    end\n  end\n  return false\nend",
  "  -- If the string is empty or has one character or one rotation of the characters,\
    \ return true\n  if #a <= 1 or #b <= 1 then return true end", "  if a:find(b)\
    \ ~= nil then\n    return true\n  elseif a:find(b, \".-\") ~= nil then\n    return\
    \ false\n  elseif b:find(a) ~= nil then\n    return false\n  elseif a:sub(1, 1)\
    \ ~= \"\" then\n    return cycpattern_check(a:sub(1, 1), b)\n  else\n    return\
    \ false\n  end\nend\n</code>\n<|/ a tags=string,lua-patterns,lua |>\n<| a tags=string,lua-patterns,lua\
    \ dscore=1 |>\nA simple recursive solution which checks also for matching prefixes\
    \ and suffixes and does not require an external library function:\n<code>", " \
    \   for i = 1, #a do\n        local t = string.sub(a, i, i)\n        if string.sub(b,\
    \ 1, #t) = t then\n            return true\n        end\n    end\n    return false\n\
    end", "    for i = 1, #a do\n        if string.find(b, a[i]) then\n          \
    \  return true\n        end\n    end\n    return false\nend", "  if #a > #b then\n\
    \    return false\n  end", "    local aL = string.len(a)\n    local bL = string.len(b)\n\
    \    if aL ~= bL then\n        return false\n    end\n    for i=1, aL do\n   \
    \     if string.sub(a,i,i) ~= string.sub(b,1,i) then\n            return false\n\
    \        end\n    end\n    return true\nend", "  local p1,p2 = string.find(a,b),string.find(a,b,1,true)\n\
    \  -- print(p1,p2)\n  -- print(p1,p2,p1,p2)\n  return p1 and p2 and p1 < p2\n\
    end", "\ta = string.lower(a)\n\tb = string.lower(b)\n\t-- Check for any common\
    \ substrings\n\tlocal commons = a:gsub(\".\" , function(word) return table.indexOf(string.lower(b),\
    \ word) > -1 end)\n\t-- Check for rotations\n\tlocal rots = a:gsub(\"[\" .. b:sub(2)\
    \ .. \"]\", function(match) return \"[\" .. string.sub(match, 1, 2) .. match \
    \ .. string.sub(match,3) end)\n\t-- Check for substring in other words\n\tlocal\
    \ subs = a:gsub(\".\" , function(word) return string.find(b, word) ~= nil end)\n\
    \t-- If no common words, return false\n\treturn not (commons or rots or subs)\n\
    end", "   local first = unpack(cycpattern1(a))\n   local second = unpack(cycpattern2(b))\n\
    \   return first:sub(1, #first) == second or first:sub(1, #first):sub(1, #first)\
    \ == second\nend", "    for i = 1, #a do\n        if b == string.sub(a, 1, i)\
    \ or b == string.sub(a, i, #a) then\n            return true\n        end\n  \
    \  end\n    return false\nend", "  return #b < 1 or #a < 1 or (#b == 2 and not\
    \ #a or #b > 1 and not #a or b[1] == a[#a] and cycpattern_check(a[#a],b[#b]) or\
    \ cycpattern_check(a[1],b[1]) and #a == #b and (a[#a] == b[#b] or a[1] == b[1])\
    \ and #a == 3 or not #a or #b or a[1] == a[1] or b[1] == b[1] or a[1] == \"*\"\
    \ or b[1] == \"*\")\nend", "   --[[\n     -- This function is an implementation\
    \ of the Cycle Pattern Check\n     -- Algorithm. The algorithm was first described\
    \ in:\n     -- Spiro, Natalia, et al. \"Cycle pattern detection in morphologically\
    \ annotated protein structures.\"\n     -- Proteins 2018; PMID: 23338508\n   --]]\n\
    \   local function sub_pattern_check(a, b, p, q) -- checks if p is a substring\
    \ of q\n      local function char_is_in_string(x, y, z)\n         return x:sub(y,\
    \ z) ~= nil\n      end\n      if char_is_in_string(a, p, q) then\n         return\
    \ true\n      end\n      if char_is_in_string(b, p, q) then\n         return true\n\
    \      end\n      if char_is_in_string(a, q, p) then\n         return true\n \
    \     end\n      if char_is_in_string(b, q, p) then\n         return true\n  \
    \    end\n      if char_is_in_string(a, p, q) then\n         return true\n   \
    \   end\n      if char_is_in_string(b, p, q) then\n         return true\n    \
    \  end\n      if char_is_in_string(a, q, p) then\n         return true\n     \
    \ end\n      if char_is_in_string(b, q, p) then\n         return true\n      end\n\
    \      return false\n   end\n   local function substr_check(a, b, p, q)\n    \
    \  if p:sub(1, #a) == q:sub(1, #b) then\n         return true\n      end\n   \
    \   if p:sub(1, #a) ~= q:sub(1, #b) then\n         return false\n      end\n \
    \     if p:sub(1, #a) == q:sub(1, #b) then\n         return true\n      end\n\
    \      if p:sub(1, #a) ~= q:sub(1, #b) then\n         return false\n      end\n\
    \      if p:sub(1, #a) == q:sub(1, #b) then\n         return true\n      end\n\
    \      if p:sub(1, #a) ~= q:sub(1, #b) then\n         return false\n      end\n\
    \      if p:sub(1, #a) == q:sub(1, #b) then\n         return true\n      end\n\
    \      if p:sub(1, #a) ~= q:sub(1, #b) then\n         return false\n      end\n\
    \      if p:sub(1, #a) == q:sub(1, #b) then\n         return true\n      end\n\
    \      if p:sub(1, #a) ~= q:sub(1, #b) then\n         ", "    local function is_sub(a,\
    \ b, e)\n        for i=1,#a do\n            if a[i]==b then return true end\n\
    \        end\n        return false\n    end\n    \n    local function is_sub2(a,\
    \ b, e)\n        for i=1,#a do\n            if a[i]~=b then return false end\n\
    \        end\n        return true\n    end\n    \n    local function is_rot(word,\
    \ i)\n        if word[i]~= word[i-1] then\n            return false\n        end\n\
    \        for k=2,#word do\n            if word[i]~= word[i-k] then\n         \
    \       return false\n            end\n        end\n        return true\n    end\n\
    \    \n    local function is_rots2(word, i)\n        if word[i]~= word[i..i] then\n\
    \            return false\n        end\n        for k=2,#word do\n           \
    \ if word[i]~= word[i-k] then\n                return false\n            end\n\
    \        end\n        return true\n    end\n    \n    if a == nil then\n     \
    \   return false\n    end\n    if b == nil then\n        return false\n    end\n\
    \    if a == b then\n        return true\n    end\n    \n    for i=1,#a do\n \
    \       if a[i] ~= b[i] then return false end\n    end\n    \n    for i=1,#b do\n\
    \        if is_sub(a,b,i) then return true end\n        if is_sub2(a,b,i) then\
    \ return true end\n        if is_rot(b,i) then return true end\n        if is_rots2(b,i)\
    \ then return true end\n    end\n    \n    return false\nend", "  local t = \"\
    \"\n  for i = 1, #a do\n    if #b - i > #t then\n      t = t .. \"-\"\n    elseif\
    \ #b - i == 0 then\n      t = t .. a\n    elseif a[i] == \"-\" then\n      t =\
    \ t .. a[i]\n    end\n  end\n  local n = 0\n  for i = 1, #a do\n    if a[i] ~=\
    \ \"-\" and a[i] ~= a[i+1] then\n      n = n + 1\n    end\n  end\n  for i = 1,\
    \ #b do\n    if b[i] ~= \"-\" and b[i] ~= b[i+1] then\n      n = n + 1\n    end\n\
    \  end\n  if #b - n > #t then\n    return false\n  elseif #b - n == 0 then\n \
    \   return true\n  else\n    local m = 0\n    for i = 1, #t do\n      if t[i]\
    \ == b[m] then\n        m = m + 1\n      end\n    end\n    return m == #b\n  end\n\
    end", "    if a ~= b then\n        for i = 1, #a do\n            for j = 1, #b\
    \ do\n                if string.find(string.sub(a,i,i), string.sub(b,j,j), 1,\
    \ true) ~= nil then\n                    return true\n                end\n  \
    \          end\n        end\n    end\n    return false\nend", "    local function\
    \ contains_substr_rotation(str, pos, len, pattern)\n        if pattern == \"\"\
    \ then\n            return true\n        end\n        if pos > #str then\n   \
    \         return false\n        end\n        if pos + len < 1 then\n         \
    \   -- Special case to check 0 index\n            return contains_substr_rotation(str,\
    \ pos, len, pattern)\n        end\n        local substr = str:sub(pos, pos + len)\n\
    \        for i = 1, #pattern do\n            if pattern:sub(i, i) == substr then\n\
    \                return true\n            end\n        end\n        return false\n\
    \    end\n    return contains_substr_rotation(a, b, 1, b)\nend", "  local len\
    \ = #a\n  local maxlen = len\n  if len > 0 then\n    len = len + 1\n  end\n  local\
    \ newb = {}\n  local i = 0\n  for j = 1, len do\n    local c = string.sub(a,i,i)\n\
    \    local d = string.sub(b,i,i)\n    if c ~= d then\n      newb[j] = c\n    end\n\
    \    i = i + 1\n  end\n  maxlen = len\n  for j = 1, len do\n    if newb[j] ~=\
    \ string.sub(b,j,j) then\n      maxlen = len\n    end\n  end\n  if maxlen == len\
    \ then\n    return true\n  else\n    return false\n  end\nend", "    return a:find(b)\
    \ or (a:gsub(b, \"[%s]\") ~= \"\")\nend", "  local bs = #b\n  local a = string.lower(a)\n\
    \  local b = string.lower(b)\n  -- check length\n  if bs ~= #a then\n    return\
    \ false\n  end\n  -- check rotation\n  local i = 0\n  local j = 0\n  while i <\
    \ bs and j < bs do\n    local t = a[j]\n    a[j] = a[i]\n    a[i] = t\n    i =\
    \ i + 1\n    j = j + 1\n  end\n  -- check if any substring matches\n  if b > a\
    \ then\n    for i=1,bs do\n      if string.find(a,b) == 1 or string.find(b,a)\
    \ == 1 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "    local function substr_or_rotation(s)\n        return string.find(s,\
    \ b) or string.find(string.gsub(s, b, \"%z\"), b)\n    end\n    return not substr_or_rotation(a)\
    \ or substr_or_rotation(a:sub(1, #a)) or substr_or_rotation(a:sub(#a+1)) or substr_or_rotation(b)\
    \ or substr_or_rotation(b:sub(1, #b)) or substr_or_rotation(b:sub(#b+1))\nend",
  "    local s = a..\"\"\n    for _, c in pairs(b) do\n        if s:find(c) == nil\
    \ then return false end\n        s = s:sub(1, #c)\n    end\n    return true\n\
    end", "  local a1, a2 = a:gsub(\"(.)\", function(c) return \"[\" .. string.sub(c,\
    \ 1, 1) .. \"]\" end)\n  local b1, b2 = b:gsub(\"(.)\", function(c) return \"\
    [\" .. string.sub(c, 1, 1) .. \"]\" end)\n  for i = 1, #b1 do\n    if string.find(a1,\
    \ string.sub(b1, i, i), 1, true) then\n      return true\n    end\n  end\n  return\
    \ false\nend", "    if a == nil or b == nil then\n        return false\n    end\n\
    \    for _, char in pairs(b) do\n        if a ~= nil and b:sub(1, #a) == a:sub(1,\
    \ #char) then\n            return true\n        end\n    end\n    return false\n\
    end", "   if #a == 0 then\n      return false\n   end", "  for _,c in ipairs(a)\
    \ do\n    for _,d in ipairs(b) do\n      if d == c or string.find(a, c, 1, true)\
    \ or string.find(b, c, 1, true) then\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "    for i = 1,#a do\n        for j = 1,#b do\n\
    \            if a[i] == b[j] or tostring(a:sub(i,i+1)) == tostring(b:sub(j,j+1))\
    \ then\n                return true\n            end\n        end\n    end\n \
    \   return false\nend", "    local b1 = {b}\n    if #b == 0 then return True end\n\
    \    local a1 = {a}\n    local b2 = {}\n    for i = 1, #a do\n        if #b >\
    \ 0 then\n            local pos = #a1\n            while pos > 0 and #b1 > 0 do\n\
    \                local i = a1[pos]\n                if #b1 > 0 then -- The string\
    \ contains more words\n                    if #b > 1 then\n                  \
    \      local j, b = b1[1], b1[2]\n                        if j == i then\n   \
    \                         table.insert(b2, j)\n                            b1\
    \ = b1[#b1]\n                        else\n                            local k\
    \ = #b\n                            for j = 1, #b1 do\n                      \
    \          table.insert(b2, k)\n                                k = k - 1\n  \
    \                          end\n                        end\n                \
    \    else -- The string only contains one word\n                        table.insert(b2,\
    \ i)\n                        b1 = b1[#b1]\n                    end\n        \
    \        end\n                pos = pos - 1\n            end\n        end\n  \
    \      if #b > 0 then -- The string contains more words\n            local j =\
    \ #a1\n            local k = #b1\n            while j > 0 and #b2 > 0 do\n   \
    \             local i = a1[j]\n                if #b2 > 0 then -- The string contains\
    \ more words\n                    if #b > 1 then\n                        local\
    \ j, b = b2[1], b2[2]\n                        if j == i then\n              \
    \              table.insert(b1, j)\n                            b2 = b2[#b2]\n\
    \                        else\n                            local k = #b1\n   \
    \                         for j = 1, #b2 do\n                                table.insert(b1,\
    \ k)\n                                k = k - 1\n                            end\n\
    \                        end\n                    else -- The string only contains\
    \ one word\n                        table.insert(b1, i)\n                    \
    \    b2 = b2[#b2]\n                    end\n                end\n            \
    \    j = j - 1\n            end\n        end\n    end\n    local j, b = #a, #b\n\
    \    while j > 0 do\n        if b[j] == b[1] then\n            table.insert(b1,\
    \ b[j])\n            b = b[#b]\n        else\n            table.insert(b2, b[j])\n\
    \            b = b[#b]\n        end\n        j = j - 1\n    end\n    return #b\
    \ == 0 and #a1 == #a\nend", "\tlocal result = true\n\tlocal strA, strB, i, j",
  "    local function helper(str)\n        local i = 0\n        while i + 1 \u2264\
    \ str do\n            local j = i\n            while j \u2264 str do\n       \
    \         if string.sub(str,j,j + 1) ~= string.sub(str,i,i + 1) then\n       \
    \             j = j + 1\n                else\n                    return true\n\
    \                end\n            end\n            i = i + 1\n        end\n  \
    \  end\n    if a == nil or b == nil then\n        return false\n    end\n    if\
    \ #a == 0 then\n        return true\n    end\n    if #b == 0 then\n        return\
    \ false\n    end\n    if helper(a) == false then\n        return false\n    end\n\
    \    if helper(b) == false then\n        return true\n    end\n    local lena\
    \ = #a\n    local lenb = #b\n    if lena == lenb then\n        return false\n\
    \    end\n    local mid = (lena + lenb) / 2\n    while true do\n        local\
    \ a = string.sub(a,mid,mid + 1)\n        local b = string.sub(b,mid,mid + 1)\n\
    \        if helper(a) == true and helper(b) == true then\n            return true\n\
    \        end\n        if string.len(a) < 2 then\n            lena = lena - 1\n\
    \        elseif string.len(a) > 2 then\n            lena = lena + 1\n        else\n\
    \            lena = lena\n            break\n        end\n        if string.len(b)\
    \ < 2 then\n            lenb = lenb - 1\n        elseif string.len(b) > 2 then\n\
    \            lenb = lenb + 1\n        else\n            lenb = lenb\n        \
    \    break\n        end\n        if lena == lenb then\n            break\n   \
    \     end\n        mid = (lena + lenb) / 2\n    end\n    return false\nend", " \
    \   for i = 1,#a do\n        local c = a[i]\n        if #b == 0 then return true\
    \ end\n        for j = 1,#b do\n            if c == b[j] then\n              \
    \  if i+1 >= #a or b[j+1] == \"\" then return true end\n                local\
    \ x = a[i+1], a[i+2] = a[i+2], a[i]\n                return cycpattern_check(x,\
    \ b[j+1])\n            end\n        end\n    end\n    return false\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>", "  for i=1, #a do\n    local pattern = a:sub(i,\
    \ i)\n    local rotation = a:sub(i+1, i+2)\n    for j=1, #b do\n      local pattern2\
    \ = b:sub(j, j)\n      local rotation2 = b:sub(j+1, j+2)\n      if pattern ==\
    \ pattern2 and rotation == rotation2 then\n        return true\n      end\n  \
    \  end\n  end\n  return false\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,pattern-matching,lua\
    \ dscore=1 |>\n<code>", "  return a:sub(1, #a) + b == b\nend", "  for i = 0, #b-1\
    \ do\n    if a:find(b[i]) then\n      return true\n    end\n  end\n  return false\n\
    end", "  -- cycpattern_check(\"abcd\",\"abd\") => False\n  if a:find(b) ~= nil\
    \ then\n    return true\n  end\n  -- cycpattern_check(\"hello\",\"ell\") => True\n\
    \  -- cycpattern_check(\"whassup\",\"psus\") => False\n  -- cycpattern_check(\"\
    abab\",\"baa\") => True\n  -- cycpattern_check(\"efef\",\"eeff\") => False\n \
    \ -- cycpattern_check(\"himenss\",\"simen\") => True\n  if a:find(b):gsub(b, \"\
    ()\") ~= nil then\n    return true\n  end\n  return false\nend", "  local function\
    \ match(w, pattern)\n    if pattern and w and pattern ~= \"\" then\n      pattern\
    \ = \"[\" .. pattern .. \"]\"\n      if w ~= pattern then\n        return false\n\
    \      else\n        return match(w:sub(1,w:len()), pattern)\n      end\n    else\n\
    \      return true\n    end\n  end\n  return match(a, b) and match(b, a)\nend",
  "   local n = 0\n   for i=1,#a do\n      if a[i] == b[n] then\n         n = n+1\n\
    \      elseif a[i] ~= b[n] then\n         return false\n      end\n   end\n  \
    \ return true\nend\n</code>\n<|/ a tags=algorithm,lua |>\n<| c |>\n`if b[#b]==b[#b]\
    \ then return false end`\n<|/ c |>\n<| a |>\nYour solution is correct but slow.\
    \ There are a lot of things wrong in your code. Try to fix the mistakes one by\
    \ one.\n1. Avoid calling table.unpack if you can. \ntable.unpack is called 3 times\
    \ in your code: ", "    local substring_test\n    local rotations_test", "   \
    \ -- Base Case -- If string is empty, return true\n    if #a < 1 then\n      \
    \  return true\n    end\n    -- Base Case -- If last character doesn't match,\
    \ return false\n    if #b == 1 then\n        return false\n    end\n    -- If\
    \ last character matches then check first character\n    if a[1] == b[1] then\n\
    \        return cycpattern_check(a[#a], b)\n    else\n        -- For each character\
    \ in string b, try a substring in a\n        for i = 1, #b do\n            local\
    \ substr = a..b[i]\n            -- Return true if substr exists within a\n   \
    \         if substr:find('/') then\n                return true\n            end\n\
    \        end\n    end\nend\n</code>\n<|/ a |>\n<| a tags=lua-patterns,lua,string\
    \ |>\nI've found a pretty fast solution to this problem.\n<code>", "    local\
    \ result = {}\n    for i = 1, #b do\n        result[string.find(a, b[i], 1, true)]\
    \ = true\n    end\n    return #result == #b\nend\n</code>\n<|/ a |>\n<| c |>\n\
    If `#b` is large then the `string.find` will be slow. Perhaps consider using `strstr`.\n\
    <|/ c |>\n<| a tags=string,lua dscore=3 |>\nThe naive approach is to create a\
    \ string of all possible rotations of your initial word then check if the 2nd\
    \ string is a substring of those rotations.\nFor example, using \"abcd\" as the\
    \ input word and \"abd\" as the second word:\n<code>\n\"abcd\" has 3 rotations\n\
    \"abd\" has 2 rotations\n\"bcd\" has 1 rotations\n</code>\nSo, if we want to check\
    \ if \"abd\" is a substring of any of those 3 rotations, we will have to check\
    \ if the 2nd word is a substring of \"abcd\" or \"bcd\" or \"cd\" etc.\nIf the\
    \ 2nd word is \"abd\", then we'll have to check if \"abd\" is a substring of \"\
    abcd\" or \"bcd\" or \"cd\" etc.\nIf the 2nd word is \"bcd\", then we'll have\
    \ to check if \"abd\" is a substring of \"abcd\" or \"bcd\" or \"cd\" etc.\nIf\
    \ the 2nd word is \"cd\", then we'll have to check if \"abd\" is a substring of\
    \ \"abcd\" or \"bcd\" or \"cd\" etc.\nThe code could look like this:\n<code>",
  "  local t = {}\n  local pat1 = \"\"\n  local pat2 = \"\"\n  local pat3 = \"\"\n\
    \  local pat4 = \"\"\n  local pat5 = \"\"\n  local pat6 = \"\"\n  for word in\
    \ a:gmatch(\"(.-)\") do\n    t[#t + 1] = word\n  end\n  for word in b:gmatch(\"\
    (.-)\") do\n    t[#t + 1] = word\n  end\n  local n = #t\n  for i = 1, n do\n \
    \   if t[i] == \"a\" then\n      pat1 = pat1 .. t[i]\n    elseif t[i] == \"b\"\
    \ then\n      pat2 = pat2 .. t[i]\n    elseif t[i] == \"c\" then\n      pat3 =\
    \ pat3 .. t[i]\n    elseif t[i] == \"d\" then\n      pat4 = pat4 .. t[i]\n   \
    \ elseif t[i] == \"e\" then\n      pat5 = pat5 .. t[i]\n    elseif t[i] == \"\
    f\" then\n      pat6 = pat6 .. t[i]\n    end\n  end\n  if pat1 == pat2 then\n\
    \    return pat1 == \"ab\"\n  end\n  if pat1 == pat3 then\n    return pat1 ==\
    \ \"ab\"\n  end\n  if pat1 == pat4 then\n    return pat1 == \"ab\"\n  end\n  if\
    \ pat1 == pat5 then\n    return pat1 == \"ab\"\n  end\n  if pat1 == pat6 then\n\
    \    return pat1 == \"ab\"\n  end\n  if pat2 == pat3 then\n    return pat2 ==\
    \ \"ba\"\n  end\n  if pat2 == pat4 then\n    return pat2 == \"ba\"\n  end\n  if\
    \ pat2 == pat5 then\n    return pat2 == \"ba\"\n  end\n  if pat2 == pat6 then\n\
    \    return pat2 == \"ba\"\n  end\n  if pat3 == pat4 then\n    return pat3 ==\
    \ \"ab\"\n  end\n  if pat3 == pat5 then\n    return pat3 == \"ab\"\n  end\n  if\
    \ pat3 == pat6 then\n    return pat3 == \"ab\"\n  end\n  if pat4 == pat5 then\n\
    \    return pat4 == \"ba\"\n  end\n  if pat4 == pat6 then\n    return pat4 ==\
    \ \"ba\"\n  end\n  if pat5 == pat6 then\n    return pat5 == \"ba\"\n  end\n  return\
    \ false\nend", "  -- Your code here\n  if a == nil or b == nil then\n    return\
    \ false\n  end\n  return a == \"*\" or\n    b ~= a or\n    (a == \"*\" and (b\
    \ == \"*\" or b == \"*\" or b == b[1:end]))\nend", "    local blen = #b\n    for\
    \ _, c in ipairs(a) do\n        local tb = string.sub(b, 0, math.min(#b, c + 1))\n\
    \        local tr = string.sub(b, c + 1, #b)\n        if tb == tr or tb == string.sub(tr,\
    \ 0, math.min(#tr, c + 1)) then\n            return true\n        end\n    end\n\
    \    return false\nend", "  return a:find(b) or \n         b:find(a) or \n   \
    \      a:find(b, 1, true) or \n         b:find(a, 1, true)\nend", "  --print(string.format(\"\
    Matching pattern %s to %s\", a, b))\n  if a:sub(1, #a)==b then\n    return true\n\
    \  else\n    for i=1,#a do\n      if a[i]:sub(1, #a[i])~=b[i]:sub(1, #b[i]) then\n\
    \        return false\n      end\n    end\n    return true\n  end\nend", "   \
    \ local words = a:gsub(\"[\\W+]\", \" \")\n    local words_length\n    local words\
    \ = words:gsub(\"\\W+\", \" \")\n    words_length = words:gsub(\"^.-\", \"\"):gsub(\"\
    [^ ]+\", \"\")\n    words_length = words_length:gsub(\"^\", \"\"):gsub(\"[^ ]+\"\
    , \"\")\n    words_length = words_length + 1\n    local result = {}\n    for i=1,\
    \ words_length do\n        table.insert(result, words[(i-1)..i-1:len(words)])\n\
    \    end\n    if a~=b or b == \"\" then\n        return false\n    else\n    \
    \    local result2\n        result2 = result:join(\" \")\n        for _, v in\
    \ ipairs(result) do\n            if v~=b or b == \"\" then\n                return\
    \ false\n            end\n        end\n        return true\n    end\nend", " \
    \  return b == a:gsub(\"(.)\"..a..\"(.)\", function(c)\n      return c:reverse():sub(1,c):reverse():sub(1,c):reverse()\n\
    \   end)\nend", "   -- Check for string patterns\n   if a ~= nil and b ~= nil\
    \ then\n      if a ~= nil then\n         for w in a:gmatch(\"%w+\") do\n     \
    \       -- Check for substrings\n            if b ~= nil then\n              \
    \ if b:sub(1,1) ~= w then\n                  return false\n               end\n\
    \               -- Check for rotation\n               for i = 1, #w do\n     \
    \             if b:sub(i, i) ~= w then\n                     return false\n  \
    \                end\n               end\n            else\n               return\
    \ false\n            end\n         end\n      else\n         return false\n  \
    \    end\n   else\n      return false\n   end\n   return true\nend", "   -- Create\
    \ a string of the two strings separated by single spaces --\n   local a1 = string.rep(a,\"\
    \ \",#a+1)\n   local b1 = string.rep(b,\" \",#b+1)\n   -- Check that the two strings\
    \ are the same length to determine if they are \n   -- substrings of each other\
    \ --\n   if (#a1 == #b) and (#a1 > 0) then\n      return true\n   else\n     \
    \ return false\n   end\nend", "    local t = {}\n    for i = 1, #a do table.insert(t,\
    \ string.sub(a,i,i)) end\n    for i = 1, #b do table.insert(t, string.sub(b,i,i))\
    \ end\n    for i = #t, 1 do\n        if string.find(string.sub(a,1,i), string.sub(t,1,i))\
    \ then\n            return false\n        end\n    end\n    return true\nend",
  "  local bindex = a:find(b)\n  if bindex == nil then\n    return false\n  elseif\
    \ bindex == 0 then\n    return true\n  else\n    local aindex = a:sub(1, bindex-1)\n\
    \    if bindex:sub(end) ~= aindex:sub(2) then\n      return false\n    else\n\
    \      return true\n    end\n  end\nend", "\tlocal s = \"\"\n\tfor w in a:gmatch(\"\
    (.-)\") do\n\t\ts = s .. w:sub(1, 2)\n\tend\n\tlocal t = \"\"\n\tfor w in a:gmatch(\"\
    (.-)\") do\n\t\tt = t .. w:sub(2, 1)\n\tend\n\t\n\treturn (cycpattern_check(cycpattern_check(a,\
    \ b), t) or #a < #b) and (#s == #t) or (#t == #s) or (#s == #t) and #s == #t\n\
    end", "    return a:sub(1, #a) == b:sub(1, #b) and #b > 0 and #a > 0\nend", " \
    \   local function check(n, m)\n        if n ~= 0 then\n            if a[m] ==\
    \ nil then return false end\n            if n >= 0 then\n                local\
    \ i = m+n\n                while i ~= m do\n                    if a[m] == nil\
    \ then return false end\n                    if a[i] == nil then return false\
    \ end\n                    if a[m] == a[i] then return false end\n           \
    \         i = i+1\n                end\n            else\n                while\
    \ m <= n do\n                    if a[m] == nil then return false end\n      \
    \              m = m+1\n                end\n            end\n        end\n  \
    \      return true\n    end\n    return check(#a, #b) and check(-1, #a) and check(0,\
    \ #a) and check(1, #a) and check(-1, #b) and check(0, #b) and check(1, #b)\nend",
  "\tlocal a_index, a_len = string:len(a)\n\tlocal b_index, b_len = string:len(b)\n\
    \tif a_index < 0 or b_index < 0 then\n\t\treturn false\n\tend\n\tif a_len < b_index\
    \ or b_len < a_index then\n\t\treturn false\n\tend\n\tlocal min_len = b_len +\
    \ a_index\n\tlocal i = a_index\n\tlocal j = 0\n\twhile i < a_len do\n\t\tif j\
    \ < b_index then\n\t\t\tif b:sub(i,j) == a:sub(i, j) then\n\t\t\t\ti = i + j\n\
    \t\t\t\tj = b_index\n\t\t\telse\n\t\t\t\treturn false\n\t\t\tend\n\t\telse\n\t\
    \t\tif a:sub(i, j) == b:sub(i - b_index, i) then\n\t\t\t\ti = i + j\n\t\t\telse\n\
    \t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\tif j < b_index then\n\t\treturn\
    \ false\n\telseif i < b_len then\n\t\treturn true\n\telse\n\t\treturn false\n\t\
    end\nend", "    for i,w in pairs(a) do\n        for j,w in pairs(b) do\n     \
    \       if w ~= nil then\n                local sub = w:find(w)\n            \
    \    if sub > 0 then\n                    if sub < #w then\n                 \
    \       local s = w:sub(1,sub-1)\n                        local t = w[sub+1]\n\
    \                        if #w > sub + 1 then\n                            s =\
    \ s .. t\n                        else\n                            s = s .. t\n\
    \                            s = s .. w[sub]\n                        end\n  \
    \                      if s == w then\n                            return true\n\
    \                        end\n                    end\n                end\n \
    \           end\n        end\n    end\n    return false\nend", "  -- assert(b)\n\
    \  local i1, j1 = a:findfirst(\"^%s$\")\n  local i2, j2 = b:findfirst(\"^%s$\"\
    )\n  local len = j2 - j1\n  if len == 0 then\n    return false\n  elseif len ==\
    \ 1 then\n    return true\n  else\n    if i2 ~= j1 then\n      b = b:sub(1, len)\n\
    \      a = a:sub(1, i1)\n    else\n      b = b:sub(1, len)\n    end\n    local\
    \ i = a\n    local j = b\n    local a2 = i\n    local b2 = j\n    local x = 0\n\
    \    local y = 1\n    repeat\n      i = i:sub(1, 1)\n      j = j:sub(1, 1)\n \
    \     x = x+1\n      if a ~= a2 then\n        y = y+1;\n        if y > i1 then\n\
    \          x = 0\n          y = 1\n        end\n        a2 = a\n      else\n \
    \       if a ~= b2 then\n          y = y+1;\n          a2 = a\n        else\n\
    \          b = b\n        end\n      end\n    until i > j\n    if x ~= len then\n\
    \      return false\n    else\n      return true\n    end\n  end\nend", "  local\
    \ lena = #a\n  local lenb = #b\n  if lena < lenb then\n    return false\n  end\n\
    \  for i = 1, lena do\n    if string.sub(a, b - i, lenb) ~= string.sub(a, b, lenb\
    \ - i) then\n      return false\n    end\n  end\n  return true\nend", "  --assert(type(a)\
    \ == \"string\" and type(b) == \"string\")\n  if a==nil or b==nil then\n    return\
    \ nil\n  end", "  -- Create a table containing all characters in the pattern\n\
    \  local t = {}\n  for i = 1, #a do\n    t[a[i]] = true\n  end\n  for i = 1, #b\
    \ do\n    t[b[i]] = true\n  end\n  -- Iterate over all possible rotations\n  for\
    \ i = 1, #a do\n    for j = 1, #b do\n      if a[i] == b[j] then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  a = string.gsub(a,\"\
    [%c]+\",\"\") --removes any characters\n  b = string.gsub(b,\"[%c]+\",\"\")\n\
    \  if a == '' and b == '' then return true end\n  if a == '' and b ~= '' or b\
    \ ~= '' and a~=b then return true end\n  if a ~= '' and b == '' then return false\
    \ end\n  if a ~= '' and b ~= '' or a~=b then return false end\n  a = string.gsub(a,\"\
    \",\"a\")\n  b = string.gsub(b,\"\",\"b\")\n  a = string.gsub(a,\"\",\"b\")\n\
    \  b = string.gsub(b,\"\",\"a\")\n  a = string.gsub(a,\"\",\"b\")\n  b = string.gsub(b,\"\
    \",\"a\")\n  a = string.gsub(a,\"b\",\"a\")\n  b = string.gsub(b,\"b\",\"a\")\n\
    \  a = string.gsub(a,\"a\",\"b\")\n  b = string.gsub(b,\"a\",\"b\")\n  a = string.gsub(a,\"\
    b\",\"a\")\n  b = string.gsub(b,\"b\",\"a\")\n  a = string.gsub(a,\"a\",\"b\"\
    )\n  b = string.gsub(b,\"a\",\"b\")\n  a = string.gsub(a,\"b\",\"a\")\n  b = string.gsub(b,\"\
    b\",\"a\")\n  a = string.gsub(a,\"a\",\"b\")\n  b = string.gsub(b,\"a\",\"b\"\
    )\n  a = string.gsub(a,\"b\",\"a\")\n  b = string.gsub(b,\"b\",\"a\")\n  a = string.gsub(a,\"\
    a\",\"b\")\n  b = string.gsub(b,\"a\",\"b\")\n  a = string.gsub(a,\"b\",\"a\"\
    )\n  b = string.gsub(b,\"b\",\"a\")\n  a = string.gsub(a,\"a\",\"b\")\n  b = string.gsub(b,\"\
    a\",\"b\")\n  a = string.gsub(a,\"b\",\"a\")\n  b = string.gsub(b,\"b\",\"a\"\
    )\n  a = string.gsub(a,\"a\",\"b\")\n  b = string.gsub(b,\"a\",\"b\")\n  a = string.gsub(a,\"\
    b\",\"a\")\n  b = string.gsub(b,\"b\",\"a\")\n  a = string.gsub(a,\"a\",\"b\"\
    )\n  b = string.gsub(b,\"a\",\"b\")\n  a = string.gsub(a,\"b\",\"a\")\n  b = string.gsub(b,\"\
    b\",\"a\")\n  a = string.gsub(a,\"a\",\"b\")\n  b = string.gsub(b,\"a\",\"b\")",
  "   if #b > #a then\n      return false\n   end\n   local startpos = 0\n   local\
    \ endpos = 0\n   local newstring\n   while startpos < #b do\n      local sub =\
    \ string.sub(b, 1, #b - startpos)\n      if a[startpos] ~= sub and startpos +\
    \ #sub < #a then\n         endpos = startpos + #sub\n         newstring = string.sub(a,\
    \ b, startpos, endpos)\n         break\n      else\n         startpos = startpos\
    \ + 1\n      end\n   end\n   return #a == #newstring and newstring ~= \"\"\nend",
  "  return #b > 0 and #a > 0 and #a == #b and #b ~= 0 and\n    ((b[1]==#a) or (a[#a]\
    \ ~= b[1]) or ((a[1]==#b) or (b[#b] ~= a[1])))\nend", "  return a and b:sub(1,\
    \ #a):sub(1, #a)==a\nend", "   -- The algorithm to check if 2 strings is a substring\
    \ of each other is as follows:\n   -- 1) Find the longest common prefix of strings\
    \ A and B\n   -- 2) If strings A and B have a common prefix of length 3 or less,\
    \ return true\n   -- 3) if strings have a common prefix of length 4 or more but\
    \ are not equal, return false\n   --    otherwise if strings have the same common\
    \ prefix but are not equal return true\n   -- In other words, we check if the\
    \ first 3 characters of A are present in B and if so return true.\n   -- The longest\
    \ common prefix algorithm is as follows.\n   -- 1. Find the length of common prefix\
    \ of strings A and B.\n   -- 2. Set the current position of current character\
    \ of A to 1 and current position of current character of B to 1.\n   --    Iterate\
    \ until A's current position is at or past the length of common prefix and B's\
    \ current position is at or past the length of common prefix.\n   -- 3. If current\
    \ character of A is different than current character of B, return true.\n   --\
    \    Otherwise if current character of A and current character of B are same return\
    \ false.\n   -- 4. Continue this process until one string runs out of characters.\n\
    \   --    This process can be broken down into 3 steps:\n   --    1) Find the\
    \ length of common prefix of strings A and B.\n   --    2) Set the current position\
    \ of A to current length of common prefix plus 1 and B to current length of common\
    \ prefix plus 1.\n   --    3) Iterate until A's current position is at or past\
    \ the length of common prefix and B's current position is at or past the length\
    \ of common prefix.", "    return #a > 0 and #b > 0 and\n    (#b > 0 and #a >\
    \ 0 and a[1] == \"s\" or #b == 1 or #a == 1) and\n    (a[1] < b[1] or #a == #b)\
    \ and #a%#b == 0\nend\n</code>\n<|/ a tags=algorithm,pattern-matching,lua,pattern-matching\
    \ |>\n<| c |>\nThank you for your answer. However, this is not exactly what I\
    \ was looking for. I'm going to edit the question to make my question a bit clearer.\n\
    <|/ c |>\n<| c |>\nNo worries. I guess I misinterpreted your question earlier.\
    \ This would be a great opportunity to familiarise yourself with the Lua pattern\
    \ matching features.\n<|/ c |>\n<| a dscore=0 tags=algorithm,pattern-matching,lua,pattern-matching\
    \ |>\n<code>", "  local function test(word, i)\n    local b1 = string.sub(b, 1,\
    \ i)\n    local b2 = string.sub(b, i + 1, 1)\n    for j = 1, #word do\n      local\
    \ w1 = string.sub(word, j, j)\n      local w2 = string.sub(word, j + 1, j + 1)\n\
    \      if string.find(b1, w1) then\n        return true\n      end\n      if string.find(b2,\
    \ w2) then\n        return true\n      end\n    end\n    return false\n  end\n\
    \  for i = 1, #a do\n    if test(a, i) then\n      if test(b, i - 1) then\n  \
    \      return true\n      end\n    end\n  end\n  return false\nend", "  local\
    \ word1, word2 = string.match(a, \"(%S+)%s*\") or \"\", string.match(b, \"(%S+)%s*\"\
    ) or \"\"\n  if not (word1 or word2) then return false end\n  local function rotated_word(c)\n\
    \    local rotation = string.match(c, \"(%S+)\")\n    rotation = rotation and\
    \ rotation ~= \"\" and rotation or c\n    rotation = string.sub(rotation, 1, string.len(rotation)\
    \ - 1) or rotation\n    rotation = string.sub(rotation, 1, string.len(rotation)\
    \ - 1) or rotation\n    return string.rep(\"a\", string.len(rotation) + 1)..rotation\n\
    \  end\n  local function is_match(word, n)\n    local t = {}\n    local s = string.match(word,\
    \ \"([^\"..string.char(160,160,160,160,160)..\"]+)\")\n    local subs = string.match(word,\
    \ \"([^\"..string.char(160,160,160,160,160)..\"]*)\")\n    local last\n    if\
    \ s then\n      local pos = 1\n      local i = 1\n      while true do\n      \
    \  if not last then\n          last = {pos = pos, end = pos + string.len(s), val\
    \ = s}\n          i = i + 1\n        elseif subs then\n          if last ~= subs\
    \ then\n            if last.pos ~= subs.pos then\n              table.insert(t,\
    \ {pos = last.pos + string.len(s), val = last.val})\n              table.insert(t,\
    \ {pos = subs.pos, val = subs.val, end = subs.end})\n              table.insert(t,\
    \ last)\n              break\n            end\n          end\n        end\n  \
    \      pos = string.sub(word, n + 1, pos) + n + 1\n        last = {}\n       \
    \ last = subs\n        subs = s\n        s = nil\n      end\n      local n = 1\n\
    \      for _, n in ipairs(t) do\n        local _, v = unpack(n)\n        if string.find(a,\
    \ v) ~= nil then\n          return true\n        end\n      end\n    end\n  end\n\
    \  if word1 and word2 then\n    local len = string.len(word1)\n    if string.len(word1)\
    \ < string.len(word2) then\n      return false\n    end\n    local n = len\n \
    \   local t\n    while true do\n      local v = word1:sub(1, n)\n      local rv\
    \ = rotated_word(v)\n      if rv:find(string.sub(rv, 1, -1)) ~= nil then\n   \
    \     local t = {rv:find(string.sub(rv, 1, -1)), rv:find(string.sub(rv, -1, 1))}\n\
    \        if t and is_match(word2, t[1]) then\n          return ", "    if a==nil\
    \ or b==nil then\n        print(\"Error : cycpattern_check parameter can not be\
    \ nil!\")\n        return false\n    end\n    local i = 1\n    while i <= #a do\n\
    \        if a[i]:find(b) ~= nil then\n            return true\n        end\n \
    \       i = i+1\n    end\n    return false\nend", "  if a:sub(1, #a) ~= b then\n\
    \    return false\n  end\n  return true\nend", "  --local function check_string(a,\
    \ b)\n  -- this could be done more concisely, but this version should work\n \
    \ if a==nil or b==nil then\n    return false\n  end\n  \n  local i,j=1,1\n  local\
    \ x,y=1,1\n  local n\n  local lena=#a\n  local lenb=#b\n  \n  while i<lena and\
    \ j<lenb do\n    n=a[i]\n    while x<=y do\n      if string.sub(lena, x-1, x)==n\
    \ then\n        i=i+1\n      else\n        return false\n      end\n      x=x+1\n\
    \    end\n    while y<=x do\n      if string.sub(lenb, y-1, y)==n then\n     \
    \   j=j+1\n      else\n        return false\n      end\n      y=y+1\n    end\n\
    \    i=i+1\n    j=j+1\n  end\n  \n  return true\nend", "  local first_word = a:match('(.-)%w+')\
    \ -- abc => abc\n  local second_word = b:match('(.-)%w+') -- abd => abd\n  for\
    \ i = 2, #first_word do\n    local substring_length = #first_word-i\n    if substring_length\
    \ == 0 then\n      -- no rotations\n      return false\n    end\n    local substring_sub1\
    \ = first_word:sub(1,#first_word-i)\n    local substring_sub2 = first_word:sub(#first_word-i,\
    \ #first_word)\n    local substring_sub3 = second_word:sub(1,#second_word-i)\n\
    \    local substring_sub4 = second_word:sub(#second_word-i, #second_word)\n  \
    \  if substring_sub1 == substring_sub2 then\n      return false\n    end\n   \
    \ if substring_sub2 == substring_sub3 then\n      return false\n    end\n    if\
    \ substring_sub3 == substring_sub4 then\n      return false\n    end\n  end\n\
    \  return true\nend", "  -- return true only if both words are the same length\n\
    \  if #a ~= #b then return false end\n  -- return true only if there is any rotation\
    \ in the first word that is in the second word\n  local function hasSubstring(word,\
    \ pattern)\n    local rotation = string.match(word, pattern)\n    return rotation\
    \ ~= nil and rotation ~= \"\"\n  end\n  return #b == 0 and #a == 0 or hasSubstring(a,\
    \ a) or hasSubstring(b, b)\nend", "  -- check length of strings\n  if #a ~= #b\
    \ then\n    return false\n  end", "\tlocal substring = string.sub(a,1,#b-1)\n\t\
    local rotation = string.sub(a,#b+1)\n\tlocal i = 1\n\tfor w in string.gmatch(b,\
    \ \"%S+\") do\n\t\tif(i==#rotation) then return false end\n\t\tlocal rotated_substring\
    \ = string.sub(rotation, i, i)\n\t\tif(rotated_substring == substring) then\n\t\
    \t\ti = i+1\n\t\telse\n\t\t\ti = i-1\n\t\t\tbreak\n\t\tend\n\tend\n\tif(i==#rotation)\
    \ then return false end\n\treturn true\nend", "\t-- Sort a so that longer substrings\
    \ are first and shorter ones last.\n\t-- This means for \"abab\" and \"baa\" the\
    \ substrings are \"ab\" and \"ba\".\n\t-- This means \"baa\" is a substring of\
    \ the longer substrings \"ab\" and \"ba\".\n\ta = a:gsub(\"^(.)(.)$\",\"%2\")\
    \ -- Remove any characters before the first letter.\n\ta = a:gsub(\"^(.)([^a-zA-Z].*)$\"\
    ,\"%2\") -- Remove any characters before the second letter.\n\ta = a:gsub(\"(.)([^a-zA-Z].*)$\"\
    ,\"%2\") -- Remove any characters after the first letter.\n\ta = a:gsub(\"(.)(.)$\"\
    ,\"%2\") -- Remove any characters after the first letter.", "    local pat, a,\
    \ b = string.find(a, \"%w\"), a, b\n    for i=1, #pat do\n        if pat[i] ==\
    \ b[1] then return true end\n    end\n    return false\nend", "    -- The words\
    \ are split into chars arrays. First word has less chars than the second one\n\
    \    local chars1 = string.gsub(a, \"[^a-zA-Z]\", \"\")\n    local chars2 = string.gsub(b,\
    \ \"[^a-zA-Z]\", \"\")", "\t-- We are looking for any possible match of a in the\
    \ b string\n\t-- (a rotation of b will match b as a rotation of a)\n\t-- We only\
    \ need to check substrings for matches (no rotations)\n\t-- (we can have \"hello\"\
    \ match \"ello\" but we only need to check for substrings)\n\t-- This also means\
    \ we can short-circuit the loop early if the first letter is found\n\tlocal function\
    \ findMatch(a, b)\n\t\tlocal pos\n\t\tlocal count = 0\n\t\tlocal found = false\n\
    \t\tfor pos = 1, #a do\n\t\t\t-- if we haven't found the letter in b\n\t\t\tif\
    \ not found and #b > pos then\n\t\t\t\t-- try to see if we can skip a character\n\
    \t\t\t\t-- if we haven't found the letter in b\n\t\t\t\tif not found and pos <\
    \ #b then\n\t\t\t\t\t-- skip a character\n\t\t\t\t\tcount = count + 1\n\t\t\t\t\
    else\n\t\t\t\t\t-- we found the letter in b\n\t\t\t\t\t-- make sure we skip the\
    \ character we skipped over\n\t\t\t\t\tcount = count - 1\n\t\t\t\t\t-- we found\
    \ the letter in b, so we are done\n\t\t\t\t\tfound = true\n\t\t\t\tend\n\t\t\t\
    end\n\t\t\t-- if we found the letter in b, return true\n\t\t\tif found and b[pos]\
    \ == a[count] then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\treturn false\n\
    \tend\n\t-- if the first letter is found\n\tif #a == 1 and findMatch(a, b) then\n\
    \t\treturn true\n\tend\n\t-- check all letters in b against the letters\n\tlocal\
    \ function checkLetter(b)\n\t\tlocal found = false\n\t\tlocal count = 0\n\t\t\
    for pos = 1, #b do\n\t\t\t-- if we haven't found the letter in b\n\t\t\tif not\
    \ found and b[pos] == a[count] then\n\t\t\t\t-- increase the count for that letter\n\
    \t\t\t\tcount = count + 1\n\t\t\t\t-- if we found the letter in b\n\t\t\t\t--\
    \ check to see if we can skip a character\n\t\t\t\t-- if we haven't found the\
    \ letter in b\n\t\t\t\tif not found and pos < #b then\n\t\t\t\t\t-- skip a character\n\
    \t\t\t\t\tcount = count + 1\n\t\t\t\telse\n\t\t\t\t\t-- we found the letter in\
    \ b\n\t\t\t\t\t-- make sure we skip the character we skipped over\n\t\t\t\t\t\
    count = count - 1\n\t\t\t\t\t-- we found the letter in b, so we are done\n\t\t\
    \t\t\tfound = true\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- if we found the letter in\
    \ b, return true\n\t\t\tif found and b[pos] == a[count] then\n\t\t\t\treturn true\n\
    \t\t\tend\n\t\tend\n\t\treturn false\n\tend\n\t-- if we have letters to check,\
    \ check each one against the letters in a\n\tif #b > 0 ", "  --assert(type(a)\
    \ == 'string' and type(b) == 'string')\n  local match\n  for _, word in pairs(a)\
    \ do\n    match = false\n    for _, subword in pairs(b) do\n      if string.find(word,\
    \ subword, true) then\n        match = true\n        break\n      end\n    end\n\
    \    if match then\n      return true\n    end\n  end\n  return false\nend", " \
    \   -- Write your code here\n    assert(type(a) == \"string\" and type(b) == \"\
    string\", \"Input parameters must be strings\")\n    assert(a ~= nil and b ~=\
    \ nil, \"Input parameters cannot be nil\")\n    assert(a ~= \"\" and b ~= \"\"\
    , \"Input parameters cannot be empty\")\n    return string.find(a, b) or string.find(b,\
    \ a) or string.find(a, b)\nend\n</code>\n<|/ a tags=string,lua |>\n<| a |>\nI\
    \ found a simple solution to this problem on another forum that does not require\
    \ string functions. Here it is\n<code>", "  local b = b .. \"\"\n  local n = #a\n\
    \  if n == 0 then\n    return true\n  end\n  if n == 1 then\n    return #b ==\
    \ 0 or b == a\n  end\n  local s = #a\n  local m = #b\n  for i = 1, n do\n    if\
    \ a[i] == b[1] then\n      s = s - 1\n      m = m - 1\n    elseif a[i] == b[m]\
    \ then\n      s = s - 1\n    else\n      return false\n    end\n  end\n  return\
    \ s == 0 and m == 0\nend", "    local blow = string.lower(b)\n    local alow =\
    \ string.lower(a)\n    if alow:len() < blow:len() then\n        for i = 1, alow:len()\
    \ do\n            if string.find(blow, alow:sub(i, i+1), 1, true) then\n     \
    \           return true\n            end\n        end\n    end\n    return false\n\
    end", "  local i = -1\n  local k = -1\n  local lena = #a\n  local lenb = #b\n\
    \  if lena > lenb then return false end\n  local j = 0\n  while i <= lena and\
    \ j <= lenb do\n    if string.sub(a, i, i+1) == string.sub(b, j, j+1) then\n \
    \     i = i + 1\n      k = k + 1\n    else\n      if k ~= 0 then\n        return\
    \ false\n      end\n      i = i + 1\n    end\n  end\n  if k == lenb then\n   \
    \ return true\n  end\n  return false\nend", "    local _, _, first, _, _ = a:find(b)\n\
    \    if not first then\n        return false\n    end\n    local _, _, second,\
    \ _, _ = a:find(b)\n    if not second then\n        return true\n    end\n   \
    \ return cycpattern_check(first[#first], second) or cycpattern_check(second[#second],\
    \ first)\nend\nreturn cycpattern_check\nend\nreturn check_rotation\nend\nreturn\
    \ check_pattern\nend\nreturn find\nend\nreturn sub\nend\nreturn starts_with\n\
    end\nreturn replace\nend\nreturn reverse\nend\nreturn upper\nend\nreturn contains\n\
    end\nreturn count\nend\nreturn replace\nend\nreturn substring\nend\nreturn sub\n\
    end\nreturn upper\nend\nreturn count\nend\nreturn replace\nend\nreturn reverse\n\
    end\nreturn substring\nend\nreturn end\nreturn count\nend\nreturn reverse\nend\n\
    return contains\nend\nreturn sub\nend\nreturn contains\nend\nreturn end\nreturn\
    \ substring\nend\nreturn replace\nend\nreturn end\nreturn reverse\nend\nreturn\
    \ sub\nend\nreturn contains\nend\nreturn substring\nend\nreturn replace\nend\n\
    return reverse\nend\nreturn substring\nend\nreturn replace\nend\nreturn count\n\
    end\nreturn sub\nend\nreturn contains\nend\nreturn substring\nend\nreturn replace\n\
    end\nreturn reverse\nend\nreturn substring\nend\nreturn replace\nend\nreturn count\n\
    end\nreturn sub\nend\nreturn contains\nend\nreturn substring\nend\nreturn replace\n\
    end\nreturn reverse\nend\nreturn substring\nend\nreturn replace\nend\nreturn reverse\n\
    end\nreturn substring\nend\nreturn replace\nend\nreturn count\nend\nreturn sub\n\
    end\nreturn contains\nend\nreturn substring\nend\nreturn replace\nend\nreturn\
    \ reverse\nend\nreturn substring\nend\nreturn replace\nend\nreturn reverse\nend\n\
    return substring\nend\nreturn replace\nend\nreturn reverse\nend\nreturn substring\n\
    end\nreturn replace\nend\nreturn reverse\nend\nreturn substring\nend\nreturn replace\n\
    end\nreturn reverse\nend\nreturn substring\nend\nreturn replace\nend\nreturn reverse\n\
    end\nreturn substring\nend\nreturn replace\nend\nreturn reverse\nend\nreturn substring\n\
    end\nreturn replace\nend\nreturn reverse\nend\nreturn substring\nend\nreturn replace\n\
    end\nreturn reverse\nend\nreturn substring\nend\nreturn replace\nend\nreturn reverse\n\
    end\n", "  return a~=\"-\" and b~=\"-\" and not a:sub(1,1) and b:sub(1,1) and\
    \ a:sub(1,1) <= #b and b:sub(1,1) <= #a \nend", "   assert(type(a) == \"string\"\
    \ and type(b) == \"string\")\n   if a:sub(1,1) ~= b[1]:sub(1,1) then\n      return\
    \ false\n   end\n   for i = 1, #b do\n      local found = false\n      for j =\
    \ 1, #a do\n         if a[j] == b[i] then\n            found = true\n        \
    \    break\n         end\n      end\n      if not found then\n         return\
    \ false\n      end\n   end\n   return true\nend", "   if a == nil then return\
    \ false end\n   if b == nil then return false end", "    local aWords = {}\n \
    \   for i = 1, #a do\n        table.insert(aWords, a[i])\n    end\n    local bWords\
    \ = {}\n    for i = 1, #b do\n        table.insert(bWords, b[i])\n    end\n  \
    \  local matches = { }\n    for i, word in ipairs(aWords) do\n        local j\
    \ = 1\n        while j + i < #bWords and bWords[i + j] == word do\n          \
    \  j = j + 1\n        end\n        table.insert(matches, word)\n    end\n    return\
    \ #matches > 0\nend", "    local s = \"\"\n    for i = 1, #a do\n        s = s\
    \ .. string.format(\"%s%c\", string.sub(a,i,i), string.sub(a,i+1,i+1))\n    end\n\
    \    return #b == 0 or #b == string.len(s) and string.find(b, s) >= 0\nend", " \
    \   local c = {}\n    for i = 1, #a do\n        table.insert(c, string.sub(a,i,i))\n\
    \    end\n    for i = 1, #b do\n        table.insert(c, string.sub(b,i,i))\n \
    \   end\n    local i = 1\n    while i <= #c do\n        if string.sub(c,i,i) ==\
    \ string.sub(b,i,i) then\n            return true\n        end\n        i = i+1\n\
    \    end\n    return false\nend", "    local s = b\n    for i = #a, 1, -1 do\n\
    \        local t = a\n        local c = 0\n        while #t > 0 do\n         \
    \   local c = c + 1\n            local t = t:sub(c, c+1)\n        end\n      \
    \  local r = #s\n        if r >= c then\n            local u = r - c\n       \
    \     for k = 1, c do\n                local s = s:sub(u+k, u+k+1)\n         \
    \   end\n        end\n    end\n    return #a == #b and s ~= nil\nend", "  local\
    \ a_len, b_len = (a:len() + 1):div(#b) + 1, (b:len() + 1):div(#a) + 1\n  local\
    \ a_str = \"\", #a\n  local b_str = \"\", #b\n  for i = 1, a_len do\n    a_str\
    \ = a_str .. string.rep(\"a\", #b)\n    b_str = b_str .. string.rep(\"b\", #a)\n\
    \  end\n  return a_str == b_str\nend", "    for i=1, #a do\n        for j=1, #b\
    \ do\n            local k = i - j\n            local l = i + j\n            if\
    \ k == 0 then\n                if a[i] ~= b[j] then\n                    return\
    \ false\n                end\n            else\n                if a[k] ~= b[j]\
    \ then\n                    return false\n                end\n            end\n\
    \        end\n    end\n    return true\nend", "   if a == nil then\n      return\
    \ false\n   end\n   if a == \"\" then\n      return true\n   end\n   local i =\
    \ 1;\n   while i <= #a do\n      if a[i] ~= b[i % #b] then\n         return false\n\
    \      end\n      i = i + 1\n   end\n   return true\nend", "    if a == nil then\n\
    \        return true\n    end", "   -- Initialize pattern\n   local pat = {}\n\
    \   for _, c in ipairs(a) do\n      pat[c] = true\n   end\n   for _, c in ipairs(b)\
    \ do\n      if pat[c] then\n         pat[c] = false\n      else\n         pat[c]\
    \ = true\n      end\n   end\n   \n   -- Initialize test case\n   local testcase\
    \ = {a}\n   \n   -- Test if pattern matches\n   while true do\n      -- Reset\
    \ testcase if pattern is still matching\n      local ret = true\n      local max\
    \ = 2^32-1\n      for c in pairs(pat) do\n         ret = ret and testcase[c]\n\
    \         if ret == true then\n            testcase[c] = true\n         else\n\
    \            testcase[c] = false\n         end\n         if ret == true then\n\
    \            break\n         end\n         if ret ~= true then\n            if\
    \ ret ~= false then\n               break\n            end\n         end\n   \
    \   end\n      -- No pattern matched and pattern no longer matches\n      if ret\
    \ == false then\n         return false\n      end\n      -- Reset the test case\n\
    \      testcase = {}\n      \n      -- Get next character\n      local c = table.unpack(table.gsub(string.gsub(a,'%c',\
    \ function()\n         return (max+1)%(max+2)\n      end), '.', string.char(max+1)),\
    \ 1)\n      -- Reset pattern if the character is encountered\n      if pat[c]\
    \ then\n         pat[c] = false\n      else\n         pat[c] = true\n      end\n\
    \   end\n   \n   -- No pattern match\n   return true\nend", "  local lenA=#a\n\
    \  local lenB=#b\n  -- a's and b's length must be equal\n  assert(lenA==lenB,\
    \ \"Lengths of both words must be equal\")\n  for i=1,lenA do\n    -- a's rotation\
    \ index\n    local idx=(i-1)%lenA\n    -- b's rotation index\n    local idxb=(i+lenB-1)%lenB\n\
    \    -- if a's rotated string matches b's rotation string at the corresponding\
    \ index\n    if a[idx] == b[idxb] then\n      return true\n    end\n  end\n  return\
    \ false\nend", "  local n = #a\n  if n == 0 then return false end\n  if n == 1\
    \ then return (a[1] == b) end\n  local ok = false\n  for i=1,n do\n    if a[i]\
    \ ~= b[(i+n-1)%#b] then\n      ok = true\n      break\n    end\n  end\n  return\
    \ ok\nend", "  if a == nil then return false end\n  if b == nil then return false\
    \ end", "  if b == nil then\n    return false\n  end\n  if a == b then\n    return\
    \ true\n  end\n  local pat_a = a:gsub(\"([\" .. b[#b] .. b[#b+1] .. b[#b+2] ..\
    \ b[#b+3] .. b[#b+4] .. b[#b+5] .. b[#b+6] .. b[#b+7] .. b[#b+8] .. b[#b+9] ..\
    \ b[#b+10] .. b[#b+11] .. b[#b+12] .. b[#b+13] .. b[#b+14] .. b[#b+15] .. b[#b+16]\
    \ .. b[#b+17] .. b[#b+18] .. b[#b+19] .. b[#b+20] .. b[#b+21] .. b[#b+22] .. b[#b+23]\
    \ .. b[#b+24] .. b[#b+25] .. b[#b+26] .. b[#b+27] .. b[#b+28] .. b[#b+29] .. b[#b+30]\
    \ .. b[#b+31] .. b[#b+32] .. b[#b+33] .. b[#b+34] .. b[#b+35] .. b[#b+36] .. b[#b+37]\
    \ .. b[#b+38] .. b[#b+39] .. b[#b+40] .. b[#b+41] .. b[#b+42] .. b[#b+43] .. b[#b+44]\
    \ .. b[#b+45] .. b[#b+46] .. b[#b+47] .. b[#b+48] .. b[#b+49] .. b[#b+50] .. b[#b+51]\
    \ .. b[#b+52] .. b[#b+53] .. b[#b+54] .. b[#b+55] .. b[#b+56] .. b[#b+57] .. b[#b+58]\
    \ .. b[#b+59] .. ", "    return a ~= b or\n           (a:sub(1,1) and a:sub(#a,#a)\
    \ ~= b)\nend", "  a = a:lower()\n  b = b:lower()\n  for i = 1, #a do\n    if a[i]\
    \ ~= b[i] then\n      return false\n    end\n  end\n  return true\nend", "  a\
    \ = a:lower()\n  b = b:lower()\n  for i = 1, #a do -- O(n^2)\n    for j = 1, #b\
    \ do\n      if a[i] == b[j] or (a[i] == '.' and a[i+1:i+#b] == b) then -- O(1)\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "   if\
    \ b == a then return true end\n   for i = 1,#b do\n      local c = string.sub(b,i,i)\n\
    \      if string.find(a,c) then\n         return true\n      end\n   end\n   return\
    \ false\nend", "  assert(type(a) == \"string\" and type(b) == \"string\")\n  local\
    \ first_len = #a\n  local second_len = #b\n  -- if the first word is empty or\
    \ if the second word is empty return true\n  if first_len == 0 or second_len ==\
    \ 0 then\n    return true\n  end", "  -- write your code here\n  \n  return false\n\
    end", "    local w = {}\n    for w in a:gmatch(\"%w+\") do end\n    for w in b:gmatch(\"\
    %w+\") do end\n    return a:sub(1, #w)~=w or\n           a:sub(-1, #w)~=w or\n\
    \           b:sub(1, #w)~=w or\n           b:sub(-1, #w)~=w\nend", "    if type(b)\
    \ ~= \"string\" then\n        return false\n    end\n    local words = string.gmatch(a,\
    \ \"([^ ]+)\")\n    for i = 1, #words do\n        if string.find(b, words[i])\
    \ then\n            return true\n        end\n    end\n    return false\nend",
  "   -- remove trailing spaces\n   a = string.gsub(a, \"[\\n\\r]\", \"\")\n   b =\
    \ string.gsub(b, \"[\\n\\r]\", \"\")\n   -- remove leading spaces\n   a = string.gsub(a,\
    \ \"[\\n\\r]\", \"\")\n   b = string.gsub(b, \"[\\n\\r]\", \"\")\n   -- get common\
    \ prefix\n   a = a:gsub(\"%a+\", \"\")\n   b = b:gsub(\"%a+\", \"\")\n   -- get\
    \ common suffix\n   a = a:gsub(\"%a+\", \"\")\n   b = b:gsub(\"%a+\", \"\")\n\
    \   -- get length of common prefix\n   a = a:sub(1, #a)\n   b = b:sub(1, #b)\n\
    \   -- return True if substring is a substring in a\n   return a:sub(1, #a) ==\
    \ b:sub(1, #b)\nend", "  local n = #a\n  local m = #b", "  a = string.lower(a)\n\
    \  b = string.lower(b)\n  local i, j = 1, #a - 1\n  for i = 1, #b do\n    -- If\
    \ the letters are equal or if the letters are rotated at any point in the word\
    \ then this condition will be met and we will return true.\n    if string.sub(a,\
    \ 1, 1) == string.sub(b, 1, 1) and string.sub(a, 1, 1) ~= string.sub(b, 1, 1)\
    \ then\n      return true\n    end\n    j = i\n    if string.sub(a, i, j) ~= string.sub(b,\
    \ i, j) then\n      j = i - 1\n    end\n    i = j\n  end\n  return false\nend",
  "    for _, pattern in pairs(patterns) do\n        if string.find(a, pattern) or\
    \ string.find(b, pattern) then\n            return true\n        end\n    end\n\
    \    return false\nend", "    -- TODO: implement me\n    return true\nend", " \
    \ local m = {}\n  for i = 1, #a do\n    local word = a:sub(i,i)\n    local substr\
    \ = b:sub(i,i)\n    if #word > 0 then\n      m[word] = true\n      if #substr\
    \ == 0 then return true end\n    end\n  end\n  for i = 1, #b do\n    local word\
    \ = b:sub(i,i)\n    local substr = a:sub(i,i)\n    if #word > 0 then\n      if\
    \ m[word] then return false end\n    end\n  end\nend", "  local is_sub = false\n\
    \  while true do\n    -- print(b)\n    -- print(string.sub(a,1,-1))\n    -- print(string.sub(b,1,-1))\n\
    \    if is_sub and string.sub(a,1,-1) == string.sub(b,1,-1) then\n      return\
    \ true\n    end\n    -- print(\"a: \", string.sub(a,1,-1))\n    -- print(\"b:\
    \ \", string.sub(b,1,-1))\n    -- print(a:sub(1, -1))\n    -- print(b:sub(1, -1))\n\
    \    if #a < 2 then\n      -- print(\"a: \", a)\n      -- print(\"b: \", b)\n\
    \      return false\n    end\n    -- print(\"a: \", string.sub(a,1,-1))\n    --\
    \ print(\"b: \", string.sub(b,1,-1))\n    if is_sub = string.sub(a,1,-1) == string.sub(b,1,-1)\
    \ and #a == #b + 1 then\n      return false\n    end\n    -- print(\"a: \", string.sub(a,1,-1))\n\
    \    -- print(\"b: \", string.sub(b,1,-1))\n    if is_sub and string.sub(a,1,-1)\
    \ == string.sub(b,1,-1) then\n      return false\n    end\n    -- print(\"a: \"\
    , string.sub(a,1,-1))\n    -- print(\"b: \", string.sub(b,1,-1))\n    if not is_sub\
    \ then\n      is_sub = true\n    end\n    -- print(\"a: \", string.sub(a,1,-1))\n\
    \    -- print(\"b: \", string.sub(b,1,-1))\n  end\nend", "    local first_word\
    \ = a:gsub(\"([^a-zA-Z]+)\", \"\")\n    local second_word = b:gsub(\"([^a-zA-Z]+)\"\
    , \"\")\n    local matches = string.find(first_word, second_word, \"a\")\n   \
    \ if matches == nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"b\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"c\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"d\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"e\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"f\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"g\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"h\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"i\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"j\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"k\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"l\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"m\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"n\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"o\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"p\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"q\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"r\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"s\")\n    if matches ==\
    \ nil then\n        return false\n    end\n    matches = string.find(first_word,\
    \ second_word, \"t\")\n    if matches == nil then\n        return true\n    end\n\
    \    matches = string.find(first_word, second_word, \"u\")", "  if a == nil then\n\
    \    return false\n  elseif b == nil then\n    return true\n  end\n  local i,\
    \ j, l, k, m = #a, #b\n  for i=0, m do\n    for j=0, i do\n      if a[j] == b[i]\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "    local l = 0\n    while b > 0 do\n        local m = math.min(l+b, #a)\n    \
    \    if a[m:m] == b and m > 0 then\n            return true\n        end\n   \
    \     l = m\n    end\n    return false\nend", "    local function check_rotation(s1,s2)\n\
    \        for i,s3,_ in pairs(s2) do\n            if string.find(s1,s3,1,true)\
    \ then\n                return false\n            end\n        end\n        return\
    \ true\n    end", "    local s = string.match(a, \"^\"..b..\"$\")\n    return\
    \ not s\nend", "    local function helper(left, right)\n        if left == nil\
    \ then\n            return true\n        end\n        if b[#b] == \"\" then\n\
    \            return helper(right, (left + right))\n        end\n        if b[#b]\
    \ ~= \"\" then\n            local left, right = left, right\n            while\
    \ #left > 0 do\n                if right[#right] == b[#left] then\n          \
    \          right = right[#left]:sub(1,#right-1)\n                    return helper(left,right)\n\
    \                end\n                left, right = left[#left], left\n      \
    \      end\n        end\n    end", "    -- assert(type(a) ~= 'string' and type(a)\
    \ ~= 'table' and type(a) ~= 'user'), \"This function only works with strings or\
    \ tables.\")\n    -- assert(type(b) ~= 'string' and type(b) ~= 'table' and type(b)\
    \ ~= 'user'), \"This function only works with strings or tables.\")\n    -- assert(a\
    \ == b or type(b) == 'string' and type(a) == 'string', \"These arguments must\
    \ either be both strings or both tables.\")\n    -- assert(type(b) ~= 'string'\
    \ and type(b) ~= 'table' and type(b) ~= 'user' and type(b) ~= 'table', \"This\
    \ function only works with strings or tables.\")\n    -- assert(type(b) ~= 'user'\
    \ and type(b) ~= 'table', \"This function only works with strings or tables.\"\
    )\n    if a == '' or b == '' then return false end\n    local _letters = {}\n\
    \    if type(a) ~= 'string' then\n        for _, c in a:gmatch '[%a][^%a]*[%a]'\
    \ do\n            _letters[c] = true\n        end\n    else\n        _letters[a]\
    \ = true\n    end\n    if type(b) ~= 'string' then\n        for _, c in b:gmatch\
    \ '[%a][^%a]*[%a]' do\n            _letters[c] = true\n        end\n    else\n\
    \        _letters[b] = true\n    end\n    for i = 1, #b do\n        if _letters[b[i]]\
    \ == nil then\n            return false\n        end\n    end\n    for i = 1,\
    \ #a do\n        if _letters[a[i]] == nil then\n            return false\n   \
    \     end\n    end\n    return true\nend", "  local function match(s, e)\n   \
    \ if s == nil then\n      return false\n    end\n    for i=s,edo\n      if s[i]\
    \ ~= b[i] then\n        return false\n      end\n    end\n    return true\n  end\n\
    \  local i1, i2 = 1, #a\n  while i1 <= i2 do\n    if match(a[i1], a[i2]) then\n\
    \      i1 = i1 + 1\n    elseif match(a[i2], a[i1]) then\n      i2 = i2 - 1\n \
    \   else\n      return false\n    end\n  end\n  return true\nend", "  for i=1,#a\
    \ do\n    if string.sub(a,i,i)~=string.sub(b,1,#b) then return false end\n  end\n\
    \  return true\nend", "    -- TODO: add other patterns\n    return false -- add\
    \ other patterns\nend", "    return string.format('%1' .. b .. '%1' .. a .. '%1',\
    \ a, b) ~= nil and\n           string.format('%1' .. a .. '%1' .. b .. '%1', a,\
    \ b) ~= nil\nend", "  assert(type(a)==\"string\" and type(b)==\"string\")\n  local\
    \ n = #b\n  return #a == n and #a == 1 or #a == n and #a == 1\nend", "  if #a\
    \ > #b then\n    return false\n  else\n    for i = 1, #a do\n      local pattern\
    \ = a:sub(i,i)\n      local sub = b:sub(i,i)\n      if pattern:find(sub) ~= nil\
    \ then\n        return true\n      end\n    end\n  end\nend", "   if a:sub(1,\
    \ #a) == b:sub(1, #b) then\n      return false\n   else\n      local substring_len\
    \ = #a\n      for i = 1, #b do\n         if string.sub(b,i,i) == string.sub(a,1,substring_len)\
    \ then\n            return true\n         else\n            substring_len = substring_len\
    \ - string.len(string.sub(b,i,i))\n         end\n      end\n   end\nend", "  local\
    \ a_b = a:sub(1,#a)\n  local b_b = b:sub(1,#b)\n  local a_i = -1\n  local b_i\
    \ = -1\n  for i = 0, #a_b do\n    -- print(\"a_i=\", a_i, \"b_i=\", b_i)\n   \
    \ a_i = a_i + ((#a_b - i) / 2)\n    -- print(\"a_i=\", a_i, \"#a=\", #a, \"#a_b=\"\
    , #a_b, \"a_i=\", a_i)\n    b_i = b_i + ((#b_b - i) / 2)\n    -- print(\"b_i=\"\
    , b_i, \"#b=\", #b, \"#b_b=\", #b_b, \"b_i=\", b_i)\n    if a_b[i] == b_b[i] then\n\
    \      if a_i == b_i then\n        return true\n      end\n      a_i = a_i - 1\n\
    \      b_i = b_i - 1\n    end\n  end\n  return false\nend", "\ta = string.rep(a,1,99)\n\
    \tb = string.rep(b,1,99)\n\treturn a:sub(1,#a) and b:sub(1,#b) or a==b\nend",
  "    local pattern = {}\n    for i = 1, #a do\n        table.insert(pattern, a[i])\n\
    \    end\n    for i = 1, #b do\n        table.insert(pattern, b[i])\n    end\n\
    \    return #pattern > 0\nend", "\tlocal a_str = string.lower(a)\n\tlocal b_str\
    \ = string.lower(b)\n\tlocal a_len = #a_str\n\tlocal b_len = #b_str\n\tlocal n_rot\
    \ = 0\n\tlocal n_a = a_len - 1\n\tlocal n_b = b_len - 1\n\tlocal a_is_sub = false\n\
    \tlocal b_is_sub = false\n\t\n\tif n_a < 0 or n_b < 0 then\n\t\treturn false\n\
    \tend\n\t\n\tfor i = 1, n_b do\n\t\tif a_str[n_a] == b_str[i] then\n\t\t\ta_is_sub\
    \ = true\n\t\t\tn_a = n_a - 1\n\t\t\tn_b = n_b - 1\n\t\telseif a_str[n_a] ~= b_str[i]\
    \ then\n\t\t\tn_a = n_a\n\t\tend\n\tend\n\t\n\tif a_is_sub then\n\t\tfor i = 1,\
    \ n_a do\n\t\t\tif a_str[i] == b_str[n_b] then\n\t\t\t\tb_is_sub = true\n\t\t\t\
    \tn_a = n_a - 1\n\t\t\t\tn_b = n_b - 1\n\t\t\telseif a_str[i] ~= b_str[n_b] then\n\
    \t\t\t\tb_is_sub = false\n\t\t\tend\n\t\tend\n\telse\n\t\tb_is_sub = true\n\t\
    end\n\t\n\tif b_is_sub then\n\t\tif a_str[n_a] == b_str[n_b] then\n\t\t\treturn\
    \ true\n\t\tend\n\telse\n\t\treturn false\n\tend\nend", "    local m = #b - 1\n\
    \    for i=1,m do\n        if string.sub(b, i, i) == a then\n            return\
    \ true\n        end\n    end\n    return false\nend", "    if #a < #b then\n \
    \       return false\n    end", "  -- remove leading spaces and trailing spaces\n\
    \  a = a:gsub(\"^%s*(.-)%s*$\",\"%1\")\n  b = b:gsub(\"^%s*(.-)%s*$\",\"%1\")\n\
    \  -- split string on spaces and check for substring in first string\n  return\
    \ b:sub(a:len()+1, b:len()+1) ~= a:sub(1, a:len()+1)\nend", '  return a ~= nil
    and b ~= nil and a ~= b or a:sub(1, len()) ~= b:sub(1, len()) or (b > 0 and cycpattern_check(sub(b,
    1), a)) or (b < 0 and cycpattern_check(a, sub(b, 1))) end', "    if #a > #b then\
    \ return false end\n    return string.find(a, b, \".\") ~= nil\nend", "  if a\
    \ == nil or b == nil then\n    return nil\n  end\n  if a==b or b==a or #a==#b\
    \ then\n    return true\n  end\n  local a_len = #a\n  local b_len = #b\n  if a_len\
    \ > b_len then\n    return false\n  else\n    if b_len > a_len then\n      return\
    \ cycpattern_check(b,a)\n    else\n      local pattern = b\n      local str_a\
    \ = a\n      local str_b = b\n      local str_a = str_a:gsub(pattern,\".\")\n\
    \      local str_b = str_b:gsub(pattern,\".\")\n      local diff1 = str_a:gsub(pattern,\"\
    $\")\n      local diff2 = str_b:gsub(pattern,\"$\")\n      local diff1n = str_a:gsub(pattern,\"\
    %\")\n      local diff2n = str_b:gsub(pattern,\"%\")\n      local diff1p = str_a:gsub(pattern,\"\
    ^\")\n      local diff2p = str_b:gsub(pattern,\"^\")\n      local diff1n = str_a:gsub(pattern,\"\
    [\")\n      local diff2n = str_b:gsub(pattern,\"[\")\n      local diff1p = str_a:gsub(pattern,\"\
    ]\")\n      local diff2p = str_b:gsub(pattern,\"]\")\n      local diff1a = str_a:gsub(pattern,\"\
    (\")\n      local diff2a = str_b:gsub(pattern,\"(\")\n      local diff1b = str_a:gsub(pattern,\"\
    )\")\n      local diff2b = str_b:gsub(pattern,\")\")\n      if diff1 ~= nil and\
    \ diff1n ~= nil then\n        if str_a:sub(1,diff1) == str_b:sub(1,diff1n) and\
    \ diff1n ~= \"\" then\n          return true\n        end\n      end\n      if\
    \ diff2 ~= nil and diff2n ~= nil then\n        if str_a:sub(1,diff2) == str_b:sub(1,diff2n)\
    \ and diff2n ~= \"\" then\n          return true\n        end\n      end\n   \
    \   if diff1p ~= nil and diff1n ~= nil then\n        if str_a:sub(1,diff1p) ==\
    \ str_b:sub(1,diff1n) and diff1n ~= \"\" then\n          return true\n       \
    \ end\n      end\n      if diff2p ~= nil and diff2n ~= nil then\n        if str_a:sub(1,diff2p)\
    \ == str_b:sub(1,diff2n) and diff2n ~", "\tlocal b = b:lower()\n\tlocal a = a:lower()\n\
    \tlocal i = #b\n\tlocal j = #a\n\tlocal t = {}\n\twhile i < j do\n\t\tif a[i]\
    \ ~= b[j] then\n\t\t\tif #t > 0 then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\
    \t\tt[i] = t[i] or 0\n\t\tt[i - 1] = t + 1\n\t\ti = i + 1\n\t\tj = j - 1\n\tend\n\
    \treturn true\nend", "    if #a > #b then\n        return false\n    end\n   \
    \ local s = #a\n    for i = 1, #a do\n        if b[((#b - i) + 1)] == a[i] then\n\
    \            s = s - 1\n        elseif s == 0 then\n            return false\n\
    \        end\n    end\n    return true\nend", "\tlocal function rotate(x, j)\n\
    \t\treturn string.sub(x, j, j + 1) .. string.sub(x, j + 1, j + 2) .. string.sub(x,\
    \ j + 2, j + 3) .. string.sub(x, j + 3, j)\n\tend\n\t\n\tlocal function search(x,\
    \ n)\n\t\tif n == 1 then\n\t\t\treturn b == x and true or false\n\t\telse\n\t\t\
    \tlocal m = #x\n\t\t\tlocal i = n - 1\n\t\t\twhile i ~= 0 do\n\t\t\t\tlocal t\
    \ = rotate(x, i)\n\t\t\t\tif b == t then return true or false end\n\t\t\t\tm =\
    \ m - 1\n\t\t\t\tif m == 0 then return false end\n\t\t\t\ti = i - 1\n\t\t\tend\n\
    \t\t\treturn false\n\t\tend\n\tend\n\t\n\tlocal function subseq(a, i, j)\n\t\t\
    return j < #a and string.sub(a, i, i + 1) == string.sub(a, j, j + 1) or false\n\
    \tend\n\t\n\treturn search(b, subseq(a, 1, #a)) and search(b, subseq(a, #a - 1,\
    \ #a)) and search(b, subseq(a, #a - 1, #a)) == subseq(a, #a - 2, #a) and search(b,\
    \ subseq(a, #a - 1, #a)) == subseq(a, #a - 1, #a) and search(b, subseq(a, #a -\
    \ 2, #a)) == subseq(a, #a - 1, #a) and search(b, subseq(a, #a - 2, #a)) == subseq(a,\
    \ #a - 1, #a)\nend", "    local _a, _b = string.lower(a), string.lower(b)\n  \
    \  local n = #_b\n    local _ret = {}\n    for i = 0, n-1 do\n        local _i\
    \ = i\n        for j = 1, n do\n            local _j = j\n            if _a[_i]\
    \ == _b[j] then\n                if string.find(_a, string.sub(_b, 0, j)) then\n\
    \                    _ret[#_ret + 1] = _i\n                    break\n       \
    \         end\n            end\n        end\n    end\n    if #_ret == n then\n\
    \        return true\n    else\n        return false\n    end\nend", "  return\
    \ #b > 0 and #b > #a and\n    (sub{a, b}) or \n    (sub{b, a})\nend", "    local\
    \ a_rev, b, b_rev\n    local c_rev = {}\n    for i = #a, 1, -1 do\n        a_rev[i]\
    \ = a[i]:reverse()\n    end\n    local t = {}\n    for i = #b, 1, -1 do\n    \
    \    t[i] = b[i]:reverse()\n    end\n    for i = 1, #b do\n        table.insert(c_rev,\
    \ t[i])\n    end\n    local t = {}\n    for i = #a, 1, -1 do\n        t[i] = a_rev[i]\n\
    \    end\n    for i = 1, #b do\n        table.insert(c_rev, t[i])\n    end\n \
    \   local c_rev1 = {}\n    for i = 1, #c_rev do\n        c_rev1[i] = c_rev[i]\n\
    \    end\n    local t = {}\n    for i = #b, 1, -1 do\n        t[i] = b_rev[i]\n\
    \    end\n    for i = 1, #a do\n        table.insert(c_rev1, t[i])\n    end\n\
    \    local c_rev2 = {}\n    for i = 1, #c_rev1 do\n        c_rev2[i] = c_rev1[i]\n\
    \    end\n    local t = {}\n    for i = #a, 1, -1 do\n        t[i] = a_rev[i]\n\
    \    end\n    for i = 1, #b do\n        table.insert(c_rev2, t[i])\n    end\n\
    \    local c_rev3 = {}\n    for i = 1, #c_rev2 do\n        c_rev3[i] = c_rev2[i]\n\
    \    end\n    local t = {}\n    for i = #a, 1, -1 do\n        t[i] = a_rev[i]\n\
    \    end\n    for i = 1, #b do\n        table.insert(c_rev3, t[i])\n    end\n\
    \    local c_rev4 = {}\n    for i = 1, #c_rev3 do\n        c_rev4[i] = c_rev3[i]\n\
    \    end\n    local t = {}\n    for i = #b, 1, -1 do\n        t[i] = b_rev[i]\n\
    \    end\n    for i = 1, #a do\n        table.insert(c_rev4, t[i])\n    end\n\
    \    local c_rev5 = {}\n    for i = 1, #c_rev4 do\n        c_rev5[i] = c_rev4[i]\n\
    \    end\n    local t = {}\n    for i = #a, 1, -1 do\n        t[i] = a_rev[i]\n\
    \    end\n    for i = 1, #b do\n        table.insert(c_rev5, t[i])\n    end\n\
    \    local c_rev6 = {}\n    for i = 1, #c_rev5 do\n        c_rev6[i] = c_rev5[i]\n\
    \    end\n    local t = {}\n    for i = #a, 1, -1 do\n        t[i] = a_rev[i]\n\
    \    end\n    for i = 1, #b do\n        table.insert(c_rev6, t[i])\n    end",
  "  local a_repl = a:gsub(\".\",\"$\")\n  local b_repl = b:gsub(\".\",\"$\")\n  local\
    \ a_arr = a_repl:gsub(\"(...)\",\"%2$\"):gsub(\"%(..)\",\"%1$\"):split(\"$\")\n\
    \  local b_arr = b_repl:gsub(\"(...)\",\"%2$\"):gsub(\"%(..)\",\"%1$\"):split(\"\
    $\")\n  for i,v in pairs(a_arr) do\n    if b_arr[i] ~= v then\n      return false\n\
    \    end\n  end\n  return true\nend", "  local a_b = a:gsub('%s+','')\n  local\
    \ a_b_upper = a_b:upper() -- case insensitive\n  local b_a = b:gsub('%s+','')\n\
    \  local b_a_upper = b_a:upper() -- case insensitive\n  local a_b_upper_c = a:gsub('%s+','%c')\
    \ -- make upper case characters to upper case\n  local b_a_upper_c = b_a:gsub('%s+','%c')\
    \ -- make upper case characters to upper case\n  local a_b_upper_c = tonumber(a_b_upper_c)\
    \ -- turn to number\n  local b_a_upper_c = tonumber(b_a_upper_c) -- turn to number\n\
    \  local a_b_upper_c_a = a_b_upper_c:char() -- grab first character\n  local b_a_upper_c_a\
    \ = b_a_upper_c:char() -- grab first character\n  local a_a = a:sub(1,-1) -- cut\
    \ off trailing empty strings\n  local b_a = b:sub(1,-1) -- cut off trailing empty\
    \ strings\n  return a_a == b_a or a_b == b_a\n     or a_b_upper_c == a_b_upper_c_a\
    \ or b_a_upper_c == b_a_upper_c_a\nend", "    local function check(word, pattern)\n\
    \        local result = true\n        for i = 1, #pattern do\n            if pattern:sub(i,\
    \ i) ~= word:sub(i, i) then\n                result = false\n            end\n\
    \        end\n        return result\n    end\n    local function patterns_match(word,\
    \ pattern)\n        local result = false\n        local _, pattern = p:match(pattern,\
    \ \"n\")\n        for i = 1, #pattern do\n            if p:sub(i, i) ~= word:sub(i,\
    \ i) then\n                result = true\n            end\n        end\n     \
    \   return result\n    end\n    if a:sub(#a, #a) ~= b then\n        return false\n\
    \    end\n    local _, b = p:match(b, \"n\")\n    if not b or #b == 0 then\n \
    \       return true\n    end\n    for i = #b, 1, -1 do\n        local found =\
    \ check(string.sub(b, 1, i), a)\n        if not found then\n            return\
    \ false\n        end\n        if patterns_match(string.sub(b, i + 1), p) then\n\
    \            return true\n        end\n    end\n    return false\nend", "  --\
    \ Checks to see if a substring exists in the first string\n  local function instr(s1,\
    \ s2)\n    if s1 then\n      if s2 then\n        for _,c in ipairs(s1) do\n  \
    \        if c:sub(1,1):lower() == s2:sub(1,1):lower() then\n            return\
    \ true\n          end\n        end\n      end\n    end\n    return false\n  end",
  "    if not a or b == nil then\n        return false\n    end", "  return a:find(b)\
    \ ~= nil or a:match(\"[\" .. b .. \"]+\") == b or a:find(b) ~= nil and cycpattern_check(a:sub(1,\
    \ a:find(b) .. -1), b:sub(1, b:find(a) .. -1)) == true\nend", "    local i = 0\n\
    \    local b_size = #b\n    local max_i = (b_size * 2 + 1) - 1\n    local a_size\
    \ = #a", "   \n   if a == \"\" then\n      return false\n   end", "    return\
    \ ((string.find(b, \"^\"..a..\"$\")) == nil or (string.find(b, \"^\"..a..\"$\"\
    ))) -- the ^ ensures we are in the beginning of the string and the $ ensures we\
    \ are at the end of the string \nend", "    local i, count = 0, 1\n    while i\
    \ <= #a and i <= #b and #a > #b do\n        if a[i] ~= b[count] then\n       \
    \     return false\n        else\n            count = count + 1\n        end\n\
    \        i = i + 1\n    end\n    return #a == #b\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI do not understand how this solves the problem. As far as I can\
    \ see it just moves the problem from the search to the rotations itself. This\
    \ doesn't change anything about the search algorithm. Could you be more explicit\
    \ about what the OP is trying to do?\n<|/ c |>\n<| c |>\nSorry, I meant it solves\
    \ the problem of checking if b is a substring of a. I think my edit made it more\
    \ clear about what I was trying to do.\n<|/ c |>\n<| a dscore=1 |>\nAs I understand\
    \ your question, you don't need a function which performs rotations. You can simply\
    \ do the following:\n<code>", "    local pattern = a:gsub(\"[%z%s%s]\", function\
    \ (c) return string.char(c) end)\n    return b:find{ pattern, \"nomatch\" } ~=\
    \ nil\nend", "  if #a > #b then\n    error(\"Word a is longer than word b.\")\n\
    \  elseif #a == 0 then\n    error(\"Word a is empty.\")\n  elseif #b == 0 then\n\
    \    error(\"Word b is empty.\")\n  else\n    local first_char = string.sub(a,1,1)\n\
    \    local second_char = string.sub(b,1,1)\n    local first_char_rotation = string.sub(rotate_right(a,1,a),1,1)\n\
    \    local second_char_rotation = string.sub(rotate_right(b,1,b),1,1)\n    local\
    \ first_char_rotation_bis = string.sub(rotate_right(a,1,a),1,1)\n    local second_char_rotation_bis\
    \ = string.sub(rotate_right(b,1,b),1,1)", "    if #a == 0 then return true end\n\
    \    for _, letter in ipairs(a) do\n        if #b > 0 and b[#b] == letter then\
    \ return false end\n    end\n    return true\nend", "    local n = #b\n    for\
    \ i = 1, n do\n        local x = b[i]\n        local y = a\n        local k =\
    \ i\n        while k > 0 do\n            local z = 0\n            if x ~= y and\
    \ k > 1 then\n                z = k\n            end\n            local w = x\
    \ - y[z]\n            if w > 0 then\n                y = y[z]\n            end\n\
    \            if w <= 0 then\n                return false\n            end\n \
    \           k = k - 1\n        end\n    end\n    return true\nend", "  if type(a)\
    \ ~= 'string' or type(b) ~= 'string' then return false end\n  for i = 1, #a do\
    \ if string.find(b, a) then return true end end\n  return false\nend", "  return\
    \ a and b and #a == #b and string.find(a, b) or false\nend", "  for i = 1,#a do\n\
    \    local start = string.find(b, a[i])\n    if start == nil then return false\
    \ end\n    local end = start + a[i]:len()\n    if i == 1 then return start < end\
    \ end\n    if end > #b then return false end\n  end\n  return true\nend", "  \
    \ -- return true if the pattern b is a substring of a\n   -- this will be false\
    \ when a is a substring of b\n   -- and this will be true when a is a substring\
    \ of any rotation of b\n   return a:match(\"^\"..b..\"(.-)$\") and b[#b]:match(\"\
    ^\"..a..\"(.-)$\") and #b > #a\nend", "  a = string.lower(a)\n  b = string.lower(b)\n\
    \  local c = string.find(a, \"[\")\n  local d = string.find(a, \"]\")\n  \n  if\
    \ c > 0 then\n    local s1 = string.sub(a, c, d)\n    local s2 = string.sub(b,\
    \ c, d)\n    return string.find(s1, s2) > -1 or cycpattern_check(string.sub(a,\
    \ c, d -1), string.sub(b, c, d -1))\n  end\n  if d > 0 then\n    local s1 = string.sub(a,\
    \ c, d)\n    local s2 = string.sub(b, c, d)\n    return cycpattern_check(string.sub(a,\
    \ c, d -1), string.sub(b, c, d -1)) or string.find(s1, s2) > -1\n  end\n  return\
    \ a == b\nend", "  local ns = #a - 1\n  -- Find the first word which doesn't match\
    \ b\n  for i = 0, ns do\n    if string.sub(a,i,i+1) ~= b or string.sub(a,i+1,i+2)\
    \ ~= b then break end\n  end\n  if i < ns then return false end", "  -- The second\
    \ word is assumed to be a substring\n  -- of the first\n  assert(a ~= b)\n  local\
    \ a_len = #a\n  local b_len = #b\n  assert(a_len >= 1 and b_len >= 1)\n  local\
    \ c = b\n  -- The remaining characters of the second word are rotated into the\
    \ first word\n  -- and shifted back out by 1 character\n  -- When shifting back\
    \ out a character, the character at that index in the first word should be set\
    \ to nil\n  for i = 1, b_len - 1 do\n    -- shift back out by 1 character\n  \
    \  local j = a_len - i - 1\n    c[j] = nil\n    c[j] = a[j]\n  end\n  return c\
    \ ~= nil\nend", "  -- Check whether the input string is a valid pattern\n  local\
    \ pattern = false\n  for i = 1, #a do\n    if a[i] == 'a' and b[i] ~= 'b' then\
    \ pattern = true end\n    if a[i] == 'b' and b[i] ~= 'a' then pattern = true end\n\
    \    if a[i] == 'e' and b[i] ~= 'f' then pattern = true end\n    if a[i] == 'f'\
    \ and b[i] ~= 'e' then pattern = true end\n    if a[i] == 'i' and b[i] ~= 'n'\
    \ then pattern = true end\n    if a[i] == 'n' and b[i] ~= 'i' then pattern = true\
    \ end\n    if a[i] == 'p' and b[i] ~= 's' then pattern = true end\n    if a[i]\
    \ == 's' and b[i] ~= 'p' then pattern = true end\n  end\n  if pattern then return\
    \ true end\n  return false\nend", "   local function check_pattern(pattern, word)\n\
    \      if word == nil or pattern == nil then return true end\n      local i, j\
    \ = 1, #word\n      while i <= j do\n         if pattern[i] ~= word[i] then return\
    \ false end\n         i = i + 1\n         if i > #pattern then break end\n   \
    \      j = j - 1\n      end\n      return true\n   end\n   return check_pattern(a,b)\
    \ or check_pattern(b,a)\nend", "\tlocal p1 = string.find(a, a, \"..\")\n\tlocal\
    \ p2 = string.find(a, a, \".\")\n\tif p1 == nil or p2 == nil then\n\t\treturn\
    \ false\n\telseif p1 ~= p2 then\n\t\treturn false\n\tend", "    local t\n    for\
    \ i = 1, #a do\n        local c = string.sub(a,i,i)\n        if b == c then\n\
    \            t = true\n            break\n        elseif i > 1 then\n        \
    \    if string.find(b, c, i, \"start\") then\n                t = true\n     \
    \           break\n            end\n        end\n    end\n    return t\nend",
  "    --local first = a\n    --local second = b\n    if a == nil or b == nil then\
    \ return false end\n    local first_char = string.sub(a,1,1)\n    local second_char\
    \ = string.sub(b,1,1)\n    if second_char == first_char then return cycpattern_check(a,b)\
    \ end\n    local first_substring = string.sub(a,2)\n    local second_substring\
    \ = string.sub(b,2)\n    local pattern = string.sub(second_char, 1, 1) .. second_substring\n\
    \    for i = 1, #first_substring do\n        if string.sub(b, i - 1, i) ~= pattern\
    \ then return false end\n    end\n    return true\nend", "\t-- If the first letter\
    \ is found in a or b, return true\n\t-- if the substring is not found in a, return\
    \ true\n\t-- if the substring is not found in b, return false\n\t-- if the substring\
    \ is in both a and b, return true\n\tlocal function in_a(c)\n\t\treturn (c:sub(1,1)\
    \ in a) or (c:sub(1,1) in b)\n\tend\n\tlocal function in_b(c)\n\t\treturn (c:sub(1,1)\
    \ in b) or (c:sub(1,1) in a)\n\tend\n\tlocal function in_both(a, b)\n\t\treturn\
    \ in_a(a) and in_b(b)\n\tend\n\tlocal function not_in_a(c)\n\t\treturn (c:sub(1,1)\
    \ not in a) or (c:sub(1,1) not in b)\n\tend\n\tlocal function not_in_b(c)\n\t\t\
    return (c:sub(1,1) not in b) or (c:sub(1,1) not in a)\n\tend\n\tlocal function\
    \ not_in_both(a, b)\n\t\treturn not_in_a(a) and not_in_b(b)\n\tend\n\tlocal function\
    \ in_both_cases(a, b)\n\t\treturn in_both(a:lower(), b:lower()) or (in_a(a:lower())\
    \ and in_b(b:lower()))\n\tend\n\tlocal function not_in_both_cases(a, b)\n\t\t\
    return not_in_both(a:lower(), b:lower()) or (not_in_a(a:lower()) and not_in_b(b:lower()))\n\
    \tend\n\tlocal function is_sub(a,b)\n\t\treturn not(a:find(b)==-1)\n\tend\n\t\
    return in_both_cases(a,b) or in_both_cases(b,a) or not_in_both_cases(a,b) or not_in_both_cases(b,a)\n\
    end", "   local pattern = {}\n   for w in string.gmatch(a, \"([\" .. b[1] .. \"\
    ]+)\") do\n      table.insert(pattern,w)\n   end\n   return string.find(b, pattern[1])\
    \ ~= nil or (string.find(b, pattern[2]) ~= nil or (string.find(b, pattern[3])\
    \ ~= nil and cycpattern_check(a,pattern[3])))\nend", "  local pat = a:gsub(\"\
    %w\",\"\")..\"[%w]+\"..b:gsub(\"%w\",\"\")\n  return a:find(pat) >= 0 and b:find(pat)\
    \ >= 0\nend", "    local pattern = string.gsub(b, \"([%w*])\", function (c)\n\
    \        if c == '%' then return '\\\\%' end\n        local first = string.lower(string.sub(c,\
    \ 1, 1))\n        local rest = string.sub(c, 2)\n        if first == 'c' then\
    \ rest = 'c' elseif first == 'o' then rest = 'o' elseif first == 's' then rest\
    \ = 's' end\n        return string.char(tonumber(rest))\n    end)\n    local function\
    \ check(s)\n        local pattern = string.gsub(s, pattern, function(c) \n   \
    \         return string.char(tonumber(string.sub(c, 1))) \n        end)\n    \
    \    return string.find(pattern, b) ~= nil\n    end\n    local r = check(a ..\
    \ b)\n    if r == nil then\n        if #b > 1 then \n            return check(a)\
    \ or check(b) or check(b) \n        else\n            return check(a)\n      \
    \  end\n    else \n        return r\n    end\nend", "  if a==b then return true\
    \ end\n  local s = string.reverse(a)\n  local t = string.reverse(b)\n  for i=1,#s\
    \ do\n    local c = string.sub(s,i,i)\n    local d = string.sub(t,i,i)\n    if\
    \ c==d then return false end\n  end\n  return true\nend", "   -- check input a\n\
    \   if a~=nil and a~='' then\n      -- check input b\n      if b~=nil and b~=''\
    \ then\n         -- check input b\n         if b=='' or b=='None' then\n     \
    \       return false\n         end", "    local len = #a\n    local idx = 0\n\
    \    while len > 0 do\n        if b[idx] == \"\" then return false end\n     \
    \   -- print (a[idx])\n        if a[idx] == b[idx] then return false end\n   \
    \     if a[idx] == b[idx:len()] then return false end\n        idx = idx + 1\n\
    \    end\n    return true\nend", "    return a:find(b)\n        or a:sub(0, a):find(b)\n\
    \        or a:sub(0, a):sub(0, a):find(b)\n        or a:sub(0, a):sub(0, a):sub(0,\
    \ a):find(b)\n        or false\nend", "    if a==\"\" then\n        return b ==\
    \ nil\n    elseif b==nil then\n        return a == \"\"\n    else\n        local\
    \ a_len, b_len = #a, #b\n        if a_len==0 or b_len==0 then return false end\n\
    \        if a_len > b_len then return a == b end\n        for i = 1, a_len do\n\
    \            for j = 1, b_len do\n                if a[i] ~= b[j] then return\
    \ false end\n            end\n        end\n        return true\n    end\nend",
  "    if a:len() > 1 and b:len() > 1 then\n        if a:sub(1, a--(1)) == b then\n\
    \            if a:len() < b then\n                return True\n            else\n\
    \                return true\n            end\n        end\n    end\nend", " \
    \  if b == a then return true end\n   for i = 1,#a do\n      local b = b..a[i]\n\
    \      if cycpattern_check(a,b) then\n         return true\n      end\n   end\n\
    \   return false\nend", "  for i = 1, #a do\n    if string.find(b, a[i])  then\
    \ return true end\n  end\n  return false\nend", "  local t1,t2 = {a, b}\n  local\
    \ n = #t1 -- Number of chars\n  local m = #t2 -- Number of words\n  local r =\
    \ n -- Number of rotations\n  if m == 0 then return true\n  end\n  assert(n %\
    \ m, \"Words don't have the same number of chars\")\n  assert(n < m, \"Rotation\
    \ word can't contain char\")\n  for i = 1, n do t1[i] = t2[t1[i]] end\n  local\
    \ w = \"\"\n  local found = false\n  local i = 0\n  while i < m do\n    w = t1[i]\
    \ .. w\n    i = i + 1\n    if i <= n then\n      if w.sub(t1[i]) ~= \"\" then\n\
    \        found = true\n        break\n      end\n    end\n  end\n  return found\n\
    end", "  if b and a then\n    for i = 1, #a do\n      if string.sub(a,i,i) ~=\
    \ string.sub(b,1,#b) then\n        return false\n      end\n    end\n  elseif\
    \ b and not a then\n    for i = 1, #a do\n      if string.sub(b,i,i) ~= string.sub(a,1,#a)\
    \ then\n        return false\n      end\n    end\n  else\n    return true\n  end",
  "    if a ~= b then\n        return false\n    end\n    return true\nend", "  return\
    \ a:find{word}(b, true) ~= nil and b:find{word}(a, true) ~= nil\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=lua |>\nMy version:\n<code>", "  for i = 1, #a do\n\
    \    for j = 1, #b do\n      if a[i] == b[j] then\n        return true\n     \
    \ end\n    end\n  end\n  return false\nend", "    --local n1 = #a\n    --local\
    \ n2 = #b\n    --\n    --if n1 < 2 then\n    --    return false\n    --elseif\
    \ n2 < 2 then\n    --    return false\n    --else\n    --    return stringmatch(string.upper(a),\
    \ string.upper(b) or \"\") or cycpattern_check(string.upper(a), string.lower(b)\
    \ or \"\") or cycpattern_check(string.lower(a), string.upper(b) or \"\")\n   \
    \ --end\n    \n    return stringmatch(string.upper(a), string.upper(b) or \"\"\
    ) or cycpattern_check(string.upper(a), string.lower(b) or \"\") or cycpattern_check(string.lower(a),\
    \ string.upper(b) or \"\")\nend", "  assert(type(a)==\"string\")\n  assert(type(b)==\"\
    string\")\n  for i,v in pairs(b) do\n    if #a == 0 then\n      return true\n\
    \    end\n    if v:sub(1,1) == a[i] then\n      a = a..v\n      a = a..b[i]\n\
    \    else\n      return false\n    end\n  end\n  return true\nend", "\ta = a:lower()\n\
    \tb = b:lower()\n\tif a:sub(1,2) ~= b or a:sub(a:len()-1) ~= b then\n\t\treturn\
    \ false\n\tend\n\tlocal p1 = a:find(b,1)\n\twhile p1 do\n\t\tif a:sub(p1,p1+1+#b)~=b\
    \ then return false end\n\t\tp1 = a:find(b,p1+1+#b)\n\tend\n\treturn true\nend",
  "  local patterns = { }\n  local patlist = {}\n  for i = 1, #a do\n    table.insert(patlist,\
    \ a[i])\n    patterns[#patterns+1] = a[i]\n  end\n  local patlength = #patterns\n\
    \  for i = 1, #b do\n    local j = #patlist\n    while true do\n      local c\
    \ = b[i]\n      i = i - 1\n      if c == b[i] then\n        j = j - 1\n      else\n\
    \        break\n      end\n    end\n    if j > 0 then\n      local k = #patlist\n\
    \      while k >= j do\n        local d = patlist[k]\n        patterns[#patterns+1]\
    \ = d\n        table.insert(patlist, d)\n        k = k - 1\n      end\n    else\n\
    \      patterns[#patterns+1] = b[i]\n    end\n  end\n  for i = 1, #patterns do\n\
    \    local pattern = patterns[i]\n    local patlength = #pattern\n    for j =\
    \ 1, patlength - 1 do\n      local pattern2 = pattern:sub(1, patlength - j - 1)\n\
    \      local patlist2 = patlist\n      for k = 1, #patlist2 do\n        if patlist2[k]\
    \ == pattern2 then\n          patlist2[k + 1] = pattern\n        end\n      end\n\
    \      for k = 1, #patlist2 do\n        if patlist2[k] == pattern then\n     \
    \     patlist2[k + 1] = pattern2\n        end\n      end\n    end\n  end\n  for\
    \ i = 1, #patlist do\n    local pattern = patterns[i]\n    local patlength = #pattern\n\
    \    for j = 1, patlength - 1 do\n      local pattern2 = pattern:sub(1, patlength\
    \ - j - 1)\n      local patlist2 = patlist\n      for k = 1, #patlist2 do\n  \
    \      if patlist2[k] == pattern2 then\n          patlist2[k + 1] = pattern\n\
    \        end\n      end\n      for k = 1, #patlist2 do\n        if patlist2[k]\
    \ == pattern then\n          patlist2[k + 1] = pattern2\n        end\n      end\n\
    \    end\n  end\n  -- patternlist\n  -- a = [\n  --   \"abcd\", \"abcd\", \"abcd\"\
    , \"abcd\", \"abcd\", \"abcd\",\n  --   \"abcd\", \"abcd\", \"abcd\", \"abcd\"\
    , \"abcd\", \"abcd\",\n  --   \"abcd\", \"abcd\", \"abcd\", \"abcd\", \"abcd\"\
    , \"abcd\",\n  --   \"abcd\", \"abcd\", \"abcd\", \"abcd\", \"abcd\", \"abcd\"\
    ,\n  --   \"abcd\", \"abcd\", \"abcd\", \"abcd\", \"abcd\", \"abcd\",\n  --  \
    \ \"abcd\", \"abcd\", \"abcd\", \"abcd\", \"abcd\", \"abcd\",\n  --   \"abcd\"\
    , \"abcd\", \"", "\ta = string.match(a, \"%w+\")\n\tb = string.match(b, \"%w+\"\
    )\n\tlocal a_len = string.len(a)\n\tlocal b_len = string.len(b)\n\tlocal i = 0\n\
    \tfor i = 1, a_len-1 do\n\t\tlocal j = string.find(b, a[i], 1, a_len-1)\n\t\t\
    if j == nil then\n\t\t\treturn false\n\t\telse\n\t\t\tif j > 0 then\n\t\t\t\t\
    local j_len = string.len(string.sub(b, 1, j-1))\n\t\t\t\tif j_len == 0 then\n\t\
    \t\t\t\t-- No rotation\n\t\t\t\t\treturn true\n\t\t\t\telse\n\t\t\t\t\t-- rotation\n\
    \t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t-- no rotation\n\t\t\t\
    \treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  local tb =\
    \ b\n  local tl = a\n  while tb:len() > 0 do\n    local pos = tl:find(tb)\n  \
    \  if pos == nil then\n      return false\n    end\n    tb = tb:sub(1, pos)\n\
    \    tl = tl:sub(1, pos + 1)\n  end\n  return true\nend", "   local s = string.lower\n\
    \   if a == nil then return false end\n   if b == nil then return false end\n\
    \   if s ~= string.lower then a = s(a) end\n   if s ~= string.lower then b = s(b)\
    \ end\n   if s == string.lower then\n      a = string.gsub(a, \"^\" .. b, \"\\\
    1\")\n      b = string.gsub(b, \"^\" .. a, \"\\1\")\n   end\n   for i=1,#a do\n\
    \      if string.find(a, string.sub(b,1,i), 1) then\n         return false\n \
    \     end\n   end\n   return true\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
