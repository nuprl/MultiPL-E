name: HumanEval_80_is_happy
language: lua
prompt: "-- You are given a string s.\n-- Your task is to check if the string is happy\
  \ or not.\n-- A string is happy if its length is at least 3 and every 3 consecutive\
  \ letters are distinct\n-- For example:\n-- is_happy(a) => False\n-- is_happy(aa)\
  \ => False\n-- is_happy(abcd) => True\n-- is_happy(aabb) => False\n-- is_happy(adb)\
  \ => True\n-- is_happy(xyy) => False\nlocal function is_happy(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_happy\n\
  \    lu.assertEquals(candidate('a'), false)\n    lu.assertEquals(candidate('aa'),\
  \ false)\n    lu.assertEquals(candidate('abcd'), true)\n    lu.assertEquals(candidate('aabb'),\
  \ false)\n    lu.assertEquals(candidate('adb'), true)\n    lu.assertEquals(candidate('xyy'),\
  \ false)\n    lu.assertEquals(candidate('iopaxpoi'), true)\n    lu.assertEquals(candidate('iopaxioi'),\
  \ false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local l = 0\n    for i = 1, #s do\n        if l+3 > #s or s[l+3]\
    \ != s[l] then\n            return false\n        end\n        l = l+1\n    end\n\
    \    return true\nend", "  -- base case\n  if #s <= 3 then\n    return true\n\
    \  end\n  -- base case\n  if #s - 3 ~= #unique(s) - 3 then\n    return false\n\
    \  end\n  -- recursive case\n  return is_happy(s:sub(1, 3)) or is_happy(s:sub(3,\
    \ 6))\nend", "  local happy = false\n  for i = 1, #s do\n    if s[i] == s[i -\
    \ 1]\n     and s[i] == s[i - 2]\n     and s[i] == s[i - 3]\n     then\n      \
    \ happy = not happy\n    else\n      happy = not happy\n    end\n  end\n  return\
    \ happy\nend", "  local ok = false -- True if is happy \n  local length = 0 --\
    \ Length of string\n  local hap_count = 0 -- Number of consecutive letters that\
    \ repeat\n  for i, c in ipairs(s) do\n    length = length + 1\n    if length ==\
    \ 3 then\n      hap_count = hap_count + 1\n      if hap_count == 3 then\n    \
    \    hap_count = 0\n      end\n    end\n  end\n  if length >= 3 and hap_count\
    \ == length * 3 then\n    ok = true\n  end\n  return ok\nend", "    -- Your code\
    \ here!\n    local table = {}\n    for i = 1, #s do\n        local letter = string.sub(s,i,i)\n\
    \        if table[letter] then\n            table[letter] = table[letter] + 1\n\
    \        else\n            table[letter] = 1\n        end\n    end\n    \n   \
    \ for i = 1, #table do\n        if #table == 3 then\n            if table[table[2]]\
    \ == 1 or table[table[2]] == 2 or table[table[2]] == 3 then\n                table.clear()\n\
    \                return true\n            end\n        end\n    end", "  local\
    \ num_chars = #s\n  -- If empty string\n  if num_chars == 0 then\n    return true\n\
    \  elseif num_chars < 3 then\n    return false\n  end\n  -- Loop through string\
    \ and remove consecutive chars\n  for i = 2, num_chars do\n    if s[i-1] == s[i]\
    \ then\n      num_chars = num_chars - 1\n    end\n  end\n  return num_chars >=\
    \ 3\nend", "  assert(s:len() >= 3)\n  return s:len() >= 3 and #s:chars() == s\
    \ and #s:chars() == 3 and\n    not s:sub(3, 3):find(s:sub(1, 1))\nend\nprint(is_happy(s))",
  "  local count = 0\n  for i = 1, #s do\n    count = count + 1\n    if string.sub(s,\
    \ i, i + 3) == string.sub(s, i+1, i+4) then\n      count = count - 1\n      if\
    \ count < 3 then\n        return false\n      end\n    end\n  end\n  return true\n\
    end", "    local count = {}\n    for i=1,#s do\n        local c = s[i]\n     \
    \   -- Only add count if it's not in the count\n        if count[c] == nil then\n\
    \            count[c] = i\n        else\n            -- Add to count\n       \
    \     count[c] = count[c] + 1\n        end\n    end", "  -- base case\n  if not\
    \ s then\n    return false\n  end", "  -- BASE CASE\n  if #s < 3 or #s == 1 then\n\
    \    return false\n  end\n  \n  -- FIND THE FIRST OCCURENCE OF A CANDIDATE\n \
    \ local s = string.rep(s, 3)\n  local count = s:sub(1, 1)\n  -- CHECK IF EVERY\
    \ 3 CHARACTERS ARE UNIQUE\n  return #count == #setmetatable(s, {__index=function()\
    \ return count end})\nend", "  -- base cases\n  if(length(s) == 0) then\n    return\
    \ true\n  elseif(length(s) == 1) then\n    if(letters(s) == s) then\n      return\
    \ true\n    else\n      return false\n    end\n  elseif(length(s) == 2) then\n\
    \    local n = 0\n    while(n < #s) do\n      if(letters(sub(s, n, n+1)) == sub(s,\
    \ n, n+1) then\n        n = n + 1\n      else\n        return false\n      end\n\
    \    end\n    return true\n  end\nend", "    local happy = false\n    local count\
    \ = 1 -- number of consecutive distinct letters\n    for i = 1, #s do\n      \
    \  local letter = string.sub(s,i,i)\n        -- check if letter is different from\
    \ current one\n        if letter == string.sub(s,i,i+1) then\n            count\
    \ = count + 1\n        elseif count > 1 and count > 3 then\n            happy\
    \ = true\n            break\n        end\n        count = 1 -- reset count of\
    \ consecutive distinct letters\n    end\n    return happy\nend", "  assert(type(s)\
    \ ~= 'string')\n  -- Base case\n  if #s == 0 then return 1 end\n  -- Base case\
    \ 2\n  if #s == 1 then return 1 end\n  -- Base case 3\n  if #s == 2 then return\
    \ 1 end\n  -- Base case 4\n  if #s == 3 then return 1 end\n  -- Base case 5\n\
    \  if #s == 4 then return 1 end\n  -- Base case 6\n  if #s == 5 then return 1\
    \ end\n  -- Base case 7\n  if #s == 6 then return 1 end\n  -- Base case 8\n  if\
    \ #s == 7 then return 1 end\n  -- Base case 9\n  if #s == 8 then return 1 end\n\
    \  -- Base case 10\n  if #s == 9 then return 1 end\n  -- Base case 11\n  if #s\
    \ == 10 then return 1 end\n  -- Base case 12\n  if #s == 11 then return 1 end\n\
    \  -- Base case 13\n  if #s == 12 then return 1 end\n  -- Base case 14\n  if #s\
    \ == 13 then return 1 end\n  -- Base case 15\n  if #s == 14 then return 1 end\n\
    \  -- Base case 16\n  if #s == 15 then return 1 end\n  -- Base case 17\n  if #s\
    \ == 16 then return 1 end\n  -- Base case 18\n  if #s == 17 then return 1 end\n\
    \  -- Base case 19\n  if #s == 18 then return 1 end\n  -- Base case 20\n  if #s\
    \ == 19 then return 1 end\n  -- Base case 21\n  if #s == 20 then return 1 end\n\
    \  -- Base case 22\n  if #s == 21 then return 1 end\n  -- Base case 23\n  if #s\
    \ == 22 then return 1 end\n  -- Base case 24\n  if #s == 23 then return 1 end\n\
    \  -- Base case 25\n  if #s == 24 then return 1 end\n  -- Base case 26\n  if #s\
    \ == 25 then return 1 end\n  -- Base case 27\n  if #s == 26 then return 1 end\n\
    \  -- Base case 28\n  if #s == 27 then return 1 end\n  -- Base case 29\n  if #s\
    \ == 28 then return 1 end\n  -- Base case 30\n  if #s == 29 then return 1 end\n\
    \  -- Base case 31\n  if #s == 30 then return 1 end\n  -- Base case 32\n  if #s\
    \ == 31 then return 1 end\n  -- Base case 33\n  if #s == 32 then return 1 end\n\
    \  -- Base case 34\n  if #s == ", "  local count = 0\n  local s = s .. ''\n  --\
    \ first three letters\n  for i = 1, 3 do\n    count = count + 1\n    local first\
    \ = string.sub(s,i,i)\n    local second = string.sub(s,i,i+1)\n    local third\
    \ = string.sub(s,i+1,i+2)\n    -- check all 3 are distinct\n    if first ~= second\
    \ and second ~= third and third ~= first then\n      return false\n    end\n \
    \ end\n  if count >= 3 then\n    -- check if they 3 are same\n    local first\
    \ = string.sub(s,1,1)\n    local second = string.sub(s,1,2)\n    local third =\
    \ string.sub(s,1,3)\n    if first ~= second and second ~= third and third ~= first\
    \ then\n      return false\n    end\n  end\n  return true\nend", "    local l\
    \ = 3\n    for i = 0, #s do\n        if s[i] ~= s[(i + l) % #s] then\n       \
    \     return false\n        end\n    end\n    return true\nend", "  local n =\
    \ #s\n  return n > 0 and n >= 3 and all( { string.len(s) - 1, string.sub(s, 1,\
    \ 1); string.sub(s, 2, 2), string.sub(s, 3, 3) } )\nend", "   -- write your code\
    \ here\n   \n   return true\nend", "    if #s > 3 then return false end\n    local\
    \ last_char = s[1]\n    for i = 2, #s do\n        if s[1] == s[i - 1] then return\
    \ false end\n        last_char = s[i]\n    end\n    return true\nend", "  -- base\
    \ case\n  if not s then\n    return nil\n  elseif #s == 0 then\n    return true\n\
    \  else\n    -- split the string into three parts\n    local l, c, r = {string.sub(s,1,1)},\
    \ string.sub(s,2,2), string.sub(s,3)\n    -- check each part\n    for i = 1, #l\
    \ do\n      if l[i] ~= c[i] or c[i] ~= r[i] then\n        return false\n     \
    \ end\n    end\n    return true\n  end\nend", "  return #s > 3 and string.len(s)\
    \ >= 3 and #s == #string.gsub(s, \"(.)(.)\", \"%1\")\nend", "    local _ = {}\n\
    \    local n = #s\n    local i = 0\n    local j = 0\n    local l = 0\n    while\
    \ i < n do\n        _[#_ + 1] = s[i]\n        i = i + 1\n    end\n    i = 0\n\
    \    while j <= n do\n        if i == n then\n            return true\n      \
    \  end\n        if _[i] ~= _[j] then\n            l = l + 1\n        end\n   \
    \     i = i + 1\n        j = j + 1\n    end\n    if l > 3 then\n        return\
    \ false\n    else\n        return is_happy(\"a\" .. \"b\" .. \"c\")\n    end\n\
    end", "    local str_length = #s\n    if str_length < 3 then\n        return false\n\
    \    end\n    local visited = {}\n    local current_index = 1\n    while true\
    \ do\n        if visited[current_index] == true then\n            return true\n\
    \        end\n        if str_length > current_index + 2 then\n            visited[current_index]\
    \ = true\n            for i = current_index + 1, str_length do\n             \
    \   visited[i] = true\n            end\n        end\n        current_index = current_index\
    \ + 1\n    end\nend", "    if #s < 3 then return false end\n    if s[1] == s[2]\
    \ or s[1] == s[3] or s[2] == s[3] then return true end\n    return is_happy(s..\"\
    abcde\")\nend", "\t-- write your code here\nend", "    local count = 0\n    for\
    \ i = 1, #s do\n        count = count + 1\n        if s[i] == s[count] then count\
    \ = count + 1\n        else count = count - 1\n        end\n    end\n    return\
    \ count >= 3 and count % 3 == 0\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI don't\
    \ think this works for strings like \"aaaaaaaaaaaaaaaaa\" because you still have\
    \ the problem of comparing each character with itself. This only works for strings\
    \ that are at least 3 long.\n<|/ c |>\n<| c |>\nAh yes, you're right. I missed\
    \ that last part of the question. I'll update my answer.\n<|/ c |>\n<| a dscore=3\
    \ tags=string,lua |>\nIf you don't want to use any \"heavy\" functions:\n<code>",
  "    local length = string.len(s)\n    if length <= 3 then return false end\n  \
    \  local hash = {}\n    for _, char in string.gmatch(s, '%a') do\n        hash[char]\
    \ = true\n    end\n    local ok = true\n    for i=1,length-1 do\n        if hash[s[i]]\
    \ == true and hash[s[i+1]] ~= hash[s[i]] then ok = false end\n    end\n    return\
    \ ok\nend", "    local ls = string.len(s)\n    if ls < 3 then return false end\n\
    \    local letters = {}\n    for i=1,ls-2 do\n        if letters[s[i]:lower()\
    \ ~= s[i+1]:lower() ] then\n            return false\n        end\n        table.insert(letters,\
    \ s[i])\n    end\n    return true\nend", "  -- Base case\n  if #s <= 3 then\n\
    \    return true\n  end", "  if s == nil then\n    return nil\n  end\n  local\
    \ len = string.len(s)\n  return len >= 3 and string.gsub(s,\"(.)(.)\",\"%1%2\"\
    ) == nil\nend", "  local l=#s\n  local m=1\n  while l<=3 do\n    if #s-l>=m and\
    \ s:sub(m,#s)~=s:sub(1,m) then return false end\n    m=m+1\n  end\n  return true\n\
    end", "  local happy = true\n  for i=1,#s do\n    local t = s[i]\n    if t ~=\
    \ s[(i+1)%#s] then\n      happy = false\n    end\n  end\n  return happy and #s\
    \ ~= 3 and #(setmetatable({},{__index=function() return true end})) == 3\nend",
  "   local _,_,happy = #s, 0, 0\n   for i = 1, #s do\n      local letter = s[i]\n\
    \      if happy[happy] ~= letter then\n         happy[happy] = letter\n      \
    \   happy = happy + 1\n      else\n         happy = happy + 1\n      end\n   \
    \   if happy == 3 then\n         happy = 0\n      end\n   end\n   return happy\
    \ == 3 and #s == happy\nend", "  if #s < 3 or s[1] ~= s[2] or s[2] ~= s[3] or\
    \ s[3] ~= s[4] then\n    return false\n  end\n  local chars = {s[1],s[2],s[3],s[4]}\n\
    \  for i = 1, #chars do\n    if chars[i] ~= chars[i - 1] then\n      return false\n\
    \    end\n  end\n  return true\nend\n</cell>\n<cell>\nassert(is_happy(\"a\"))\n\
    assert(not is_happy(\"a\"))\nassert(is_happy(\"abc\"))\nassert(not is_happy(\"\
    abc\"))\nassert(is_happy(\"abcd\"))\nassert(is_happy(\"aabb\"))\nassert(is_happy(\"\
    adb\"))\nassert(not is_happy(\"xyy\"))\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a string s and returns the number of unique characters in the string.",
  "  -- your code here\n  local count = 0\n  for i = 1, #s do\n    count = count +\
    \ 1\n    if count == 3 and s[i-1] == s[i+1] then\n      count = count + 1\n  \
    \  end\n  end\n  \n  return count\nend", "  if #s < 3 then return false end\n\
    \  local function check(char, pos)\n    if pos > #s then return true end\n   \
    \ if char == s[pos] then return check(char, pos + 1) end\n    return check(char,\
    \ pos + 1)\n  end\n  return check(s[1], 1)\nend", "  local len = string.len(s)\n\
    \  return len >= 3 and all(\n    function (idx)\n      local letter = string.sub(s,idx,idx)\n\
    \      return not letters[letter]\n    end,\n    1,len-3\n  )\nend", "    local\
    \ length = #s\n    local is_happy = length > 0 and length >= 3\n    if is_happy\
    \ then\n        for i = 1, length do\n            local char = s[i]\n        \
    \    local index = i - 1\n            local next_char = s[i + 1]\n           \
    \ local next_index = i + 2\n            \n            -- If it is not distinct,\
    \ then it's happy if it has at least 3 letters and every 3 letters are distinct\n\
    \            if next_char == char then \n                if next_index - index\
    \ > 3 then \n                    is_happy = false\n                end\n     \
    \       end\n        end\n    end\n    return is_happy\nend", "   for _, c in\
    \ pairs(s) do\n      if c:byte() ~= c and c:byte() ~= c+1 and c:byte() ~= c+2\
    \ then return false end\n   end\n   return true\nend", "    local counts = {}\n\
    \    for i = 1, #s do\n        table.insert(counts, tostring(s[i])) -- tostring\
    \ converts to string and stores letters in a table\n    end\n    if #counts <\
    \ 3 then\n        return false\n    end\n    local count = 1\n    for i = 2, #s\
    \ do\n        count = count + 1\n        if counts[count - 1] == tostring(s[i])\
    \ then\n            count = count - 1\n        else\n            count = count\
    \ + 1\n        end\n    end\n    return #counts >= 3\nend", "  assert(s:len()\
    \ >= 3)\n  for i = 1, s:len() do\n    local letter = s:sub(i,i)\n    local letter2\
    \ = s:sub(i,i+1)\n    local letter3 = s:sub(i,i+2)\n    assert(letter ~= letter2)\n\
    \    assert(letter ~= letter3)\n    assert(letter2 ~= letter3)\n  end\n  return\
    \ true\nend", "  assert(type(s) ~= 'string')\n  return s:len() >= 3 and (not s:sub(1,\
    \ 2):any(function(c)\n    return string.find(string.lowercase(c), string.lowercase(c))\
    \ ~= nil\n  end)\n  and not s:sub(2, 3):any(function(c)\n    return string.find(string.lowercase(c),\
    \ string.lowercase(c)) ~= nil\n  end)\n  and not s:sub(3, 4):any(function(c)\n\
    \    return string.find(string.lowercase(c), string.lowercase(c)) ~= nil\n  end)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=lua,string,algorithm |>\nHere is a\
    \ simple solution using Lua patterns and metatables. \n<code>", "    -- Base case\n\
    \    if #s < 3 then\n        return false\n    end", "  -- base case\n  if #s\
    \ <= 3 then\n    return false\n  end", "    local n = 1\n    for i=1,#s,1 do\n\
    \        if s[i] ~= s[n-i] then\n            return false\n        end\n     \
    \   n = n + 1\n    end\n    return true\nend", "  local length = 0\n  for i=1,#s\
    \ do\n    if s[i] == s[i] then\n      length = length + 1\n    end\n  end\n  return\
    \ length > 3 and length % 3 == 0\nend", "  local length = #s\n  if length <= 3\
    \ then return false end\n  for i = 1, #s - 1 do\n    if s[1] == s[i] or s[1] ==\
    \ s[i + 1] or s[1] == s[i + 2] then return false end\n  end\n  return true\nend",
  "    local count = 0\n    local start = 1\n    local end = #s - 1\n    local s =\
    \ s\n    while start < end do\n        local a = s[start]\n        count = count\
    \ + 1\n        start = start + 1\n        if count == 3 then\n            count\
    \ = count + 1\n            if a ~= s[start] or s[start+1] or s[start+2] then\n\
    \                count = count + 1\n            end\n        end\n    end\n  \
    \  return #s >= 3 and (count == 3 or #s <= 5)\nend", "  -- base case\n  if #s\
    \ <= 0 then\n    return true\n  end\n  -- find middle index of string\n  local\
    \ middle = #s / 2\n  -- init first character and last character to 0\n  local\
    \ first_char = s[1]\n  local last_char = s[middle]\n  -- init flag\n  local flag\
    \ = true\n  -- check if string is happy or not(second character)\n  local check\
    \ = s[1]\n  -- loop through middle character\n  for i = 2, middle do\n    -- check\
    \ current character with the current character\n    if s[i] != s[i] then\n   \
    \   -- return false if they are different\n      return false\n    else\n    \
    \  -- update flag if they are the same\n      if not check then\n        -- update\
    \ the first character\n        first_char = s[i]\n        -- update the last character\n\
    \        last_char = s[i]\n        -- update the flag\n        flag = true\n \
    \     else\n        -- update the middle character\n        middle = middle\n\
    \        -- update the flag\n        flag = false\n      end\n    end\n  end\n\
    \  -- if flag is true return happy else return false\n  return flag\nend", " \
    \   local l1, l2 = #s, 3\n    local i, j\n    for i = 1, l1 do\n        for j\
    \ = 1, l2 do\n            if s[j] == s[i] and j + i < l2 and s[j + i] == s[i]\
    \ then return false end\n        end\n    end\n    return true\nend", "    if\
    \ #s < 3 then return false end\n    for i = 1, #s do\n        if string.sub(s,i,i+1)\
    \ ~= string.sub(s,i,i+1) then\n            return false\n        end\n    end\n\
    \    return true\nend", "    local l = s:len()\n    return l > 3 and l >= 3 and\
    \ (not table.remove_by_ref(s:gsub(\"(.)([^\\1])\\\\1{2,}\", \".\")))\nend", " \
    \ local function is_unique(a,b) return not (a or b) or a == b end\n  local function\
    \ is_happy_recur (s,i,count)\n    if count == 0 then\n      return true\n    end\n\
    \    count = count - 1\n    local letter = s[i]\n    i = i + 1\n    if s[i] ~=\
    \ letter then\n      is_happy_recur(s,i,count)\n    end\n    if not (count <=\
    \ 0) then\n      -- count > 0\n      if not is_unique(s[i],s[i+1]) then\n    \
    \    return false\n      end\n      i = i + 1\n      if s[i] ~= letter then\n\
    \        is_happy_recur(s,i,count)\n      end\n    end\n    return true\n  end\n\
    \  is_happy_recur(s,0,1)\nend", "  -- BASE\n  if #s <= 3 then return false end\n\
    \  local map = {}\n  for i = 1, #s do\n    local key = string.sub(s, i, i)\n \
    \   if map[key] == nil then\n      map[key] = 1\n    else\n      map[key] = map[#map]\
    \ + 1\n    end\n  end\n  if #map > 3 then return false end\n  for i = 1, 3 do\n\
    \    if map[string.sub(s, 'i', i)] ~= map[string.sub(s, 'd', i)] then return false\
    \ end\n  end\n  return true\nend\nprint (is_happy(a))\nprint (is_happy(aa))\n\
    print (is_happy(abcd))\nprint (is_happy(aabb))\nprint (is_happy(adb))\nprint (is_happy(xyy))\n\
    </cell>\n<cell>", "\t-- base case\n\tif s == \"\" then return true end\n\tlocal\
    \ tt = {s}\n\tlocal len = 0\n\twhile len < #tt do\n\t\tlocal letter = tt[len]\n\
    \t\tlocal next = tt[len+1]\n\t\t-- base case\n\t\tif len == #tt then\n\t\t\tif\
    \ letter ~= letter then return false end\n\t\t\t-- base case\n\t\t\tif letter\
    \ == next then return false end\n\t\tend\n\t\t-- recursive case\n\t\tif next ~=\
    \ letter then\n\t\t\tlen = len+1\n\t\t\ttt[len] = next\n\t\telse\n\t\t\tlen =\
    \ len+1\n\t\t\ttt[len] = next\n\t\t\ttt[len] = next\n\t\tend\n\tend\n\treturn\
    \ true\nend", "  local letters = {}\n  for _, b in ipairs(s) do\n    table.insert(letters,\
    \ b)\n  end\n  return #s >= 3 and all(letter_is_distinct(letters[{i, i + 3}],\
    \ letters[{i + 3, i + 6}], letters[{i + 6, i + 9}], letters[{i + 9, i + 12}])\
    \ for i in range(0, #letters - 3))\nend", "  return #s >= 3 and #s == #(s:gsub(\"\
    (.)\", \"%1\")) or s == \"\"\nend", "    local count = 0\n    for i = 1, #s do\n\
    \        if s[i] ~= s[count+1] then\n            count = count + 1\n        else\n\
    \            count = count + 1\n        end\n    end\n    if count == 3 then\n\
    \        for i = 1, #s do\n            if s[i] ~= s[count+1] then\n          \
    \      return false\n            end\n        end\n        return true\n    end\n\
    end", "  -- base case\n  if #s <= 0 then\n    return false\n  end\n  -- base case\n\
    \  if #s <= 3 then\n    return true\n  end\n  -- base case\n  if #s <= 5 then\n\
    \    return true\n  end\n  -- base case\n  if #s <= 8 then\n    return true\n\
    \  end\n  -- base case\n  if #s <= 11 then\n    return true\n  end\n  -- base\
    \ case\n  if #s <= 12 then\n    return true\n  end\n  -- base case\n  if #s <=\
    \ 16 then\n    return true\n  end\n  -- base case\n  if #s <= 21 then\n    return\
    \ true\n  end\n  -- base case\n  if #s <= 24 then\n    return true\n  end\n  --\
    \ base case\n  if #s <= 28 then\n    return true\n  end\n  -- base case\n  if\
    \ #s <= 49 then\n    return true\n  end\n  -- base case\n  if #s <= 50 then\n\
    \    return true\n  end\n  -- base case\n  if #s <= 70 then\n    return true\n\
    \  end\n  -- base case\n  if #s <= 80 then\n    return true\n  end\n  -- base\
    \ case\n  if #s <= 90 then\n    return true\n  end\n  -- base case\n  if #s <=\
    \ 100 then\n    return true\n  end\n  -- base case\n  if #s <= 120 then\n    return\
    \ true\n  end\n  -- base case\n  if #s <= 140 then\n    return true\n  end\n \
    \ -- base case\n  if #s <= 170 then\n    return true\n  end\n  -- base case\n\
    \  if #s <= 200 then\n    return true\n  end\n  -- base case\n  if #s <= 230 then\n\
    \    return true\n  end\n  -- base case\n  if #s <= 270 then\n    return true\n\
    \  end\n  -- base case\n  if #s <= 310 then\n    return true\n  end\n  -- base\
    \ case\n  if #s <= 360 then\n    return true\n  end\n  -- base case\n  if #s <=\
    \ 420 then\n    return true\n  end\n  -- base case\n  if #s <= 480 then\n    return\
    \ true\n  end\n  -- base case\n  if #s <= 550 then\n    return true\n  end\n \
    \ -- base case\n  if #s <= 600 then\n    return true\n  end\n  -- base case\n\
    \  if #s <= 660 then\n    return true\n  end\n  -- base case\n", "    if #s <\
    \ 3 or s[1] == 'a' or s[1] == 'e' or s[1] == 'i' or s[1] == 'o' or s[1] == 'u'\
    \ then return false end\n    local h = {}\n    for i=1,#s,3 do\n        h[string.sub(s,i,i)]\
    \ -- Check if it is a distinct letter\n    end\n    local n = #s\n    for i=n-1,1,-1\
    \ do\n        if h[string.sub(s,i,i)] then return false end\n    end\n    return\
    \ true\nend\n</code>\n<|/ a tags=string,lua-table,lua dscore=2 |>\n<| c |>\nThis\
    \ code only checks against the start of a word, rather than the whole word (e.g\
    \ `'a123'` is happy while `'a12345'` isn't). To solve this you can use the [string.match\
    \ function](http://lua-users.org/wiki/PatternsTutorial).\n<|/ c |>\n<| c |>\n\
    This doesn't work for a string `'aaaabcbaa'` - this has a length of 5, but isn't\
    \ happy.\n<|/ c |>\n<| a |>\nHere's my solution. It is a bit longer than the others,\
    \ but it is also more efficient.\n<code>", "    local l = 1\n    while l <= #s\
    \ and (l % 3 == 0 or l-1 == 1) do\n        if l-1 ~= #s then return false end\n\
    \        local n = string.sub(s, l, l)\n        if #n ~= 3 then\n            return\
    \ false\n        end\n        for i = 1, #n do\n            if n[i] ~= n[i+1]\
    \ then\n                return false\n            end\n        end\n        l\
    \ = l + 1\n    end\n    return true\nend", "    local start\n    local end\n \
    \   local cnt\n    if #s <= 3 then\n        return true\n    end\n    start =\
    \ 2\n    cnt = 1\n    while start <= #s do\n        cnt = cnt + 1\n        if\
    \ cnt == 3 then\n            if s[start] ~= s[start + 1] or s[start] ~= s[start\
    \ + 2] or s[start] ~= s[start + 3] then\n                cnt = 1\n           \
    \ end\n        else\n            if s[start] ~= s[start + 1] or s[start] ~= s[start\
    \ + 2] then\n                cnt = 1\n            end\n        end\n        if\
    \ cnt == 3 then\n            cnt = 1\n        end\n        start = start + 4\n\
    \    end\n    return cnt >= 3\nend", "    local happy = s:len() >= 3 and s:sub(1,\
    \ 3):distinct(3)\n    return happy\nend", "   local count = 0\n   for i = 1, #s\
    \ do\n      if count%3 ~= 0 then\n         return false\n      end\n      if s[i\
    \ - 1] ~= s[i - 3] then\n         count = count + 1\n      else\n         count\
    \ = count + 1\n      end\n      if s[i - 2] ~= s[i - 1] then\n         count =\
    \ count + 1\n      else\n         count = count + 1\n      end\n      if s[i -\
    \ 3] ~= s[i - 2] then\n         count = count + 1\n      else\n         count\
    \ = count + 1\n      end\n      if s[i - 4] ~= s[i - 3] then\n         count =\
    \ count + 1\n      else\n         count = count + 1\n      end\n      if s[i -\
    \ 5] ~= s[i - 4] then\n         count = count + 1\n      else\n         count\
    \ = count + 1\n      end\n   end", "   if s:len() < 3 then return false end\n\
    \   for i=3,s:len() do\n      if string.sub(s,i-1,i) ~= string.sub(s,i-1,i) then\
    \ return false end\n   end\n   return true\nend", "    local n = 1\n    for i\
    \ = 1, #s do\n        if string.sub(s,i,i) == string.sub(s,i,i-1) and string.sub(s,i,i-1)\
    \ == string.sub(s,i,i-2) and string.sub(s,i,i-2) == string.sub(s,i,i-3) then\n\
    \            n = n + 1\n        end\n    end\n    return n >= 3 and n == #s or\
    \ false\nend\nprint(is_happy(\"adb\"))\nprint(is_happy(\"abcd\"))\nprint(is_happy(\"\
    xyy\"))\nprint(is_happy(\"aabc\"))\nprint(is_happy(\"abccc\"))\nprint(is_happy(\"\
    abbbccc\"))\nprint(is_happy(\"a\"))\nprint(is_happy(\"b\"))\nprint(is_happy(\"\
    abc\"))\nprint(is_happy(\"abb\"))\nprint(is_happy(\"abbb\"))\nprint(is_happy(\"\
    abbbc\"))\nprint(is_happy(\"a\"))\nprint(is_happy(\"bb\"))\nprint(is_happy(\"\
    bbc\"))\nprint(is_happy(\"bbbb\"))\nprint(is_happy(\"bbb\"))\nprint(is_happy(\"\
    aaabb\"))\nprint(is_happy(\"aaa\"))\nprint(is_happy(\"a\"))\nprint(is_happy(\"\
    b\"))\nprint(is_happy(\"c\"))\nprint(is_happy(\"ab\"))\nprint(is_happy(\"b\"))\n\
    print(is_happy(\"b\"))\nprint(is_happy(\"bb\"))\nprint(is_happy(\"bb\"))\nprint(is_happy(\"\
    a\"))\nprint(is_happy(\"a\"))\nprint(is_happy(\"abb\"))\nprint(is_happy(\"bb\"\
    ))\nprint(is_happy(\"bb\"))\nprint(is_happy(\"a\"))\nprint(is_happy(\"b\"))\n\
    print(is_happy(\"a\"))\nprint(is_happy(\"ab\"))\nprint(is_happy(\"a\"))\nprint(is_happy(\"\
    bbb\"))\nprint(is_happy(\"abbb\"))\nprint(is_happy(\"ab\"))\nprint(is_happy(\"\
    abbb\"))\nprint(is_happy(\"abbbb\"))\nprint(is_happy(\"abbbb\"))\nprint(is_happy(\"\
    abbbbc\"))\nprint(is_happy(\"abbbcc\"))\nprint(is_happy(\"abbbccc\"))\nprint(is_happy(\"\
    abbbccc\"))\nprint(is_happy(\"abbbccc\"))\nprint(is_happy(\"abbbccc\"))\nprint(is_happy(\"\
    abbbccc\"))\nprint(is_happy(\"abbbccc\"))\nprint(is_happy(\"abbbccc\"))\nprint(is_happy(\"\
    abbbccc\"))\nprint(is_happy(\"abbbccc\"))\nprint(is_", "  s = s:lower()\n  return\
    \ s and (#s >= 3 and all (s:sub(i+1, i+4):sub(i+4)) == \"\" and s:sub(1, 3) or\
    \ false)\nend", "    -- Your code here\n    --assert(s == 'happy') -- change to\
    \ pass/fail test cases", "  local h\n  if #s < 3 then return false end\n  for\
    \ i=1,3 do\n    if s[i] ~= s[1+i] then return false end\n  end\n  for i=2,#s do\n\
    \    if s[i] ~= s[1+i] then return false end\n  end\n  return true\nend", "  \
    \ if #s < 3 then return false end\n   local last_letter = s[1]\n   for i = 2,\
    \ #s - 1 do\n      if last_letter == s[i] then\n         return false\n      else\n\
    \         last_letter = s[i]\n      end\n   end\n   return true\nend", "  local\
    \ n = #s\n  local happy = false\n  local cnt\n  for i = 1, n do\n    cnt = 1\n\
    \    for j = 1, 3 do\n      cnt = cnt * 10 + tonumber( string.sub(s,i,i+j) )\n\
    \    end\n    if cnt == n and cnt ~= n then\n      happy = true\n    end\n  end\n\
    \  return happy\nend", "  -- write your code here\n  local num_distinct = 0\n\
    \  for i = 1, #s do\n    local char = s[i]\n    if num_distinct < 3 then\n   \
    \   num_distinct = num_distinct + 1\n    else\n      if num_distinct == 3 then\n\
    \        num_distinct = num_distinct + 1\n      else\n        num_distinct = num_distinct\
    \ + 1\n      end\n    end\n  end\n  return (num_distinct == 3)\nend", "    --\
    \ Base case\n    if #s == 0 then return false\n    -- The current character\n\
    \    local c = s[1]\n    -- If the current character is the same as the previous\
    \ character\n    local is_same_prev = c == s[#s-1]\n    -- If the current character\
    \ is the same as the next character\n    local is_same_next = c == s[#s]\n   \
    \ -- If the current character is the same as the previous character and the next\
    \ character is different\n    -- and the previous character is different from\
    \ the next character\n    local is_same_next_diff = is_same_prev and not is_same_next\
    \ and s[#s-1] == s[#s]\n    -- If the current character is the same as the previous\
    \ character and the next character is different\n    -- and the previous character\
    \ is the same as the next character\n    local is_same_prev_diff = is_same_prev\
    \ and is_same_next and s[#s-1] != s[#s]\n    -- If the current character is the\
    \ same as the previous character and the next character is different\n    -- and\
    \ the previous character is the same as the next character\n    local is_same_prev_diff_next\
    \ = is_same_prev and is_same_next and not is_same_next_diff\n    -- If all previous\
    \ checks return true\n    return (#s >= 3 and is_same_prev and is_same_next_diff\
    \ and is_same_prev_diff and is_same_prev_diff_next)\nend\n</cell>\n<cell>", " \
    \   local count = 0\n    for i = 1, #s do\n        if s[i - 1] ~= s[i] then\n\
    \            count = count + 1\n        end\n    end\n    return #s >= 3 and count\
    \ >= 3\nend", "  assert(type(s) == 'string', 'is_happy() expects s argument to\
    \ be of type string')\n  return #s <= 3 and #{string.rep('a', 3)} <= #s and #{}\
    \ ~= #s\nend", "    -- base case\n    if #s < 3 then return false end", "   --\
    \ Your code here\n   return s == true or s == false\nend", "  s = s:gsub(\"(.)\"\
    ..alphabet..\"(.)\"..alphabet..\"(.)\"..alphabet..\"(.)\"..alphabet, \"%1 %2 %3\
    \ %4 %5 %6 %7 %8 %9 %10 %11 %12 %13 %14 %15\")\n  return #s >= 3 and (#(s:gsub(\"\
    %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12 %13 %14 %15\")) - #s) == 0\nend", "  local\
    \ happy = string.len(s) >= 3 and (not is_repeated_char_in_seq(string.sub(s,1,3),string.sub(s,4,string.len(s)),string.sub(s,string.len(s)-1,string.len(s)))\n\
    \  return happy\nend", "  -- Your code here\n  return string.len(s) < 3 and string.find(string.gsub(s,\
    \ '[%a]', function(c) return not string.find(string.lower(c), string.lower(string.sub(c,\
    \ 1, 2))) end), 'a'..'z') ~= nil\nend\nassert(is_happy('') == false, \"Test failed!\"\
    )\nassert(is_happy('a') == true, \"Test failed!\")\nassert(is_happy('aa') == false,\
    \ \"Test failed!\")\nassert(is_happy('abc') == true, \"Test failed!\")\nassert(is_happy('aabb')\
    \ == false, \"Test failed!\")\nassert(is_happy('adb') == true, \"Test failed!\"\
    )\nassert(is_happy('xyy') == false, \"Test failed!\")", "  -- write your code\
    \ in here\n  return true\nend", "  local n = 1\n  local last = {x = string.sub(s,1,1),\
    \ y = string.sub(s,2,2)}\n  while last ~= nil do\n    last = string.sub(s,n+1,n+3)\n\
    \    if last ~= last.x then\n      if last.x ~= last.y then\n        return false\n\
    \      end\n    else\n      if last.x ~= last.y then\n        n = n + 1\n    \
    \  end\n    end\n  end\n  return true\nend", "\t-- Write your code here.\n\tif\
    \ #s <= 3 then\n\t\treturn true\n\telse\n\t\tlocal count = 1\n\t\tfor i,v in pairs(s)\
    \ do\n\t\t\tif v == s[i] then\n\t\t\t\tcount = count + 1\n\t\t\telse\n\t\t\t\t\
    if count == 3 then\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\t\tcount = 0\n\t\
    \t\tend\n\t\tend\n\t\treturn true\n\tend\nend", "  if s == nil then return end\n\
    \  local happy = false\n  local happyCount = 0\n  for c in s:gmatch(\".\") do\n\
    \    happy = true\n    if #s > happyCount then\n      happyCount = #s\n    end\n\
    \    if #s == happyCount + 1 then\n      happyCount = #s\n    end\n    if s:sub(happyCount,\
    \ happyCount + 1) ~= c then\n      happy = false\n    end\n  end\n  return happy\n\
    end", "  local count = 0\n  for _, letter in string.gmatch(s, '[%l]+') do\n  \
    \  count = count + 1\n    if count > 2 then\n      return false\n    end\n  end\n\
    \  -- All characters are distinct, all but first are distinct, all but last are\
    \ distinct\n  if count == 1 then\n    return true\n  end\n  return false\nend",
  "   -- your code here\n   return true\nend", "  local n = 1\n  local last = {}\n\
    \  for c in string.gmatch(s, '%A') do\n    last[#last+1] = c\n    n = n + 1\n\
    \  end\n  last = last - 1\n  if #last < 3 then\n    return false\n  end\n  local\
    \ is_happy = true\n  for i = 1, #last do\n    if last[i] ~= last[i + 1] then\n\
    \      is_happy = false\n      break\n    end\n  end\n  return is_happy\nend",
  "  if s:len() < 3 then return false end\n  local map = {}\n  for i = 1, s:len()\
    \ - 2 do\n    if map[tostring(s:sub(i, i + 3))] == nil then\n      map[tostring(s:sub(i,\
    \ i + 3))] = true\n    else\n      return false\n    end\n  end\n  return true\n\
    end", "    local count = 0\n    for i=1,#s do\n        if s[i] == s[i - 1] then\n\
    \            count = count + 1\n        elseif count == 0 then\n            count\
    \ = count + 1\n        elseif count == 3 then\n            count = count + 1\n\
    \        end\n    end\n    return count >= 3 and count % 3 == 0\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nHi, I like the solution. However I don't quite understand\
    \ what is happening here. Can you please explain what happens here?", "    local\
    \ num_vowels = #vowels\n    local num_consonants = #consonants\n    local count\
    \ = 0\n    for i = 1, #s do\n        if vowels[s[i]] == 1 then\n            count\
    \ = count + 1\n        end\n    end\n    return num_vowels >= 3 and count == num_vowels\
    \ \nend\nassert(is_happy(\"abcdefghi\") == \"True\")\nassert(is_happy(\"aaa\"\
    ) == \"False\")\nassert(is_happy(\"abbcccddd\") == \"True\")\nassert(is_happy(\"\
    abbccddeee\") == \"False\")\nassert(is_happy(\"abbcccdddeeed\") == \"True\")\n\
    assert(is_happy(\"abbcccddeeee\") == \"False\")\nassert(is_happy(\"abbcccdddeeee\"\
    ) == \"False\")\nassert(is_happy(\"abbbcccddddeeee\") == \"False\")\nassert(is_happy(\"\
    abbbcccdddeeee\") == \"False\")\nassert(is_happy(\"aaabbbcccddddeeee\") == \"\
    False\")", "  -- base case\n  if #s <= 3 then return false end", "  -- base case\n\
    \  if s == \"\" then return true end\n  if #s < 3 then return false end\n  \n\
    \  local len = #s\n  local i = 0\n  local is_distinct\n  \n  while i < len do\n\
    \    is_distinct = false\n    for j = 1, i do\n      if s[i] ~= s[j] then\n  \
    \      is_distinct = true\n        break\n      end\n    end\n    if not is_distinct\
    \ then\n      return false\n    end\n    i = i + 1\n  end\n  \n  return true\n\
    end", "  local result = {}\n  local len = string.len(s)\n  if len < 3 then return\
    \ false end\n  for i = 1, len do\n    result[string.sub(s,i,i)] = 1\n  end\n \
    \ for i = 1, len do\n    if result[string.sub(s,i,i)] ~= 1 then return false end\n\
    \  end\n  return true\nend", "  return s ~= nil and string.len(s) >= 3 and all(\n\
    \    string.find(s, string.sub(s, 1, i)) ~= nil and string.find(s, string.sub(s,\
    \ i + 1, i)) ~= nil and\n    string.find(s, string.sub(s, 1, i + 1)) == nil and\
    \ string.find(s, string.sub(s, i + 1, i + 1)) == nil\n  ) \nend\n</cell>\n<cell>",
  "    local start = 0\n    local end = 0\n    for i = 1, #s do\n        -- skip first\
    \ letter\n        if start ~= 1 then\n            if s[start] == s[end] then\n\
    \                -- found same letter\n                start = start + 1\n   \
    \             -- skip to next letter\n                while end < #s and s[end]\
    \ == s[end] do\n                    start = end + 1\n                    end =\
    \ end + 1\n                end\n            else\n                -- found different\
    \ letter\n                return false\n            end\n        end\n       \
    \ -- skip last letter\n        if end < #s then\n            if s[end] ~= s[end-1]\
    \ then\n                -- found different letter\n                return false\n\
    \            end\n        end\n        -- continue checking\n        start = end\
    \ + 1\n        end = end + 1\n    end\n    -- check for last letter\n    if s[end]\
    \ ~= s[end-1] then\n        -- found different letter\n        return false\n\
    \    end\n    -- no difference\n    return true\nend\nis_happy(\"\")\nis_happy(\"\
    a\")\nis_happy(\"aa\")\nis_happy(\"abcd\")\nis_happy(\"abbd\")\nis_happy(\"adb\"\
    )\nis_happy(\"xyy\")\nis_happy(\"xyyz\")", "    if s == nil then\n        return\
    \ false\n    end\n    if #s <= 3 then\n        return true\n    end\n    local\
    \ first_letter = s[1]\n    if #s > 3 then\n        local count = 0\n        for\
    \ i = 2, #s do\n            if s[i] != first_letter then\n                return\
    \ false\n            end\n            count = count + 1\n        end\n       \
    \ return count == 3\n    else\n        return first_letter == s[2] and first_letter\
    \ ~= s[3]\n    end\nend", "  -- Write your code here\n  local count=0\n  local\
    \ temp={}\n  local happy=false\n  for i=1,#s do\n    count=count+1\n    table.insert(temp,s[i])\n\
    \  end\n  local count1=count\n  local count2=count\n  local count3=count\n  local\
    \ count4=count\n  local count5=count\n  local count6=count\n  local count7=count\n\
    \  local count8=count\n  local count9=count\n  local count10=count\n  local count11=count\n\
    \  local count12=count\n  local count13=count\n  local count14=count\n  local\
    \ count15=count\n  local count16=count\n  local count17=count\n  local count18=count\n\
    \  local count19=count\n  local count20=count\n  local count21=count\n  local\
    \ count22=count\n  local count23=count\n  local count24=count\n  local count25=count\n\
    \  local count26=count\n  local count27=count\n  local count28=count\n  local\
    \ count29=count\n  local count30=count\n  local count31=count\n  local count32=count\n\
    \  local count33=count\n  local count34=count\n  local count35=count\n  local\
    \ count36=count\n  local count37=count\n  local count38=count\n  local count39=count\n\
    \  local count40=count\n  local count41=count\n  local count42=count\n  local\
    \ count43=count\n  local count44=count\n  local count45=count\n  local count46=count\n\
    \  local count47=count\n  local count48=count\n  local count49=count\n  local\
    \ count50=count\n  local count51=count\n  local count52=count\n  local count53=count\n\
    \  local count54=count\n  local count55=count\n  local count56=count\n  local\
    \ count57=count\n  local count58=count\n  local count59=count\n  local count60=count\n\
    \  local count61=count\n  local count62=count\n  local count63=count\n  local\
    \ count64=count\n  local count65=count\n  local count66=count\n  local count67=count\n\
    \  local ", "  assert(type(s) ~= 'string')\n  local haystack = s:gsub('(.-)$','%1')\n\
    \  local needles = #haystack % 3 == 0 and haystack:sub(1,-3) or '\\0'\n  return\
    \ #needles == 3 and #haystack > 3 and #haystack:sub(1,#needles) == #needles\n\
    end", "    return #s >= 3 and check_rep(s)\nend", "  if #s < 3 then return false\
    \ end\n  local n = 1\n  while n < #s do\n    if string.sub(s, n, n + 1) == string.sub(s,\
    \ n, n + 1) then return false end\n    n = n + 1\n  end\n  return true\nend",
  "  -- Write your code here\n  local n = #s\n  return ((n>=3) and (not (n%3)) and\
    \ (not ((n:lower())..(n:lower()))))\nend", "  -- Your code here\n  local len =\
    \ string.len(s)\n  if len < 3 then return false end\n  if len == 3 then return\
    \ true end\n  local last_char, next_char = {}, {}\n  for i, v in pairs(s) do\n\
    \    if last_char[i - 1] and next_char[i + 1] then\n      if last_char[i - 1]\
    \ == next_char[i + 1] then\n        return false\n      else\n        return true\n\
    \      end\n    end\n    last_char[i] = v\n  end\nend", "    return #s >=3 and\
    \ #s % 3 == 0 and\n           map(x-> #s == 3 or x == s[3], \n               \
    \ unpack(unpack(s))\n           ) == [1,1,1]\nend", "  return #s >= 3 and (#s\
    \ - 3) == #filter(function (a) return a ~= s[a] end)\nend", "   local happi =\
    \ {}\n   for i = 1,#s do\n      table.insert(happi, s[i])\n      if i >= 3 then\
    \ return false end\n   end\n   return true\nend", "    local n = #s\n    if n\
    \ < 3 or n%3 ~= 0 then return false end\n    local i = 1\n    while i <= n do\n\
    \        local prev = s[i-1:i+1]\n        local next = s[i+2:i+3]\n        if\
    \ prev == next or prev ~= next then return false end\n        i = i + 4\n    end\n\
    \    return true\nend", "   if s ~= nil then\n      local alphabet = {}\n    \
    \  for i,c in ipairs(s) do\n         if alphabet[c] == nil then\n            alphabet[c]\
    \ = true\n         else\n            alphabet[c] = false\n         end\n     \
    \ end\n      if #alphabet >= 3 then\n         if #alphabet - 1 == #s and alphabet:sub(1,\
    \ 3) == alphabet:sub(2, 3) then\n            return true\n         end\n     \
    \ end\n   end\n   return false\nend", "    return not s and nil or #s >= 3 and\
    \ #s % 3 == 0 and \\\n        all({unpack(str:gsub(\"([%a])\", function(x)\n \
    \           return x ~= 'a' and x ~= 'z' and x ~= 'A' and x ~= 'Z'\n        end))}\
    \ == {unpack(s:gsub(\"(.)(.)\", function(x)\n            return x\n        end))})\n\
    end", "  -- Your code here\nend", "  -- Base case\n  if #s < 3 then\n    return\
    \ false\n  end", "  -- Base case\n  if s == nil then return nil\n  elseif #s <=\
    \ 3 then return true\n  -- Recursive case\n  else\n    local happy = true\n  \
    \  for i = 1, #s - 1 do\n      if s[i] != s[i] and s[i + 1] != s[i + 1] and s[i\
    \ + 1] != s[i + 1] then happy = false\n      end\n    end\n    return happy\n\
    \  end\nend\n</cell>\n<text>\nProblem 8\nGiven a binary tree and a sum, determine\
    \ if the tree adds that sum or not. A leaf is a node with no children.", "   \
    \ if #s < 3 then return false end\n    for i = 1, #s do\n        if s[i] != s[i+1]\
    \ then return false end\n    end\n    return true\nend", "  -- base case\n  if\
    \ s == nil then\n    return false\n  end\n  -- if the length is 3, then it is\
    \ a happy string\n  if s:len() >= 3 then\n    -- get the first three letter\n\
    \    local n1, n2, n3 = s:sub(1,3)\n    -- check if the three letters are distinct\n\
    \    for i = 1, 3 do\n      if s:sub(i,i) == n1 then\n        -- continue searching\n\
    \        -- if we reach this point, the first three letters are distinct\n   \
    \     return true\n      elseif s:sub(i,i) == n2 then\n        -- continue searching\n\
    \        -- if we reach this point, the second three letters are distinct\n  \
    \      return true\n      elseif s:sub(i,i) == n3 then\n        -- continue searching\n\
    \        -- if we reach this point, the third three letters are distinct\n   \
    \     return true\n      end\n    end\n    -- if n1, n2, n3 are all the same letter,\
    \ then\n    -- check if n1 is not n2, or n3 is not n2\n    local n1_not_n2 = not\
    \ (n1 == n2)\n    local n3_not_n2 = not (n3 == n2)\n    -- if n1_not_n2 and\n\
    \    -- n3_not_n2 are true, it means that n1 and n3 are not\n    -- distinct\n\
    \    return not (n1_not_n2 or n3_not_n2)\n  end\n  return false\nend", "    local\
    \ length = #s\n    if length < 3 or length % 3 ~= 0 then\n        return false\n\
    \    end\n    local letters = {}\n    for i = 1, length do\n        local letter\
    \ = string.sub(s,i,i)\n        if letters[letter] == nil then\n            table.insert(letters,letter)\n\
    \        end\n    end\n    for i = 1, length do\n        local letter = string.sub(s,i,i)\n\
    \        if letters[letter] ~= letter then\n            return false\n       \
    \ end\n    end\n    return true\nend", "  local num_distinct = nil\n  for i =\
    \ 1, #s do\n    local c = s[i]\n    if not num_distinct or num_distinct ~= c then\n\
    \      num_distinct = c\n    end\n  end", "  if s == nil then return false end\n\
    \  return string.len(s) >= 3 and (string.sub(s,1,3) ~= string.sub(s,3,6) or string.sub(s,6,9)\
    \ ~= string.sub(s,9,12) or string.sub(s,12,15) ~= string.sub(s,15,19))\nend",
  "  local count = 0\n  local index = 0\n  while index < #s do\n    if index % 3 ==\
    \ 0 then\n      if s[count] == s[count-1] and s[count] == s[count+1] and s[count]\
    \ == s[count+2] then\n        index = count + 3\n      else\n        index = count\n\
    \      end\n    elseif s[count] == s[count-1] then\n      index = count\n    end\n\
    \    count = count + 1\n  end\n  if count >= 3 then\n    return true\n  else\n\
    \    return false\n  end\nend", "  local happy = false\n  local letters = {}\n\
    \  local count = 0\n  for i = 1, #s do\n    count = count + 1\n    if count ==\
    \ 1 then\n      table.insert(letters, s[i])\n    else\n      table.insert(letters,\
    \ s[i - 1]) -- we already have this letter in the array\n    end\n    table.insert(letters,\
    \ s[i])\n  end\n  if #letters >= 3 then\n    local count2 = 0\n    for i = 1,\
    \ #letters do\n      count2 = count2 + 1\n      local char = letters[i]\n    \
    \  if not table.contains(letters, char) then -- if the char is not already in\
    \ the array\n        for j = 1, #letters do -- add all chars already in the array\
    \ to letters\n          if letters[j] == char then\n            table.insert(letters,\
    \ char)\n            break\n          end\n        end\n        if count2 == #letters\
    \ then -- if the char is in the array we dont need to check it again\n       \
    \   happy = true\n          break\n        end\n      end\n    end\n  end\n  return\
    \ happy\nend", "  -- base case\n  if #s == 0 then\n    return true\n  end", " \
    \   local happy = false\n    local len\n    -- Check for string length\n    if\
    \ #s > 0 then\n        len = #s\n    else\n        return false\n    end\n   \
    \ -- Check for all 3 letters distinct\n    for i = 1, len do\n        for j =\
    \ i + 1, len do\n            for k = j + 1, len do\n                if s[i]:lower()\
    \ ~= s[j]:lower() ~= s[k]:lower() then\n                    happy = true\n   \
    \                 break\n                end\n            end\n        end\n \
    \   end\n    return happy\nend", "   if s == nil then\n      return nil\n   end\n\
    \   local n = 3\n   local letters = {}\n   for i=1, #s do\n      letters[i] =\
    \ s[i]\n   end\n   if #letters == 0 or #letters == 1 or #letters == 2 then\n \
    \     return true\n   end\n   for i=1, #letters do\n      if letters[i] != letters[i+1]\
    \ then\n         n = n + 1\n      end\n   end\n   return n >= 3 and is_happy_helper(s,\
    \ letters, #letters, n)\nend", "  -- your code goes here\n  if #s <= 3 or #s ~=\
    \ 3 then\n    return false\n  end\n  local counts = {}\n  for i = 1, #s do\n \
    \   local c = s[i]\n    if not counts[c] then\n      counts[c] = 1\n    else\n\
    \      counts[c] = counts[c] + 1\n    end\n  end\n  local count = 0\n  for k,\
    \ v in pairs(counts) do\n    count = count + 1\n    if count ~= 3 then\n     \
    \ return false\n    end\n  end\n  return true\nend", "  s = s:gsub(\"(.-)\", function(c)\n\
    \    return (c:match(\"(.-)\"))\n  end)\n  return #s >= 3 and s:sub(1, 3) == s:sub(4)\n\
    end", "    local count = 0\n    local last_count = 0\n    for i,x in ipairs(s)\
    \ do\n        if i == 0 then\n            if x ~= last_count then\n          \
    \      count = count + 1\n            else\n                count = count\n  \
    \          end\n            last_count = x\n        elseif i == 1 then\n     \
    \       if x ~= last_count then\n                count = count + 1\n         \
    \   else\n                count = count\n            end\n            last_count\
    \ = x\n        else\n            if x ~= last_count then\n                count\
    \ = count + 1\n            else\n                count = count\n            end\n\
    \            last_count = x\n        end\n    end\n    return count > 2 and count\
    \ % 3 == 0\nend", "    local happy = false\n    local length = #s\n    for idx\
    \ = 1, length do\n        if idx == 1 then\n            -- First letter\n    \
    \        if s[1] == s[2] and s[2] == s[3] then\n                happy = happy\n\
    \            end\n        else\n            -- After the first letter\n      \
    \      if s[1] == s[2] and s[2] == s[3] then\n                if s[idx] == s[idx+1]\
    \ and s[idx+1] == s[idx+2] then\n                    -- Letter after 3rd letter\n\
    \                    happy = happy\n                end\n            end\n   \
    \     end\n    end\n    return happy\nend", "    local count = 0\n    for i =\
    \ 1, #s do\n        count = count + 1\n        if s[i] == s[i] and s[i] == s[i]\
    \ and s[i+1] == s[i+1] and s[i+1] == s[i+1] then\n            if count > 3 then\n\
    \                return false\n            end\n        else\n            if count\
    \ == 3 then\n                return true\n            end\n        end\n    end\n\
    \    return true\nend", "   if #s < 3 then return False end\n   for i=1, #s do\
    \ -- loop through all characters\n      if s[i] ~= s[i] then\n         return\
    \ false -- one letter is repeated\n      end\n   end\n   return true -- all 3\
    \ letters are distinct\nend", "    local _s = s... -- concatenate string s\n \
    \   local happy = true\n    local last_non_distinct_letter = nil\n    for i =\
    \ 1, #_s do -- loop on string s\n        local letter = _s[i]\n        if last_non_distinct_letter\
    \ ~= letter then\n            happy = not happy\n            last_non_distinct_letter\
    \ = letter\n        else\n            last_non_distinct_letter = nil\n       \
    \ end\n    end\n    return happy\nend", "  local happy = false\n  local last_letter\
    \ = nil\n  for i = 1, #s do\n    local letter = s:sub(i,i)\n    if last_letter\
    \ ~= letter then\n      happy = happy\n    else\n      happy = happy or not is_distinct(letter)\n\
    \    end\n    last_letter = letter\n  end\n  return happy\nend", "    local happy\
    \ = false\n    for i = 1, #s do\n        if s[i - 1] == s[i - 2] == s[i - 3] then\n\
    \            if s[i - 1] == s[i - 4] then\n                if s[i - 2] == s[i\
    \ - 5] then\n                    happy = true\n                    break\n   \
    \             end\n            end\n        end\n    end\n    return happy\nend",
  "    if not s then\n        return false\n    end\n    -- return true for an empty\
    \ string\n    if not s:sub(1,1) then\n        return true\n    end\n    -- length\
    \ >= 3\n    if s:len() >= 3 then\n        local n = 1\n        -- iterate through\
    \ 3 letters starting from the first letter\n        while n < 3 do\n         \
    \   if s:sub(n,n) ~= s:sub(n-1,n-1) then\n                return false\n     \
    \       end\n            n = n + 1\n        end\n    end\n    -- return true for\
    \ all other cases\n    return true\nend", "    local n = string.len(s)\n    return\
    \ n >= 3 and (n-3) ~= 0 and\n        all(string.find(string.gsub(s, {'%a'..'a'},\
    \ '*'), c) == nil for c in string.gsub(s, {'%a'..'a'}, '*'))\nend", "  local len\
    \ = #s\n  return len >= 3 and {\n      len = (len > 3 and len or 3)\n      :zip(s)\n\
    \      :map(function(pair)\n          return table.count(pair, pair[1])\n    \
    \  end)\n      :sum() % 2 == 0\n  }()\nend", "    if not s or #s <= 3 then\n \
    \       return false\n    end", "    local len = #s\n    if len < 3 then\n   \
    \     return false\n    end\n    local last_letter = nil\n    for i = 1, (len-3)\
    \ do\n        local letter = s:sub(i, i+3)\n        if letter ~= last_letter then\n\
    \            return false\n        end\n        last_letter = letter\n    end\n\
    \    return true\nend", "  -- Your code here\nend", "  if #s < 3 then return false\
    \ end\n  for idx = 1, #s do\n    if s[idx] ~= s[(idx - 1)] then\n      return\
    \ false\n    end\n  end\n  return true\nend", "    local n = 0\n    for i,x in\
    \ ipairs(s) do\n        if x == x then\n            n = n + 1\n        end\n \
    \   end\n    return n == 3 and string.match(s,'(.-)%\\2%\\2%') ~= nil\nend\n</code>\n\
    <|/ a tags=lua-patterns,lua dscore=1 |>\n<| a |>\nAs stated in the comments, your\
    \ pattern will work fine for strings of 3 characters and with 3 distinct characters.\
    \ \nBut if you have strings of any number of characters and you want the pattern\
    \ to return true, you should modify the pattern to match any string of the pattern\
    \ with three distinct characters:\n<code>", "   local hap_str = \"^[ABCDEFGHIJKLMNOPQRSTUVWXYZ]{3,}$\"\
    \n   local s = string.gsub(s, \"([\" .. hap_str .. \"]{3})\", \"\\\\1\\\\2\")\n\
    \   s = string.gsub(s, \"([\" .. hap_str .. \"]{3,})\", \"\\\\1\")\n   return\
    \ string.gsub(s, \"\\\\1\", \"[ABCDEFGHIJKLMNOPQRSTUVWXYZ]\")\nend", "  if #s\
    \ > 3 then\n    return false\n  end", "    local n = #s\n    if n == 0 then\n\
    \        return true\n    end\n    if n % 3 == 0 then\n        local a = {}\n\
    \        for i = 1, n do\n            a[#a + 1] = s[i]\n        end\n        return\
    \ #a == 3 and not is_happy(table.concat(a, \"\", 1))\n    elseif n % 3 == 1 then\n\
    \        return is_happy(table.concat(s, \"\", 1))\n    else\n        return is_happy(table.concat(s,\
    \ \"\", 2))\n    end\nend", "  -- base cases\n  if #s < 3 then\n    return false\n\
    \  elseif #s == 3 then\n    return true\n  end\n  -- recursive case\n  for i =\
    \ 2, #s do\n    if s[i-2] == s[i] and s[i-1] == s[i+1] then\n      return false\n\
    \    end\n  end\n  return true\nend", "  if s == nil then return nil end\n  local\
    \ len = 1\n  while len < 3 do\n    if #s == len then\n      len = len + 1\n  \
    \  else\n      return nil\n    end\n  end\n  local first = true\n  local last\
    \ = len - 1\n  local count = 0\n  while len >= 3 do\n    if s[last] == s[last+1]\
    \ then\n      count = count + 1\n    end\n    last = last - 1\n    if count ==\
    \ 3 then\n      return not first\n    end\n    count = count\n  end\n  return\
    \ not first\nend", "    local alphabet = {}\n    for char in s:gmatch(\"%S+\"\
    ) do\n        alphabet[#alphabet+1] = char\n    end\n    if #alphabet < 3 then\n\
    \        return false\n    end\n    local happy = true\n    for i=1, #alphabet-1\
    \ do\n        for j=i+1, #alphabet-1 do\n            if alphabet[i] ~= alphabet[j]\
    \ then\n                happy = false\n                break\n            end\n\
    \        end\n    end\n    return happy\nend", "  -- Your code here\n  local chars\
    \ = {}\n  for i = 1, #s, 2 do\n    table.insert(chars, string.sub(s,i,i))\n  end\n\
    \  return #chars >= 3 and\n          #chars == #set:distinct(chars)\nend", " \
    \ -- base case\n  if #s < 3 then\n    return false\n  end", "    return #s >=\
    \ 3 and (#s == 3 or (#s % 3 == 0 and math.random() <= 0.5))\nend\n</cell>\n<cell>",
  "  s = s:gsub('.', function (c) return #c end) -- remove all '.'\n  s = s:gsub('.',\
    \ '') -- remove all spaces\n  s = s:gsub('.', '') -- remove all '\\n'\n  return\
    \ s:len() >= 3 and #s:len()%3 == 0 -- check if string at least 3 chars\nend",
  "  if #s < 3 then\n    return false\n  elseif #s == 3 then\n    if s[1] == s[2]\
    \ and s[1] == s[3] then\n      return true\n    else\n      return false\n   \
    \ end\n  else\n    return true\n  end\nend", "    -- write your code here\n  \
    \  local result = true\n    local l\n    local k\n    for i=1,#s do\n        l\
    \ = string.sub(s, i, i)\n        local count = 0\n        for j=1,#l do\n    \
    \        if j == 1 then\n                k = l[j]\n            else\n        \
    \        k = l[j-1]\n            end\n            if k ~= l then\n           \
    \     count = count + 1\n            end\n        end\n        if count < 3 or\
    \ count == 3 then\n            result = false\n            break\n        end\n\
    \    end\n    return result\nend\nassert(is_happy(\"aa\"))\nassert(is_happy(\"\
    abb\"))\nassert(is_happy(\"a\"))\nassert(is_happy(\"aaaa\"))\nassert(is_happy(\"\
    aaab\"))\nassert(is_happy(\"ab\"))\nassert(is_happy(\"abcd\"))\nassert(is_happy(\"\
    abcdd\"))\nassert(is_happy(\"xyy\"))\nassert(not is_happy(\"aba\"))\nassert(not\
    \ is_happy(\"ada\"))\nassert(not is_happy(\"abx\"))", "  return s ~= nil and (#s\
    \ >= 3 and (#s mod 3) == 0 and #(setmetatable(s, { __mode = \"k\" })) == 3)\n\
    end\n</cell>\n<code language=julia-1.4>\nprintln(is_happy(\"happy\"))\nprintln(is_happy(\"\
    happyay\"))\nprintln(is_happy(\"happyay\"))\nprintln(is_happy(\"happyayay\"))\n\
    </cell>\n<text>\n4. Longest common substring", "    local function is_distinct(str)\n\
    \        return str:sub(1, 2) ~= str:sub(2, 3)\n    end\n    return s:len() >=\
    \ 3 and (string.sub(s, 1, 3):filter(is_distinct):len() == s:len() * 3)\nend",
  "  local alphabet = {}\n  for _ = 1, #s do\n    table.insert(alphabet, string.byte(s,_))\n\
    \  end\n  local l = 3\n  local c = 1\n  while l < #alphabet:len() do\n    if string.byte(s,l)\
    \ == alphabet[c] then\n      c = c + 1\n    else\n      l = l + 1\n    end\n \
    \ end\n  local happy = (#alphabet:len() >= 3 and l == #alphabet)\n  return happy\n\
    end\nprint (is_happy('hello'))\nprint (is_happy('hellooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
  "  if #s < 3 then return false end\n  local new_s = {}\n  for i=1,#s do\n    local\
    \ letter = s[i]\n    if new_s[letter] ~= letter then\n      if new_s[letter] ~=\
    \ nil then return false end\n      new_s[letter] = letter\n    end\n  end\n  if\
    \ #new_s < 3 then return false end\n  for i=3,#s do\n    local letter = s[i]\n\
    \    if new_s[letter] == letter then return false end\n  end\n  return true\n\
    end", "  local n = #s\n  local count = 0\n  local prev = \"\"\n  for i = 1,n do\n\
    \    if prev == s[i-1] then\n      count = count + 1\n    elseif prev == s[i]\
    \ then\n      count = count - 1\n    else\n      count = 0\n    end\n    prev\
    \ = s[i]\n  end\n  return count >= 2 and count == n\nend", "  if s:len() < 3 then\n\
    \    return false\n  end\n  local count = 1\n  for i=1,#s do\n    if s[i] ~= s[count]\
    \ then\n      return false\n    end\n    count = count+1\n  end\n  return true\n\
    end", "  -- base case\n  if #s == 0 then\n    return true\n  end", "  if #s <\
    \ 3 then return false end\n  for i = 1, #s do\n    local letter = string.sub(s,i,i)\n\
    \    if i == 1 then\n      if letter == letter then\n        return false\n  \
    \    else\n        return true\n      end\n    end\n    if letter == letter then\n\
    \      return false\n    end\n  end\n  return true\nend", "    local len = #s\n\
    \    if len < 3 then return false end", "  local happy = false\n  local count\
    \ = 1\n  for i = 1, #s do\n    if s[count] == s[count+1] then count = count +\
    \ 2 end\n    if count == 3 then happy = true break end\n    count = count + 1\n\
    \  end\n  return happy\nend", "  -- base case\n  if #s <= 3 then return false\
    \ end\n  \n  -- find all consequtive 3 letters and check if they are distinct\n\
    \  for i = 1, #s - 1 do\n    if s[i] == s[i+1] then return false end\n    if s[i]\
    \ != s[i+1] then return false end\n  end\n  \n  -- if we reach here then we have\
    \ found a happy string\n  return true\nend", "  return s:len() >= 3 and\n    all(isletter(s)\
    \ for s = s:sub(1,2))\nend", "  if s == \"\" then\n    return true\n  end\n  \n\
    \  local l1 = s:len()\n  if l1 == 0 then\n    return true\n  end\n  \n  local\
    \ l2 = s:len()\n  if l2 == 0 then\n    return true\n  end\n  \n  local l3 = s:len()\n\
    \  if l3 == 0 then\n    return true\n  end\n  \n  for i=1,l3 do\n    if string.sub(s,i,i+1)\
    \ ~= string.sub(s,i,i+1) then\n      return false\n    end\n  end\n  \n  return\
    \ true\nend", "    local count = 0\n    for i, c in string.gmatch(s, '%C') do\n\
    \        if c == c then\n            count = count + 1\n        else\n       \
    \     count = 0\n        end\n    end\n    return count >= 3 and count == string.len(s)\
    \ and (string.find(s, '^(.)\\1$', 1, true) or true)\nend", "  local happy = false\n\
    \  for i=1,#s do\n    if s[i] ~= s[i +1] then return false end\n    if s[i +1]\
    \ ~= s[i +2] then return false end\n    happy = true\n  end\n  return happy\n\
    end", "  local len = #s\n  local count = 0\n  local l = 1\n  for i = 1, len do\n\
    \    if s[i] == s[i - 1] or s[i] == s[i - 2] or s[i] == s[i - 3] then\n      count\
    \ = count + 1\n      if count == 3 then return true end\n    end\n    l = l +\
    \ 1\n  end\n  return false\nend", "   -- write your code in C# here\nend", " \
    \   if not s:len() then\n        return false\n    end\n    local last_char =\
    \ {}\n    local length = s:len()\n    for i = 1, length do\n        last_char[i]\
    \ = s:sub(i-1, i)\n    end\n    if length < 3 then\n        return false\n   \
    \ end\n    local seen = {}\n    for i = 1, length do\n        for j = 1, length\
    \ do\n            if i > j then\n                local l1 = last_char[i]\n   \
    \             local l2 = last_char[j]\n                if l1~=l2 and seen[l1]\
    \ then -- if both are same and first one was seen earlier\n                  \
    \  return false\n                end\n                seen[l1] = true\n      \
    \      end\n        end\n    end\n    return true\nend", "  local num_chars =\
    \ #s\n  if num_chars < 3 or num_chars % 3 ~= 0 then\n    return false\n  end\n\
    \  local s_sorted = s:gsub(\"([^\" .. string.char(string.char(\"a\") .. string.char(\"\
    z\"))) .. \" .. ([^\" .. string.char(string.char(\"a\") .. string.char(\"z\"))\
    \ .. \"])\", \"%1\")\n  for i = 1, num_chars do\n    if s_sorted ~= string.sub(s_sorted,i,i)\
    \ then\n      return false\n    end\n  end\n  return true\nend", "    -- Write\
    \ your code in Lua 5.3 or higher.\n    -- Do not use any string library functions\
    \ (in other words, do not write \"string.len\" or similar things).\n    -- Return\
    \ True if the string is happy and False otherwise.\n    local happy = false\n\
    \    local len = string.len(s)\n    local i, j = 1, len\n    while i <= len and\
    \ j <= len do\n        if s[i] == s[j] then\n            i = i + 1\n         \
    \   j = j + 1\n        else\n            i = i + 1\n            j = j - 1\n  \
    \          if i <= j then\n                happy = true\n            end\n   \
    \     end\n    end\n    return happy\nend", "    local is_happier = true\n   \
    \ for i=1,#s do\n        if s[i]~=s[i+2] then\n            is_happier = false\n\
    \            break\n        end\n    end\n    return is_happier\nend", "    local\
    \ n = string.len(s)\n    return n > 3 and #is_distinct(s, 1, n - 3) == n\nend",
  "    if #s <= 3 then\n        return true\n    end", "  -- Base Case\n  if #s <=\
    \ 0 then\n    return true\n  elseif #s >= 3 then\n    return #s >=3 and #s % 3\
    \ == 0 and #s == sum(string.chars(s))\n  else\n    return false\n  end\nend",
  "    -- base case\n    if #s < 3 then return false end\n    -- if three consecutive\
    \ letters are distinct\n    local alphabet = {}\n    for i = 1, #s do\n      \
    \  alphabet[string.sub(s, i, i)] = 1\n    end\n    -- check if at least 3 distinct\
    \ letters exists\n    for i = 1, #alphabet - 1 do\n        if alphabet[i] == 1\
    \ then\n            return false\n        end\n    end\n    return true\nend",
  "    if #s < 3 then\n        return false\n    end\n    local n = 1\n    for i =\
    \ 1, #s do\n        local char = s[i]\n        -- if not char then return\n  \
    \      if char ~= s[i - 1] then\n            n = n + 1\n            if n % 3 =\
    \ 0 then\n                -- if char == s[i - 1] then\n                return\
    \ false\n            end\n        end\n    end\n    return true\nend", "  -- Write\
    \ your code here\n  local length = 0\n  for _, c in pairs(s) do length = length\
    \ + 1 end\n  return length >= 3 and length == (3 * #s) / 3\nend", "    local c1\
    \ = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local c2 = {'a',\
    \ 'b', 'c','d', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local c3 = {'a', 'b', 'c',\
    \ 'd','e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local c4 = {'a', 'b', 'c', 'd','e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'}\n    local c5 = {'a', 'b', 'c', 'd','e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'}\n    local c6 = {'a', 'b', 'c', 'd','e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\
    \ 'z'}\n    local c7 = {'a', 'b', 'c', 'd','e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n\
    \    local c8 = {'a', 'b', 'c', 'd','e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local\
    \ c9 = {'a', 'b', 'c', 'd','e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local c10 = {'a',\
    \ 'b', 'c', 'd','e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local c11 = {'a', 'b', 'c',\
    \ 'd','e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local c12 = {'a', 'b', 'c', 'd','e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'}\n    local c13 = {'a', 'b', 'c', 'd','e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', '", "  if #s < 3 then return false end\n  local\
    \ visited = {}\n  local function is_happy_helper(pos, count)\n    if pos > #s\
    \ or visited[pos] then return false end\n    if count == 3 then return true end\n\
    \    visited[pos] = true\n    return is_happy_helper(pos+1, count+1)\n  end\n\
    \  return is_happy_helper(1, 1)\nend", "  -- base case\n  if #s <= 3 then return\
    \ false end\n  -- check non-consecutive letters\n  if is_happy(s[#s-3]) and is_happy(s[#s-2])\
    \ and is_happy(s[#s-1]) then return false end\n  return true\nend\nassert(is_happy(s))",
  "  if #s <= 3 then\n    return false\n  end\n  local alphabet = {}\n  for i = 1,\
    \ #s do\n    alphabet[string.sub(s,i,i)] = true\n  end\n  for i = 1, #s do\n \
    \   for j = i+1, #s do\n      if alphabet[i] and alphabet[j] then\n        return\
    \ false\n      end\n    end\n  end\n  return true\nend", "    local len = #s\n\
    \    return (len >= 3 and len % 3 == 0) and all(x:find(s) do\n        local letter\
    \ = s:sub(i,i)\n        return not(letter:find(letter))\n        for i=i+1,len-1\
    \ do\n            local letter = s:sub(i,i)\n            return not(letter:find(letter))\n\
    \        end\n    end)\nend\nassert(is_happy(\"a\")==false,\"false\")\nassert(is_happy(\"\
    aa\")==false,\"false\")\nassert(is_happy(\"abcd\")==true,\"true\")\nassert(is_happy(\"\
    aabb\")==false,\"false\")\nassert(is_happy(\"adb\")==true,\"true\")\nassert(is_happy(\"\
    xyy\")==false,\"false\")", "    local happy = false\n    for letter in s:gmatch(\"\
    [a-z]+\") do\n        happy = happy and letter ~= letter\n    end\n    return\
    \ happy and s:len() >= 3 and not s:sub(1,3) ~= s:sub(3,3)\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\n<code>", "  local counts = {}\n  for i = 1,#s do\n    counts[s[i]]=counts[s[i]]+1\n\
    \  end\n  \n  return #counts>=3 and #counts ~= #s and counts[1] == counts[#counts]\n\
    end", "  local length = #s\n  if length <= 3 then\n    return true\n  end", " \
    \  -- base case\n   if #s <= 3 then\n      return false\n   end", "  -- base case\n\
    \  if #s <= 3 then\n    return true\n  end", "  local ok, s, i = 1, s, 1\n  while\
    \ i <= #s do\n    if not ok or tonumber(s[i:i+1]) ~= tonumber(s[i-1:i+2]) then\n\
    \      ok = false\n    end\n    i = i + 1\n  end\n  return ok\nend", "    if #s\
    \ <= 3 then\n        return true\n    end\n    local len = #s\n    local result\
    \ = true\n    for i=1,len-1 do\n        local j = i+1\n        local k = j+1\n\
    \        local count = 0\n        for _,c in pairs(s) do\n            if c ==\
    \ s[i] then\n                count = count + 1\n                if count == 3\
    \ then\n                    result = false\n                    break\n      \
    \          end\n            end\n        end\n    end\n    return result\nend",
  "  -- code here\n  -- code here\nend", "    local n = 1\n    for i = 1, #s do\n\
    \        if s[n] ~= s[n] then\n            n = n + 1\n        else\n         \
    \   n = 1\n        end\n    end\n    return n >= 3 and n == #s or false\nend",
  "    local h3\n    local h4", "  -- base cases\n  if #s <= 3 then return true end",
  "    local result = true\n    for i = 1, #s do\n        local curr = s:sub(i,i)\n\
    \        for j = i + 1, #s do\n            local next = s:sub(j,j)\n         \
    \   if curr == next then\n                result = false\n            end\n  \
    \      end\n    end\n    return result\nend", "    local counts = {}\n    for\
    \ i = 1, #s do\n        if counts.hasOwnProperty(s[i]) then\n            counts[s[i]]\
    \ = counts[s[i]] + 1\n        else\n            counts[s[i]] = 1 \n        end\n\
    \    end\n    return #counts >= 3 and counts[1] == counts[#counts] -- length >=3\
    \ and counts[1] == counts[#counts]\nend", "  if #s < 3 then return false end\n\
    \  local function helper (s, n, i, h)\n    if #s < n then return false end\n \
    \   if #s > n then return false end\n    if h == nil then return true end\n  \
    \  if s[i] ~= h or helper(s, n, i + 1, h) then return false end\n    return true\n\
    \  end\n  return helper(s, 3, 1, nil)\nend", "    if #s <= 3 then return false\
    \ end\n    local i, j = 1, 1\n    for _,c in string.gmatch(s, \"%S\") do\n   \
    \     if c ~= s[i] and s[i+1] ~= c and s[j] ~= c then\n            return false\n\
    \        end\n        i = i + 1\n        j = j + 1\n    end\n    return true\n\
    end", "  -- base case\n  if #s < 3 or #s ~= (#s)^3 then return false end", " \
    \   local n = #s\n    if n < 3 then\n        return false\n    end\n    local\
    \ ok, cnt = {}, 0\n    for i = 1, #s do\n        if cnt > 1 then\n           \
    \ cnt = 1\n        end\n        if s[i] ~= s[i - cnt] then\n            cnt =\
    \ 1\n        else\n            cnt = cnt + 1\n        end\n    end\n    return\
    \ cnt == n\nend", "  local count = 0\n  for i=1,#s do\n    count = count + 1\n\
    \    if count > 3 then\n      count = count - 1\n    end\n    if s[i] == s[i]\
    \ then\n      count = count - 1\n    end\n  end\n  return count >= 3 or string.rep(\"\
    z\", #s)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
