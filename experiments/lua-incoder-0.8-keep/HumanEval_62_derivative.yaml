name: HumanEval_62_derivative
language: lua
prompt: "-- xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n-- Return derivative of this polynomial in the same form.\n-- >>>\
  \ derivative([3, 1, 2, 4, 5])\n-- [1, 4, 12, 20]\n-- >>> derivative([1, 2, 3])\n\
  -- [2, 6]\nlocal function derivative(xs)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = derivative\n\
  \    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})\n    lu.assertEquals(candidate({1,\
  \ 2, 3}), {2, 6})\n    lu.assertEquals(candidate({3, 2, 1}), {2, 2})\n    lu.assertEquals(candidate({3,\
  \ 2, 1, 0, 4}), {2, 2, 0, 16})\n    lu.assertEquals(candidate({1}), {})\nend\n\n\
  os.exit(lu.LuaUnit.run())"
completions: ["  if #xs < 1 then return nil end\n  return xs[1] * derivative(xs[2:])\
    \ or 1\nend", "  local d\n  for i = 1, #xs do\n    if i == 1 then\n      d = 1\n\
    \    else\n      d = d * xs[i]\n    end\n  end\n  return d\nend", "  if xs ==\
    \ nil then\n    return nil\n  elseif #xs == 0 then\n    return [0]\n  else\n \
    \   local n = #xs\n    local d\n    local k\n    -- create result vector for derivative\n\
    \    d = {xs[1]}\n    -- create k for kth degree of x^k\n    for k = 2, n do\n\
    \      d[k] = 0\n      for i = 1, k do\n        d[k] = d[k] + xs[i] * d[k - i]\n\
    \      end\n    end\n    return d\n  end\nend", "  local n = #xs\n  assert(n >\
    \ 0, \"At least 2 arguments required.\")\n  if n == 1 then\n    local x = xs[1]\n\
    \    local deriv = 0\n    for i = 1, n do\n      deriv = deriv + xs[i] * i\n \
    \   end\n    return deriv\n  end\n  local y = {}\n  local d\n  for i = 1, n do\n\
    \    local x = xs[i]\n    local dn = 1\n    for j = 1, i do\n      dn = 1 * dn\
    \ + xs[j] * y[j]\n    end\n    table.insert(y, dn)\n  end\n  if n == 1 then\n\
    \    return y[1]\n  end\n  d = {}\n  for i = 1, n do\n    table.insert(d, y[i]\
    \ * derivative(xs)[i])\n  end\n  return d\nend", "    if not xs then\n       \
    \ return nil\n    end\n    local n = #xs - 1\n    local x = 1\n    local f = 0\n\
    \    for i = 1, n do\n        f = f * x + xs[i]\n        x = x\n    end\n    return\
    \ f\nend", "  -- Compute xs[-1] * xs[-2] * ... * xs[0]\n  -- using Horner's method.\n\
    \  -- See \"Implementing the derivative of a polynomial at a point \" by\n  --\
    \ Steven L. Johnson, 2002, page 287\n  if #xs == 0 then\n    return [0]\n  end\n\
    \  local d = 0\n  for i = 1, #xs do\n    local x = xs[i]\n    local factor = 1\
    \ + d\n    d = d * x\n    if i % 2 == 1 then\n      d = d * x\n    end\n    factor\
    \ = factor * x\n    if xs[i] != 0 then\n      factor = factor * x\n    end\n \
    \   xs[i] = factor\n  end\n  return d\nend", "  local n = 1\n  local i = 1\n \
    \ local derivative = { xs[1] }\n  for i = 2, #xs do\n    derivative[i] = ((n -\
    \ 1) * xs[i] + derivative[i-1]) / n\n    n = n + 1\n  end\n  return derivative\n\
    end", "  local d = 0\n  local j = 1\n  local i = 1\n  for i = 1, #xs do\n    if\
    \ i == 1 then\n      d = xs[i] - 1\n    else\n      d = d + (xs[i] - 1) * j\n\
    \    end\n    j = j * (xs[i] - 1)\n  end\n  return d\nend", "  if xs == nil then\
    \ return nil end\n  assert(#xs > 0)\n  if xs[1] == 0 then return xs end\n  if\
    \ xs[1] == 1 then return [-xs[2] / xs[1]] end\n  local k = 1\n  local sum = 0\n\
    \  local i = 1\n  while i < #xs do\n    sum = sum + xs[i] * xs[k]\n    k = k +\
    \ 1\n    if k > 2 then\n      k = k - 1\n    end\n    i = i + 1\n  end\n  return\
    \ [-sum / xs[1]]\nend", "  if not xs then return false end\n  local n = #xs -\
    \ 1\n  local p = {}\n  -- For each term, xs[k] * y^k\n  for k = 1, n do\n    p[k]\
    \ = xs[k] -- p[k] is xs[k], but use it to access y\n    -- p[k] = y^k, p[k] is\
    \ coefficient of y^k\n    -- p[k] ~= xs[k] * y^k, y^k is coefficient of xs[k]\n\
    \  end\n  -- p[n] = y^n, xs[n] is coefficient of y^n\n  p[n] = xs[n]\n  return\
    \ p\nend", "  assert(#xs == 1)\n  local x = xs[1]\n  local f = 1\n  for i = 2,\
    \ #xs do\n    f = f * (x - xs[i - 1])\n  end\n  return f\nend", "  assert(#xs\
    \ > 0, \"derivative needs at least one argument\")\n  local d = 0\n  local xprev\
    \ = xs[1]\n  local xfirst = xs[1]\n  for i = 2, #xs do\n    d = d * xprev + xs[i]\n\
    \    xprev = xs[i]\n  end\n  return d\nend", "    if not xs or #xs == 0 then\n\
    \        return []\n    end\n    local dp = [1]\n    for i=1,#xs do\n        dp[1]\
    \ = dp[1] * xs[i] + dp[1]\n    end\n    return dp\nend\n</code>\n<|/ a dscore=4\
    \ tags=lua,matrix,linear-algebra,arrays,algorithm |>\n<| a |>\nThis is a good\
    \ question, since I was going to write a solution for it, which is basically the\
    \ same as the one you already posted but with more functionality.\nSo I wrote\
    \ a library which you can use to easily perform matrix operations (additions,\
    \ multiplications, etc) between Lua matrices and matrices, as well as determinants\
    \ (determinant of a square matrix), and inverses (inverse of a matrix).\nHere\
    \ is the library (I'm the author):\nhttps://github.com/danijar/lua-matrices\n\
    Here is a tutorial for working with matrices in Lua:\nhttps://lua-users.org/wiki/MatricesTutorial\n\
    Here is a tutorial for determinants:\nhttps://math.mit.edu/~dw/webmath/examples/determinant.html\n\
    Here is a tutorial for inverses:\nhttps://math.mit.edu/~dw/webmath/examples/inverse.html\n\
    <|/ a tags=lua,matrix,linear-algebra,arrays,algorithm dscore=4 |>\n<| a dscore=3\
    \ |>\nHere's a short recursive implementation of determinant. \n<code>", "  local\
    \ d = 0\n  for _, x in ipairs(xs) do d = d * x + x end\n  return d\nend", "  \
    \  if #xs == 0 then\n        return nil\n    end\n    local result = {xs[1]}\n\
    \    for i = 2, #xs do\n        result[1] = result[1] + (xs[i] - result[1]) /\
    \ (xs[i-1] - xs[i-2])\n    end\n    return result\nend", "  -- If list has 1 element,\
    \ return first element twice.\n  if #xs == 1 then\n    return [xs[1], xs[1]]\n\
    \  end", "  if not xs then return nil end\n  if xs[1] == 0 then return [] end\n\
    \  return xs[1] * derivative(xs[2])\nend", "  return xs:gsub('([-+]?%d*)', function(a,\
    \ b) return a * b end):gsub('([-+]?%d*)', function(a, b) return b * a end):gsub('%d*',\
    \ function(a, b) return a * b end)\nend", "  if xs == [] then\n    return []\n\
    \  end", "  if xs[1] == 0 then -- 0th derivative is a constant.\n    return x\n\
    \  elseif xs[2] ~= 0 then -- 1st derivative is linear.\n    return [xs[1], xs[2]]\n\
    \  else\n    local i = 0\n    local j = 1\n    local cj = 1\n    local x = xs[i]\n\
    \    local cx = xs[i]\n    local h = 1 - cx -- h is used to determine new value\
    \ of x.\n    while cj >= 0 do\n      cj = cj - 1\n      x = x * x + cx\n     \
    \ cx = x * h + cj\n      i = i + 1\n      j = j + 1\n      if i == #xs then\n\
    \        i = i - 1\n        j = j + 1\n        if j == #xs then -- base case\n\
    \          cj = cj + 1 -- next value of cj\n        end\n      end\n    end\n\
    \    return [x] -- return derivate in the same form as input\n  end\nend", " \
    \ if #xs == 0 then return nil end\n  local dp = [1]\n  local x = xs[1]\n  local\
    \ d = 0\n  for i = 2, #xs do\n    local y = xs[i]\n    local tmp = d\n    d =\
    \ d + y * (x - 1)\n    x = tmp\n    dp[i] = d\n  end\n  return dp\nend", "   \
    \ local d = 0\n    for i = 1, #xs do\n        d = d * xs[i]\n    end\n    return\
    \ d\nend", "  if xs == nil then\n    return nil\n  elseif #xs < 2 then\n    return\
    \ nil\n  elseif #xs == 2 then\n    return [1]\n  else\n    local n = #xs - 1\n\
    \    local result = {}\n    result[1] = x[1]\n    for i = 2, n do\n      result[i]\
    \ = x[i]\n      result[i + 1] = result[i] ^ xs[i]\n    end\n    return result\n\
    \  end\nend", "  if #xs == 1 then\n    return [1]\n  end", "  assert(#xs > 0)\n\
    \  local result = {}\n  result[1] = xs[1]\n  for i=2,#xs do\n    result[i] = xs[i]\n\
    \    result[i-1] = result[i]\n  end\n  return result\nend", "  if xs[1] == 0 then\n\
    \    error(\"xs must have more than one term.\")\n  end", "   if xs == nil then\
    \ return nil end\n   if #xs == 1 then\n      return [1]\n   end\n   local deriv\
    \ = xs[1]\n   for i = 2, #xs do\n      deriv = deriv * xs[i]\n   end\n   return\
    \ deriv\nend", "  if #xs == 0 then\n    return [0]\n  else\n    if xs[1] == 0\
    \ then\n      return derivative(xs)\n    else\n      local div = xs[1]\n     \
    \ local dpdx = {}\n      dpdx[1] = xs[2]\n      for i = 2, #xs do\n        div\
    \ = div * xs[i]\n        dpdx[i + 1] = div\n      end\n      return dpdx\n   \
    \ end\n  end\nend", "   if xs == nil then\n      return nil\n   end\n   return\
    \ xs[1] - xs[2] * xs[1] + xs[3] * xs[1] * xs[2] + xs[4] * xs[1] * xs[2] * xs[3]\
    \ -- the first derivative\nend", "  assert(#xs > 0)\n  if #xs == 1 then\n    return\
    \ [1]\n  end\n  local r = {}\n  for i = 1, #xs do\n    table.insert(r, 2 * xs[i\
    \ - 1] + xs[i])\n  end\n  return r\nend", "  assert(type(xs) == 'table')\n  local\
    \ d = {}\n  local count = 0\n  -- Reverse xs so that we can start from last element\
    \ and work backwards.\n  -- This way we'll have smaller polynomial as a result.\n\
    \  for i = #xs - 1, 1, -1 do\n    count = count + 1\n    table.insert(d, 0, xs[i])\n\
    \    for j = #xs - 1, 1, count do\n      table.insert(d, xs[j] * xs[i - j])\n\
    \    end\n  end\n  return d\nend", "  local d = {}\n  for i=1,#xs do\n    d[i]\
    \ = xs[i+1]\n  end\n  return d\nend", "    local xlen = #xs\n    local result\
    \ = {}\n    for i = 1, xlen do\n        local x = xs[i]\n        result[i] = 1\n\
    \        for k = i + 1, xlen do\n            result[i] = result[i] + x * xs[k]\n\
    \        end\n    end\n    return result\nend", "  if #xs < 2 then\n    return\
    \ nil\n  end\n  return xs[#xs] - derivative(sublist(xs, 1, #xs - 1))\nend", " \
    \ if xs[1] == 0 then\n    return []\n  else\n    local n = #xs - 1\n    local\
    \ x = xs[n]\n    local d = [1]\n    for i = 1, n do\n      d = d * x\n    end\n\
    \    d:resize(n + 1, 1)\n    d[n + 1] = x\n    return d\n  end\nend", "  return\
    \ xs:reverse():map(function(x)\n    return x * x\n  end)\nend", "    local d =\
    \ 0\n    for i = 1, #xs do\n        d = d * xs[i] -- d *= x[i]\n    end\n    return\
    \ d\nend", "  local n = 1\n  local deriv = xs[1]\n  for i = 2, #xs do\n    n =\
    \ n * xs[i]\n    deriv = deriv + xs[i] * n\n  end\n  return deriv\nend", "  local\
    \ n = #xs + 1\n  local deriv = xs[n]\n  if n > 1 then\n    deriv = deriv * derivative(xs[1:n])\n\
    \  end\n  return deriv\nend", "  if xs[1] == 0 then\n    return {}\n  else\n \
    \   -- The last element is the coefficient of the polynomial before the last term\n\
    \    local coeff = xs[#xs]\n    local terms = { coeff, xs[#xs-1] }\n    local\
    \ dterms = { coeff }\n    for i = #xs, 1, -1 do\n      dterms = { xs[i-1] * terms[1]\
    \ + dterms[1] }\n    end\n    return dterms\n  end\nend", "  if xs == nil then\
    \ return nil end\n  if xs[1] == 0 then return [nil]\n  elseif xs[1] == 1 then\
    \ return [xs[1]]\n  elseif xs[2] == 0 then return [derivative(xs)[1]] * xs[1]\n\
    \  elseif xs[2] == 1 then return [derivative(xs)[1] * xs[1]]\n  elseif xs[3] <=\
    \ 0 and xs[2] ~= 0 then return derivative([xs[1], xs[2] / xs[3]]) --\n  elseif\
    \ xs[3] == 0 then return [derivative([xs[1], xs[2] / xs[3]])[1]]\n  else return\
    \ [derivative([xs[1], xs[2] / xs[3]])[1]\n             , derivative([xs[1], xs[2]\
    \ / xs[3]])[2]]\n  end\nend", "  local d = {}\n  if xs == nil then return d end\n\
    \  local n = #xs\n  if n == 0 then return d end\n  assert(n >= 1)\n  local result\
    \ = {}\n  local x = xs[1]\n  result[1] = xs[1]\n  local i = 2\n  for i = 3, n+2\
    \ do\n    result[i] = result[i-1]*x + xs[i-1]\n  end\n  result[n+1] = 1\n  return\
    \ result\nend", "  if xs == nil then return nil end\n  local d = {}\n  local i\
    \ = 1\n  while i < #xs do\n    if i == 1 then\n      table.insert(d, xs[1] / xs[i])\n\
    \    else\n      table.insert(d, xs[i] / xs[i - 1])\n    end\n    i = i + 1\n\
    \  end\n  return d\nend", "  assert(#xs > 0)\n  if #xs == 1 then\n    return [1]\n\
    \  elseif #xs == 2 then\n    return [xs[1] - xs[1]*xs[0]]\n  else\n    local poly\
    \ = [xs[1] - xs[1]*xs[0]]\n    for i = 2, #xs do\n      poly = poly .. \", \"\
    \ .. xs[i]*xs[i]\n    end\n    return poly\n  end\nend", "  local n = #xs\n  if\
    \ n == 0 then\n    return {}\n  end\n  -- Return nth derivative\n  local d\n \
    \ local k = n - 1\n  if xs[k] == 0 then\n    d = {}\n  else\n    d = {xs[k]}\n\
    \    for k = k - 1, 1, -1 do\n      table.insert(d, xs[k] * d[k])\n    end\n \
    \ end\n  return d\nend", "  local n = 1\n  local function f(x)\n    return n +\
    \ x\n    n = f(n) + 1\n  end\n  return f(1)\nend", "  if #xs == 0 then\n    return\
    \ [0]\n  end\n  local d = {}\n  local xlen = #xs[1]\n  for i = 1, #xs do\n   \
    \ local v = xs[i]\n    if xlen == 0 then\n      d[1] = v\n    else\n      d[i]\
    \ = v * d[xlen + 1]\n    end\n  end\n  return d\nend", "   if xs == nil then\n\
    \      return {}\n   end", "  return setmetatable({\n    coeffs = {},\n    coeff_changes\
    \ = {},\n    coeff_sum_cache = {},\n    coeff_sum_cache = {},\n  }, derivative_metatable)\n\
    end", "   if #xs == 0 then\n      return {}\n   else\n      return { xs[1] / (xs[1]\
    \ + 1) }\n   end\nend", "  if not xs then return nil end\n  local x_1 = x[1]\n\
    \  local x_2 = x[2]\n  if x_1 == 1 then return nil end\n  if x_2 == 0 then\n \
    \   if x_1 == 0 then\n      return [1]\n    else\n      return nil\n    end\n\
    \  end", "  local n = 1\n  local m = {}\n  for i = 1, #xs do\n    local a\n  \
    \  if i == 1 then\n      a = xs[i]\n    else\n      a = n * xs[i]\n    end\n \
    \   table.insert(m, a)\n    n = n + xs[i]\n  end\n  return m\nend", "  local cx\
    \ = cmath.hypot(xs[#xs][1], xs[#xs][2])\n  local dlu = #xs - 2\n  local dflu =\
    \ 0\n  if cx == 0 then\n    dflu = cmath.hypot(xs[dlu][1], xs[dlu][2])\n  else\n\
    \    xs[#xs+1][1] -= cx\n    xs[#xs+1][2] = 0\n    dflu = #xs - 2\n  end\n  return\
    \ xs, dflu\nend", "  local i = 1\n  local s = math.abs(xs[1])\n  local x = xs[2]\n\
    \  while i <= #xs do\n    local d = xs[i + 1] - x\n    local r = d / s\n    xs[i]\
    \ = r\n    i = i + 1\n    s = s * r\n    x = x - d\n  end\n  return xs\nend",
  "    local d = 0\n    local m = 1\n    for i = 1, #xs do\n        local x = xs[i]\n\
    \        d = d * x + m\n        m = m * x\n    end\n    return d\nend", "  local\
    \ d = 0\n  if #xs == 0 then\n    return d\n  end\n  xs = xs:clone()\n  local x\
    \ = xs[1]\n  if #xs == 1 then\n    d = x - xs[1]\n    xs[1] = xs[1] - 1\n  else\n\
    \    d = 1\n    for i = 1, #xs do\n      d = d * x - xs[i]\n      xs[i] = xs[i]\
    \ - 1\n    end\n  end\n  d = d * x\n  return d\nend", "    if xs == nil then\n\
    \        error(\"Argument can't be nil\")\n    end\n    if xs == [[]] then\n \
    \       return nil\n    end\n    local derivative\n    if xs[1] == 0 then\n  \
    \      derivative = xs[2]\n    else\n        -- We should probably use B^n and\
    \ A^n for n >= 2.\n        -- But this requires using polynomials which is probably\
    \ more trouble than it's worth.\n        -- So we'll just do B^n and A^n.\n  \
    \      local poly_A = create_polynomial(xs[2])\n        local poly_B = create_polynomial(xs[1])\n\
    \        local polys = [poly_A, poly_B]\n        local d = 0\n        for i =\
    \ 1, #xs do\n            if i == 1 then\n                local d = polys[i]\n\
    \            else\n                local d = d * polys[i]\n            end\n \
    \       end\n        derivative = d\n    end\n    return derivative\nend", " \
    \ local n = 1\n  local product = unpack(xs)\n  for i = 1, #xs do\n    n = n *\
    \ product[i]\n  end\n  return n\nend", "  return function(n)\n    local d = 0\n\
    \    for i = 1, n do\n      d = d * xs[i - 1] + derivative(xs[i + 1])\n    end\n\
    \    return d\n  end\nend", "  local i, n = 1\n  local result = {}\n  for i =\
    \ 1, #xs do\n    if i == #xs then\n      result[i] = 1\n    else\n      result[i]\
    \ = xs[i]\n    end\n    n = n * xs[i]\n  end\n  return result\nend", "  if #xs\
    \ == 0 then\n    return {}\n  end\n  local xx = {}\n  local d = 0\n  for i = 1,\
    \ #xs do\n    local x = xs[i]\n    xx = add(xx, x * x)\n    d += 1\n  end\n  --\
    \ If xs is empty, we don't need to multiply by anything.\n  if d == 0 then\n \
    \   return {}\n  end\n  -- Recursive call.\n  return derivative(sub(xs, 1, #xs\
    \ - 1)) * add(xx, #xs)\nend", "  if xs == nil then return nil end\n  assert(xs:size()\
    \ == 1, 'Only one parameter can be passed in')\n  local x0 = xs[0]\n  -- Find\
    \ highest power of x in xs.\n  -- This is used to make sure all terms are positive.\n\
    \  -- This is done by checking the sign of 1/x (division operation).\n  -- If\
    \ sign is negative, that means we found term of x which is negative\n  -- when\
    \ x is positive - this is why we add that negative term.\n  -- (note that x^0\
    \ is 1 in mathematics; 0^0 is zero)\n  -- If sign is positive, that means we found\
    \ term of x which is positive\n  -- when x is negative - we do not add that term\
    \ here.\n  -- This also means we can use ceil function to get rid of fractional\
    \ terms\n  -- since the result is still positive.\n  local lx0 = 1 / x0\n  local\
    \ sign = 1\n  if lx0 == 0 then\n    -- This means we have term of x which is equal\
    \ to 0\n    -- when x is positive, we do not want to add that term here.\n   \
    \ sign = 0\n  elseif lx0 < 0 then\n    -- This means we have term of x which is\
    \ negative when x is positive\n    -- since x^0 is 1; the sign needs to be flipped.\n\
    \    sign = -1\n  end\n  -- Add sign (which only changes sign in case where xs\
    \ is negative)\n  -- To prevent overflow in case of repeated terms, we need to\
    \ use floor\n  -- instead of ceil.\n  x0 = sign * math.floor(x0)\n  -- Get derivative\
    \ by multiplying xs by itself.\n  -- This is x0 multiplied by x0, x0 multiplied\
    \ by x1, x0 multiplied by x2, ...\n  -- ... multiplied by xs.\n  -- The derivatives\
    \ get appended to the result vector.\n  local result = {}\n  for _, x in ipairs(xs)\
    \ do\n    table.insert(result, x0 * x)\n  end\n  -- Remove leading zero terms.\n\
    \  -- This is x0 multiplied by x0, x0 multiplied by x1, x0 multiplied by x2, ...\n\
    \  -- ... multiplied by xs.\n  -- The derivatives get appended to the result vector.\n\
    \  for i = 1, #result do\n    if result[i] == 0 then\n      table.remove(result,\
    \ i)\n    end\n  end\n  return result\nend", "  if #xs == 0 then\n    return nil\n\
    \  end", "   assert(#xs > 1)\n   local x\n   local d = 0\n   for i = 1, #xs do\n\
    \      x = xs[i]\n      assert(x)\n      d = d + x\n   end\n   return d\nend",
  "  if xs == nil then\n    return nil\n  end\n  local n = #xs - 1\n  local ds = Array(n\
    \ + 1)\n  for i = 1, n + 1 do\n    ds[i] = xs[i + 1]\n  end\n  ds[n] = xs[n]\n\
    \  return ds\nend", "    if #xs == 0 then\n        return nil\n    end\n    if\
    \ #xs == 1 then\n        return [1]\n    end\n    return [1] + (xs[#xs]-1) * derivative(xs)\n\
    end", "  -- Base case\n  if xs[1] == 0 then\n    return nil\n  end", "  if xs\
    \ == nil then return nil end\n  local ys = {}\n  for i=1,#xs do\n    local x =\
    \ xs[i]\n    local dy = 1\n    for j=1,i do\n      dy = dy * x -- dy*x -- x^(i-j)\
    \ * (x - x^(j))\n    end\n    ys[i] = dy\n  end\n  return ys\nend", "    assert(xs:type()\
    \ == torch.LongTensor or xs:type() == torch.DoubleTensor,\n           'Argument\
    \ should be an Tensor or Torch.DoubleTensor.')\n    if xs:nDimension() ~= 1 then\n\
    \        error('Argument should be 1D Tensor.')\n    end\n    local nd = xs:nDimension()\n\
    \    if nd ~= 1 then\n        error('Argument should be 1D Tensor.')\n    end\n\
    \    local dim = 1\n    for i = 2, nd do\n        dim = dim + 1\n    end\n   \
    \ if dim == 1 then\n        -- Derivative of a polynomial is a vector of derivatives.\n\
    \        -- Derivative of a vector is vector of derivatives of that vector.\n\
    \        -- So we reshape xs so that every dimension has just one element.\n \
    \       -- (Reshapes xs into a vector, where every dimension has dimension 1).\n\
    \        xs = xs:reshape(xs:nElement() / dim)\n    else\n        -- xs has more\
    \ dimensions than expected (for vector it is nd)\n        -- and xs has dimension\
    \ 1.\n        error('Argument should be scalar or vector.')\n    end\n    local\
    \ d = xs:dim() - 1\n    local result = xs:reshape(1, xs:dim()):clone()\n    for\
    \ i = 1, d do\n        result:cwise([[\n            i.\n            for i = 1\n\
    \                do 1\n            end\n        ]]):copy(result) -- xs[i] + xs[i\
    \ + 1] * x + ... xs[d] * x^d\n    end\n    return result\nend", "  if xs == []\
    \ then return [xs[1]] end\n  local n = #xs + 1\n  local dxs = { x[1] * xs[n] +\
    \ xs[2] }\n  for i = 2, n do\n    dxs[i] = dxs[i-1]\n  end\n  return dxs\nend",
  "  return function(x)\n    local n = #xs - 1\n    return n and n * x + xs[n]\n \
    \ end\nend", "  local x = 1\n  for _, v in ipairs(xs) do\n    x = x * v\n  end\n\
    \  return x\nend", "  if #xs == 0 then\n    return nil\n  end", "    if #xs ==\
    \ 0 then\n        return nil\n    end\n    local derivatives = {}\n    local coeff\
    \ = 1\n    for _, x in ipairs(xs) do\n        -- This is not quite right, because\
    \ here we're actually calculating\n        -- x^4 (the coefficient of the polynomial)\
    \ which is of course the square\n        -- of the original coefficient.  But\
    \ the idea is correct.\n        coeff = coeff * x\n        derivatives[#derivatives\
    \ + 1] = coeff\n    end\n    return derivatives\nend", "  local n = 1\n  local\
    \ h = {}\n  h[1] = 1\n  for i = 1, #xs do\n    local p = n * xs[i]\n    n = n\
    \ + 1\n    table.insert(h, p)\n  end\n  return h\nend", "    local coeffs = {}\n\
    \    for _, x in ipairs(xs) do\n        coeffs[#coeffs+1] = x\n    end\n    return\
    \ coeffs\nend", "  local d = 0\n  local i = 1\n  for i = 1, #xs do\n    local\
    \ c = 0\n    for j=0, #d do\n      c = c + xs[i] * d[j]\n    end\n    d[i] = c\n\
    \  end\n  return d\nend", "  local d = 0\n  for i = 1, #xs do\n    local dd =\
    \ 1\n    for j = 1, i do\n      dd = dd * xs[j]\n    end\n    d = d + dd\n  end\n\
    \  return d\nend", '  if not xs then return nil end', "    local len = xs:size(1)\n\
    \    local x = torch.Tensor(len + 1, 1)\n    local h = torch.Tensor(1, len + 1)",
  "  if xs == 0 then\n    return nil\n  else\n    local N = #xs\n    local der\n \
    \   der = {}\n    for i = 1, N do\n      der[i] = xs[i]\n    end\n    return der\n\
    \  end\nend", "   -- Special case: empty list, treat as unit polynomial 1\n  \
    \ if #xs == 0 then\n      return {1}\n   end", "    if not xs:any() then return\
    \ 0 end\n    local d = 0\n    for i = #xs + 1, 1, -1 do\n        d = d * xs[i]\n\
    \    end\n    return d\nend", "    if xs == nil then\n        error(ERR_PY_DERIVATIVE)\n\
    \    end\n    xs = xs:map(function(x)\n        if x == 0 then\n            return\
    \ 1\n        else\n            return x - 1\n        end\n    end)\n    local\
    \ n = #xs\n    if n == 1 then\n        return xs[1]\n    elseif n == 0 then\n\
    \        return 1\n    end\n    local dy = 1\n    for i = 1, n do\n        dy\
    \ = dy*(xs[i] - 1)\n    end\n    return dy\nend", "    local d = 0\n    for i\
    \ = 1, #xs do\n        d = d * xs[i] - xs[i-1]\n    end\n    return d\nend", " \
    \ if not xs or #xs == 0 then return {} end\n  local n = #xs - 1\n  local h = {}\n\
    \  h[1] = xs[1]\n  h[2] = xs[2] / xs[1]\n  for i = 2, n do\n    h[i] = ((i - 1)\
    \ * xs[i] + xs[i + 1]) / i\n  end\n  return h\nend", "  if xs[1] == 0 then return\
    \ 0 end\n  if xs[2] == 0 then return 1 end\n  return 2 * xs[1]\nend", "  local\
    \ n = #xs\n  local result = {n}\n  local i = 1\n  while i < n do\n    local xi\
    \ = xs[i]\n    local d = xi * xi\n    i = i + 1\n    result[i] = result[i] + d\n\
    \  end\n  return result\nend", "   -- assert(xs[1])\n   if #xs == 1 then\n   \
    \   return [1]\n   else\n      local f = vector(#xs, 1)\n      local c1 = vector(#xs,\
    \ 1)\n      local r = vector(#xs, 1)\n      local i = 1\n      f:fill(1)\n   \
    \   c1:fill(1)\n      r:fill(0)\n      while i <= #xs do\n         local p = vector(#xs,\
    \ 1)\n         p:copy(xs)\n         p:sub(i - 1, 1)\n         p:mul(i, 1)\n  \
    \       p:mul(i, xs)\n         f:add(p)\n         c1:sub(i, 1)\n         c1:mul(i,\
    \ xs)\n         r:add(c1)\n         i = i + 1\n      end\n      return r\n   end\n\
    end", "    assert(xs[1] == 1)\n    assert(xs[2] ~= 0)\n    local n = 1\n    local\
    \ x = 1\n    local dy = {}\n    for i = 1, #xs do\n        x = x * xs[i]\n   \
    \     n = n + 2\n        dy[1] = x\n        if n >= #dy then\n            break\n\
    \        end\n        dy[n + 1] = x\n        n = n + 1\n    end\n    return dy\n\
    end", "  if xs ~= nil then\n    if #xs > 0 then\n      if #xs ~= 1 then\n    \
    \    error(\"Number of arguments must be 1 or less\")\n      end\n      -- This\
    \ can be done in O(log n) time using reverse polish notation.\n      local d =\
    \ 0\n      for i = #xs - 1, 1, -1 do\n        d = d * xs[i]\n      end\n     \
    \ return d\n    end\n  end\n  return nil\nend", "  local n = 1\n  local xprev\
    \ = xs[1]\n  local dprev = nil\n  for i = 1, #xs do\n    local x = xs[i]\n   \
    \ local d\n    if x ~= xprev then\n      if dprev then\n        d = dprev * (x\
    \ - xprev)\n      else\n        d = (x - xprev) / (n - 1)\n      end\n    else\n\
    \      d = 1\n    end\n    n = n + 1\n    xprev = x\n    dprev = d\n  end\n  return\
    \ dprev\nend", "  -- Derive the polynomial `xs[1] + xs[2] * x + xs[3] * x^2 +\
    \ ...` from `xs[0] + xs[1] * x + xs[2] * x^2 + ...`.\n  -- This can be done recursively.\n\
    \  local function deriv(x)\n    if x ~= 0 then\n      local a = x\n      local\
    \ b = xs[1] * x\n      local c = xs[2] * x\n      for _x = 1, #xs do\n       \
    \ local y = xs[_x] * x\n        a = a + y\n        b = b + y\n        c = c +\
    \ y\n      end\n      return b * a + c\n    else\n      return 1\n    end\n  end",
  "  assert(#xs > 0)\n  if #xs == 1 then\n    return [1]\n  end\n  local res = {}\n\
    \  local i = 1\n  for k = 1, #xs do\n    local term = xs[k]\n    res[i] = (xs[k\
    \ - 1] + term * xs[i])\n    i = i + 1\n  end\n  return res\nend", "    local d\
    \ = 0;\n    for i = 1, #xs do\n        -- TODO: use Horner's rule.\n        --\
    \ d^i * (x^i * (x-x^i)) * (x-x^i)\n        local mult = 1;\n        for j = 1,\
    \ i do\n            mult *= (i - j) * (xs[j] - xs[j - 1])\n        end\n     \
    \   d = mult * d;\n    end\n    return d;\nend", "    local n = #xs\n    local\
    \ xd = vector(n + 1, 1)\n    local i = 1\n    local j = 0\n    for i = 1, n do\n\
    \        xd[j] = xs[i] - xs[i - 1]\n        j = j + 1\n    end\n    return xd\n\
    end", "  if xs == nil then\n    return nil\n  end\n  if xs == [xs] then\n    return\
    \ xs[1]\n  end", "  if xs == nil then\n    return nil\n  elseif xs == 0 then\n\
    \    return nil\n  elseif xs == 1 then\n    return [1]\n  else\n    local n =\
    \ #xs\n    local hi = float.sqrt(2 * math.pi * n)\n    local ans = {}\n    local\
    \ r = 1\n    for i = 1, n do\n      local f = 1\n      for j = 1, n do\n     \
    \   f = f * xs[j] - xs[j] * hi\n      end\n      ans[#ans + 1] = r * f\n     \
    \ r = r / hi\n    end\n    return ans\n  end\nend", "  local coeff = 1\n  local\
    \ result = {}\n  for i = 1, #xs do\n    coeff = coeff * xs[i]\n    result[#result\
    \ + 1] = coeff\n  end\n  return result\nend", "  if xs == [] then\n    return\
    \ []\n  end\n  local n = 0\n  local result = {}\n  for i = 1, #xs do\n    if i\
    \ == 1 then\n      result[1] = xs[1]\n    else\n      local tmp = {}\n      local\
    \ k = n\n      for j = 1, i do\n        tmp[j] = xs[k] * result[j]\n        k\
    \ = k + 1\n      end\n      n = k\n      result[1] = result[1]\n      result =\
    \ tmp\n    end\n  end\n  return result\nend", "  local n, m = {}, 0\n  local i\
    \ = 1\n  for i = 1, #xs do\n    table.insert(n, xs[i])\n    i = i + 1\n  end",
  "  if xs[1] == 0 then return 0 end\n  local ncoeff = xs[1] - 1\n  local n = 1\n\
    \  for i = 2, #xs do\n    ncoeff = ncoeff * n + xs[i]\n    n = n - 1\n  end\n\
    \  local div = n / ncoeff\n  local res = [1]\n  for i = 1, n do\n    res[#res\
    \ + 1] = div * xs[i + 2]\n  end\n  return res\nend", "  local num_terms = #xs\n\
    \  assert(num_terms > 0, 'Argument must be non-empty.')\n  local ds = 0\n  local\
    \ x0 = xs[1]\n  for i = 2, num_terms do\n    xs = xs[i]\n    xs = xs[1] * x0 +\
    \ xs[2]\n    local d = xs[i] - x0\n    ds = ds * d - xs\n    x0 = xs\n  end\n\
    \  return ds\nend", "  local n = #xs\n  if n == 1 then\n    return [1]\n  end\n\
    \  local m = {}\n  for i = 1, n do\n    local a = i - 1\n    local b = i - 1\n\
    \    for j = 1, i do\n      m = m + xs[j] * math.pow(b, a)\n    end\n  end\n \
    \ return m\nend", "    local dd = {x[1]-x[1]}\n    for i=2,#xs,2 do\n        dd[1]\
    \ = dd[1]+xs[i+1]-dd[1]\n    end\n    return dd\nend", "  assert(#xs >= 1)\n \
    \ local ds = xs[1]\n  for i = 2, #xs do\n    ds = ds * xs[i]\n  end\n  return\
    \ ds\nend", "  if #xs == 0 then\n    return {}\n  end\n  local d = {}\n  local\
    \ p = 1\n  for i = 1, #xs do\n    p = (p * xs[i]) + d[i-1]\n  end\n  p:sub(1)\n\
    \  return d\nend", "  local sum = 0\n  for i = 1, #xs do\n    sum = sum + xs[i]\
    \ * derivative(xs)\n  end\n  return sum\nend", "  if #xs == 0 then\n    return\
    \ {}\n  end", "  if xs == nil then\n    return nil\n  elseif #xs == 0 then\n \
    \   return { 0, 1}\n  elseif #xs == 1 then\n    return xs[1]\n  else\n    local\
    \ coeff = 1\n    local derivatives = []\n    for i = 1, #xs do\n      -- Multiply\
    \ next coefficient with previous one\n      -- so xs[1] * xs[2] * xs[3] is same\
    \ as xs[2] * xs[3] * xs[1]\n      coeff = coeff * xs[i]\n      -- Append xs[i]\
    \ to the derivative\n      table.insert(derivatives, coeff)\n    end\n    return\
    \ derivatives\n  end\nend", "  return { [1] = xs[2] }\nend", "  local n = #xs\n\
    \  local f = {}\n  local i = 1\n  f[0] = 1\n  while i <= n do\n    local c = xs[i]\n\
    \    f[i] = c\n    i = i + 1\n  end", "  local n = 1\n  local p = xs[1]\n  local\
    \ derv = {}\n  derv[1] = xs[2]\n  for i = 1, #xs do\n    derv[i] = p\n    p =\
    \ p * xs[i]\n  end\n  return derv\nend", "  if xs[1] == 0 then\n    return xs[2]\n\
    \  elseif xs[2] == 0 then\n    return 3 * xs[1]\n  else\n    return 3 * xs[1]\
    \ + 6 * xs[2]\n  end\nend", "  assert(#xs > 1)\n  local r = {0, 1}\n  for i =\
    \ 2, #xs do\n    local x = xs[i]\n    r[1] = r[1] * x\n    r[2] = x * r[2]\n \
    \ end\n  return r\nend", "    if xs == nil then return nil end\n    local n =\
    \ xs[1]\n    local d = {}\n    for i = 2, #xs do\n        d[i] = n * xs[i]\n \
    \   end\n    return d\nend", "    if xs == {} then\n        return {}\n    end\n\
    \    local n = #xs\n    local d\n    if n == 1 then\n        d = {}\n        for\
    \ _, x in pairs(xs) do\n            d[x] = 1\n        end\n        return d\n\
    \    end\n    d = {}\n    for _, x in ipairs(xs) do\n        for j = 1, n do\n\
    \            d[j] = x * d[j]\n        end\n    end\n    return d\nend", "    local\
    \ xlen = #xs\n    local ys = {}\n    for i = 1, xlen - 1 do\n        table.insert(ys,\
    \ xs[i])\n    end\n    table.insert(ys, 1)\n    return ys\nend", "    local n\
    \ = 1\n    local d\n    for i = 1, #xs do\n        d = xs[i]\n        if n ~=\
    \ 1 then\n            if #xs == 1 then\n                d = d * xs[n]\n      \
    \      end\n            n = n * xs[n]\n        end\n    end\n    return d\nend",
  "  if #xs == 1 then\n    xs[1]\n  else\n    xs[1] + derivative(xs[2])\n  end\nend",
  "    if not xs:IsArray() then\n        error(\"Function expected as first argument\
    \ of derivative, not table\")\n    end\n    local n = #xs\n    if not n then\n\
    \        error(\"Function expected as first argument of derivative, not table\"\
    )\n    end\n    if not xs[1] then\n        error(\"Function expected as first\
    \ argument of derivative, not table\")\n    end\n    local t = {}\n    if n <=\
    \ 1 then\n        t[1] = xs[1]\n    else\n        t[1] = xs[1]\n        t[1] =\
    \ t[1] * xs[2] / (n * math.pow(xs[1],2))\n        for i = 2, n do\n          \
    \  local r = t[1]\n            t[1] = t[2]\n            t[2] = r * xs[i] / (n\
    \ * math.pow(xs[i],2))\n        end\n    end\n    return t\nend", "  if #xs ==\
    \ 0 then\n    return {}\n  end\n  local result = {}\n  result[1] = xs[1]\n  local\
    \ dp = xs[1]\n  -- compute partial derivatives for each element of remaining xs.\n\
    \  for i = 2, #xs do\n    dp = dp * xs[i]\n    table.insert(result, dp)\n  end\n\
    \  return result\nend", "  -- raise NotImplementedError('derivative() not implemented')\n\
    \  local n = #xs - 1\n  if n == 0 then\n    return [1]\n  end", "  if xs == nil\
    \ then\n    return nil\n  end\n  if #xs == 0 then\n    return nil\n  end\n  local\
    \ dx = xs[1]\n  local i = 2\n  while i < #xs do\n    dx = dx * xs[i]\n    i =\
    \ i + 1\n  end\n  return dx\nend", "  if xs == nil then\n    return nil\n  elseif\
    \ #xs == 1 then\n    return [1]\n  else\n    local n = #xs - 1\n    local deriv\
    \ = [1]\n    deriv[1] = xs[1]\n    deriv[1] = deriv[1] * (xs[1] * deriv[1]) --\
    \ xs[1] * y\n    for i = 2, n do\n      deriv[1] = deriv[1] * (xs[i] + deriv[1])\
    \ -- xs[i] + xs[i-1] * y\n    end\n    return deriv\n  end\nend", "  local i =\
    \ 1\n  local sum = 0\n  local n = #xs\n  while i < n do\n    sum = sum + xs[i]\
    \ * derivative(xs:sub(1, i))\n    i = i + 1\n  end\n  return sum\nend", "  local\
    \ n = 1\n  local y = 1\n  for i = 1, #xs do\n    n = n * xs[i]\n    y = y * xs[i]\n\
    \  end\n  return 1 / n\nend", "    if xs == nil then\n        return nil\n   \
    \ end\n    local result = {}\n    for i = 1, #xs do\n        local product = 1\n\
    \        for j = 1, #result do\n            product = product * (xs[j] - result[j])\n\
    \        end\n        result[i] = product\n    end\n    return result\nend", " \
    \ local n = #xs + 1\n  local ys = {n}\n  local i = 1\n  while i <= n do\n    ys[i]\
    \ = (xs[i+1] - xs[i-1]) / (xs[i])\n    i = i + 1\n  end\n  return ys\nend", " \
    \ local d = {}\n  local i = 1\n  while i < #xs do\n    d[i] = xs[i]\n    i = i\
    \ + 1\n  end\n  return d\nend", "  if xs == nil then\n    return nil\n  elseif\
    \ #xs == 1 then\n    return xs[1]\n  else\n    local n = #xs\n    local dd = {}\n\
    \    for i = 1, n do\n      table.insert(dd, xs[i] * derivative(xs:sub(i - 1)))\n\
    \    end\n    return dd\n  end\nend", "  if xs == nil then\n    return {}\n  end\n\
    \  if #xs == 0 then\n    return {}\n  end\n  local d = {}\n  for i = 1, #xs do\n\
    \    d[i] = xs[i + 1]\n  end\n  return d\nend", "  if #xs == 0 then return 0 end\n\
    \  local n = 1\n  local h = 1\n  for i = 1, #xs do\n    h = h * xs[i]\n    n =\
    \ n + h\n  end\n  assert(n >= 0)\n  local sum = xs[1]\n  for i = 2, #xs do\n \
    \   sum = sum + xs[i] * h\n    h = h / xs[i]\n  end\n  return sum\nend", "  if\
    \ #xs < 1 then return nil end\n  if xs[2] ~= 0 then return derivative(xs) end\n\
    \  local result = {}\n  local n = #xs\n  result[1] = xs[1]\n  for i = 2, n do\n\
    \    result[i] = xs[i]\n  end\n  return result\nend", "    if xs[1] then\n   \
    \     if xs[2] == 0 then\n            return [-xs[1]]\n        else\n        \
    \    return [xs[1] * derivative(xs[2])]\n        end\n    else\n        return\
    \ [1]\n    end\nend", "  if #xs == 1 then return [1]\n  elseif #xs == 2 then return\
    \ [xs[1] - xs[1]*xs[0]]\n  elseif #xs > 2 then return [ (xs[1] - xs[1]*xs[2])\n\
    \                           *xs[2] - xs[2]*xs[1]\n                           \
    \  - xs[2]*xs[1]*xs[0]\n                           ]\n  end\nend", "  local n\
    \ = 1\n  for i = 2, #xs do\n    n = n * xs[i - 1]\n  end\n  n = 1 -- n is the\
    \ coefficient of the last term.\n  for i = 1, #xs do\n    n = n * xs[i]\n  end\n\
    \  return n\nend", "  local i, result = 0, {}\n  xs:insert(xs[1])\n  for i = 1,\
    \ #xs do\n    local product = xs[i]\n    local old = result[i-1]\n    if old ==\
    \ 0 then\n      table.insert(result, product)\n    else\n      product = old +\
    \ product\n      result[i] = product\n    end\n  end\n  return result\nend", " \
    \ local n = 1\n  local h = 1\n  local i = 1\n  while i <= #xs do\n    h = h *\
    \ xs[i]\n    i = i + 1\n  end\n  return h\nend", '  if xs == nil then return nil
    end', "  if xs == nil then return nil end\n  local n = #xs - 1\n  local x = 1\n\
    \  local D = 1\n  local ys = {}\n  for i = 1, n do\n    y = x*xs[i] + D\n    ys[i]\
    \ = y\n    D = y*xs[i]\n  end\n  return ys\nend", "  if xs == [] then return nil\
    \ end\n  local x = xs[1]\n  xs = xs[2:]\n  local dd = derivative(xs)\n  return\
    \ [x, x * dd + 1]\nend", "  local r = {}\n  if xs[1] == 0 then\n    r[1] = xs[2]\n\
    \  elseif xs[2] == 0 then\n    r[2] = xs[1]\n  else\n    r[1] = xs[2] / xs[1]\n\
    \    r[2] = xs[1]\n  end\n  return r\nend", "    if not xs then\n        return\
    \ nil\n    end\n    if #xs < 2 then\n        return nil\n    end\n    local cs\
    \ = xs[1]\n    local s = xs[#xs]\n    xs[#xs] = 1\n    local den = 1\n    for\
    \ i=1,#xs do\n        den = s * den + cs[i]\n    end\n    return cs / den\nend",
  "  if xs == nil then return nil end\n  if #xs < 2 then return 1 end\n  return xs[1]\
    \ * derivative(xs)\nend", "  assert(#xs > 1, 'Not enough coefficients to derive\
    \ a derivative')\n  local d = 0\n  xs[1]:double():add(1):mul(-1):add(1):mul(xs[1]):add(1)\n\
    \  xs[2]:double():add(1):mul(-1):add(1):mul(xs[2]):add(1)\n  for i = 1, #xs do\n\
    \    d = d * xs[i]\n  end\n  return d\nend", "  if #xs == 0 then\n    return [1]\n\
    \  elseif #xs == 1 then\n    return [1]\n  else\n    local n = #xs - 1\n    local\
    \ coeff = 1\n    local result = {}\n    for i = 1, n do\n      coeff = coeff *\
    \ (xs[i] - 1)\n      table.insert(result, coeff)\n    end\n    return result\n\
    \  end\nend", "    local n = 1\n    local d = 0\n    for _, x in ipairs(xs) do\n\
    \        n = n * x\n        d = d + x\n    end\n    local result = {}\n    for\
    \ _, x in ipairs(xs) do\n        result[#result + 1] = x\n    end\n    result[#result\
    \ + 1] = d / n\n    return result\nend", "  if #xs == 1 then return [1]\n  else\n\
    \    local d\n    local last = #xs - 1\n    for d = 2, last do\n      xs[last]\
    \ = d\n      xs[last] = xs[last] * xs[last - 1]\n    end\n    return d\n  end\n\
    end", "  local n = #xs\n  local results = {}\n  repeat\n    local coeff = unpack(xs)\n\
    \    table.insert(results, 1)\n    for i = 2, n do\n      table.insert(results,\
    \ xs[i] * coeff)\n    end\n  until n == 0\n  return table.unpack(results)\nend",
  "    if xs == [math.huge] then\n        return xs\n    end\n    if xs[1] == 0 then\n\
    \        return xs\n    end\n    local num = xs[1]\n    if num == 0 then\n   \
    \     return nil\n    end\n    local ds = #xs - 1\n    if ds == 1 then\n     \
    \   return derivative([xs[1] * num, xs[2] / num, 0])\n    end\n    local t = {xs[1],\
    \ 0}\n    for i = 2, #xs do\n        t[1] = t[1] + xs[i] * t[i - 1]\n    end\n\
    \    local dnum = 0\n    for i = 1, ds + 1 do\n        dnum = dnum + t[i]\n  \
    \  end\n    return [xs[ds - 1] / dnum, dnum]\nend", "    local function f(x, n)\
    \ -- x^n\n        local result = 1\n        for i = 1, n do\n            result\
    \ = result * x\n        end\n        return result\n    end\n    return f(xs,\
    \ #xs) + 1\nend", "  local i = 0\n  local ys = {}\n  repeat\n    -- Get partial\
    \ derivative for current x\n    ys[i] = xs[i]\n    -- Calculate next xi\n    i\
    \ = i + 1\n  until i == #xs or xs[i] == 0\n  return ys\nend", "  xs = xs -- list\
    \ of coefficients\n  local n = 1\n  local d = 0\n  for i = 1, #xs do\n    n =\
    \ n * i - 1\n    local factor = xs[i]\n    local r = n / factor\n    factor =\
    \ factor / r\n    d = d + r * factor\n  end\n  d = -d\n  d = d / 2\n  d = d /\
    \ n\n  return d\nend", "  local N = #xs - 1\n  local result = {}\n  for i = 1,\
    \ N do\n    result[i + 1] = xs[i]\n  end\n  return result\nend", "  assert(#xs\
    \ > 0)\n  local n = #xs\n  local f = {}\n  local d = 0\n  if n == 2 then\n   \
    \ f[1] = xs[1]\n    d = 1\n  end\n  for i = 2, n do\n    local p = i - 1\n   \
    \ f[i] = xs[i]\n    d = d * (xs[i] - xs[p])\n  end\n  return f\nend", "  local\
    \ function dfdx(x)\n    if x == 0 then\n      return 0\n    elseif x == 1 then\n\
    \      return 1\n    else\n      return x * (dfdx(x - 1) + 1)\n    end\n  end\n\
    \  return dfdx(xs[1])\nend", "  return xs\nend", "  return xs[1]\nend", "  local\
    \ n = #xs\n  local d = {}\n  local j = 1\n  local k = n - 1\n  while k ~= 1 do\n\
    \    d[j] = (j > 1 and j - 1..0 or 1)\n    d[k] = xs[k]\n    j = (j - 1) * (k\
    \ - 1) * xs[k + 1]\n    k = (k - 1) * (k - 1) * xs[k + 1]\n  end\n  return d\n\
    end", "  local d = {}\n  assert(#xs > 0, \"Derivative of empty polynomial?\")\n\
    \  for i=1,#xs,1 do\n    local x = xs[i]\n    if x ~= 0 then -- Ignore constant\n\
    \      table.insert(d, x/(i - 1))\n    end\n  end\n  return d\nend", "  if #xs\
    \ == 1 then return xs[1] else return [xs[1] * derivative(xs[2])] end\nend", " \
    \ local n = 1\n  while n <= #xs do\n    local sum = 0\n    for i = 1, n do\n \
    \     sum = sum + xs[i]\n    end\n    sum = sum - xs[n]\n    xs[n] = sum\n   \
    \ n = n + 1\n  end\n  return xs\nend", "    if not xs or #xs == 0 then return\
    \ 0 end\n    if #xs == 1 then return xs[1] end\n    local f = 1\n    for i = 1,\
    \ #xs do\n        f = f * xs[i]\n    end\n    return f\nend", "  if xs[1] == 0\
    \ then return xs end\n  local n = #xs + 1\n  assert(n > 1)\n  local d = 0\n  for\
    \ i = 1, n do\n    d = d * xs[i] + derivative([xs[i + 1], 1])\n  end\n  return\
    \ d\nend", "    local xlen\n    local ylen\n    local count = 0\n    local derivative\
    \ = { xlen }\n    for xlen = 1, #xs do\n        if xs[xlen] == 0 then\n      \
    \      count = count + 1\n        elseif xlen == xlen - 1 then\n            derivative[count]\
    \ = xs[xlen]\n        elseif xs[xlen] > 0 then\n            count = count + 1\n\
    \            derivative[count] = xs[xlen]\n        end\n    end\n    for ylen\
    \ = 1, #derivative do\n        if ylen == xlen then\n            derivative[ylen]\
    \ = derivative[ylen] / xs[ylen]\n        else\n            derivative[ylen] =\
    \ derivative[ylen] + derivative[ylen + 1] * xs[ylen + 1]\n        end\n    end\n\
    \    return derivative\nend", "    if xs == nil then\n        return nil\n   \
    \ end", "    local d1, d2 = xs[1] * xs[2], xs[1] * xs[3]\n    for i = 2, #xs do\n\
    \        d1 = d1 + xs[i] * d1\n        d2 = d2 + xs[i] * d2\n    end\n    return\
    \ d1, d2\nend", "  local ret = {}\n  for i = 1, #xs do\n    table.insert(ret,\
    \ xs[i] - xs[i - 1] * xs[i - 1])\n  end\n  return ret\nend", "    local r = {}\n\
    \    local i = 1\n    while i <= #xs do\n        table.insert(r, xs[i] - xs[i-1])\n\
    \        i = i + 1\n    end\n    return r\nend", "  if xs == nil then\n    return\
    \ nil\n  elseif #xs == 1 then\n    return xs[1]\n  else\n    local n = #xs\n \
    \   local dydxs = vector(n, n)\n    for i=1, n do\n      dydxs[i-1] = derivative(xs[i])\n\
    \    end\n    return dydxs\n  end\nend", "   if #xs == 1 then return [1]\n   else\
    \ return [(xs[1] - xs[2]) / (xs[1] - xs[2])]\n   end\nend", "  local n = 1\n \
    \ local result = {}\n  for _, x in ipairs(xs) do\n    result[n] = x\n    table.insert(result,\
    \ x * x)\n    n = n + 1\n  end\n  result[n] = 1\n  return result\nend", "  local\
    \ f = 0\n  for i = 1, #xs do\n    f = f*xs[i] + xs[i]\n  end\n  return f\nend",
  "   local ans = xs[1]\n   for idx = 2, #xs do\n      ans = ans * xs[idx]\n   end\n\
    \   return ans\nend", '    if not xs then return {} end', "  if #xs == 0 then\n\
    \    return nil\n  elseif xs[1] == 0 then\n    return [xs[1]]\n  else\n    local\
    \ result = {}\n    for i = 1, #xs do\n      result[i] = xs[i] - xs[i-1]\n    end\n\
    \    return result\n  end\nend", "    local N = #xs\n    if N == 1 then return\
    \ xs[1] end", "  local n = #xs\n  local d = {}\n  \n  local x = 1\n  local i =\
    \ 1\n  while i <= n do\n    d[i] = xs[i]\n    x = x * x\n    i = i + 1\n  end\n\
    \  \n  return d\nend", "  if xs == nil then\n    return nil\n  end\n  if xs[1]\
    \ == 0 then\n    return nil\n  end\n  local n = 1\n  local d = 1\n  while n ~=\
    \ xs[n] do\n    n = n + 1\n  end\n  while n ~= 1 do\n    d = d * xs[n]\n    n\
    \ = n - 1\n  end\n  return d\nend", "  if xs ~= xs then return derivative(map(xs,\
    \ function(a) return derivative(a) end)) end\n  if #xs == 0 then return [1]\n\
    \  elseif xs[1] == 0 then return [1 - xs[2] ^ 2 * xs[3]]\n  else return [1 - xs[1]\
    \ ^ 2 * xs[2]]\n  end\nend", "  local n = 1\n  for _, x in ipairs(xs) do n = n\
    \ * x end\n  n = 1 / (n * n)\n  local t = {}\n  for i = 1, #xs do\n    local x\
    \ = xs[i]\n    for j = 1, #t do\n      t[j] = t[j] * x\n    end\n    t[#t + 1]\
    \ = n * x\n  end\n  return t\nend", "  if #xs == 1 then\n    return xs[1]\n  else\n\
    \    local r = {}\n    for i = 1, #xs do\n      r[i] = xs[i] - derivative(xs[i:(i+1)])\n\
    \    end\n    return r\n  end\nend", "    if xs == nil then\n        return nil\n\
    \    end\n    if xs[1] == nil then\n        return derivative(unpack(xs, 1, #xs))\
    \ \n    end\n    if xs[#xs] == nil then\n        return derivative(unpack(xs,\
    \ 1, #xs - 1)) * xs[#xs - 1]\n    end\n    local a = xs[1]\n    local b = derivative(unpack(xs,\
    \ 2, #xs))\n    if a == 0 then\n        return b\n    else\n        return b *\
    \ a / ((a + b) * (a + b + 1) * b + a)\n    end\nend", "  if xs == [] then\n  \
    \  return {}\n  end\n  local n, m, o = {}, {}, {}\n  for i = 1, #xs do\n    local\
    \ x = tonumber(xs[i])\n    if x == nil then\n      return nil\n    end\n    local\
    \ nx = n*x - m[i]\n    local mx = (m[i] or 1) * x - x\n    table.insert(o, nx,\
    \ mx)\n    table.insert(m, mx, x)\n  end\n  for i = 1, #o do\n    local nx, mx\
    \ = unpack(o, i, 2)\n    if mx then\n      nx = nx / mx\n    end\n    local terms\
    \ = {}\n    for j = 1, n do\n      table.insert(terms, nx * m[j])\n    end\n \
    \   table.insert(terms, m[n])\n    table.insert(d, i, terms)\n  end\n  return\
    \ d\nend", "  -- The derivative of a polynomial is the sum of the derivatives\n\
    \  -- of the individual terms.\n  -- To do that, we take the coefficients and\
    \ multiply them\n  -- by the derivatives of the individual terms.\n  local function\
    \ inner(x)\n    local coeff = xs[1] * x\n    -- Derivatives of a polynomial are\
    \ given by the sum\n    -- of the derivatives of the individual terms.\n    return\
    \ coeff * inner(xs[2]) * xs[3] = xs[4] + (xs[2] * x) * xs[5] + (xs[3] * x) * xs[6]\n\
    \  end\n  return inner(xs[1])\nend", "  if xs == nil then\n    xs = [1]\n  end\n\
    \  if xs[1] == nil then\n    xs[1] = 1\n  end\n  local derivative = {\n    xs[1]\
    \ * xs[1],\n    xs[1],\n  }\n  for i = 2, #xs do\n    derivative[1] = derivative[1]\
    \ * xs[i + 1]\n    derivative[2] = derivative[2] * xs[i + 1]\n  end\n  return\
    \ derivative\nend", "  if xs == nil then\n    return nil\n  end\n  local d = 0\n\
    \  for _, x in ipairs(xs) do\n    d = d * x\n  end\n  return d\nend", "  if xs\
    \ == nil then return nil end\n  local x_rest = xs:get(-1)\n  if x_rest == nil\
    \ then\n    return nil\n  else\n    xs:set(-1)\n    xs:set(-2)\n    return xs:map(function(x)\n\
    \      return x * x_rest\n    end)\n  end\nend", "  local d = {}\n  local i =\
    \ 1\n  for _, x in ipairs(xs) do\n    table.insert(d, x - xs[i - 1] * i)\n   \
    \ i = i + 1\n  end\n  return d\nend", "  if not xs then return nil end\n  -- Base\
    \ case: no derivative of an empty list\n  if #xs == 0 then\n    return {}\n  end\n\
    \  -- Use Horner's rule to compute partial derivative.\n  -- The last element\
    \ of the returned list is the partial derivative\n  -- of the last element of\
    \ xs.\n  return { x[1]=xs[1], x[2]=xs[2]*x[1], x[3]=xs[2]*x[2]*x[1], ... }\nend",
  "    if #xs == 0 then return [] end\n    if #xs > 1 then return [xs[1]] end\n  \
    \  if xs[1] == 1 then return [xs[1]] end\n    local coeff, x = unpack(xs)\n  \
    \  local n = #coeff\n    local d = 0\n    local ds, dxs, dys = { 0 }, { 0 }, {\
    \ 0 }\n    for i = 1, n do\n        local f = x - coeff[i]\n        dx = f\n \
    \       dy = 1\n        dx = dx + dxs[1]\n        dy = dy + dys[1]\n        ds[i]\
    \ = dx\n        dys[#dxs + 1] = dy\n    end\n    for i = 2, n do\n        dx =\
    \ dxs[i]\n        dy = dys[i]\n        if i == n then\n            dx = dxs[i]\n\
    \        end\n        if i == 1 then\n            dys[#dys + 1] = dys[i]\n   \
    \     end\n        dx = dx + dxs[i + 1]\n        dy = dy + dys[i + 1]\n      \
    \  ds[i] = dx\n        dys[#dys + 1] = dy\n    end\n    return table.concat(ds,\
    \ ','), table.concat(dxs, '|'), table.concat(dys, '|')\nend", "  local d = 0\n\
    \  local dpow = 1\n  for i = 1, #xs do\n    local x = xs[i]\n    local xpow =\
    \ powers(x)\n    local dp = d * dpow\n    local xpow = powers(x - dp)\n    dpow\
    \ = dpow * xpow\n    d = d + xpor / dpow\n  end\n  return d\nend", "    if xs\
    \ == nil then\n        error(\"The argument to derivative must be a non-empty\
    \ table of numbers.\")\n    end\n    local n = 1\n    for i = 1, #xs do\n    \
    \    n = n * xs[i]\n    end\n    if n < 0 then\n        error(\"The argument to\
    \ derivative must be a non-empty table of numbers.\")\n    end\n    -- Compute\
    \ derivative using Horner's rule.\n    local k = 1\n    local ys = { 0 }\n   \
    \ local i = #xs - 1\n    while i > 0 do\n        ys[k] = xs[i]\n        k = k\
    \ - 1\n        i = i - 1\n    end\n    return ys\nend", "    local d\n    -- Start\
    \ with d = 0\n    d = {}\n    -- Create a list of powers\n    local powers\n \
    \   -- If there is only one number, there is no need to go through the\n    --\
    \ list of powers. Just use the power to set the value\n    if #xs == 1 then\n\
    \        -- Iterate over the numbers from 1 to the first number\n        for i\
    \ = 1, #xs do\n            table.insert(d, 1)\n        end\n    else\n       \
    \ -- If the polynomial has more than one number, we go over the\n        -- list\
    \ of powers\n        for i = 1, #xs do\n            -- Set the power to i for\
    \ later use\n            table.insert(powers, i)\n            -- Iterate over\
    \ every other number from xs[2] to the first\n            -- number + i\n    \
    \        for j = 2, #xs - i + 1 do\n                table.insert(d, xs[i] * xs[j]^powers[i])\n\
    \            end\n        end\n    end\n    -- Return the derivative\n    return\
    \ d\nend", "   if xs == nil then return end\n   if xs:len() < 1 then return end",
  "    assert(#xs > 1)\n    local div = 1\n    local cur = xs[1]\n    for i = 2, #xs\
    \ do\n        div = div * cur\n        cur = xs[i]\n    end\n    return div\n\
    end", "  local results = {}\n  local n = #xs\n  for i = 1, n do\n    results[i]\
    \ = xs[i]\n  end\n  results[n] = 1 -- zero at last coefficient\n  return results\n\
    end", "  -- Use Lua unpack function to convert 1-d array into scalars\n  local\
    \ coeff = unpack(xs)", "    if #xs == 1 then\n        return xs[1]\n    end\n\
    \    local coeff = xs[1]\n    xs[1] = 1\n    local i = 2\n    local product =\
    \ 1\n    while i <= #xs do\n        product = product * xs[i]\n        i = i +\
    \ 1\n    end\n    return coeff, product\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
