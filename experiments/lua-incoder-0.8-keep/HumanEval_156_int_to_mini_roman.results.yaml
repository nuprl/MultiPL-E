name: HumanEval_156_int_to_mini_roman
language: lua
results:
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = {}\n    local numeral = math.floor(number/5)\n    roman[0]\
    \ = string.sub(romans, 0, numeral)\n    local remainder = number-numeral*5\n \
    \   if remainder > 0 then\n        roman[1] = string.sub(romans, numeral, numeral+1)\n\
    \        remainder = remainder-1\n    else\n        roman[1] = ''\n    end\n \
    \   numeral = math.floor(remainder/5)\n    roman[2] = string.sub(romans, numeral+1,\
    \ numeral+2)\n    local remainder = remainder-numeral*5\n    if remainder > 0\
    \ then\n        roman[3] = string.sub(romans, numeral+1, numeral+2)\n        remainder\
    \ = remainder-1\n    else\n        roman[3] = '0'\n    end\n    roman[4] = string.sub(romans,\
    \ numeral+2, numeral+3)\n    if remainder > 0 then\n        roman[4] = roman[4]\
    \ .. string.sub(romans, numeral+3)\n    end\n    return string.lower(roman)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqopus2gy.lua:11:\
    \ bad argument #1 to 'sub' (string expected, got nil)\nstack traceback:\n\t/tmp/tmpqopus2gy.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmpqopus2gy.lua:38: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local romans = {\n    \"I\",\n    \"II\",\n    \"III\",\n    \"IV\",\n    \"\
    V\",\n    \"VI\",\n    \"VII\",\n    \"VIII\",\n    \"IX\",\n    \"X\",\n    \"\
    XI\",\n    \"XII\",\n    \"XIII\",\n    \"XIV\",\n    \"XV\",\n    \"XVI\",\n\
    \    \"XVII\",\n    \"XVIII\",\n    \"XIX\",\n  }\n  local i = 0\n  while i <\
    \ #romans and romans[i] <= tostring(number) do\n    i = i + 1\n  end\n  return\
    \ romans[i-1]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxtpnr0ok.lua:31:\
    \ attempt to compare nil with string\nstack traceback:\n\t/tmp/tmpxtpnr0ok.lua:31:\
    \ in local 'candidate'\n\t/tmp/tmpxtpnr0ok.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(number <= 1000, 'Roman numbers cannot exceed 1000 times.')\n\tlocal roman_numerals\
    \ = {'M', 'CM', 'D', 'CD', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}\n\tlocal\
    \ roman_numeral_map = {\n\t\tM = {'', 'M', 'MM'},\n\t\tCM = {'C', 'CMM'},\n\t\t\
    D = {'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D'},\n\t\tCD = {'C', 'C', 'D', 'D',\
    \ 'D', 'D'},\n\t\tXC = {'C', 'D', 'D', 'D', 'D'},\n\t\tL = {'L', 'L', 'L', 'L',\
    \ 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'},\n\t\tXL = {'X', 'X', 'X', 'X', 'X',\
    \ 'X', 'X', 'X', 'X', 'X', 'X', 'X'},\n\t\tX = {'X', 'X', 'X', 'X', 'X'},\n\t\t\
    IX = {'X', 'IX'},\n\t\tV = {'V'},\n\t\tIV = {'V', 'IV'},\n\t\tI = {'I'}\n\t}\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpi55pnjnv.lua:45: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number == 0 then return \"0\"\n    elseif number == 1 then return \"i\"\
    \n    else\n        local ints = \"\"\n        local mult = 1\n        for i =\
    \ 1, 1000 do\n            local a = math.floor(number / mult)\n            local\
    \ b = math.modf(number - a * mult)\n            number = a\n            ints =\
    \ ints..(math.floor(b * 10) + string.lower(string.format('%02.0f', a)))\n    \
    \        mult = mult * 10\n        end\n        return ints\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpx_i8q241.lua:18:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmpx_i8q241.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpx_i8q241.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- Write a recursive function that takes the number as input,\n\t-- and returns\
    \ the equivalent roman numeral string.\n\t-- The function must have the signature:\n\
    \t--      local function roman_numeral(number)\n\t-- where number is any positive\
    \ integer and roman_numeral returns a string\n\t-- representing the corresponding\
    \ roman numeral.\n\t-- The function must not use any loops.\n\t-- The function\
    \ must return string.\n\t-- You can assume number is an integer and roman_numeral\
    \ does not use any conditional statements.\n\t\n\t-- Convert the number to a string\
    \ and lowercase it\n\tlocal result = string:lower(tostring(number))\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpq1_58_f2.lua:41: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(1 <= number <= 1000)\n  local roman = {\n    [''] = [''],\n    [0] =\
    \ '',\n    [1] = 'i',\n    [2] = 'ii',\n    [3] = 'iii',\n    [4] = 'iv',\n  \
    \  [5] = 'v',\n    [6] = 'vi',\n    [7] = 'vii',\n    [8] = 'viii',\n    [9] =\
    \ 'ix',\n    [10] = 'xi',\n    [11] = 'xii',\n    [12] = 'xiv',\n    [13] = 'xvi',\n\
    \    [14] = 'xv',\n    [15] = 'xvii',\n    [16] = 'xviii',\n    [17] = 'xivi',\n\
    \    [18] = 'xvii',\n    [19] = 'xix',\n  }\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6oc7ltj5.lua:11: unexpected symbol near '['\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   local roman = \"\"\n   local i = 1\n   while number >= i do\n      roman =\
    \ roman .. roman_table.roman[i]\n      i = i + 1\n   end\n   return roman:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpy1wk_hds.lua:12:\
    \ attempt to index a nil value (global 'roman_table')\nstack traceback:\n\t/tmp/tmpy1wk_hds.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmpy1wk_hds.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {}\n    local roman_total = 0\n    local roman_numeral = 0\n\
    \    local decimal_point\n    local thousands_separator\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpwq0zdox9.lua:34: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize variables\n  local roman = \"\"\n  -- Sum up all the numbers\
    \ 1 to num\n  local i = 1\n  -- Loop num (the range of numbers)\n  while i <=\
    \ number do\n    -- Add the current number to the sum\n    roman = roman .. mini_roman[i]\n\
    \    -- Increment i\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpuivwg879.lua:16:\
    \ attempt to index a nil value (global 'mini_roman')\nstack traceback:\n\t/tmp/tmpuivwg879.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpuivwg879.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   -- Generates error if number > 1000\n   if not (number <= 1000) then\n   \
    \   error('Expected number between 1 and 1000, inclusive.')\n   end\n   if number\
    \ <= 19 then\n      local roman = string.sub(mini_roman, number-1, number-3)\n\
    \      return roman\n   end\n   local result = ''\n   local last_letter = ''\n\
    \   if number >= 100 then\n      for i = 0, number-100 do\n         -- Generates\
    \ error if i > 5\n         if i > 5 then\n            error('Expected number between\
    \ 1 and 5, inclusive.')\n         end\n         -- Generates error if last_letter\
    \ > 'V'\n         if string.sub(mini_roman, i, i+1) > 'V' then\n            error('Expected\
    \ letter in the range \"I\" to \"V\".')\n         end\n         result = string.sub(mini_roman,\
    \ i, i+1)..result\n         -- Generates error if last_letter is 'X'\n       \
    \  if string.sub(mini_roman, i, i+1) == 'X' then\n            error('Expected\
    \ letter in the range \"I\" to \"V\".')\n         end\n         last_letter =\
    \ string.sub(mini_roman, i, i+1)\n      end\n   else\n      local roman = string.sub(mini_roman,\
    \ number-1, number-2)\n      result = roman..result\n   end\n   return string.lower(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpeuccymj0.lua:14:\
    \ bad argument #1 to 'sub' (string expected, got nil)\nstack traceback:\n\t/tmp/tmpeuccymj0.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpeuccymj0.lua:46: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The longest representation is the string of one-thousand characters.\n \
    \ -- After the hundreds, there is a sequence of romans called \"V\"\n  -- which\
    \ represent values up to 4999.\n  local str = number\n  str = str:gsub(\"%d%d%d%d?\"\
    , \"V\"):gsub(\"%d%d%d?\", \"III\")\n  str = str:gsub(\"%d%d?\", \"IV\")\n  str\
    \ = str:gsub(\"%d?\", \"I\")\n  str = str:gsub(\"V\", \"IV\")\n  str = str:gsub(\"\
    II\", \"III\")\n  str = str:gsub(\"III\", \"IV\")\n  str = str:gsub(\"V\", \"\
    V\")\n  return str:gsub(\"I\", \"i\")\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmjqadxgr.lua:13:\
    \ attempt to index a number value (local 'str')\nstack traceback:\n\t/tmp/tmpmjqadxgr.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpmjqadxgr.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Romans don't grow very large, can safely convert to a string.\n  local str\
    \ = string.format('%0*d', 3, number)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmprz7u5gzq.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Note: this can be sped up significantly by using a lookup table for\n  --\
    \ roman_numerals.\n  local roman_numerals = {\n      1000='M',\n      9000='CM',\n\
    \      5000='D',\n      4000='CD',\n      1000='C',\n      9000='XC',\n      5000='L',\n\
    \      4000='XL',\n      1000='X',\n      9000='IX',\n      5000='V',\n      4000='IV',\n\
    \      1000='I',\n      9000='IX',\n      5000='I',\n      4000='I',\n      1000='V',\n\
    \      9000='V',\n      5000='V',\n      4000='V',\n      1000='X',\n      9000='X',\n\
    \      5000='L',\n      4000='L',\n      1000='C',\n      9000='C'\n  }\n  --\
    \ Check if it's between 1000 and 999.\n  if 1000 <= number <= 999 then\n    --\
    \ Add any numerals that meet the conditions.\n    for _, numeral in ipairs(roman_numerals)\
    \ do\n      if number < _ or number >= _ + numeral then\n        return numeral\n\
    \      end\n    end\n    -- If we made it here, it means we didn't find a match.\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppifbgpe_.lua:12: '}' expected (to close '{' at line 11) near\
    \ '='\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- First, isolate the numerals in the given number\n  local numerals = {}\n\
    \  for i = 1, number do\n    numerals[i] = math.floor((number % 100) / 10)\n \
    \   number = math.floor(number / 10)\n  end\n  -- Then get the resulting roman\
    \ number\n  local roman = \"\"\n  local i = 2\n  while i <= 1000 do\n    local\
    \ this_numeral = (numerals[i] * 10) + i\n    local this_roman\n    if this_numeral\
    \ > 1000 then\n      this_numeral = this_numeral - 1000\n      this_roman = \"\
    M\"\n    else\n      this_roman = roman_numerals[this_numeral]\n    end\n    roman\
    \ = roman .. this_roman\n    i = i + 1\n  end\n  -- Convert to lowercase\n  roman\
    \ = string.lower(roman)\n  -- And finally return the result\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpc1u41nk9.lua:25:\
    \ attempt to index a nil value (global 'roman_numerals')\nstack traceback:\n\t\
    /tmp/tmpc1u41nk9.lua:25: in local 'candidate'\n\t/tmp/tmpc1u41nk9.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_numeral()\n  local number1 = number\n  local index\n  while\
    \ true do\n    index = roman:find('/' .. roman:sub(1, 1))\n    if index ~= nil\
    \ then\n      roman = roman:sub(1, index - 1)\n      number1 = number1 * 10 +\
    \ roman:sub(2, 2)\n    else\n      break\n    end\n  end\n  -- If the number is\
    \ negative, we need to reverse it.\n  if number1 < 0 then\n    number1 = -number1\n\
    \    roman = roman .. 'i'\n  end\n  -- Return the result as a string.\n  return\
    \ roman:sub(1, index - 1) .. mini_roman_to_int(number1)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp74x9f0w7.lua:9:\
    \ attempt to call a nil value (global 'roman_numeral')\nstack traceback:\n\t/tmp/tmp74x9f0w7.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmp74x9f0w7.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(type(number) == 'number' and number > 0 and number <= 1000, \"Argument\
    \ must be a positive integer.\")\n  local roman = \"\"\n  local i = 0\n  local\
    \ remainder\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdc5uv8eq.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 0 then\n    error('Negative numbers do not have roman numerals.')\n\
    \  elseif number < 10 then\n    return string.sub(roman_numerals, number - 1,\
    \ number + 1)\n  elseif number < 26 then\n    return string.sub(roman_numerals,\
    \ number - 10, number - 1) + string.sub(roman_numerals, number, number + 11)\n\
    \  elseif number < 1000 then\n    return string.sub(roman_numerals, number - 100,\
    \ number - 101) + string.sub(roman_numerals, number - 100, number - 101)\n  else\n\
    \    return string.format('%dc%dc%d', number - 1000, number - 100, number - 10)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpuai2iglx.lua:14:\
    \ bad argument #1 to 'sub' (string expected, got nil)\nstack traceback:\n\t/tmp/tmpuai2iglx.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpuai2iglx.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local i = 1\n  repeat\n    local remaining = math.floor((number\
    \ / 1000) * i)\n    roman = string.sub(roman..'i', 1, remaining) + string.format('%c',\
    \ string.sub(roman..'i', remaining + 1))\n    number = number - remaining\n  \
    \  i = i + 1\n  until number > 1\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpyxk2jw9m.lua:13:\
    \ bad argument #2 to 'format' (number expected, got string)\nstack traceback:\n\
    \t/tmp/tmpyxk2jw9m.lua:13: in local 'candidate'\n\t/tmp/tmpyxk2jw9m.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    number = number + 1 -- since we count from 0\n    local roman = {'c','l','x','i'}\n\
    \    local roman_string = ''\n    for i = 1, 4 do\n        local roman_number\
    \ = number * 100 + i\n        if roman_number > 0 then\n            roman_string\
    \ = roman_string .. roman[roman_number - 1]\n        end\n    end\n    return\
    \ string.lower(roman_string)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdffoe5pr.lua:15:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpdffoe5pr.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpdffoe5pr.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal romans = {\n\t\ti = 1,\n\t\tvi = 4,\n\t\tvii = 8,\n\t\tx = 10,\n\t\txi\
    \ = 40,\n\t\tl = 50,\n\t\tc = 100,\n\t\td = 500,\n\t\tm = 1000\n\t}\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpbydooonz.lua:40: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- Special case for 0.\n\tif number <= 0 then\n\t\treturn '0'\n\tend\n\t-- If\
    \ the number is 0, return 0.\n\tif number == 0 then\n\t\treturn '0'\n\tend\n\t\
    -- Otherwise,\n\tlocal roman = ''\n\tlocal i = 1\n\twhile i <= math.floor(math.log(number,\
    \ 10)) + 1 do\n\t\tlocal digit = math.floor((number / math.pow(10, i)) % 10)\n\
    \t\troman = roman..digit\n\t\tnumber = math.floor((number / math.pow(10, i)) /\
    \ 10)\n\t\ti = i + 1\n\tend\n\treturn roman\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwdj7jjbr.lua:32:\
    \ expected: \"xix\"\nactual: \"1\"\nstack traceback:\n\t/tmp/tmpwdj7jjbr.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(type(number) == 'number', string.format('number should be a number'))\n\
    \tassert(number > 0 and number <= 1000, string.format('number should be between\
    \ 1 and 1000'))\n\tlocal mini_roman = ''\n\tlocal last_ix = 1\n\twhile number\
    \ ~= 0 do\n\t\t-- find next index after last non-zero digit\n\t\tlocal idx = number:find(string.format('%d%d%d%d',\
    \ 0, 0, 0, 1, 0), last_ix + 1, true)\n\t\tif idx then\n\t\t\t-- subtract 1 from\
    \ idx to exclude the non-zero digit\n\t\t\tidx = idx - 1\n\t\telse\n\t\t\t-- idx\
    \ is nil if no non-zero digit present\n\t\t\tidx = nil\n\t\tend\n\t\tassert(idx,\
    \ string.format('number should be between 1 and 999'))\n\t\tmini_roman = mini_roman\
    \ .. string.format('%d', number:sub(1, idx))\n\t\tlast_ix = idx\n\t\tnumber =\
    \ number:sub(idx + 1)\n\tend\n\treturn mini_roman:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqxh5xe0p.lua:15:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmpqxh5xe0p.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpqxh5xe0p.lua:34: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- TODO: Find a better way to do this!\n  local roman\n  local roman_len\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpqq0b2jyd.lua:32: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   if number < 1 then return '?' end\n   if number < 10 then\n      return string.rep('I',\
    \ number-1)\n   elseif number < 100 then\n      return 'I'\n   elseif number <\
    \ 1000 then\n      return 'III'\n   elseif number < 10000 then\n      return 'IV'\n\
    \   elseif number < 100000 then\n      return 'V'\n   elseif number < 1000000\
    \ then\n      return 'IX'\n   elseif number < 10000000 then\n      return 'X'\n\
    \   elseif number < 100000000 then\n      return 'XL'\n   elseif number < 1000000000\
    \ then\n      return 'L'\n   elseif number < 10000000000 then\n      return 'XC'\n\
    \   elseif number < 100000000000 then\n      return 'C'\n   else\n      return\
    \ 'C'\n   end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp04x0mq0p.lua:40:\
    \ expected: \"xix\"\nactual: \"I\"\nstack traceback:\n\t/tmp/tmp04x0mq0p.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000)\n  if number == 0 then\n    return \"\
    0\"\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmplbypc012.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = \"\"\n  local roman_letters = {}\n  local i = 1 -- The first\
    \ letter gets index 1.\n  -- Iterate the string, char by char.\n  for char in\
    \ number:gmatch(\"%a+\") do\n    -- Add the letter to the roman string if the\
    \ index divides evenly by\n    -- the value of the previous index (modulo 100).\n\
    \    if i % 2 == 0 and number > 0 and (roman:sub(1, 1) == \"\" or roman_letters[roman:sub(1,\
    \ 1)] == nil) then\n      roman_letters[roman:sub(1, 1)] = char\n      roman =\
    \ roman:sub(2, roman:len())\n    else\n      roman_letters[roman:sub(1, 1)] =\
    \ char\n      roman = roman:sub(2, roman:len())\n    end\n    i = i + 1\n  end\n\
    \  -- Add the last letter.\n  if roman:sub(1, 1) == \"\" then\n    roman_letters[roman:sub(1,\
    \ 1)] = number\n  end\n  -- Convert the roman letters to integers.\n  local roman_integers\
    \ = {}\n  for letter, index in pairs(roman_letters) do\n    roman_integers[index]\
    \ = tonumber(letter)\n  end\n  -- Finally, convert the integer number into its\
    \ roman equivalent string.\n  return roman_integers[#roman_integers]\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxojbbflq.lua:13:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmpxojbbflq.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpxojbbflq.lua:41: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The mini roman numeral for a number is obtained by adding 'i' before\n \
    \ -- converting the number to a string (because of the numeral system).\n  --\n\
    \  -- The number of 'i's is equal to the number's digits. The number of 'x's is\n\
    \  -- equal to one. Hence we start with an empty string and append 'i's as we\n\
    \  -- proceed.\n  local roman = \"\"\n  local count = 0\n  local i = 0\n  for\
    \ digit in string.gmatch(tostring(number), \"%d+\") do\n    count = count + 1\n\
    \    if count < 10 then\n      roman = roman .. \"i\"\n    elseif count == 10\
    \ then\n      roman = roman .. \"i\"\n    elseif count == 11 then\n      roman\
    \ = roman .. \"i\"\n    elseif count == 12 then\n      roman = roman .. \"i\"\n\
    \    else\n      roman = roman .. \"x\"\n    end\n    i = i + 1\n  end\n  return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuh9gv_p1.lua:39:\
    \ expected: \"xix\"\nactual: \"i\"\nstack traceback:\n\t/tmp/tmpuh9gv_p1.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number == 0 then\n    return ''\n  end\n  local roman = {\n    ['I'] = 1,\n\
    \    ['V'] = 5,\n    ['X'] = 10,\n    ['L'] = 30,\n    ['C'] = 50,\n    ['D']\
    \ = 100,\n    ['M'] = 500,\n  }\n  local roman_numeral = roman[string.sub(roman,\
    \ number, number)]\n  local roman_numeral_lower = roman_numeral\n  local last_value\
    \ = 0\n  while last_value <= 4 do\n    local next_value = roman_numeral .. string.sub(roman,\
    \ last_value, last_value + 1)\n    roman_numeral = next_value\n    last_value\
    \ = last_value + 1\n  end\n  return roman_numeral_lower\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbthezwf3.lua:21:\
    \ bad argument #1 to 'sub' (string expected, got table)\nstack traceback:\n\t\
    /tmp/tmpbthezwf3.lua:21: in local 'candidate'\n\t/tmp/tmpbthezwf3.lua:35: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- No romans below 1000, so return nothing.\n    if number <= 1000 then\n\
    \        -- Convert number to a string.\n        local string = number\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpf3dfvfg0.lua:33: 'end' expected (to close 'if' at line 10)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tif number < 1 or number > 1000 then\n\t\terror (\"int_to_mini_roman: input out\
    \ of range\")\n\tend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp0617v3go.lua:32: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_num\n    if number <= 1000 then\n        roman_num = 'x'\n  \
    \      local i = 0\n        while(number >= 1000) do\n            roman_num =\
    \ roman_num..'c'\n            number = number-1000\n            i = i+1\n    \
    \    end\n        roman_num = roman_num..romans[i]\n    else\n        roman_num\
    \ = ''\n        local i = 0\n        while(number >= 1000) do\n            roman_num\
    \ = roman_num..'m'\n            number = number-1000\n            i = i+1\n  \
    \      end\n        roman_num = roman_num..romans[i]\n    end\n    return roman_num\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4zqowl_a.lua:18:\
    \ attempt to index a nil value (global 'romans')\nstack traceback:\n\t/tmp/tmp4zqowl_a.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmp4zqowl_a.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ' ';\n    for i = 1, number do\n        roman = roman .. string.char((number\
    \ % 100 - i) % 10 + 1);\n    end\n    return roman:lower();\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0e9vb9hw.lua:19:\
    \ expected: \n\"xix\"\nactual: \n\" \t\b\a\x06\x05\x04\x03\x02\x01\n\t\b\a\x06\
    \x05\x04\x03\x02\x01\"\nstack traceback:\n\t/tmp/tmp0e9vb9hw.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numeral = nil\n    -- The formula is based on roman-numerals\
    \ rather than arabic numerals.\n    -- This means that the numerals used have\
    \ already been converted\n    -- into the equivalent roman numerals.\n    if number\
    \ >= 1000 then\n        roman_numeral = math.floor((number / 1000)%10)..'k'\n\
    \        number = ((number / 1000)-roman_numeral)*1000\n    else\n        roman_numeral\
    \ = math.floor((number / 100)%10)..'m'\n        number = (number / 100) - roman_numeral*100\n\
    \    end\n    if number >= 100 then\n        roman_numeral = roman_numeral..'c'\n\
    \        number = number - 100\n    end\n    if number >= 10 then\n        roman_numeral\
    \ = roman_numeral..'m'\n        number = number - 10\n    end\n    if number >=\
    \ 1 then\n        roman_numeral = roman_numeral..'l'\n        number = number\
    \ - 1\n    end\n    -- Return the final result.\n    return roman_numeral..tostring(number)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmps5kmsud_.lua:18:\
    \ attempt to perform arithmetic on a string value (local 'roman_numeral')\nstack\
    \ traceback:\n\t/tmp/tmps5kmsud_.lua:18: in local 'candidate'\n\t/tmp/tmps5kmsud_.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(number >= 1 and number <= 1000, 'Given number is out of range')\n\tlocal\
    \ result = {}\n\tlocal i = 1\n\twhile i <= number do\n\t\tlocal remainder, counter\
    \ = math.modf(math.floor(number / 1000))\n\t\ttable.insert(result, string.rep(mini_roman_table[counter],\
    \ i - 1))\n\t\tnumber = remainder\n\t\ti = i + 1\n\tend\n\ttable.insert(result,\
    \ mini_roman_table[number - 1])\n\treturn table.concat(result, '', 1)\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpraq1u3om.lua:14:\
    \ attempt to index a nil value (global 'mini_roman_table')\nstack traceback:\n\
    \t/tmp/tmpraq1u3om.lua:14: in local 'candidate'\n\t/tmp/tmpraq1u3om.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number <= 0 then return nil end\n    local roman = roman_string(number)\n\
    \    roman = roman:gsub('%d%d%d?%d?%d?%d?', '%%%1$s')\n    roman = roman:gsub('%d%d%d?%d?%d?%d??',\
    \ '%%%2$s')\n    roman = roman:gsub('%d%d%d?%d?%d??%d?%d?', '%%%3$s')\n    roman\
    \ = roman:gsub('%d%d%d?%d??%d?%d??', '%%%4$s')\n    roman = roman:gsub('%d%d%d?%d??%d??%d??',\
    \ '%%%5$s')\n    roman = roman:gsub('%d%d%d?%d??%d??%d??%d?', '%%%6$s')\n    roman\
    \ = roman:gsub('%d%d%d?%d??%d??%d??%d??', '%%%7$s')\n    roman = roman:gsub('%d%d%d?%d??%d??%d??%d??%d?',\
    \ '%%%8$s')\n    roman = roman:gsub('%d%d%d?%d??%d??%d??%d??%d??%d??', '%%%9$s')\n\
    \    roman = roman:gsub('%d%d%d?%d??%d??%d??%d??%d??%d??%d??', '%%%10$s')\n  \
    \  return roman:gsub('%%%$s', '')\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmeknw6a6.lua:10:\
    \ attempt to call a nil value (global 'roman_string')\nstack traceback:\n\t/tmp/tmpmeknw6a6.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpmeknw6a6.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(type(number) == 'number')\n  assert(number >= 1 and number <= 1000)\n\
    \  -- The mapping is as follows:\n  local map = {\n    -- 0\n    ['i'] = 1000,\n\
    \    ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 9\n   \
    \ ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 10\n  \
    \  ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 11\n  \
    \  ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 12\n  \
    \  ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 13\n  \
    \  ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 14\n  \
    \  ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 15\n  \
    \  ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 16\n  \
    \  ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 17\n  \
    \  ['v'] = 900,\n    ['x'] = 500,\n    ['l'] = 450,\n    ['c'] = 400,\n    ['d']\
    \ = 300,\n    ['m'] = 300,\n    ['a'] = 250,\n    ['n'] = 200,\n    -- 18\n  \
    \  ['v'] = 900,\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvhgje63w.lua:109: '}' expected (to close '{' at line 12) near\
    \ 'function'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- We want to see all of the digits, so we work our way up\n    -- from the\
    \ number by repeatedly dividing it by 10.\n    -- We do NOT want to see all of\
    \ the digits.\n    -- We do not want to see trailing zeros, as they are significant.\n\
    \    -- We do not want to see the leading zeros, because they serve no purpose.\n\
    \    -- We do want to see negative numbers, because we can't represent them\n\
    \    -- with roman numerals.\n    -- We do not want to see fractions, because\
    \ our algorithm doesn't handle\n    -- them properly.\n    -- We do not want to\
    \ see scientific notation; it just makes things harder.\n    -- We only want to\
    \ see positive numbers, and we only want to see digits.\n    -- In particular,\
    \ we do not want to see things like \"0.5\", \"0.E+6\".\n    -- We only want to\
    \ see things like \"9\", not \"99\".\n    -- We only want to see things like \"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\".\n    -- We don't want to see things\
    \ like \"III\", \"II\" or \"I\".\n    -- We only want to see things like \"IV\"\
    , not \"V\".\n    -- We want to see things like \"I\", \"III\", \"III\", \"IV\"\
    .\n    -- Therefore, if we started with a positive number, we must have\n    --\
    \ the first few digits to be non-zero.\n    local digits = {}\n    local negative\
    \ = number:floor() > 0\n    local first_digit = number:floor()\n    if negative\
    \ then\n        first_digit = -first_digit\n    end\n    local last_digit = number:floor()\n\
    \    -- Since we're working with positive numbers, there will never be any decimals\n\
    \    -- after the last digit.\n    -- Therefore, our first few digits will always\
    \ be non-zero.\n    local last_digit_index = #digits + 1\n    for i = first_digit,\
    \ 1, -1 do\n        -- We don't want to see trailing zeros, as they are significant.\n\
    \        -- We don't want to see a decimal point or exponent symbol (e.g., \"\
    .E+3\").\n        -- We want to see negative numbers, because we can't represent\
    \ them\n        -- with roman numerals.\n        if i > 0 and i % 10 == 0 then\n\
    \            -- We don't want to see fractions, because our algorithm doesn't\
    \ handle\n            -- them properly.\n            -- We want to see scientific\
    \ notation; it just makes things harder.\n            -- We don't want to see\
    \ things like \"0.5\", \"0.E+6\".\n            -- We want to see things like \"\
    9\", not \"99\".\n            -- We want to see things like \"M\", \"CM\", \"\
    D\", \"CD\", \"C\", \"XC\".\n\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpnrwopdpt.lua:72: 'end' expected (to close 'if' at line 44)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number <= 0 then return nil end\n    local roman = \"\"\n    local roman_numerals\
    \ = {\n        100 = 'M',\n        900 = 'CM',\n        500 = 'D',\n        400\
    \ = 'CD',\n        100 = 'C',\n        90 = 'XC',\n        50 = 'L',\n       \
    \ 40 = 'XL',\n        10 = 'X',\n        9 = 'IX',\n        5 = 'V',\n       \
    \ 4 = 'IV',\n        1 = 'I',\n    }\n    for index = 1, number do\n        local\
    \ roman_numeral = roman_numerals[math.floor((number-index) * 10000)]\n       \
    \ if roman_numeral then\n            roman = roman .. roman_numeral\n        else\n\
    \            roman = roman .. roman_numeral..\"I\"\n        end\n    end\n   \
    \ return string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphnv7ff10.lua:12: '}' expected (to close '{' at line 11) near\
    \ '='\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = 'C'\n  local i = 1\n  while number >= 100 do\n    roman = roman\
    \ .. 'C'\n    i = i + 1\n    number = number - 100\n  end\n  if number >= 10 then\n\
    \    roman = roman .. 'L'\n    i = i + 1\n    number = number - 10\n  end\n  if\
    \ number >= 1 then\n    roman = roman .. 'X'\n    i = i + 1\n    number = number\
    \ - 1\n  end\n  return roman, i\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0vs976jr.lua:32:\
    \ expected: \"xix\"\nactual: \"CLX\"\nstack traceback:\n\t/tmp/tmp0vs976jr.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- No exception for negative numbers\n  if not number and number ~= 0 then\n\
    \    error('number must be positive')\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpekpyh505.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The mapping from integer to string was taken from:\n  -- https://github.com/codewithdan/mini-roman/blob/master/src/int2rom.lua\n\
    \  if number < 1 then\n    return nil\n  end\n  local roman_numerals = {\n   \
    \ I='', II='M', III='D', IV='C', V='L', VI='X', VII='V', VIII='IX',\n    IX='C',\
    \ X='L', XI='X', XII='L', XIII='X', XIV='C',\n  }\n  local roman_numeral = ''\n\
    \  for i = 1, 4 do\n    roman_numeral = roman_numerals[number]\n    if roman_numeral\
    \ ~= '' then\n      break\n    end\n    roman_numeral = roman_numerals[number\
    \ - i * 100]\n    if roman_numeral ~= '' then\n      break\n    end\n  end\n \
    \ if roman_numeral ~= '' then\n    return roman_numeral:lower()\n  else\n    return\
    \ nil\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpiirr9nah.lua:30:\
    \ attempt to index a nil value (local 'roman_numeral')\nstack traceback:\n\t/tmp/tmpiirr9nah.lua:30:\
    \ in local 'candidate'\n\t/tmp/tmpiirr9nah.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- No checks\n  assert(number, \"Expected a positive integer\")\n  assert(number\
    \ >= 1, \"Expected a positive integer\")\n  assert(number <= 1000, \"Expected\
    \ a positive integer\")\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4oo5078q.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   local roman\n   for i = 1, number do\n      local roman = (roman and roman\
    \ .. ',') or ''\n      roman = roman .. string.sub({'I', 'V', 'X', 'L', 'C', 'D',\
    \ 'M'},\n         math.floor((number - i)/3) + 1, math.floor((number - i) % 3)\
    \ + 1)\n   end\n   return string.lower(roman)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxlawu3ep.lua:12:\
    \ bad argument #1 to 'sub' (string expected, got table)\nstack traceback:\n\t\
    /tmp/tmpxlawu3ep.lua:12: in local 'candidate'\n\t/tmp/tmpxlawu3ep.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    number = math.floor(number)\n    if number < 1 then return 'ERROR' end\n\
    \    local romans = {\n        '',\n        'I',\n        'II',\n        'III',\n\
    \        'IV',\n        'V',\n        'VI',\n        'VII',\n        'VIII',\n\
    \        'IX',\n        'X'\n    }\n    local roman = romans[number]\n    local\
    \ count = 0\n    local result = \"\"\n    while number > 0 do\n        count =\
    \ number % 10\n        roman = roman:gsub('%d%', romans[count])\n        number\
    \ = math.floor(number / 10)\n        if number == 0 then\n            break\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptg71ol0p.lua:29:\
    \ attempt to index a nil value (local 'roman')\nstack traceback:\n\t/tmp/tmptg71ol0p.lua:29:\
    \ in local 'candidate'\n\t/tmp/tmptg71ol0p.lua:41: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number, 'Invalid input')\n  assert(number >= 1, 'Invalid input: number\
    \ should be positive')\n  assert(number <= 1000, 'Invalid input: number should\
    \ be less than 1000')\n  -- The number is assumed to be in decreasing order\n\
    \  local result = {}\n  local i = 1 -- Iterate over the remaining digits\n  while\
    \ number >= 1000 do\n    table.insert(result, i)\n    number = number % 1000\n\
    \    i = i + 1\n  end\n  table.insert(result, i)\n  return table.concat(result,\
    \ '')\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbqdq91e1.lua:27:\
    \ expected: \"xix\"\nactual: \"1\"\nstack traceback:\n\t/tmp/tmpbqdq91e1.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    number = number or 0\n    local digits = tostring(number:reverse())\n   \
    \ local roman_numeral = ''\n    local current_numeral = ''\n    for i = 1, #digits\
    \ do\n        if string.byte(digits, i) == 0 then\n            if current_numeral\
    \ ~= '' and roman_numeral ~= '' then\n                roman_numeral = roman_numeral\
    \ .. current_numeral\n                current_numeral = ''\n            end\n\
    \        else\n            current_numeral = current_numeral .. string.sub(digits,\
    \ i)\n        end\n    end\n    return roman_numeral:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpurgyggir.lua:10:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmpurgyggir.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpurgyggir.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 then\n        return nil\n    end\n    local roman = romanize(number)\n\
    \    local i, count = 1, 1\n    local ret = ''\n    while i < #roman do\n    \
    \    local char = roman[i]\n        if i == #roman then\n            ret =  char\n\
    \        elseif count > 1 then\n            ret =  char..'x'..char\n        else\n\
    \            ret =  char\n        end\n        count = count + 1\n        i =\
    \ i + 1\n    end\n    if number<1000 then\n        return tolower(ret)\n    else\n\
    \        return nil\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5bz0wu2e.lua:12:\
    \ attempt to call a nil value (global 'romanize')\nstack traceback:\n\t/tmp/tmp5bz0wu2e.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmp5bz0wu2e.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Convert to base 10\n    number = tonumber(number)\n    -- The number must\
    \ not be negative\n    if not number then return nil end\n    -- Test for invalid\
    \ cases\n    if number == 1 then return \"I\" end\n    if number == 10 then return\
    \ \"X\" end\n    -- We only care about the lower part\n    local result = \"\"\
    \n    while number > 1 do\n        local multiple = math.floor((number - 1) /\
    \ 3)\n        result = \"V\" .. result .. int_to_mini_roman(multiple)\n      \
    \  local remaining = number - multiple*3\n        number = remaining\n    end\n\
    \    -- If the number was originally odd, prepend a \"I\"\n    if number % 2 ==\
    \ 1 then\n        result = \"I\" .. result\n    end\n    -- Return the result\
    \ in lowercase\n    return result:lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    number = tonumber(number)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphchf5vtc.lua:30: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Check argument for being an integer number between 1 and 1000\n  if not\
    \ (number >= 1 and number <= 1000) then return nil end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdzsspprr.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- assert(number >= 0 and number <= 1000)\n\t\n\t-- Start with an initial value\
    \ of empty string.\n\tlocal roman = ''\n\t\n\t-- The first 5 powers of ten are\
    \ all special cases of the roman numerals \n\t-- of that power. For each such\
    \ power, there are exactly five cases to \n\t-- which that particular power of\
    \ ten can be mapped to its roman numeral.\n\t-- Start by appending a \"i\" to\
    \ indicate that the power of the tens \n\t-- is itself the roman numeral of the\
    \ power of tens.\n\troman = roman .. 'i' .. 'i'\n\t\n\t-- Add the tens, starting\
    \ with the number itself.\n\tlocal tens = number\n\tfor i=1, 5 do\n\t\t-- assert(tens\
    \ >= 0 and tens < 1000)\n\t\t\n\t\t-- Compute the corresponding roman numeral,\
    \ and append it to roman.\n\t\troman = roman .. mini_roman_to_int(tens)\n\t\t\n\
    \t\t-- Divide the number by 10.\n\t\ttens = tens - 10\n\tend\n\t\n\t-- If the\
    \ number was less than 10, append \"m\" instead.\n\tif number < 10 then\n\t\t\
    roman = roman .. 'm'\n\tend\n\t\n\treturn roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpx08bpj6l.lua:27:\
    \ attempt to call a nil value (global 'mini_roman_to_int')\nstack traceback:\n\
    \t/tmp/tmpx08bpj6l.lua:27: in local 'candidate'\n\t/tmp/tmpx08bpj6l.lua:44: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Handle negative numbers\n  if number < 0 then\n    return nil\n  elseif\
    \ number == 0 then\n    return '0'\n  else\n    -- Find the highest 'm' such that\
    \ 'm' fits in the number\n    -- (floor((n-1)/m) - 1).\n    -- This gives us the\
    \ largest number such that 'm' fits in\n    -- the number without losing information.\n\
    \    -- Note that we do not have to handle any special cases for 'm' equal\n \
    \   -- to 0.\n    local m = math.floor((number - 1) / math.floor((number - 1)\
    \ / 1000))\n    -- If 'm' is larger than 1000, then we can just subtract 'm' from\
    \ the\n    -- number to get the same effect as rounding up. Otherwise, round up\n\
    \    -- first, and then subtract 'm' from the number to get the desired effect.\n\
    \    local result = round_up_first(number, m)\n    -- Subtract 'm' from the number,\
    \ then add 'i' to the result.\n    return result + (\"i\"):sub(string.len(result))\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpewkexupn.lua:25:\
    \ attempt to call a nil value (global 'round_up_first')\nstack traceback:\n\t\
    /tmp/tmpewkexupn.lua:25: in local 'candidate'\n\t/tmp/tmpewkexupn.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result to an empty string.\n  local result = ''\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6fi1vpch.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\n  local num_str = to_string(number)\n  if num_str:find('^0')\
    \ then\n    num_str = num_str:gsub('^0', ' ')\n    roman = nil\n  elseif num_str:len()\
    \ == 3 then\n    roman = nil\n  elseif num_str:len() > 3 then\n    local romans\
    \ = romans_to_romans(num_str)\n    roman = romans[number]\n  end\n  if roman then\n\
    \    return roman:lower()\n  else\n    return nil\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpngwj0065.lua:10:\
    \ attempt to call a nil value (global 'to_string')\nstack traceback:\n\t/tmp/tmpngwj0065.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpngwj0065.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   -- Sanity check\n   if number < 1 or number > 1000 then\n      return 'X'\n\
    \   end\n   local romans = {\n      [1] = 'I',\n      [2] = 'II',\n      [3] =\
    \ 'III',\n      [4] = 'IV',\n      [5] = 'V',\n      [6] = 'VI',\n      [7] =\
    \ 'VII',\n      [8] = 'VIII',\n      [9] = 'IX',\n   }\n   local roman_numeral\
    \ = romans[number]\n   -- Add 'I' to the numeral if it is a multiple of 4\n  \
    \ if number % 4 ~= 0 then\n      roman_numeral = roman_numeral .. 'I'\n   end\n\
    \   -- Append the remaining number components\n   for i = 2, number do\n     \
    \ roman_numeral = roman_numeral .. romans[i]\n   end\n   return string.lower(roman_numeral)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8xdvt7d3.lua:27:\
    \ attempt to concatenate a nil value (local 'roman_numeral')\nstack traceback:\n\
    \t/tmp/tmp8xdvt7d3.lua:27: in local 'candidate'\n\t/tmp/tmp8xdvt7d3.lua:39: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(number >= 1 and number <= 1000)\n\tlocal roman = \n\t\t'M',\n\t\t'CM',\n\
    \t\t'D',\n\t\t'CD',\n\t\t'C',\n\t\t'XC',\n\t\t'L',\n\t\t'XL',\n\t\t'X',\n\t\t\
    'IX',\n\t\t'V',\n\t\t'IV',\n\t\t'I',\n\tend\n\tfor i = 1, 8 do\n\t\tlocal mult\
    \ = number / math.pow(10, i * 2 - 1)\n\t\tif mult >= 10 then\n\t\t\troman = roman\
    \ .. roman\n\t\t\tnumber = mult - 10\n\t\telse\n\t\t\troman = roman .. roman\n\
    \t\t\tnumber = mult\n\t\tend\n\tend\n\treturn roman:lower() .. math.ceil(number\
    \ / 10):lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdzh06z4c.lua:24: unexpected symbol near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result\n  local result = ''\n  -- Check for special cases\n \
    \ if number <= 0 then\n    return 'zero'\n  elseif number == 1 then\n    return\
    \ 'i' -- Special case\n  elseif number == 2 then\n    return 'iix'\n  elseif number\
    \ == 3 then\n    return 'ixi'\n  elseif number == 4 then\n    return 'v'\n  elseif\
    \ number == 5 then\n    return 'vi'\n  elseif number == 6 then\n    return 'vii'\n\
    \  elseif number == 7 then\n    return 'ix'\n  elseif number == 8 then\n    return\
    \ 'ixi'\n  elseif number == 9 then\n    return 'l'\n  elseif number == 10 then\n\
    \    return 'li'\n  elseif number == 11 then\n    return 'lx'\n  elseif number\
    \ == 12 then\n    return 'l'\n  elseif number == 13 then\n    return 'lii'\n \
    \ elseif number == 14 then\n    return 'lxx'\n  elseif number == 15 then\n   \
    \ return 'l'\n  elseif number == 16 then\n    return 'lii'\n  elseif number ==\
    \ 17 then\n    return 'lx'\n  elseif number == 18 then\n    return 'l'\n  elseif\
    \ number == 19 then\n    return 'lii'\n  elseif number == 20 then\n    return\
    \ 'lx'\n  elseif number == 21 then\n    return 'l'\n  elseif number == 22 then\n\
    \    return 'lii'\n  elseif number == 23 then\n    return 'lx'\n  elseif number\
    \ == 24 then\n    return 'l'\n  elseif number == 25 then\n    return 'lii'\n \
    \ elseif number == 26 then\n    return 'lxx'\n  elseif number == 27 then\n   \
    \ return 'l'\n  elseif number == 28 then\n    return 'lii'\n  elseif number ==\
    \ 29 then\n    return 'lx'\n  elseif number == 30 then\n    return 'l'\n  elseif\
    \ number == 31 then\n    return 'lii'\n  elseif number == 32 then\n    return\
    \ 'lx'\n  elseif number == 33 then\n    return 'l'\n  elseif number == 34 then\n\
    \    return 'lii'\n  elseif number == 35 then\n    return 'lx'\n  elseif number\
    \ == 36 then\n    return 'l'\n  elseif number == 37 then\n    return 'lii'\n \
    \ elseif number == 38 then\n    return 'lx'\n  elseif number == 39 then\n    return\
    \ 'l'\n  elseif number == 40 then\n    return 'lii'\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpa0rklobh.lua:94: 'end' expected (to close 'if' at line 12)\
    \ near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romanize(number)\n  local mini = roman:sub(1, 1)\n  for i = 2,\
    \ roman:len() do\n    mini = mini .. roman:sub(i, i)\n  end\n  return mini\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6ugq4rk3.lua:9:\
    \ attempt to call a nil value (global 'romanize')\nstack traceback:\n\t/tmp/tmp6ugq4rk3.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmp6ugq4rk3.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Base case\n    if number == 0 then\n        return ''\n    end\n    --\
    \ Recursive case\n    local remainder\n    local i = 2\n    while number >= 10\
    \ do\n        number = number - 10\n        remainder = math.floor(remainder *\
    \ 100) + 10\n        table.insert(roman_table, roman_strings[remainder])\n   \
    \     i = i + 1\n    end\n    remainder = math.floor(remainder * 100)\n    table.insert(roman_table,\
    \ roman_strings[remainder])\n    i = i + 1\n    while i < 10 and number >= 1000\
    \ do\n        number = number - 1000\n        remainder = math.floor(remainder\
    \ * 1000) + 1000\n        table.insert(roman_table, roman_strings[remainder])\n\
    \        i = i + 1\n    end\n    table.insert(roman_table, roman_strings[number])\n\
    \    return table.concat(roman_table, \"\")\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpwlcp7t10.lua:18:\
    \ attempt to perform arithmetic on a nil value (local 'remainder')\nstack traceback:\n\
    \t/tmp/tmpwlcp7t10.lua:18: in local 'candidate'\n\t/tmp/tmpwlcp7t10.lua:38: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case.\n  if number <= 1 then\n    return number\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpxx9q2gaz.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Based on \"Methods of Mathematical Inquiry\", Academic Press, 1995.\n  --\
    \ The algorithm converts the integer to a roman numeral.\n  -- Romans use consecutive\
    \ integers starting with 1, except for the first row\n  -- where consecutive integers\
    \ start at 2.\n  -- For example, the integer 100 is converted to the numeral IX.\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9rjfel20.lua:34: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(1 <= number <= 1000,\n         'Argument to int_to_mini_roman must be\
    \ an integer between 1 and 999')\n  local roman = ''\n  for i = 1, number do roman\
    \ = roman .. roman_numeral(i) end\n  return roman:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzt5a0i1g.lua:9:\
    \ attempt to compare boolean with number\nstack traceback:\n\t/tmp/tmpzt5a0i1g.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpzt5a0i1g.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tnumber = tonumber(number)\n\tif number <= 0 then return end\n\tlocal roman =\
    \ { ['I'] = 1, 'V' = 5, 'X' = 10, 'L' = 50 }\n\tlocal n = 1\n\twhile n > 0 do\n\
    \t\tlocal c = math.floor(number / roman.V)\n\t\tnumber = number - c * roman.V\n\
    \t\troman[roman[roman.I] .. c] = n\n\t\tn = n + 1 end\n\tlocal romanstring\n\t\
    if number > 0 then romanstring = roman[roman[roman.I] .. 1]\n\t\telse romanstring\
    \ = roman[roman[roman.I]]\n\tend\n\treturn romanstring\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8orhcmh0.lua:11: '}' expected near '='\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result\n  local result = ''\n  -- Only integers greater than\
    \ 0 are supported\n  if number <= 0 then\n    return '?'\n  -- Only valid roman\
    \ numbers are supported\n  elseif number < 1000 then\n    -- Divide number by\
    \ 1000\n    local number = number / 1000\n    -- Iterate through each thousand\n\
    \    for index = 0, 1, 1000 do\n      -- Subtract current thousand from number\n\
    \      number = number - index\n      -- Determine which digit the number has\n\
    \      local digit = math.floor(number)\n      -- Convert the digit to a string\n\
    \      result = result .. mini_to_roman(digit)\n    end\n    -- Add the final\
    \ digit\n    result = result .. mini_to_roman(math.floor(number - math.floor(number)))\n\
    \  else\n    -- Iterate through each hundred\n    for index = 0, 1, 100 do\n \
    \     -- Subtract current hundred from number\n      number = number - index\n\
    \      -- Determine which digit the number has\n      local digit = math.floor(number)\n\
    \      -- Convert the digit to a string\n      result = result .. mini_to_roman(digit)\n\
    \    end\n    -- Add the final digit\n    result = result .. mini_to_roman(math.floor(number\
    \ - math.floor(number)))\n  end\n  return result:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpl93z2lnf.lua:25:\
    \ attempt to call a nil value (global 'mini_to_roman')\nstack traceback:\n\t/tmp/tmpl93z2lnf.lua:25:\
    \ in local 'candidate'\n\t/tmp/tmpl93z2lnf.lua:48: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number == nil then\n    return nil\n  end\n  local romans = {\n    i = 0,\n\
    \    f = \"i\"\n  }\n  while romans.i <= number do\n    romans.i = romans.i +\
    \ 100\n    romans.f = romans.f .. \"v\"\n  end\n  return string.lower(romans.f)\
    \ .. romans.i\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppg4nhluc.lua:26:\
    \ expected: \"xix\"\nactual: \"iv100\"\nstack traceback:\n\t/tmp/tmppg4nhluc.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result\n  local roman = \"\"\n  -- Calculate Roman numerals\n\
    \  for i=1,1000 do\n    roman = roman .. string.rep(\"M\",i-1) .. string.rep(\"\
    CM\",3-(i%100)) .. string.rep(\"D\",i%10)\n  end\n  -- Convert to lower case\n\
    \  roman = string.lower(roman)\n  -- Return Roman numeral\n  return roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal alphabet = {\n\t\t['M'] = 1000,\n\t\t['CM'] = 900,\n\t\t['D'] = 500,\n\
    \t\t['CD'] = 400,\n\t\t['C'] = 100,\n\t\t['XC'] = 90,\n\t\t['L'] = 50,\n\t\t['XL']\
    \ = 40,\n\t\t['X'] = 10,\n\t\t['IX'] = 9,\n\t\t['V'] = 5,\n\t\t['IV'] = 4,\n\t\
    \t['I'] = 1,\n\t}\n\t-- Find the largest number less than or equal to number\n\
    \tlocal largest_index = nil\n\tfor index, value in pairs(alphabet) do\n\t\tif\
    \ value < number then\n\t\t\tlargest_index = index\n\t\t\tbreak\n\t\tend\n\tend\n\
    \t-- Find the smallest number greater than or equal to number\n\tlocal smallest_index\
    \ = nil\n\tfor index, value in pairs(alphabet) do\n\t\tif value > number then\n\
    \t\t\tsmallest_index = index\n\t\t\tbreak\n\t\tend\n\tend\n\t-- If the largest\
    \ number is equal to the number, return it.\n\tlocal roman_numeral = alphabet[largest_index]\
    \ .. alphabet[smallest_index]\n\treturn roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsmn866uq.lua:48:\
    \ expected: \"xix\"\nactual: \"1040\"\nstack traceback:\n\t/tmp/tmpsmn866uq.lua:48:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman, int_str, i = roman_num_to_roman(number, 1)\n    \n    while\
    \ i < math.floor(number / 100) do\n        roman, i = roman_num_to_roman(100 *\
    \ number + i, 2)\n    end\n    \n    while i < number do\n        roman = roman\
    \ .. 'M'\n        i = i + 1\n    end\n    return roman, i + 1\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpy4v7mvxh.lua:9:\
    \ attempt to call a nil value (global 'roman_num_to_roman')\nstack traceback:\n\
    \t/tmp/tmpy4v7mvxh.lua:9: in local 'candidate'\n\t/tmp/tmpy4v7mvxh.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = string.gsub(\n      string.rep('MCMXCIIV', number/1000),\n\
    \        '(..)(..)(..)(..)',\n        function(digits)\n            return digits[1]\
    \ .. digits[2]\n        end\n    )\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpqyif48ch.lua:36: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal romans = {}\n\tromans[1000] = \"M\";    -- 1000s\n\tromans[900] = \"CM\"\
    ;   -- 900s\n\tromans[500] = \"D\";    -- 500s\n\tromans[400] = \"CD\";   -- 400s\n\
    \tromans[100] = \"C\";    -- 100s\n\tromans[90] = \"XC\";   -- 90s\n\tromans[50]\
    \ = \"L\";    -- 50s\n\tromans[40] = \"XL\";   -- 40s\n\tromans[10] = \"X\"; \
    \   -- 10s\n\tromans[9] = \"IX\";   -- 9s\n\tromans[5] = \"V\";    -- 5s\n\tromans[4]\
    \ = \"IV\";   -- 4s\n\tromans[1] = \"I\";    -- 1s\n\t\n\tlocal current_roman\
    \ = nil\n\tfor i = 1, number do\n\t\tif romans[i] ~= nil then\n\t\t\tcurrent_roman\
    \ = romans[i]\n\t\t\tbreak\n\t\telse\n\t\t\tcurrent_roman = romans[number % 100]\n\
    \t\t\tnumber = number // 100\n\t\tend\n\tend\n\treturn current_roman, number\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp31rejw2a.lua:40:\
    \ expected: \"xix\"\nactual: \"I\"\nstack traceback:\n\t/tmp/tmp31rejw2a.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local romans = { 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X',\
    \ 'XI', 'XII', 'XIII', 'XIV', 'XX',\n                 'XXX', 'XL', 'XC', 'L',\
    \ 'LX', 'LXX', 'LXXX', 'XC', 'XCXX', 'XLXXX', 'XIV',\n                 'XIVXX',\
    \ 'XXXI', 'XXXII', 'XXXIII', 'XXXIV', 'XV', 'XVI', 'XVII', 'XVIII' }\n  local\
    \ roman = {}\n  local i = 0\n  while i < #romans do\n    roman[i] = romans[i]:sub(1,\
    \ romans[i]:len() - 1):lower()\n    i = i + 1\n  end\n  if roman[number] == 'XXX'\
    \ then\n    return romans[number - 1]\n  else\n    return romans[number]\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdvxd6f8g.lua:15:\
    \ attempt to index a nil value (field '?')\nstack traceback:\n\t/tmp/tmpdvxd6f8g.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpdvxd6f8g.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   if number < 1 then\n      return nil\n   end\n   if number >= 1000 then\n\
    \      return 'M'\n   end\n   if number >= 900 and number < 1000 then\n      return\
    \ 'CM'\n   end\n   if number >= 500 and number < 900 then\n      return 'D'\n\
    \   end\n   if number >= 400 and number < 500 then\n      return 'CD'\n   end\n\
    \   if number >= 100 and number < 400 then\n      return 'C'\n   end\n   if number\
    \ >= 90 and number < 100 then\n      return 'XC'\n   end\n   if number >= 50 and\
    \ number < 90 then\n      return 'L'\n   end\n   if number >= 40 and number <\
    \ 50 then\n      return 'XL'\n   end\n   if number >= 10 and number < 40 then\n\
    \      return 'X'\n   end\n   if number >= 9 and number < 10 then\n      return\
    \ 'IX'\n   end\n   if number >= 5 and number < 9 then\n      return 'V'\n   end\n\
    \   if number >= 4 and number < 5 then\n      return 'IV'\n   end\n   if number\
    \ >= 1 and number < 4 then\n      return nil\n   end\n   if number == 0 then\n\
    \      return '0'\n   end\n   if number == 1 then\n      return 'I'\n   end\n\
    \   return nil\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq_6wbxe7.lua:63:\
    \ expected: \"xix\"\nactual: \"X\"\nstack traceback:\n\t/tmp/tmpq_6wbxe7.lua:63:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_table.roman\n  for i = 1, 1000 do\n    if roman[i] == number\
    \ then\n      return string.sub(i, 1, i-1)\n    end\n  end\n  return nil\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv9pfoi7s.lua:9:\
    \ attempt to index a nil value (global 'roman_table')\nstack traceback:\n\t/tmp/tmpv9pfoi7s.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpv9pfoi7s.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_num = ''\n    local num_div = 1\n    local last_roman_num = nil\n\
    \    local first_roman_num = nil\n    local roman_num_len = nil\n    if number\
    \ == 0 then\n        roman_num = ''\n        return\n    end\n    while number\
    \ > 0 do\n        if first_roman_num == nil then\n            roman_num = string.sub(roman_num,\
    \ 1, roman_num_len - 1..)\n        end\n        local digit = math.floor(number\
    \ / num_div)\n        local remainder = number - digit * num_div\n        if remainder\
    \ < 10 then\n            last_roman_num = string.sub(roman_num, roman_num_len\
    \ - 1..)\n            last_roman_num = string.sub(last_roman_num, roman_num_len\
    \ - 1.., roman_num_len - 1..)\n            last_roman_num = string.sub(last_roman_num,\
    \ 1, roman_num_len - 1..)\n        elseif remainder < 100 then\n            roman_num\
    \ = string.sub(roman_num, roman_num_len - 1..)\n            roman_num = string.sub(roman_num,\
    \ roman_num_len - 1.., roman_num_len - 1..)\n            roman_num = string.sub(roman_num,\
    \ 1, roman_num_len - 1..)\n            roman_num_len = 0\n        elseif remainder\
    \ < 1000 then\n            roman_num_len += 1\n        end\n        num_div =\
    \ num_div * 10\n        first_roman_num = string.sub(roman_num, roman_num_len\
    \ - 1..)\n        first_roman_num = string.sub(first_roman_num, roman_num_len\
    \ - 1.., roman_num_len - 1..)\n        first_roman_num = string.sub(first_roman_num,\
    \ 1, roman_num_len - 1..)\n    end\n    if roman_num ~= '' then\n        roman_num\
    \ = roman_num.\n        sub(roman_num., 1, roman_num_len - 1..)\n    end\n   \
    \ return roman_num:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsd_ah_zp.lua:20: malformed number near '1..'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.gsub(string.rep('I', number), 'I', 'V')\n  roman = string.gsub(roman,\
    \ 'V', 'I')\n  roman = roman:gsub('(.)I', '\\1X')\n  roman = roman:gsub('(.)I',\
    \ '\\1X')\n  roman = roman:gsub('(.)I', '\\1X')\n  roman = roman:gsub('(.)I',\
    \ '\\1X')\n  roman = roman:gsub('(.)I', '\\1X')\n  roman = roman:gsub('(.)I',\
    \ '\\1X')\n  roman = roman:gsub('(.)I', '\\1X')\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp807t7szw.lua:24:\
    \ expected: \"xix\"\nactual: \"\x01X\x01X\x01X\x01X\x01X\x01X\x01X\x01X\x01\x01\
    X\"\nstack traceback:\n\t/tmp/tmp807t7szw.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   assert(type(number) == number, \"Expected a number\")\n   assert(type(number)\
    \ == number, \"Expected a number\")\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpb5npwwl3.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local i = 1\n    while number > 0 do\n        local\
    \ remainder = math.floor((number / 100) * i)\n        number = number - remainder\n\
    \        i = i + 1\n        roman = roman .. string.sub(i, 0, 1) .. 'i' .. string.sub(remainder,\
    \ -1)\n    end\n    roman = roman .. string.sub(i, 1, 1) .. 'i' .. 'I'\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1jnszc7r.lua:24:\
    \ expected: \"xix\"\nactual: \"2i03i04i05i06i07i18i19i11i11i11i11i11i11i11i11i11i11i12i12i12i02i02i02i02i12i02i02i03i03i03i03i03i03i13i03i03i03i04i04i04i04i04i04i04i04i04i04i05i05i15i05i05i05i05i05i05i05i06i06i06i06i06i06i06i06i06i06i07i07i07i07i07i07i07i07i07i07i08i08i08i08i08i08i08i08i08i08i09i09i09i09i09i09i09i09i09i09i01i01i11iI\"\
    \nstack traceback:\n\t/tmp/tmp1jnszc7r.lua:24: in function 'test_humaneval'\n\n\
    Ran 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = \"\"\n  while number >= 100 do\n    roman = roman .. \"d\"\n\
    \    number = number - 100\n  end\n  if number >= 10 then\n    roman = roman ..\
    \ \"c\"\n    number = number - 10\n  end\n  roman = roman .. \"m\"\n  number =\
    \ number - 1\n  while number >= 1000 do\n    roman = roman .. \"c\"\n    number\
    \ = number - 1000\n  end\n  roman = roman .. \"m\"\n  number = number - 1\n  return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp669xk07y.lua:32:\
    \ expected: \"xix\"\nactual: \"cmm\"\nstack traceback:\n\t/tmp/tmp669xk07y.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The roman numeral is just the integer with the highest decimal digit removed.\n\
    \  -- E.g. 5 -> '', 15 -> 'i', 20 -> 'ii', 252 -> 'cdxxvi'.\n  -- If the highest\
    \ decimal digit was 3, the roman numeral would be 'MMM'.\n  local int_str = tostring(number)\n\
    \  -- Find the position of the decimal place in int_str and remove it.\n  local\
    \ decimal_place_index = string.find(int_str, \".\")\n  local new_number = number:sub(1,\
    \ decimal_place_index - 1)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpds_iuknu.lua:36: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    -- Base case:\n    if number == 0 then\n        roman\
    \ = 'I'\n        return roman\n    end\n    local digit_count = 1\n    local denominator\
    \ = math.floor((number * 100) + 0.5)\n    while denominator > 10 do\n        digit_count\
    \ = digit_count + 1\n        denominator = math.floor((denominator * 100) + 0.5)\n\
    \    end\n    for digit = 1, digit_count do\n        local remainder\n       \
    \ remainder = (number - (10^digit_count * digit)) / denominator\n        roman\
    \ = (remainder * 10^digit_count) + roman .. 'I'\n    end\n    roman = roman:sub(1,string.reverse(roman))\n\
    \    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpad3i05xn.lua:24:\
    \ attempt to perform arithmetic on a string value (local 'roman')\nstack traceback:\n\
    \t/tmp/tmpad3i05xn.lua:24: in local 'candidate'\n\t/tmp/tmpad3i05xn.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number <= 1000 then\n        return string.sub(mini_roman_table[number],\
    \ 0, 1)\n    end\n    local num\n    for num = 0, 1000 do\n        if mini_roman_table[number]\
    \ == mini_roman_table[num] then\n            break\n        end\n    end\n   \
    \ return string.sub(mini_roman_table[num], 0, 1) ..\n        int_to_mini_roman(number\
    \ / 1000) ..\n        int_to_mini_roman(number % 1000)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpjpr3c_w8.lua:10:\
    \ attempt to index a nil value (global 'mini_roman_table')\nstack traceback:\n\
    \t/tmp/tmpjpr3c_w8.lua:10: in local 'candidate'\n\t/tmp/tmpjpr3c_w8.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Handle negative cases\n    if number <= 0 then\n        return nil\n \
    \   end\n    \n    -- Find the first multiple of the thousandth\n    local thousandth\
    \ = math.floor(number / 1000)\n    -- Multiply it by the thousandth to get the\
    \ next multiple\n    local next_thousandth = number * 1000\n    \n    -- Find\
    \ the first multiple of the hundredth\n    local hundredth = math.floor(next_thousandth\
    \ / 100)\n    -- Multiply it by the hundredth to get the next multiple\n    local\
    \ next_hundredth = next_thousandth * 100\n    \n    -- Find the first multiple\
    \ of the tenth\n    local tenth = math.floor(next_hundredth / 10)\n    -- Multiply\
    \ it by the tenth to get the next multiple\n    local next_tenth = next_hundredth\
    \ * 10\n    \n    -- Find the first multiple of the unit\n    local unit = math.floor(next_tenth\
    \ / 1)\n    -- Multiply it by the unit to get the next multiple\n    local next_unit\
    \ = next_tenth * 1\n    \n    -- Roman-ize all digits from 1-9\n    local roman_digits\
    \ = \"\"\n    if unit >= 1 then\n        roman_digits = roman_digits .. \"I\"\n\
    \    elseif unit >= 2 then\n        roman_digits = roman_digits .. \"II\"\n  \
    \  elseif unit >= 3 then\n        roman_digits = roman_digits .. \"III\"\n   \
    \ elseif unit >= 4 then\n        roman_digits = roman_digits .. \"IV\"\n    elseif\
    \ unit >= 5 then\n        roman_digits = roman_digits .. \"V\"\n    elseif unit\
    \ >= 6 then\n        roman_digits = roman_digits .. \"VI\"\n    elseif unit >=\
    \ 7 then\n        roman_digits = roman_digits .. \"VII\"\n    elseif unit >= 8\
    \ then\n        roman_digits = roman_digits .. \"VIII\"\n    elseif unit >= 9\
    \ then\n        roman_digits = roman_digits .. \"IX\"\n    end\n    \n    -- Roman-ize\
    \ all digits from 10-19\n    roman_digits = roman_digits .. string.format(\"%c\"\
    , math.floor(number / 10))\n    \n    -- Roman-ize all digits from 20-99\n   \
    \ roman_digits = roman_digits .. string.format(\"%c\", math.floor(number / 100))\n\
    \    \n    -- Roman-ize all digits from 100-999\n    roman_digits = roman_digits\
    \ .. string.format(\"%c\", math.floor(number / 1000\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpzrmy7j0f.lua:64: ')' expected (to close '(' at line 63) near\
    \ 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number <= 1000, 'Invalid argument to int_to_mini_roman')\n  local roman\
    \ = ''\n  local max_roman = 1000\n  for i = 1, number do\n    if i % 1000 < max_roman\
    \ then\n      roman = roman .. 'm'\n    else\n      roman = roman .. 'c'\n   \
    \ end\n  end -- for\n  return string.lower(roman)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4ec9oa9t.lua:25:\
    \ expected: \"xix\"\nactual: \"mmmmmmmmmmmmmmmmmmm\"\nstack traceback:\n\t/tmp/tmp4ec9oa9t.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_numerals()\n  local roman_str = ''\n  for i = 1, number\
    \ do\n    local roman = roman[math.floor((number - i - 1) / roman.per_digit +\
    \ 1)]\n    roman_str = roman_str .. roman.roman\n  end\n  return roman_str:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_7av30l0.lua:9:\
    \ attempt to call a nil value (global 'roman_numerals')\nstack traceback:\n\t\
    /tmp/tmp_7av30l0.lua:9: in local 'candidate'\n\t/tmp/tmp_7av30l0.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {\n        100 = 'M',\n        900 = 'CM',\n        500 =\
    \ 'D',\n        400 = 'CD',\n        100 = 'C'\n    }\n    local roman\n    for\
    \ i = 1, 3 do\n        local next_roman = romans[math.floor((number - math.floor((number\
    \ / i) * i)) / i)]\n        if roman then\n            roman = roman .. next_roman\n\
    \        else\n            roman = next_roman\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpul_u3qy3.lua:10: '}' expected (to close '{' at line 9) near\
    \ '='\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {\n        'I',\n        'IV',\n        'V',\n        'IX',\n\
    \        'X',\n        'XL',\n        'L',\n        'XC',\n        'C',\n    \
    \    'CD',\n        'D',\n        'CM',\n        'M',\n        'MM'\n    }\n \
    \   local roman\n    local numeral\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpeamwh1lt.lua:47: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Sanity check: Assert that it's in range\n  assert(number >= 1 and number\
    \ <= 1000)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp5eail7y8.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   if number == nil then\n      return nil\n   end\n   if number > 1000 then\n\
    \      return nil\n   end\n   local romans = {}\n   romans[1] = \"I\"\n   romans[2]\
    \ = \"II\"\n   romans[4] = \"III\"\n   romans[5] = \"IV\"\n   romans[8] = \"V\"\
    \n   romans[10] = \"VI\"\n   romans[50] = \"LIX\"\n   romans[100] = \"C\"\n  \
    \ romans[500] = \"D\"\n   romans[1000] = \"M\"\n   romans[5000] = \"MIX\"\n  \
    \ romans[10000] = \"MMM\"\n   romans[100000] = \"MMMM\"\n   romans[1000000] =\
    \ \"MMMMM\"\n   romans[10000000] = \"MMMMMM\"\n   romans[100000000] = \"XXXX\"\
    \n   romans[1000000000] = \"XXXXXX\"\n   romans[10000000000] = \"XXXXXXXX\"\n\
    \   romans[100000000000] = \"XXXXXXXXXX\"\n   romans[1000000000000] = \"XXXXXXXXXXXX\"\
    \n   romans[10000000000000] = \"XXXXXXXXXXXXXX\"\n   romans[100000000000000] =\
    \ \"XXXXXXXXXXXXXXXX\"\n   romans[1000000000000000] = \"XXXXXXXXXXXXXXXXXX\"\n\
    \   romans[10000000000000000] = \"XXXXXXXXXXXXXXXXXXXX\"\n   romans[100000000000000000]\
    \ = \"XXXXXXXXXXXXXXXXXXXXXX\"\n   romans[1000000000000000000] = \"XXXXXXXXXXXXXXXXXXXXXXXX\"\
    \n   romans[10000000000000000000] = \"XXXXXXXXXXXXXXXXXXXXXXXXXX\"\n   romans[100000000000000000000]\
    \ = \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpeu1fd7dg.lua:64: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman = \"M\"\n\tlocal numeral = number\n\trepeat\n\t\tlocal next_numeral\
    \ = numeral\n\t\tnumeral = math.floor((numeral / 10) + 0.5)\n\t\troman = roman\
    \ .. roman[string.sub(roman, 1, #roman - 1)]\n\t\tif next_numeral <= 499 then\n\
    \t\t\troman = roman .. roman[string.sub(roman, #roman + 1)]\n\t\telse\n\t\t\t\
    roman = roman .. roman[string.sub(roman, 1, #roman - 1)]\n\t\tend\n\t\troman =\
    \ string.lower(roman)\n\tuntil number == next_numeral\n\treturn roman\nend\nreturn\
    \ int_to_mini_roman\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgbioicxh.lua:25: <eof> expected near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result\n  local result = \"\"\n  -- Iterate over numeral characters\n\
    \  for i, n in ipairs(string.gmatch(tostring(number), \"%d*([%d]+)\")) do\n  \
    \  -- If the current character is equal to the roman numeral character, append\
    \ it to the result\n    if n == tostring(number) then\n      result = result ..\
    \ n\n      -- Otherwise, if the next character is a \"x\", append it to the result\n\
    \    elseif n == \"x\" then\n      result = result .. n\n      -- Otherwise, replace\
    \ the current character with the current roman numeral character\n    else\n \
    \     result = result .. n\n    end\n  end\n  -- Return result in lowercase\n\
    \  return result:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\nattempt to\
    \ index a function value\nstack traceback:\n\nRan 1 tests in 0.000 seconds, 0\
    \ successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- We only consider the numbers that fit in a mini-roman (<= 1000)\n  if number\
    \ <= 1000 then\n    local roman_numbers = {}\n    roman_numbers[1000] = 'M'\n\
    \    roman_numbers[900] = 'CM'\n    roman_numbers[500] = 'D'\n    roman_numbers[400]\
    \ = 'CD'\n    roman_numbers[100] = 'C'\n    roman_numbers[90] = 'XC'\n    roman_numbers[50]\
    \ = 'L'\n    roman_numbers[40] = 'XL'\n    roman_numbers[10] = 'X'\n    roman_numbers[9]\
    \ = 'IX'\n    roman_numbers[5] = 'V'\n    roman_numbers[4] = 'IV'\n    roman_numbers[1]\
    \ = 'I'\n    for i = 1, number do\n      local roman_value = roman_numbers[i]\n\
    \      -- Check that the next value is higher than the last\n      if roman_numbers[i\
    \ - 1] ~= roman_value then\n        roman_numbers[i] = roman_value\n      end\n\
    \    end\n    local roman_number = ''\n    for _, value in ipairs(roman_numbers)\
    \ do\n      roman_number = roman_number .. value\n    end\n    return roman_number:lower()\n\
    \  else\n    return nil\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0jswlofg.lua:45:\
    \ expected: \"xix\"\nactual: \"i\"\nstack traceback:\n\t/tmp/tmp0jswlofg.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {'', 'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XC', 'XL',\
    \ 'X', 'XL', 'IX', 'V', 'IV', 'I'}\n    local num_roman = #roman_numerals\n  \
    \  local remainder = number % 100\n    local result = roman_numerals[number -\
    \ remainder]\n    if remainder >= 50 then\n        result = result .. roman_numerals[remainder\
    \ - 50]\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuo8oz5ae.lua:22:\
    \ expected: \"xix\"\nactual: nil\nstack traceback:\n\t/tmp/tmpuo8oz5ae.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number and number <= 1000, 'Invalid input')\n  -- Special cases\n  if\
    \ number == 0 then return '0'\n  if number == 1 then return 'i'\n  -- Normal cases\n\
    \  local roman = nil\n  local max_roman, i = math.log10(number) + 1, 1\n  while\
    \ i <= max_roman do\n    local digit = math.floor((number % 100) / 10)\n    local\
    \ next_digit = math.floor((number % 10) / 10)\n    if i == 1 then\n      if next_digit\
    \ == 0 then roman = 'i' else roman = 'i'..'x'..digit\n      end\n    else\n  \
    \    if next_digit == 0 then\n        roman = 'i'..'v'..digit\n      else\n  \
    \      roman = 'i'..'v'..digit..'x'..next_digit\n      end\n    end\n    number\
    \ = math.floor(number / 10)\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsvxxyf5t.lua:12: 'end' expected (to close 'if' at line 11)\
    \ near 'if'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number == 0 then\n    return '0'\n  end\n  local roman = {'M', 'CM', 'D',\
    \ 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}\n  local digits, remainder\
    \ = div(number, 10)\n  assert(remainder == 0, 'Integer division')\n  local roman_number\
    \ = ''\n  for i = 1, digits do\n    local remainder = number - digits*10 - i\n\
    \    roman_number = roman_number .. roman[remainder]\n  end\n  return string.lower(roman_number)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzvzlkyu7.lua:13:\
    \ attempt to call a nil value (global 'div')\nstack traceback:\n\t/tmp/tmpzvzlkyu7.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpzvzlkyu7.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 then\n    return '0'\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpagj96lf3.lua:32: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1, 'The given number must be greater or equal to 1.')\n  assert(number\
    \ <= 1000, 'The given number must be lesser than or equal to 1000.')\n  local\
    \ roman_table = {\n    [1000] = 'M',\n    [900] = 'CM',\n    [500] = 'D',\n  \
    \  [400] = 'CD',\n    [100] = 'C',\n    [90] = 'XC',\n    [50] = 'L',\n    [40]\
    \ = 'XL',\n    [10] = 'X',\n    [9] = 'IX',\n    [5] = 'V',\n    [4] = 'IV',\n\
    \    [10] = 'I',\n  }\n  local roman_ret = ''\n  for i, v in ipairs(roman_table)\
    \ do\n    local count = math.floor((number / v) + 0.5)\n    number = number %\
    \ v\n    if count == 1 then\n      roman_ret = roman_ret..v\n    else\n      roman_ret\
    \ = roman_ret..v..roman_table[i]..count\n    end\n  end\n  return string.lower(roman_ret)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7l19n7g3.lua:42:\
    \ expected: \"xix\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmp7l19n7g3.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 then\n    return nil\n  else\n    local romans = {\n      [1]\
    \ = \"I\", -- i\n      [2] = \"II\",\n      [3] = \"III\",\n      [4] = \"IV\"\
    ,\n      [5] = \"V\", -- v\n      [6] = \"VI\",\n      [7] = \"VII\",\n      [8]\
    \ = \"VIII\",\n      [9] = \"IX\", -- x\n      [10] = \"X\", -- l\n      [11]\
    \ = \"XI\",\n      [12] = \"XII\",\n      [13] = \"XIII\",\n      [14] = \"XIV\"\
    ,\n      [15] = \"XV\",\n      [16] = \"XVI\",\n      [17] = \"XVII\",\n     \
    \ [18] = \"XVIII\",\n      [19] = \"XIX\", -- lx\n      [20] = \"XX\", -- xl\n\
    \      [21] = \"XLI\",\n      [22] = \"XLII\",\n      [23] = \"XLIII\",\n    \
    \  [24] = \"XLIV\",\n      [25] = \"XLIVI\",\n      [26] = \"XLIVII\",\n     \
    \ [27] = \"XLIVIII\",\n      [28] = \"XLIIX\", -- lxl\n      [29] = \"XLIXX\"\
    , -- lxx\n      [30] = \"XLXX\", -- lxx\n      [31] = \"XLYX\", -- lyx\n     \
    \ [32] = \"XC\", -- c\n      [33] = \"XC\", -- cc\n      [34] = \"XC\", -- cd\n\
    \      [35] = \"XC\", -- d\n      [36] = \"XC\", -- dc\n      [37] = \"XC\", --\
    \ dcc\n      [38] = \"XC\", -- dccc\n      [39] = \"XC\", -- dcd\n      [40] =\
    \ \"XC\", -- dccd\n      [41] = \"XC\", -- ccc\n      [42] = \"XC\", -- cdd\n\
    \      [43] = \"XC\", -- cccd\n      [44] = \"XC\", -- ccd\n      [45] = \"XC\"\
    , -- dccc\n      [46] = \"XC\", -- dcccd\n      [47] = \"XC\", -- cccd\n     \
    \ [48] = \"XC\", -- cccde\n      [49] = \"XC\", -- cccd\n      [50] = \"XC\",\
    \ -- cde\n      [51] = \"XC\", -- cccde\n      [52] = \"XC\", -- cccdee\n    \
    \  [53] = \"XC\", -- cccd\n      [54] = \"XC\", -- cde\n      [55\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgll3h50e.lua:68: ']' expected near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = {'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I'}\n  local result\
    \ = ''\n  local i = number\n  local numeral = 1\n  while i ~= 0 do\n    i = math.floor(i/10)\n\
    \    roman[i] = roman[i] .. numeral\n    numeral = numeral + 1\n  end\n  i = 1\n\
    \  while i <= #roman do\n    i = i\n    roman[i] = roman[i] .. roman[i]\n  end\n\
    \  while i ~= 0 do\n    result = roman[i] .. result\n    i = i-1\n  end\n  return\
    \ result:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp77gx7oc9.lua:15:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmp77gx7oc9.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp77gx7oc9.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Handle cases where n is negative\n    if number < 0 then\n        error(\"\
    Cannot convert negative numbers to roman numerals.\")\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp0nfvxr1q.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {\n        ['M'] = 1000,\n        ['CM'] = 900,\n        ['D']\
    \ = 500,\n        ['CD'] = 400,\n        ['C'] = 100,\n        ['XC'] = 90,\n\
    \        ['L'] = 50,\n        ['XL'] = 40,\n        ['X'] = 10,\n        ['IX']\
    \ = 9,\n        ['V'] = 5,\n        ['IV'] = 4,\n        ['I'] = 3,\n    }\n \
    \   local roman_numeral = ''\n    local remainder = number\n    while remainder\
    \ ~= 0 do\n        local roman_numeral_part = romans[remainder % 100]\n      \
    \  roman_numeral = roman_numeral .. roman_numeral_part\n        remainder = remainder\
    \ - roman_numeral_part\n    end\n    return roman_numeral .. 'I'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0qa2md2g.lua:28:\
    \ attempt to concatenate a nil value (local 'roman_numeral_part')\nstack traceback:\n\
    \t/tmp/tmp0qa2md2g.lua:28: in local 'candidate'\n\t/tmp/tmp0qa2md2g.lua:37: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tnumber = number or 0\n\tlocal roman_num = ''\n\tlocal max_num = 5000\n\tfor\
    \ i = 1, max_num do\n\t\tlocal mult = math.floor(math.log(number / i) / math.log(max_num))\n\
    \t\tlocal remainder = number - i * mult\n\t\troman_num = roman_num .. roman_roman[mult\
    \ - 1]\n\t\tif remainder > 0 then\n\t\t\troman_num = roman_num .. roman_roman[remainder]\n\
    \t\tend\n\tend\n\treturn roman_num:lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprzu65588.lua:15:\
    \ attempt to index a nil value (global 'roman_roman')\nstack traceback:\n\t/tmp/tmprzu65588.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmprzu65588.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = roman_numerals.mini_roman[number]\n    if roman == nil then\n\
    \        error'Invalid input.'\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4e_d1obl.lua:9:\
    \ attempt to index a nil value (global 'roman_numerals')\nstack traceback:\n\t\
    /tmp/tmp4e_d1obl.lua:9: in local 'candidate'\n\t/tmp/tmp4e_d1obl.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = {\n        1000 = 'M',\n        900 = 'CM',\n        500 =\
    \ 'D',\n        400 = 'CD',\n        100 = 'C',\n        90 = 'XC',\n        50\
    \ = 'L',\n        40 = 'XL',\n        10 = 'X',\n        9 = 'IX',\n        5\
    \ = 'V',\n        4 = 'IV',\n        1 = 'I'\n    }\n    local roman_numbers =\
    \ { }\n    for i = 0, 1000 do\n        roman_numbers[#roman_numbers + 1] = roman[i]\n\
    \    end\n    local romans = { }\n    local lastroman\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4wqt726a.lua:10: '}' expected (to close '{' at line 9) near\
    \ '='\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = \"\"\n    local numeral = \"\"\n    if number < 1 then\n  \
    \      return \"?\"\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgbc6fbx2.lua:34: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = \"\"\n    local alphabet = \"IVXLCDM\"\n    while number >\
    \ 0 do\n        roman = roman .. alphabet[number % 10]\n        number = math.floor(number\
    \ / 10)\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0vqtfgv0.lua:12:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmp0vqtfgv0.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmp0vqtfgv0.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tassert(type(number) == \"number\")\n\tassert(number > 0 and number <= 1000)\n\
    \tlocal roman = \"\"\n\tlocal i = 2\n\twhile i < number do\n\t\troman = roman\
    \ .. string.char(\n\t\t\t((number - i) * 10) - i % 10 + 1,\n\t\t\t((number - i)\
    \ * 10) % 10 + 1,\n\t\t\ti\n\t\t)\n\t\ti = i + 1\n\tend\n\treturn roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpecaqie3b.lua:27:\
    \ expected: \n\"xix\"\nactual: \n\"\x01\x02\x01\x03\x01\x04\x01\x05}\x01\x06r\x01\
    \ag\x01\b\\\x01\t[\x01\nP\x01\vE\x01\f:\x01\r/\x01\x0E$\x01\x0F\x19\x01\x10\x0E\
    \x01\x11\x03\x01\x12\"\nstack traceback:\n\t/tmp/tmpecaqie3b.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_table = mini_roman_table\n    for i = 1, 100 do\n        if number\
    \ < i then\n            return roman_table[i]\n        end\n        number = number\
    \ - i\n        roman_table = roman_table[i]\n    end\nend\nmini_roman_table =\
    \ {\n    {\n        '',\n        'm',\n        'cm',\n        'd',\n        'cd',\n\
    \        'c',\n        'xc',\n        'lx',\n        'xl',\n        'x',\n   \
    \     'ix',\n        'v',\n        'iv',\n        'i'\n    },\n    {\n       \
    \ '',\n        'i',\n        'ii',\n        'iii',\n        'iv',\n        'v',\n\
    \        'vi',\n        'vii',\n        'viii',\n        'ix',\n        'x',\n\
    \        'xi',\n        'xii'\n    },\n    {\n        '',\n        'e',\n    \
    \    'ee',\n        'ei',\n        'e',\n        'ai',\n        'a'\n    },\n\
    \    {\n        '',\n        'a',\n        'aa',\n        'i',\n        'ii',\n\
    \        'iii',\n        'iv',\n        'v',\n        'vi',\n        'vii',\n\
    \        'viii',\n        'ix',\n        'x',\n        'xi',\n        'xii'\n\
    \    },\n    {\n        '',\n        'a',\n        'aa',\n        'i',\n     \
    \   'ii',\n        'iii',\n        'iv',\n        'v',\n        'vi',\n      \
    \  'vii',\n        'viii',\n        'ix',\n        'x',\n        'xi',\n     \
    \   'xii'\n    },\n    {\n        '',\n        'a',\n        'aa',\n        'i',\n\
    \        'ii',\n        'iii',\n        'iv',\n        'v',\n        'vi',\n \
    \       'vii',\n        'viii',\n        'ix',\n        'x',\n        'xi',\n\
    \        'xii'\n    },\n    {\n        '',\n        'a',\n        'aa',\n    \
    \    'i',\n        'ii',\n        'iii',\n        'iv',\n        'v',\n      \
    \  'vi',\n        'vii',\n        'viii',\n        'ix',\n        'x',\n     \
    \   'xi',\n        'xii'\n    },\n    {\n        '',\n        'a',\n        'aa',\n\
    \        'i',\n        'ii',\n        'iii',\n        'iv',\n        'v',\n  \
    \      'vi',\n        'vii',\n        'viii',\n        'ix',\n        'x',\n \
    \       'xi',\n        'xii'\n    },\n    {\n        '',\n        'a',\n\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfkt02o17.lua:150: '}' expected (to close '{' at line 144)\
    \ near 'function'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number > 0 and number <= 1000,\n         \"Invalid integer: \" .. tostring(number))\n\
    \  local roman = ''\n  local alphabet = 'mrvx'\n  local digits = ''\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6w2bxbqo.lua:34: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   number = tonumber(number)\n   if not number then\n      return nil\n   end\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpseovcpm1.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = \"\"\n    local roman_numeral = roman_numerals.roman_numerals[number]\n\
    \    if not roman_numeral then\n        error(\"Not a number\")\n    end\n   \
    \ local roman_numeral_len = #roman_numeral\n    for i = 1, roman_numeral_len do\n\
    \        roman = roman .. roman_numeral[i]\n    end\n    return roman:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpr2na9l6g.lua:10:\
    \ attempt to index a nil value (global 'roman_numerals')\nstack traceback:\n\t\
    /tmp/tmpr2na9l6g.lua:10: in local 'candidate'\n\t/tmp/tmpr2na9l6g.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 then\n    return 'x'\n  end\n  if number < 3 then\n    return\
    \ to_string(number)\n  end\n  local romans = {'', 'cm', 'd', 'x', 'l', 'v', 'h'};\n\
    \  local roman_numerals = \n    { '', 'c', 'm', 'd', 'x', 'l', 'c', 'x', 'v',\
    \ 'x' };\n  local roman_numeral_counts = {0, 0, 1, 2, 2, 2, 2, 2, 3, 3, 3};\n\
    \  local result = '';\n  local roman_number = math.floor(number/1000);\n  for\
    \ i = 1, 9 do\n    if roman_number < roman_numeral_counts[i] then\n      result\
    \ = result .. romans[i];\n      roman_number = roman_numerals[i]\n    end\n  end\n\
    \  local remainder = number % 1000;\n  result = result .. roman_numerals[roman_number]\
    \ .. \n    int_to_mini_roman(remainder)\n  return result;\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6ud71922.lua:22:\
    \ attempt to compare string with number\nstack traceback:\n\t/tmp/tmp6ud71922.lua:22:\
    \ in local 'candidate'\n\t/tmp/tmp6ud71922.lua:36: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  return assert(assert(string.gsub(number:gsub('%', function(x)\n    return x:lower()\
    \ ~= x ? '%' : '%' .. math.floor(x:roman()*100)\n  end)..., '%0', ''), \".\",\
    \ \"\"), \"xix\") or assert(assert(string.gsub(number:gsub('%', function(x)\n\
    \    return x:lower() ~= x ? '%' : '%' .. math.floor(x:roman()*10)\n  end)...,\
    \ '%0', ''), \".\", \"\"), \"clii\") or assert(assert(string.gsub(number:gsub('%',\
    \ function(x)\n    return x:lower() ~= x ? '%' : '%' .. math.floor(x:roman()*1)\n\
    \  end)..., '%0', ''), \".\", \"\"), \"cdxxvi\")\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp5nba9vtl.lua:10: 'end' expected (to close 'function' at line\
    \ 9) near '?'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = table.replicate('I', number + 2)\n  roman[number] = 'I'\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmph7vrydwx.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- See http://www.unicode.org/charts/PDF/U03200.pdf for an explanation of\
    \ how the Roman numerals work\n    if number <= 0 then return nil end\n    local\
    \ roman = nil\n    local i = 2\n    while i <= math.floor(math.log(number) / math.log(10000))\
    \ do\n        local t = math.pow(10000, i - 1) * number\n        if roman==nil\
    \ then\n            roman = roman_number(t)\n        else\n            roman =\
    \ roman .. roman_number(t)\n        end\n        i = i + 1\n    end\n    return\
    \ string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpopu10tb7.lua:22:\
    \ bad argument #1 to 'lower' (string expected, got nil)\nstack traceback:\n\t\
    /tmp/tmpopu10tb7.lua:22: in local 'candidate'\n\t/tmp/tmpopu10tb7.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- The longest Roman numeral is ten characters in length.\n\tlocal roman_two\
    \ = {\n\t\t[1] = 'i',\n\t\t[2] = 'ii',\n\t\t[3] = 'iii',\n\t\t[4] = 'iv',\n\t\t\
    [5] = 'v',\n\t\t[6] = 'vi',\n\t\t[7] = 'vii',\n\t\t[8] = 'viii',\n\t\t[9] = 'ix',\n\
    \t\t[10] = 'x'\n\t}\n\tlocal roman_two_capitalized = {\n\t\t[1] = 'I',\n\t\t[2]\
    \ = 'II',\n\t\t[3] = 'III',\n\t\t[4] = 'IV',\n\t\t[5] = 'V',\n\t\t[6] = 'VI',\n\
    \t\t[7] = 'VII',\n\t\t[8] = 'VIII',\n\t\t[9] = 'IX',\n\t\t[10] = 'X'\n\t}\n\t\
    local roman_ten = {\n\t\t[1] = 'i',\n\t\t[2] = 'ii',\n\t\t[3] = 'iii',\n\t\t[4]\
    \ = 'iv',\n\t\t[5] = 'v',\n\t\t[6] = 'vi',\n\t\t[7] = 'vii',\n\t\t[8] = 'viii',\n\
    \t\t[9] = 'ix',\n\t\t[10] = 'x',\n\t\t[11] = 'xx',\n\t\t[12] = 'xxx',\n\t\t[13]\
    \ = 'xxxi',\n\t\t[14] = 'xxxii',\n\t\t[15] = 'xxxiii',\n\t\t[16] = 'xxxiv',\n\t\
    \t[17] = 'xxxv',\n\t\t[18] = 'xxxvi',\n\t\t[19] = 'xxxvii',\n\t\t[20] = 'xxxviii',\n\
    \t\t[21] = 'xxxix',\n\t\t[22] = 'xxxi',\n\t\t[23] = 'xxxii',\n\t\t[24] = 'xxxiii',\n\
    \t\t[25] = 'xxxiiii',\n\t\t[26] = 'xxxiiiiv',\n\t\t[27] = 'xxxiiiv',\n\t\t[28]\
    \ = 'xxxiv',\n\t\t[29] = 'xxxv',\n\t\t[30] = 'xxxvi',\n\t\t[31] = 'xxxvii',\n\t\
    \t[32] = 'xxxviii',\n\t\t[33] = 'xxxix',\n\t\t[34] = 'xxxi',\n\t\t[35] = 'xxxii',\n\
    \t\t[36] = 'xxxiii',\n\t\t[37] = 'xxxiiii',\n\t\t[38] = 'xxxiiiiv',\n\t\t[39]\
    \ = 'xxxiiiv',\n\t\t[40] = 'xxxiv',\n\t\t[41] = 'xxxv',\n\t\t[42] = 'xxxvi',\n\
    \t\t[43] = 'xxxvii',\n\t\t[44] = 'xxxviii',\n\t\t\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8ijzpzjq.lua:82: '}' expected (to close '{' at line 34) near\
    \ 'function'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 then return nil end\n  local roman = romans[number]\n  if roman\
    \ ~= nil then\n    return roman\n  end\n  local decimal = math.floor(math.log(number,\
    \ 1000) / math.log(10)) + 1\n  if decimal > 3 then\n    error(\"Invalid input:\
    \ number too large\")\n  end\n  local roman_string = \"M\"\n  for i = 0, decimal\
    \ - 1 do\n    roman_string = roman_string .. romans[number % 1000]\n    number\
    \ = number / 1000\n  end\n  return roman_string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpsjw1wexe.lua:10:\
    \ attempt to index a nil value (global 'romans')\nstack traceback:\n\t/tmp/tmpsjw1wexe.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpsjw1wexe.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1, 'int_to_mini_roman called without a positive number')\n\
    \  assert(number <= 1000, 'int_to_mini_roman called with a number greater than\
    \ 999')\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp5xsx_6l8.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 then\n    return '0'\n  end\n  local roman = string.rep('x',\
    \ number)\n  return string.gsub(roman, '.', '\xB7')\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjmj81kif.lua:19:\
    \ expected: \"xix\"\nactual: \"\xB7\xB7\xB7\xB7\xB7\xB7\xB7\xB7\xB7\xB7\xB7\xB7\
    \xB7\xB7\xB7\xB7\xB7\xB7\xB7\"\nstack traceback:\n\t/tmp/tmpjmj81kif.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {\n        [1] = 'i',\n        [4] = 'i',\n        [9] = 'ii',\n\
    \        [14] = 'ii',\n        [19] = 'iii',\n        [28] = 'iii',\n        [38]\
    \ = 'iii',\n        [47] = 'iv',\n        [58] = 'v',\n        [68] = 'v',\n \
    \       [78] = 'vi',\n        [88] = 'vi',\n        [98] = 'vii',\n        [107]\
    \ = 'vii',\n        [109] = 'viii',\n        [119] = 'ix',\n        [128] = 'xxx',\n\
    \    }\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpj5bybzcp.lua:48: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   if number <= 1000 then\n      return (math.floor((number / 100) + 1) * 'M'\n\
    \             + math.floor(number / 10)  * 'CM'\n             + math.floor(number\
    \ % 10)  * 'D'\n             + math.floor(number % 100) * 'CD')\n   else\n   \
    \   return (math.floor((number / 100) + 1) * 'M'\n             + math.floor(number\
    \ / 10)  * 'C'\n             + math.floor(number % 10)  * 'D'\n             +\
    \ math.floor(number % 100) * 'C')\n   end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph7jrjqp8.lua:10:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmph7jrjqp8.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmph7jrjqp8.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  while number > 0 do\n    local remainder, digit = math.modf(number\
    \ % 10)\n    roman =\n      (digit > 0 and 'i'..digit) or 'i'..(10*remainder)\n\
    \    number = math.floor(number / 10)\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_xjsrdd4.lua:22:\
    \ expected: \"xix\"\nactual: \"i10\"\nstack traceback:\n\t/tmp/tmp_xjsrdd4.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number == 0 then\n    return ''\n  else\n    if number % 1000 <= 50 then\n\
    \      return (number % 1000):reverse():reverse() + int_to_mini_roman((number\
    \ % 1000)):reverse()\n    else\n      local roman = (number % 1000):reverse()\
    \ + int_to_mini_roman((number % 1000):reverse())\n      local first_hundred =\
    \ roman:sub(1, 1):reverse()\n      local hundred = roman:sub(2)\n      return\
    \ (first_hundred:reverse() + hundred:reverse()):reverse()\n    end\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpi8ptg21j.lua:13:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpi8ptg21j.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpi8ptg21j.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number <= 0 then\n        error(\"the argument must be a positive integer\"\
    )\n    end\n    if number == 0 then\n        return \"\"\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6zu6tjsh.lua:35: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   if number == 0 then\n      return \"0\"\n   end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_xnvvlrw.lua:32: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   assert(number >= 1 and number <= 1000)\n   local roman = ''\n   local i\n\
    \   if number == 0 then\n      return '0'\n   end\n   for i = 2, number do\n \
    \     roman = roman .. 'i'\n   end\n   if number < 10 then\n      roman = roman\
    \ .. 'x'\n      return roman\n   end\n   local half = number / 10\n   for i =\
    \ 1, half do\n      roman = roman .. 'l'\n   end\n   if half < 10 then\n     \
    \ roman = roman .. 'c'\n      return roman\n   end\n   for i = 1, number - half\
    \ do\n      roman = roman .. 'd'\n   end\n   if number > 10 then\n      roman\
    \ = roman .. 'x'\n      return roman\n   end\n   half = number % 10\n   for i\
    \ = 1, half do\n      roman = roman .. 'c'\n   end\n   if half < 10 then\n   \
    \   roman = roman .. 'm'\n      return roman\n   end\n   for i = 1, number - half\
    \ do\n      roman = roman .. 'i'\n   end\n   return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpttatf3i_.lua:54:\
    \ expected: \"xix\"\nactual: \"iiiiiiiiiiiiiiiiiilc\"\nstack traceback:\n\t/tmp/tmpttatf3i_.lua:54:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 or number >= 1000 then\n    return nil\n  else\n\
    \    -- Determine number of digits\n    local digits = math.floor(math.log(number)\
    \ / math.log(1000))\n    -- Convert number to string\n    local roman = tonumber(string.format('%g',\
    \ number))\n    -- Determine what the last digit should be\n    local last_digit\
    \ = math.floor(digits)\n    -- Convert number to string\n    local mini = tonumber(string.format('%g',\
    \ number))\n    -- Add 'i' to the beginning of the roman string if needed\n  \
    \  if roman ~= '0' and roman ~= '1' then\n      mini = 'i' .. mini\n    end\n\
    \    -- Add 'm' to the beginning of the mini string if needed\n    if mini ~=\
    \ '0' and mini ~= '1' then\n      roman = 'm' .. roman\n    end\n    -- Determine\
    \ what the last digit should be\n    local new_last_digit = math.floor(digits)\n\
    \    -- If new last digit is greater than current last digit, add a 'x'\n    --\
    \ to the beginning of the roman string\n    if new_last_digit > last_digit then\n\
    \      roman = 'x' .. roman\n    end\n    -- If the roman number had more than\
    \ two digits, add a 'c' to the beginning\n    -- of the roman string\n    if digits\
    \ > 2 then\n      roman = 'c' .. roman\n    end\n    -- Return the result as a\
    \ string\n    return mini .. roman\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe0cxbhcx.lua:49:\
    \ expected: \"xix\"\nactual: \"i19m19\"\nstack traceback:\n\t/tmp/tmpe0cxbhcx.lua:49:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \t-- Note: we do NOT return string in case number is too large, it's OK\n\t--\
    \ because we get only one char per number, and we don't have 'x' char in string.\n\
    \t-- TODO: if number > 1000, we should return 'xxx' instead of 'xix', for example\n\
    \t-- >>> int_to_mini_roman(1452) -- clii\n\t-- >>> int_to_mini_roman(1342) --\
    \ cldxvi\n\t-- >>> int_to_mini_roman(1232) -- cxxxvi\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp74xewh8e.lua:35: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1eec5n71.lua:30: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Special case: zero\n  if number <= 0 then\n    return \"0\"\n  end\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp06zteegk.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 then return nil end\n  local roman = { ['I'] = 1, 'V': 5, 'X':\
    \ 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 }\n  local roman_numeral = ''\n \
    \ for i = 1, number do\n    roman_numeral = roman_numeral .. roman[tonumber(math.floor(i\
    \ / 5)) * 5 + i % 5]\n  end\n  return roman_numeral:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpqi3y71g9.lua:10: '}' expected near ':'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number)\n  assert(number <= 1000)\n  local roman = ''\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpq6lg6jl5.lua:32: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman_nums = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"\
    XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" }\n\tlocal roman_nums_lower = { \"M\"\
    , \"c\", \"d\", \"c\", \"x\", \"l\", \"xl\", \"x\", \"i\", \"v\", \"i\", \"I\"\
    \ }\n\tlocal roman_nums_2 = { \"M\", \"D\", \"C\", \"L\", \"XL\", \"X\", \"V\"\
    , \"I\" }\n\tlocal roman_nums_3 = { \"D\", \"C\", \"L\", \"XL\", \"X\", \"V\"\
    , \"I\" }\n\tlocal roman_nums_4 = { \"L\", \"XL\", \"X\", \"V\", \"I\" }\n\tlocal\
    \ roman_nums_5 = { \"X\", \"V\", \"I\" }\n\tlocal roman_nums_6 = { \"V\", \"I\"\
    \ }\n\tlocal roman_nums_7 = { \"V\" }\n\tlocal roman_nums_8 = { \"I\" }\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdcwz1xk9.lua:38: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result to empty\n  local result = \"\"\n  -- Iterate through\
    \ all decimal digits from right to left\n  for i = #number, 2, -1 do\n    -- Get\
    \ the remainder modulo 100\n    local remainder = math.fmod(number, 100)\n   \
    \ -- If the remainder is zero or greater, append an 'i'\n    -- If not, append\
    \ a capital letter corresponding to the digit\n    if remainder >= 10 then\n \
    \     result = result .. \"i\"\n    else\n      result = result .. string.sub(string.char(string.byte(\"\
    a\"):sub(1, i + 1), remainder))\n    end\n    -- Divide the number by 100\n  \
    \  number = math.fdiv(number, 100)\n  end\n  -- Return the result as a lowercase\
    \ string\n  return result:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpkph319nm.lua:12:\
    \ attempt to get length of a number value (local 'number')\nstack traceback:\n\
    \t/tmp/tmpkph319nm.lua:12: in local 'candidate'\n\t/tmp/tmpkph319nm.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base cases\n  if number == 0 then\n    return ''\n  end\n  if number ==\
    \ 1 then\n    return 'I'\n  end\n  if number % 100 == 0 then\n    return 'M'\n\
    \  end\n  if number % 100 == 0 then\n    return 'D'\n  end\n  if number % 10 ==\
    \ 0 then\n    return 'C'\n  end\n  -- Remember each of the three rules\n  local\
    \ roman_numeral = nil\n  local numeral_places = nil\n  -- Find the most significant\
    \ digit first\n  local most_significant_digit = number % 10\n  -- Remove that\
    \ digit\n  number = number / 10\n  -- Now work through the numbers\n  while number\
    \ > 0 do\n    numeral_places = math.modf(number)\n    roman_numeral = ''\n   \
    \ -- Add the tens\n    if numeral_places[1] == 0 then\n      if numeral_places[2]\
    \ == 1 then\n        roman_numeral = roman_numeral .. 'I'\n      else\n      \
    \  roman_numeral = roman_numeral .. 'X'\n      end\n    else\n      roman_numeral\
    \ = roman_numeral .. 'L'\n    end\n    -- Add the hundreds\n    if numeral_places[2]\
    \ == 0 then\n      roman_numeral = roman_numeral .. 'C'\n    else\n      roman_numeral\
    \ = roman_numeral .. 'D'\n    end\n    -- Add the rest\n    roman_numeral = roman_numeral\
    \ .. 'M'\n    -- Add the most significant digit\n    if most_significant_digit\
    \ < 4 then\n      roman_numeral = roman_numeral .. math.abs(most_significant_digit)\n\
    \    end\n    -- Next iteration\n    number = number / 10\n  end\n  return roman_numeral\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpvpjf2ib6.lua:37:\
    \ attempt to index a number value (local 'numeral_places')\nstack traceback:\n\
    \t/tmp/tmpvpjf2ib6.lua:37: in local 'candidate'\n\t/tmp/tmpvpjf2ib6.lua:67: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1)\n  assert(number <= 1000)\n  local roman = ''\n  local\
    \ i = 1\n  while i <= math.floor(math.log(number,2)) do\n    local mult = math.pow(1000,i)\n\
    \    local dec = math.floor(number/mult)\n    number = number - dec*mult\n   \
    \ roman =  roman..string.rep('',math.floor(math.log(i+2,10)))..string.rep('i',dec)\
    \ -- Flip upside-down\n    i = i + 1\n  end\n  return string.lower(roman)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb4__tzyj.lua:26:\
    \ expected: \"xix\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpb4__tzyj.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = 'MCMLXVII'\n  local result = ''\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpuk91y9da.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman_number = 0\n\t-- Base case\n\tif number <= 0 then\n\t\treturn \"\
    0\"\n\tend\n\t-- Handle negative numbers\n\tif number < 0 then\n\t\tnumber = -number\n\
    \t\troman_number = int_to_mini_roman(number)\n\tend\n\t-- Handle special cases\n\
    \tif number <= 4000 then\n\t\treturn 'x'..number\n\telseif number <= 7999 then\n\
    \t\treturn 'c'..number\n\telseif number <= 19000 then\n\t\treturn 'd'..((number-2000)\
    \ % 100)..'i'\n\telseif number <= 29999 then\n\t\treturn 'm'..((number-22001)\
    \ / 100)..'n'\n\telseif number <= 39999 then\n\t\treturn 'l'..((number-22098)\
    \ / 10)..'c'\n\telseif number <= 49999 then\n\t\treturn 'xl'..((number-22008)\
    \ / 10..'l'..((number-22099) / 100))\n\telseif number <= 59999 then\n\t\treturn\
    \ 'xc'..((number-22012) / 100)..'m'..((number-22099) / 100)\n\telseif number <=\
    \ 69999 then\n\t\treturn 'xd'..((number-22098) / 10..'l'..((number-22099) / 100))\n\
    \telseif number <= 79999 then\n\t\treturn 'xl'..((number-22098) / 10..'l'..((number-22099)\
    \ / 100))\n\telseif number <= 99999 then\n\t\treturn 'xc'..((number-22012) / 100)..'m'..((number-22099)\
    \ / 100)\n\telseif number <= 99999999 then\n\t\treturn 'xd'..((number-22098) /\
    \ 10..'l'..((number-22099) / 100))\n\telseif number <= 999999999 then\n\t\treturn\
    \ 'xc'..((number-22012) / 100)..'m'..((number-22099) / 100)\n\telseif number <=\
    \ 1000000000 then\n\t\treturn 'xd'..((number-22098) / 10..'l'..((number-22099)\
    \ / 100))\n\telse\n\t\t-- Handle rounding errors\n\t\tif number % 1000000000 >\
    \ 0 then\n\t\t\t-- Round up\n\t\t\troman_number = roman_number .. 'm'\n\t\t\t\
    if number % 1000000 > 0 then\n\t\t\t\troman_number = roman_number .. 'l'\n\t\t\
    \t\tif number % 100000 > 0 then\n\t\t\t\t\troman_number = roman_number .. 'x'\n\
    \t\t\t\t\tif \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpn831ffi1.lua:31: malformed number near '10..'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number < 1 then return nil end\n    local romans = {\n        thousand\
    \  = \"M\",\n        million   = \"MM\",\n        billion   = \"M\",\n       \
    \ trillion  = \"MMM\",\n        quadrillion = \"MMMM\",\n        gigillion  =\
    \ \"MMMMM\",\n        septillion = \"MMMMMM\",\n        octillion  = \"MMMMMMM\"\
    ,\n        ninety    = \"MMMMMMMM\"\n    }\n    local roman = romans[math.floor(number\
    \ / 1000)]\n    local n = number % 1000\n    if n > 0 then\n        roman = roman\
    \ .. int_to_mini_roman(n)\n    end\n    return roman:lower() .. romans[math.floor(n\
    \ / 100)]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpes_1c2jk.lua:21:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmpes_1c2jk.lua:21: in upvalue 'int_to_mini_roman'\n\
    \t/tmp/tmpes_1c2jk.lua:24: in upvalue 'int_to_mini_roman'\n\t/tmp/tmpes_1c2jk.lua:24:\
    \ in upvalue 'int_to_mini_roman'\n\t/tmp/tmpes_1c2jk.lua:24: in upvalue 'int_to_mini_roman'\n\
    \t/tmp/tmpes_1c2jk.lua:24: in upvalue 'int_to_mini_roman'\n\t/tmp/tmpes_1c2jk.lua:24:\
    \ in upvalue 'int_to_mini_roman'\n\t/tmp/tmpes_1c2jk.lua:24: in upvalue 'int_to_mini_roman'\n\
    \t/tmp/tmpes_1c2jk.lua:24: in upvalue 'int_to_mini_roman'\n\t/tmp/tmpes_1c2jk.lua:24:\
    \ in upvalue 'int_to_mini_roman'\n\t...\n\t/tmp/tmpes_1c2jk.lua:24: in local 'candidate'\n\
    \t/tmp/tmpes_1c2jk.lua:32: in function 'test_humaneval'\n\nRan 1 tests in 0.300\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpojwvgs2f.lua:32: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize output string\n  local result = \"\"\n  -- Convert integer into\
    \ a string\n  local number_str = number:tostring()\n  -- Loop through each character\
    \ in the string\n  for i = 1, #number_str do\n    -- If the character is greater\
    \ than '9', subtract '9' from the number\n    -- Otherwise, subtract '0'\n   \
    \ local current_digit = tonumber(number_str:sub(i, i))\n    if current_digit >\
    \ 9 then\n      -- We need to subtract '9'\n      local current_digit - 9\n  \
    \  else\n      -- We need to subtract '0'\n      local current_digit - 0\n   \
    \ end\n    -- Append the resulting digit to the output string\n    result = result\
    \ .. string.sub(\"0123\", current_digit)\n  end\n  return result:lower()\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp78p9x5ss.lua:20: unexpected symbol near '-'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- https://fr.wikipedia.org/wiki/Rom%C3%A9e\n  local roman_numerals = {\n \
    \   'I',\n    'II',\n    'III',\n    'IV',\n    'V',\n    'VI',\n    'VII',\n\
    \    'VIII',\n    'IX',\n    'X',\n    'XI',\n    'XII',\n    'XIII',\n    'XIV',\n\
    \    'XV',\n    'XVI',\n    'XVII',\n    'XVIII',\n    'XIX',\n  }\n  local result\
    \ = ''\n  local base\n  for base = 1, 100 do\n    local num = math.floor(number\
    \ / base)\n    if num == 0 then\n      break\n    end\n    local digit = roman_numerals[num\
    \ - 1]\n    if result == '' then\n      result = digit\n    else\n      result\
    \ = result .. roman_numerals[num] .. digit\n    end\n  end\n  assert(#result <\
    \ 50, 'Error while computing mini-roman')\n  return result:lower()\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqya815fc.lua:42:\
    \ attempt to concatenate a nil value (local 'digit')\nstack traceback:\n\t/tmp/tmpqya815fc.lua:42:\
    \ in local 'candidate'\n\t/tmp/tmpqya815fc.lua:52: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(1 <= number and number <= 1000, 'Input must be between 1 and 1000')\n\
    \  local roman = roman_numeral()\n  for i = 1, number do\n    local char = roman:next()\n\
    \    roman:insert(char)\n  end\n  roman:insert('d')\n  roman:insert('c')\n  return\
    \ roman:join()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1s2oguh3.lua:10:\
    \ attempt to call a nil value (global 'roman_numeral')\nstack traceback:\n\t/tmp/tmp1s2oguh3.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmp1s2oguh3.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Find out how many digits in the number\n  local num_digits = math.floor(math.log(number)/math.log(1000))\n\
    \  -- Return the corresponding roman numeral\n  return 'M'..number/1000..'D'..(number-1000*math.pow(1000,num_digits))..'C'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpajw2ns0q.lua:12: malformed number near '1000..'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Convert integer into Roman numeral of minimum length.\n  -- Input: number\
    \ -- positive integer between 1 and 1000.\n  -- Output: roman numeral string\n\
    \  -- Explanation: Roman numeral is used in numeral systems such as Japanese,\n\
    \  -- where numerals are represented using numeral symbols with different numbers\n\
    \  -- than the actual numerals. Roman numerals have no limits on the number\n\
    \  -- of symbols, and are usually written in lowercase.\n  -- See https://en.wikipedia.org/wiki/Roman_numerals\
    \ for details.\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1ozr34qf.lua:37: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- We make a copy, so we can reuse it.\n    local roman = string.gsub(number,\
    \ '([%d]+)', '%-1$2')\n    local roman = string.gsub(roman, '(%[-+])%[-+]', '%%%%')\n\
    \    local roman = string.gsub(roman, '(%[d-z])', '%d')\n    local roman = string.gsub(roman,\
    \ '(%[di])', '%1%2')\n    local roman = string.gsub(roman, '(%[-i])%[-i]', '%%%')\n\
    \    roman = string.gsub(roman, '(%[di-z])', '%d')\n    roman = string.gsub(roman,\
    \ '(%[ddz])', '%1%2')\n    roman = string.gsub(roman, '(%[-di])', '%1%2')\n  \
    \  roman = string.gsub(roman, '(%[-dd])', '%1%2')\n    roman = string.gsub(roman,\
    \ '(%[-zi])', '%1%2')\n    roman = string.gsub(roman, '(%[di-])', '%1%2')\n  \
    \  roman = string.gsub(roman, '(%[di-])', '%%%1')\n    roman = string.gsub(roman,\
    \ '(%[dd-])', '%1%2')\n    roman = string.gsub(roman, '(%[-di-])', '%1%2')\n \
    \   roman = string.gsub(roman, '(%[-di-])', '%%%1%2')\n    roman = string.gsub(roman,\
    \ '(%[-dd-])', '%1%2')\n    roman = string.gsub(roman, '(%[z])', '%%%1')\n   \
    \ roman = string.gsub(roman, '(%[-z])', '%1%%')\n    roman = string.gsub(roman,\
    \ '(%[-i%])', '%1%%%')\n    roman = string.gsub(roman, '(%[di%])', '%1%2%%')\n\
    \    roman = string.gsub(roman, '(%[-di%])', '%1%2%%')\n    roman = string.gsub(roman,\
    \ '(%[dd%])', '%1%2%%')\n    roman = string.gsub(roman, '(%[-di%])', '%1%2%%')\n\
    \    roman = string.gsub(roman, '(\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_mcultpr.lua:33: unfinished string near ''('\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1)\n  assert(number <= 1000)\n  local roman = {'','','i','ii','iii','iv','v','vi','vii','viii'}\n\
    \  local nums = string.rep(\"9\", number)\n  return roman[(math.floor(number /\
    \ 10)) + 1]..nums\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpklhcs3_0.lua:19:\
    \ expected: \"xix\"\nactual: \"9999999999999999999\"\nstack traceback:\n\t/tmp/tmpklhcs3_0.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local num_str = string.format(\"%u\", number)\n    local roman = string.char()\n\
    \    for i=1, 4 do\n        roman = roman .. string.sub(num_str, i - 1, 1)\n \
    \   end\n    return string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo8b9j0uj.lua:20:\
    \ expected: \"xix\"\nactual: \"11\"\nstack traceback:\n\t/tmp/tmpo8b9j0uj.lua:20:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number == 0 then\n    return ''\n  end\n  local romans = {\n    '',\n  \
    \  'M',\n    'CM',\n    'D',\n    'CD',\n    'C'\n  }\n  local roman = romans[number%100]\n\
    \  number = number/100\n  local hundreds = {\n    '',\n    'C',\n    'XC',\n \
    \   'L',\n    'XL',\n    'X'\n  }\n  local hundred = hundreds[number%10]\n  number\
    \ = number/10\n  local tens = {\n    '',\n    'X',\n    'XX',\n    'L',\n    'XL',\n\
    \    'XC',\n    'XLC'\n  }\n  local ten = tens[number%10]\n  number = number/10\n\
    \  local ones = {\n    '',\n    'I',\n    'II',\n    'III',\n    'IV'\n  }\n \
    \ local one = ones[number%10]\n  return one..roman..hundred..ten\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgis8t90v.lua:51:\
    \ attempt to concatenate a nil value (local 'hundred')\nstack traceback:\n\t/tmp/tmpgis8t90v.lua:51:\
    \ in local 'candidate'\n\t/tmp/tmpgis8t90v.lua:57: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.char(\n    number / 1000, 'x',\n    number % 1000, 'c',\n\
    \    number % 1000, 'l',\n    number % 1000, 'x'\n  )\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpld1bceow.lua:35: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\n  local numeral = string.gsub(number:rep(4), '([a-z]+)',\
    \ function(digit)\n    roman = roman or digit\n    return tonumber(roman)\n  end)\n\
    \  return string.lower(numeral)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdd6fkz3t.lua:10:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmpdd6fkz3t.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpdd6fkz3t.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, \"The given integer must be between\
    \ 1 and 1000\")\n  local roman\n  local roman_values = {'M', 'CM', 'D', 'CD',\
    \ 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}\n  for i, value in ipairs(roman_values)\
    \ do\n    if number >= value and number < value + 10 then\n      roman = roman\
    \ .. value\n    end\n  end\n  return lower(roman)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpg4m4glgb.lua:13:\
    \ attempt to compare string with number\nstack traceback:\n\t/tmp/tmpg4m4glgb.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpg4m4glgb.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Convert to roman numerals\n    local roman_numerals =\n        { 'I',\
    \ 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII',\
    \ 'XIV',\n          'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'X', 'XI', 'XII',\
    \ 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII',\n          'XIX', 'XXX' };\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1lx3y727.lua:34: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- We first check if we cannot generate an exact answer\n  if number <= 0 or\
    \ number > 999 then\n    error('Given integer must be between 0 and 999')\n  end\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpv3z9nz1b.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {'I', 'II', 'III', 'IV', 'V', 'VI'}\n  local roman_numerals_lower\
    \ = roman_numerals:map(function(roman_numeral)\n    return string.lower(roman_numeral)\n\
    \  end)\n  local roman_numerals_upper = roman_numerals:map(function(roman_numeral)\n\
    \    return roman_numeral:sub(1,1) .. roman_numeral:sub(2)\n  end)\n  local roman_numerals_numeral\
    \ = roman_numerals:map(function(roman_numeral)\n    return roman_numeral:sub(1,1)\
    \ .. roman_numeral:sub(2)\n  end)\n  local roman_numerals_numeral_with_suffix\
    \ = roman_numerals:map(function(roman_numeral)\n    return roman_numeral:sub(1,2)\
    \ .. roman_numeral:sub(3)\n  end)\n  local roman_numeral_suffixes = {'i', 'ii',\
    \ 'iii', 'iv', 'v', 'v'}\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpqxhqkysa.lua:43: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 then\n    error('Argument must be a positive number')\n  end\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmprtw0nsqb.lua:32: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(1 <= number and number <= 1000)\n  local roman = nil\n  local i = 1\
    \ -- i goes from 1 to 3\n  -- Calculate Roman numerals of number\n  repeat\n \
    \   local numeral = i .. roman_numeral(number, i)\n    if roman==nil then\n  \
    \    roman = numeral\n    else\n      roman = roman .. roman_numeral(number, i)\n\
    \    end\n    i = i + 1\n  until i>=3 -- and i is greater than 3\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprfp_fivx.lua:14:\
    \ attempt to call a nil value (global 'roman_numeral')\nstack traceback:\n\t/tmp/tmprfp_fivx.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmprfp_fivx.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Return early if number isn't in range.\n  if number < 1 or number > 1000\
    \ then\n    return \"?\"\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpqdvpdnvi.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Romans start at 1000\n  local roman_numerals = {}\n  local roman_numeral\
    \ = 0\n  -- Starting with 1000 and ending at 1000000, there are 900 possible roman\
    \ numerals\n  -- that we can create.\n  -- For each possible number, find out\
    \ how many possible romans it will create and store\n  -- it in a table.\n  for\
    \ i = 1000, 1000 + (1000 * (1000 - 1)) / 1000, 1000 do\n    local roman_number\
    \ = math.floor((number - i) / 100) + 1\n    roman_numerals[roman_number] = roman_numerals[roman_number]\
    \ or {}\n    roman_numerals[roman_number][i - 1000] = 1\n  end\n  -- Now we know\
    \ the possible roman numerals, we can just look through them, and find\n  -- out\
    \ how many of each there are.\n  local roman_numeral_counts = {}\n  local roman_numeral_count\
    \ = 1\n  for i = 1, 1000 do\n    roman_numeral_counts[i] = roman_numeral_counts[i]\
    \ + 1\n  end\n  -- Go through each possible number, and find the lowest roman_numeral\
    \ that can create\n  -- it.\n  for i = 1, 1000 do\n    local roman_numeral_count\
    \ = roman_numeral_counts[i]\n    if roman_numeral_count > roman_numeral_counts[roman_numeral]\
    \ then\n      roman_numeral = i\n      roman_numeral_count = roman_numeral_counts[i]\n\
    \    end\n  end\n  -- Romans don't like being too long, so we clip it if it's\
    \ too long\n  roman_numeral = roman_numeral .. 'i'\n  -- And finally we return\
    \ the roman numeral\n  return roman_numerals\n  -- Return the number\n  -- return\
    \ 'aero'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpt7vj151u.lua:26:\
    \ attempt to perform arithmetic on a nil value (field '?')\nstack traceback:\n\
    \t/tmp/tmpt7vj151u.lua:26: in local 'candidate'\n\t/tmp/tmpt7vj151u.lua:48: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 0 and number <= 1000,\n         'invalid input: ' .. tostring(number)\
    \ .. 'should be integer')\n  local roman_numeral = ''\n  local remainder = math.mod(number,\
    \ 10)\n  local i = 1\n  while remainder ~= 0 do\n    roman_numeral = tostring(i\
    \ - 1) .. roman_numeral .. tostring(remainder)\n    remainder = math.floor(remainder\
    \ / 10)\n    i = i + 1\n  end\n  return roman_numeral:lower() .. tostring(number)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2z3hca8t.lua:12:\
    \ attempt to call a nil value (field 'mod')\nstack traceback:\n\t/tmp/tmp2z3hca8t.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmp2z3hca8t.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tif number == 0 then\n\t\treturn ''\n\tend\n\tlocal romans = {\n\t\t100 = 'M',\
    \ 500 = 'D', 1000 = 'CM', 5000 = 'CD', 10000 = 'CDI', 5000 = 'CDI', \n\t\t100000\
    \ = 'CMC', 1000000 = 'MMC', 10000000 = 'MMM', 100000000 = 'MMMM', 1000000000 =\
    \ 'MMMMM', \n\t\t1000000000000 = 'QQQQ', 10000000000000 = 'QQQQQ', 100000000000000\
    \ = 'QQQQQQ'\n\t}\n\tlocal roman_numeral = ''\n\tlocal numeral_length = math.floor(math.log(number,\
    \ 1000))\n\twhile numeral_length ~= 0 do\n\t\tlocal current_roman = romans[math.floor(number\
    \ / 1000 / 1000 * 10000)]\n\t\troman_numeral = roman_numeral .. current_roman\n\
    \t\tnumber = math.floor(number / 1000 / 1000 * 1000)\n\t\tnumeral_length = numeral_length\
    \ - 1\n\tend\n\treturn string.lower(roman_numeral)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpuwt1dd6h.lua:13: '}' expected (to close '{' at line 12) near\
    \ '='\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number == 0 then\n    return 'M'\n  -- If number < 0, return\
    \ an empty string\n  elseif number < 0 then\n    return ''\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdzl43agx.lua:36: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number < 1 then\n    return nil\n  end\n  -- If it's less\
    \ than or equal to 1000, return its roman numeral\n  if number <= 1000 then\n\
    \    return string_concat(to_string(number), '')\n  end\n  -- Divide by 1000 and\
    \ repeat the process with the remainder\n  return string_concat(to_string(number\
    \ / 1000), mini_roman(number % 1000))\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpo_or574o.lua:15:\
    \ attempt to call a nil value (global 'to_string')\nstack traceback:\n\t/tmp/tmpo_or574o.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpo_or574o.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000)\n  local roman = 'I'\n  for i = 1, 4\
    \ do\n    roman = roman:sub(1, roman:len()-2):gsub(\"%d%d?\", \"%1$2\")\n  end\n\
    \  return roman:sub(1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7ualknjh.lua:20:\
    \ expected: \"xix\"\nactual: \"I\"\nstack traceback:\n\t/tmp/tmp7ualknjh.lua:20:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Round to the nearest 'd'.\n  local factor = 1\n  while math.floor(number/factor)\
    \ == number do\n    factor = factor * 10\n  end\n  number = number - factor\n\
    \  local roman = ''\n  local tens = math.floor(number/10)\n  if tens ~= 0 then\n\
    \    for i = 1, tens do\n      roman = roman .. 'x'\n    end\n  end\n  local units\
    \ = number - tens * 10\n  if units <= 4 then\n    roman = roman .. int_to_roman(units)\n\
    \  else\n    roman = roman .. 'v'\n    if units > 10 then\n      roman = roman\
    \ .. int_to_roman(units - 10)\n    end\n  end\n  return string.lower(roman)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkno_by5t.lua:37:\
    \ expected: \"xix\"\nactual: \"v\"\nstack traceback:\n\t/tmp/tmpkno_by5t.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Preprocess the number by adding zeroes to the left until it is a string\
    \ of length 3.\n    -- Example: '123' -> '000123'\n    local int_to_roman = nil\n\
    \    while number ~= nil do\n        local remainder, digits = math.modf(number)\n\
    \        -- Add a zero if the left part is more than 2 digits and less than or\
    \ equal to 3 digits\n        -- Example: 3 -> 0003\n        if digits > 2 and\
    \ digits <= 3 then\n            int_to_roman = int_to_roman .. \"0\"\n       \
    \ end\n        -- Append the remainder to our string\n        int_to_roman = int_to_roman\
    \ .. string.format(\"%0*d\", digits, remainder)\n        -- Remove the processed\
    \ digits from the number\n        number = math.floor(number / 10)\n    end\n\
    \    -- Prepend a roman numeral symbol if we have a string of length 3\n    --\
    \ Example: '0003' -> 'MCMXC'\n    if int_to_roman ~= nil then\n        int_to_roman\
    \ = \"M\"..int_to_roman\n    end\n    -- Convert the string to a lowercase string\n\
    \    int_to_roman = string.lower(int_to_roman)\n    return int_to_roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp57a915da.lua:20:\
    \ invalid option '%*' to 'format'\nstack traceback:\n\t/tmp/tmp57a915da.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmp57a915da.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman = {\n\t\t['I'] = 1,\n\t\t['V'] = 5,\n\t\t['X'] = 10,\n\t\t['C']\
    \ = 50,\n\t\t['D'] = 100,\n\t\t['M'] = 500,\n\t\t['L'] = 1000,\n\t}\n\tlocal roman_num\n\
    \tfor i, key in pairs(roman) do\n\t\tif number >= key then\n\t\t\troman_num =\
    \ roman[key]\n\t\t\tbreak\n\t\tend\n\tend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphtqfl66s.lua:45: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number < 1 then return end\n  local roman = ''\n  local last_index = #roman\n\
    \  for i = 1, (number-1+1) do\n    local digit = math.floor(i/10)\n    roman =\
    \ roman .. _mini_romans[digit]\n    i = i % 10\n  end\n  roman = roman .. _mini_romans[number]\n\
    \  return roman:lower() -- Return the roman numeral in lowercase\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphzxof74w.lua:14:\
    \ attempt to index a nil value (global '_mini_romans')\nstack traceback:\n\t/tmp/tmphzxof74w.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmphzxof74w.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize numeral string to \"\".\n  local numeral_string = \"\"\n  --\
    \ If the number is negative, convert it to positive form and store it in\n  --\
    \ numeral_string.\n  local sign = ''\n  if number < 0 then\n    sign = '-'\n \
    \   number = number * -1\n  end\n  -- Find the number of digits of the number.\n\
    \  local digits = math.floor(math.log(number) / math.log(1000))\n  -- Convert\
    \ the number to a roman numeral.\n  for i = 1, digits do\n    -- Calculate the\
    \ partial sum up to i.\n    local partial_sum = 0\n    local digit_count = 0\n\
    \    for j = 0, i do\n      if math.floor(number / math.pow(1000, j)) ~= 0 then\n\
    \        digit_count = digit_count + 1\n        -- Add the remainder of number/1000\
    \ times 1000 to partial_sum.\n        partial_sum = partial_sum + math.floor(number\
    \ / math.pow(1000, j))\n        -- Divide the number by 1000 and remove it from\
    \ the remainder.\n        number = math.floor(number / math.pow(1000, j))\n  \
    \    else\n        break\n      end\n    end\n    -- If the number of digits are\
    \ evenly divisible by 1000, then divide the\n    -- numeral string into two parts\
    \ using the middle digit.\n    if digit_count % 2 == 0 then\n      -- Calculate\
    \ the quotient and remainder of the division.\n      local quotient = number /\
    \ math.pow(1000, digit_count - 1)\n      local remainder = number - quotient *\
    \ math.pow(1000, digit_count - 1)\n      -- If the quotient is odd, then add an\
    \ \"i\" to the numeral string.\n      if quotient % 2 ~= 0 then\n        numeral_string\
    \ = numeral_string .. 'i'\n      else\n        numeral_string = numeral_string\
    \ .. 'x'\n      end\n      -- Add the quotient to the numeral string.\n      numeral_string\
    \ = numeral_string .. to_char(quotient)\n      -- Add the remainder to the numeral\
    \ string.\n      numeral_string = numeral_string .. to_char(remainder)\n    else\n\
    \      -- Get the remainder of number/1000 times 1000.\n      local quotient =\
    \ number / math.pow(1000, digit_count)\n      -- Add the quotient to the numeral\
    \ string.\n      numeral_string = numeral_string .. to_char(quotient)\n      --\
    \ Divide the number by 1000.\n      number = math.floor(number / math.pow(1000,\
    \ digit_count))\n    end\n  end\n  -- If the number is greater than 999, add an\
    \ \"i\" to the numeral string.\n  if number > 999 then\n    numeral_string = numeral_string\
    \ .. 'i'\n  end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpj9dyelkt.lua:86: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number <= 0 then\n        return nil\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmptascixv6.lua:32: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local romans = {}\n    local numeral_to_roman\n    \n    -- First, translate\
    \ numeric characters to their roman equivalents.\n    -- We assume a minimum roman\
    \ length of 3.\n    local function translate(num,roman)\n        if roman~=nil\
    \ then\n            romans[roman] = romans[roman] or ''\n        end\n       \
    \ if num < 1000 then\n            romans[roman..'I'] = romans[roman..'V'] = romans[roman..'X']\
    \ = romans[roman..'L'] = romans[roman..'C'] = romans[roman..'D'] = romans[roman..'M']\
    \ = romans[roman..''']\n        else\n            numeral_to_roman = translate(num/1000,roman..'I'..'V'..'X'..'L'..'C'..'D'..'M')\n\
    \            romans[roman] = numeral_to_roman\n            while numeral_to_roman~=nil\
    \ do\n                numeral_to_roman = translate(num%1000,roman..numeral_to_roman)\n\
    \                romans[roman..'I'] = romans[roman..'V'] = romans[roman..'X']\
    \ = romans[roman..'L'] = romans[roman..'C'] = romans[roman..'D'] = romans[roman..'M']\
    \ = romans[roman..'']\n            end\n            numeral_to_roman = translate(num%1000,roman..'I'..'V'..'X'..'L'..'C'..'D'..'M')\n\
    \            romans[roman] = numeral_to_roman\n        end\n        return romans[roman..'']\n\
    \    end\n    \n    -- Now use the translated roman values to compute the roman\
    \ numeral equivalents.\n    local function roman_to_numeral(roman)\n        local\
    \ numerals = romans[roman]\n        if numerals then\n            numerals = numerals:gsub('%%C','C'):gsub('%%L','L'):gsub('%%D','D'):gsub('%%M','M')\n\
    \        end\n        romans[roman] = numerals\n        return romans\n    end\n\
    \    \n    local result = translate(number,nil)\n    \n    -- Return the roman\
    \ numer\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpf4oy16yr.lua:19: unexpected symbol near '='\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numeral = nil\n    local roman_numeral_string = \"\"\n    local\
    \ int_to_roman_table = { \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\"\
    , \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\" }\n    local roman_numeral_string_length\
    \ = #int_to_roman_table\n    for i = 1, roman_numeral_string_length do\n     \
    \   local num_roman =\n            (number / roman_numeral_string_length) * roman_numeral_string_length\
    \ +\n            i - 1\n        if num_roman < 1 then\n            num_roman =\
    \ roman_numeral_string_length + num_roman\n        end\n        roman_numeral\
    \ = int_to_roman_table[num_roman]\n        if i == 1 then\n            roman_numeral_string\
    \ = roman_numeral .. roman_numeral_string .. roman_numeral\n        else\n   \
    \         roman_numeral_string = roman_numeral_string .. roman_numeral .. roman_numeral\n\
    \        end\n    end\n    return string.lower(roman_numeral_string)\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpz29ssd7e.lua:22:\
    \ attempt to concatenate a nil value (local 'roman_numeral')\nstack traceback:\n\
    \t/tmp/tmpz29ssd7e.lua:22: in local 'candidate'\n\t/tmp/tmpz29ssd7e.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 then\n    error('argument must be positive: ' .. tostring(number))\n\
    \  else\n    local roman_numeral = ''\n    local i\n    for i = 1, 10 do\n   \
    \   local remainder = number % i\n      if remainder ~= 0 then\n        roman_numeral\
    \ = roman_numeral .. string.lower(to_roman(i - remainder))\n        number = number\
    \ - remainder\n      else\n        roman_numeral = roman_numeral .. string.lower(to_roman(i))\n\
    \      end\n    end\n    return roman_numeral\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_o1biftw.lua:20:\
    \ attempt to call a nil value (global 'to_roman')\nstack traceback:\n\t/tmp/tmp_o1biftw.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmp_o1biftw.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result to 'I'.\n  local roman_numeral = 'I'\n  -- Check first\
    \ digit and adjust if needed.\n  if number < 1000 then\n    if number == 0 then\n\
    \      roman_numeral = 'I'\n    else\n      roman_numeral = string.sub(roman_numeral,\
    \ 1, 1)\n    end\n  end\n  -- Iterate over the rest of the digits.\n  for i =\
    \ 2, 1000 do\n    -- Add the current digit.\n    roman_numeral = string.sub(roman_numeral,\
    \ i, i) + tostring(number % 10)\n    -- If last digit, check whether it is an\
    \ incomplete roman numeral.\n    if i == 1000 then\n      -- If the final digit\
    \ is I (the number was an incomplete roman numeral),\n      -- check whether it\
    \ is a vowel or a consonant.\n      if roman_numeral ~= 'I' and (string.sub(roman_numeral,\
    \ -1, 1) ~= 'i' or\n                                  string.sub(roman_numeral,\
    \ -1, 1) ~= 'u' or\n                                  string.sub(roman_numeral,\
    \ -1, 1) ~= 'o' or\n                                  string.sub(roman_numeral,\
    \ -1, 1) ~= 'u') then\n        -- If the final digit is not I, add the last vowel/consonant.\n\
    \        roman_numeral = roman_numeral .. 'a'\n      else\n        -- If the final\
    \ digit is I, add the last consonant.\n        roman_numeral = roman_numeral ..\
    \ 'b'\n      end\n    end\n    -- Divide the number by 10, as this reduces the\
    \ number of digits.\n    number = number / 10\n  end\n  -- Return the result.\n\
    \  return roman_numeral\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp91q9x5kr.lua:22:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmp91q9x5kr.lua:22:\
    \ in local 'candidate'\n\t/tmp/tmp91q9x5kr.lua:48: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number == 0 then\n        return '0'\n    end\n    local roman\n    local\
    \ decimal\n    local exponent\n    local digits\n    local tens\n    local length\n\
    \    number = tonumber(number)\n    length = string.format(\"%g\", number).lenght\n\
    \    if length == 0 then\n        return '0'\n    end\n    roman = string.sub(tostring(number),\
    \ 1, length)\n    if tonumber(roman) == 0 then\n        decimal = '0'\n      \
    \  exponent = 0\n        digits = roman\n    else\n        decimal = string.sub(tostring(roman),\
    \ -1)\n        exponent = tostring(string.find(roman, \".\") - 2)\n        digits\
    \ = string.sub(tostring(roman), 2, string.find(roman, \".\") - 2)\n    end\n \
    \   if exponent > 0 then\n        tens = string.sub(tostring(digits), -exponent,\
    \ -1)\n        if tonumber(tens) == 0 then\n            exponent = 0\n       \
    \ else\n            decimal = decimal .. 'x' .. tens\n            digits = digits\n\
    \        end\n    else\n        digits = string.sub(tostring(digits), -exponent)\n\
    \        if tonumber(digits) == 0 then\n            exponent = 0\n        else\n\
    \            decimal = decimal .. 'x' .. digits\n        end\n    end\n    if\
    \ tonumber(decimal) == 0 then\n        return nil\n    end\n    if tonumber(decimal)\
    \ > 0 then\n        return decimal .. string.sub(tostring(decimal), -1)\n    else\n\
    \        return nil\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpowuxrn_v.lua:33:\
    \ attempt to compare number with string\nstack traceback:\n\t/tmp/tmpowuxrn_v.lua:33:\
    \ in local 'candidate'\n\t/tmp/tmpowuxrn_v.lua:62: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  for i = 1, 4 do\n    local mult = math.pow(10, i - 1)\n\
    \    local num = math.floor((number / mult) * mult)\n    local char = string.sub('XIV',\
    \ 2, i)\n    roman = roman .. char\n    number = number - num\n  end\n  return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2h41w8jy.lua:23:\
    \ expected: \"xix\"\nactual: \"IIVIV\"\nstack traceback:\n\t/tmp/tmp2h41w8jy.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   if number <= 0 or number > 1000 then\n      print('ERROR: given number is\
    \ invalid. Require 1 <= num <= 1000')\n      return\n   end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsvo8dqtb.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    if number > 1000 then\n        error('Argument must be between 1 and 1000')\n\
    \    end\n    local roman_numeral = ''\n    if number <= 0 then\n        error('Argument\
    \ must be positive')\n    end\n    while number > 0 do\n        local remainder\
    \ = number % 100\n        roman_numeral = string.sub('MCMXCIV', remainder, #roman_numeral)\n\
    \        number = math.floor(number / 100)\n    end\n    return string.lower(roman_numeral)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkb4my5gz.lua:27:\
    \ expected: \"xix\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpkb4my5gz.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal romans = {\n\t\t[1] = '',\n\t\t[2] = 'i',\n\t\t[3] = 'i',\n\t\t[4] = 'i',\n\
    \t\t[5] = 'i',\n\t\t[6] = 'i',\n\t\t[7] = 'i',\n\t\t[8] = 'i',\n\t\t[9] = 'i',\n\
    \t\t[10] = 'i',\n\t\t[11] = 'i',\n\t\t[12] = 'i',\n\t\t[13] = 'i',\n\t\t[14] =\
    \ 'i',\n\t\t[15] = 'i',\n\t\t[16] = 'i',\n\t\t[17] = 'ii',\n\t\t[18] = 'iii',\n\
    \t\t[19] = 'iiii',\n\t\t[20] = 'iv',\n\t\t[21] = 'v',\n\t\t[22] = 'vi',\n\t\t\
    [23] = 'vii',\n\t\t[24] = 'viii',\n\t\t[25] = 'ix',\n\t\t[26] = 'x',\n\t\t[27]\
    \ = 'xi',\n\t\t[28] = 'xii',\n\t\t[29] = 'xiii',\n\t\t[30] = 'xiv',\n\t\t[31]\
    \ = 'vx',\n\t\t[32] = 'vxi',\n\t\t[33] = 'vxiv',\n\t\t[34] = 'vxxi',\n\t\t[35]\
    \ = 'vxxii',\n\t\t[36] = 'vxxiii',\n\t\t[37] = 'vxxiv',\n\t\t[38] = 'vxxv',\n\t\
    \t[39] = 'vxxvi',\n\t\t[40] = 'vxxvii',\n\t\t[41] = 'vxxviii',\n\t\t[42] = 'vxxxi',\n\
    \t\t[43] = 'vxxxii',\n\t\t[44] = 'vxxxiii',\n\t\t[45] = 'vxxxiv',\n\t\t[46] =\
    \ 'vxxxv',\n\t\t[47] = 'vxxxvi',\n\t\t[48] = 'vxxxvii',\n\t\t[49] = 'vxxxviii',\n\
    \t\t[50] = 'vxxxxi',\n\t\t[51] = 'vxxxxii',\n\t\t[52] = 'vxxxxiii',\n\t\t[53]\
    \ = 'vxxxxiv',\n\t\t[54] = 'vxxxxv',\n\t\t[55] = 'vxxxxvi',\n\t\t[56] = 'vxxxxvii',\n\
    \t\t[57] = 'vxxxxviii',\n\t\t[58] = 'vxxxxix',\n\t\t[59] = 'vxxxxx',\n\t\t[60]\
    \ = 'vxxxxxi',\n\t\t[61] = 'vxxxxxx',\n\t\t[62] = 'vxxxxxii',\n\t\t[63] = 'vxxxxxxi',\n\
    \t\t[64] = 'vxxxxxii',\n\t\t[65] = 'vxxxxxxii',\n\t\t[66] = 'vxxxxxxx',\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpoqwt1sb3.lua:78: '}' expected (to close '{' at line 9) near\
    \ 'function'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman2str(number)\n  local alphabet = alphabet2str(number)\n\
    \  return alphabet:sub(1, alphabet:len() - roman:len() + 1):lower() + roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxa9_sfxf.lua:9:\
    \ attempt to call a nil value (global 'roman2str')\nstack traceback:\n\t/tmp/tmpxa9_sfxf.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpxa9_sfxf.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- Round up to nearest hundred thousand\n    number = math.floor(number +\
    \ 2999) / 1000\n    if number <= 0 then\n        error('Number is less than 1:\
    \ ', number)\n    end\n    -- Write out numbers\n    if number >= 1000 then\n\
    \        local current_thousand = number\n        local num_hundreds = 0 -- Will\
    \ be multiplied by 100\n        local num_tens = 0 -- Will be multiplied by 10\n\
    \        while current_thousand > 1000 do\n            num_hundreds = num_hundreds\
    \ + 1\n            current_thousand = current_thousand - 1000\n        end\n \
    \       while num_hundreds > 0 do\n            local hundreds = num_hundreds -\
    \ 1\n            local tens = math.floor(current_thousand / 10)\n            num_tens\
    \ = num_tens + (hundreds * (10 * tens))\n            current_thousand = current_thousand\
    \ - tens * 10\n        end\n        -- Write out final number\n        local mini_roman\
    \ = ''\n        while number >= 1000 do\n            mini_roman = mini_roman ..\
    \ 'M'\n            number = number - 1000\n        end\n        while num_tens\
    \ > 0 do\n            local tens = num_tens - 1\n            local units = math.floor(number\
    \ / 10)\n            mini_roman = mini_roman .. 'C' .. units\n            number\
    \ = number - tens * 10\n        end\n        while number >= 10 do\n         \
    \   mini_roman = mini_roman .. 'L' .. math.floor(number / 10)\n            number\
    \ = number - math.floor(number / 10)\n        end\n        mini_roman = mini_roman\
    \ .. 'X'\n        return mini_roman\n    end\n    -- Write out numerals\n    if\
    \ number >= 5000 then\n        local current_thousand = number\n        local\
    \ num_hundreds = 0 -- Will be multiplied by 100\n        local num_tens = 0 --\
    \ Will be multiplied by 10\n        while current_thousand > 5000 do\n       \
    \     num_hundreds = num_hundreds + 1\n            current_thousand = current_thousand\
    \ - 5000\n        end\n        while num_hundreds > 0 do\n            local hundreds\
    \ = num_hundreds - 1\n            local tens = math.floor(current_thousand / 10)\n\
    \            num_tens = num_tens + (hundreds * (10 * tens))\n            current_thousand\
    \ = current_thousand - tens * 10\n        end\n        -- Write out final number\n\
    \        local mini_roman = ''\n        while number >= 5000 do\n            mini_roman\
    \ = mini_roman .. 'V'\n            number = number - 5000\n        end\n     \
    \   while num_ten\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpf_s3060_.lua:70: 'do' expected near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = roman_int_cache[number]\n    if not roman then\n        local\
    \ romans = roman_numerals[number]\n        local roman = ''\n        for i = 1,\
    \ #romans do\n            if number >= romans[i] then\n                roman =\
    \ roman..romans[i]\n                number = number - romans[i]\n            \
    \    break\n            end\n        end\n        roman_int_cache[number] = roman\n\
    \    end\n    return string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmeaiv3uo.lua:9:\
    \ attempt to index a nil value (global 'roman_int_cache')\nstack traceback:\n\t\
    /tmp/tmpmeaiv3uo.lua:9: in local 'candidate'\n\t/tmp/tmpmeaiv3uo.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number and number >= 1 and number <= 1000)\n  local roman = string.new()\n\
    \  -- write each numeral starting from the highest value\n  -- 9 is 1000 in numeral,\
    \ 10 is 900 in numeral, etc.\n  for i = 9, 1, -1 do\n    local n = math.floor(number/i)\n\
    \    number = number - n*n\n    roman = string.sub(roman, 1, i - 1) + ntos(n)\
    \ + roman\n  end\n  return roman\nend\nminiroman = mini_roman\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpietr0uvq.lua:10:\
    \ attempt to call a nil value (field 'new')\nstack traceback:\n\t/tmp/tmpietr0uvq.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpietr0uvq.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The number is assumed to be between 1 and 1000 (inclusive)\n  assert(number\
    \ <= 1000 and number >= 1)\n  local romans = {\n    [''] = string.rep('', 1000),\n\
    \    ['M'] = string.rep('M', 1000),\n    ['CM'] = string.rep('C', 100),\n    ['D']\
    \ = string.rep('D', 10),\n    ['CD'] = string.rep('D', 10),\n    ['C'] = string.rep('C',\
    \ 10),\n    ['XC'] = string.rep('X', 10),\n    ['L'] = string.rep('L', 10),\n\
    \    ['XL'] = string.rep('X', 10),\n    ['X'] = string.rep('X', 10),\n    ['IX']\
    \ = string.rep('I', 10),\n    ['V'] = string.rep('V', 10),\n    ['IV'] = string.rep('I',\
    \ 10),\n    ['I'] = string.rep('I', 10),\n  }\n  -- Romans with fewer than three\
    \ digits\n  if number <= 199 or number > 1000 then\n    return romans[tostring(number)]\n\
    \  end\n  -- Romans with more than three digits\n  if number > 1999 then\n   \
    \ -- Add additional letters for thousands\n    local num_thousands\n    if number\
    \ <= 50000 then\n      num_thousands = tostring(number / 1000)\n      local remainder\
    \ = number % 1000\n      -- Add additional letters for hundreds\n      if remainder\
    \ <= 99 then\n        local num_hundreds = tostring(remainder / 100)\n       \
    \ local remainder_hundreds = remainder % 100\n        return romans[num_thousands]\
    \ .. romans[num_hundreds] .. romans[remainder_hundreds]\n      end\n      -- Add\
    \ additional letters for tens\n      if remainder <= 99 then\n        local num_tens\
    \ = tostring(remainder / 10)\n        local remainder_tens = remainder % 10\n\
    \        return romans[num_thousands] .. romans[num_tens] .. romans[remainder_tens]\n\
    \      end\n      -- Add additional letters for ones\n      if remainder <= 9\
    \ then\n        local num_ones = tostring(remainder / 1)\n        return romans[num_thousands]\
    \ .. romans[num_ones]\n      end\n    end\n    -- If no letters were needed, just\
    \ add one\n    return romans[tostring(number)]\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgrc10zff.lua:64:\
    \ expected: \"xix\"\nactual: nil\nstack traceback:\n\t/tmp/tmpgrc10zff.lua:64:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    -- First break number up into its digits\n    local digits = math.floor((number\
    \ - 1) / 100)\n    number = number - 100 * digits\n    -- Then break each of those\
    \ digits' digits into their individual digits\n    local digits_as_strings = math.huge\n\
    \    for i = 1, digits do\n        digits_as_strings = math.floor((digits_as_strings\
    \ / 10) * (i + 1)) + math.floor(digits_as_strings / 10)\n    end\n    -- Now convert\
    \ the individual digits into a number\n    local digits_to_numbers = digits_as_strings\
    \ - (math.floor(digits_as_strings / 10)) * 10\n    -- Now we can create the Roman\
    \ numeral\n    local roman = nil\n    if digits_to_numbers <= 26 then\n      \
    \  roman = string.sub(mini_roman_numerals, 1, digits_to_numbers)\n    elseif digits_to_numbers\
    \ <= 52 then\n        roman = string.sub(mini_roman_numerals, 2, digits_to_numbers)\n\
    \    elseif digits_to_numbers <= 108 then\n        roman = string.sub(mini_roman_numerals,\
    \ 3, digits_to_numbers)\n    elseif digits_to_numbers <= 402 then\n        roman\
    \ = string.sub(mini_roman_numerals, 4, digits_to_numbers)\n    elseif digits_to_numbers\
    \ <= 708 then\n        roman = string.sub(mini_roman_numerals, 5, digits_to_numbers)\n\
    \    elseif digits_to_numbers <= 109 then\n        roman = string.sub(mini_roman_numerals,\
    \ 6, digits_to_numbers)\n    elseif digits_to_numbers <= 403 then\n        roman\
    \ = string.sub(mini_roman_numerals, 7, digits_to_numbers)\n    elseif digits_to_numbers\
    \ <= 709 then\n        roman = string.sub(mini_roman_numerals, 8, digits_to_numbers)\n\
    \    elseif digits_to_numbers <= 439 then\n        roman = string.sub(mini_roman_numerals,\
    \ 9, digits_to_numbers)\n    elseif digits_to_numbers <= 794 then\n        roman\
    \ = string.sub(mini_roman_numerals, 10, digits_to_numbers)\n    elseif digits_to_numbers\
    \ <= 103 then\n        roman = string.sub(mini_roman_numerals, 11, digits_to_numbers)\n\
    \    elseif digits_to_numbers <= 305 then\n        roman = string.sub(mini_roman_numerals,\
    \ 12, digits_to_numbers)\n    elseif digits_to_numbers <= 690 then\n        roman\
    \ = string.sub(mini_roman_numerals, 13, digits_to_number\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpphf2faq2.lua:47: ')' expected (to close '(' at line 46) near\
    \ 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number > 0, \"Invalid roman (negative?): \" .. number)\n  assert(number\
    \ <= 999, \"Invalid roman (>999): \" .. number)\n  local roman = \"\"\n  for i\
    \ = 0, number - 1, 1 do\n    roman = roman .. mini_to_roman[i]\n  end\n  return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpnnp9b0b9.lua:13:\
    \ attempt to index a nil value (global 'mini_to_roman')\nstack traceback:\n\t\
    /tmp/tmpnnp9b0b9.lua:13: in local 'candidate'\n\t/tmp/tmpnnp9b0b9.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000)\n  local roman = { }\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7sl4mema.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    number = assert(tonumber(number), 'Failed to convert argument \"number\"\
    \ to an integer.')\n    local romans = {\n        I = 'i',\n        X = 'x',\n\
    \        C = 'c',\n        D = 'd',\n        M = 'm',\n        V = 'v',\n    \
    \    L = 'l',\n        R = 'x',\n        IQ = 'i',\n        II = 'i',\n      \
    \  III = 'i',\n        IV = 'v',\n        VI = 'v',\n        VII = 'v',\n    \
    \    VIII = 'v',\n        IX = 'x',\n        XI = 'x',\n        XII = 'x',\n \
    \       XIII = 'x',\n        XIV = 'x',\n        XL = 'l',\n        XV = 'v',\n\
    \        IV = 'iv',\n        V = 'vi',\n        IX = 'ix',\n        X = 'x'\n\
    \    }\n    local roman = ''\n    local remainder\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppviu1fb1.lua:60: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Roman (lowercase and reversed) is just the same as Roman numerals,\n  --\
    \ except that lower cased ones are represented with their capitalized versions.\n\
    \  -- e.g. 'i' instead of 'one'.\n  local roman = string.gsub(number_to_roman(number),\
    \ '(%[aeiou])(%[aeiou])(%[aeiou])',\n\t\t\t'%1\\\\\\2\\\\3')\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmph8e7b33b.lua:34: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base cases\n  if number <= 0 then\n    return 'x'\n  end\n  if number <=\
    \ 20 then\n    return 'x'\n  end\n  -- A Roman numeral is just a concatenation\
    \ of numerals scaled by their position\n  -- in Roman numeral, excluding the numeral\
    \ that corresponds to 'I'\n  local roman_numerals = roman_numerals .. 'i'\n  --\
    \ Each numeral corresponds to a letter in Roman numeral\n  for i = 1, number -\
    \ 1 do\n    roman_numerals = roman_numerals .. roman_letters[i]\n  end\n  -- The\
    \ 'I' letter corresponds to the integer number\n  roman_numerals = roman_numerals\
    \ .. roman_letters[number - 1]\n  -- Return the converted string\n  return roman_numerals\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1ge5k_bt.lua:32:\
    \ expected: \"xix\"\nactual: \"x\"\nstack traceback:\n\t/tmp/tmp1ge5k_bt.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local romans = {\n      ('M','CM','D','CD','C','XC','XL','L','X','IX','V','IV','I')\n\
    \      ,('M','D','C','XC','L','XL','X','IX','V','IV','I')\n      ,('D','C','XL','X','IX','V','IV','I')\n\
    \      ,('C','X','XL','L','X','IX','V','IV','I')\n      ,('X','XL','V','IV','I')\n\
    \      ,('L','X','V','IV','I')\n      ,('XL','V','I')\n      ,('V','I')\n  }\n\
    \  local roman_index = 1\n  -- Find the smallest value greater than or equal to\
    \ 'number' that is a\n  -- roman numeral.\n  -- For example, given 'number' equal\
    \ to 21, the smallest value greater\n  -- than or equal to 21 is III.\n  local\
    \ roman_numeral = 'I'\n  while roman_numeral ~= roman_index and roman_numeral\
    \ ~= nil do\n    roman_numeral = romans[roman_index][math.floor(math.abs(number/roman_index))]\n\
    \    roman_index = roman_index + 1\n  end\n  return roman_numeral or roman_index\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpkhhfgdly.lua:10: ')' expected near ','\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The maximum number of integer representations that we need.\n  local max_int_repr\
    \ = math.ceil(math.log(number, 1000) / math.log(10)) + 1\n  -- Round down to the\
    \ max number of representations.\n  -- This protects against integer overflow.\n\
    \  number = math.floor(number / math.pow(10, max_int_repr))\n  -- Convert to the\
    \ closest base 10 representation.\n  local roman = number:div(math.pow(10, max_int_repr)):mul(math.pow(10,\
    \ max_int_repr - 1))\n  return roman:reverse():gsub('%d$', ''):reverse():gsub('(.-)(.)$',\
    \ function(s1, s2)\n    return s1 .. string.reverse(s2)\n  end)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpoztvx92z.lua:15:\
    \ attempt to index a number value (local 'number')\nstack traceback:\n\t/tmp/tmpoztvx92z.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpoztvx92z.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   assert(number >= 1 and number <= 1000, \"Bad input: \" .. tostring(number))\n\
    \   local roman, roman_num\n   if number == 1 then\n      roman = \"I\"\n    \
    \  roman_num = number\n   else\n      roman, roman_num = generate_roman(number)\n\
    \   end\n   return roman, roman_num\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5hs9ffvk.lua:15:\
    \ attempt to call a nil value (global 'generate_roman')\nstack traceback:\n\t\
    /tmp/tmp5hs9ffvk.lua:15: in local 'candidate'\n\t/tmp/tmp5hs9ffvk.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  if number <= 0 then\n    return \"error invalid number\"\n  end\n  local roman\
    \ = \"\"\n  local factor = 1\n  while number >= factor do\n    roman = string.sub(roman,\
    \ 1, string.reverse(roman:sub(2, 3)))..\n      (string.sub(roman, 4, string.reverse(roman:sub(2,\
    \ 3))):sub(1, 1))\n    number = number - factor\n    factor = factor * 1000\n\
    \  end\n  roman = roman..\n    (string.sub(roman, 4, string.reverse(roman:sub(2,\
    \ 3))):sub(1, 1))\n  roman = roman..\n    string.sub(roman, 2)\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_i7dsog9.lua:15:\
    \ bad argument #3 to 'sub' (number expected, got string)\nstack traceback:\n\t\
    /tmp/tmp_i7dsog9.lua:15: in local 'candidate'\n\t/tmp/tmp_i7dsog9.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- assert(number >= 1)\n  -- assert(number <= 1000)\n  local roman = ''\n \
    \ for i = 1, number do\n    local remaining = math.floor((number - i) / i)\n \
    \   if remaining > 0 then\n      roman = roman .. 'L'..remaining\n    else\n \
    \     roman = roman .. 'M'..i\n    end\n  end\n  return string.lower(roman)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptkkkx_3q.lua:26:\
    \ expected: \"xix\"\nactual: \"l18l8l5l3l2l2l1l1l1m10m11m12m13m14m15m16m17m18m19\"\
    \nstack traceback:\n\t/tmp/tmptkkkx_3q.lua:26: in function 'test_humaneval'\n\n\
    Ran 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \   assert(number > 0, 'Invalid input number for int_to_mini_roman: ' .. number)\n\
    \   assert(number <= 1000, 'Invalid input number for int_to_mini_roman: ' .. number)\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7a_lg71v.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- We use roman_numerals because it is more convenient to work with than romans\n\
    \  local roman_numerals = {\n    ['M'] = 1000,\n    ['CM'] = 900,\n    ['D'] =\
    \ 500,\n    ['CD'] = 400,\n    ['C'] = 100,\n    ['XC'] = 90,\n    ['L'] = 50,\n\
    \    ['XL'] = 40,\n    ['X'] = 10,\n    ['IX'] = 9,\n    ['V'] = 5,\n    ['IV']\
    \ = 4,\n    ['I'] = 1\n  }\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdjtbv18z.lua:45: 'end' expected (to close 'function' at line\
    \ 8) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_nums = { }\n  -- First we convert the number to decimal.\n  local\
    \ dec = 0\n  for i = 1, number do\n    dec = dec + i\n    roman_nums[dec] = i\n\
    \  end\n  -- Now we convert the decimal to roman numeral.\n  local roman_num =\
    \ ''\n  for i = 1, dec do\n    roman_num = roman_num .. roman_nums[i]\n  end\n\
    \  return roman_num\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv9l3b034.lua:19:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmpv9l3b034.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmpv9l3b034.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize to lowest roman's number + 1\n  local roman_nums = string.char(0xFF\
    \ .. 0xFE)\n  -- Add 'i' before the roman's number\n  roman_nums:insert('i')\n\
    \  -- Round to the nearest multiple of 3\n  number = number - number % 3\n  --\
    \ Round down to the nearest multiple of 5\n  number = number - number % 5\n  --\
    \ Round down to nearest multiple of 10\n  number = number - number % 10\n  --\
    \ Round down to nearest multiple of 100\n  number = number - number % 100\n  --\
    \ Round down to nearest multiple of 1000\n  number = number - number % 1000\n\
    \  -- Remove leading 'x'\n  roman_nums:sub(1,1)\n  -- Return roman numeral\n \
    \ return string.lower(roman_nums)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpkkn0z8le.lua:10:\
    \ bad argument #1 to 'char' (value out of range)\nstack traceback:\n\t/tmp/tmpkkn0z8le.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpkkn0z8le.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romanTable:sub(1, number)\n  return roman:sub(1, 1):lower() +\
    \ roman:sub(2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3pwf2xft.lua:9:\
    \ attempt to index a nil value (global 'romanTable')\nstack traceback:\n\t/tmp/tmp3pwf2xft.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmp3pwf2xft.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman = ''\n\twhile number > 1000 do\n\t\troman = roman..'M'\n\t\tnumber\
    \ = number - 1000\n\tend\n\twhile number > 5000 do\n\t\troman = roman..'CM'\n\t\
    \tnumber = number - 5000\n\tend\n\twhile number > 4000 do\n\t\troman = roman..'D'\n\
    \t\tnumber = number - 4000\n\tend\n\twhile number > 1000 do\n\t\troman = roman..'C'\n\
    \t\tnumber = number - 1000\n\tend\n\twhile number > 500 do\n\t\troman = roman..'XC'\n\
    \t\tnumber = number - 500\n\tend\n\twhile number > 400 do\n\t\troman = roman..'L'\n\
    \t\tnumber = number - 400\n\tend\n\twhile number > 100 do\n\t\troman = roman..'XL'\n\
    \t\tnumber = number - 100\n\tend\n\twhile number > 50 do\n\t\troman = roman..'X'\n\
    \t\tnumber = number - 50\n\tend\n\twhile number > 40 do\n\t\troman = roman..'V'\n\
    \t\tnumber = number - 40\n\tend\n\twhile number > 10 do\n\t\troman = roman..'IV'\n\
    \t\tnumber = number - 10\n\tend\n\twhile number > 9 do\n\t\troman = roman..'I'\n\
    \t\tnumber = number - 9\n\tend\n\treturn roman..number\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptqzrsvzu.lua:60:\
    \ expected: \"xix\"\nactual: \"IV9\"\nstack traceback:\n\t/tmp/tmptqzrsvzu.lua:60:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
