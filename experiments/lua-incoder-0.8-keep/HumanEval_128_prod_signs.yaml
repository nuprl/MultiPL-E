name: HumanEval_128_prod_signs
language: lua
prompt: "-- You are given an array arr of integers and you need to return\n-- sum\
  \ of magnitudes of integers multiplied by product of all signs\n-- of each number\
  \ in the array, represented by 1, -1 or 0.\n-- Note: return None for empty arr.\n\
  -- Example:\n-- >>> prod_signs([1, 2, 2, -4]) == -9\n-- >>> prod_signs([0, 1]) ==\
  \ 0\n-- >>> prod_signs([]) == None\nlocal function prod_signs(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prod_signs\n\
  \    lu.assertEquals(candidate({1, 2, 2, -4}), -9)\n    lu.assertEquals(candidate({0,\
  \ 1}), 0)\n    lu.assertEquals(candidate({1, 1, 1, 2, 3, -1, 1}), -10)\n    lu.assertEquals(candidate({}),\
  \ None)\n    lu.assertEquals(candidate({2, 4, 1, 2, -1, -1, 9}), 20)\n    lu.assertEquals(candidate({-1,\
  \ 1, -1, 1}), 4)\n    lu.assertEquals(candidate({-1, 1, 1, 1}), -4)\n    lu.assertEquals(candidate({-1,\
  \ 1, 1, 0}), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #arr == 0 then return end\n  if arr[1] < 0 then\n    return -prod_signs(arr\
    \ * -1)\n  end\n  local prod = 1\n  for i = 2, #arr do\n    prod = prod * arr[i]\n\
    \    if prod < 0 then return end\n  end\n  return prod\nend", "  if #arr == 0\
    \ then return end\n  local signs = arr[1]\n  local sign = 1\n  for i = 2, #arr\
    \ do\n    if sign == 1 and signs[i] == 1 then sign = 1 end\n    else if sign ==\
    \ -1 and signs[i] == -1 then sign = 1 end\n    sign = sign * signs[i]\n  end\n\
    \  return sign\nend", "  if #arr < 1 then return nil end\n  local result = 1\n\
    \  for i = 1, #arr do\n    local sign = arr[i] >= 0 and 1 or -1\n    result =\
    \ sign * result * sign\n  end\n  return result\nend", "    local sum = 0\n   \
    \ local sign = 1\n    local i, n = #arr, 1\n    while i do\n        sum = sum\
    \ + arr[i] * sign\n        n = n - 1\n        sign = sign * -1\n        i = i\
    \ + 1\n    end\n    return sum\nend", "  if arr == nil then return nil end\n \
    \ local i, sign\n  local sum = 1, 0\n  for i=1, #arr do\n    local sign = math.sign(\
    \ arr[i] )\n    sum = sum * sign\n    sum = sum + sign\n  end\n  return sum\n\
    end", "  if #arr == 0 then\n    return nil\n  end\n  if #arr == 1 then\n    return\
    \ arr[1]\n  end\n  local ans = arr[1]\n  for i = 2, #arr do\n    if arr[i] < 0\
    \ then\n      ans = -ans\n    elseif arr[i] > 0 then\n      ans = ans * arr[i]\n\
    \    end\n  end\n  return ans\nend", "  if #arr == 0 then return 0 end\n  local\
    \ prod = 1\n  local sum = 0\n  for i = 1, #arr do\n    sum = sum + arr[i]\n  \
    \  prod = prod * math.sign(arr[i])\n  end\n  return sum * prod\nend", "  if #arr\
    \ < 1 then\n    return nil\n  else\n    if arr[1] <= 0 then\n      return arr[1]\
    \ * prod_signs(arr[2:])\n    else\n      return prod_signs(arr[2:]) * arr[1]\n\
    \    end\n  end\nend", "  -- Base case\n  if #arr == 0 then return 0 end\n  local\
    \ sign = arr[1]\n  -- For all other cases, if sign of first element is not equal\
    \ to sign\n  -- of all the other elements then return None.\n  for i = 2, #arr\
    \ do\n    local sign2 = arr[i]\n    if sign ~= sign2 then return nil end\n  end\n\
    \  return sign\nend", '  if #arr == 0 then return nil end', "  if #arr == 0 then\n\
    \    return 0\n  else\n    local s = arr[1]\n    for i = 2, #arr do\n      if\
    \ arr[i] ~= 0 then\n        s = (arr[i] * s) * sign(-arr[i])\n      end\n    end\n\
    \    return s\n  end\nend", "  assert(arr and #arr > 0, 'invalid argument')\n\
    \  local sum = 0\n  for i = 1, #arr do\n    local sign = arr[i] and 1 or -1\n\
    \    sum = sum + math.abs(sign) * sign\n  end\n  return sum\nend", "    local\
    \ sign = 1\n    local sum = 0\n    for i = 1, #arr do\n        sum = sum + math.abs(arr[i])\
    \ * sign\n        sign = -sign\n    end\n    return sum\nend", "  if arr == nil\
    \ then return nil end\n  local signs = { 1, 0, -1 }\n  local total = 0\n  for\
    \ i, x in ipairs(arr) do\n    total = total + (x * signs[i])\n  end\n  return\
    \ total\nend", "  if arr[1] == nil then\n    return nil\n  end\n  local res =\
    \ arr[1]\n  for i = 2, #arr do\n    res = res * arr[i]\n  end\n  return res\n\
    end", "    local sum = 0\n    for i=1,#arr do\n        if arr[i] > 0 then\n  \
    \          sum = sum + arr[i]\n        elseif arr[i] < 0 then\n            sum\
    \ = sum - arr[i]\n        end\n    end\n    return sum\nend", "  local signs,\
    \ product = 1, 1\n  for i = 1, #arr do\n    signs = signs * math.sign(arr[i])\n\
    \    product = product * abs(arr[i])\n  end\n  return signs * product\nend", " \
    \ if #arr == 0 then\n    return nil\n  end\n  local sign = 1\n  local sum = 0\n\
    \  for i = 1, #arr do\n    sum = sum + math.abs(arr[i]) * sign\n    sign = -sign\n\
    \  end\n  return sum\nend", "  if arr == nil then\n    return nil\n  end\n  if\
    \ #arr == 1 then\n    return arr[1]\n  end\n  if #arr == 2 then\n    return arr[1]*arr[2]\n\
    \  end\n  if #arr == 3 then\n    return arr[1]*arr[2]*arr[3]\n  end\n  if #arr\
    \ > 3 then\n    local sum = 1\n    for i = 1, #arr do\n      sum*=arr[i]\n   \
    \ end\n    return sum\n  end\nend", "  if #arr == 0 then\n    return nil\n  end\n\
    \  if #arr == 1 then\n    return arr[1]\n  end\n  local mult = 1\n  for i = 1,\
    \ #arr do\n    if arr[i] < 0 then\n      mult = mult * -1\n    end\n  end\n  return\
    \ mult * arr_sum(arr)\nend", "   -- check validity of arr\n   if not arr then\
    \ return nil end\n   -- base cases\n   if #arr == 1 then\n      return arr[1]\
    \ > 0 and arr[1] or -arr[1]\n   end\n   if #arr == 2 then\n      return arr[1]\
    \ * arr[2] and arr[1] * arr[2] or arr[1] * -arr[2]\n   end\n   -- recursive case\n\
    \   local i = 1\n   local result = 0\n   while i <= #arr do\n      -- use i as\
    \ the index for the next element in the array\n      local sign = arr[i] > 0 and\
    \ 1 or -1\n      -- multiply by the sign of the next element\n      result = result\
    \ * sign and result * sign or result * -sign\n      i = i + 1\n   end\n   return\
    \ result\nend", "  if #arr < 1 then return nil end\n  local sign = 1\n  local\
    \ product = 1\n  for i = 1, #arr do\n    local cur = arr[i]\n    if cur > 0 and\
    \ cur < 0 then\n      product = product * sign\n    elseif cur < 0 and cur > -1\
    \ then\n      product = product * sign\n    end\n    sign = sign * math.abs(cur)\n\
    \  end\n  return product\nend", "  if #arr == 0 then\n    return nil\n  end",
  "  if #arr == 0 then return None else return 0\n  local sign = 1\n  local i = 1\n\
    \  while i < #arr do\n    local sign = sign * -1\n    i = i + 1\n  end\n  local\
    \ sign = 1\n  while i < #arr do\n    local sign = sign * arr[i]\n    i = i + 1\n\
    \  end\n  return sign\nend\n  ", "  local sign = arr[1]\n  local sum = 0\n  for\
    \ i=2,#arr do\n    local sign = sign * arr[i]\n    sum = sum + sign\n  end\n \
    \ return sum\nend", "  if arr == nil then return end\n  local signs = { -1, -1,\
    \ -1 }\n  for i = 1, #arr do\n    sign = signs[arr[i]]\n    if sign ~= -1 then\
    \ return nil end\n    signs[arr[i]] = arr[i] ~= 0 and 1 or -1\n  end\n  return\
    \ #signs == 0 and 1 or signs[1] * signs[2] * signs[3]\nend", "  if #arr == 0 then\
    \ return None end\n  local result = 1\n  for i, v in ipairs(arr) do\n    result\
    \ = result * v\n    if result < 0 then\n      return nil\n    end\n  end\n  return\
    \ result\nend", "  if #arr == 0 then return end\n  local sign = arr[1]\n  local\
    \ prod = 1\n  for i = 2, #arr do\n    prod = prod * sign\n    sign = arr[i]\n\
    \  end\n  return prod\nend", "  if #arr == 0 then\n    return None\n  elseif #arr\
    \ == 1 then\n    return arr[1]*prod(mapfunction(function(x) return sign(x) end,\
    \ arr))\n  else\n    return arr[1]*prod(mapfunction(function(x) return sign(x)\
    \ * prod_signs(arr) end, arr))\n  end\nend", "  local result = 1\n  for i = 1,\
    \ #arr do\n    local mult = 1\n    for j = 1, 3 do\n      if arr[i] > 0 then\n\
    \tmult = mult*(arr[j] - 1)\n      elseif arr[i] < 0 then\n\tmult = mult*(1 - arr[j])\n\
    \      else\n\tmult = mult*0\n      end\n    end\n    result = result * mult\n\
    \  end\n  return result\nend", "   if not arr or #arr == 0 then\n      return\
    \ nil\n   end\n   local sum, sign = 1\n   for i = 1, #arr do\n      if arr[i]\
    \ < 0 then\n         sum = -sum\n         sign = - sign\n      elseif arr[i] >\
    \ 0 then\n         sum = sum\n      else\n         sign = 0\n      end\n   end\n\
    \   return sum * sign\nend", "  local product = 1\n  local sign = 1\n  for i,\
    \ v in ipairs(arr) do\n    local sign = v % 2 and 1 or -1\n    product = product\
    \ * (sign * v)\n  end\n  return product\nend", "   local result, sign\n   for\
    \ i = 1, #arr do\n      sign = arr[i]\n      if sign == 1 then result = result\
    \ + magnitude (arr) end\n      if sign == -1 then result = result - magnitude\
    \ (arr) end\n      if sign == 0 then result = result * magnitude (arr) end\n \
    \  end\n   return result\nend", "    local result = 1\n    for i = 1, #arr do\n\
    \        if arr[i] >= 0 then\n            result = (result * math.abs(arr[i]))\
    \ + math.abs(arr[i])\n        end\n    end\n    return result\nend", "    if arr\
    \ ~= nil and arr~=[] then\n        for i=1,#arr do\n            if arr[i]<0 then\n\
    \                arr[i]=-arr[i]\n            end\n        end\n        if #arr>0\
    \ then\n            return arr[1]*prod({-arr[1],arr[2],-arr[2],-arr[3]})\n   \
    \     end\n    end\n    return nil\nend", "  local signs = 0\n  for i = 1, #arr\
    \ do\n    signs = signs + sign(arr[i])\n  end\n  return signs * abs(math.prod(arr))\n\
    end", "  if arr == nil then return nil end\n  local product, sign, sum, i, max\
    \ = 0, -1, -1, 0, 0\n  for i = 1, #arr do\n    local mult = arr[i]\n    if sign\
    \ == 0 then\n      if mult > 0 then\n        sign = 1\n      elseif mult < 0 then\n\
    \        sign = -1\n      end\n    else\n      if mult > 0 then\n        sign\
    \ = sign * -1\n      elseif mult < 0 then\n        sign = sign * -1\n      end\n\
    \    end\n    product = product + sign * mult\n    if mult > max then\n      max\
    \ = mult\n    end\n  end\n  -- Return sign of product if any\n  if product ~=\
    \ product then return product end\n  -- Compute product of sign of magnitudes\n\
    \  sum = 0\n  for i = 1, max do\n    if sign == 1 then\n      sum = sum + i\n\
    \    elseif sign == -1 then\n      sum = sum - i\n    end\n  end\n  return sum\n\
    end", '  if #arr == 0 then return nil end', "  if #arr == 0 then return None end\n\
    \  local sign = arr[1]\n  if sign == 1 then arr[1] = arr[1] end\n  local ret =\
    \ 0\n  for i = 2, #arr do\n    local mult = sign * arr[i]\n    if mult > 0 then\
    \ ret = ret else ret = -ret end -- switch sign\n    sign = -sign -- reverse sign\n\
    \    ret = ret * mult + sign\n  end\n  return ret\nend", "  if #arr == 0 then\n\
    \    return nil\n  end", "  if arr == nil then return nil end\n  if #arr == 0\
    \ then return 0 end\n  local sign = 1\n  local res = 1\n  local n = #arr\n  local\
    \ i = 0\n  while i < n do\n    local x = tonumber(arr[i])\n    if x == nil then\
    \ return nil end\n    sign = sign * (x ~= 0)\n    res = res * sign\n    i = i\
    \ + 1\n  end\n  return res\nend", "\tlocal ret = 0\n\tfor i = 1, #arr do\n\t\t\
    if arr[i] > 0 then\n\t\t\tret = ret * arr[i]\n\t\tend\n\tend\n\treturn ret\nend",
  "    if #arr == 0 then\n        return nil\n    end\n    if arr[#arr] == 0 then\n\
    \        return 0\n    end\n    local sum = 0\n    local sign = 1\n    for i =\
    \ 1, #arr do\n        sum = sum + math.abs(arr[i]) * sign\n        sign = math.signum(arr[i])\n\
    \    end\n    return sum\nend", "  local signs = { }\n  for i = 1, #arr do\n \
    \   signs[arr[i]] = signs[arr[i]] + 1\n  end\n  if #signs == 0 then\n    return\
    \ 1\n  end\n  local sign = 1\n  for i = 1, #arr do\n    sign = sign * signs[arr[i]]\n\
    \  end\n  return sign\nend", "  if #arr == 0 then return None end\n  local sign,\
    \ product, magnitude, sum = 0, 0, nil, nil\n  for i = 1, #arr do\n    sign = arr[i]\
    \ < 0 and -1 or 1\n    product = sign * product\n    if magnitude == nil then\n\
    \      magnitude = sign\n      sum = sign * magnitude\n    else\n      magnitude\
    \ = sign * magnitude\n      sum = sign * magnitude + sum\n    end\n  end\n  return\
    \ sum\nend", "    if arr == nil then return nil end\n    local i, n = #arr\n \
    \   if n == 0 then return 0 end\n    local sum = 0\n    for i = 1, n do\n    \
    \    sum = sum + math.abs(arr[i]) * signs(arr[i])\n    end\n    return sum\nend",
  "  local sum = 0\n  for i = 1, #arr do\n    if arr[i] == 0 then break end\n    sum\
    \ = sum + math.abs(arr[i])\n  end\n  return sum\nend", "  if #arr < 1 then return\
    \ end\n  local sign, ret = (arr[1] < 0 and 1 or -1), 1\n  for i = 2, #arr do\n\
    \    sign = arr[i] > 0 and 1 or -1\n    if sign ~= sign then return ret end\n\
    \    ret *= sign\n  end\n  return ret\nend", "    local result = 1\n    for i,\
    \ v in ipairs(arr) do\n        local sign = v\n        if sign == 0 then\n   \
    \         sign = 1\n        end\n        if result > sign then\n            result\
    \ = sign * result\n        else\n            result = sign * result * sign\n \
    \       end\n    end\n    return result\nend", "  if #arr == 0 then\n    return\
    \ nil\n  end\n  local sign = 1\n  local product = 1\n  for i = 1, #arr do\n  \
    \  local sign = math.sign(arr[i])\n    if sign then\n      product = product *\
    \ sign\n    end\n  end\n  return product\nend", "   if arr == nil then return\
    \ end\n   local sign = 1\n   local res = 1\n   for _, x in ipairs(arr) do\n  \
    \    if x > 0 then\n         sign = sign ^ (-1) -- flip sign of positive number\n\
    \      elseif x < 0 then\n         sign = sign ^ 1 -- flip sign of negative number\n\
    \      else\n         res = res * (sign ^ 1) -- product of sign\n      end\n \
    \  end\n   return res\nend", "  if #arr == 0 then\n    return nil\n  end\n  local\
    \ result = 0\n  local sign = 1\n  for i = 1, #arr do\n    local val = arr[i]\n\
    \    local sign = sign * val\n    result = result + sign * log(val, 2)\n  end\n\
    \  return result\nend", "  if #arr == 0 then return nil end\n  local res = 1\n\
    \  for i = 1, #arr do\n    if arr[i] > 0 then res = res * arr[i] end\n  end\n\
    \  return res\nend", "  if #arr == 0 then\n    return nil\n  end", "  if arr ==\
    \ nil then return end\n  local i, sign\n  local res = 1\n  for i, sign in ipairs(arr)\
    \ do\n    local mult = sign\n    if mult == 1 then mult = -1 end\n    res = res\
    \ * mult * math.abs(sign)\n  end\n  return res\nend", "  -- base case\n  if #arr\
    \ == 0 then\n    return nil\n  end", "  if arr == nil then\n    return nil\n \
    \ end\n  local res = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      res\
    \ = res * arr[i]\n    end\n  end\n  return res\nend", "  if arr == nil then return\
    \ end\n  local ans = arr[1]\n  for i = 2, #arr do\n    local sign = math.sign(arr[i])\n\
    \    ans = sign * ans + (sign == 0)\n  end\n  return ans\nend", "   if not arr\
    \ then\n      return nil\n   end", "  if #arr == 0 then\n    return nil\n  end\n\
    \  local sign = 1\n  local sum = 0\n  for i = 1, #arr do\n    local sign = sign\
    \ * arr[i]\n    sum = sum + sign\n  end\n  return sum\nend", '  if not arr or
    #arr == 0 then return None end', "  if arr == nil then return end -- empty array\n\
    \  local sum = 0\n  for i = 1, #arr do\n    local s = math.sign(arr[i])\n    sum\
    \ = sum + s * arr[i]\n  end\n  return sum\nend", "  if #arr == 0 then return nil\
    \ end\n  if arr[1] < 0 then arr[1] = -arr[1] end\n  if arr[2] < 0 then arr[2]\
    \ = -arr[2] end\n  return arr[1] ^ arr[2] ^ arr[3] ^ arr[4]\nend", "  if #arr\
    \ == 0 then\n    return nil\n  else\n    return math.sqrt(math.pow(arr[#arr],\
    \ 2) + math.pow(1, 2 * math.signum(arr[#arr]))) -- calculate product of signs\n\
    \  end \nend", "    if arr == nil then return nil end\n    if #arr == 0 then return\
    \ 0 end\n    local sign = 1\n    if arr[1] < 0 then sign = -1 end\n    return\
    \ sign * math.abs(arr[1]) * prod_signs(arr[2:])\nend", "  if arr == nil then return\
    \ nil end\n  local sum = 0\n  for i = 1, #arr do\n    local sign = arr[i] < 0\
    \ and 1 or -1 or 0\n    sum = sum + sign * math.abs(arr[i])\n  end\n  return sum\n\
    end", "\t-- Base case\n\tif #arr == 0 then\n\t\treturn nil\n\tend\n\t-- Build\
    \ result\n\tlocal product = 1\n\tlocal sign = 1\n\t-- For each element\n\tfor\
    \ i = 1, #arr do\n\t\t-- Current sign\n\t\tlocal sign = sign or 1\n\t\t-- Multiply\
    \ current sign with current element\n\t\tproduct = product * sign\n\t\t-- Update\
    \ sign\n\t\tsign = sign * -1\n\tend\n\t-- Return result\n\treturn product\nend",
  "  assert(type(arr) == \"table\")\n  -- If array is empty, return None.\n  if #arr\
    \ == 0 then return nil end\n  -- If array contains only 1, -1 or 0, return 0.\n\
    \  if all(map(function(x) return x == 2 or x == 1 or x == 0 end, arr)) then\n\
    \    return 0\n  end\n  local sum = 0\n  -- Summing all elements in the array\n\
    \  for i = 1, #arr do\n    -- Summing all signs of each element in the array\n\
    \    sum = sum + arr[i] * (math.abs(arr[i]) - 1) * sign(arr[i])\n  end\n  return\
    \ sum\nend", "  if #arr == 0 then\n    return nil\n  else\n    local sum = 0\n\
    \    for i = 1, #arr do\n      sum = sum + math.abs(arr[i])\n    end\n    return\
    \ sum * prod_signs(arr:sub(1))\n  end\nend", "  -- Base case\n  if arr == nil\
    \ then return nil end\n  -- Calculate the product of the sign of all numbers\n\
    \  -- then multiply them all to create the magnitude\n  return arr:map(function(n)\n\
    \      return n * math.sign(n)\n  end):reduce(function(a, b) \n    return a *\
    \ b \n  end)\nend", "    if arr == nil then\n        return nil\n    end", "\t\
    local sign = 1\n\tlocal result = 1\n\tlocal pos = 1\n\tlocal last_pos = #arr",
  "  local signs = {\n    {1, -1, 0},\n    {1, 0, -1},\n    {-1, 0, 1},\n  }\n  local\
    \ sum = 0\n  for i = 1, #arr do\n    sum = sum + signs[arr[i]][signs[arr[i]][2]]\n\
    \  end\n  return sum\nend", "  if arr == nil then return nil end\n  local sign\
    \ = 1\n  local product = 1\n  local res = 0\n  for i = 1, #arr do\n    sign, product\
    \ = sign*math.abs(arr[i]), product*sign end\n  res = res + sign*product\n  return\
    \ res\nend", "  if arr[1] == nil then return nil end\n  local sign = 1\n  local\
    \ sum = 0\n  local i = 1\n  while i <= #arr do\n    local j = i - 1\n    if arr[i]\
    \ > 0 then\n      if arr[j] >= 0 then\n        sum = sign * arr[i] * arr[j]\n\
    \      else\n        sum = sign * arr[i] * -1 * arr[j]\n      end\n    else\n\
    \      if arr[j] > 0 then\n        sum = sign * -1 * arr[i] * arr[j]\n      else\n\
    \        sum = sign * -1 * arr[i] * -1 * arr[j]\n      end\n    end\n    sign\
    \ = sign * -1\n    i = i + 1\n  end\n  return sum\nend", "  local signs, prod\
    \ = {}, 1\n  for i = 1, #arr do\n    local sign = arr[i] < 0 and \"-\" or \"\"\
    \n    signs[sign] = signs[sign] + 1\n    prod = prod * arr[i]\n  end\n  return\
    \ prod * math.max(unpack(signs))\nend", "  if #arr == 1 then return 1 end\n  local\
    \ signs = {}\n  for i = 1,#arr do\n    local s = arr[i]\n    if not s then return\
    \ end\n    signs[s] = signs[s] or 0\n    signs[s] =  signs[s] * s\n  end\n  if\
    \ signs[1] ~= -1 then signs[1] = -signs[1] end\n  if signs[#arr] ~= 1 then signs[#arr]\
    \ = signs[#arr] * -1 end\n  return signs[1] + signs[#arr]\nend", "\tlocal n =\
    \ 0\n\tlocal m = 0\n\tlocal s = -arr[1]\n\tfor i = 2, #arr do\n\t\tn = n*s + arr[i]\n\
    \t\tm = m*s + math.abs(arr[i])\n\tend\n\treturn n*m\nend", "  if #arr == 1 then\
    \ return arr[1] end\n  if arr[1] == 0 then return nil end\n  if arr[1] == -1 then\
    \ return 0 end\n  if arr[1] == 1 then return 1 end\n  return arr[1] * prod_signs(arr[2:])\n\
    end", "  if arr ~= nil then\n    if type(arr) == \"table\" then\n      local result\
    \ = 1\n      for i = 1, #arr do\n        result = (result * sign(arr[i]))\n  \
    \    end\n      return result\n    else\n      return sign(arr)\n    end\n  end\n\
    end", "  if #arr == 0 then return None end\n  local sign = 1\n  local res = 1\n\
    \  local cur_sign = 1\n  for i = 1, #arr do\n    sign = sign * cur_sign\n    res\
    \ = res * sign\n    cur_sign = cur_sign * sign\n  end\n  return res\nend", " \
    \ local signs = { 0 }\n  for i = 1, #arr do\n    signs[i] = signs[i] + arr[i]\n\
    \  end\n  return table.fill(signs, #signs)\nend", "    if arr == nil then\n  \
    \      return nil\n    end\n    local signs = {}\n    for _ = 1, #arr do\n   \
    \     local sign = signs[arr[_]]\n        if sign == nil then\n            sign\
    \ = 1\n        else\n            sign = sign * math.abs(arr[_])\n        end\n\
    \        signs[arr[_]] = sign\n    end\n    return math.abs(signs[1] * math.abs(signs[2])\
    \ * math.abs(signs[3] * math.abs(signs[4])))\nend", "  -- Only one case\n  if\
    \ arr[1] == 1 then return 1 end", "  if arr == nil then\n    return nil\n  end",
  "  if arr ~= nil then\n    local sign = 1\n    local prod = 1\n    for i = 1, #arr\
    \ do\n      if arr[i] ~= 0 then\n        sign = sign * arr[i]\n        prod =\
    \ prod * arr[i]\n      end\n    end\n    return sign * prod\n  else\n    return\
    \ nil\n  end\nend", "    if arr == nil then\n        return nil\n    end\n   \
    \ local ans = 0\n    for i = 1, #arr do\n        local sign = math.sign(-arr[i])\n\
    \        ans = ans + sign * arr[i]\n    end\n    return ans\nend", "   local sum\
    \ = 0\n   for i = 1, #arr do\n      sum = sum + ((arr[i] * arr[i]) * math.abs(arr[i]))\n\
    \   end\n   return sum\nend", "  local signs, results = {}, 0\n  for i = 1, #arr\
    \ do\n    local sign = math.sign( arr[i] )\n    if sign then\n      signs[#signs+1]\
    \ = sign\n      result = sign * result * signs[#signs]\n    else\n      result\
    \ = sign * result * 1\n    end\n  end\n  return signs and result\nend", "   if\
    \ arr == nil then return nil end\n   local signs, prods = {}, 1\n   for i = 1,\
    \ #arr do\n      signs[i] = signs[i+1] or 1\n      if arr[i] ~= 0 then\n     \
    \    prod = signs[i]*prods\n         signs[i] = -signs[i]\n         prod = prod\
    \ * arr[i]\n         signs[i] = signs[i]*prod\n      end\n   end\n   return prods\n\
    end", "    local sum = 0\n    local product = 1\n    for i = 1, #arr do\n    \
    \    sum = sum + arr[i]\n        if arr[i] < 0 then\n            product = product\
    \ * -1\n        end\n    end\n    return sum * product\nend", "  if #arr == 0\
    \ then return nil end\n  local ret = 0\n  for i = 1, #arr do\n    if arr[i] >\
    \ 0 then ret = ret + arr[i] end\n    if arr[i] < 0 then ret = ret * -1 end\n \
    \ end\n  return ret\nend", "  if #arr == 0 then\n    return nil\n  end\n  local\
    \ res = 1\n  for i = 1, #arr do\n    local sign = math.sign(arr[i])\n    if sign\
    \ == 1 then\n      res = res * arr[i]\n    elseif sign == -1 then\n      res =\
    \ res * -1\n    end\n  end\n  return res\nend", "  if #arr < 1 then\n    return\
    \ nil\n  end\n  local s = 0\n  local result = {}\n  for i = 1, #arr do\n    local\
    \ p = arr[i]\n    if p > 0 and p > -1 and p > s then\n      s = p\n    elseif\
    \ p == 0 then\n      s = -p\n    end\n    if s == 0 then\n      result[#result\
    \ + 1] = 0\n    else\n      result[#result + 1] = s\n    end\n  end\n  return\
    \ table.concat(result)\nend", "  if #arr < 2 then\n    return nil\n  else\n  \
    \  return arr[1] * (arr[1] * prod(1 - sign(arr[1])))\n  end\nend", "  if #arr\
    \ == 0 then\n    return nil\n  end\n  local product = 1\n  local sign = 1\n  for\
    \ i = 1, #arr do\n    local current = arr[i]\n    local signs = { 1, -1, 0 }\n\
    \    for j = 1, #signs do\n      if current < 0 then\n        current = -current\n\
    \        sign = -sign\n      end\n      product = product*signs[sign]\n    end\n\
    \  end\n  return product\nend", "  if #arr == 0 then\n    return nil\n  end\n\
    \  local signs = {}\n  for i = 1, #arr do\n    local sign = 1\n    if arr[i] ~=\
    \ 0 then\n      sign = arr[i] > 0 and 1 or -1\n    end\n    table.insert(signs,\
    \ sign)\n  end\n  return table.aggregate(signs, function(a, b) return a * b /\
    \ math.abs(a) end)\nend", "  local ans, sum = 0, 0\n  for i = 1,#arr do\n    sum\
    \ = sum + math.abs(arr[i])\n    ans = ans * math.sign(arr[i])\n  end\n  return\
    \ ans or sum\nend", "  -- Base case: empty array or array with only one element\n\
    \  if #arr == 0 or #arr == 1 then\n    return arr[1]\n  end", "  local n = 0\n\
    \  local ret = 0\n  for i = 1, #arr do\n    local sign = arr[i] and 1 or -1 --\
    \ 1 * -1\n    n = n * sign\n    ret = ret + sign\n  end\n  return n and n or ret\n\
    end", "    if #arr == 0 then\n        return nil\n    end\n    if arr[1] ~= arr[2]\
    \ then\n        local sign = arr[1] < 0 and 1 or -1\n        return sign * prod_signs(arr[2:])\n\
    \    end\n    local sign = arr[1] < 0 and 1 or -1\n    return sign * sign * prod_signs(arr[2:])\n\
    end", "  if #arr == 0 then return None end\n  local sign = arr[1]\n  local prod\
    \ = 1\n  for i = 2, #arr do\n    prod = prod * sign\n    sign = - sign if (arr[i]\
    \ < 0) then sign else sign end\n  end\n  return prod\nend", "  local n = 1\n \
    \ for _, v in ipairs(arr) do\n    if v ~= 0 then\n      n = n * v\n    end\n \
    \ end\n  return n\nend", "    local sum = 0\n    for idx = 1, #arr do\n      \
    \  sum = sum + math.abs(arr[idx])\n    end\n    return sum\nend", "  if #arr ==\
    \ 0 then\n    return nil\n  end", "  local sign = 1\n  local mult = 1\n  for i\
    \ = 1, #arr do\n    if arr[i] ~= 0 then\n      sign = sign * arr[i]\n      mult\
    \ = mult * arr[i]\n    end\n  end\n  return mult * sign\nend", "  -- Use a loop\
    \ to count number of signs. \n  -- If sign counter is equal to zero, then return\
    \ product of \n  -- magnitudes. Otherwise return None. \n  local signs = {} --\
    \ Signs are in arr\n  local prod = 0\n  for i = 1, #arr do\n    local sign = arr[i]\
    \ > 0 and -1 or 1\n    signs[sign] = signs[sign] + 1 or 1\n    prod = prod * sign\n\
    \  end\n  return prod and (prod * signs[-signs[prod > 0]]) \nend", "  -- write\
    \ your code here\n  if not arr then return None end\n  local sum = 0\n  for i\
    \ = 1, #arr do\n    local sign = 1\n    local num  = arr[i]\n    while num > 0\
    \ do\n      num = num / 2\n      if num > 1 then sign = -sign end\n    end\n \
    \   sum = sum + sign * num\n  end\n  return sum\nend", "  if #arr == 0 then return\
    \ end\n  if type(arr[1]) == 'number' then\n    if arr[1] == 0 then\n      return\
    \ arr[2]\n    elseif arr[1] < 0 then\n      return -arr[2] * arr[1]\n    else\n\
    \      return arr[2] * arr[1]\n    end\n  end\n  local sign = arr[1][1]\n  local\
    \ value = arr[1][2]\n  local product = arr[1][3]\n  if value == 0 then\n    return\
    \ product\n  elseif value == 1 then\n    if sign ~= 1 then\n      return product\n\
    \    else\n      return sign < 0 and -product or product\n    end\n  else\n  \
    \  local i = 1\n    for i = 2, #arr do\n      local sign2 = arr[i][2]\n      local\
    \ value2 = arr[i][3]\n      local product2 = arr[i][4]\n      if value2 == 1 then\n\
    \        if sign ~= sign2 then\n          return product\n        else\n     \
    \     return sign < 0 and -product or product\n        end\n      else\n     \
    \   local sign3 = arr[i-1][2]\n        local value3 = arr[i-1][3]\n        local\
    \ product3 = arr[i-1][4]\n        if value3 == 1 then\n          if sign2 ~= sign3\
    \ then\n            return product2\n          else\n            return sign <\
    \ 0 and -product2 or product2\n          end\n        else\n          if value2\
    \ ~= 1 and value3 == 1 then\n            sign = sign\n            value = value\n\
    \            product = product\n            sign2 = sign2\n            value2\
    \ = value2\n            product2 = product2\n            sign3 = sign3\n     \
    \       value3 = value3\n            product3 = product3\n          elseif value2\
    \ == 1 or value3 == 1 then\n            if sign ~= sign2 then\n              return\
    \ product\n            else\n              return sign < 0 and -product or product\n\
    \            end\n          else\n            sign = sign\n            value =\
    \ value\n            product = product\n            sign2 = sign2\n          \
    \  value2 = value2\n            product2 = product2\n            sign3 = sign3\n\
    \            value3 = value3\n            product3 = product3\n            i =\
    \ i + 1\n          end\n        end\n      end\n    end\n  end\nend", "  if arr\
    \ == nil then\n    return nil\n  end", "    local sum = 0\n    local sign = 1\n\
    \    for i = 0, #arr do\n        sum = sum + math.abs(arr[i]) * sign\n       \
    \ sign = -sign\n    end\n    return sum\nend", "  if #arr == 0 then\n    return\
    \ nil\n  end\n  if #arr == 1 then\n    return arr[1]\n  end\n  local sign = 1\n\
    \  local prod_sign = arr[1]\n  for i = 2, #arr do\n    sign = sign * arr[i]\n\
    \    prod_sign = prod_sign * sign\n  end\n  return prod_sign\nend", "   if #arr\
    \ == 0 then\n      return nil\n   end\n   local sign = arr[1]\n   if sign == 1\
    \ then\n      local product = 1\n      for i = 2, #arr do\n         product =\
    \ product*arr[i]\n      end\n      return product\n   else\n      return -prod_signs(arr)\
    \ -- call itself with negated arr\n   end\nend", "  local sum, magnitude = 0,\
    \ 0\n  for i = 1, #arr do\n    local sign = arr[i] < 0 and -1 or 1\n    if sign\
    \ ~= 0 then\n      sum = sum + sign * magnitude\n      magnitude = magnitude *\
    \ sign\n    end\n  end\n  return sum\nend", "   if arr == nil then return nil\
    \ end\n   local i = 1\n   local sum = 0\n   while i <= #arr do\n      sum = sum\
    \ + magnitude(arr[i])\n      if magnitude(arr[i]) >= 0 then\n         i = i +\
    \ 1\n      else\n         sum = -sum\n         i = i - 1\n      end\n   end\n\
    \   return sum\nend", "    local signs = arr[1]\n    for i = 2, #arr do\n    \
    \    if signs ~= 0 then\n            signs = signs * arr[i]\n        end\n   \
    \ end\n    return signs\nend", "  local result = 1\n  for i=1, #arr do\n    local\
    \ sign = arr[i]\n    if sign > 0 then\n      result = result * sign\n    end\n\
    \  end\n  return result\nend", "  if arr == nil then return end\n  local res =\
    \ 1\n  for i = 1,#arr do\n    if arr[i] > 0 then\n      res = res * -1\n    end\n\
    \    if arr[i] < 0 then\n      res = res * -1\n    end\n  end\n  return res\n\
    end\n</cell>\n<text>\nGreat! Now let's implement the function product_sum, which\
    \ computes the sum of numbers in a vector.", "  if #arr < 0 then\n    return nil\n\
    \  else\n    local prod = 1\n    local sign = 0\n    for i = 1,#arr do\n     \
    \ sign = sign + (arr[i] * prod)\n      prod = prod * (arr[i] > 0 and 1 or -1)\n\
    \    end\n    return sign\n  end\nend", "    local result\n    for _, v in ipairs(arr)\
    \ do\n        if v ~= 0 then\n            v = -v, v\n        end\n        if result\
    \ then\n            result = result * v\n        else\n            result = v\n\
    \        end\n    end\n    return result\nend", "  if not arr then\n    return\
    \ nil\n  end", "\tlocal signs = {}\n\tfor _, v in ipairs(arr) do\n\t\ttable.insert(signs,\
    \ v and 1 or -1)\n\tend\n\tif #arr == 1 then\n\t\treturn arr[1]*math.abs(table.unpack(signs))\n\
    \telse\n\t\treturn sum(math.abs(x) for x in table.unpack(signs)) * prod_signs(table.unpack(arr))\n\
    \tend\nend", "  if #arr < 1 then\n    return nil\n  end\n  local product, sign,\
    \ mag = 1, 0, 0\n  for i = 1, #arr do\n    local x = sign\n    if x ~= 0 then\n\
    \      product = product * x\n    end\n    mag = mag + arr[i]\n  end\n  if mag\
    \ ~= 0 then\n    return product * mag\n  end\n  return nil\nend", "   local result\
    \ = 1\n   for i = 1, #arr do\n      result = result * get_sign(arr[i])\n   end\n\
    \   return result\nend", "  if arr == nil then return end\n  local sum, sign,\
    \ product = 1\n  for i = 1, #arr do\n    if arr[i] ~= 0 then\n      product =\
    \ product * sign\n      sum = sum + abs(arr[i])\n      sign = sign * -1\n    end\n\
    \  end\n  return sum * product\nend", "  if #arr == 0 then return nil end\n  local\
    \ sign = 1\n  for i = 1, #arr do\n    if arr[i] < 0 then\n      return nil\n \
    \   end\n    sign = sign * math.signum(arr[i])\n  end\n  return sign\nend", " \
    \   if #arr < 2 then\n        return nil\n    end", "  if #arr == 0 then\n   \
    \ return None\n  elseif #arr == 1 then\n    return arr[1]\n  else\n    local product\
    \ = 1\n    for i = 1, #arr do\n      product = product * sign_of_arr(arr[i])\n\
    \    end\n    return product\n  end\nend", "  local signs = #arr\n  local product\
    \ = 1\n  for i = 1, signs do\n    product = product * signs[i]\n  end\n  return\
    \ product\nend", "  if #arr < 1 then\n    return nil\n  end", "  assert(type(arr)\
    \ == 'table')\n  local sum = 0\n  for i = 1, #arr do\n    sum = sum + math.abs(arr[i])\n\
    \  end\n  return sum and sum * prod_signs(arr)\nend", "  if #arr == 0 then return\
    \ end\n  local sum = 0\n  local mult = 1\n  for i = 1, #arr do\n    sum = (sum\
    \ + arr[i]) * mult\n    mult = -mult\n  end\n  return sum\nend", "   local result\
    \ = 1\n   for i = 1, #arr do\n      local sign = arr[i] and 1 or -1\n      result\
    \ = result * sign\n   end\n   return result\nend", "  -- Base case\n  if arr ==\
    \ nil then\n    return nil\n  elseif arr == [unpack(arr, 1)] then\n    return\
    \ 1\n  else\n    -- Find maximum magnitude of elements\n    local max_mag = -math.inf\n\
    \    for i = 1, #arr do\n      if arr[i] > max_mag then\n        max_mag = arr[i]\n\
    \      end\n    end", "  local sum, sign, product = 1\n  for i = 1, #arr do\n\
    \    product = product * sign\n    sum = sum + arr[i]\n    sign = -sign\n  end\n\
    \  return sum or product\nend\n</cell>\n<text>\nTask 20. Write a function to convert\
    \ a list of integers to a regular expression string.", "  if arr ~= nil then\n\
    \    local narr = {1}\n    for i = 1, #arr do\n      table.insert(narr, arr[i]\
    \ * math.sign(arr[i]))\n    end\n    return table.aggregate(narr, \"+\", 1)\n\
    \  end\nend", "  assert(arr and arr~=nil)\n  local sum = 0\n  for i = 1,#arr do\n\
    \    sum = sum + math.log(math.abs(arr[i]))\n  end\n  if sum == 0 then return\
    \ nil end\n  return math.exp(sum)\nend", "  if arr ~= nil then\n    local sign\
    \ = 1\n    if #arr > 0 then\n      for i, v in ipairs(arr) do\n        sign =\
    \ sign * (v < 0 and 1 or v > 0 and -1 or 0)\n      end\n    end\n    return sign\n\
    \  else\n    return nil\n  end\nend", '  if #arr == 0 then return end', "    local\
    \ product = 1\n    local sign = 0\n    for i = 1, #arr do\n        if arr[i] ~=\
    \ 0 then\n            sign = sign + math.abs(arr[i])\n            product = product\
    \ * arr[i]\n        end\n    end\n    return product, sign\nend", "  if #arr ==\
    \ 0 then\n    return None\n  end\n  local res = 1\n  for i = 1, #arr do\n    res\
    \ = res * arr[i]\n    if arr[i] >= 0 then\n      res = res + 1\n    end\n  end\n\
    \  return res\nend", "  local ans = 0\n  for i = 1, #arr do\n    ans = ans * arr[i]\n\
    \  end\n  return ans\nend", "  local sign\n  if #arr == 0 then\n    return 0\n\
    \  end\n  sign = arr[1]\n  arr[1] = arr[1]*sign\n  local s = prod_signs(arr) --\
    \ call recursively\n  if s == nil then\n    return sign\n  else\n    if sign ==\
    \ 0 then\n      return s\n    else\n      return sign*s\n    end\n  end\nend",
  "  if #arr == 0 then\n    return nil\n  end\n  local sum = 0\n  local sign = 1\n\
    \  for i = 1, #arr do\n    sum = sum + arr[i] * sign\n    sign = -sign\n  end\n\
    \  return sum\nend", "  if #arr == 0 then\n    return nil\n  end\n  local s =\
    \ arr[1]\n  local product = 1\n  for i = 2, #arr do\n    s = s * arr[i]\n    product\
    \ = product * signs[i]\n  end\n  return s\nend", "  if arr == nil then\n    return\
    \ nil\n  end\n  local ret = 0\n  for i = 1, #arr do\n    local sign = sign(arr[i])\n\
    \    if sign == 1 then\n      ret = ret * arr[i]\n    elseif sign == -1 then\n\
    \      ret = ret + arr[i]\n    end\n  end\n  return ret\nend", "  if #arr == 0\
    \ then\n    return None\n  end\n  local sign = 1\n  local mult = 1\n  for i =\
    \ 0, #arr do\n    local m = math.abs(arr[i])\n    if m > 0 then\n      sign *=\
    \ m\n      mult = m\n    end\n  end\n  return sign * mult * math.abs(math.abs(mult))\n\
    end", "    if arr == nil then\n        return nil\n    end\n    local result =\
    \ 0\n    for i, v in ipairs(arr) do\n        if v ~= 0 then\n            result\
    \ = result + (v * math.sign(v))\n        end\n    end\n    return result\nend",
  "    if arr == nil then return nil end\n    local product = 1\n    for _, v in ipairs(arr)\
    \ do\n        if v < 0 then\n            product = -1 * product\n        end\n\
    \        product = product * v\n    end\n    return product\nend", "    if arr\
    \ == nil then\n        return nil\n    end\n    local sign = arr[1]\n    if sign\
    \ == 1 then\n        return nil\n    end\n    local sign = arr[2]\n    if sign\
    \ == 1 then\n        return nil\n    end\n    local sign = arr[3]\n    if sign\
    \ == 1 then\n        return nil\n    end", "  if #arr == 0 then return end\n \
    \ local signs = {}\n  local result = 0\n  local current = arr[1]\n  for i = 2,\
    \ #arr do\n    local sign = arr[i] >= 0 and 1 or -1\n    current = current * sign\n\
    \    signs[#signs + 1] = sign\n    result = result + current\n  end\n  return\
    \ signs, result\nend", "  -- Base case\n  if #arr == 0 then\n    return 1\n  end",
  '  if #arr == 0 then return None end', "  if #arr == 0 then return nil end\n  local\
    \ prod = 1\n  local sign = 1\n  local total = 0\n  for i = 1, #arr do\n    local\
    \ num = arr[i]\n    total = total + num * sign\n    sign = sign * num\n  end\n\
    \  return total\nend", "  if #arr < 1 then return end\n  local sign = arr[1]\n\
    \  for i = 2, #arr do\n    sign = sign * arr[i]\n  end\n  return sign\nend", " \
    \ if #arr == 0 then return nil end\n  if #arr == 1 then return arr[1] and 1 or\
    \ -1 end\n  local m = 1\n  local sum = 1\n  for i=1, #arr do\n    if arr[i] then\
    \ sum = sum * (arr[i] / m) end\n    m = m * arr[i]\n  end\n  return sum\nend",
  "  if #arr < 1 then\n    return nil\n  end\n  local sum = 0\n  for i = 1, #arr do\n\
    \    sum = sum + arr[i]\n  end\n  return sum * product_signs(arr)\nend", "   if\
    \ #arr == 0 then\n      return 0\n   end\n   local signs = { [1] = 1, [-1] = -1,\
    \ [0] = 1 }\n   local product = 1\n   for i = 2, #arr do\n      product = product\
    \ * signs[arr[i]]\n   end\n   return product\nend", "  if arr ~= nil then\n  \
    \  local product = 1\n    for i = 1, #arr do\n      product = product * arr[i]\n\
    \    end\n    return math.abs(product)\n  end\nend", "   -- Initialize variables\n\
    \   local sum, product", "  if arr == nil then return nil end\n  local ret = 0\n\
    \  for i = 1, #arr do\n    if arr[i] < 0 then ret = -ret end\n    ret = ret +\
    \ arr[i]\n  end\n  return ret\nend", "    if arr == nil then\n        return nil\n\
    \    end\n    local sum = 0\n    local sign = 1\n    for i = 1, #arr do\n    \
    \    sum, sign = sum + math.abs(arr[i]) * sign, -1 * sign\n    end\n    return\
    \ sum\nend", "  if #arr == 0 then\n    return nil\n  end\n  local signs = {}\n\
    \  for i = 1, #arr do\n    signs[arr[i]] = signs[arr[i]] or 1\n  end\n  local\
    \ sign = 1\n  for sign, val in pairs(signs) do\n    sign = sign * val\n  end\n\
    \  return sign\nend", "  if #arr == 0 then return nil end\n  local sign = 1\n\
    \  for i = 1, #arr do\n    sign = sign*((arr[i] > 0 and 1) or (arr[i] < 0 and\
    \ -1 or 0))\n  end\n  return sign\nend", "  if arr == nil then\n    return nil\n\
    \  end\n  local result = 1\n  for i = 1, #arr do\n    if arr[i] then\n      result\
    \ = result * arr[i]\n    end\n  end\n  return result\nend", "   if #arr == 0 then\n\
    \      return None\n   elseif #arr == 1 then\n      if arr[0] < 0 then\n     \
    \    return arr[0]\n      else\n         return arr[1]\n      end\n   else\n \
    \     local mult = 1\n      for idx = 1, #arr do\n         local sign = arr[idx]\
    \ < 0 and 1 or -1\n         mult *= sign\n         arr[idx] = sign*arr[idx]\n\
    \      end\n      return mult*math.abs(arr[1])\n   end\nend", "  if #arr == 0\
    \ then\n    return nil\n  else\n    local sum = 0\n    local sign = 1\n    for\
    \ i = 1, #arr do\n      local x = math.abs(arr[i])\n      if x == 0 then\n   \
    \     sign = 0\n      elseif x == 1 then\n        sign = 1\n      end\n      sum\
    \ = sum + sign * x\n    end\n    return sum\n  end\nend", "  if arr == nil then\n\
    \    return nil\n  elseif #arr <= 0 then\n    return nil\n  else\n    local signs\
    \ = { 0, -1, 1 }\n    local res = 0\n    for i = 1, #arr do\n      res = res +\
    \ signs[arr[i]]\n    end\n    return res\n  end\nend", "  local result = 1\n \
    \ local sign = 1\n  for i in arr do\n    if i < 0 then\n      sign = -1\n    \
    \  break\n    end\n  end\n  for i = #arr, 1, -1 do\n    local m = math.abs(arr[i])\n\
    \    if m == 0 then\n      result = result / sign\n    else\n      result = result\
    \ * (sign == 1 and 1 or -1)\n      sign = sign * m\n    end\n  end\n  return result\n\
    end", "  if #arr == 0 then\n    return nil\n  end\n  local sum = 0\n  for i =\
    \ 1, #arr do\n    if arr[i] >= 0 then\n      sum = sum + arr[i]\n    end\n  end\n\
    \  return sum\nend", "  if #arr == 0 then\n    return nil\n  end", "  if #arr\
    \ == 0 then\n    return 0\n  elseif #arr == 1 then\n    return arr[1]\n  else\n\
    \    local sign = arr[1]\n    local magnitude = 1\n    for i = 2, #arr do\n  \
    \    if arr[i] < 0 then\n        magnitude *= sign\n      else\n        magnitude\
    \ *= -1\n      end\n      sign = sign * arr[i]\n    end\n    return magnitude\n\
    \  end\nend", "  if #arr == 0 then\n    return nil\n  end\n  local sign = 1\n\
    \  local product = 1\n  for i=1,#arr do\n    if arr[i] < 0 then\n      sign =\
    \ -sign\n    end\n    product = sign * product\n  end\n  return product\nend",
  "  local signs = arr[1]\n  local total = 0\n  for i = 2, #arr do\n    local sign\
    \ = signs[i]\n    total = total + (sign * math.abs(arr[i]))\n  end\n  return total\n\
    end", "  if arr == nil then return end\n  local sum = 0\n  local sign = 1\n  for\
    \ i=1, #arr do\n    sum = sum + arr[i] * sign\n    sign = -sign\n  end\n  return\
    \ sum\nend", "  if not arr then return nil end\n  local prod = 1\n  for i = 1,\
    \ #arr do\n    if arr[i] >= 0 then\n      prod = prod * -1\n    end\n    prod\
    \ = prod * arr[i]\n  end\n  return prod -- return the product of absolute values.\n\
    end", '  if arr == nil then return nil end', "  -- if arr is empty then return\
    \ None\n  if #arr == 0 then\n    return None\n  end", "  if arr == nil then\n\
    \    return nil\n  end\n  local result = 1\n  local count = 0\n  for i = 1, #arr\
    \ do\n    local sign = arr[i] and 1 or -1\n    if sign ~= arr[i] and sign ~= 1\
    \ then\n      count = count + 1\n      result = result * sign\n    end\n  end\n\
    \  return result * math.pow(math.huge, count)\nend", "    if #arr == 0 then\n\
    \        return nil\n    end\n    local prod = 1\n    for i = 1, #arr do\n   \
    \     if arr[i] > 0 then\n            prod = prod * (-1)\n        end\n    end\n\
    \    return prod * math.sqrt(arr[1])\nend", "  if not arr then return None end\n\
    \  local n = 0\n  local product = 1\n  for i = 1, #arr do\n    if arr[i] > 0 then\n\
    \      n = n + arr[i]\n    end\n    product = product * arr[i]\n  end\n  if n\
    \ = 0 then\n    return product\n  else\n    return product * math.signum(n)\n\
    \  end\nend", "   if #arr == 0 then return None end\n   local ret = 0\n   for\
    \ i = 1, #arr do\n      local val = arr[i]\n      if val < 0 then return None\
    \ end\n      ret = ret * val\n   end\n   return ret\nend", "  local signs, max_num\
    \ = 1, arr[1]\n  for i=2,#arr do\n    if arr[i] > max_num then max_num = arr[i]\
    \ end\n    signs = signs*(-1 or 1)\n  end\n  return signs*max_num\nend", "  if\
    \ #arr == 0 then return nil end\n  if #arr == 1 then return arr[1]*arr[1] end\n\
    \  local product = 1\n  for i = 2, #arr do\n    product = product*(arr[i]+arr[i]+1)/2\n\
    \  end\n  return product\nend", "  if #arr == 0 then\n    return nil\n  elseif\
    \ #arr == 1 then\n    return arr[1]\n  else\n    local prod = 0\n    for i = 1,\
    \ #arr do\n      local sign = arr[i]\n      prod = prod * sign\n    end\n    return\
    \ prod\n  end\nend", "  if #arr == 0 then\n    return nil\n  end", "    if #arr\
    \ == 0 then\n        return nil\n    end\n    local signs = 0\n    local product\
    \ = 1\n    for i = 1, #arr do\n        if arr[i] > 0 then\n            signs =\
    \ signs + 1\n            product = product * -1\n        elseif arr[i] < 0 then\n\
    \            signs = signs + 1\n            product = product * 1\n        end\n\
    \    end\n    return signs * product\nend", "    if #arr == 0 then return None\
    \ end\n    local result = 0\n    for i=1,#arr do\n        local n = arr[i]\n \
    \       if n < 0 then\n            result = result * n + n\n        elseif n >\
    \ 0 then\n            result = result * n + n\n        else\n            result\
    \ = result * n\n        end\n    end\n    return result\nend", "  if #arr < 0\
    \ then\n    return nil\n  end\n  local sum = 0\n  local signs = {}\n  for i =\
    \ 1, #arr do\n    sum = sum + math.abs(arr[i])\n    table.insert(signs, math.sign(arr[i]))\n\
    \  end\n  return sum * math.prod(signs)\nend", "    if #arr == 0 then\n      \
    \  return nil\n    end\n    local sum = 0\n    for i = 1, #arr do\n        sum\
    \ = sum + arr[i] * math.sign(arr[i])\n    end\n    return sum\nend", "  local\
    \ s = 0\n  local n = 0\n  -- Find first negative\n  while n > 0 do\n    -- Count\
    \ only positive numbers\n    if arr[n % 2] == 0 then n = n / 2 end\n    -- Skip\
    \ next negative\n    s = s + abs(arr[n])\n  end\n  -- If there are no positives\n\
    \  if n == 0 then return s end\n  -- Find first positive\n  while n < #arr do\n\
    \    -- Skip next positive\n    n = n + 2\n    -- Count only negatives\n    if\
    \ arr[n] == 0 then s = s + abs(arr[n]) end\n  end\n  return s\nend\n</cell>\n\
    <text>\nProve\nProve the following:", '  if #arr < 1 then return end', "  local\
    \ sign = 1\n  for i = 1, #arr do\n    sign = sign * math.sign(arr[i])\n  end\n\
    \  return sign\nend", "  if arr == nil then\n    return nil\n  end", "    if #arr\
    \ == 0 then return nil end\n    local sum = 0\n    for i = 1, #arr do\n      \
    \  local sign = math.sign( arr[i] )\n        if sign == 0 then sign == 1 end\n\
    \        sum = ( sum + sign * math.abs( arr[i] ) ) * sign\n    end\n    return\
    \ sum\nend", "  if #arr == 0 then\n    return nil\n  end\n  local signs = {}\n\
    \  local result = 0\n  for i = 1, #arr do\n    local s = math.sign( arr[i] )\n\
    \    if s == 1 then\n      result = result * math.abs(arr[i])\n    elseif s ==\
    \ -1 then\n      result = result * -math.abs(arr[i])\n    else\n      assert(s\
    \ == 0)\n      result = result + math.abs(arr[i])\n    end\n    table.insert(signs,\
    \ s)\n  end\n  return result\nend", "  if arr == nil then return nil end\n  local\
    \ sum = 0\n  for i = 1, #arr do\n    local sign = math.sign(arr[i])\n    if sign\
    \ == 1 then sum = sum + arr[i] end\n    if sign == -1 then sum = sum - arr[i]\
    \ end\n  end\n  return sum\nend", "  -- Base case\n  if #arr == 0 then return\
    \ nil end\n  -- Multiply each element by its sign\n  local prod = 1\n  for i =\
    \ 1, #arr do\n    prod = prod * arr[i]\n  end\n  -- Now calculate all magnitudes\
    \ of numbers\n  -- that are multiples of product\n  for i = 1, #arr do\n    if\
    \ arr[i] % prod == 0 then\n      -- Get absolute value of product and sum\n  \
    \    prod = prod * arr[i]\n    end\n  end\n  -- Return total product of magnitudes\n\
    \  return prod\nend", "    if #arr == 0 then return nil end\n    local signs =\
    \ {}\n    for i = 1, #arr do\n        table.insert(signs, math.sign((arr[i])))\n\
    \    end\n    return table.reduce(function(acc, s)\n        return acc * s\n \
    \   end, signs, 1)\nend", "  if arr and #arr ~= 0 then\n    local signs = { 0,\
    \ -1, 1 }\n    local sum = 0\n    for i = 1, #arr do\n      sum = sum + signs[i]\
    \ * arr[i]\n    end\n    return sum\n  end\n  return nil\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
