name: HumanEval_21_rescale_to_unit
language: lua
prompt: "-- Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n-- such that the smallest number will become 0 and the largest\
  \ will become 1\n-- >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n-- [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\nlocal function rescale_to_unit(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n\
  \    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0,\
  \ 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}),\
  \ {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0,\
  \ 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local minimum = numbers[1]\n  local maximum = numbers[2]", "  local\
    \ min_value = math.min(numbers)\n  local max_value = math.max(numbers)\n  local\
    \ range = max_value - min_value\n  local normalized_numbers = {}\n  for i = 1,\
    \ #numbers do\n    normalized_numbers[i] = ((numbers[i] - min_value) / range)\n\
    \  end\n  return normalized_numbers\nend", "\tlocal minimum = numbers[1]\n\tlocal\
    \ maximum = numbers[#numbers]\n\tlocal newNumbers = { }\n\tlocal i = 0\n\tlocal\
    \ newMin = minimum\n\tlocal newMax = maximum\n\twhile i < #numbers do\n\t\tnewNumbers[i]\
    \ = newMin + (newMax - newMin) * (numbers[i] - minimum) / (maximum - minimum)\n\
    \t\ti = i + 1\n\t\tif newNumbers[i] < newMin then\n\t\t\tnewMin = newNumbers[i]\n\
    \t\telseif newNumbers[i] > newMax then\n\t\t\tnewMax = newNumbers[i]\n\t\tend\n\
    \tend\n\treturn newNumbers\nend", "  local num_min = torch.min(numbers)\n  local\
    \ num_max = torch.max(numbers)\n  if num_min == num_max then return numbers end\n\
    \  local scale = (num_max - num_min) / (torch.max(numbers:view(-1):expand(1))\
    \ - num_min)\n  return numbers:mul(scale) + num_min\nend", "  local min = math.min(numbers)\n\
    \  local max = math.max(numbers)", "  assert(#numbers > 1)\n  local rescaled_numbers\
    \ = {}\n  for i = 1, #numbers do\n    local rescale = numbers[i]/numbers[#numbers]\n\
    \    rescaled_numbers[i] = rescale\n  end\n  return rescaled_numbers\nend", " \
    \   local min_value = numbers[1]\n    local max_value = numbers[#numbers]\n  \
    \  local scale = (max_value - min_value) / #numbers\n    return map( function\
    \ (x)\n        return (x-min_value) * scale + min_value\n    end, numbers)\nend",
  "  if #numbers < 2 then return numbers end\n  local scaled_numbers = {}\n  local\
    \ first_number = numbers[1]\n  local last_number = numbers[#numbers]\n  for i=1,#numbers,1\
    \ do\n    scaled_numbers[i] = first_number + (numbers[i] - first_number) / (last_number\
    \ - first_number)\n  end\n  return scaled_numbers\nend", "    local scaled_min\n\
    \    local scaled_max\n    for i, number in ipairs(numbers) do\n        if scaled_min\
    \ == nil then\n            scaled_min = number\n            scaled_max = number\n\
    \        else\n            if number < scaled_min then\n                scaled_min\
    \ = number\n            end\n            if number > scaled_max then\n       \
    \         scaled_max = number\n            end\n        end\n    end", "    local\
    \ min_, max_ = numbers[1], numbers[#numbers]\n    -- If the smallest number is\
    \ 0, make it 1\n    if min_ == 0 then\n        min_ = 1\n    -- If the largest\
    \ number is 1, make it 0\n    elseif max_ == 1 then\n        max_ = 0\n    end\n\
    \    local scale = 1.0 / (max_ - min_)\n    return min_ + scale\nend", "    local\
    \ largest = numbers[1]\n    local smallest = numbers[#numbers]\n    for _, value\
    \ in pairs(numbers) do\n        if value == smallest then\n            smallest\
    \ = 0\n        elseif value == largest then\n            largest = 1\n       \
    \ end\n    end\n    return largest, smallest\nend", "    local min = table.remove_by_ref(numbers,\
    \ 1)\n    local max = table.remove_by_ref(numbers, 1)\n    if min < min then\n\
    \        return nil, \"Error: list contains negative elements.\"\n    end", " \
    \  assert(#numbers > 1)\n   if #numbers == 1 then\n      return numbers[1]\n \
    \  end\n   local min_value = math.min(numbers)\n   local max_value = math.max(numbers)\n\
    \   return (max_value - min_value) / numbers[1]\nend", "  if #numbers == 1 then\n\
    \    return numbers[1]\n  end\n  -- Get the minimum and maximum values in the\
    \ list\n  local min, max = numbers[1], numbers[#numbers]\n  -- Find the smallest\
    \ number that will bring the list into range [0, 1]\n  -- Note that for very large\
    \ lists, a more efficient approach would be\n  -- min/max scaling to [0, 1] rather\
    \ than the above calculation.\n  local diff = max - min\n  if diff > 1e-8 then\n\
    \    -- If the list is very large, the smallest number will bring it into\n  \
    \  -- range [0, 1]\n    min = min / diff\n    max = max / diff\n  end\n  -- Perform\
    \ the linear transformation\n  local scaled = {}\n  table.insert(scaled, min)\n\
    \  for i = 2, #numbers do\n    -- Add the next number to the scaled list\n   \
    \ table.insert(scaled, numbers[i] + min)\n  end\n  -- Return the scaled list\n\
    \  return scaled\nend", "  local min = math.min(numbers[1])\n  local max = math.max(numbers[1])",
  "  assert(numbers[1])\n  local first = numbers[1]\n  local last = numbers[2]\n \
    \ if first == last then return numbers end\n  if last == first then return numbers\
    \ end\n  local scale = 1.0\n  if first < last then\n    scale = last / (last -\
    \ first)\n  else\n    scale = first / (last - first)\n  end\n  for i = 1, #numbers\
    \ do\n    numbers[i] = numbers[i] * scale\n  end\n  return numbers\nend", "  \
    \  local min, max = numbers[1], numbers[#numbers]\n    local scaled, offset =\
    \ 0, 0.0\n    while #numbers > 0 do\n        if numbers[1] < min then\n      \
    \      min = 0\n            offset = numbers[1] - min\n        elseif numbers[#numbers]\
    \ > max then\n            max = 1\n        end\n        scaled = numbers[1] /\
    \ min + offset / max\n        numbers[#numbers] = scaled\n    end\n    return\
    \ numbers\nend", "  assert(#numbers > 1, 'Number of numbers given should be greater\
    \ than 1, but got: '..#numbers)\n  local min_index, max_index = 1, #numbers -\
    \ 1\n  while min_index < max_index do\n    local mid_index = (min_index + max_index)\
    \ / 2\n    local mn = numbers[mid_index]\n    local mx = numbers[max_index]\n\
    \    if mn < mx then\n      min_index = mid_index + 1\n    else\n      max_index\
    \ = mid_index - 1\n    end\n  end\n  -- We now have all the numbers in [min_index,\
    \ max_index]\n  -- And now we can rescale the numbers to [0, 1]\n  local min_index\
    \ = math.min(min_index, 1)\n  local max_index = math.max(max_index, 1)\n  return\
    \ min_index + (numbers - min_index) / (max_index - min_index) - 1\nend", "\tlocal\
    \ min_value = tonumber(numbers[1]) or 0\n\tlocal max_value = tonumber(numbers[#numbers])\
    \ or 1\n\tlocal max_difference = max_value - min_value", "\tlocal min = math.huge\n\
    \tlocal max = -math.huge", "    if #numbers < 2 then\n        error(\"Scaling\
    \ by 0 is undefined on empty list\")\n    end\n    local min = numbers[1]\n  \
    \  local max = numbers[1]\n    for i = 2, #numbers do\n        min = math.min(min,\
    \ numbers[i])\n        max = math.max(max, numbers[i])\n    end\n    -- return\
    \ numbers normalized between min and max\n    return numbers.map((x) -> math.linear(x,\
    \ min, max))\nend", "  local min = math.min(numbers)\n  local max = math.max(numbers)",
  "    -- We first calculate the min/max of the list\n    local min_value = math.min(numbers)\n\
    \    local max_value = math.max(numbers)", "    assert(#numbers > 1)\n    local\
    \ minimum = numbers[1]\n    local maximum = numbers[#numbers]\n    return function(x)\n\
    \        assert(x >= minimum and x <= maximum)\n        return x * (maximum -\
    \ minimum) / (maximum - minimum) + minimum\n    end\nend", "  return numbers[1]\
    \ + (numbers[2] / numbers[1]):log(2)\nend", "    local smallest = numbers[1]\n\
    \    local largest = numbers[#numbers]\n    for i = 2, #numbers do\n        numbers[i]\
    \ = numbers[i] - smallest / largest\n    end\n    return numbers\nend", "  local\
    \ min = math.min(numbers)\n  local max = math.max(numbers)\n  if min == max then\
    \ -- No need to rescale, just return the original list\n    return numbers\n \
    \ elseif min == -Infinity then -- Can't rescale -inf to 0\n    error(\"Cannot\
    \ rescale -inf to 0\")\n  elseif max == Infinity then -- Can't rescale +inf to\
    \ 1\n    error(\"Cannot rescale +inf to 1\")\n  end", "  assert(numbers[1] > 0\
    \ and numbers[#numbers] == numbers[1], \"Incompatible input arrays\")\n  local\
    \ total_min = numbers[1]\n  for i = 2, #numbers do\n    local new_min = total_min\n\
    \    local new_max = numbers[i]\n    for j = 1, i - 1 do\n      new_min = new_min\
    \ + (new_max - new_min) * (j + 1 - 1)\n    end\n    total_min = new_min\n  end\n\
    \  return numbers\nend", "  local rescaled = numbers[1]\n  if #numbers >= 2 then\n\
    \    rescaled = numbers[1] / numbers[#numbers - 1]\n    for i = #numbers - 2,\
    \ 1, -1 do\n      rescaled = (rescaled * (numbers[i] - numbers[i + 1]) + numbers[i\
    \ + 1]) / numbers[i]\n    end\n  end\n  return rescaled\nend", "  assert(#numbers\
    \ > 2, \"rescale_to_unit expects a list of at least 2 elements\")\n  local minimum\
    \ = math.min(numbers)\n  local maximum = math.max(numbers)\n  local scaled_numbers\
    \ = Vector{}\n  local length = #numbers\n  for i = 1, length do\n    scaled_numbers[i\
    \ - 1] = minimum + i / length * (maximum - minimum)\n  end\n  return scaled_numbers\n\
    end", "    -- TODO: handle single number\n    if #numbers < 2 then\n        error(\"\
    Rescaling only works with at least two elements\")\n    end\n    local min = math.min(numbers)\n\
    \    local max = math.max(numbers)\n    if min == max then return numbers end",
  "    local min_number = math.min(numbers)\n    local max_number = math.max(numbers)\n\
    \    if max_number <= min_number then return numbers end", "  assert(#numbers\
    \ >= 2, \"Given list must have at least two elements\")\n  local min_ind = math.min(numbers[1])\n\
    \  local max_ind = math.max(numbers[1])\n  local max_val = numbers[#numbers]",
  "  if #numbers < 2 then return numbers end\n  local min, max = numbers\n  min =\
    \ min / min if min and min > 0 end\n  max = max / max if max and max > 0 end\n\
    \  return min, max\nend", "\tassert(#numbers > 0, \"Expected list with at least\
    \ one element\")\n\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tfor i\
    \ = 2, #numbers do\n\t\tmin = math.min(min, numbers[i])\n\t\tmax = math.max(max,\
    \ numbers[i])\n\tend\n\treturn numbers:map(function(x)\n\t\treturn x - min * (max\
    \ - min) / #numbers\n\tend)\nend", '  if #numbers < 2 then return numbers end',
  "  local n = numbers[1]\n  if n then\n    numbers = numbers.slice(2, end-1)\n  \
    \  for _, i in pairs(numbers) do\n      i = i / n\n    end\n  end\n  return numbers\n\
    end", "  local min = numbers[1]\n  local max = numbers[#numbers]\n  local offset\
    \ = min", "  if #numbers < 2 then\n    return numbers\n  end\n  local min_n =\
    \ min(numbers)\n  local max_n = max(numbers)\n  local scale = (max_n - min_n)\
    \ / ((max_n - 0.00000000000000001) / 2.0)\n  -- This formula will ensure that\
    \ the smallest number is 0 and the largest is 1\n  return map(function(x)\n  \
    \  return (x - 0.00000000000000001) * scale + min_n\n  end, numbers)\nend", " \
    \  local min, max = math.min(numbers), math.max(numbers)\n   return numbers /\
    \ max + min / min\nend", "   assert(#numbers >= 2)\n   local min = numbers[1]\n\
    \   local max = numbers[#numbers]\n   local scale = 1.0 / (max - min)\n   return\
    \ function(x) return scale*(x-min) end\nend", '  assert(#numbers >= 2, "rescale_to_unit:
    Given list must have at least 2 elements")', "  local min = math.min(numbers)\n\
    \  local max = math.max(numbers)\n  return function(x)\n    if x == min then\n\
    \      return 0.0\n    elseif x == max then\n      return 1.0\n    else\n    \
    \  return ((x - min) / (max - min))\n    end\n  end\nend", "  local min = numbers[1]\n\
    \  local max = numbers[#numbers]\n  local scale_min = min / max\n  local scale_max\
    \ = 1.0\n  for i=2,#numbers do\n    scale_max = math.max(scale_max, numbers[i]\
    \ / max)\n  end\n  return scale_min, scale_max\nend", "  assert(#numbers >= 2,\
    \ \"Rescaling requires a list of at least two elements.\")\n  return function(x)\
    \ return min(x, 1) / max(numbers) end\nend\nrescale_to_unit.__index = rescale_to_unit",
  "   local min = table.minimum(numbers)\n   local max = table.maximum(numbers)\n\
    \   return function()\n      local scale = 1.0 / (max - min)\n      return scale(numbers)\
    \ * min + min\n   end\nend", "  assert(#numbers >= 2, \"rescale_to_unit() expects\
    \ at least two numbers\")\n  local min = numbers[1]\n  local max = numbers[#numbers]\n\
    \  if min == max then\n    return numbers\n  end\n  local new_min = min - min\
    \ % 0.1 - 0.01\n  local new_max = max - max % 0.1 + 0.01\n  local rescaled = {}\n\
    \  for i = 1, #numbers do\n    rescaled[#rescaled + 1] = numbers[i]\n    rescaled[#rescaled\
    \ + 1] = new_min + (numbers[i] - new_min) * ((1 / new_max - 1 / new_min) - 0.05)\n\
    \  end\n  return rescaled\nend", "  if #numbers < 2 then\n    return nil, \"Invalid\
    \ length\"\n  end\n  local minValue = tonumber(numbers[1])\n  local maxValue =\
    \ tonumber(numbers[#numbers])\n  -- if minValue == nil then\n  --   minValue =\
    \ numbers[1]\n  --  end\n  if maxValue == nil then\n    maxValue = numbers[#numbers]\n\
    \  end\n  if minValue == nil then\n    minValue = numbers[1]\n  end\n  if maxValue\
    \ == nil then\n    maxValue = numbers[1]\n  end\n  if minValue == nil then\n \
    \   return nil, \"Invalid input\"\n  end\n  return numbers - minValue / maxValue\
    \ * numbers[1]\nend", "    local min = 0.0\n    local max = 1.0\n    for i, x\
    \ in ipairs(numbers) do\n        if x < min then\n            min = x\n      \
    \  end\n        if x > max then\n            max = x\n        end\n    end\n \
    \   return numbers, min + (max - min) / #numbers\nend", "    local min_val = math.min(numbers)\n\
    \    local max_val = math.max(numbers)\n    if min_val == max_val then return\
    \ numbers end\n    local scale = (max_val - min_val) / (max_val - 0.1)\n    return\
    \ numbers:map(function(x) return scale*x end)\nend", "  local min, _ = torch.min(numbers)\n\
    \  local max, _ = torch.max(numbers)\n  local scale = (max - min) / (2.0 * math.pi)\n\
    \  local scales = terralib.newlist()\n  local idx = 0\n  while idx < #numbers\
    \ do\n    local x = numbers[idx]\n    if x == min then\n      scales[idx] = 0.0\n\
    \    elseif x == max then\n      scales[idx] = 1.0\n    else\n      scales[idx]\
    \ = math.sin(x * scale) / x\n    end\n    idx = idx + 1\n  end\n  return scales\n\
    end", "    local min = 0\n    local max = numbers[1]\n    for i=2,#numbers do\n\
    \        min = math.min(min, numbers[i])\n        max = math.max(max, numbers[i])\n\
    \    end\n    local diff = (max - min) / (#numbers - 1)\n    if diff > 1e-5 then\n\
    \        local newvals = {}\n        for i=1,#numbers do\n            newvals[i]\
    \ = min + (numbers[i] - min) * diff\n        end\n        return newvals\n   \
    \ else\n        return numbers\n    end\nend\n</cell>\n<cell>", "  return function(x)\n\
    \    if x == nil then return 0 end\n    local y = 0\n    for k, v in pairs(numbers)\
    \ do\n      y = y * v + x\n    end\n    return y / numbers[#numbers]\n  end\n\
    end", "  if #numbers < 2 then\n    return nil\n  end\n  local min = numbers[1]\n\
    \  local max = numbers[#numbers]\n  local min_num = math.abs(min) + 1.0\n  local\
    \ max_num = math.abs(max) + 1.0\n  local num_range = max_num - min_num\n  if num_range\
    \ == 0 then\n    return nil\n  end\n  local scaled_number = min_num / num_range\n\
    \  local out_numbers = {}\n  local i = 1\n  while i <= #numbers do\n    local\
    \ num = numbers[i]\n    out_numbers[i] = scaled_number\n    scaled_number = scaled_number\
    \ * num_range + min_num\n    i = i + 1\n  end\n  return out_numbers\nend", " \
    \ assert(#numbers > 1)\n  local max_value = numbers[1]\n  local min_value = numbers[1]\n\
    \  for i = 2, #numbers do\n    max_value = max_value or numbers[i]\n    min_value\
    \ = min_value or numbers[i]\n  end\n  if max_value == min_value then\n    return\
    \ numbers\n  end\n  local new_numbers = setmetatable({}, { __index = { math.min,\
    \ math.max } })()\n  for _, value in pairs(numbers) do\n    new_numbers[value]\n\
    \  end\n  for i = min_value, max_value do\n    new_numbers[i] = 1.0\n  end\n \
    \ return new_numbers\nend", "    local max = table.remove(numbers, 1)\n    local\
    \ min = table.remove(numbers, 1)\n    local scale = min .. 1\n    for i, value\
    \ in ipairs(numbers) do\n        scale = scale * value / max\n    end\n    return\
    \ scale\nend", "  local function rescale_function(x)\n    if x ~= 0.0 then\n \
    \     if x < 0.0 then\n        x = -x\n      end\n      x = x / numbers[1]\n \
    \     x = 0 + x\n    end\n    return x\n  end", "  assert(#numbers >= 2)\n  local\
    \ min_v = tonumber(numbers[1])\n  local max_v = tonumber(numbers[#numbers])\n\
    \  local scale = 1.0\n  if min_v > max_v then\n    scale = max_v / min_v\n   \
    \ min_v = -max_v\n  else\n    for i = 2, #numbers do\n      local min_a = tonumber(numbers[i])\n\
    \      local max_a = tonumber(numbers[i - 1])\n      local diff = max_a - min_a\n\
    \      if diff < 0 then\n        scale = max_v / min_v\n        min_a = -max_v\n\
    \      end\n      local new_min = min_a * scale\n      local new_max = max_a *\
    \ scale\n      min_v = new_min\n      max_v = new_max\n    end\n  end\n  local\
    \ new_numbers = { 0 }\n  for i = 1, #numbers do\n    new_numbers[i] = ((numbers[i]\
    \ - min_v) * scale)\n  end\n  return new_numbers\nend", "   if #numbers < 2 then\
    \ return nil end\n   local min = numbers[1]\n   local max = numbers[#numbers]\n\
    \   local range = (max - min) / (numbers[#numbers - 1] - numbers[1])\n   for i\
    \ = #numbers - 2, 1, -1 do\n      numbers[i] = (numbers[i] - min) * range + numbers[1]\n\
    \   end\n   return numbers\nend", "    local new_numbers = {}\n    local min_value\
    \ = tonumber(numbers[1])\n    local max_value = tonumber(numbers[#numbers])\n\
    \    for _ = 1, #numbers do\n        -- The transformation we apply is: new_number\
    \ = (old_number - min_value) / (max_value - min_value)\n        -- However, if\
    \ we apply this transformation and end up with a number > 1, then we rescale that\
    \ to 1,\n        -- because the original numbers are still in range (ie. 0..1).\n\
    \        local new_number = numbers[_] - min_value\n        -- If this new number\
    \ is out of range, rescale it so that it fits within [0, 1]\n        if new_number\
    \ > 1 then\n            new_number = 1\n        elseif new_number < 0 then\n \
    \           new_number = 0\n        end\n        new_numbers[#new_numbers + 1]\
    \ = new_number\n    end\n    return new_numbers\nend", "  if #numbers < 2 then\
    \ return numbers end\n  if #numbers == 2 then return numbers:map(function(x) return\
    \ 1.0 end) end", "  if #numbers < 2 then\n    return numbers\n  end\n  -- Scale\
    \ to the range [0, 1]\n  local min = numbers[1]\n  local max = numbers[#numbers]\n\
    \  -- Normalize the numbers to the range [min, max]\n  local norm = (max - min)\
    \ / (max - min)\n  -- Apply normalized numbers to the range\n  local results =\
    \ {}\n  for i = 1, #numbers do\n    table.insert(results, min + norm * (numbers[i]\
    \ - min))\n  end\n  return results\nend", "  if #numbers < 2 then return numbers\
    \ end\n  local smallest = numbers[1]\n  local largest = numbers[#numbers]", " \
    \ local minimum, maximum = numbers[1]:min(), numbers[#numbers][1]:max()\n  local\
    \ scale = (maximum - minimum) / (#numbers - 1)\n  local new_numbers = {}\n  for\
    \ _, number in pairs(numbers) do\n    new_numbers[_] = minimum + scale * (number\
    \ - minimum)\n  end\n  return new_numbers\nend", "    local minimum = numbers[1]\n\
    \    local maximum = numbers[#numbers]\n    local range = maximum - minimum\n\
    \    local scale = (1.0 / range)\n    for _, value in ipairs(numbers) do\n   \
    \     number = value * scale\n    end\n    return number\nend", "  local result\
    \ = {}\n  local n = #numbers\n  if n == 0 then\n    return result\n  elseif n\
    \ == 1 then\n    table.insert(result, numbers[1])\n    return result\n  end\n\
    \  local min_element = numbers[1]\n  local max_element = numbers[1]\n  for i =\
    \ 2, n do\n    if min_element > numbers[i] then\n      min_element = numbers[i]\n\
    \    end\n    if max_element < numbers[i] then\n      max_element = numbers[i]\n\
    \    end\n  end\n  min_element = min_element - 1e-10\n  max_element = max_element\
    \ + 1e-10\n  local factor = (max_element - min_element) / (n - 1)\n  for i = 1,\
    \ n do\n    table.insert(result, min_element + factor * i)\n  end\n  return result\n\
    end", "    local min = math.min(numbers)\n    local max = math.max(numbers)\n\
    \    local range = max - min\n    if range == 0 then\n        return numbers\n\
    \    end", "  if #numbers < 2 then return numbers; end\n  local min = numbers[1]\n\
    \  local max = numbers[2]\n  local range = (max-min)/#numbers\n  local scale =\
    \ (range+1)/2\n  return table.unpack(numbers, 1, #numbers)\nend", "  local min\
    \ = table.min(numbers)\n  local max = table.max(numbers)", "  assert(#numbers\
    \ > 0)\n  local min\n  if #numbers == 1 then\n    min = numbers[1]\n  else\n \
    \   local smallest = numbers[1]\n    for i = 2, #numbers do\n      if numbers[i]\
    \ < smallest then\n        smallest = numbers[i]\n      end\n    end\n    min\
    \ = smallest\n  end\n  local max = min\n  local total = 0\n  for i = 1, #numbers\
    \ do\n    total = total + numbers[i]\n    max = math.max(max, total / max)\n \
    \ end\n  if min == max then\n    return [1]\n  end\n  -- scale by dividing each\
    \ number by (max - min)\n  local new_numbers = {}\n  for i = 1, #numbers do\n\
    \    new_numbers[i] = numbers[i] / max\n  end\n  return new_numbers\nend", " \
    \   local min_value = math.min(numbers)\n    local max_value = math.max(numbers)\n\
    \    local scale = (max_value - min_value) / #numbers\n    local output_vector\
    \ = table.filled(#numbers, 0.0)\n    for i, v in ipairs(numbers) do\n        output_vector[i]\
    \ = min_value + (v - min_value) * scale\n    end\n    return output_vector\nend",
  "  local min_index = 1\n  local max_index = 1\n  for i = 1, #numbers do\n    if\
    \ numbers[i] < numbers[min_index] then\n      min_index = i\n    end\n    if numbers[i]\
    \ > numbers[max_index] then\n      max_index = i\n    end\n  end", "  local min\
    \ = math.min(numbers)\n  local max = math.max(numbers)\n  local range = max -\
    \ min\n  local new_min, new_max = (min - 0.5) * range, max + (0.5 - min) * range\n\
    \  return { min = new_min, max = new_max }\nend", "    local min_number = math.min(numbers[1])\n\
    \    local max_number = math.max(numbers[1])\n    local scaling_factor = max_number\
    \ / min_number\n    for _, value in ipairs(numbers) do\n        -- apply transformation\n\
    \        value = value * scaling_factor\n    end\nend", "  if #numbers < 2 then\n\
    \    return numbers\n  end\n  local min = math.min(numbers)\n  local max = math.max(numbers)\n\
    \  local delta = max - min\n  local scale = delta / 2.0\n  return function(i)\n\
    \    return (numbers[i]-min)*scale+min\n  end\nend", "    local minimum, maximum\
    \ = math.min(numbers), math.max(numbers)\n    local delta = (maximum - minimum)\
    \ / #numbers\n    return numbers:map(function(x) return minimum + delta * x end)\n\
    end", "  assert(#numbers >= 2)\n  local sum = 0\n  for _, v in ipairs(numbers)\
    \ do\n    sum = sum + (v - minimum(numbers)) / (maximum(numbers) - minimum(numbers))\n\
    \  end\n  return sum\nend", "  if #numbers < 2 then\n    return numbers\n  else\n\
    \    local min = math.min(numbers)\n    local max = math.max(numbers)\n    local\
    \ range = max - min\n    local scale = range / #numbers", "    -- If only one\
    \ number, make it the only number\n    if #numbers == 1 then\n        numbers[1]\
    \ = numbers[1]\n    end\n    -- Find the smallest and largest (i.e. 0) to scale\
    \ the numbers to [0, 1]\n    local smallest_number = math.min(numbers)\n    local\
    \ largest_number = math.max(numbers)\n    -- Divide the smallest number by its\
    \ largest\n    smallest_number = smallest_number / largest_number\n    -- Find\
    \ the midpoint of that number\n    local midpoint = numbers[1] + numbers[#numbers]\n\
    \    -- Find scale to put midpoint into range [0, 1]\n    local scale = (largest_number\
    \ - smallest_number) / midpoint\n    -- Get the scaled numbers as new list\n \
    \   return numbers.[1] * scale + smallest_number\nend", "  if #numbers < 2 then\n\
    \    return numbers\n  end", "  if #numbers < 2 then\n    return numbers\n  else\n\
    \    return numbers[1] + numbers[2] * (numbers[1] / numbers[2])\n  end\nend",
  "  assert(#numbers > 2, \"rescale_to_unit() expects list of at least two elements\"\
    )\n  local min = numbers[1]\n  local max = numbers[#numbers]\n  if min == max\
    \ then\n    return numbers\n  elseif min == nil then\n    return numbers[#numbers]\n\
    \  else\n    return (numbers - min) / (max - min)\n  end\nend", "  if #numbers\
    \ < 2 then return numbers else return (numbers[1] + numbers[#numbers]) / 2.0 end\n\
    end", "  local min, max = unpack(numbers)\n  if min == max then\n    return numbers\n\
    \  end", "  assert(#numbers > 0)\n  if #numbers == 1 then\n    return numbers[1]\n\
    \  end\n  local min_value = numbers[1]\n  local max_value = numbers[1]\n  for\
    \ i = 2, #numbers do\n    if numbers[i] < min_value then\n      min_value = numbers[i]\n\
    \    end\n    if numbers[i] > max_value then\n      max_value = numbers[i]\n \
    \   end\n  end\n  local scaled_min = min_value\n  local scaled_max = max_value\n\
    \  for i = 1, #numbers do\n    scaled_min = scaled_min * i - min_value\n    scaled_max\
    \ = scaled_max * i - max_value\n  end\n  scaled_min = scaled_min + 1\n  scaled_max\
    \ = scaled_max - 1\n  for i = 1, #numbers do\n    numbers[i] = ((numbers[i] -\
    \ scaled_min) / (scaled_max - scaled_min)) * 2 - 1\n  end\n  return numbers\n\
    end", "  assert(#numbers > 0, 'The input list must have at least one element')",
  "  local min = math.min(numbers)\n  local max = math.max(numbers)\n  local scaled_numbers\
    \ = {}\n  for _, number in ipairs(numbers) do\n    scaled_numbers[number] = math.abs((number\
    \ - min) / (max - min))\n  end\n  return scaled_numbers\nend", "  local min =\
    \ numbers[1]\n  local max = numbers[1]\n  for _, num in pairs(numbers) do\n  \
    \  if num < min then\n      min = num\n    end\n    if num > max then\n      max\
    \ = num\n    end\n  end\n  return min + (max - min) * (1.0 / #numbers)\nend",
  "    -- If only one number given, treat it as \"100%\"\n    if #numbers == 1 then\n\
    \        numbers = {number}\n    end", "  local minimum = numbers[1]\n  local\
    \ maximum = numbers[#numbers]\n  local length = #numbers\n  local result = {}\n\
    \  for _, number in pairs(numbers) do\n    local factor = number / maximum\n \
    \   for i = 1, length do\n      if factor < numbers[i] then\n        factor =\
    \ numbers[i]\n      end\n    end\n    result[#result + 1] = factor\n  end\n  return\
    \ result\nend", "  if #numbers == 1 then\n    numbers[1] = 0\n    return numbers[1]\n\
    \  elseif #numbers == 2 then\n    numbers[1] = 0\n    numbers[#numbers + 1] =\
    \ 1\n    return numbers\n  end", "  if #numbers == 0 then return numbers end\n\
    \  if #numbers == 1 then\n    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for i = 2, #numbers do\n      min = math.min(min, numbers[i])\n      max\
    \ = math.max(max, numbers[i])\n    end\n    numbers[1] = min + 1\n    numbers[#numbers\
    \ + 1] = max\n    return numbers\n  end\n  local min = numbers[1]\n  local max\
    \ = numbers[1]\n  for i = 2, #numbers do\n    min = math.min(min, numbers[i])\n\
    \    max = math.max(max, numbers[i])\n  end\n  numbers[1] = min + 1\n  numbers[#numbers\
    \ + 1] = max\n  for i = #numbers, 1, -1 do\n    numbers[i] = numbers[i] - min\n\
    \  end\n  return numbers\nend", "  assert(#numbers >= 2, 'rescale_to_unit expects\
    \ a list of numbers')\n  return function(x)\n    if x == nil then\n      x = 1\n\
    \    end\n    local minval = math.min(numbers)\n    local maxval = math.max(numbers)\n\
    \    return minval + x / maxval\n  end\nend", "  assert(#numbers > 0, \"numbers\
    \ should not be empty\")\n  local min = table.min(numbers)\n  local max = table.max(numbers)\n\
    \  if min == max then\n    return numbers\n  else\n    local scaled = numbers\
    \ / max\n    return scaled:gsub(\"^%w+\", \"\"):gsub(\"%w+$\", \"\"):gsub(\"%w+%.\"\
    , \"\"):gsub(\"%.%.%w+\", \"\")\n      :gsub(\"%.%w+$\", \"%f\"):gsub(\"%w+%.\"\
    , \"%f\"):gsub(\"^%w+\", \"%f\"):gsub(\"%w+$\", \"%f\"):gsub(\"%w+%.\", \"%f\"\
    ):gsub(\"^%w+%\\\\.\", \"%f\"):gsub(\"%w+%$\", \"%f\"):gsub(\"%w+%.%$\", \"%f\"\
    ):gsub(\"^%w+%$\", \"%f\")\n      :gsub(\"^%w+\", \"\"):gsub(\"%w+$\", \"\"):gsub(\"\
    %w+%.\", \"\"):gsub(\"%.%.%w+\", \"\")\n      :gsub(\"%.%w+$\", \"%f\"):gsub(\"\
    %w+%.\", \"%f\"):gsub(\"^%w+\", \"%f\"):gsub(\"%w+$\", \"%f\"):gsub(\"%w+%.\"\
    , \"%f\"):gsub(\"^%w+%\\\\.\", \"%f\"):gsub(\"%w+%$\", \"%f\"):gsub(\"%w+%.%$\"\
    , \"%f\")\n      :gsub(\"^%w+\", \"\"):gsub(\"%w+$\", \"\"):gsub(\"%w+%.\", \"\
    \"):gsub(\"%.%.%w+\", \"\")\n      :gsub(\"%.%w+$\", \"%f\"):gsub(\"%w+%.\", \"\
    %f\"):gsub(\"^%w+\", \"%f\"):gsub(\"%w+$\", \"%f\"):gsub(\"%w+%.\", \"%f\"):gsub(\"\
    ^%w+%\\\\.\", \"%f\"):gsub(\"%w+%$\", \"%f\"):gsub(\"%w+%.%$\", \"%f\")\n    \
    \  :gsub(\"^%w+\", \"\"):gsub(\"%w+$\", \"\"):gsub(\"%w+%.\", \"\"):gsub(\"%.%.%w+\"\
    , \"\")\n      :gsub(\"%.%w+$\", \"%f\"):gsub(\"%w+%.\", \"%f\"):gsub(\"^%w+\"\
    , \"%f\"):gsub(\"%w+$\", \"%f\"):gsub(\"%", "  if #numbers < 2 then\n    return\
    \ numbers\n  end", "  assert(#numbers > 0)\n  assert(#numbers == 1 or #numbers\
    \ == 2)\n  if #numbers == 2 then\n    return (numbers[1] - numbers[0]) / (numbers[#numbers\
    \ - 1] - numbers[#numbers])\n  end\n  return numbers[1] - numbers[0]\nend", " \
    \ if #numbers < 2 then\n    return numbers\n  end\n  local min_ind = math.min(unpack(numbers))\n\
    \  local max_ind = math.max(unpack(numbers))\n  local scaled_numbers = {}\n  for\
    \ i, v in ipairs(numbers) do\n    scaled_numbers[i] = v * (max_ind - min_ind)\
    \ / (max_ind + 1e-9)\n  end\n  return scaled_numbers\nend", "  local max   = numbers[1]\n\
    \  local min   = numbers[#numbers]\n  if min == max then\n    return numbers\n\
    \  end\n  local scale = (max - min) / (2 * sys.f32_MIN .. sys.f32_MAX)\n  return\
    \ { math.round(min - scale * 0.5), math.round(max + scale * 0.5) }\nend", "  local\
    \ smallest = numbers[1]\n  local largest = numbers[1]", "  local minim = math.min(numbers)\n\
    \  local maxim = math.max(numbers)\n  return function(x)\n    return (x - minim)\
    \ / (maxim - minim)\n  end\nend", "\tlocal minimum, maximum = table.getn(numbers),\
    \ numbers[1]\n\tlocal new_numbers = numbers:map(function(x) return x / maximum\
    \ - minimum end):map(function(x) return x * maximum + minimum end)\n\treturn new_numbers\n\
    end", "  local min = table.min(numbers) or 0\n  local max = table.max(numbers)\
    \ or 1\n  local scale = (max - min) / (max * (max - min))\n  return function(n)\n\
    \    return n * scale + min\n  end\nend", "\tassert(#numbers >= 2, 'Require at\
    \ least two elements')", "    local result = {}\n    local smallest = numbers[1]\n\
    \    local largest = numbers[1]", "   assert(#numbers >= 2)\n   local min_value\
    \ = math.min(numbers[1])\n   local max_value = math.max(numbers[1])\n   for i\
    \ = 1, #numbers do\n      numbers[i] = numbers[i] * max_value - min_value\n  \
    \ end\n   return numbers\nend", "    -- TODO: check that there are at least 2\
    \ numbers in the list\n    -- TODO: check that all numbers are numbers (e.g. don't\
    \ make strings and try to parse as floats)\n    local min_value = numbers[1]\n\
    \    local max_value = numbers[#numbers]\n    local old_range = max_value - min_value\n\
    \    local new_range = max_value - 0.01", "    if numbers[1] == nil then\n   \
    \     return numbers[2]\n    else\n        return numbers[1]\n    end\nend", " \
    \ if #numbers < 2 then return numbers end\n  local min = math.min(numbers)\n \
    \ local max = math.max(numbers)\n  local min_pos = #numbers\n  local max_pos =\
    \ #numbers + 1\n  local scale = 1\n  for i = min_pos, max_pos, -1 do\n    if numbers[i]\
    \ < min then\n      numbers[i] = 0\n      min_pos = i - 1\n      scale = 1 / scale\n\
    \    elseif numbers[i] > max then\n      numbers[i] = 1\n      max_pos = i - 1\n\
    \      scale = 1 / scale\n    end\n  end\n  return numbers, scale\nend", "  local\
    \ min = table.min(numbers)\n  local max = table.max(numbers)\n  return { min =\
    \ min == 0 and 0.0 or min, max = max == 0 and 1.0 or max }\nend", "  if #numbers\
    \ < 2 then\n    return numbers\n  end", "  local min = 0\n  local max = numbers[1]",
  "    assert(#numbers > 0)\n    local min = math.min(numbers)\n    local max = math.max(numbers)\n\
    \    local scale = (max - min) / (#numbers - 1)\n    return table.Copy(numbers)\
    \ .. [min + scale]\nend", "    local min = numbers[1]\n    local max = numbers[#numbers]",
  "    local minimum = math.min(numbers)\n    local maximum = math.max(numbers)\n\
    \    local minimum_in_range = minimum - EPSILON\n    local maximum_in_range =\
    \ maximum + EPSILON\n    local linear_range = (maximum_in_range - minimum_in_range)\
    \ / (#numbers - 1)\n    local linear = minimum_in_range + (#numbers - 1) * linear_range\n\
    \    local result = {}\n    for _, number in ipairs(numbers) do\n        result[#result\
    \ + 1] = number - linear\n    end\n    return result\nend", "    local minimum,\
    \ maximum = unpack(numbers[1])\n    local scale = maximum - minimum\n    local\
    \ new_numbers = {}\n    for _, number in ipairs(numbers) do\n        new_numbers[number]\
    \ = ((number - minimum) * scale) + minimum\n    end\n    return new_numbers\n\
    end", "  local n = numbers[1]\n  local m = numbers[#numbers]\n  local factor =\
    \ (n+m) / (n+m)^2\n  local i = 0\n  while i < #numbers do\n    numbers[i] = numbers[i]\
    \ / factor\n    i = i + 1\n  end\n  return numbers\nend", "  assert(#numbers >\
    \ 1, \"Rescaling a vector requires at least 2 elements\")\n  local minimum = numbers[1]\n\
    \  local maximum = numbers[1]\n  local largest = largest(numbers)\n  for i = 2,\
    \ #numbers do\n    local element = numbers[i]\n    if element < minimum then\n\
    \      minimum = element\n    end\n    if element > maximum then\n      maximum\
    \ = element\n    end\n    largest = largest(numbers)\n  end\n  local rescaled_numbers\
    \ = {}\n  if smallest == largest then\n    rescaled_numbers[1] = minimum\n   \
    \ return rescaled_numbers\n  end\n  local range = maximum - minimum\n  for i =\
    \ 1, #numbers do\n    rescaled_numbers[i] = ((numbers[i] - minimum) / range) *\
    \ (largest-minimum) + minimum\n  end\n  return rescaled_numbers\nend", "    local\
    \ min = math.min(numbers)\n    local max = math.max(numbers)\n    if min == max\
    \ then\n        return numbers\n    end", "    -- if there's only one number in\
    \ the list, make it a list with one element\n    local new_numbers = numbers[1]\n\
    \    if #numbers > 1 then\n        -- find the smallest number and largest number\n\
    \        local smallest_number = math.min(numbers)\n        local largest_number\
    \ = math.max(numbers)\n        -- scale all the numbers to their new values\n\
    \        for i = 1, #numbers do\n            new_numbers[i] = ((numbers[i] - smallest_number)\
    \ / (largest_number - smallest_number)) * 1.0\n        end\n    end\n    return\
    \ new_numbers\nend", "  if #numbers < 2 then\n    return numbers\n  end\n  local\
    \ min = tonumber(numbers[1])\n  local max = tonumber(numbers[#numbers])\n  assert(min\
    \ ~= nil and max ~= nil, 'Could not rescale list: invalid values')\n  min = min\
    \ or 0\n  max = max or 1\n  local length = #numbers\n  local results = {}\n  for\
    \ i = 1, #numbers do\n    local value = tonumber(numbers[i])\n    assert(value\
    \ ~= nil, 'Could not rescale list: invalid values')\n    local scale = max / value\n\
    \    results[i] = min + (value - min) * scale\n  end\n  return results\nend",
  "  assert(#numbers >= 2, \"rescale_to_unit expects a list of at least two elements\"\
    )\n  local min = numbers[1]\n  local max = numbers[#numbers]\n  local range =\
    \ (max - min) / 2.0\n  for i = 2, #numbers do\n    numbers[i] = (numbers[i] -\
    \ min) / range + 0.5\n  end\n  return numbers\nend", "  local min = numbers[1]\n\
    \  local max = numbers[#numbers]\n  local scale = max - min\n  local new_numbers\
    \ = terralib.newlist()\n  for _, number in ipairs(numbers) do\n    new_numbers:insert(min\
    \ + (number - min) / scale)\n  end\n  return new_numbers\nend", "  if numbers[1]\
    \ <= 0 then\n    error(\"rescale_to_unit: first number must be positive\")\n \
    \ end\n  if numbers[#numbers] <= 0 then\n    error(\"rescale_to_unit: last number\
    \ must be positive\")\n  end\n  local min = numbers[1]\n  local max = numbers[#numbers]\n\
    \  local range = (max - min) / (numbers[#numbers - 1] - min)\n  local result =\
    \ {}\n  for i = 1, #numbers do\n    table.insert(result, min + range * (i - 1))\n\
    \  end\n  return result\nend", "  local min = math.min(numbers)\n  local max =\
    \ math.max(numbers)\n  local scaled, scale = rescale_to_unit(min, max)\n  local\
    \ newMin, newMax\n  if min == max then\n    newMin = min\n    newMax = min\n \
    \ else\n    newMin = min - 0.5 * (max - min)\n    newMax = max + 0.5 * (max -\
    \ min)\n  end\n  return scaled, newMin, newMax\nend", "    -- If there's only\
    \ one element, then there's nothing to do.\n    if #numbers == 1 then\n      \
    \  return numbers\n    end\n    -- If there's only one element, return the same\
    \ thing.\n    if #numbers == 0 then\n        return {0, 1}\n    end\n    -- Otherwise,\
    \ replicate the first element twice to get enough zeros to multiply them out\n\
    \    -- >>> rescale_to_unit([1])\n    -- [0, 1, 1, 1]\n    -- >>> rescale_to_unit([2])\n\
    \    -- [0, 1, 1, 1]\n    local num_ones = 2 * numbers[1]\n    -- Get the largest\
    \ number\n    -- >>> rescale_to_unit([4, 3])\n    -- [4, 5, 3, 3]\n    -- >>>\
    \ rescale_to_unit([3, 6])\n    -- [3, 6, 3, 3]\n    -- >>> rescale_to_unit([3,\
    \ 2])\n    -- [3, 6, 3, 3]\n    -- >>> rescale_to_unit([6, 3])\n    -- [3, 6,\
    \ 3, 3]\n    -- >>> rescale_to_unit([3, 3])\n    -- [3, 6, 3, 3]\n    -- >>> rescale_to_unit([2,\
    \ 6])\n    -- [3, 6, 3, 3]\n    -- >>> rescale_to_unit([2, 3])\n    -- [3, 6,\
    \ 3, 3]\n    -- >>> rescale_to_unit([3, 2])\n    -- [3, 6, 3, 3]\n    local max_num\
    \ = math.max(numbers)\n    -- Get smallest number\n    -- >>> rescale_to_unit([4,\
    \ 3])\n    -- [4, 3, 2, 3]\n    -- >>> rescale_to_unit([3, 6])\n    -- [3, 6,\
    \ 3, 3]\n    -- >>> rescale_to_unit([3, 2])\n    -- [3, 6, 3, 3]\n    -- >>> rescale_to_unit([6,\
    \ 3])\n    -- [3, 6, 3, 3]\n    -- >>> rescale_to_unit([3, 3])\n    -- [3, 6,\
    \ 3, 3]\n    -- >>> rescale_to_unit([2, 6])\n    -- [3, 6, 3, 3]\n    -- >>> rescale_to_unit([2,\
    \ 3])\n    -- [3, 6, 3, 3]\n    -- >>> rescale_to_unit([3, 2])\n    -- [3, 6,\
    \ 3, 3]\n    -- Now multiply by 2 so largest becomes 0 and smallest becomes 1,\
    \ and divide by 2 so each\n    -- number will get divided by 2\n    -- >>> rescale_to_unit([4,\
    \ 3]) * 2.0\n    -- [4.0, 3.0]\n    -- >>> rescale_to_unit([3, 6]) * 2.0\n   \
    \ -- [3.0, 6.0]\n    -- >>> rescale_to_unit([3, 2]) * 2.0\n    -- [3.0, 6.0]\n\
    \    -- >>> rescale_to_unit([6, 3]) * 2.0\n    -- [3.0, 6.0]\n    -- >>> rescale_to_unit([3,\
    \ 3]) * 2.0\n    -- [3.0, 6.0]\n    -- >>> rescal", "  assert(#numbers >= 2, \"\
    Argument must be a list of at least two numbers.\")\n  assert(numbers[1] == numbers[#numbers],\
    \ \"Argument must be a list of numbers.\")\n  local rescaled = {}\n  local total\
    \ = 0\n  for i = 1, #numbers do\n    rescaled[i] = (numbers[i] - total) / total\n\
    \    total = total + numbers[i]\n  end\n  return rescaled\nend", "    if #numbers\
    \ < 2 then\n        return nil\n    end\n    local smallest = numbers[1]\n   \
    \ local largest = numbers[#numbers]\n    local scaling = largest - smallest\n\
    \    local i = 1\n    while i < #numbers and numbers[i] ~= 0 do\n        smallest\
    \ = smallest + numbers[i]\n        largest = largest - numbers[i]\n        i =\
    \ i + 1\n    end\n    if scaling == 0 then\n        largest = 1\n    end\n   \
    \ return smallest / scaling\nend", "  local min = numbers[1]\n  local max = numbers[2]\n\
    \  local scale\n  if min < 0 then\n    local sign = math.sign(min)\n    min =\
    \ sign * -min\n    max = sign * -max\n  end", "  if #numbers == 1 then\n    return\
    \ numbers[1]\n  end", "  local n = numbers[1]\n  local m = numbers[#numbers]",
  '    assert(#numbers > 1)', "    assert(#numbers >= 2, \"rescale_to_unit requires\
    \ at least two numbers\")\n    local smallest_x = math.min(numbers)\n    local\
    \ largest = math.max(numbers)\n    local length = #numbers\n    assert(smallest_x\
    \ ~= largest or smallest == largest, \"rescale_to_unit only works for numbers\
    \ between 0 and 1\")\n    local offset = largest - smallest_x\n    local results\
    \ = {}\n    for i = 1, length do\n        results[i] = smallest_x + offset * i\n\
    \    end\n    return results\nend", "\tlocal min_value = math.min(numbers)\n\t\
    local max_value = math.max(numbers)\n\tassert(min_value ~= 0 and max_value ~=\
    \ 0)\n\treturn numbers - min_value + max_value\nend", "  assert(#numbers >= 2,\
    \ \"rescale_to_unit expected a list of numbers (at least 2 elements)\")\n  if\
    \ #numbers == 1 then\n    return numbers\n  elseif #numbers == 2 then\n    return\
    \ numbers, 0.5\n  end\n  local min, max = numbers[1], numbers[#numbers]\n  local\
    \ range = max - min + 1\n  return numbers, range / min\nend", "  if #numbers <\
    \ 2 then return nil end\n  local min = numbers[1]\n  if min == nil then min =\
    \ numbers[2] end\n  if min == nil then min = 1 end\n  local max = numbers[#numbers]\n\
    \  if max == nil then max = 1 end\n  if min == 0 then min = 1 end\n  if max ==\
    \ 1 then max = 1 end\n  local sum = 0\n  local n = #numbers - 1\n  for i = 1,\
    \ n do\n    sum = sum + numbers[i]\n    numbers[i] = sum / n\n  end\n  return\
    \ numbers\nend", "  local min_value, max_value = unpack(numbers[1])\n  local scaled_number\
    \ = nil\n  local min_num = nil\n  local max_num = nil\n  if #numbers == 1 then\n\
    \    scaled_number = numbers[1]\n  elseif #numbers == 2 then\n    min_num, max_num\
    \ = numbers[1], numbers[2]\n  else\n    scaled_number = function(v)\n      return\
    \ ((v - min_value) / (max_value - min_value)) * (max_num - min_num) + min_num\n\
    \    end\n  end\n  return scaled_number\nend", "  local minimum, maximum = unpack(numbers)\n\
    \  minimum, maximum = minimum or 0, maximum or 1\n  local range = maximum - minimum\n\
    \  local min_rescaled = minimum - (minimum - minimum + 1) * range / 2\n  return\
    \ min_rescaled, min_rescaled + range / 2\nend", "  if #numbers < 2 then\n    return\
    \ numbers\n  end\n  local min_num = math.min(numbers)\n  local max_num = math.max(numbers)\n\
    \  if min_num == 0.0 then\n    return numbers\n  elseif min_num > 0.0 then\n \
    \   local scale = (max_num - min_num) / math.max(min_num, 1)\n    return min_num\
    \ + (numbers - min_num) * scale\n  else\n    local scale = (max_num - min_num)\
    \ / math.min(max_num, 1)\n    return min_num + (numbers - min_num) * scale\n \
    \ end\nend", "  assert(#numbers >= 2)\n  local min = numbers[1]\n  local max =\
    \ numbers[#numbers]\n  local factor = 1.0\n  for i = 2, #numbers do\n    if numbers[i]\
    \ < min then\n      factor = factor * (max - min) / (numbers[i] - min)\n     \
    \ min = numbers[i]\n    end\n    if numbers[i] > max then\n      factor = factor\
    \ * (max - min) / (numbers[i] - max)\n      max = numbers[i]\n    end\n  end\n\
    \  factor = factor * (max - min) / (max - min - 1.0)\n  for i = #numbers, 1, -1\
    \ do\n    numbers[i] *= factor\n  end\n  return numbers\nend", "    local min_val,\
    \ max_val = math.min(numbers), math.max(numbers)\n    local scale_factor = (max_val\
    \ - min_val) / (1.0 - min_val)\n    return table.map(\n        function(x) return\
    \ min_val + x * scale_factor end,\n        numbers\n    )\nend", "\tassert(#numbers\
    \ >= 2, 'rescale_to_unit requires at least two elements')\n\tlocal minimum = numbers[1]\n\
    \tlocal maximum = numbers[#numbers]\n\tlocal scaled = math.min(1, math.max(0,\
    \ (numbers[1] - minimum) / (maximum - minimum)))\n\treturn scaled, scaled\nend",
  "  local smallest_num = numbers[1]\n  local largest = numbers[#numbers]", "  assert(#numbers\
    \ >= 2, 'List must have at least 2 elements.')", "  -- Convert to table\n  local\
    \ length = #numbers\n  local table = {}\n  for i=1,length do\n    table[i] = numbers[i]\n\
    \  end\n  -- Apply transformation to table\n  for i=1,length do\n    table[i]\
    \ = ((numbers[i] - min[#numbers]) / (max[#numbers] - min[#numbers])) * (max[#numbers]\
    \ - min[#numbers]) + min[#numbers]\n  end\n  -- Return result table\n  return\
    \ table\nend", "  if #numbers < 2 then return numbers end\n  local min_value =\
    \ numbers[1]\n  local max_value = numbers[1]\n  for i = 2, #numbers do\n    if\
    \ numbers[i] < min_value then\n      min_value = numbers[i]\n    elseif numbers[i]\
    \ > max_value then\n      max_value = numbers[i]\n    end\n  end\n  for i = 1,\
    \ #numbers do\n    numbers[i] = (((numbers[i] - min_value) * (max_value - min_value)\
    \ / (max_value - min_value) + min_value) / (max_value - min_value))\n  end\n \
    \ return numbers\nend", "\tassert(#numbers > 1)\n\tlocal min = numbers[1]\n\t\
    local max = numbers[1]\n\tfor i = 2, #numbers do\n\t\tmin = min > numbers[i] and\
    \ min or numbers[i]\n\t\tmax = max < numbers[i] and max or numbers[i]\n\tend\n\
    \treturn numbers:map(function(x) return (x - min) / (max - min) end)\nend", " \
    \ local min = 1\n  local max = nil\n  if #numbers > 1 then\n    min = numbers[1]\n\
    \    for idx = 2, #numbers do\n      min = min and numbers[idx] or min\n     \
    \ max = max and max or numbers[idx]\n    end\n  else\n    max = numbers[1]\n \
    \   for idx = 2, #numbers do\n      min = min and min or numbers[idx]\n      max\
    \ = max and max or numbers[idx]\n    end\n  end\n  if min == max then\n    return\
    \ min\n  end\n  -- TODO: This assumes no floating-point errors, which is incorrect\n\
    \  --       In fact, it fails e.g. for 4.9999999999999995 -- not 4.999999999999999999999995\n\
    \  --       This can be fixed by finding the next power of 10 (using math.floor(math.log10(max)))\n\
    \  local scale = 10^(math.floor(math.log10(max)))\n  return min * scale / scale\n\
    end", "  if #numbers == 1 then\n    return numbers[1]\n  else\n    return (numbers[1]\
    \ - numbers[1]:min()) /\n      (numbers[1]:max() - numbers[1]:min())\n  end\n\
    end", "  if #numbers < 2 then\n    return numbers\n  else\n    local min_val =\
    \ math.min(numbers)\n    local max_val = math.max(numbers)\n    local rescaled\
    \ = min_val\n    for i = 1, #numbers do\n      rescaled = rescaled + (max_val\
    \ - min_val) * (numbers[i] - min_val)\n    end\n    return rescaled\n  end\nend",
  "  if #numbers < 2 then return numbers end\n  local min = numbers[1]\n  local max\
    \ = numbers[#numbers]\n  local scale = 1.0 / (max - min)\n  for i = 2, #numbers\
    \ do\n    numbers[i] = numbers[i] - min * scale\n  end\n  return numbers\nend",
  '    assert(#numbers > 1)', "  local min = math.min(numbers)\n  local max = math.max(numbers)\n\
    \  local scaled_min, scaled_max = 0, 1\n  -- In case the numbers have the same\
    \ value, we rescale so that the smallest number will be 0 and the largest will\
    \ be 1\n  if min == max then\n    scaled_min, scaled_max = min, max\n  else\n\
    \    scaled_min, scaled_max = min - min, max - (min - max)\n  end\n  return scaled_min\
    \ .. scaled_max / (max - min)\nend", "  local min = unpack(numbers)[1]\n  local\
    \ max = unpack(numbers)[#numbers]\n  local scale = (max - min) / (#numbers - 1)\n\
    \  for i = 2, #numbers do\n    numbers[i] = numbers[i] - min + scale * (i - 1)\n\
    \  end\n  return numbers\nend", "  local min = math.min(numbers)\n  local max\
    \ = math.max(numbers)\n  local scale = (max - min) / (#numbers - 1)\n  for i =\
    \ 1, #numbers do\n    numbers[i] = numbers[i] - min\n  end\n  for i = 1, #numbers\
    \ do\n    numbers[i] = numbers[i] * scale\n  end\nend", "    local minn, maxn\
    \ = numbers.min, numbers.max\n    local minp = math.max(minn, 1.0)\n    local\
    \ maxp = math.min(maxn, 1.0)\n    return minp + maxp * (numbers - minn) / (maxn\
    \ - minn)\nend", "  return function(w)\n    return w / maximum(numbers) * 1.0\
    \ - 1.0\n  end\nend", "  if #numbers == 1 then\n    return numbers[1]\n  end\n\
    \  local min, _, _, _ = unpack(numbers)\n  local scale = 1./max - min\n  local\
    \ output = { }\n  for _, value in ipairs(numbers) do\n    output[#output + 1]\
    \ = scale * value\n  end\n  return output\nend", "    local min = -math.infinity\n\
    \    local max = math.infinity\n    for _, x in ipairs(numbers) do\n        min\
    \ = math.min(min, x)\n        max = math.max(max, x)\n    end\n    local new_numbers\
    \ = {}\n    for _, x in ipairs(numbers) do\n        new_numbers[#new_numbers +\
    \ 1] = (x - min) / (max - min)\n    end\n    return new_numbers\nend", "  if #numbers\
    \ < 2 then\n    return numbers\n  end", "  local n = table.max(numbers)\n  local\
    \ m = table.min(numbers)\n  local scale_sum = 0.0\n  local scale_sum_sq = 0.0\n\
    \  local scale_n = 0.0", '  assert(#numbers > 1, "rescale_to_unit() expects a
    list with at least one element")', "  if #numbers == 1 then\n    return {numbers[1]}\n\
    \  end\n  local min = math.min(numbers[1])\n  local max = math.max(numbers[1])\n\
    \  local factor = (max - min) / (numbers[#numbers] + 1)\n  local new_numbers =\
    \ {}\n  for i = 2, #numbers, 1 do\n    new_numbers[i + 1] = numbers[i + 1] * factor\n\
    \  end\n  return new_numbers\nend", "    assert(#numbers >= 2)\n    local minimum\
    \ = math.min(numbers[1])\n    local maximum = math.max(numbers[1])", "  assert(#numbers\
    \ > 0, \"rescale_to_unit expects a list of numbers\")\n  local min_val = math.min(numbers)\n\
    \  local max_val = math.max(numbers)\n  if min_val == 0 then\n    error(\"rescale_to_unit\
    \ expects a list of numbers\")\n  end\n  if max_val == 0 then\n    error(\"rescale_to_unit\
    \ expects a list of numbers\")\n  end\n  if min_val == max_val then\n    return\
    \ numbers\n  else\n    local num_factor = (max_val - min_val) / #numbers\n   \
    \ local factors = {}\n    local i = 0\n    for val in numbers do\n      factors[i]\
    \ = val / num_factor\n      i = i + 1\n    end\n    return factors\n  end\nend",
  "  if #numbers < 2 then\n    return numbers\n  end\n  local min = numbers[1]\n \
    \ local max = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] < min then\n\
    \      min = numbers[i]\n    end\n    if numbers[i] > max then\n      max = numbers[i]\n\
    \    end\n  end\n  local new_number = (min + ((max - min) * numbers[1])) / 2.0\n\
    \  table.insert(numbers, new_number)\n  table.sort(numbers)\n  return numbers\n\
    end", "  if numbers[1] == nil then\n    return numbers\n  end\n  local min_value\
    \ = numbers[1]\n  local max_value = numbers[2]\n  local results = {}\n  local\
    \ max_to_min = min_value - max_value\n  for i = 1, #numbers do\n    local value\
    \ = numbers[i]\n    if value == nil then\n      value = min_value\n    end\n \
    \   local value_diff = value - min_value\n    local value_rescaled = value_diff\
    \ / max_to_min\n    local out_value = max_value + value_rescaled * max_to_min\n\
    \    results[i] = out_value\n  end\n  return results\nend", "  local min = numbers[1]\n\
    \  local max = numbers[#numbers]\n  local offset = 0\n  -- Find the first non-zero\
    \ number in the list\n  for i = 1, #numbers do\n    if numbers[i] then\n     \
    \ offset = i\n      break\n    end\n  end\n  return function()\n    local result\
    \ = {}\n    local i = offset + 1\n    local fraction = min + ((max - min) / #numbers)\n\
    \    -- Compute intermediate numbers while keeping the max number\n    while i\
    \ < #numbers and numbers[i] <= fraction do\n      result[i] = numbers[i]\n   \
    \   i = i + 1\n    end\n    -- Shift all numbers by one\n    for j = i, #numbers\
    \ - 1 do\n      result[j] = numbers[j + 1]\n    end\n    result[#numbers - 1]\
    \ = fraction -- Shift last number\n    -- Unshift intermediate numbers\n    for\
    \ j = 1, #numbers do\n      result[j] = numbers[j]\n    end\n    return result\n\
    \  end\nend", "  return function(x)\n    if x == nil then return nil end\n   \
    \ if x > 1 then\n      local i, max = 1, numbers[1]\n      for i = 2, #numbers\
    \ do\n        if numbers[i] < max then\n          max = numbers[i]\n        end\n\
    \      end\n      return (x - min) / (max - min)\n    else\n      local i, min\
    \ = 1, numbers[1]\n      for i = 2, #numbers do\n        if numbers[i] > min then\n\
    \          min = numbers[i]\n        end\n      end\n      return (max - x) /\
    \ (max - min)\n    end\n  end\nend", "  assert(numbers[1] >= numbers[2], \"Expected\
    \ two numbers to be greater than or equal each other\")\n  if #numbers <= 1 then\
    \ return numbers end\n  local scale = (numbers[1] - numbers[2]) / (numbers[#numbers]-1)\n\
    \  local new_numbers = {}\n  for i = 2, #numbers do\n    new_numbers[i] = numbers[i]\
    \ + scale\n  end\n  return new_numbers\nend", "  local min, max = numbers[1],\
    \ numbers[#numbers]\n  if min == max then\n    return numbers\n  else\n    local\
    \ scaled_min, scaled_max = min - min, max - min\n    if scaled_min == scaled_max\
    \ then\n      scaled_min, scaled_max = -10, 10\n    end\n    return scaled_min,\
    \ scaled_max\n  end\nend", "  if #numbers < 2 then return numbers end\n  assert(numbers[1]\
    \ > numbers[#numbers])\n  local minimum = numbers[1]\n  local maximum = numbers[#numbers]\n\
    \  return numbers:map(function(number)\n    if number < minimum then\n      number\
    \ = minimum\n    end\n    if number > maximum then\n      number = maximum\n \
    \   end\n    return number - minimum\n  end)\nend", "  assert(#numbers >= 2)\n\
    \  local largest = numbers[1]\n  for i = 2, #numbers do\n    largest = math.min(largest,\
    \ numbers[i])\n  end\n  return numbers / largest\nend", "    assert(#numbers >=\
    \ 2, \"Rescaling to unit needs at least 2 numbers\")\n    local minimum = numbers[1]\n\
    \    local maximum = numbers[1]\n    for i = 2, #numbers do\n        minimum =\
    \ minimum > numbers[i] and minimum or numbers[i]\n        maximum = maximum <\
    \ numbers[i] and maximum or numbers[i]\n    end\n    \n    -- Scale numbers linearly\n\
    \    local function scale_to_unit(num)\n        return minimum + num * (maximum\
    \ - minimum) / (#numbers - 1)\n    end\n    \n    return numbers:map(scale_to_unit)\n\
    end\n</cell>\n<text>\nAnd let's add some helper functions for plotting the results!",
  "    if #numbers < 2 then\n        error(\"Rescale a list of at least two elements\
    \ is a no-op.\")\n    end\n    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for i = 2, #numbers do\n        if numbers[i] < min then\n            min\
    \ = numbers[i]\n        elseif numbers[i] > max then\n            max = numbers[i]\n\
    \        end\n    end\n    local scale = (max - min) / (#numbers - 1)\n    for\
    \ i = 1, #numbers do\n        numbers[i] = numbers[i] - min + scale\n    end\n\
    \    return numbers\nend", "  if #numbers < 2 then\n    return numbers\n  end\n\
    \  local min = numbers[1]\n  local max = numbers[#numbers]\n  local new_numbers\
    \ = {}\n  for _, num in pairs(numbers) do\n    new_numbers[#new_numbers+1] = num\
    \ - min * (max - min) / (max - min)\n  end\n  return new_numbers\nend", "  assert(#numbers\
    \ >= 2)\n  if #numbers == 1 then\n    return numbers\n  end\n  local min = numbers[1]\n\
    \  local max = numbers[#numbers]\n  local min = min or math.min(numbers)\n  local\
    \ max = max or math.max(numbers)\n  local scaled = min + (max - min) * (1.0 /\
    \ #numbers)\n  return [scaled, scaled]\nend", "    local min_number = math.min(numbers)\n\
    \    local max_number = math.max(numbers)\n    return function()\n        if min_number\
    \ ~= 0 then\n            min_number = min_number - 1\n        end\n        if\
    \ max_number ~= 1 then\n            max_number = max_number + 1\n        end\n\
    \        return min_number + (max_number - min_number) * numbers[1]\n    end\n\
    end\nrescale_to_unit.min_value = 0.0\nrescale_to_unit.max_value = 1.0", "    assert(#numbers\
    \ >= 2, \"This function is not designed to handle list of length 0 or 1\")\n \
    \   local maxval = numbers[1]\n    local minval = numbers[1]\n    local factor\
    \ = numbers[1] / maxval\n    for _, number in pairs(numbers) do\n        local\
    \ new_number = number * factor\n        minval = min(minval, new_number)\n   \
    \     maxval = max(maxval, new_number)\n    end\n    return minval, maxval\nend",
  "    local max_number = math.max(numbers)\n    local min_number = math.min(numbers)\n\
    \    \n    if min_number == max_number then\n        return numbers\n    end",
  "  local min, max = numbers.min, numbers.max\n  if min == max then return {0,1}\n\
    \  elseif min == max then\n    return {min,0}\n  else\n    local scale = 1.0\n\
    \    local scaled_min = math.floor(min / scale) * scale\n    local scaled_max\
    \ = math.ceil(max / scale) * scale\n    return {scaled_min, scaled_max}\n  end\n\
    end", "  assert(#numbers > 0, \"Argument should be a list of at least two elements\"\
    )\n  local min = numbers[1]\n  local max = numbers[#numbers]\n  if min == max\
    \ then\n    -- if all elements are the same, just return one element\n    return\
    \ numbers[1]\n  elseif min == 0 or max == 1 then\n    -- if the min and max are\
    \ both 0 or 1, just return them\n    return min, max\n  else\n    -- otherwise\
    \ scale between them\n    local scale = min / max\n    local new_numbers = {}\n\
    \    for i = 1, #numbers do\n      new_numbers[i] = numbers[i] * scale\n    end\n\
    \    return new_numbers\n  end\nend", "  assert(#numbers > 1)\n  local min_index\
    \ = 1\n  for i = 2, #numbers do\n    if numbers[i] < numbers[min_index] then\n\
    \      min_index = i\n    end\n  end\n  local max_index = #numbers - 1\n  if numbers[max_index]\
    \ < numbers[min_index] then\n    max_index = max_index - 1\n  end\n  assert(numbers[min_index]\
    \ >= 0)\n  assert(numbers[max_index] >= 0)\n  local scaled_numbers = {}\n  for\
    \ i = min_index, max_index, 1 do\n    scaled_numbers[i] = numbers[i] / numbers[max_index]\n\
    \  end\n  return scaled_numbers\nend", "  if #numbers < 2 then\n    return nil\n\
    \  end\n  local min = numbers[1]\n  local max = numbers[#numbers]\n  local factor\
    \ = (max - min) / (#numbers - 1)\n  local result = {}\n  for i = 1, #numbers do\n\
    \    result[i] = min + (numbers[i] - min) * factor\n  end\n  return result\nend",
  "    local minimum = numbers[1]\n    local maximum = numbers[1]\n    for i = 2,\
    \ #numbers do\n        if numbers[i] < minimum then\n            minimum = numbers[i]\n\
    \        elseif numbers[i] > maximum then\n            maximum = numbers[i]\n\
    \        end\n    end\n    return minimum, maximum\nend", "    -- First, rescale\
    \ the numbers to be between 0 and 1\n    local min_number = numbers[1]\n    local\
    \ max_number = numbers[#numbers]\n    local adjusted_numbers = {}\n    for _,\
    \ number in pairs(numbers) do\n        adjusted_numbers[#adjusted_numbers + 1]\
    \ = (number - min_number) / (max_number - min_number)\n    end\n    -- Then, return\
    \ the scaled numbers\n    return adjusted_numbers\nend", "    local min = math.min(numbers)\n\
    \    local max = math.max(numbers)\n    local scaled_numbers = numbers.map(function(x)\n\
    \        return x / max\n    end)\n    return scaled_numbers\nend", "  assert(#numbers\
    \ >= 2, \"This function expects a list of at least two elements\")\n  local max_number\
    \ = math.max(numbers)\n  local min_number = math.min(numbers)\n  if min_number\
    \ == 0.0 then\n    -- The input vector is all zeros.\n    return numbers\n  end\n\
    \  if min_number == max_number then\n    -- The input vector consists of a single\
    \ element. Return a one-element vector.\n    return {min_number}\n  end", "  \
    \  local min = 1\n    local max = 0\n    for _, x in ipairs(numbers) do\n    \
    \    min = math.min(min, x)\n        max = math.max(max, x)\n    end", "    assert(#numbers\
    \ > 1, 'Expected a list of numbers. Received: ' .. table.concat(numbers, ','))\n\
    \    local min_val = math.min(numbers)\n    local max_val = math.max(numbers)\n\
    \    local num_elements = #numbers\n    local rescaled = {}\n    for i = 1, num_elements\
    \ do\n        rescaled[i] = (numbers[i] - min_val) / (max_val - min_val) * (num_elements\
    \ - 1)\n    end\n    return rescaled\nend", "  local minimum = tonumber(numbers[1])\n\
    \  local maximum = tonumber(numbers[#numbers])", "  if #numbers == 1 then\n  \
    \  return numbers\n  end", "   if #numbers < 2 then\n      return numbers\n  \
    \ end", "  local n = table.remove(numbers)\n  if n == nil then return nil end\n\
    \  local min = 0\n  local max = numbers[1]\n  for i = 2, #numbers do\n    min\
    \ = numbers[i] or min\n    max = numbers[i] or max\n  end\n  local n_interval\
    \ = max - min\n  if n_interval == 0 then\n    return nil\n  end\n  local interval\
    \ = 1 / n_interval\n  local result = {}\n  for i = 1, n do\n    local x = min\
    \ * interval + interval / 2\n    table.insert(result, x)\n  end\n  return result\n\
    end", '  local minn, maxn = numbers[1], numbers[#numbers]', "  assert(#numbers\
    \ >= 2)\n  local minimum = numbers[1]\n  local maximum = numbers[#numbers]\n \
    \ return function()\n    if minimum ~= 0 then\n      minimum = minimum / maximum\n\
    \      local newmin = minimum\n      local i = 0\n      while minimum > 0 and\
    \ i < #numbers do\n        minimum = minimum * maximum\n        minimum = math.max(minimum,\
    \ newmin)\n        i = i + 1\n      end\n    end\n    if maximum ~= 1 then\n \
    \     maximum = maximum / minimum\n      local newmax = maximum\n      i = 0\n\
    \      while maximum > 0 and i < #numbers do\n        maximum = maximum * minimum\n\
    \        maximum = math.min(maximum, newmax)\n        i = i + 1\n      end\n \
    \   end\n    numbers[#numbers] = minimum\n    numbers[1] = maximum\n  end\nend",
  "    local min_value = math.min(numbers)\n    local max_value = math.max(numbers)\n\
    \    local scale_factor = max_value - min_value\n    local scaled_numbers = {}\n\
    \    for i, number in ipairs(numbers) do\n        scaled_numbers[i] = round(number\
    \ * scale_factor) + min_value\n    end\n    return scaled_numbers\nend", "   assert(#numbers\
    \ > 1)\n   local min = math.min(numbers)\n   local max = math.max(numbers)\n \
    \  local scale = (max - min) / 2.0\n   return function(n)\n      local t = n *\
    \ scale + min\n      return t / scale\n   end\nend", "  if numbers[1] == nil then\n\
    \    numbers[1] = 1\n  end", "  -- First assume that all numbers are positive.\n\
    \  local smallest_number = math.min(numbers)\n  local max_number = math.max(numbers)",
  "  assert(#numbers > 1)\n  local scale = 1.0\n  for _, x in ipairs(numbers) do\n\
    \    scale = math.min(scale, x)\n  end\n  return function(x)\n    if x == nil\
    \ then\n      return nil\n    end\n    return math.min(1.0 + scale * x, 1.0)\n\
    \  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
