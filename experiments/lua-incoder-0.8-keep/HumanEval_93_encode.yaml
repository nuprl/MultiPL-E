name: HumanEval_93_encode
language: lua
prompt: "-- Write a function that takes a message, and encodes in such a \n-- way\
  \ that it swaps case of all letters, replaces all vowels in \n-- the message with\
  \ the letter that appears 2 places ahead of that \n-- vowel in the english alphabet.\
  \ \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n--\
  \ >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encode\n\
  \    lu.assertEquals(candidate('TEST'), 'tgst')\n    lu.assertEquals(candidate('Mudasir'),\
  \ 'mWDCSKR')\n    lu.assertEquals(candidate('YES'), 'ygs')\n    lu.assertEquals(candidate('This\
  \ is a message'), 'tHKS KS C MGSSCGG')\n    lu.assertEquals(candidate('I DoNt KnOw\
  \ WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local encoded = message\n  local vowels = {'a', 'e', 'i', 'o', 'u',\
    \ 'y'}\n  local letters = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', \n   \
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x'}\n  -- First, convert message\
    \ to lower case\n  message = message:lower()\n  -- Then, swap case of all letters,\
    \ and swap vowels\n  for i = 1, #message do\n    local letter = message[i]\n \
    \   local vowel = vowels[letter:find('a')] or letter\n    if i > 1 then\n    \
    \  encoded = encoded[:i] .. (letters[vowel] or vowel) .. encoded[i+1:]\n    end\n\
    \  end\n  -- Finally, replace vowels with 2x letters\n  for i = 1, #vowels do\n\
    \    local letter = vowels[i]\n    local vowel = vowels[i]\n    local idx = message:find(vowel)\n\
    \    while idx > 0 do\n      encoded = encoded[:idx] .. (letters[letter] or letter)\
    \ .. encoded[idx+1:]\n      idx = message:find(vowel, idx+1)\n    end\n  end\n\
    \  return encoded\nend", "  local messageLength = message:len()\n  if messageLength\
    \ ~= 0 then\n    local alpha = \"abcdefghijklmnopqrstuvwxyz\"\n    local vowels\
    \ = \"aeiouAEIOU\"\n    local newMessage = \"\"\n    local newMessageLength =\
    \ 0", "  -- TODO: implement this function\n  return message\nend", "  local msg\
    \ = {}\n  local vowels = { 'a','e','i','o','u','y' }\n  \n  for i = 1, #message\
    \ do\n    local vowel = string.sub(message,i,i)\n    if vowel == 'A' or vowel\
    \ == 'a' then\n      vowel = string.sub(message,i,i-1)\n      table.insert(msg,vowel)\n\
    \    end\n  \n    table.insert(msg,string.sub(message,i,i+1))\n  end\n  \n  table.sort(msg)\n\
    \  \n  for i = 1, #msg do\n    if vowels[string.sub(msg,i,i+1)] then\n      local\
    \ letter = string.sub(msg,i,i)\n      table.insert(msg,letter)\n    end\n  end\n\
    \  \n  return table.concat(msg)\nend", "  local function toLetter(n)\n    return\
    \ string.char(n + 96) .. string.char(n + 96)\n  end\n  local function swapCase(message)\n\
    \    local function swapCaseInLetters(letter)\n      if letter:sub(1,1) == 'a'\
    \ then\n        letter = string.upper(letter)\n      elseif letter:sub(1,1) ==\
    \ 'A' then\n        letter = string.lower(letter)\n      end\n      return letter\n\
    \    end\n    return string.gsub(message, \"([AEIOUaeiou])\", swapCaseInLetters)\n\
    \  end\n  return string.gsub(message, \"([AEIOUaeiou])\", toLetter)\nend", "\t\
    -- We are going to make a table where we keep track of the\n\t-- mapping from\
    \ letters to the letter that appears two letters\n\t-- ahead of the letter.\n\t\
    local mapping = {}\n\t-- We are going to use a list for our result\n\t-- We will\
    \ make a new table because we will append new letters\n\t-- onto the end of a\
    \ list\n\tlocal result = {}\n\t-- We will add the first letter to the list\n\t\
    result[#result + 1] = ''\n\t-- We will loop through each letter in the message\n\
    \tfor i, letter in pairs(message) do\n\t\t-- If the letter is not a letter, we\
    \ just skip it\n\t\tif not letter:match('^[a-zA-Z]$') then\n\t\t\t-- We skip it\n\
    \t\t\tcontinue\n\t\telse\n\t\t\t-- We will make a new list that keeps track of\
    \ the letter\n\t\t\t-- that appears two letters ahead\n\t\t\tlocal new_result\
    \ = {letter}\n\t\t\t-- We will loop through all the letters one position ahead\n\
    \t\t\tfor j = i + 1, #message do\n\t\t\t\t-- We will try to match it to the existing\
    \ mappings\n\t\t\t\t-- If a match is found, we append the letter to the \n\t\t\
    \t\t-- new mapping that we have created \n\t\t\t\tfor _, mapping in pairs(mapping)\
    \ do\n\t\t\t\t\t-- If the mapping matches the letter, we append it to the\n\t\t\
    \t\t\t-- new mapping\n\t\t\t\t\tif mapping:match(message[j]) then\n\t\t\t\t\t\t\
    new_result[#new_result + 1] = mapping[j]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\
    \t\t\t-- We will append the new result onto the result list\n\t\t\tresult = result\
    \ + new_result\n\t\tend\n\tend\n\t-- We will return a list with all the letters\
    \ in the correct order\n\treturn result\nend", "    local str = \"\"\n    for\
    \ c in string.gmatch(message, \"%a\") do\n        if string.find(vowels, string.lower(c))\
    \ ~= nil then\n            local pos = string.find(vowels, string.lower(c))\n\
    \            local next = string.sub(message, pos + 1, pos + 1)\n            if\
    \ string.len(next) == 1 then\n                next = string.sub(next, 2, string.len(next))\n\
    \            end\n            str = str .. string.sub(string.lower(c), pos + 1,\
    \ pos + 1) .. next\n        elseif string.find(vowels, string.lower(c)) ~= nil\
    \ then\n            str = str .. string.lower(c)\n        else\n            str\
    \ = str .. c\n        end\n    end\n    return str\nend\n</code>\n<|/ a tags=lua,string,arrays\
    \ |>\n<| c |>\nThis is way too complicated for what I want, as I'm already aware\
    \ of what I want to do. I want to turn the string into numbers. So if I have a\
    \ string `test`, I want an array of `{'t','t','g','s','t'}`. The `string` library\
    \ doesn't have anything like that. `string.gmatch` would do what I'm trying to\
    \ do here, but only on individual letters, not whole words.\n<|/ c |>\n<| a |>\n\
    I came up with this solution which doesn't require an external library:\n<code>",
  "  local function encode(message, offset, char)\n    if offset == 1 then\n     \
    \ return string.char(message.upper(2), message.upper(3))\n    end", "  local result\
    \ = \"\"\n  for i = 1, #message do\n    local char = string.sub(message, i, i)\n\
    \    local nextChar = string.sub(message, i + 1, i + 1)\n    if nextChar == \"\
    A\" then\n      nextChar = \"a\"\n    end \n    if string.sub(\"AEIOUYaeiouy\"\
    , nextChar, nextChar) then\n      nextChar = string.sub(\"AEIOUYaeiouy\", nextChar,\
    \ nextChar)\n    end\n    \n    if char == \"a\" then\n      result = result ..\
    \ nextChar\n    end\n    \n    if char == \"E\" then\n      if result ~= \"\"\
    \ then\n        result = result .. nextChar\n      end\n      result = result\
    \ .. \"e\"\n    end\n    \n    if char == \"I\" then\n      if result ~= \"\"\
    \ then\n        result = result .. nextChar\n      end\n      result = result\
    \ .. \"i\"\n    end\n    \n    if char == \"O\" then\n      if result ~= \"\"\
    \ then\n        result = result .. nextChar\n      end\n      result = result\
    \ .. \"o\"\n    end\n    \n    if char == \"U\" then\n      if result ~= \"\"\
    \ then\n        result = result .. nextChar\n      end\n      result = result\
    \ .. \"u\"\n    end\n  end\n  return result\nend", "    local vowels  = {'a',\
    \ 'e', 'i', 'o', 'u'}\n    local alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n   \
    \ local letters  = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'}", "  return\
    \ message:gsub(\"[a\xE0\xE1\xE2\xE3\xE4\xE5]\", \"\\%u\")\n            :gsub(\"\
    [e\xE9\xE8\xEB]\", \"\\%u\")\n            :gsub(\"[i\xEC\xED\xEE\xEF]\", \"\\\
    %u\")\n            :gsub(\"[o\xF2\xF3\xF4\xF5\xF6]\", \"\\%u\")\n            :gsub(\"\
    [u\xFA\xF9\xFA\xFB\xFC]\", \"\\%u\")\n            :gsub(\"[AaAaAaAaAaAa]\", \"\
    \\%u\")\n            :gsub(\"[EeEeEeEeEeEe]\", \"\\%u\")\n            :gsub(\"\
    [IiIiIiIiIiIiI]\", \"\\%u\")\n            :gsub(\"[OoOoOoOoOoOoOo]\", \"\\%u\"\
    )\n            :gsub(\"[UuUuUuUuUuUuUu]\", \"\\%u\")\n            :gsub(\"[YyYyYyYyYyYyYy]\"\
    , \"\\%u\")\n            :gsub(\"[a\xE2\xE0\xE4]\", \"\\%u\")\n            :gsub(\"\
    [e\xE8\xE9\xEA\xEB]\", \"\\%u\")\n            :gsub(\"[i\xEE\xEF]\", \"\\%u\"\
    )\n            :gsub(\"[o\xF4\xF2\xF6]\", \"\\%u\")\n            :gsub(\"[u\xFB\
    \xFC]\", \"\\%u\")\n            :gsub(\"[\xC3]\", \"\\%u\")\n            :gsub(\"\
    [\xC4]\", \"\\%u\")\n            :gsub(\"[\xC2]\", \"\\%u\")\n            :gsub(\"\
    [\xC0]\", \"\\%u\")\n            :gsub(\"[\xD1]\", \"\\%u\")\n            :gsub(\"\
    [\xDC]\", \"\\%u\")\n            :gsub(\"[\xDE]\", \"\\%u\")\n            :gsub(\"\
    [\xFE]\", \"\\%u\")\n            :gsub(\"[\xDE]\", \"\\%u\")\n            :gsub(\"\
    [\xFE]\", \"\\%u\")\n            :gsub(\"[\xDE]\", \"\\%u\")\n            :gsub(\"\
    [\xDE]\", \"\\%u\")\n            :gsub(\"[\xDE]\", \"\\%u\")\n            :gsub(\"\
    [\xDE]\", \"\\", "\t-- Write your code here.\n\tlocal alphabet = string.char(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n\tlocal vowels = {\"a\",\"e\",\"i\",\"o\",\"u\"\
    }\n\tlocal splitMessage = string.gsub(message, \"[^\" .. table.concat(alphabet)\
    \ .. \"]\", \"\")\n\tlocal alphabetCount = 1\n\tlocal encoded = \"\"\n\tlocal\
    \ index = 0\n\tfor i = 1, #splitMessage do\n\t\tif splitMessage[i] ~= \"\" then\n\
    \t\t\tif string.sub(i, 1, 1) ~= string.sub(splitMessage[i], 1, 1) then\n\t\t\t\
    \tindex = index + 1\n\t\t\telse\n\t\t\t\tindex = index + 1\n\t\t\t\tlocal letter\
    \ = string.sub(splitMessage[i], 1, 1) .. string.sub(splitMessage[i], 2, 2)\n\t\
    \t\t\tletter = string.sub(letter, 1, letter:len())\n\t\t\t\tif #splitMessage ==\
    \ index + 1 then\n\t\t\t\t\tencoded = encoded .. letter .. letter\n\t\t\t\telse\n\
    \t\t\t\t\tencoded = encoded .. letter .. string.sub(splitMessage[i], 1, (index\
    \ + 1))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn encoded\nend", "  --\
    \ If the string is empty or null, return an empty string\n  if message == nil\
    \ or message == '' then\n    return ''\n  end", "    message = string.gsub(message,\
    \ \"([aeiou])\", \"%1%\")\n    message = string.gsub(message, \"([aeiou])([aeiou])\"\
    , \"%1%2%1%\")\n    message = string.gsub(message, \"([aeiou])([aeiou])([aeiou])\"\
    , \"%1%2%1%2%1%\")\n    message = string.gsub(message, \"([aeiou])([aeiou])([aeiou])([aeiou])\"\
    , \"%1%2%1%2%1%2%1%\")\n    message = string.gsub(message, \"([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])\"\
    , \"%1%2%1%2%1%2%1%2%1%\")\n    message = string.gsub(message, \"([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])\"\
    , \"%1%2%1%2%1%2%1%2%1%2%1%\")\n    message = string.gsub(message, \"([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])\"\
    , \"%1%2%1%2%1%2%1%2%1%2%1%2%1%\")\n    message = string.gsub(message, \"([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])([aeiou])\"\
    , \"%1%2%1%2%1%2%1%2%1%2%1%2%1%2%1%\")\n    return message\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks! But I don't think the exercise specifically specifies\
    \ that this is what he meant by \"encode using an algorithm.\"\n<|/ c |>\n<| a\
    \ dscore=1 |>\nIt doesn't really matter what language your professor uses for\
    \ this problem, but you can do this in PHP as follows:\n<code>\n<?php", "    local\
    \ new_message = ''\n    for i = 1, #message do\n        local vowels = {'a', 'e',\
    \ 'i', 'o', 'u'}\n        for j = 1, #vowels do\n            if string.sub(message,\
    \ i, i + #vowels) == vowels[j] then\n                local offset = j + 2\n  \
    \              if offset > #vowels then\n                    offset = #vowels\n\
    \                end\n                new_message = new_message .. string.sub(message,\
    \ i, i + offset)\n            end\n        end\n    end\n    return new_message\n\
    end", "    local result = {}\n    for i, letter in ipairs(message) do\n      \
    \  local first = string.sub((string.sub(letter, 0, 1) + string.sub(letter, 1,\
    \ 1)), 2, 1)\n        local second = string.sub((string.sub(letter, 2, 1) + string.sub(letter,\
    \ 3, 2)), 2, 1)\n        local third = string.sub((string.sub(letter, 4, 1) +\
    \ string.sub(letter, 5, 2)), 2, 1)\n        table.insert(result, string.sub(letter,\
    \ 1, 1) + first + second + third)\n    end\n    return table.concat(result, \"\
    \")\nend", "    local alphabet = {['A'] = 'a', 'aA' = 'A', 'B' = 'b', 'Bb' = 'B',\
    \ 'C' = 'c',\n                      'Cc' = 'C', 'D' = 'd', 'Dd' = 'D', 'E' = 'e',\
    \ 'Ee' = 'E',\n                      'F' = 'f', 'Ff' = 'F', 'G' = 'g', 'Gg' =\
    \ 'G', 'H' = 'h',\n                      'Hh' = 'H', 'I' = 'i', 'Ii' = 'I', 'J'\
    \ = 'j',\n                      'Jj' = 'J', 'K' = 'k', 'Kk' = 'K', 'L' = 'l',\n\
    \                      'Ll' = 'L', 'M' = 'm', 'Mm' = 'M', 'N' = 'n',\n       \
    \               'Nn' = 'N', 'O' = 'o', 'Oo' = 'O', 'P' = 'p',\n              \
    \        'Pp' = 'P', 'Q' = 'q', 'Qq' = 'Q', 'R' = 'r',\n                     \
    \ 'Rr' = 'R', 'S' = 's', 'Ss' = 'S', 'T' = 't',\n                      'Tt' =\
    \ 'T', 'U' = 'u', 'Uu' = 'U', 'V' = 'v',\n                      'Vv' = 'V', 'W'\
    \ = 'w', 'Ww' = 'W', 'X' = 'x',\n                      'Xx' = 'X', 'Y' = 'y',\
    \ 'Yy' = 'Y', 'Z' = 'z',\n                      'Zz' = 'Z'}\n    return string.gsub(message,\
    \ \"(.)([aAeEiIoOuUyY])\", function(char,letter)\n        return string.sub(alphabet[letter],\
    \ 1,\n                          string.find(alphabet[letter], letter + 2, 1))\n\
    \    end)\nend", "  local result = \"\"\n  \n  -- get all vowels in message\n\
    \  local vowels = \"AEIOUaeiou\"\n  -- find their positions\n  local positions\
    \ = { }\n  for vowel in vowels:gmatch(\"[%a]+\") do \n    table.insert(positions,\
    \ string.find(message, vowel) + 1)\n  end\n  \n  -- replace each vowel in the\
    \ message with its 2 places ahead vowel\n  for pos, char in ipairs(positions)\
    \ do\n    -- get the 2 places ahead vowel\n    local next = string.sub(message,\
    \ pos, pos)\n    local vowel\n    local vowel_position\n    -- determine which\
    \ vowel we have\n    if vowels:sub(1, 1) == \"A\" then\n      vowel = string.sub(\"\
    AEIOUaeiou\", 1)\n      vowel_position = string.find(vowels, next) + 1\n    elseif\
    \ vowels:sub(1, 1) == \"E\" then\n      vowel = string.sub(\"AEIOUaeiou\", 1)\n\
    \      vowel_position = string.find(vowels, next, 2) - 1\n    elseif vowels:sub(1,\
    \ 1) == \"I\" then\n      vowel = string.sub(\"AEIOUaeiou\", 1)\n      vowel_position\
    \ = string.find(vowels, next, 4) - 1\n    elseif vowels:sub(1, 1) == \"O\" then\n\
    \      vowel = string.sub(\"AEIOUaeiou\", 1)\n      vowel_position = string.find(vowels,\
    \ next, 6) - 1\n    elseif vowels:sub(1, 1) == \"U\" then\n      vowel = string.sub(\"\
    AEIOUaeiou\", 1)\n      vowel_position = string.find(vowels, next, 8) - 1\n  \
    \  else\n      error(\"Invalid vowel\")\n    end\n    -- insert the vowel into\
    \ the message\n    result = result .. string.sub(message, pos, pos) .. string.sub(vowels,\
    \ vowel_position, vowel_position)\n  end\n  return result\nend", "\tlocal result\
    \ = ''\n\tfor i = 1, #message do\n\t\tlocal letter = string.lower(message[i])\n\
    \t\tif letter == 'a' or letter == 'e' or letter == 'i' or letter == 'o' or letter\
    \ == 'u' then\n\t\t\tresult = result .. letter\n\t\telse\n\t\t\tlocal vowels =\
    \ \"aeiouAEIOU\"\n\t\t\tlocal a = string.find(vowels, letter)\n\t\t\tif a then\n\
    \t\t\t\tlocal a2 = string.find(vowels, string.lower(message[i+2]))\n\t\t\t\tif\
    \ a2 then\n\t\t\t\t\tresult = result .. string.sub((string.lower(message[i])))\n\
    \t\t\t\telse\n\t\t\t\t\tresult = result .. string.sub((string.lower(message[i])))\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend", "    local result\
    \ = ''\n    \n    for letter in message:gmatch'[%a]'\n        do\n           \
    \ if string.find(letter, 'aeiou', 1) then\n                local index_of_vowel\
    \ = string.find(letter, '[aeiou]')\n                local index_of_vowel_2 = string.find(letter,\
    \ '[aeiou]', index_of_vowel + 1)\n                \n                result = (result\
    \ .. string.sub(letter, 1, index_of_vowel - 1)) .. \n                        \
    \   (string.sub(letter, index_of_vowel + 1, index_of_vowel_2) .. string.sub(letter,\
    \ index_of_vowel_2 + 1))\n            else\n                result = (result ..\
    \ letter)\n            end\n        end\n    \n    return result\nend", "    local\
    \ message = message:upper()\n    local message_length = #message\n    local message_length_to_swap\
    \ = math.abs(message_length - 1)\n    local vowel_mapping = {}\n    local vowel_mapping_length\
    \ = 26\n    for letter = string.lowercase do\n        local vowel_count = string.count(message,\
    \ letter)\n        local first_vowel_index = math.floor(vowel_count / 2)\n   \
    \     local second_vowel_index = math.floor(vowel_count / 2) + 1\n        local\
    \ vowel_mapping_index = first_vowel_index\n        for i = first_vowel_index,\
    \ second_vowel_index do\n            vowel_mapping_index = i - 1\n           \
    \ vowel_mapping[string.sub(message, i - 1, 1)] = string.sub(message, i, 1)\n \
    \       end\n        vowel_mapping[letter] = vowel_mapping_index\n    end", " \
    \ -- Find all vowels in the message\n  local vowels = {}\n  for i = 1, string.len(message)\
    \ do\n    if string.sub(message, i, i) ~= 'a' and string.sub(message, i, i) ~=\
    \ 'e' and string.sub(message, i, i) ~= 'i' and string.sub(message, i, i) ~= 'o'\
    \ and string.sub(message, i, i) ~= 'u' then\n      table.insert(vowels, string.sub(message,\
    \ i, i))\n    end\n  end\n  -- Find the locations of the vowels\n  local locations\
    \ = {}\n  for i = 1, string.len(message) do\n    if string.sub(message, i, i)\
    \ ~= 'a' and string.sub(message, i, i) ~= 'e' and string.sub(message, i, i) ~=\
    \ 'i' and string.sub(message, i, i) ~= 'o' and string.sub(message, i, i) ~= 'u'\
    \ then\n      table.insert(locations, i)\n    end\n  end\n  -- Replace the vowels\
    \ with the locations\n  local index = 1\n  for i = 1, string.len(message) do\n\
    \    if string.sub(message, i, i) ~= 'a' and string.sub(message, i, i) ~= 'e'\
    \ and string.sub(message, i, i) ~= 'i' and string.sub(message, i, i) ~= 'o' and\
    \ string.sub(message, i, i) ~= 'u' then\n      string.sub(message, index, index-1)\
    \ = vowels[i]\n      index = index + 1\n    end\n  end\n  -- Replace the vowels\
    \ with the letters 2 places ahead of the vowel\n  for i = 1, string.len(message)\
    \ do\n    if string.sub(message, i, i) ~= 'a' and string.sub(message, i, i) ~=\
    \ 'e' and string.sub(message, i, i) ~= 'i' and string.sub(message, i, i) ~= 'o'\
    \ and string.sub(message, i, i) ~= 'u' then\n      string.sub(message, i, i) =\
    \ string.sub(message, locations[i], locations[i]-1)\n    end\n  end\n  return\
    \ message\nend", "\tlocal decoded = message\n\tdecoded = string.gsub(decoded,\
    \ '([a-z])', function(c)\n\t\tlocal n = string.find(string.lowercase string.sub(c,\
    \ 1, 1), 'aeiou')\n\t\tif n ~= nil then\n\t\t\treturn string.sub(c, 1, n + 1)\
    \ .. string.upper(string.sub(c, n, 1))\n\t\telse\n\t\t\treturn string.sub(c, 1,\
    \ 1)\n\t\tend\n\tend)", "    -- Replace vowel characters with their corresponding\
    \ letters\n    local result = message\n    for i = 1, #message do\n        local\
    \ character = string.sub( message, 1, i)\n        local new_character = string.sub(\
    \ alphabet, #alphabet + 1, i)\n        result = string.gsub( result, character,\
    \ new_character)\n    end\n    -- Replace all vowel characters with their corresponding\
    \ letters\n    result = string.gsub( result, '[aeiou]', function(character)\n\
    \        return string.sub( alphabet, #alphabet + 1, string.find( alphabet, character))\n\
    \    end)\n    return result\nend", "    local alphabet = {\n        'a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', \n        'l', 'm', 'n', 'o', 'p',\
    \ 'q', 'r', 's', 't', 'u', 'v', 'w', \n        'x', 'y', 'z', 'A',  'B',  'C',\
    \  'D',  'E',  'F',  'G',  'H', \n        'I',  'J',  'K',  'L',  'M',  'N', \
    \ 'O',  'P',  'Q',  'R', \n        'S',  'T',  'U',  'V',  'W',  'X',  'Y',  'Z',\
    \ 'W', 'R', \n        'T', 'S', 'U', 'P', 'S', 'V', 'Q', 'P', 'L', 'K', 'K', 'Q',\
    \ \n        'F', 'T', 'S', 'V', 'S', 'B', 'K', 'M', 'S', 'S', 'K', 'G', \n   \
    \     'Y', 'I', 'E', 'F', 'H', 'R', 'T', 'S', 'K', 'S', 'C', 'G', \n        'M',\
    \ 'S', 'G', 'R', 'M', 'P', 'K', 'S', 'S', 'G', 'Y', 'V', \n        'P', 'I', 'E',\
    \ 'G', 'G', 'K', 'M', 'K', 'Q', 'H', 'H', 'R', \n        'C', 'M', 'G', 'K', 'Q',\
    \ 'P', 'K', 'R', 'K', 'S', 'V', 'K', \n        'G', 'Y', 'K', 'M', 'G', 'M', 'R',\
    \ 'H', 'T', 'I', 'S', 'D', \n        'R', 'D', 'M', 'P', 'P', 'S', 'K', 'I', 'M',\
    \ 'V', 'R', 'H', \n        'L', 'K', 'V', 'S', 'D', 'H', 'K', 'K', 'H', 'T', 'I',\
    \ 'T', \n        'S', 'G', 'I', 'H', 'H', 'H', 'K', 'S', 'G', 'K', 'P', 'S', \n\
    \        'Q', 'H', 'S', 'G', 'R', 'P', 'R', 'P', 'L', 'P', 'R', 'G', \n      \
    \  'M', 'I', 'T', 'S', 'G', 'S', 'G', 'S', 'G', 'S', 'K', 'L', \n        'H',\
    \ 'I', 'S', 'K', 'M', 'D', 'R', 'D', 'S', 'K', 'V', 'G', \n        'V', 'I', 'S',\
    \ 'K', 'R', 'I', 'K', 'G', 'Y', 'I', 'K', 'G', \n        'Y', 'I', 'K', 'L', 'H',\
    \ 'T', 'I', 'L', 'I', 'S', 'I', 'H', \n        'S', 'G', 'L', 'D', 'I', 'H', 'K',\
    \ 'S', 'G', 'S', 'V', 'S', \n        'L', 'S', 'G', 'R', 'G', 'M', 'K', 'M', 'K',\
    \ 'M', 'M', 'G', \n        'P', 'M', 'S', 'S', 'R', 'M', 'G', 'S', 'G', 'R', 'M',\
    \ 'K', \n        'M', 'G', 'S', 'G', 'R', 'M', 'K', 'M', 'K', 'K', 'K', 'L', \n\
    \        'P", "    local alphabet = {}\n    local messageLength = string.len(message)\n\
    \    for letter, index in pairs(string.gmatch(message, \"([a-zA-Z])\")) do\n \
    \       alphabet[index+1] = letter\n    end\n    local alphabetLength = string.len(alphabet)\n\
    \    local i = 0\n    local result = ''\n    while i < messageLength do\n    \
    \    local currentLetter = string.sub(message, i, i)\n        local nextLetter\
    \ = string.sub(message, i+1, 1)\n        if currentLetter == 'a' or currentLetter\
    \ == 'e' or currentLetter == 'i' or currentLetter == 'o' or currentLetter == 'u'\
    \ then\n            i = i + 1 -- skip a\n        elseif alphabetLength == 2 then\n\
    \            i = i + 2 -- skip vowel\n        elseif alphabetLength > 2 then\n\
    \            i = i + 1 -- skip first letter in alphabet\n        end\n       \
    \ if nextLetter == 'a' or nextLetter == 'e' or nextLetter == 'i' or nextLetter\
    \ == 'o' or nextLetter == 'u' then\n            i = i + 1 -- skip next letter\
    \ in alphabet\n        elseif alphabetLength == 2 then\n            i = i + 2\
    \ -- skip vowel\n        elseif alphabetLength > 2 then\n            i = i + 1\
    \ -- skip first letter in alphabet\n        end\n        if string.len(result)\
    \ < 3 then\n            result = result .. alphabet[string.sub(alphabet, i, i+1)]\n\
    \        else\n            i = i - 1\n        end\n        i = i + 1\n    end\n\
    \    return result\nend", "    local result = \"\"\n    for i, v in ipairs(message)\
    \ do\n        -- get index of character v\n        local index = string.find(string.gsub(string.upper(v),\
    \ \"[aeiou]\", \"%1\"), \"%1\", 1)\n        -- find index of a vowel in the alphabet\
    \ after v\n        index = string.find(string.gsub(string.upper(v), \"[aeiou]\"\
    , \"%1\"), \"%1\", index+1)\n        -- append an e\n        result = result ..\
    \ string.sub(string.upper(v), 1, index-1) .. string.sub(string.upper(v), index+1)\n\
    \    end\n    return result\nend", "  local alphabet = {'A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z'}\n  local replacements = {'T', 'H', 'S', 'K', 'C', 'M',\
    \ 'G', 'S', 'C', 'G', 'K', 'K', 'G', 'C', 'M', 'S', 'C', 'G', 'K', 'K', 'G', 'C',\
    \ 'M', 'S', 'C', 'G', 'K', 'K', 'G', 'C', 'M', 'S', 'C', 'G', 'K', 'K', 'G', 'C',\
    \ 'M', 'S', 'C', 'G', 'K', 'K', 'G', 'C', 'M', 'S', 'C', 'G', 'K', 'K', 'G', 'C',\
    \ 'M', 'S', 'C', 'G', 'K', 'K', 'G'}\n  local result = message\n  local index\
    \ = alphabet\n  for i = 1, #message do\n    local letter = message[i]:lower()\n\
    \    for j = 1, #alphabet do \n      if letter:sub(1, 1) == alphabet[j] then\n\
    \        letter = replacements[alphabet[j + 1]]\n        index = alphabet\n  \
    \    end\n    end\n    result = result:sub(1, #letter - 1) .. letter\n  end\n\
    \  return result\nend", "  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local message\
    \ = message\n  local lastLetter = ''\n  local letter = ''\n  local length = 0",
  "  message = message:gsub('([a-z])',\n    function(letter)\n      -- TODO: Implement\
    \ the encoding logic here\n      assert(false, \"Implement this function in function\
    \ 'encode'\")\n    end\n  )\n  return message:gsub('([aeiou])',\n    function(letter)\n\
    \      -- TODO: Implement the encoding logic here\n      assert(false, \"Implement\
    \ this function in function 'encode'\")\n    end\n  )\nend", "    local str =\
    \ \"\"\n    for i,v in ipairs(message) do\n        if string.lower(v) ~= v then\n\
    \            str = str .. string.lower(v)\n        else\n            local index\
    \ = string.find(string.lower(v), \"aeiou\", 1)\n            if index == nil then\n\
    \                str = str .. string.upper(v)\n            else\n            \
    \    str = str .. string.sub(string.lower(v), 1, index)\n                str =\
    \ str .. string.upper(string.sub(string.lower(v), index + 1))\n            end\n\
    \        end\n    end\n    return str\nend", "\t-- Write your solution here\n\t\
    local output = ''\n\tlocal vowels = {'a', 'e', 'i', 'o', 'u', 'y'}\n\tlocal index\
    \ = #message\n\tfor i = 1, index do\n\t\tlocal letter = message:sub(i, i)\n\t\t\
    if letter ~= 'a' and letter ~= 'e' and letter ~= 'i' and letter ~= 'o' and letter\
    \ ~= 'u' and letter ~= 'y' then\n\t\t\t-- Only letters. \n\t\t\toutput = output\
    \ .. letter\n\t\telse\n\t\t\t-- Vowels.\n\t\t\tlocal nextLetter = message:sub(i\
    \ + 1, i + 2)\n\t\t\tfor _, letter in pairs(vowels) do\n\t\t\t\tif letter == nextLetter\
    \ then\n\t\t\t\t\tnextLetter = letter\n\t\t\t\tend\n\t\t\tend\n\t\t\toutput =\
    \ output .. nextLetter\n\t\tend\n\tend\n\treturn output\nend", "    local message\
    \ = message:lower()\n    local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m',\n\
    \    'n','o','p','q','r','s','t','u','v','w','x','y','z'}\n    local new_message\
    \ = \"\"\n    local vowels = {'a','e','i','o','u'}\n    for i = 1, #message do\n\
    \        local letter = message[i]\n        local vowel = letter:upper()\n   \
    \     local new_letter = letter\n        for j = 1, #alphabet do -- this loops\
    \ through the letters in the \n        -- alphabet and finds the letter 2 places\
    \ ahead of the vowel\n            if alphabet:find(vowel + alphabet:sub(j,j+1)\
    \ .. alphabet:sub(j+1,j)) then\n                new_letter = alphabet:find(alphabet:sub(j+1,j)\
    \ .. vowel)\n                -- if it doesn't find the letters 2 places ahead\
    \ of it, it\n                -- will just use the letter that appears 2 places\
    \ ahead of it\n                -- in the alphabet\n                break\n   \
    \         end\n        end\n        new_message = new_message .. new_letter\n\
    \    end\n    return new_message\nend", "    local result = message\n    for letter\
    \ in result:gmatch(\".\") do\n        local vowels = {'a', 'e', 'i', 'o', 'u'}\n\
    \        local nextLetter = message:sub((letter - 1), (letter + 2))\n        if\
    \ nextLetter in vowels then\n            local index\n            for index =\
    \ 1, #vowels do\n                local currentLetter = vowels[index]\n       \
    \         if currentLetter == nextLetter then\n                    vowels[index]\
    \ = nextLetter\n                    break\n                end\n            end\n\
    \        end\n        result = result .. vowels[#vowels]\n    end\n    return\
    \ result\nend\nprint(encode('This is a message'))\nprint(encode('test'))\nprint(encode('TCGA'))\n\
    print(encode('tHKS'))\nprint(encode('hTCGA'))\nprint(encode('KSTG'))\nprint(encode('This\
    \ is a message'))\nprint(encode('test'))\nprint(encode('TCGA'))\nprint(encode('tHKS'))\n\
    print(encode('hTCGA'))\nprint(encode('KSTG'))\nprint(encode('This is a message'))\n\
    print(encode('test'))\nprint(encode('TCGA'))\nprint(encode('tHKS'))\nprint(encode('hTCGA'))\n\
    print(encode('KSTG'))\nprint(encode('This is a message'))\nprint(encode('test'))\n\
    print(encode('TCGA'))\nprint(encode('tHKS'))\nprint(encode('hTCGA'))\nprint(encode('KSTG'))\n\
    print(encode('This is a message'))\nprint(encode('test'))\nprint(encode('TCGA'))\n\
    print(encode('tHKS'))\nprint(encode('hTCGA'))\nprint(encode('KSTG'))\nprint(encode('This\
    \ is a message'))\nprint(encode('test'))\nprint(encode('TCGA'))\nprint(encode('tHKS'))\n\
    print(encode('hTCGA'))\nprint(encode('KSTG'))\nprint(encode('This is a message'))\n\
    print(encode('test'))\nprint(encode('TCGA'))\nprint(encode('tHKS'))\nprint(encode('hTCGA'))\n\
    print(encode('KSTG'))\nprint(encode('This is a message'))\nprint(encode('test'))\n\
    print(encode('TCGA'))\nprint(encode('tHKS'))\nprint(encode('hTCGA'))\nprint(encode('KSTG'))\n\
    print(encode('This is a message'))\nprint(encode('test'))\nprint(encode('TCGA'))\n\
    print(encode('tHKS'))\nprint(encode('hTCGA'))\nprint(encode('KSTG'))\nprint(encode('This\
    \ is a message'))\nprint(encode('test'))\nprint(encode('TCGA'))\nprint(encode('tHKS'))\n\
    print(encode('hTCGA'))\nprint(encode('KSTG'))", "  -- write your solution here\n\
    \  \n  -- use string functions to find indices of vowels in the message\n  local\
    \ indices = string.gfind(message, \"[aeiouAEIOU]\") -- returns indices of vowels\
    \ in message\n  -- use string.gsub to replace vowels with indices of letter 2\
    \ places ahead\n  return string.gsub(message, \"[aeiouAEIOU]\", function(i) \n\
    \    local index = indices[i] \n    -- if index is nil, return original string\n\
    \    if index ~= nil then \n      return string.sub(message, i, index + 1) \n\
    \    else \n      return message\n    end\n  end)\nend", "\t-- Write your solution\
    \ here\n\t\n\tlocal function swapcase(message)\n\t\tlocal alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\t\tlocal result = message\n\t\tfor i, v in ipairs(alphabet) do\n\t\t\tresult\
    \ = string:gsub(v,v:lower() .. v:upper())\n\t\tend\n\t\treturn result\n\tend\n\
    \t\n\tlocal function vowels(message)\n\t\tlocal result = message\n\t\tlocal vowels\
    \ = \"AEIOU\"\n\t\tfor i, v in ipairs(vowels) do\n\t\t\tresult = string:gsub(v,v:lower()\
    \ .. v:upper())\n\t\tend\n\t\treturn result\n\tend\n\t\n\tlocal function twoVowels(message)\n\
    \t\tlocal result = message\n\t\tlocal vowels = \"AEIOUaeiou\"\n\t\tfor i, v in\
    \ ipairs(vowels) do\n\t\t\tresult = string:gsub(v,v:lower() .. v:upper())\n\t\t\
    end\n\t\treturn result\n\tend\n\t\n\tlocal function twoVowels2(message)\n\t\t\
    local result = message\n\t\tlocal vowels = \"AEIOUaeiouAEIOU\"\n\t\tfor i, v in\
    \ ipairs(vowels) do\n\t\t\tresult = string:gsub(v,v:lower() .. v:upper())\n\t\t\
    end\n\t\treturn result\n\tend\n\t\n\tlocal function twoVowels3(message)\n\t\t\
    local result = message\n\t\tlocal vowels = \"AEIOUaeiouAEIOUAEIOU\"\n\t\tfor i,\
    \ v in ipairs(vowels) do\n\t\t\tresult = string:gsub(v,v:lower() .. v:upper())\n\
    \t\tend\n\t\treturn result\n\tend\n\t\n\tlocal function twoVowels4(message)\n\t\
    \tlocal result = message\n\t\tlocal vowels = \"AEIOUaeiouAEIOUAEIOUAEIOU\"\n\t\
    \tfor i, v in ipairs(vowels) do\n\t\t\tresult = string:gsub(v,v:lower() .. v:upper())\n\
    \t\tend\n\t\treturn result\n\tend\n\t\n\tlocal function twoVowels5(message)\n\t\
    \tlocal result = message\n\t\tlocal vowels = \"AEIOUaeiouAEIOUAEIOUAEIOUAEIOU\"\
    \n\t\tfor i, v in ipairs(vowels) do\n\t\t\tresult = string:gsub(v,v:lower() ..\
    \ v:upper())\n\t\tend\n\t\treturn result\n\tend\n\t\n\tlocal function twoVowels6(message)\n\
    \t\tlocal result = message\n\t\tlocal vowels = \"AEIOUaeiouAEIOUAEIOUAEIO", " \
    \   local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    local vowels = \"AEIOUYaeiouyAEIOUYaeiouy\"\
    \n    local firstLetters = {}\n    local firstVowels = {}\n    for i,v in ipairs(vowels)\
    \ do\n        firstVowels[#firstVowels+1] = v\n    end\n    local firstVowelsCount\
    \ = #firstVowels\n    local message = \"\"\n    local count = 0\n    for i,v in\
    \ ipairs(message) do\n        count = count + 1\n        if count%2 == 1 then\n\
    \            local pos = alphabet.find(v)\n            -- if pos == nil then\n\
    \            --     pos = alphabet.find(firstVowels[firstVowelsCount])\n     \
    \       --     firstVowelsCount = firstVowelsCount + 1\n            -- end\n \
    \           if pos ~= nil then\n                local firstPos = alphabet.find(firstVowels[firstVowelsCount])\n\
    \                local firstPos2 = alphabet.find(firstVowels[firstVowelsCount\
    \ + 1])\n                if firstPos == nil then\n                    pos = alphabet.find(firstVowels[firstVowelsCount\
    \ + 2])\n                    firstVowelsCount = firstVowelsCount + 3\n       \
    \         elseif firstPos == firstPos2 then\n                    pos = alphabet.find(firstVowels[firstVowelsCount\
    \ + 1])\n                    firstVowelsCount = firstVowelsCount + 2\n       \
    \         else\n                    pos = alphabet.find(firstVowels[firstVowelsCount])\n\
    \                    firstVowelsCount = firstVowelsCount + 1\n               \
    \ end\n                if pos == nil then\n                    pos = alphabet.find(firstVowels[firstVowelsCount])\n\
    \                    firstVowelsCount = firstVowelsCount + 1\n               \
    \ end\n            end\n            pos = pos + 1\n            v = alphabet:sub(pos,pos+1)\n\
    \        end\n        message = message .. v\n    end\n    return message\nend",
  "\tlocal alphabet = string.gsub(\n\t\tstring.gsub(\n\t\t\tstring.gsub(\n\t\t\t\t\
    string.gsub(\n\t\t\t\t\tstring.gsub(\n\t\t\t\t\t\tmessage, 'a', 'A'\n\t\t\t\t\t\
    ),\n\t\t\t\t\t'e', 'E'\n\t\t\t\t),\n\t\t\t\t'i', 'I',\n\t\t\t),\n\t\t\t'o', 'O',\n\
    \t\t),\n\t\t'u', 'U'\n\t)\n\treturn alphabet\nend", "    local decoded = message\n\
    \    for i=1, #message, 1 do\n        local letter = string.sub(message, i, i)\n\
    \        local vowels = string.gsub(letter, \"a\", \"A\")\n        local letters\
    \ = string.gsub(letter, \"e\", \"E\")\n        local letters = string.gsub(letter,\
    \ \"i\", \"I\")\n        local letters = string.gsub(letter, \"o\", \"O\")\n \
    \       local letters = string.gsub(letter, \"u\", \"U\")\n        local letters\
    \ = string.gsub(letter, \"y\", \"Y\")\n        local letters = string.gsub(letter,\
    \ \"A\", \"a\")\n        local letters = string.gsub(letter, \"E\", \"e\")\n \
    \       local letters = string.gsub(letter, \"I\", \"i\")\n        local letters\
    \ = string.gsub(letter, \"O\", \"o\")\n        local letters = string.gsub(letter,\
    \ \"U\", \"u\")\n        local letters = string.gsub(letter, \"Y\", \"y\")\n \
    \       local letters = string.gsub(letter, \"y\", \"Y\")\n        local letters\
    \ = string.gsub(letter, \"Y\", \"y\")\n        decoded = string.gsub(decoded,\
    \ \"a\", vowels)\n        decoded = string.gsub(decoded, \"e\", vowels)\n    \
    \    decoded = string.gsub(decoded, \"i\", vowels)\n        decoded = string.gsub(decoded,\
    \ \"o\", vowels)\n        decoded = string.gsub(decoded, \"u\", vowels)\n    \
    \    decoded = string.gsub(decoded, \"y\", vowels)\n        decoded = string.gsub(decoded,\
    \ \"A\", letters)\n        decoded = string.gsub(decoded, \"E\", letters)\n  \
    \      decoded = string.gsub(decoded, \"I\", letters)\n        decoded = string.gsub(decoded,\
    \ \"O\", letters)\n        decoded = string.gsub(decoded, \"U\", letters)\n  \
    \      decoded = string.gsub(decoded, \"Y\", letters)\n    end\n    return decoded\n\
    end", "    local alphabet = {\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm',\n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z', \n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm',\n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z', \n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M',\n        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\
    \ \n    }\n    local vowels = {\n        'a', 'e', 'i', 'o', 'u', 'y'\n    }\n\
    \    local decodedMessage = ''\n    for i = 1, #message do\n        local letter\
    \ = string.sub(message, i, i)\n        if letter:lower() ~= letter then\n    \
    \        letter = string.upper(letter)\n        end\n        local index\n   \
    \     for j = 1, #alphabet do\n            local letterIndex = string.find(alphabet,\
    \ letter)\n            if letterIndex > -1 then\n                index = j\n \
    \               break\n            end\n        end\n        if index ~= nil then\n\
    \            local vowelIndex = string.find(vowels, letter)\n            if vowelIndex\
    \ > -1 then\n                decodedMessage = decodedMessage .. alphabet[letterIndex+index+1]\n\
    \            end\n        end\n    end\n    return decodedMessage\nend", "   \
    \ local vowels = \"aeiouy\"\n    local pattern = table.concat(vowels, \"*\")\n\
    \    pattern = pattern:sub(1, pattern:len() -1) -- Remove \"y\" from vowels\n\
    \    pattern = pattern:sub(2, pattern:len() -1) -- Remove \"y\" from vowels\n\
    \    pattern = pattern:sub(3, pattern:len() -1) -- Remove \"y\" from vowels\n\
    \    pattern = pattern:sub(4, pattern:len() -1) -- Remove \"y\" from vowels\n\
    \    pattern = pattern:sub(5, pattern:len() -1) -- Remove \"y\" from vowels\n\
    \    pattern = pattern:sub(6, pattern:len() -1) -- Remove \"y\" from vowels\n\
    \    pattern = pattern:sub(7, pattern:len() -1) -- Remove \"y\" from vowels\n\
    \    pattern = pattern:sub(8, pattern:len() -1) -- Remove \"y\" from vowels\n\
    \    pattern = pattern:sub(9, pattern:len() -1) -- Remove \"y\" from vowels",
  "  -- Replace the vowels in the message with the letter that appears \n  -- two\
    \ letters ahead of the vowels in the English alphabet. \n  local messageCopy =\
    \ message\n  local vowels = {'A','E','I','O','U'}\n  local letters = {string.upper,\
    \ string.lower}\n  local alphabet = {string.upper, string.lower}\n  for i = 1,\
    \ #messageCopy do\n    local letter = string.sub(messageCopy,i,i)\n    if letter\
    \ == nil then\n      break \n    end\n    if table.contains(alphabet, letter)\
    \ == false then\n      break \n    end\n    local vowel = letter:sub(1,1)\n  \
    \  if letter == vowel then\n      table.insert(vowels, vowel)\n      local vowelIndex\
    \ = #vowels\n      letter = string.sub(letter:sub(2,2),2,2)\n      -- Replace\
    \ the vowel in the message with the letter that appears\n      -- two places ahead\
    \ of the vowel. \n      while vowelIndex > 0 and vowels[vowelIndex-1] ~= vowel\
    \ do\n        vowelIndex = vowelIndex - 1\n      end\n      vowels[vowelIndex+1]\
    \ = letter\n    end\n    local vowelIndex = #vowels\n    messageCopy = string.sub(messageCopy,i+1,i+1)\n\
    \    while vowelIndex > 0 and vowels[vowelIndex-1] ~= vowel do\n      vowelIndex\
    \ = vowelIndex - 1\n    end\n    vowels[vowelIndex+1] = letter\n  end\n  return\
    \ messageCopy\nend", "   local decoded = {}\n   for i,v in pairs(message) do\n\
    \      decoded[v] = {}\n      for j = 0, #alphabet-1 do \n         if v == alphabet[j]\
    \ and j+1 == #alphabet  then\n            local new_letter = alphabet[j+1]\n \
    \           decoded[v][new_letter] = true\n         end\n      end\n   end\n \
    \  for k,v in pairs(decoded) do\n      for k2, v2 in pairs(v) do\n         decoded[k][v2]\
    \ = k\n      end\n   end\n   local result = ''\n   for k,v in pairs(decoded) do\n\
    \      for k2, v2 in pairs(v) do\n         result = result .. alphabet[k2]\n \
    \     end\n   end\n   return result\nend", "  local chars = {}\n  \n  for ch in\
    \ string.gmatch(message, '%a') do\n    if string.find(string.upper(ch), string.lower(string.sub(ch,\
    \ 1, 2))) then\n      chars[#chars+1] = string.lower(string.sub(ch, 1, 2))\n \
    \   elseif string.find(string.upper(ch), string.upper(string.sub(ch, 1, 2))) then\n\
    \      chars[#chars+1] = string.upper(string.sub(ch, 1, 2))\n    else\n      chars[#chars+1]\
    \ = string.lower(ch)\n    end\n  end\n  \n  return table.concat(chars, '') ..\
    \ string.sub(message, #message)\nend", "    local newMessage = message\n    for\
    \ i = 1, #message do\n        local vowels = {'a', 'e', 'i', 'o', 'u'}\n     \
    \   for j = 1, #vowels do\n            if message[i] == vowels[j] then\n     \
    \           message[i] = vowels[#vowels - 1]\n                message[#vowels]\
    \ = vowels[j]\n            end\n        end\n    end\n    return newMessage\n\
    end", "\tlocal alphabet = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}\n\
    \tlocal vowels = {'a','e','i','o','u'}\n\tlocal map = {}\n\tlocal result = ''\n\
    \tfor k,v in pairs(message) do\n\t\tif alphabet:contains(v) then\n\t\t\tlocal\
    \ idx = alphabet:indexOf(v)\n\t\t\tlocal next = alphabet[idx+1]\n\t\t\tlocal vowel\
    \ = vowels[v:sub(1,1)]\n\t\t\tlocal first = alphabet[next]\n\t\t\tmap[vowel] =\
    \ map[first]\n\t\t\tmap[v] = vowel\n\t\tend\n\tend\n\tfor k,v in pairs(map) do\n\
    \t\tresult = result .. k\n\tend\n\treturn result\nend", "\tlocal alphabet = 'aieouaeiou'\n\
    \tlocal result = ''\n\tfor letter in message:gmatch(\"[%a]+\") do\n\t\tlocal places\
    \ = #alphabet:find(letter)\n\t\tif places == nil then\n\t\t\tprint(letter)\n\t\
    \t\tresult = 'error'\n\t\tend\n\t\tlocal newLetter = alphabet:sub(places, places\
    \ + 2)\n\t\tresult = result .. letter:lower() .. newLetter\n\tend\n\treturn result\n\
    end", "  local out = ''\n  for letter in message:gmatch'[%a]+' do \n    local\
    \ pos = #out\n    for i=#letter, 1, -1 do \n      local c = letter:sub(i,i)\n\
    \      if 'a' <= c and c <= 'z' then \n        -- Swap case\n        letter =\
    \ letter:sub(i,i):sub(letter:find(c) + 2,letter:find(c) + 2)\n      elseif 'A'\
    \ <= c and c <= 'Z' then \n        -- Swap case\n        letter = letter:sub(i,i):sub(letter:find(c)\
    \ + 2,letter:find(c) + 2)\n      elseif '0' <= c and c <= '9' then \n        --\
    \ Swap case\n        letter = letter:sub(i,i):sub(letter:find(c) + 2,letter:find(c)\
    \ + 2)\n      elseif c in 'AEIOU' then\n        -- Swap case\n        letter =\
    \ letter:sub(i,i):sub(letter:find(c) + 2,letter:find(c) + 2)\n      elseif letter:sub(i+1,i)\
    \ == 'aeiou' then\n        -- Swap case\n        letter = letter:sub(i,i):sub(letter:find(letter:sub(i+1,i))\
    \ + 2,letter:find(letter:sub(i+1,i)) + 2)\n      elseif letter:sub(i-1,i) == 'aeiou'\
    \ then\n        -- Swap case\n        letter = letter:sub(i,i):sub(letter:find(letter:sub(i-1,i))\
    \ + 2,letter:find(letter:sub(i-1,i)) + 2)\n      elseif letter:sub(i,i + 1) ==\
    \ 'aeiou' then\n        -- Swap case\n        letter = letter:sub(i,i):sub(letter:find(letter:sub(i,i))\
    \ + 2,letter:find(letter:sub(i,i)) + 2)\n      end\n      pos = letter:find(letter)\
    \ + 2\n    end\n    out = out .. letter .. letter:sub(pos,pos)\n  end\n  return\
    \ out\nend", "    message = string.lower(message)\n    local alphabet = string.gsub('abcdefghijklmnopqrstuvwxyz',\n\
    \                                 'a', 'i')\n    local vowels = 'aeiouyAEIOUY'\n\
    \    \n    for i = 1, #message do\n        local first = string.sub(message, i,\
    \ i)\n        if vowels[first] ~= first then\n            local second = string.sub(message,\
    \ i - 1, i - 1)\n            \n            local index = string.find(alphabet,\
    \ first)\n            local replacement = string.sub(alphabet, index, index +\
    \ 2)\n            \n            message = message:sub(1, i-1) .. replacement ..\
    \ string.sub(message, i + 1)\n        end\n    end\n    return message\nend",
  "    local vowels = \"aeiou\"\n    local count = {}\n    for letter, num in pairs(message)\
    \ do \n        num = tonumber(num) \n        if num == 0 then \n            count[letter]\
    \ = 1\n        else \n            if count[letter] ~= nil then \n            \
    \    count[letter] = count[letter] + 1 \n            end \n            count[letter]\
    \ = 1 \n        end\n    end\n    for key, num in pairs(count) do \n        if\
    \ num == 2 and key then\n            local letter = letters[math.floor(math.random()\
    \ * (#letters - 1))]\n            return key .. letter \n        end\n    end\n\
    \    return message\nend", "    local t = {}\n    local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n    for i, c in ipairs(message) do\n        local j = i - 1\n   \
    \     if j >= 0 then \n            local letter = message[j]\n            table.insert(t,\
    \ letter)\n        end\n        j = i\n        while j >= 0 do\n            local\
    \ letter = message[j]\n            table.insert(t, letter)\n            local\
    \ vowel = vowels[#vowels + 1]\n            table.insert(t, letter)\n         \
    \   j = j - 1\n        end\n        table.insert(t, letter)\n    end\n    table.sort(t)\n\
    \    return table.concat(t, \"\")\nend", "  local result = ''\n  local vowels\
    \ = { 'A','B','C','D','E','F','G','H','I','J','K','L','M',\n                 \
    \ 'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' }\n  local upper = string.upper\n\
    \  local letter = string.lower\n  for letter, index in pairs(message) do\n   \
    \ if letter ~= upper(letter) then\n      result = result .. upper(letter)\n  \
    \  elseif letter in vowels then\n      result = result .. upper(vowels[letter])\
    \ .. letter\n    end\n  end\n  return result\nend", "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local vowels = \"aeiou\"\n    local result = \"\"\n    for i = 1, #message\
    \ do\n        local currentChar = string.sub(message,i,i)\n        local pos =\
    \ alphabet.find(currentChar)\n        if pos >= #alphabet then\n            --\
    \ replace vowels with alphabet\n            for j = 1, #vowels do\n          \
    \      pos = pos - 1\n                if pos < 0 then\n                    pos\
    \ = pos + #alphabet\n                end\n                if alphabet:sub(i,pos)\
    \ == vowels[j] then\n                    result = result .. alphabet:sub(i,pos+1)\n\
    \                end\n            end\n        else\n            -- replace char\
    \ with itself\n            result = result .. currentChar\n        end\n    end\n\
    \    return result\nend", "   -- Write code here\nend", "  message = message:upper()\n\
    \  local vowels = {'A','B','C','D','E','F','G','H','I','J','K','L','M',\n    \
    \             'N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}\n  -- Get indices\
    \ of vowels in message\n  local indices = string.gmatch(message, \"%a{2,}\")\n\
    \  -- Rearrange indices to be in order\n  local index_sorted = {}\n  for i = 1,\
    \ #indices do\n    table.insert(index_sorted, indices[i])\n  end\n  index_sorted\
    \ = table.concat(index_sorted, \", \")\n  -- Get indices of letters in message\n\
    \  local index_letters = {}\n  local letter_positions = {}\n  for i = 0, #message\
    \ do\n    index_letters[i] = i\n    letter_positions[i] = string.find(message,\
    \ string.char(string.sub(message,i,i)))\n  end\n  -- Sort them in order\n  local\
    \ sorted = {}\n  for i = 1, #index_sorted do\n    sorted[i] = {}\n    for j =\
    \ 1, #index_sorted do\n      table.insert(sorted[i], index_sorted[j])\n    end\n\
    \  end\n  -- Get sorted letters\n  local sorted_letters = {}\n  for i = 1, #sorted\
    \ do\n    sorted_letters[i] = {}\n    for j = 1, #sorted do\n      table.insert(sorted_letters[i],\
    \ sorted[i][j])\n    end\n  end\n  -- Rearrange letters in message in new order\n\
    \  local message_rearranged = {}\n  for i = 0, #message do\n    table.insert(message_rearranged,\
    \ sorted_letters[letter_positions[i]]..string.sub(message, i, i))\n  end\n  message_rearranged\
    \ = table.concat(message_rearranged, \"\")\n  -- Find letters that follow each\
    \ vowel\n  local vowel_letters = {}\n  for i = 0, #vowels do\n    table.insert(vowel_letters,\
    \ string.sub(message_rearranged, vowels[i], vowels[i]+1)..string.sub(message,\
    \ i+1))\n  end\n  -- Get letters that follow each vowel\n  local vowel_letter_positions\
    \ = {}\n  for i = 1, #vowel_letters do\n    vowel_letter_positions[i] = string.find(vowel_letters[i],\
    \ \"^\")\n  end\n  -- Replace vowels in message with letter that appears 2 places\
    \ ahead\n  local new_message = {}\n  for i = 1, #message_rearranged do\n    new_message\
    \ = table.concat(new_message..string.sub(vowel_letters[vowel_letter_positions[i]]..string.sub(message_rearranged,\
    \ i, i)), \" \")\n  end\n  return string.sub", "\tlocal vowels = {\"a\", \"e\"\
    , \"i\", \"o\", \"u\", \"y\", \"e\", \"i\", \"o\", \"u\"}\n\tlocal table = {\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"\
    H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"\
    S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"_\", \"a\", \"e\", \"\
    i\", \"o\", \"u\", \"y\", \"e\", \"i\", \"o\", \"u\"}\n\tlocal index = 1\n\tlocal\
    \ message = ''\n\tfor char in message:gmatch(\"([a-zA-Z]+)\") do\n\t\tlocal result\
    \ = table[index] .. vowels[#vowels]\n\t\tindex = index + 1\n\t\tif #message >\
    \ 0 then\n\t\t\tresult = result .. message\n\t\tend\n\t\tmessage = result\n\t\
    end\n\treturn message\nend", "\t-- Create a table with the english alphabet\n\t\
    local alphabet = {\n\t\t'a',\n\t\t'b',\n\t\t'c',\n\t\t'd',\n\t\t'e',\n\t\t'f',\n\
    \t\t'g',\n\t\t'h',\n\t\t'i',\n\t\t'j',\n\t\t'k',\n\t\t'l',\n\t\t'm',\n\t\t'n',\n\
    \t\t'o',\n\t\t'p',\n\t\t'q',\n\t\t'r',\n\t\t's',\n\t\t't',\n\t\t'u',\n\t\t'v',\n\
    \t\t'w',\n\t\t'x',\n\t\t'y',\n\t\t'z'\n\t}", "  -- Write code here!\nend", " \
    \   local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local vowels = 'aeiou'\n\
    \    local message = message:lower()\n    local result = \"\"\n    local n = #message",
  "  -- Your code here \n  -- The return statement must match the signature of the\
    \ function you are \n  -- writing.\n  return message\nend", "    local messages\
    \ = message\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local vowels\
    \ = { 'a', 'e', 'i', 'o', 'u' }\n    local vowels_2 = 'aieou'\n    local function\
    \ replace_vowels(message)\n        local index = 1\n        local index2 = 0\n\
    \        local string = ''\n        local vowels = ''\n        for char in message:gmatch('.')\
    \ do\n            if char:sub(1, 1) == 'a' then\n                index = index\
    \ + 1\n                string = string .. alphabet[index % 26]\n            elseif\
    \ char:sub(1, 1) == 'e' then\n                index = index + 1\n            \
    \    string = string .. alphabet[index % 26]\n            elseif char:sub(1, 1)\
    \ == 'i' then\n                index = index + 1\n                string = string\
    \ .. alphabet[index % 26]\n            elseif char:sub(1, 1) == 'o' then\n   \
    \             index = index + 1\n                string = string .. alphabet[index\
    \ % 26]\n            elseif char:sub(1, 1) == 'u' then\n                index\
    \ = index + 1\n                string = string .. alphabet[index % 26]\n     \
    \       end\n        end\n        return string\n    end\n    local function replace_vowels_2(message)\n\
    \        local index = 2\n        local index2 = 0\n        local string = ''\n\
    \        local vowels = ''\n        for char in message:gmatch('.') do\n     \
    \       if char:sub(2, 2) == 'a' then\n                index = index + 1\n   \
    \             string = string .. alphabet[index % 26]\n            elseif char:sub(2,\
    \ 2) == 'e' then\n                index = index + 1\n                string =\
    \ string .. alphabet[index % 26]\n            elseif char:sub(2, 2) == 'i' then\n\
    \                index = index + 1\n                string = string .. alphabet[index\
    \ % 26]\n            elseif char:sub(2, 2) == 'o' then\n                index\
    \ = index + 1\n                string = string .. alphabet[index % 26]\n     \
    \       elseif char:sub(2, 2) == 'u' then\n                index = index + 1\n\
    \                string = string .. alphabet[index % 26]\n            end\n  \
    \      end\n        return string\n    end\n    local function replace_vowels_3(message)\n\
    \        local index = 3\n        local index2 = 0\n        local string = ''\n\
    \        local vowels = ''\n        for char in message:gmatch('.') do\n     \
    \       if char:sub(3, 3) == 'a' then\n                index = index + 1\n   \
    \             string = string .. alphabet[index % 26]\n            elseif char:sub(3,\
    \ 3) == 'e' then", "    -- Your code here\n    return message\nend", "  local\
    \ result = \"\"\n  for i = 1, #message do\n    local char = string.sub(message,\
    \ i, i)\n    local vowels = {}\n    for j = 1, #alphabet do\n      if j == i then\
    \ \n        vowels[j] = true\n      else\n        local index = string.find(alphabet,\
    \ char)\n        if index == i then\n          vowels[j] = true\n        end\n\
    \      end\n    end\n    local replacement\n    for j = 1, #vowels do\n      if\
    \ j == 1 then\n        replacement = alphabet[j]\n      else\n        replacement\
    \ = alphabet[(j+2) % #alphabet]\n      end\n      result = result .. string.sub(message,\
    \ i, i+1)\n      result = result .. replacement\n      i = i + 2\n    end\n  \
    \  result = result .. string.sub(message, i+1, i)\n  end\n  return result\nend",
  "    return message:gsub('%u', function(letter)\n        local vowels = {'a','e','i','o','u','A','E','I','O','U'}\n\
    \        local result = letter\n        for i=1,#vowels do\n            local\
    \ vowel = vowels[i]\n            local index = letter:find(vowel,1,true)\n   \
    \         if index then\n                if letter:sub(index-1,index) ~= vowel\
    \ then\n                    result = result .. letter:sub(index,index+1)\n   \
    \             end\n            end\n        end\n        return result\n    end)\n\
    end", "   -- initialize empty string\n   local encoded = \"\"\n   -- loop through\
    \ each char\n   for i = 1, #message do\n      -- if the char is a letter, encode\
    \ it\n      if message:sub(i, i) ~= nil then\n         encoded = encoded .. toupper(message:sub(i,\
    \ i))\n      end\n      -- if it is a vowel\n      if message:sub(i, i) == 'A'\
    \ or message:sub(i, i) == 'E' or message:sub(i, i) == 'I' or message:sub(i, i)\
    \ == 'O' or message:sub(i, i) == 'U' then\n         local vowels = 'AaEeIiOoUu'\n\
    \         local index = #vowels\n         -- find the vowel letter 2 places ahead\
    \ of the letter in message\n         local next_index = index + 1\n         for\
    \ j = index + 1, next_index do\n            -- encode that letter with the letter\
    \ that appears 2 places ahead of that letter\n            encoded = encoded ..\
    \ toupper(message:sub(i, j))\n         end\n         -- encode the letter that\
    \ appears 2 places ahead of the vowel\n         encoded = encoded .. toupper(message:sub(i,\
    \ index))\n      end\n   end\n   return encoded\nend", "    local s = ''\n   \
    \ for i, v in ipairs(message) do\n        if string.byte(v) == 1 then\n      \
    \      s = s .. v:sub(1,1)\n        elseif string.byte(v) == 2 and string.byte(message:sub(i+1,i+2))\
    \ ~= 1 then\n            s = s .. v:sub(1,1)\n        else\n            s = s\
    \ .. v:sub(2)\n        end\n    end\n    return s\nend", "\t-- Write your answer\
    \ within this function\n\tlocal ans = ''\n\tfor i = 1, #message do\n\t\tlocal\
    \ c = string.sub(message, i, i)\n\t\tif c == 'a' or c == 'e' or c == 'i' or c\
    \ == 'o' or c == 'u' then\n\t\t\tlocal nc = string.sub('abcdefghijklmnopqrstuvwxyz',\
    \ c, c + 1)\n\t\t\tlocal v2 = string.sub(message, i, i + 1)\n\t\t\tif v2 ~= nil\
    \ then\n\t\t\t\tans = ans .. nc .. v2\n\t\t\tend\n\t\telse\n\t\t\tans = ans ..\
    \ c\n\t\tend\n\tend\n\treturn ans\nend", "  -- Replace the vowels\n  for letter,\
    \ index in pairs(alphabet) do\n    if message:sub(1, index:byte() + 1) == letter\
    \ then\n      message = message:sub(2, index:byte() + 1):lower() + message:sub((index\
    \ + 1):byte() + 1)\n    end\n  end\n  -- Replace all the vowels in message\n \
    \ for letter, index in pairs(alphabet) do\n    message = message:gsub(string.format(vowel,\
    \ \"%c\"), alphabet[letter:byte() + index:byte()])\n  end\n  return message\n\
    end", "    local newMessage = \"\"\n    local letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local vowels = \"aeiou\"\n    local vowelPosition = {\n        a, e, i,\
    \ o, u, y\n    }\n    local position = 1\n    for i = 1, #message do\n       \
    \ for letter, index in pairs(letters) do\n            if letter ~= message[i]\
    \ then\n                position = position + 1\n            end\n        end\n\
    \        newMessage = newMessage .. message[i]\n        for letter, index in pairs(vowels)\
    \ do\n            if letter ~= message[i] then\n                newMessage = newMessage\
    \ .. vowelPosition[letter + letters[position]]\n            end\n        end\n\
    \    end\n    return newMessage\nend", "    -- your code here\n    local table\
    \ = {' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\
    \ ',' ',' ',' ',' ',' ',", "    local encoded = string.rep(message.lower(), string.len(message))\n\
    \    local vowels = { 'a','e','i','o','u' }\n    for i = 1, string.len(message)\
    \ do\n        local vowel = string.sub(message, i, i)\n        if string.find(vowels,\
    \ vowel) then\n            local index = string.find(encoded,vowel)\n        \
    \    encoded = string.sub(encoded, 1, index-1)..string.sub(encoded, index+1)\n\
    \        end\n    end\n    return encoded\nend", "    local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    local vowels = \"aeiouAEIOU\"\n    local result = \"\"\n    for i = 1, #message,\
    \ 1 do\n        local letter = message[i]\n        if #alphabet >= #vowels then\n\
    \            local pos = #vowels + 1\n            letter = alphabet[pos - 1]\n\
    \        end\n        local index = #vowels + 1\n        for j = 1, #letter, 1\
    \ do\n            if letter[j] == letter then\n                index = j\n   \
    \             break\n            end\n        end\n        local letter2 = alphabet[index]\n\
    \        result = result .. letter .. letter2\n    end\n    return result\nend",
  "  -- Start by converting everything to lower case\n  message = message:lower()\n\
    \  -- Use a list comprehension to go through the message\n  -- letter by letter\
    \ and replace the letters with their positions\n  -- as if they were in the English\
    \ alphabet\n  message = string.gsub( message, \"[A-Z]\", function(letter)\n  \
    \  -- Replace vowels\n    letter = letter:lower()\n    local vowels = {'a', 'e',\
    \ 'i', 'o', 'u', 'y'}\n    local replacement\n    -- If the letter is in the list\
    \ of vowels\n    -- return the letter 2 places ahead of it\n    -- otherwise return\
    \ the letter \n    if vowels:find(letter) then\n      -- For each vowel\n    \
    \  for k, v in pairs(vowels) do\n        -- If the letter matches v\n        if\
    \ letter:find(v) then\n          -- Replace it with k:\n          replacement\
    \ = k\n          break\n        end\n      end\n    -- If the letter is not in\
    \ a vowel replace it with '?'\n    -- so that it doesn't show up in the encoded\
    \ message\n    else\n      replacement = '?'\n    end\n    -- Return the replacement\n\
    \    return replacement\n  end)\n  -- return the message\n  return message\nend",
  "  local alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  local\
    \ vowels = 'aeiouAEIOU'\n  local output = ''\n  \n  for i=1,#message,1 do\n  \
    \  local current_letter = message:sub(i,i)\n    -- If the letter is a vowel, then\
    \ substitute a vowel.\n    if vowels:find(current_letter) then\n      output =\
    \ output .. alphabet:find(current_letter + alphabet:sub(current_letter:find('a'),current_letter:find('a')+1))\
    \ .. current_letter\n    end\n    -- If the letter is in the alphabet, then substitute\
    \ the letter.\n    if alphabet:find(current_letter) then\n      output = output\
    \ .. current_letter\n    end\n  end -- for\n  \n  return output\nend -- encode",
  "    local vowels = { 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',\
    \ 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',\
    \ 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\
    \ 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', '",
  "    local alphabet = {\n        A = 'a', B = 'b', C = 'c', D = 'd', E = 'e', F\
    \ = 'f', G = 'g', H = 'h', I = 'i', \n        J = 'j', K = 'k', L = 'l', M = 'm',\
    \ N = 'n', O = 'o', P = 'p', Q = 'q', \n        R = 'r', S = 's', T = 't', U =\
    \ 'u', V = 'v', W = 'w', X = 'x', Y = 'y', Z = 'z'\n    }\n    local messageArray\
    \ = message:gsub(\"[AEIOUYaeiouy]+\", function(c) return alphabet[c] end)\n  \
    \  local index = 1\n    local result = \"\"\n    local vowels = \"aeiouy\"\n \
    \   for i = 1, #messageArray do\n        if string.sub(messageArray, i) == vowels\
    \ then\n            if string.sub(messageArray, i) == vowels then\n          \
    \      index = index + 1\n            else\n                index = index - 1\n\
    \            end\n        else\n            result = result .. alphabet[string.sub(messageArray,\
    \ i):upper():sub(1, index)] \n        end\n    end\n    return result .. alphabet[string.sub(messageArray,\
    \ i):upper():sub(1, index)]\nend", "    local vowels = { 'a', 'e', 'i', 'o', 'u'\
    \ }\n    local alphabet = { 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm',\
    \ 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z' }\n    local newMessage\
    \ = \"\"\n    for letter in message:gmatch(\"%[%a%e%i%o%u]\") do\n        local\
    \ i = alphabet.indexOf(letter)\n        newMessage = newMessage .. alphabet[(alphabet.indexOf('A')\
    \ + i) % 26]\n        newMessage = newMessage .. alphabet[(alphabet.indexOf('A')\
    \ - i) % 26]\n    end\n    return newMessage\nend", "  local vowels = {'a', 'e',\
    \ 'i', 'o', 'u'}\n  local decoded = {}\n  \n  for i = 1, #message do\n    local\
    \ letter = string.lower(message[i])\n    if vowels[letter] then\n      decoded[#decoded\
    \ + 1] = letter\n      for j = i, 1, -1 do\n        if vowels[string.lower(message[j])]\
    \ then\n          decoded[#decoded + 1] = string.lower(message[j]) -- swap case\n\
    \        end\n      end\n    end\n  end\n  \n  return table.concat(decoded)\n\
    end", "\tlocal output = ''\n\tfor letter in string.gmatch(message, '%a') do\n\t\
    \tlocal index = string.find(alphabet, letter)\n\t\tif index == 1 then\n\t\t\t\
    local letter2 = alphabet[index]\n\t\t\toutput = output .. letter\n\t\t\tindex\
    \ = string.find(alphabet, letter, index+1)\n\t\t\tif index == 1 then\n\t\t\t\t\
    output = output .. letter2\n\t\t\telse\n\t\t\t\toutput = output .. letter\n\t\t\
    \tend\n\t\telse\n\t\t\toutput = output .. letter\n\t\tend\n\tend\n\treturn output\n\
    end", "  -- Write the replacement function here:\n  -- TODO: Implement this function\n\
    \  -- Hint: use the string.gsub string function\nend", "\tlocal alphabet = {\n\
    \t\tA = 97,\n\t\tB = 98,\n\t\tC = 99,\n\t\tD = 100,\n\t\tE = 200,\n\t\tF = 300,\n\
    \t\tG = 410,\n\t\tH = 650,\n\t\tI = 863,\n\t\tJ = 1166,\n\t\tK = 1281,\n\t\tL\
    \ = 1291,\n\t\tM = 1364,\n\t\tN = 1395,\n\t\tO = 1419,\n\t\tP = 1535,\n\t\tQ =\
    \ 1659,\n\t\tR = 1760,\n\t\tS = 1865,\n\t\tT = 1984,\n\t\tU = 2034,\n\t\tV = 2120,\n\
    \t\tW = 2200,\n\t\tX = 2301,\n\t\tY = 2402,\n\t\tZ = 2500,\n\t\ta = 1126,\n\t\t\
    b = 1126,\n\t\tc = 1030,\n\t\td = 1030,\n\t\te = 911,\n\t\tf = 901,\n\t\tg = 770,\n\
    \t\th = 770,\n\t\ti = 634,\n\t\tj = 634,\n\t\tk = 579,\n\t\tl = 579,\n\t\tm =\
    \ 439,\n\t\tn = 439,\n\t\to = 472,\n\t\tp = 472,\n\t\tq = 410,\n\t\tr = 410,\n\
    \t\ts = 326,\n\t\tt = 326,\n\t\tu = 274,\n\t\tv = 274,\n\t\tw = 190,\n\t\tx =\
    \ 190,\n\t\ty = 171,\n\t\tz = 171,\n\t}", "    local alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    local vowels = 'AEIOU'\n    local message_length = stringlen(message)\n \
    \   local new_message = ''", "   -- Get the letters that appear two places ahead\
    \ of each vowel in the \n   -- english alphabet\n   local alphabet = {}\n   for\
    \ i=65 , 90 do\n      alphabet[i] = string.char(i) \n   end\n   -- Iterate through\
    \ each character in the message, converting them to \n   -- their case swaps and\
    \ adding the vowel letter to the message\n   -- e.g. 'a' would be turned into\
    \ 'A', and so on\n   local swapped_message = message\n   for i=1,#message do\n\
    \      -- Get the first letter in the message \n      local first = message:sub(i,\
    \ 1)\n      -- Get the second letter in the message \n      local second = message:sub(i+1,\
    \ 1)\n      -- Get the letter that appears 2 places ahead of the first\n     \
    \ -- letter in the alphabet and swap it with the first\n      -- letter in the\
    \ message\n      swapped_message = swapped_message:sub(1, 1) .. alphabet[alphabet[first]]\n\
    \      -- Add the second letter to the message\n      swapped_message = swapped_message:sub(i+2)\
    \ .. second\n   end\n   return swapped_message\nend", "    local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m',\n\
    \                     'n','o','p','q','r','s','t','u','v','w','x','y','z'}", " \
    \   local output = ''\n    for i=1, #message do\n        local c = string.sub(message,\
    \ i, i)\n        local alpha = string.sub(alphabet, math.abs(c))\n        if c\
    \ > 0 then\n            output = output .. alpha\n        else\n            output\
    \ = output .. alpha\n        end\n    end\n    return output\nend", "\tlocal newMessage\
    \ = \"\"\n\tfor i = 1, #message do\n\t\tlocal currentChar = string.sub(message,\
    \ i, i)\n\t\tlocal nextChar = string.sub(message, i + 1, 1)\n\t\tif currentChar\
    \ == \"a\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet, 2, 2)\n\
    \t\telseif currentChar == \"e\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 2, 3)\n\t\telseif currentChar == \"i\" then\n\t\t\tnewMessage = newMessage ..\
    \ string.sub(alphabet, 2, 4)\n\t\telseif currentChar == \"o\" then\n\t\t\tnewMessage\
    \ = newMessage .. string.sub(alphabet, 2, 5)\n\t\telseif currentChar == \"u\"\
    \ then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet, 2, 6)\n\t\telseif\
    \ currentChar == \"y\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 2, 7)\n\t\telseif nextChar == \"a\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 3, 3)\n\t\telseif nextChar == \"e\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 3, 4)\n\t\telseif nextChar == \"i\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 3, 5)\n\t\telseif nextChar == \"o\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 3, 6)\n\t\telseif nextChar == \"u\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 3, 7)\n\t\telseif nextChar == \"y\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 3, 8)\n\t\telseif currentChar == \"b\" then\n\t\t\tnewMessage = newMessage ..\
    \ string.sub(alphabet, 4, 2)\n\t\telseif currentChar == \"c\" then\n\t\t\tnewMessage\
    \ = newMessage .. string.sub(alphabet, 4, 3)\n\t\telseif currentChar == \"d\"\
    \ then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet, 4, 4)\n\t\telseif\
    \ currentChar == \"f\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 4, 5)\n\t\telseif currentChar == \"g\" then\n\t\t\tnewMessage = newMessage ..\
    \ string.sub(alphabet, 4, 6)\n\t\telseif currentChar == \"h\" then\n\t\t\tnewMessage\
    \ = newMessage .. string.sub(alphabet, 4, 7)\n\t\telseif currentChar == \"j\"\
    \ then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet, 4, 8)\n\t\telseif\
    \ currentChar == \"k\" then\n\t\t\tnewMessage = newMessage .. string.sub(alphabet,\
    \ 4, 9)\n\t\telseif currentChar == \"l\" then\n\t\t\tnewMessage = newMessage ..\
    \ string.sub(alphabet", "  -- TODO: Write your code here\n  local encoded = message\n\
    \  local vowels = 'aeiouAEIOU'\n  for i=1,#message do\n    local char = message[i]\n\
    \    if char in vowels then\n      local j = 1\n      while i+j < #message and\
    \ vowels:sub(vowels:sub(i+j),1) ~= char do\n        j = j + 1\n      end\n   \
    \   encoded = encoded:sub(i-j,i-1) .. char\n    end\n  end\n  return encoded\n\
    end", "   local new_message = \"\"\n   for w in message:gmatch(\"[%w]+\") do\n\
    \      -- Only letters allowed\n      if #w ~= 1 then break end\n      -- All\
    \ letters need to be 2 places ahead of vowel\n      if w:sub(1, 1) == 'a' or w:sub(1,\
    \ 1) == 'e' or w:sub(1, 1) == 'i' or w:sub(1, 1) == 'o' or w:sub(1, 1) == 'u'\
    \ then\n         local new_w = w:sub(1, 1) and w:sub(1, 2)\n         -- If there\
    \ is a vowel then replace with that vowel\n         if new_w:sub(1, 1) == 'a'\
    \ or new_w:sub(1, 1) == 'e' or new_w:sub(1, 1) == 'i' or new_w:sub(1, 1) == 'o'\
    \ or new_w:sub(1, 1) == 'u' then\n            new_w = new_w:sub(2, 1)\n      \
    \   end\n         -- Replace all vowels in the word with new_w\n         new_message\
    \ = new_message .. new_w\n      elseif w:sub(1, 1) == 'A' or w:sub(1, 1) == 'E'\
    \ or w:sub(1, 1) == 'I' or w:sub(1, 1) == 'O' or w:sub(1, 1) == 'U' then\n   \
    \      local new_w = w:sub(1, 1) and w:sub(1, 2)\n         -- If there is a vowel\
    \ then replace with that vowel\n         if new_w:sub(1, 1) == 'A' or new_w:sub(1,\
    \ 1) == 'E' or new_w:sub(1, 1) == 'I' or new_w:sub(1, 1) == 'O' or new_w:sub(1,\
    \ 1) == 'U' then\n            new_w = new_w:sub(2, 1)\n         end\n        \
    \ -- Replace all vowels in the word with new_w\n         new_message = new_message\
    \ .. new_w\n      end\n   end\n   return new_message\nend", "    local buffer\
    \ = {}\n    local index = 1\n    local lastVowel = -1\n    local count = 0\n \
    \   local tempMessage = ''\n    for i = 1, #message do\n        local char = message[i]\n\
    \        \n        if char == ' ' then \n            if lastVowel > -1 then\n\
    \                count = count + 1\n            else\n                buffer[index]\
    \ = string.sub(tempMessage, lastVowel, i - 1)\n                index = index +\
    \ 1\n            end\n            tempMessage = string.sub(message, i + 1, 1)\n\
    \            lastVowel = -1\n            count = 0\n        elseif char == 'a'\
    \ then\n            count = count + 1\n        elseif char == 'e' then\n     \
    \       count = count + 1\n        elseif char == 'i' then\n            count\
    \ = count + 1\n        elseif char == 'o' then\n            count = count + 1\n\
    \        elseif char == 'u' then\n            count = count + 1\n        elseif\
    \ char == 'A' then\n            count = count + 1\n        elseif char == 'E'\
    \ then\n            count = count + 1\n        elseif char == 'I' then\n     \
    \       count = count + 1\n        elseif char == 'O' then\n            count\
    \ = count + 1\n        elseif char == 'U' then\n            count = count + 1\n\
    \        elseif count > 2 then\n            buffer[index] = string.sub(tempMessage,\
    \ lastVowel, i - 1)\n            index = index + 1\n            lastVowel = i\
    \ - 1\n            count = 0\n        end\n        \n        if count == 2 then\n\
    \            buffer[index] = char\n            index = index + 1\n           \
    \ lastVowel = i - 1\n            count = 0\n        end\n    end\n    \n    if\
    \ lastVowel > -1 then\n        buffer[index] = string.sub(tempMessage, lastVowel,\
    \ #message)\n        index = index + 1\n    else\n        buffer[index] = string.sub(tempMessage,\
    \ lastVowel, #message)\n        index = index + 1\n    end\n    \n    return table.concat(buffer,\
    \ \"-\")\nend", "\t-- Write your function here. \n\t-- This function should return\
    \ a string. \n\t-- Use the string library function replace to substitute \n\t\
    -- all letters in the message with the letter that appears \n\t-- 2 places ahead\
    \ of the vowel that appears in the message. \n\t-- Assume only letters. \n\treturn\
    \ string.replace(message,'a','A')\n\t\t..string.replace(message,'e','E')\n\t\t\
    ..string.replace(message,'i','I')\n\t\t..string.replace(message,'o','O')\n\t\t\
    ..string.replace(message,'u','U')\nend", "    local newMessage = ''\n    local\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n    for i = 1, #message do\n        for\
    \ j = 1, #vowels do\n            local indexVowel = string.find(vowels, message[i])\n\
    \            local indexVowelNext = string.find(vowels, message[i+j])\n      \
    \      if indexVowel and indexVowelNext then\n                newMessage = newMessage\
    \ .. message[i]:sub(1, indexVowel-1) .. message[i+j]:sub(1, indexVowelNext-1)\
    \ .. message[i]:sub(1, indexVowel+1)\n            elseif indexVowel then\n   \
    \             newMessage = newMessage .. message[i]:sub(1, indexVowel)\n     \
    \       elseif indexVowelNext then\n                newMessage = newMessage ..\
    \ message[i+j]:sub(1, indexVowelNext-1)\n            end\n        end\n    end\n\
    \    return newMessage\nend", "  -- TODO\nend", "  local alphabet = \n    {'a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', \n     'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', \n     'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C',\
    \ 'D', \n     'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', \n     'O', 'P',\
    \ 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', \n     'Y', 'Z'}\n  local code = ''\
    \ -- Initialize an empty string.\n  for i, letter in pairs(message) do\n    if\
    \ alphabet:find(letter:lower()) ~= nil then\n      code = code .. alphabet:find(letter:lower())\
    \ .. alphabet:find(letter:lower())\n    else\n      code = code .. letter\n  \
    \  end\n  end\n  return code\nend", "  local message = string.lower(message) --\
    \ lowercase our message\n  \n  -- initialize our return value\n  local out = ''\n\
    \  \n  -- loop through our message\n  for _, letter in ipairs(message) do\n  \
    \  -- initialize our new letter\n    local nextLetter = ''\n    \n    -- loop\
    \ through the english alphabet \n    for i, letter in ipairs(alphabet) do\n  \
    \    if letter == letter then -- letter is equal to the letter in our english\
    \ alphabet\n        nextLetter = alphabet[i + 1] -- get the letter in the english\
    \ alphabet 2 places ahead\n      elseif letter == letter then -- letter is equal\
    \ to the letter in our english alphabet\n        nextLetter = alphabet[i + 2]\
    \ -- get the letter in the english alphabet 3 places ahead\n      end\n    end\n\
    \    \n    -- append to our return value\n    out = out .. letter .. nextLetter\n\
    \  end\n  \n  return out -- return the new encoded message\nend", "    local alphabet\
    \ = {\n        ['A'] = ['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n   \
    \     ['B'] = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n        ['C']\
    \ = ['A', 'B', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\
    \ 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n        ['D'] = ['A', 'B',\
    \ 'C', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n        ['E'] = ['A', 'B', 'C', 'D', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'],\n        ['F'] = ['A', 'B', 'C', 'D', 'E', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'],\n        ['G'] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n\
    \        ['H'] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'I', 'J', 'K', 'L', 'M',\
    \ 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n        ['I']\
    \ = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n        ['J'] = ['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z'],\n        ['K'] = ['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\
    \ 'Y', 'Z'],\n        ['L'] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K", "  local uppercase = string.upper(message)\n  local lowercase = string.lower(message)\n\
    \  local vowels = string.char(tonumber(\" AEIOU\"))\n  local substitution = {}\n\
    \  for i = 1, #vowels do\n    local pos = i\n    local lastpos = 1\n    while\
    \ pos < #uppercase do\n      if string.sub(uppercase,pos,pos+1) ~= vowels[i] then\n\
    \        local letter = string.sub(uppercase,lastpos,pos)\n        substitution[letter]\
    \ = letter\n        lastpos = pos+1\n      end\n      pos = pos+1\n    end\n \
    \ end\n  local finalMessage = \"\"\n  for i = 1, #lowercase do\n    if substitution[lowercase[i]]\
    \ ~= \"\" then\n      finalMessage = finalMessage .. substitution[lowercase[i]]\n\
    \    elseif lowercase[i] ~= \" \" then\n      finalMessage = finalMessage .. lowercase[i]\n\
    \    end\n  end\n  return finalMessage\nend", "    return \nend", "  local message\
    \ = \"t\"..message\n  local letters = {}\n  for i=1,#message do\n    local letter\
    \ = message:sub(i,i)\n    local index = letter:upper()\n    letters[index] = letter\n\
    \  end\n  local vowels = {}\n  for i=0,271 do\n    local letter = string.char(i)\n\
    \    local index = letter:upper()\n    local numVowels = string.ptr(letter):sub(1)\n\
    \    local vowel = letter:sub((numVowels-2)/2,(numVowels-2)/2)\n    vowels[letter]\
    \ = vowel\n  end\n  for i=1,#message do\n    local letter = message:sub(i,i)\n\
    \    local index = letter:upper()\n    local letter2 = letters[index]\n    if\
    \ letter2 ~= letter then\n      letters[letter] = letter2\n    end\n    if letters[letter]\
    \ == letter then\n      letters[letter] = vowels[letter]\n    end\n  end\n  return\
    \ table.concat(letters,'')\nend", "  -- encode a message \n  -- return the encoded\
    \ message\n  -- -- write your code here\n  -- -- don't forget to return the encoded\
    \ message \n  \n  -- encode a message with every letter in the english alphabet\
    \ \n  local letters = string.gsub(string.upper(message), '[^a-z]', '')\n  \n \
    \ -- encode each letter \n  for i = 1, #letters do\n    -- get 2 letters before\
    \ current letter and replace current letter\n    -- with that letter in the alphabet\n\
    \    local two = string.sub (letters, i - 1, i - 2)\n    letters[i] = string.sub\
    \ (letters, i, i)\n    -- replace vowel with the two letters ahead\n    letters[i]\
    \ = letters[i] == 'a' or letters[i] == 'e' or letters[i] == 'i'\n      or letters[i]\
    \ == 'o' or letters[i] == 'u' then\n      letters[i] = letters[i] + two\n    \
    \  end\n  end\n  \n  return letters\nend", "\tlocal vowels = {'a','e','i','o','u','y','A','E','I','O','U','Y'}\n\
    \tlocal vowels_reverse = {'y','u','i','o','a','e','Y','U','I','O','A','E'}\n\t\
    local result = {}\n\tlocal new_message = {}", "\t-- Write your solution here.\n\
    \t-- You will need a string and table lookup \n\t-- -- The first table will hold\
    \ the mappings from letters to their \n\t-- -- encoded values\n\t-- -- The second\
    \ table will hold the mappings from letters to the \n\t-- -- letters that appear\
    \ 2 places ahead of them\n\t-- -- Then you'll need to look up the letter in the\
    \ first table and \n\t-- -- look the character 2 places ahead in the second table\
    \ to get the \n\t-- -- letter that should be appended\n\t-- -- Finally, you will\
    \ need to append the letter to your string\nend", "    message = message:gsub('[a\xE1\
    \xE0\xE3\xE2\xE4]', function(c)\n        return string.upper(string.sub(c, 1,\
    \ 1))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 1, 2))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 1, 3))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 1, 4))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 1, 5))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 1, 6))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 1, 7))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 1, 8))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 1, 9))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 1))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 2))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 3))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 4))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 5))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 6))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 7))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 8))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 2, 9))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 3, 1))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 3, 2))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 3, 3))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 3, 4))\n    end):gsub('[AEIOU]', function(c)\n        return string.upper(string.sub(c,\
    \ 3, 5))", '  -- Write your solution here', "  local vowels = {'a','e','i','o','u','y'}\n\
    \  local message_length = #message\n  local alphabet = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.",
  "  local alphabet = 'aAeEiIoOuU'\n  local vowels = 'aAeEiIoOuU'", "  -- TODO: Write\
    \ your solution here.\n  return message\nend", "    local newMessage = {}\n  \
    \  local vowels = 'aeiouyAEIOUY'\n    \n    for index, letter in pairs(message)\
    \ do\n        if letter == 'A' then\n            letter = vowels[math.random(#vowels)]\n\
    \        end\n        newMessage[index] = letter\n    end\n    \n    for index,\
    \ letter in pairs(message) do\n        if letter == 'A' then\n            letter\
    \ = vowels[math.random(#vowels)]\n        end\n        newMessage[index] = letter\n\
    \    end\n    \n    return table.concat(newMessage)\nend", "    local alphabet\
    \ = {a,e,i,o,u}\n    local index = {}\n    local newMessage = {}\n    for index,\
    \ value in pairs(alphabet) do\n        newMessage[index + 1] = message\n    end\n\
    \    local vowels = {'a','e','i','o','u'}\n    for index, value in pairs(vowels)\
    \ do\n        newMessage[index + 1] = message\n    end\n    for index, value in\
    \ pairs(alphabet) do\n        newMessage[index + 1] = message\n    end\n    for\
    \ index, value in pairs(vowels) do\n        newMessage[index + 1] = message\n\
    \    end\n    return newMessage\nend", "  local result = message\n  local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  local vowels = \"aeiouAEIOU\"", "  return\
    \ message\n  :gsub(\"([a-z])\", function(a, b)\n    local letter = string.byte(a)\n\
    \    local vowel = string.byte(a:sub(2))\n    return string.char(\n      letter\
    \ + vowel,\n      letter + vowel + letter + vowel\n    )\n  end)\n  :gsub(\"[aeiou]\"\
    , function(letter)\n    return letter:sub(2)\n  end)\n  :gsub(\"[AEIOU]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[AEIOU]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:sub(1, 1)\n  end)\n  :gsub(\"[aeiou]\", function(letter)\n\
    \    return letter:", "    -- encode returns a list of lists, \n    -- where each\
    \ inner list is a group of letters that are \n    -- equivalent to the same letter\
    \ in the english alphabet.\n    -- e.g. 'test' and 'this is a message' would be\
    \ encoded as \n    -- [['T', 'G'], ['S', 'T'], ['S', 'T'], ['H', 'K'], ['S', 'C']].\n\
    \    -- Each inner list is an array of letters. The letters \n    -- are in the\
    \ same order as in the message.\n    -- Assume each character in the message is\
    \ in lower case.\n    local characters = {}\n    for letter in string.gmatch(message,\
    \ '%l') do\n        -- We want to compare every letter to every other letter.\n\
    \        for innerlist in characters do\n            -- We want to compare every\
    \ letter of the first list \n            -- to every letter of the second list.\n\
    \            for letter2 in string.gmatch(innerlist, '%l') do\n              \
    \  -- We want to compare every letter of the first list \n                -- to\
    \ the letter that appears 2 places ahead of \n                -- the letter in\
    \ the second list.\n                if letter == letter2 then\n              \
    \      -- We don't want to compare letters that are \n                    -- exactly\
    \ the same.\n                    if innerlist ~= [] then\n                   \
    \     -- The letter that appears 2 places ahead of \n                        --\
    \ the letter that appears 2 places ahead of \n                        -- the letter\
    \ that appears 2 places ahead of \n                        -- the letter that\
    \ appears 2 places ahead of \n                        -- this letter is also a\
    \ letter.\n                        table.insert(innerlist, letter)\n         \
    \           else\n                        -- This letter is the letter that appears\
    \ \n                        -- 2 places ahead of the letter that appears \n  \
    \                      -- 2 places ahead of the letter that appears \n       \
    \                 -- 2 places ahead of the letter that appears \n            \
    \            -- 2 places ahead of this letter is the letter \n               \
    \         -- that appears 2 places ahead of the \n                        -- letter\
    \ that appears 2 places ahead of \n                        -- the letter that\
    \ appears 2 places ahead of \n                        -- the letter that appears\
    \ 2 places ahead of \n                        -- this letter is also a letter.\n\
    \                        table.insert(characters, {letter})\n                \
    \    end\n                end\n            end\n        end\n    end\n    return\
    \ table.concat(characters)\nend", "    local buffer = \"\"\n    for i = 1, #message\
    \ do\n        local char = string.sub(message, i, i)\n        if char == \"a\"\
    \ then\n            buffer = buffer .. \"A\"\n        elseif char == \"e\" then\n\
    \            buffer = buffer .. \"E\"\n        elseif char == \"i\" then\n   \
    \         buffer = buffer .. \"I\"\n        elseif char == \"o\" then\n      \
    \      buffer = buffer .. \"O\"\n        elseif char == \"u\" then\n         \
    \   buffer = buffer .. \"U\"\n        elseif char == \"A\" then\n            buffer\
    \ = buffer .. \"a\"\n        elseif char == \"E\" then\n            buffer = buffer\
    \ .. \"e\"\n        elseif char == \"I\" then\n            buffer = buffer ..\
    \ \"i\"\n        elseif char == \"O\" then\n            buffer = buffer .. \"\
    o\"\n        elseif char == \"U\" then\n            buffer = buffer .. \"u\"\n\
    \        else\n            buffer = buffer .. char\n        end\n    end\n   \
    \ return buffer\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    local vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    local\
    \ messageLetters = string.gsub(message, '[^' .. alphabet .. ']', '')\n    local\
    \ decodedMessage = \"\"\n    for i = 1, #messageLetters do\n        local indexOfLetter\
    \ = alphabet.indexOf(messageLetters[i])\n        if indexOfLetter ~= nil then\n\
    \            local indexOfVowel = vowels.indexOf(messageLetters[i])\n        \
    \    if indexOfVowel ~= nil then\n                local indexOfVowelTwo = vowels.indexOf(messageLetters[i\
    \ + 1])\n                if indexOfVowelTwo ~= nil then\n                    decodedMessage\
    \ = decodedMessage .. alphabet[indexOfVowelTwo + 1]\n                else\n  \
    \                  decodedMessage = decodedMessage .. alphabet[indexOfVowel +\
    \ 1]\n                end\n            else\n                decodedMessage =\
    \ decodedMessage .. alphabet[indexOfLetter + 1]\n            end\n        else\n\
    \            decodedMessage = decodedMessage .. messageLetters[i]\n        end\n\
    \    end\n    return decodedMessage\nend", "  local result = {}\n  for i, letter\
    \ in ipairs(message) do\n    local vowels = { 'a', 'e', 'i', 'o', 'u' }\n    result[i]\
    \ = letter\n    for _, vowel in ipairs(vowels) do\n      local index = letter:find(vowel)\n\
    \      if index then\n        result[i] = result[i]..(letter:sub(index+1, index+2))\n\
    \      end\n    end\n  end\n  return table.concat(result, \"-\")\nend", "    local\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet2 = \"bcdfghjklmnpqrstvwxyz\"",
  "   local vowels = {'a', 'e', 'i', 'o', 'u'}\n   local alphabet = {'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', \n      'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', \n      'x', 'y', 'z'}\n   local alphamap = {}\n\
    \   local vowelmap = {}\n   for i = 1, #alphabet do\n      alphamap[alphabet[i]]\
    \ = i\n   end\n   for i = 1, #vowels do\n      vowelmap[vowels[i]] = i\n   end\n\
    \   local message = \"\"\n   for _, letter in ipairs(message) do\n      local\
    \ charindex = alphabet[letter]\n      if charindex then\n         local newletter\
    \ = alphamap[letter]\n         if newletter then\n            message = message\
    \ .. newletter\n         else\n            message = message .. letter\n     \
    \    end\n      end\n   end\n   local result = \"\"\n   for _, letter in ipairs(message)\
    \ do\n      local charindex = alphabet[letter]\n      if charindex then\n    \
    \     local newletter = alphamap[letter]\n         if newletter then\n       \
    \     local vowelindex = vowelmap[letter]\n            local twoplaces = letter:sub(twoplaces_length+1-vowelindex)\n\
    \            if twoplaces then\n               result = result .. alphabet[vowelmap[twoplaces]]\n\
    \            else\n               result = result .. letter\n            end\n\
    \         else\n            result = result .. letter\n         end\n      end\n\
    \   end\n   return result\nend", "  local message_lower = message:lower()\n  local\
    \ message_upper = message:upper()\n  local vowels = 'aeiouyAEIOUY'\n  for i =\
    \ 1, #message do\n    local letter = message:sub(i,i)\n    if letter:upper() in\
    \ vowels then\n      local vowel = vowels:find(letter:upper())\n      local letter2\
    \ = message:sub(vowel + 1,vowel)\n      if letter2:upper() in vowels then\n  \
    \      letter2 = letter2:lower()\n      end\n      message_lower = message_lower\
    \ .. letter2\n    end\n  end\n  return message_lower\nend", "    local function\
    \ rev_case(str)\n        local s = str:lower()\n        s = string.gsub(s, 'a',\
    \ 'A')\n        s = string.gsub(s, 'e', 'E')\n        s = string.gsub(s, 'i',\
    \ 'I')\n        s = string.gsub(s, 'o', 'O')\n        s = string.gsub(s, 'u',\
    \ 'U')\n        s = string.gsub(s, 'y', 'Y')\n        s = string.gsub(s, 'h',\
    \ 'H')\n        s = string.gsub(s, 'w', 'W')\n        s = string.gsub(s, 'n',\
    \ 'N')\n        s = string.gsub(s, 's', 'S')\n        s = string.gsub(s, 't',\
    \ 'T')\n        s = string.gsub(s, 'd', 'D')\n        s = string.gsub(s, 'p',\
    \ 'P')\n        s = string.gsub(s, 'l', 'L')\n        s = string.gsub(s, 'r',\
    \ 'R')\n        s = string.gsub(s, 'z', 'Z')\n        return string.gsub(s, '([aeiou])',\
    \ function(c) return string.sub(c, 1, 1) end)\n    end", "   local vowels = {'a',\
    \ 'e', 'i', 'o', 'u', 'y'} \n   local newMessage = ''\n   for i = 1, #message\
    \ do\n      local currentLetter = message[i]\n      local currentVowel = string.sub(currentLetter,\
    \ 1, 1)\n      if vowels[currentVowel] then\n         local previousLetter = string.sub(currentLetter,\
    \ 2, 1)\n         newMessage = newMessage .. string.sub(vowels[currentVowel],\
    \ 1, 1) \n         newMessage = newMessage .. vowels[previousLetter]\n      else\n\
    \         newMessage = newMessage .. currentLetter\n      end\n   end\n   return\
    \ newMessage\nend\n</cell>\n<text>\nLet's check our implementation:", "   local\
    \ newMessage = message\n   local vowels = {'a', 'e', 'i', 'o', 'u'}\n   local\
    \ letters = {string.lowercase, string.uppercase, string.ascii,\n             \
    \        string.uppercase, string.lowercase}\n   for i = 1,#message do\n     \
    \ local curLetter = message[i]\n      -- This line makes sure that lower case\
    \ letters have a lower case letter\n      -- after being swapped for the lower\
    \ case letter\n      local newLetter = string.uppercase (letters[curLetter])\n\
    \      newMessage = newMessage:gsub(string.rep('%a', function(vowel) \n      \
    \   if vowels[curLetter] == vowels[vowel:sub(2)] then \n            return curLetter\n\
    \         else\n            return vowel:sub(2)\n         end\n      ), newLetter)\n\
    \   end\n   return newMessage\nend", "  -- Write your code here.\n  local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  -- initialize counter\n  local i = 0\n \
    \ -- initialize empty message\n  local message = ''\n  -- iterate through message\n\
    \  for character in message\n    do\n      -- iterate through characters in alphabet\
    \ and find index of character\n      local index = alphabet.find(character)\n\
    \      -- if character is found then add 2 letters to index\n      if index >=\
    \ 0 then\n        index = index + 2\n      else\n        index = index + 2\n \
    \     end\n      -- swap cases\n      local char = alphabet[index]\n      -- add\
    \ character to message\n      message = message .. char\n    end\n  -- return\
    \ message\n  return message\nend", "  -- Decode a message. \n  -- Decode a message\
    \ from left to right. \n  -- Keep track of the current position in the \n  --\
    \ message to be decoded. \n  -- Example:\n  -- >>> decode('tHKS KS C MGSSCGG')\n\
    \  -- 'This is a message'\n  -- >>> decode('tHKS KS C MGSSCGG')\n  -- 'This is\
    \ a message'\n  -- >>> decode('KS tHKS KS C MGSSCGG')\n  -- 'This is a message'\n\
    \  -- >>> decode('tHKS KS C MGSSCGG')\n  -- 'This is a message'\n  -- >>> decode('tHKS\
    \ KS C MGSSCGG')\n  -- 'This is a message'\n  -- >>> decode('tHKS KS C MGSSCGG')\n\
    \  -- 'This is a message'\n  -- >>> decode('tHKS KS C MGSSCGG')\n  -- 'This is\
    \ a message'\n  -- >>> decode('KS tHKS KS C MGSSCGG')\n  -- 'This is a message'\n\
    \  -- >>> decode('KS tHKS KS C MGSSCGG')\n  -- 'This is a message'\n  -- >>> decode('KS\
    \ tHKS KS C MGSSCGG')\n  -- 'This is a message'\n  -- >>> decode('tHKS KS C MGSSCGG')\n\
    \  -- 'This is a message'\n  -- >>> decode('KS tHKS KS C MGSSCGG')\n  -- 'This\
    \ is a message'\n  -- >>> decode('tHKS KS C MGSSCGG')\n  -- 'This is a message'\n\
    \  -- >>> decode('tHKS KS C MGSSCGG')\n  -- 'This is a message'\n  -- >>> decode('tHKS\
    \ KS C MGSSCGG')\n  -- 'This is a message'\n  -- >>> decode('tHKS KS C MGSSCGG')\n\
    \  -- 'This is a message'\n  -- >>> decode('tHKS KS C MGSSCGG')\n  -- 'This is\
    \ a message'\n  -- >>> decode('tHKS KS C MGSSCGG')\n  -- 'This is a message'\n\
    \  -- >>> decode('tHKS KS C MGSSCGG')\n  -- 'This is a message'\n  -- >>> decode('tHKS\
    \ KS C MGSSCGG')\n  -- 'This is a message'\n  -- >>> decode('", "    local messages\
    \ = string.gmatch(message, '([a-zA-Z]+)') -- split into words\n    local words\
    \ = { } \n    for _, word in ipairs(messages) do \n        words[#words + 1] =\
    \ '' -- initialize empty word \n        local vowels = { 'a', 'e', 'i', 'o', 'u',\
    \ 'A', 'E', 'I', 'O', 'U' }\n        for i,letter in ipairs(word) do \n      \
    \      words[#words + 1] = word \n        end\n        for i,letter in ipairs(word)\
    \ do -- loop through each letter in the word, swapping case\n            local\
    \ position = #vowels + i + 1 -- starting position of vowel within word\n     \
    \       while position > 0 do -- loop through positions ahead\n              \
    \  if words[position] == letter then -- if the letter matches, \n            \
    \        words[position] = words[position].upper() -- replace with its uppercase\
    \ equivalent\n                    position = position-1 -- decrement position\n\
    \                elseif words[position] == words[position].lower() then -- if\
    \ the letter is at the 2nd letter ahead\n                    words[position] =\
    \ letter\n                    position = position-1 -- decrement position\n  \
    \              else\n                    position = position -- move position\
    \ in loop\n                end\n            end\n        end\n    end\n    local\
    \ message = table.concat(words) -- join words back into message \n    for i,letter\
    \ in ipairs(letters) do -- replace vowels with letter\n        message = message:gsub('['..letter..'-]',\
    \ function(letter)\n            local position = #letters + i + 1 -- starting\
    \ position of letter in message\n            local vowel = letters.vowels[letter]\n\
    \            while position > 0 do -- loop through positions ahead\n         \
    \       if words[position] == letter then -- if the letter matches, \n       \
    \             return vowel -- replace with its vowel\n                elseif words[position]\
    \ == words[position].lower() then -- if the letter is at the 2nd letter ahead\n\
    \                    return vowel -- replace with its vowel\n                else\n\
    \                    position = position -- move position in loop\n          \
    \      end\n            end\n            return letter -- if no vowels match,\
    \ return letter\n        end)\n    end\n    return message\nend\n</code>\nThe\
    \ reason for using a separate function to handle letters is to allow you to change\
    \ the code later without having to go through every single letter in the alphabet\
    \ and change them all individually.\n<|/ a tags=lua dscore=2 |>\n<| c |>\nJust\
    \ a quick thought... how about a function that receives the message and returns\
    \ the decoded message?\n<|/ c |>\n<| c |>\nI added a way to decode it as well, ",
  "  local alphabet = {}\n  for i=1,26  do alphabet[i] = string.char(i) end\n  \n\
    \  local index = 1\n  -- This loop will keep replacing each vowel with a letter\
    \ from our alphabet\n  -- and will continue until we have no more vowels to replace.\n\
    \  while index <= #message do\n    local vowel = string.sub(message, index, index+1)\n\
    \    local nextVowel = string.sub(message, index+1, index+2)\n    if nextVowel\
    \ == \"E\" then\n      alphabet[string.sub(message, index+1, index+2)] = \"E\"\
    \n    elseif nextVowel == \"I\" then\n      alphabet[string.sub(message, index+1,\
    \ index+2)] = \"I\"\n    elseif nextVowel == \"O\" then\n      alphabet[string.sub(message,\
    \ index+1, index+2)] = \"O\"\n    elseif nextVowel == \"U\" then\n      alphabet[string.sub(message,\
    \ index+1, index+2)] = \"U\"\n    elseif nextVowel == \"A\" then\n      alphabet[string.sub(message,\
    \ index+1, index+2)] = \"A\"\n    elseif nextVowel == \"I\" then\n      alphabet[string.sub(message,\
    \ index+1, index+2)] = \"I\"\n    end\n    index = index + 2\n  end\n  \n  --\
    \ Here we go through each letter in our message and replace vowels\n  -- with\
    \ the letters that come 2 letters ahead.\n  for i=1,#message do\n    if alphabet[string.sub(message,\
    \ i, i+1)] ~= 'E' then\n      alphabet[string.sub(message, i, i+1)] = alphabet[string.sub(message,\
    \ i, i+2)]\n    end\n  end\n  \n  return table.concat(alphabet)\nend", "    local\
    \ newMessage = \"\"\n    for i = 1, #message do\n        newMessage = string.lower(message[i]:gsub(\"\
    [aeiou]\", function(c) \n            local previousVowel = math.floor((i - 1)\
    \ / 2)\n            return string.char((math.abs(string.find(string.lower(message[previousVowel]),\
    \ c)) + 1) \n                + string.find(string.lower(message[i]), c))\n   \
    \     end))\n    end\n    return newMessage\nend", "  if message == '' or message\
    \ == '-' then return '-' end\n  local alphabet = {['A'] = 'A', ['a'] = 'a', ['B']\
    \ = 'B', ['b'] = 'b', ['C'] = 'C', \n    ['c'] = 'c', ['D'] = 'D', ['d'] = 'd',\
    \ ['E'] = 'E', ['e'] = 'e', ['F'] = 'F', \n    ['f'] = 'f', ['G'] = 'G', ['g']\
    \ = 'g', ['H'] = 'H', ['h'] = 'h', ['I'] = 'I', \n    ['i'] = 'i', ['J'] = 'J',\
    \ ['j'] = 'j', ['K'] = 'K', ['k'] = 'k', ['L'] = 'L', \n    ['l'] = 'l', ['M']\
    \ = 'M', ['m'] = 'm', ['N'] = 'N', ['n'] = 'n', ['O'] = 'O', \n    ['o'] = 'o',\
    \ ['P'] = 'P', ['p'] = 'p', ['Q'] = 'Q', ['q'] = 'q', ['R'] = 'R', \n    ['r']\
    \ = 'r', ['S'] = 'S', ['s'] = 's', ['T'] = 'T', ['t'] = 't', ['U'] = 'U', \n \
    \   ['u'] = 'u', ['V'] = 'V', ['v'] = 'v', ['W'] = 'W', ['w'] = 'w', ['X'] = 'X',\
    \ \n    ['x'] = 'x', ['Y'] = 'Y', ['y'] = 'y', ['Z'] = 'Z', ['z'] = 'z', \n  \
    \  ['0'] = '0', ['1'] = '1', ['2'] = '2', ['3'] = '3', ['4'] = '4', \n    ['5']\
    \ = '5', ['6'] = '6', ['7'] = '7', ['8'] = '8', ['9'] = '9', \n    ['a'] = 'a',\
    \ ['b'] = 'b', ['c'] = 'c', ['d'] = 'd', ['e'] = 'e', \n    ['f'] = 'f', ['g']\
    \ = 'g', ['h'] = 'h', ['i'] = 'i', ['j'] = 'j', \n    ['k'] = 'k', ['l'] = 'l',\
    \ ['m'] = 'm', ['n'] = 'n', ['o'] = 'o', \n    ['p'] = 'p', ['q'] = 'q', ['r']\
    \ = 'r', ['s'] = 's', ['t'] = 't', \n    ['u'] = 'u', ['v'] = 'v', ['w'] = 'w',\
    \ ['x'] = 'x', \n    ['y'] = 'y', ['z'] = 'z'}\n  local swaps = {}\n  local vowels\
    \ = 'AEIOUaeiou'\n  for i=1, #message do\n    local t = message[i]\n    if t ==\
    \ 'A' then\n      swaps[#swaps + 1] = 'B'\n    elseif t == 'B' then\n      swaps[#swaps\
    \ + 1] = 'A'\n    elseif t == 'a' then\n      swaps[#swaps + 1] = 'A'\n    elseif\
    \ t == 'e' then\n      swaps[#swaps + 1] = 'E'\n    elseif t == 'i", "  local\
    \ messages = {}\n  for i, letter in pairs(message) do\n    messages[i] = letter\n\
    \  end\n  local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\
    \ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\
    \ 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'}\n  for letter, position in\
    \ pairs(alphabet) do\n    for i = 1, #message do\n      local index = alphabet.index(letter,\
    \ i)\n      if i == position then\n        table.insert(messages, alphabet[index\
    \ + 1])\n      else\n        table.insert(messages, alphabet[index])\n      end\n\
    \    end\n  end\n  return table.concat(messages, \" \")\nend", "    local messageLetters\
    \ = {}\n    for i = 1, #message, 1 do\n        local lowerLetter = string.lower(message[i])\n\
    \        table.insert(messageLetters, lowerLetter)\n    end\n    table.sort(messageLetters)\n\
    \    local vowels = \"aeiouAEIOU\"\n    local result = \"\"\n    for i = 1, #messageLetters,\
    \ 1 do\n        if #vowels > i then\n            local lowerVowel = string.lower(vowels[i])\n\
    \            local lowerLetter = string.lower(messageLetters[i])\n           \
    \ local newVowel = lowerVowel .. lowerLetter\n            table.insert(result,\
    \ \"aeiou\" .. newVowel)\n            table.insert(result, newVowel .. lowerLetter)\n\
    \        else\n            table.insert(result, messageLetters[i])\n        end\n\
    \    end\n    return result\nend", "   -- Start with the empty message. \n   --\
    \ Swap case and place all vowels into the message at 2 spots. \n   -- E.g. if\
    \ the vowel is 'e', then place 'a' at 2 spots, so that \n   -- you have the letter\
    \ 'e' and 'a' alternating. \n   -- If you use a loop, this will look something\
    \ like this: \n   -- for i = 1, #message do\n   --     local letter = message[i]\n\
    \   --     if letter == 'a' then\n   --         letter = 'e'\n   --         i\
    \ = i - 1\n   --     end\n   --     ...\n   --     return message\n   -- end",
  "   local words = {}\n   for i = 1, #message do \n      local word = string.gsub(string.sub(message,\
    \ i, i+1), '[aeiou]', function(c)\n         if words[c] then return words[c] else\
    \ return c end\n      end)\n      table.insert(words, word)\n   end\n   return\
    \ table.concat(words)\nend", "    local vowels = {\"a\", \"e\", \"i\", \"o\",\
    \ \"u\", \"y\"} -- TODO: Support other consonants\n    local function vowel_to_index(vowel)\n\
    \        return math.floor(vowel.upcase:find('a'..'z'))\n    end\n    local function\
    \ index_to_vowel(index)\n        return string.sub(alphabet, (index - math.floor((index\
    \ - 1) / 2)) * 2, index * 2)\n    end\n    local function get_index(vowel)\n \
    \       local index = vowel_to_index(vowel)\n        return math.floor(index /\
    \ 2)\n    end\n    local function get_vowel(index)\n        return index_to_vowel(index)\n\
    \    end\n    local function swap_case(message)\n        return string.gsub(message,\
    \ \"%a\", function(letter)\n            local index = get_index(letter)\n    \
    \        local vowel = get_vowel(index)\n            return vowel_to_index(vowel)..letter\n\
    \        end) .. message\n    end\n    return swap_case(encode(swap_case(message)))\n\
    end", "  -- Write your solution here!\n  \n  return message\nend", '    -- Write
    your solution here', "  -- Build translation table\n  local alphabet = {}\n  for\
    \ i=1,#ENCODE_ALPHABET do\n    alphabet[i] = ENCODE_ALPHABET[i]\n  end\n  -- Build\
    \ translation table\n  local vowels = {}\n  for i=1,#ENCODE_VOWELS do\n    vowels[i]\
    \ = ENCODE_VOWELS[i]\n  end\n  -- Decode string\n  local s = message\n  -- Translate\
    \ string\n  local t = {}\n  for i=1,#s do\n    local e = alphabet[s[i]]\n    if\
    \ e ~= nil then\n      local v = vowels[e]\n      if v ~= nil then\n        local\
    \ x = #t\n        t[x] = v\n      end\n    end\n  end\n  -- Re-encode string\n\
    \  return table.concat(t, \" \")\nend", "   -- Your code here!\n   return message\n\
    end", "    local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    local vowels =\
    \ { \"A\", \"E\", \"I\", \"O\", \"U\", \"Y\" }\n    local lookup = {}\n    for\
    \ i, v in ipairs(vowels) do\n        lookup[v] = alphabet[i+1]\n    end\n    local\
    \ encoded = \"\"\n    for i, c in ipairs(message) do\n        if lookup[c] then\n\
    \            encoded = encoded .. lookup[c]\n        else\n            encoded\
    \ = encoded .. c\n        end\n    end\n    return encoded\nend", "    local vowels\
    \ = {'a', 'e', 'i', 'o', 'u', 'y'}\n    local alpha = {['A'] = 'B', 'C'] = 'D',\
    \ \n        'G'] = 'H', 'K'] = 'L', \n        'M'] = 'N', 'N'] = 'N', 'O'] = 'P',\
    \ \n        'S'] = 'S', 'T'] = 'T', 'W'] = 'X', \n        'Y': 'Z'}\n    local\
    \ msg = {}\n    for i=1,#message do msg[i] = alpha[message[i]]; end\n    for i=1,#vowels\
    \ do msg[vowels[i]] = \n        alpha[vowels[i+1]]; end -- Swap the case of all\
    \ letters\n    for i=1,#msg-1 do \n        local vowel = vowels[i]\n        local\
    \ letter = alpha[msg[i]]\n        local index = msg:find(vowel)\n        if index\
    \ ~= nil then\n            local next = msg[index+1]\n            msg[index] =\
    \ letter\n            msg[index+1] = next\n        end\n    end\n    return table.concat(msg,'')\
    \ -- Combine letters in order\nend", "  local messageArr = message:gsub(\"[^a-zA-Z]+\"\
    , \"\")\n  local charMap = {}\n  local vowels = \"aeiou\"\n  for i=1,#vowels do\n\
    \    charMap[#charMap+1] = vowels:sub(i,i)\n  end\n  local charArr = messageArr:gsub(\"\
    %w\", function(ch)\n    if charMap[#charMap] ~= nil then\n      return charMap[#charMap]\n\
    \    end\n    return ch\n  end)\n  return table.concat(charArr, \"\")\nend", " \
    \ local alphabet = {\n    ['a'] = 'A', \n    ['b'] = 'B', \n    ['c'] = 'C', \n\
    \    ['d'] = 'D', \n    ['e'] = 'E', \n    ['f'] = 'F', \n    ['g'] = 'G', \n\
    \    ['h'] = 'H', \n    ['i'] = 'I', \n    ['j'] = 'J', \n    ['k'] = 'K', \n\
    \    ['l'] = 'L', \n    ['m'] = 'M', \n    ['n'] = 'N', \n    ['o'] = 'O', \n\
    \    ['p'] = 'P', \n    ['q'] = 'Q', \n    ['r'] = 'R', \n    ['s'] = 'S', \n\
    \    ['t'] = 'T', \n    ['u'] = 'U', \n    ['v'] = 'V', \n    ['w'] = 'W', \n\
    \    ['x'] = 'X', \n    ['y'] = 'Y', \n    ['z'] = 'Z'\n  }\n  local vowels =\
    \ \n    { \n      ['e'] = 'e', \n      ['i'] = 'i', \n      ['o'] = 'o', \n  \
    \    ['u'] = 'u', \n      ['y'] = 'y', \n      ['A'] = 'B', \n      ['B'] = 'B',\
    \ \n      ['C'] = 'C', \n      ['D'] = 'D', \n      ['E'] = 'E', \n      ['F']\
    \ = 'F', \n      ['G'] = 'G', \n      ['H'] = 'H', \n      ['I'] = 'I', \n   \
    \   ['J'] = 'J', \n      ['K'] = 'K', \n      ['L'] = 'L', \n      ['M'] = 'M',\
    \ \n      ['N'] = 'N', \n      ['O'] = 'O', \n      ['P'] = 'P', \n      ['Q']\
    \ = 'Q', \n      ['R'] = 'R', \n      ['S'] = 'S', \n      ['T'] = 'T', \n   \
    \   ['U'] = 'U', \n      ['V'] = 'V', \n      ['W'] = 'W', \n      ['X'] = 'X',\
    \ \n      ['Y'] = 'Y', \n      ['Z'] = 'Z'\n    }", "  local message_letters =\
    \ string.gsub(message, \"[a-z]\", function(letter)\n    return string.upper(letter)\n\
    \  end)", "    local outMessage = string.rep('',512)\n    local letters = string.gsub(message,'%W','')\n\
    \    local vowels = 'aeiou'\n    local vowelMap = {}\n    for i = 1, #vowels do\n\
    \        vowelMap[i] = string.sub(vowels,i,i+1)\n    end\n    for i = 1, #letters\
    \ do\n        local firstLetter = letters[i]\n        local firstVowel = string.sub(firstLetter,1,1)\n\
    \        if vowelMap[firstVowel] ~= nil then\n            local pos = string.find(vowels,firstVowel)\n\
    \            local nextLetter = string.sub(letters[i],pos+1,pos)\n           \
    \ local prevLetter = string.sub(letters[i],1,pos-1)\n            outMessage =\
    \ string.sub(outMessage,1,i-1) .. vowelMap[prevLetter] .. vowelMap[nextLetter]\n\
    \        else\n            outMessage = string.sub(outMessage,1,i-1) .. firstLetter\n\
    \        end\n    end\n    return outMessage\nend", "  local vowels = { 'a', 'e',\
    \ 'i', 'o', 'u' }\n  local function swapcase(letter)\n    if letter ~= nil then\n\
    \      letter = string.lower(letter)\n    end\n    return letter\n  end\n  local\
    \ function vowel_replacement(letter)\n    if vowels.include(letter) then\n   \
    \   local position = string.find(vowels, letter) - 1\n      local next = string.sub(vowels,\
    \ position, 1)\n      local new_letter = string.sub(vowels, position, position\
    \ + 2)\n      local result = string.gsub(letter, letter, string.gsub(letter, next,\
    \ new_letter))\n      return swapcase(result)\n    end\n    return letter\n  end\n\
    \  local function replace_vowels(letter)\n    return string.gsub(letter, '[aeiou]',\
    \ vowel_replacement)\n  end\n  local function replace_all( letter )\n    return\
    \ string.gsub(letter, '[aeiou]', replace_vowels)\n  end\n  return string.gsub(message,\
    \ '[^a-zA-Z]', replace_all)\nend", "    local alphabet = {}\n    alphabet[1] =\
    \ 'a'\n    alphabet[2] = 'b'\n    alphabet[3] = 'c'\n    alphabet[4] = 'd'\n \
    \   alphabet[5] = 'e'\n    alphabet[6] = 'f'\n    alphabet[7] = 'g'\n    alphabet[8]\
    \ = 'h'\n    alphabet[9] = 'i'\n    alphabet[10] = 'j'\n    alphabet[11] = 'k'\n\
    \    alphabet[12] = 'l'\n    alphabet[13] = 'm'\n    alphabet[14] = 'n'\n    alphabet[15]\
    \ = 'o'\n    alphabet[16] = 'p'\n    alphabet[17] = 'q'\n    alphabet[18] = 'r'\n\
    \    alphabet[19] = 's'\n    alphabet[20] = 't'\n    alphabet[21] = 'u'\n    alphabet[22]\
    \ = 'v'\n    alphabet[23] = 'w'\n    alphabet[24] = 'x'\n    alphabet[25] = 'y'\n\
    \    alphabet[26] = 'z'\n    alphabet[27] = 'A'\n    alphabet[28] = 'B'\n    alphabet[29]\
    \ = 'C'\n    alphabet[30] = 'D'\n    alphabet[31] = 'E'\n    alphabet[32] = 'F'\n\
    \    alphabet[33] = 'G'\n    alphabet[34] = 'H'\n    alphabet[35] = 'I'\n    alphabet[36]\
    \ = 'J'\n    alphabet[37] = 'K'\n    alphabet[38] = 'L'\n    alphabet[39] = 'M'\n\
    \    alphabet[40] = 'N'\n    alphabet[41] = 'O'\n    alphabet[42] = 'P'\n    alphabet[43]\
    \ = 'Q'\n    alphabet[44] = 'R'\n    alphabet[45] = 'S'\n    alphabet[46] = 'T'\n\
    \    alphabet[47] = 'U'\n    alphabet[48] = 'V'\n    alphabet[49] = 'W'\n    alphabet[50]\
    \ = 'X'\n    alphabet[51] = 'Y'\n    alphabet[52] = 'Z'", "\tlocal result = ''\n\
    \tlocal vowels = {'a','e','i','o','u'}\n\tlocal letters = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \tfor i = 1, #message do\n\t\tlocal current = message[i]\n\t\tfor j = 1, #vowels\
    \ do\n\t\t\tif vowels[j] == current then\n\t\t\t\tlocal next_letter = letters[j-1]\n\
    \t\t\t\tlocal next_vowel = vowels[j+1]\n\t\t\t\tresult = result .. next_letter\n\
    \t\t\t\tif next_letter == next_vowel then\n\t\t\t\t\tresult = result .. next_letter\n\
    \t\t\t\tend\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend",
  "    local decoded = {}\n    local vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E',\
    \ 'I', 'O', 'U'}\n    local pos = 1\n    for char in message:gmatch'[%a]+' do\n\
    \        -- If it is a letter\n        if char in vowels then\n            --\
    \ Add the letter to the decoded string.\n            decoded[#decoded+1] = char\n\
    \        else\n            -- If the letter is not a vowel\n            -- then\
    \ swap all letters after the first vowel with \n            -- the letter that\
    \ appears 2 places ahead of it on the \n            -- english alphabet and save\
    \ it for future use.\n            local next_vowel = letters[(pos:sub(1):upper()):upper()]\n\
    \            decoded[#decoded+1] = next_vowel\n            decoded[#decoded+1]\
    \ = char\n            pos = pos + 1\n        end\n    end\n    -- Add anything\
    \ leftover after the last vowel.\n    decoded[#decoded+1] = letters[pos:sub(1):upper()]\n\
    \    return table.concat(decoded)\nend", "\tlocal alphabet = string.gsub('abcdefghijklmnopqrstuvwxyz',\
    \ 'a', 'Z')\n\tlocal vowels = string.gsub('aeiou', 'a', 'A')\n\tmessage = string.gsub(message,\
    \ '[aeiou]', vowels)\n\tmessage = string.gsub(message, '[aA]', 'Z')\n\tmessage\
    \ = string.gsub(message, '[bB]', 'b')\n\tmessage = string.gsub(message, '[cC]',\
    \ 'c')\n\tmessage = string.gsub(message, '[dD]', 'd')\n\tmessage = string.gsub(message,\
    \ '[eE]', 'e')\n\tmessage = string.gsub(message, '[fF]', 'f')\n\tmessage = string.gsub(message,\
    \ '[gG]', 'g')\n\tmessage = string.gsub(message, '[hH]', 'h')\n\tmessage = string.gsub(message,\
    \ '[iI]', 'i')\n\tmessage = string.gsub(message, '[jJ]', 'j')\n\tmessage = string.gsub(message,\
    \ '[kK]', 'k')\n\tmessage = string.gsub(message, '[lL]', 'l')\n\tmessage = string.gsub(message,\
    \ '[mM]', 'm')\n\tmessage = string.gsub(message, '[nN]', 'n')\n\tmessage = string.gsub(message,\
    \ '[oO]', 'o')\n\tmessage = string.gsub(message, '[pP]', 'p')\n\tmessage = string.gsub(message,\
    \ '[qQ]', 'q')\n\tmessage = string.gsub(message, '[rR]', 'r')\n\tmessage = string.gsub(message,\
    \ '[sS]', 's')\n\tmessage = string.gsub(message, '[tT]', 't')\n\tmessage = string.gsub(message,\
    \ '[uU]', 'u')\n\tmessage = string.gsub(message, '[vV]', 'v')\n\tmessage = string.gsub(message,\
    \ '[wW]', 'w')\n\tmessage = string.gsub(message, '[xX]', 'x')\n\tmessage = string.gsub(message,\
    \ '[yY]', 'y')\n\tmessage = string.gsub(message, '[zZ]', 'z')\n\tmessage = string.gsub(message,\
    \ 'A', 'a')\n\tmessage = string.gsub(message, 'B', 'b')\n\tmessage = string.gsub(message,\
    \ 'C', 'c')\n\tmessage = string.gsub(message, 'D', 'd')\n\tmessage = string.gsub(message,\
    \ 'E', 'e')\n\tmessage = string.gsub(message, 'F', 'f')\n\tmessage = string.gsub(message,\
    \ 'G', 'g')\n\tmessage = string.gsub(message, 'H', 'h')\n\tmessage = string.gsub(message,\
    \ 'I', 'i')\n\tmessage = ", "   -- TODO: fix this\n   for _, letter in pairs(message)\
    \ do\n      local index = string.find(string.lower(letter), 'a'):first\n     \
    \ if index == nil then return message end -- don't know how to handle this\n \
    \     local index2 = string.find(string.lower(letter), 'z'):first\n      if index2\
    \ == nil then return message end -- don't know how to handle this\n      local\
    \ letterIndex = string.sub(letter, index, index2)\n      letterIndex = string.lower(letterIndex)\n\
    \      letterIndex = string.sub(letterIndex, 1, 1)\n      letterIndex = string.find(string.upper(letterIndex),\
    \ 'A'):first\n      if letterIndex == nil then letterIndex = 0 end -- don't know\
    \ how to handle this\n      letterIndex = letterIndex + 2\n      letter = string.sub(letter,\
    \ 1, letterIndex - 1)\n      letter = string.lower(letter)\n      letter = string.upper(letter)\n\
    \      message = string.sub(message, index, -1)\n      message = string.sub(message,\
    \ 1, string.find(message, 'a'):first-1) .. letter .. string.sub(message, string.find(message,\
    \ 'a'):first + 1, string.find(message, 'z'):first)\n   end\n   return message\n\
    end", "  if message == nil then return nil end\n  local message = message:gsub('^%l',\
    \ letter)\n  return message:gsub('aeiou', vowel)\nend", "    local alphabet =\
    \ {\n        [\"a\"] = \"k\",\n        [\"b\"] = \"h\",\n        [\"c\"] = \"\
    y\",\n        [\"d\"] = \"t\",\n        [\"e\"] = \"d\",\n        [\"f\"] = \"\
    h\",\n        [\"g\"] = \"n\",\n        [\"h\"] = \"q\",\n        [\"i\"] = \"\
    p\",\n        [\"j\"] = \"h\",\n        [\"k\"] = \"v\",\n        [\"l\"] = \"\
    p\",\n        [\"m\"] = \"g\",\n        [\"n\"] = \"w\",\n        [\"o\"] = \"\
    d\",\n        [\"p\"] = \"t\",\n        [\"q\"] = \"y\",\n        [\"r\"] = \"\
    k\",\n        [\"s\"] = \"v\",\n        [\"t\"] = \"t\",\n        [\"u\"] = \"\
    w\",\n        [\"v\"] = \"m\",\n        [\"w\"] = \"y\",\n        [\"x\"] = \"\
    f\",\n        [\"y\"] = \"t\",\n        [\"z\"] = \"y\",\n        [\"A\"] = \"\
    K\",\n        [\"B\"] = \"H\",\n        [\"C\"] = \"Y\",\n        [\"D\"] = \"\
    T\",\n        [\"E\"] = \"D\",\n        [\"F\"] = \"H\",\n        [\"G\"] = \"\
    N\",\n        [\"H\"] = \"Q\",\n        [\"I\"] = \"P\",\n        [\"J\"] = \"\
    H\",\n        [\"K\"] = \"V\",\n        [\"L\"] = \"P\",\n        [\"M\"] = \"\
    G\",\n        [\"N\"] = \"W\",\n        [\"O\"] = \"D\",\n        [\"P\"] = \"\
    T\",\n        [\"Q\"] = \"Y\",\n        [\"R\"] = \"K\",\n        [\"S\"] = \"\
    V\",\n        [\"T\"] = \"T\",\n        [\"U\"] = \"W\",\n        [\"V\"] = \"\
    M\",\n        [\"W\"] = \"Y\",\n        [\"X\"] = \"F\",\n        [\"Y\"] = \"\
    T\",\n        [\"Z\"] = \"Y\"\n    }", "    local alphabet = {['A'] = 'A', 'B']\
    \ = 'B', 'C'] = 'C', 'D'] = 'D', 'E'] = 'E', 'F'] = 'F', \n        'G'] = 'G',\
    \ 'H'] = 'H', 'I'] = 'I', 'J'] = 'J', 'K'] = 'K', 'L'] = 'L', 'M'] = 'M', \n \
    \       'N'] = 'N', 'O'] = 'O', 'P'] = 'P', 'Q'] = 'Q', 'R'] = 'R', 'S'] = 'S',\
    \ 'T'] = 'T', \n        'U'] = 'U', 'V'] = 'V', 'W'] = 'W', 'X'] = 'X', 'Y'] =\
    \ 'Y', 'Z'] = 'Z', 'a'] = 'A', \n        'b'] = 'B', 'c'] = 'C', 'd'] = 'D', 'e']\
    \ = 'E', 'f'] = 'F', 'g'] = 'G', 'h'] = 'H', \n        'i'] = 'I', 'j'] = 'J',\
    \ 'k'] = 'K', 'l'] = 'L', 'm'] = 'M', 'n'] = 'N', 'o'] = 'O', \n        'p'] =\
    \ 'P', 'q'] = 'Q', 'r'] = 'R', 's'] = 'S', 't'] = 'T', 'u'] = 'U', 'v'] = 'V',\
    \ \n        'w'] = 'W', 'x'] = 'X', 'y'] = 'Y', 'z'] = 'Z', '?'] = '?', ' ': '',\
    \ '!': '!', '?': '?'};\n    local alphabetRev = {['?'] = '?', ' ': '', '!': '!',\
    \ '?': '?'};\n    local function revChar(c)\n        local ret = alphabetRev[alphabet[c]];\n\
    \        if ret == nil then\n            return string.format(\"%c\", c);\n  \
    \      else\n            return ret;\n        end\n    end\n    local function\
    \ swapCase(c)\n        if string.find(alphabet[c], \"A\", 1, true) then\n    \
    \        ret = string.gsub(alphabet[c], \"A\", alphabetRev[\"A\"]);\n        elseif\
    \ string.find(alphabet[c], \"B\", 1, true) then\n            ret = string.gsub(alphabet[c],\
    \ \"B\", alphabetRev[\"B\"]);\n        elseif string.find(alphabet[c], \"C\",\
    \ 1, true) then\n            ret = string.gsub(alphabet[c], \"C\", alphabetRev[\"\
    C\"]);\n        elseif string.find(alphabet[c], \"D\", 1, true) then\n       \
    \     ret = string.gsub(alphabet[c], \"D\", alphabetRev[\"D\"]);\n        elseif\
    \ string.find(alphabet[c], \"E\", 1, true) then\n            ret = string.gsub(alphabet[c],\
    \ \"E\", alphabetRev[\"E\"]);\n        elseif string.find(alphabet[c], \"F\",\
    \ 1, true) then\n            ret = string.gsub(alphabet[c], \"F\", alphabetRev[\"\
    F\"]);\n        elseif string.find(alphabet[c], \"G\", 1, true) then\n       \
    \     ret = string.gsub(alphabet[c], \"G\", alphabetRev[\"G\"]);", "  local message_encoded\
    \ = message\n  local vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n  for i = 1,\
    \ #message do\n    local letter = string.lower(message[i])\n    local count =\
    \ 0\n    for j = 1, #vowels do\n      if string.lower(vowels[j]) == letter then\n\
    \        count = count + 1\n      end\n    end\n    letter = string.sub(vowels,\
    \ count - 2, count - 1)\n    message_encoded = string.sub(message_encoded, i,\
    \ i + 1) .. letter\n  end\n  return message_encoded\nend", "   -- We start by\
    \ replacing all letters with their counterparts in the \n   -- english alphabet:\n\
    \   local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n   local translated = message",
  "  if #message == 0 then \n    return message\n  end", "    local alphabet = {'\
    \ ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    local vowels = {'a',\
    \ 'e', 'i', 'o', 'u'}", "\t-- TODO: Write the code that returns a string.\n\t\
    return message\nend", "    -- Your code here\n    if message == nil then\n   \
    \     return nil\n    end\n    local vowels = 'aeiouAEIOU'\n    local letters\
    \ = {\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ \n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n\
    \    }\n    local new_message = ''\n    local index = 1\n    local message = tostring(message)\n\
    \    local current_letter = ''\n    for i = 1,#message do\n        if message[i]\
    \ ~= '#' and letters[message[i]] ~= nil then\n            if letters[message[i]]\
    \ == vowels[(index - 1)] then\n                -- if current letter is vowel,\
    \ current letter is second letter of vowel\n                -- replace current\
    \ letter\n                current_letter = letters[message[i]]\n            else\n\
    \                -- if current letter is first letter of vowel, check if current\
    \ letter is vowel\n                if letters[message[i]] == vowels[(index - 1)]\
    \ then\n                    -- if current letter is vowel, current letter is second\
    \ letter of vowel\n                    -- replace current letter\n           \
    \         current_letter = letters[message[i]]\n                else\n       \
    \             -- if current letter is first letter of vowel, check if current\
    \ letter is vowel\n                    -- replace current letter\n           \
    \         current_letter = letters[message[i]]\n                end\n        \
    \    end\n            index = index + 1\n            new_message = new_message\
    \ .. current_letter\n        else\n            new_message = new_message .. message[i]\n\
    \        end\n    end\n    return new_message\nend", "\tlocal vowels = {'a', 'e',\
    \ 'i', 'o', 'u'}\n\tlocal alphabet = {string.char(string.byte('A') + i) for i\
    \ in {0,1}}\n\tlocal message_length = #message\n\tlocal buffer = {}\n\tlocal i,\
    \ j\n\t-- Fill the buffer with '-' characters. \n\tfor i = 1, message_length do\n\
    \t\ttable.insert(buffer, '-')\n\tend\n\t-- Fill the buffer with vowels. \n\tfor\
    \ i = 1, message_length do\n\t\tif vowels:member(message[i]) then\n\t\t\ttable.insert(buffer,\
    \ message[i])\n\t\tend\n\tend\n\t-- Fill the buffer with characters corresponding\
    \ to their position\n\t-- in the alphabet of 2 places ahead. \n\tfor i = 1, message_length\
    \ do\n\t\tj = i + 2\n\t\tif j > message_length then\n\t\t\tj = message_length\n\
    \t\tend\n\t\tif alphabet:member(message[i]) then\n\t\t\ttable.insert(buffer, alphabet[alphabet.indexOf(message[i])\
    \ + j])\n\t\tend\n\tend\n\t-- Add the '-' at the end. \n\ttable.insert(buffer,\
    \ '-')\n\treturn table.concat(buffer, '') \nend", "  -- TODO: Add your implementation\
    \ here\n  -- Don't forget to return a string -- not an integer!\n  return message\n\
    end", "  local message = string.lower(message)\n  \n  local vowels = { 'a', 'e',\
    \ 'i', 'o', 'u' }\n  local alphabet = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z' }\n  \n  for i = 1, #message do\n    local letter = message[i]\n  \
    \  for j = 1, #vowels do\n      letter = string.gsub(letter, '[%a]', alphabet[string.find(vowels,\
    \ letter) + j])\n    end\n    \n    message = string.gsub(message, '%a', letter)\n\
    \  end\n  \n  return message\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local vowels = { 'a','e','i','o','u','y','A','E','I','O','U','Y' }\n    local\
    \ newMessage = message\n    for i = 1,#message do\n        for j = 1,#alphabet\
    \ do\n            newMessage = newMessage:gsub( alphabet:sub(i,i),alphabet:sub(j,j):lower()\
    \ )\n        end\n        for i = 1,#vowels do\n            newMessage = newMessage:gsub(\
    \ vowels:sub(i,i), alphabet:sub(i,i) )\n        end\n    end\n    return newMessage\n\
    end", "\tlocal newString = '' \n\tlocal vowels = {'a','e','i','o','u'}\n\tlocal\
    \ alphabet = {\n\t\t\"z\",\"a\",\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\"\
    ,\"l\",\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\n\t\t\"t\",\"v\",\"w\",\"x\",\"y\"\
    ,\"z\"\n\t}\n\tfor i = 1, #message do\n\t\tlocal letter = message[i]\n\t\tlocal\
    \ newLetter = nil\n\t\tif #vowels == 0 then \n\t\t\tfor j = 1, #alphabet do \n\
    \t\t\t\tif alphabet[j] == letter then \n\t\t\t\t\tnewLetter = alphabet[j+1]\n\t\
    \t\t\tend\n\t\t\tend\n\t\telse \n\t\t\tfor j = 1, #vowels do \n\t\t\t\tif vowels[i]\
    \ == letter then \n\t\t\t\t\tnewLetter = alphabet[j+1]\n\t\t\t\tend\n\t\t\tend\n\
    \t\tend\n\t\tif newLetter ~= nil then \n\t\t\tif i == 1 then \n\t\t\t\tnewString\
    \ = newString .. newLetter\n\t\t\telse \n\t\t\t\tnewString = newString .. newLetter\
    \ .. ' ' \n\t\t\tend\n\t\tend \n\tend\n\treturn newString\nend", "  -- Write your\
    \ code here.\n  return nil\nend", "    local result = \"\"\n    for letter in\
    \ string.gsub(message, \"[a-z]\", function (letter)\n        local position\n\
    \        for position = #alphabet do \n            if alphabet[position] == letter\
    \ then\n                return alphabet[position + 1]\n            end\n     \
    \   end\n        return letter\n    end)\n    return string.gsub(message, \"[aeiou]\"\
    , function (letter)\n        local position\n        for position = #alphabet\
    \ do \n            if alphabet[position] == letter then\n                return\
    \ alphabet[position + 1]\n            end\n        end\n        return letter\n\
    \    end)\nend\n</cell>\n<text>\nWrite a function that decodes in a manner that\
    \ takes messages in that \nmanner. Assume only letters. \nExample:\n>>> decode('TGST')\n\
    'test'\n>>> decode('tHKS KS C MGSSCGG')\n'This is a message'\nHints:\nstring.gsub\n\
    string.sub\nstring.match", "    local result = \"\"\n    for i = 1, #message do\
    \ \n        local letter = string.sub(message, i, i)\n        local letterNumber\
    \ = string.sub(message, i, i+1)\n        if letter ~= nil then\n            letter\
    \ = string.lower(letter)\n        end\n        -- Replace all vowels\n       \
    \ if letterNumber ~= nil then\n            letter = string.sub(alphabet, letterNumber+1,\
    \ letterNumber+2)\n        end\n        -- Replace letters in message with vowels\
    \ 2 places ahead of them\n        if letter ~= nil then\n            letter =\
    \ string.sub(alphabet, letterNumber+2, letterNumber+3)\n        end\n        if\
    \ letter ~= nil then\n            result = result .. string.sub(alphabet, letterNumber+1,\
    \ letterNumber+1) .. letter\n        end\n    end\n    return result\nend", " \
    \   local letters = {}\n    local vowels = \"aeiou\"\n    for letter, index in\
    \ pairs(message) do\n        letters[letter] = letter\n    end\n    local vowelMap\
    \ = {}\n    for i = 1, #vowels do\n        vowelMap[i + 1] = vowels[i]\n    end\n\
    \    for letter, index in pairs(message) do\n        local vowel = letters[letter]:sub(1,\
    \ 2)\n        letters[letter] = vowelMap[vulgs[vowel]]\n    end\n    return table.concat(letters)\n\
    end", "  -- Your code here\n  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \  local vowels = \"aeiou\"", "    local encoded = message\n    local letters\
    \ = string.gsub(message, '[AEIOUYaeiouy]+', ' ')\n    for _, letter in pairs(letters)\
    \ do\n        if letter:byte() > 0 then\n            encoded = string.gsub(encoded,\
    \ letter:byte()-1, letter:byte()+letter:byte())\n        end\n    end\n    encoded\
    \ = string.gsub(encoded, ' $', ' $')\n    for _, letter in pairs(string.gsub(message,\
    \ '([AEIOUYaeiouy])', '\\\\1')) do\n        if letter:byte() > 0 then\n      \
    \      encoded = string.gsub(encoded, letter:byte()-1, letter:byte()+letter:byte())\n\
    \        end\n    end\n    return encoded\nend", "  -- Write your code here\n\
    \  -- Use a nested table or hashmap.\n  -- \n  return message\nend", "    -- Write\
    \ your code here.\nend", "\tlocal alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \n\tlocal vowels = \"aeiouy\"\n\tlocal output\n\tfor i = 1, #message do \n\t\t\
    local letter = message:sub(i,i)\n\t\tlocal pos = alphabet:find(letter)\n\t\tfor\
    \ j = 1, #vowels do\n\t\t\tlocal vowel = vowels:sub(j, j)\n\t\t\tif pos > 0 and\
    \ letter == vowel:sub(1, 1) then\n\t\t\t\tpos = alphabet:find(vowel:sub(1,1))\n\
    \t\t\t\tletter = letter:sub(1,1)\n\t\t\tend\n\t\tend\n\t\toutput = output .. alphabet:sub(pos,\
    \ pos) .. letter\n\tend\n\treturn output\nend", "    local alphabet = {}\n   \
    \ for i = 1, #ENGLISH_ALPHABET do\n        alphabet[i] = ENGLISH_ALPHABET[i]\n\
    \    end\n    \n    local function rev(alphabet, i, v)\n        alphabet[i] =\
    \ alphabet[alphabet[i]]\n    end\n    \n    local function rev_count(alphabet,\
    \ i, v)\n        alphabet[i] = alphabet[alphabet[i]] + 1\n    end\n    \n    local\
    \ function rev_swap(alphabet, i, v)\n        alphabet[i] = alphabet[alphabet[i]]\
    \ .. ENGLISH_ALPHABET[alphabet[i] - 1]\n    end\n    \n    local function rev_swap_counts(alphabet,\
    \ i, v)\n        alphabet[i] = alphabet[alphabet[i]] - 1\n    end\n    \n    local\
    \ function rev_swap_and_count(alphabet, i, v)\n        alphabet[i] = alphabet[alphabet[i]]\
    \ .. ENGLISH_ALPHABET[alphabet[i] - 1]\n        rev_count(alphabet, i, v)\n  \
    \  end\n    \n    local function rev_swap_and_count(alphabet, i, v)\n        alphabet[i]\
    \ = alphabet[alphabet[i]] .. ENGLISH_ALPHABET[alphabet[i] - 1]\n        rev_swap_counts(alphabet,\
    \ i, v)\n    end\n    \n    local function rev_swap_and_count(alphabet, i, v)\n\
    \        alphabet[i] = alphabet[alphabet[i]] .. ENGLISH_ALPHABET[alphabet[i] -\
    \ 1]\n        rev_swap_counts(alphabet, i, v)\n    end\n    \n    local function\
    \ rev_swap_and_count(alphabet, i, v)\n        alphabet[i] = alphabet[alphabet[i]]\
    \ .. ENGLISH_ALPHABET[alphabet[i] - 1]\n        rev_swap_counts(alphabet, i, v)\n\
    \    end\n    \n    local function rev_swap_and_count(alphabet, i, v)\n      \
    \  alphabet[i] = alphabet[alphabet[i]] .. ENGLISH_ALPHABET[alphabet[i] - 1]\n\
    \        rev_swap_counts(alphabet, i, v)\n    end\n    \n    local function rev_swap_and_count(alphabet,\
    \ i, v)\n        alphabet[i] = alphabet[alphabet[i]] .. ENGLISH_ALPHABET[alphabet[i]\
    \ - 1]\n        rev_swap_counts(alphabet, i, v)\n    end\n    \n    local function\
    \ rev_swap_and_count(alphabet, i, v)\n        alphabet[i] = alphabet[alphabet[i]]\
    \ .. ENGLISH_ALPHABET[alphabet[i] - 1]\n        rev_swap_counts(alphabet, i, v)\n\
    \    end\n    \n    local function rev_swap_and_count(alphabet, i, v)\n      \
    \  alphabet[i] = alphabet[alphabet[i]] .. EN", "    local result = \"\"\n    local\
    \ vowels = \"aeiouy\"\n    for i = 1, #message do\n        local char = string.sub(message,\
    \ i, i)\n        if string.find(vowels, char) then\n            local vowel_position\
    \ = string.find(vowels, char)\n            local vowel_next = string.sub(message,\
    \ i+1, 1)\n            local new_letter = string.sub(message, i+1, vowel_position+1)\n\
    \            local new_vowel = string.sub(message, i+1, vowel_position-1)\n  \
    \          result = result .. (string.lower(new_letter)..\n                string.upper(new_vowel))\n\
    \        else\n            result = result .. (string.lower(char))\n        end\n\
    \    end\n    return result\nend", "  local vowels = {'a', 'e', 'i', 'o', 'u',\
    \ 'A', 'E', 'I', 'O', 'U'}\n  local capitals = {'A', 'E', 'I', 'O', 'U'}\n  local\
    \ letters = {string.gsub(message, \"%c\", \n\t\t\t\t function(letter)\n\t\t\t\t\
    \   return string.sub(letter, 1, 1) == 'a'\n\t\t\t\t     and letter ~= letter\n\
    \t\t\t\t       and string.find(vowels, letter)\n\t\t\t\t       or string.find(capitals,\
    \ letter)\n\t\t\t\t     end\n\t\t\t\t  )} \n  local vowels2 = {string.gsub(message,\
    \ \"%c\", \n\t\t\t\t function(letter)\n\t\t\t\t   return string.sub(letter, 1,\
    \ 1) == 'a'\n\t\t\t\t     and letter ~= letter\n\t\t\t\t       and string.find(vowels,\
    \ letter)\n\t\t\t\t       or string.find(capitals, letter)\n\t\t\t\t     end\n\
    \t\t\t\t  )} \n  local capitals2 = {string.gsub(message, \"%c\", \n\t\t\t\t function(letter)\n\
    \t\t\t\t   return string.sub(letter, 1, 1) == 'A'\n\t\t\t\t     and letter ~=\
    \ letter\n\t\t\t\t       and string.find(vowels, letter)\n\t\t\t\t       or string.find(capitals,\
    \ letter)\n\t\t\t\t     end\n\t\t\t\t  )} \n  for _, letter in ipairs(letters)\
    \ do\n    if string.sub(letter, 1, 1) ~= 'a' then\n      letter = string.upper(letter)\n\
    \    end\n  end\n  \n  -- Swap\n  for _, letter in ipairs(letters) do\n    letters[#letters]\
    \ = letter\n  end\n  \n  for _, letter in ipairs(letters) do\n    letters[#letters]\
    \ = letter\n  end\n  \n  -- Replace vowels\n  for _, letter in ipairs(letters)\
    \ do\n    if string.find(vowels, letter) then\n      letter = string.sub(letter,\
    \ 1, 2) .. letters[string.find(vowels2, letter)] .. string.sub(letter, 3)\n  \
    \  end\n  end\n  \n  -- Replace capitals\n  for _, letter in ipairs(letters) do\n\
    \    if string.find(capitals, letter) then\n      letter = string.sub(letter,\
    \ 1, 2) .. letters[string.find(capitals2, letter)] .. string.sub(letter, 3)\n\
    \    end\n  end\n  \n  return table.concat(letters, \"\")\nend", "  local translate\
    \ = {\n    ['A'] = 'N',\n    ['B'] = 'O',\n    ['C'] = 'A',\n    ['D'] = 'E',\n\
    \    ['E'] = 'U',\n    ['F'] = 'I',\n    ['G'] = 'O',\n    ['H'] = 'A',\n    ['I']\
    \ = 'A',\n    ['J'] = 'E',\n    ['K'] = 'S',\n    ['L'] = 'U',\n    ['M'] = 'E',\n\
    \    ['N'] = 'A',\n    ['O'] = 'B',\n    ['P'] = 'I',\n    ['Q'] = 'O',\n    ['R']\
    \ = 'U',\n    ['S'] = 'I',\n    ['T'] = 'U',\n    ['U'] = 'A',\n    ['V'] = 'E',\n\
    \    ['W'] = 'I',\n    ['X'] = 'A',\n    ['Y'] = 'U',\n    ['Z'] = 'I'\n  }\n\
    \  local result = ''\n  for char in message:gmatch'([A-Z])+' do\n    char = translate[char]\n\
    \    local next = translate[string.sub(message, 1, 1)] or string.sub(message,\
    \ 2, 1)\n    \n    if not result then \n      result = char\n    elseif next ==\
    \ 'S' then\n      result = result .. char\n    else\n      result = result ..\
    \ string.sub(message, 1, 1) .. string.sub(message, 2, 1) \n    end\n  end\n  return\
    \ result\nend", "   -- Write your code here\n   local function toUppercase(str)\n\
    \      -- Write your code here\n      local result = ''\n      for i = 1, #str\
    \ do\n         if string.sub(str, i, i) ~= nil then\n            local upper =\
    \ string.sub(str, i, i):upper()\n            result = (result .. upper):sub(1,\
    \ upper:len() + 1)\n         end\n      end\n      return result\n   end\n   local\
    \ function vowels(str)\n      -- Write your code here\n      local vowels = {'a',\
    \ 'e', 'i', 'o', 'u'}\n      local index = {}\n      for _, v in ipairs(vowels)\
    \ do\n         index[v] = true\n      end\n      local result = ''\n      for\
    \ i = 1, #str do\n         local letter = string.sub(str, i, i)\n         if index[letter]\
    \ then\n            local letter2 = string.sub(str, i - 2, i)\n            letter\
    \ = letter2 .. letter:lower()\n         end\n         result = result .. letter\n\
    \      end\n      return result\n   end\n   local function swapCase(str)\n   \
    \   -- Write your code here\n      local new = ''\n      for i = 1, #str do\n\
    \         local letter = string.sub(str, i, i)\n         if letter ~= nil then\n\
    \            local upcase = letter:upper()\n            new = (new .. upcase):sub(1,\
    \ upcase:len() + 1)\n         end\n      end\n      return new\n   end\n   local\
    \ function vowelCount(str)\n      -- Write your code here\n      local vowels\
    \ = {'a', 'e', 'i', 'o', 'u'}\n      local count = #vowels\n      for i = 1, #str\
    \ do\n         local letter = string.sub(str, i, i)\n         if letter ~= nil\
    \ then\n            local count = #vowels\n            for _, v in ipairs(vowels)\
    \ do\n               local sub = letter:find(v)\n               if sub ~= nil\
    \ then\n                  count = count - 1\n               end\n            end\n\
    \            if count > 0 then\n               count = count - 1\n           \
    \ end\n         end\n      end\n      return count\n   end\n   local function\
    \ encode(message)\n      local result = message\n      if #result > 0 then\n \
    \        local firstLetter = string.sub(result, 1, 1)\n         local newLetter\
    \ = firstLetter:upper()\n         if firstLetter ~= nil and newLetter ~= nil then\n\
    \            if firstLetter:lower() == 'a' and newLetter:lower() == 'e' then\n\
    \               newLetter = string.sub(result, 2, 2)\n            end\n      \
    \      if firstLetter:lower() == 'a' and newLetter:lower() == 'i' ", "    local\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    local vowels = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY",
  "    message = string.upper(message)\n    local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    local alphabetLen = #alphabet\n    for i = 1, #message do\n        local\
    \ letter = string.sub(message, i, i)\n        if letter == \"A\" or letter ==\
    \ \"E\" or letter == \"I\" or letter == \"O\" or letter == \"U\" then\n      \
    \      letter = string.sub(message, i - 1, i + 1)\n            letter = alphabet[alphabet.indexOf(letter)\
    \ + alphabetLen - 1]\n        end\n        message = string.sub(message, i, i)\
    \ + letter\n    end\n    return message\nend", "    local output=''\n    local\
    \ i\n    for i=1,#message do \n        local x=string.lower(message[i])\n    \
    \    local pos=string.find(x, 'a')\n        if pos ~= nil then\n            x=string.upper(string.sub(x,\
    \ pos-1, pos+1))\n        end \n        local y=string.find(x, 'a')\n        if\
    \ y ~= nil then\n            if y>1 then \n                output=output..string.sub(x,\
    \ y-2, y)..string.lower(string.sub(x, 1, y))\n            else\n             \
    \   output=output..string.upper(x)\n            end\n        else\n          \
    \  output=output..x\n        end\n    end\n    return output\nend", "  local function\
    \ swapcase(char)\n    return string.gsub(string.lower(char), \n              \
    \        'a', function(c) return string.upper(c) end)\n  end\n  local function\
    \ vowel_swap(char)\n    local alphabet = 'bcdfghjklmnpqrstvwxyz'\n    local position\
    \ = alphabet == string.lower(char) and 1 or 2\n    \n    return string.sub(alphabet,\
    \ position - 1, position + #alphabet)\n  end\n  return string.gsub(message, '%l',\
    \ swapcase) .. \n           string.gsub(message, '%L', vowel_swap)\nend", "  --\
    \ Create a variable called 'alphabet' that will hold the \n  -- letters of the\
    \ english alphabet without vowels\n  local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  -- Create a variable called 'output' that will hold the \n  -- output string\
    \ after swapping case and vowels\n  local output = \"\"\n  -- Loop over each character\
    \ in the message\n  for i, c in string.gmatch(message, \"%a\") do\n    -- Check\
    \ if the current character is in the alphabet\n    if string.find(alphabet, c)\
    \ then\n      -- If it is, swap case with the character in alphabet \n      --\
    \ 2 places ahead of the current character\n      output = string.sub(alphabet,\
    \ \n        string.find(alphabet, c) + 2, \n        string.find(alphabet, c) +\
    \ 2)\n      -- Re-insert the current character in the output string\n      output\
    \ = output .. string.sub(alphabet, string.find(alphabet, c), string.find(alphabet,\
    \ c) + 1)\n      -- Finally, re-insert the current character in the alphabet\n\
    \      output = output .. c\n    end\n  end\n  return output\nend", "    local\
    \ buffer = {}\n    for i = 1, #message do\n        local letter = string.lower(message[i])\n\
    \        if letter ~= 'a' and letter ~= 'e' and letter ~= 'i' and letter ~= 'o'\
    \ and letter ~= 'u' then\n            table.insert(buffer, letter)\n        else\n\
    \            local index = string.find(letter, 'a')\n            if index then\n\
    \                local letter = string.sub(letter, 1, index-1)\n             \
    \   table.insert(buffer, letter)\n            else\n                local vowels\
    \ = {}\n                for j = 1, #VOWELS do\n                    vowels[VOWELS[j]]\
    \ = false\n                end\n                for j = index, #message do\n \
    \                   local letter = string.lower(message[j])\n                \
    \    if letter ~= 'a' and letter ~= 'e' and letter ~= 'i' and letter ~= 'o' and\
    \ letter ~= 'u' then\n                        vowels[letter] = true\n        \
    \            end\n                end\n                table.insert(buffer, VOWELS[#VOWELS])\n\
    \                for j = index, #message do\n                    local letter\
    \ = string.lower(message[j])\n                    if vowels[letter] then\n   \
    \                     table.insert(buffer, letter)\n                    end\n\
    \                end\n            end\n        end\n    end\n    return table.concat(buffer)\n\
    end", "  local encoded = message\n  local vowels = \"AEIOUaeiou\"\n  for i = 1,\
    \ #vowels, 2 do\n    encoded = substitute(encoded, vowels, vowels, i)\n  end\n\
    \  return encoded\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local vowels = string.gsub(message, '[aeiou]', '')\n    local newmessage\
    \ = ''\n    for i = 1, #message do \n        local letter = alphabet:sub((i -\
    \ 1) % #alphabet, i)\n        local vowel = alphabet:sub(i + 1, i + 2)\n     \
    \   newmessage = newmessage .. string.sub(vowels, vowel:len()) .. letter\n   \
    \ end\n    return newmessage\nend", "    local encoded = \"\"\n    for letter,\
    \ place in pairs(string.gmatch(message, \"([A-Z])\")) do\n        if place > 1\
    \ then\n            local vowel = string.sub(message, place - 1, 1)\n        \
    \    local next = string.sub(message, place)\n            local nextLetter = string.sub(message,\
    \ place + 1)", "\tlocal function replace_vowel(letter)\n\t\tlocal lookup = { 'A',\
    \ 'a', 'B', 'b', 'C', 'c', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f', 'I', 'i', 'J',\
    \ 'j', 'K', 'k', 'L', 'l', 'M', 'm', 'N', 'n', 'O', 'o', 'P', 'p', 'R', 'r', 'S',\
    \ 's', 'T', 't', 'U', 'u', 'V', 'v', 'W', 'w', 'X', 'x', 'Y', 'y', 'Z', 'z' }\n\
    \t\tlocal vowel\n\t\tif lookup[letter]~=nil then\n\t\t\tvowel = lookup[letter]\n\
    \t\telse\n\t\t\tvowel = letter\n\t\tend\n\t\t-- Write your function here\n\t\t\
    return letter\n\tend\n\t-- Write your function here\n\tlocal message = \"\"\n\t\
    for _,c in ipairs(message) do\n\t\tif c == 'A' or c == 'a' then\n\t\t\tmessage\
    \ = message .. replace_vowel(c)\n\t\telseif c == 'B' or c == 'b' then\n\t\t\t\
    message = message .. replace_vowel(c)\n\t\telseif c == 'C' or c == 'c' then\n\t\
    \t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'D' or c == 'd' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'E' or c == 'e' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'F' or c == 'f' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'G' or c == 'g' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'H' or c == 'h' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'I' or c == 'i' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'J' or c == 'j' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'K' or c == 'k' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'L' or c == 'l' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'M' or c == 'm' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'N' or c == 'n' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'O' or c == 'o' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'P' or c == 'p' then\n\
    \t\t\tmessage = message .. replace_vowel(c)\n\t\telseif c == 'Q' or c == 'q' then\n\
    \t\t\tmessage = message .. replace_vowel", "\t-- Write your code here. For example:\n\
    \t-- local letters = 'abcdefghijklmnopqrstuvwxyz'\n\t-- return message:gsub('.',function(letter)\n\
    \t-- return letters[letter:lower():match('-')]+letters[letter:upper():match('-')]\
    \ \n\t-- end)\nend", "  -- Base case\n  if message == '' then\n    return ''\n\
    \  end", "  -- Write your solution below:\n  -- Note that we assume only letters.\n\
    \  local new_message = ''\n  for i = 1, message:len() do\n    -- We want 2 occurrences\
    \ of \"a\"s before the vowel, 2 occurrences of \"o\"s after\n    -- it, and 1\
    \ occurrence of \"e\"s after the vowel.\n    -- The 'a' count is easy: just look\
    \ for the next occurrence of the vowel.\n    -- The 'o' and 'e' counts require\
    \ a little tricky: we assume there is an\n    -- occurrence of the vowel immediately\
    \ after the one we're interested in\n    -- (so that we can't just look one place\
    \ before), so we can look for the \n    -- vowel 4 places after. This means we\
    \ have to remember the last occurrence \n    -- of the vowel we're interested\
    \ in, and add 2 after it.\n    -- The first occurrence of \"o\" and \"e\" are\
    \ a bit harder: we need to keep \n    -- a record of the last occurrence of the\
    \ vowel we were interested in, and look\n    -- back for 2 places after it. How\
    \ we do that is left as an exercise for the\n    -- reader ;)\n    local current_char\
    \ = message:sub(i, i)\n    if current_char == 'a' then\n      new_message = new_message\
    \ .. \"a\"\n      i = i + 3\n    else if current_char == 'e' then\n      new_message\
    \ = new_message .. \"e\"\n      i = i + 2\n    elseif current_char == 'o' then\n\
    \      new_message = new_message .. \"o\"\n      i = i - 1\n    else if current_char\
    \ == 'u' then\n      -- Note that in python we could just use string.translate,\
    \ but I want\n      -- to do this in Lua, so we instead have to make a translation\
    \ table.\n      local translation_table = {['u'] = 'v'}\n      new_message = new_message\
    \ .. string.translate(translation_table, i)\n      i = i + 2\n    end\n  end\n\
    \  return new_message\nend", "  -- Write your solution here\n  local alpha = \"\
    abcdefghijklmnopqrstuvwxyz\"\n  local vowels = \"aeiouAEIOU\"\n  local vowels_map\
    \ = {\n    [\"a\"] = \"a\",\n    [\"e\"] = \"e\",\n    [\"i\"] = \"i\",\n    [\"\
    o\"] = \"o\",\n    [\"u\"] = \"u\",\n    [\"A\"] = \"a\",\n    [\"E\"] = \"e\"\
    ,\n    [\"I\"] = \"i\",\n    [\"O\"] = \"o\",\n    [\"U\"] = \"u\",\n  }\n  local\
    \ map = {}\n  for i = 1, #message do\n    local letter = message[i]\n    map[letter]\
    \ = alpha:sub(i, i + 1):sub(#letter + 2)\n  end\n  return message:gsub(\"[\" ..\
    \ vowels .. \"]\", function(letter)\n    return vowels_map[map[letter]]\n  end)\n\
    end", "  local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  local vowels = \"\
    AEIOU\"\n  local index = 1\n  local output = ''\n  for i = 1, #message, 1 do\n\
    \    local letter = message[i]\n    local replacement = ''\n    if (letter ==\
    \ 'A') or (letter == 'E') or (letter == 'I') or (letter == 'O') or (letter ==\
    \ 'U') then\n      replacement = alphabet[index + 1]\n      index = index + 2\n\
    \    end\n    \n    for j = 1, #vowels, 1 do\n      if (vowels[j] == letter) then\n\
    \        replacement = alphabet[index]\n        index = index + 1\n      end\n\
    \    end\n    \n    output = output .. replacement\n  end\n  return output\nend",
  "\t-- Write your function here.\nend", "  local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  -- Create a table of the letters in alphabet. \n  -- The keys of the table\
    \ are the letters in alphabet and the \n  -- values are the letters that appear\
    \ in the english alphabet \n  -- (letters that have a case difference with those\
    \ in the \n  -- english alphabet).\n  local letters = {}\n  -- Initialize a variable\
    \ to store the letter that appears \n  -- 2 places ahead of the vowel. \n  local\
    \ previous\n  -- For each letter in message. \n  for letter in message:gmatch(\"\
    [^A-Za-z]+\") do\n    -- If the letter is a vowel, store the letter. \n    if\
    \ letter == \"A\" or letter == \"E\" or letter == \"I\" then\n      previous =\
    \ letter\n      -- If the letter is not a vowel, store the letter. \n    else\
    \ \n      -- Create a list of the letters whose case difference \n      -- with\
    \ letter in english alphabet is in letters \n      -- (the list will contain the\
    \ letters in alphabet that are \n      -- case difference with letter in english\
    \ alphabet). \n      local diffs = {}\n      -- Initialize a variable to store\
    \ the letter that appears \n      -- 2 places ahead of letter in english alphabet.\
    \ \n      local letter\n      for letter in alphabet:gmatch(\"[^A-Za-z]+\") do\n\
    \        -- If the letter in english alphabet and letter are \n        -- both\
    \ not vowels, add the letter to a list of the \n        -- letters in alphabet\
    \ that have case difference \n        -- with letter in english alphabet. \n \
    \       if letter ~= letter then\n          if letter ~= previous and letter ~=\
    \ letter:lower() then\n            table.insert(diffs, letter)\n          end\n\
    \        end\n      end\n      -- If the list has more than one letter, then the\
    \ \n      -- letter is in the english alphabet. \n      if #diffs > 0 then\n \
    \       -- If letter in english alphabet and letter are \n        -- not case\
    \ difference, then letter is case \n        -- difference with the letter in english\
    \ alphabet. \n        -- Add letter to letters in alphabet whose case \n     \
    \   -- difference with letter in english alphabet is \n        -- the letter in\
    \ english alphabet. \n        table.insert(letters, letter)\n      -- If the list\
    \ has one letter, then the letter is in \n      -- english alphabet. \n      else\n\
    \        -- If letter in english alphabet and letter are \n        -- not case\
    \ difference, then letter is case \n        -- difference with the letter in english\
    \ alphabet. \n        ", '  if message == nil then return nil end', "   -- The\
    \ \"dictionary\" below is just a list of vowels and two letters\n   -- (one letter\
    \ ahead of the vowel). \n   -- You can add more letters if you like. \n   local\
    \ vowels = {'a','e','i','o','u'}\n   local dictionary = {\"d\",\"f\",\"g\",\"\
    h\",\"j\",\"k\",\"l\",\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"\
    x\",\"y\"}\n   local output = ''", "    -- Replace all vowels in the message with\
    \ its index \n    -- in the alphabet.\n    message = string.gsub(message, '[aeiou]',\
    \ function(vowel)\n        return string.sub(alphabet, string.len(alphabet) -\
    \ vowel + 1, \n            string.len(alphabet) - vowel)\n    end)", "    local\
    \ alphabet = {\n        -- NOTE: These first 3 entries are the same as in the\
    \ question \n        -- -- above. \n        'A', 'B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', \n        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z', \n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', \n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z', \n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', \n        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z', \n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ \n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', \n\
    \        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', \n \
    \       'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', \n  \
    \      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', \n   \
    \     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', \n    \
    \    -- NOTE: This next entry is different from the question above. \n       \
    \ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', \n        'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', \n        'a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', \n        'n', 'o', 'p',\
    \ 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', \n        'A', 'B', 'C', 'D',\
    \ 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', \n        'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', \n        'a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', \n        'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z', \n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\
    \ 'I', 'J', 'K', 'L', 'M', \n        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z', \n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h", "  local\
    \ alphabet = string.letters .. string.digits\n  local vowels = \"aeiouAEIOU\"\n\
    \  local mapping = {}\n  -- Build a mapping from each letter to its position in\
    \ alphabet\n  for i = 1, #message do\n    local letter = message[i]\n    mapping[letter]\
    \ = i\n  end\n  -- Build an index of each vowel\n  -- index = {vowel, vowel, ...}\n\
    \  local index = {}\n  for i = 1, #vowels do\n    index[vowels[i]] = i\n  end\n\
    \  -- Map each letter to the letter that appears 2 places ahead of \n  -- the\
    \ vowel. \n  -- Example: tHKS KS C MGSSCGG\n  for i = 1, #message do\n    local\
    \ letter = message[i]\n    local mappedLetter = alphabet[mapping[letter]]\n  \
    \  local twoLettersBefore = alphabet[index[letter]] \n    mapping[letter] = alphabet[index[letter]\
    \ + 2]\n    mapping[twoLettersBefore] = alphabet[index[letter] + 1]\n  end\n \
    \ -- Build the resulting string\n  return table.concat(mapping, \"\")\nend", " \
    \ local function replaceVowels(vowel, letter)\n    if vowel == 'a' or vowel ==\
    \ 'e' or vowel == 'i' or vowel == 'o' or vowel == 'u' then\n      return letter\n\
    \    else\n      return letter .. vowel\n    end\n  end\n  \n  local function\
    \ replaceLetters(letter, letterVowelPair)\n    local function replaceVowels1(vowel,\
    \ letter)\n      local letterVowelPair2 = letterVowelPair\n      if vowel == 'a'\
    \ or vowel == 'e' or vowel == 'i' or vowel == 'o' or vowel == 'u' then\n     \
    \   return letter\n      else\n        return letter .. vowel\n      end\n   \
    \ end\n    local function replaceVowels2(vowel, letterVowelPair2)\n      local\
    \ letterVowelPair3 = letterVowelPair2\n      if vowel == 'a' or vowel == 'e' or\
    \ vowel == 'i' or vowel == 'o' or vowel == 'u' then\n        return letterVowelPair2\n\
    \      else\n        return letterVowelPair2 .. vowel\n      end\n    end\n  \
    \  \n    local letterVowelPair = letter\n    for i = 1, #letter do\n      letterVowelPair\
    \ = replaceVowels(letterVowelPair, letter[i])\n    end\n    return replaceLetters(letter,\
    \ letterVowelPair)\n  end\n  \n  local letters = string.gsub(message, '%l%c%l%c',\
    \ '')\n  local letterVowelPairs = {}\n  for i = 1, #letters do\n    local letter\
    \ = letters[i]\n    local letterVowelPair = letter\n    for j = 1, 2 do\n    \
    \  letterVowelPair = replaceVowels(letterVowelPair, letter[j])\n    end\n    table.insert(letterVowelPairs,\
    \ letterVowelPair)\n  end\n  \n  local newMessage\n  for i = 1, #letterVowelPairs\
    \ do\n    local letterVowelPair = letterVowelPairs[i]\n    local letterVowelPair2\
    \ = letterVowelPairs[i + 1]\n    local letterVowelPair3 = letterVowelPairs[i +\
    \ 2]\n    \n    local letter = letterVowelPair\n    for j = 1, #letterVowelPairs\
    \ do\n      local letter2 = letterVowelPair2\n      for k = 1, #letterVowelPairs\
    \ do\n        local letter3 = letterVowelPair3\n        if i == j and i == k and\
    \ i == j then\n          ", "  -- Find the letter that appears 2 places ahead\
    \ of the vowel in the \n  -- english alphabet. \n  local vowel = 'A' -- Assume\
    \ only letters. \n  local letters = {}\n  -- Iterate over the message, looking\
    \ for any letters that appears \n  -- in english alphabet 2 places ahead. \n \
    \ for i = 1, #message do\n    local letter = message[i]:upper()\n    if letter:byte()\
    \ > 127 then -- Assume only letters. \n      table.insert(letters, letter)\n \
    \   end\n  end\n  -- Iterate over the letters and swap case for all letters in\
    \ the \n  -- message that are in the english alphabet. \n  for i = 1, #letters\
    \ do\n    local letter = letters[i]\n    for j = 1, #message do\n      -- If the\
    \ letter is in the english alphabet and appears 2 \n      -- places ahead, swap\
    \ case with the letter that appears 2 \n      -- places ahead.\n      if message[j]:byte()\
    \ == letter then\n        message[j], message[j+1] = message[j+1], message[j]\n\
    \      end\n    end\n  end\n  return table.concat(message) -- return table with\
    \ changed case\nend", "  -- write your answer here\n  return nil\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
