name: HumanEval_58_common
language: lua
prompt: "-- Return sorted unique common elements for two lists.\n-- >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n-- [1, 5, 653]\n-- >>> common([5,\
  \ 3, 2, 8], [3, 2])\n-- [2, 3]\nlocal function common(l1, l2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = common\n\
  \    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}),\
  \ {1, 5, 653})\n    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})\n \
  \   lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})\n    lu.assertEquals(candidate({4,\
  \ 3, 2, 8}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #l1 == 0 then return l2 end\n  if #l2 == 0 then return l1 end\n\
    \  local i1 = 1\n  local i2 = 1\n  local i\n  local l3 = {}\n  repeat\n    if\
    \ l1[i1] == l2[i2] then\n      l3[#l3 + 1] = l1[i1]\n      i1 = i1 + 1\n     \
    \ i2 = i2 + 1\n    elseif l1[i1] > l2[i2] then\n      break\n    else\n      l3[#l3\
    \ + 1] = l2[i2]\n      i2 = i2 + 1\n    end\n  until i1 >= #l1\n  return l3\n\
    end", "  if #l1 == 0 or #l2 == 0 then\n    return {}\n  elseif #l1 > #l2 then\n\
    \    local temp = l2\n    l2 = l1\n    l1 = temp\n  end\n  local l3 = {}\n  for\
    \ i = 1, #l1 do\n    local found = false\n    for j = 1, #l2 do\n      if l1[i]\
    \ == l2[j] then\n        found = true\n        break\n      end\n    end\n   \
    \ if not found then\n      table.insert(l3, l1[i])\n    end\n  end\n  return l3\n\
    end", "    local hash1 = {}\n    local i1, j1, len1 = unpack(l1)\n    local hash2\
    \ = {}\n    local i2, j2, len2 = unpack(l2)\n    for i = 1, len1 do\n        hash1[l1[i]]\
    \ = true\n    end\n    for i = 1, len2 do\n        hash2[l2[i]] = true\n    end\n\
    \    local common_elements = {}\n    for k = 1, #hash1 do\n        if hash2[k]\
    \ then\n            table.insert(common_elements, k)\n        end\n    end\n \
    \   return common_elements\nend", "   if #l1 ~= #l2 then return nil end\n   local\
    \ set = {}\n   for _, e in ipairs(l1) do\n      set[e] = true\n   end\n   return\
    \ setmetatable(set, common)\nend", "  if l1 == nil or l2 == nil then\n    return\
    \ nil\n  end\n  local i, v1, v2, n = 1, l1[1], l2[1], 0\n  while i <= n do\n \
    \   if v1 <= v2 then\n      v1, v2 = v2, v1\n    end\n    i = i + 1\n  end\n \
    \ return v1\nend", "    local i1, i2, i3 = {}, {}, {}\n    for i, v in ipairs(l1)\
    \ do\n        i1[v] = true\n    end\n    for i, v in ipairs(l2) do\n        i2[v]\
    \ = true\n    end\n    local set1, set2 = i1, i2\n    local i3, i4 = {}, {}\n\
    \    for i, v in pairs(set1) do\n        i3[v] = true\n    end\n    for i, v in\
    \ pairs(set2) do\n        i4[v] = true\n    end\n    return set1, set2, i3, i4\n\
    end", "  local t1 = {}\n  for i, v in ipairs(l1) do\n    t1[v] = true\n  end\n\
    \  local t2 = {}\n  for i, v in ipairs(l2) do\n    t2[v] = true\n  end\n  return\
    \ setmetatable(table.keys(t1), {})\nend", "  -- Find common length of both lists.\n\
    \  local len1 = #l1\n  local len2 = #l2", "  local hash = {}\n  for i=1,#l1 do\
    \ hash[l1[i]] = i end\n  for i=1,#l2 do hash[l2[i]] = i end\n  return table.sort(table.concat(l1,\
    \ '') .. table.concat(l2, ''), function(a, b) return hash[a] < hash[b] end)\n\
    end", "  local common = {}\n  local i1\n  local i2\n  local max\n  max = #l1 >\
    \ #l2 and #l1 or #l2\n  for i1 = 1, max do\n    local found = false\n    for i2\
    \ = 1, #l2 do\n      if l1[i1] == l2[i2] then\n        common[#common+1] = l1[i1]\n\
    \        found = true\n        break\n      end\n    end\n    if not found then\n\
    \      common[#common+1] = l2[i2]\n    end\n  end\n  return common\nend", "  \
    \  assert(#l1 ~= 0 and #l2 ~= 0, \"Lists must have equal length\")\n    local\
    \ sorted = {}\n    for i, x in ipairs(l1) do\n        table.insert(sorted, x)\n\
    \    end\n    for _, x in ipairs(l2) do\n        table.insert(sorted, x)\n   \
    \ end\n    return sorted\nend", "  if l1 == nil then return nil end\n  if l2 ==\
    \ nil then return l1 end\n  local i1, i2 = 1, #l1\n  local j1, j2 = 1, #l2\n \
    \ repeat\n    while i1 < i2 do\n      if l1[i1] == l2[j1] then\n        i1 = i1\
    \ + 1\n      else\n        j1 = j1 + 1\n      end\n    end\n    while j1 < j2\
    \ do\n      if l1[i1] == l2[j2] then\n        i2 = i2 - 1\n      else\n      \
    \  j2 = j2 - 1\n      end\n    end\n    if i2 == i1 then return l1, l2 end\n \
    \   if i1 < i2 then\n      i2, i1 = i1, i2\n      l2, l1 = l1, l2\n    end\n \
    \ until i1 == i2\nend", "    local i1, i2 = 1, #l1\n    local j1, j2 = 1, #l2\n\
    \    while i1 <= i2 do\n        local j\n        while j1 <= j2 do\n         \
    \   if l1[j1] == l2[j2] then\n                j1 = j1 + 1\n            else\n\
    \                j2 = j2 + 1\n            end\n        end\n        if j1 <= j2\
    \ then\n            table.insert(l1, l1[i1])\n            i1 = i1 + 1\n      \
    \  else\n            i2 = i2 + 1\n        end\n    end\n    return l1\nend", "\t\
    local a = {}\n\tlocal i = 1\n\tlocal j = 1\n\tfor k in pairs(l1) do\n\t\ta[k]\
    \ = true\n\tend\n\tfor k in pairs(l2) do\n\t\tif a[k] == true then\n\t\t\ti =\
    \ i + 1\n\t\telse\n\t\t\tj = j + 1\n\t\t\ta[k] = true\n\t\tend\n\tend\n\treturn\
    \ i ~= j\nend", "  local c1 = {}\n  local i = 1\n  for k in pairs(l1) do\n   \
    \ c1[k] = true\n    i = i + 1\n  end\n  local c2 = {}\n  local j = 1\n  for k\
    \ in pairs(l2) do\n    c2[k] = true\n    j = j + 1\n  end\n  for k in pairs(c1)\
    \ do\n    if not c2.has(k) then\n      return k\n    end\n  end\n  return nil\n\
    end", "  if #l1 == 0 then return l2 end\n  if #l2 == 0 then return l1 end\n  local\
    \ i, j, k, m = {}, {}, {}, {}\n  for i, v1 in ipairs(l1) do\n    if v2=l1[i] then\n\
    \      for j, v2 in ipairs(l2) do\n        if v1==v2 then k[#k+1] = v2\n     \
    \   elseif v1<v2 then k[#k+1] = v1\n        end\n      end\n    end\n  end\n \
    \ for i, v1 in ipairs(l1) do\n    if v2=l2[i] then\n      m[v1] = k[#k]\n    end\n\
    \  end\n  return m\nend", "  local tmp = {}\n  for k, v in pairs(l1) do\n    if\
    \ k in l2 then\n      table.insert(tmp, v)\n    end\n  end\n  return table.sort(tmp)\n\
    end", "  local result = {}\n  for _, v1 ipairs(l1) do\n    local found = false\n\
    \    for _, v2 ipairs(l2) do\n      if v1 == v2 then\n        found = true\n \
    \       break\n      end\n    end\n    if not found then\n      table.insert(result,\
    \ v1)\n    end\n  end\n  return table.sort(result)\nend", "  if l1 == nil or l2\
    \ == nil then\n    return nil\n  else\n    if l1 == l2 then\n      return l1\n\
    \    elseif #l1 == 0 then\n      return l2\n    elseif #l2 == 0 then\n      return\
    \ l1\n    end\n    local i\n    local j\n    local len1 = #l1\n    local len2\
    \ = #l2\n    local c1 = {}\n    local c2 = {}\n    for i = 1, len1 do\n      c1[#c1\
    \ + 1] = l1[i]\n    end\n    for j = 1, len2 do\n      c2[#c2 + 1] = l2[j]\n \
    \   end\n    table.sort(c1)\n    table.sort(c2)\n    for i = 1, #c1 do\n     \
    \ if c2[i] == c1[i] then\n        return c1[i]\n      end\n    end\n    return\
    \ nil\n  end\nend", "    local i1, i2, n = 0, #l1, #l2, 1\n    while i1 < n and\
    \ i2 < n do\n        if l1[i1] == l2[i2] then return l1[i1]\n        elseif l1[i1]\
    \ > l2[i2] then return nil end\n        i1, i2 = i1 + 1, i2 + 1\n    end\n   \
    \ return nil\nend", "    if #l1 == 0 then return l2 end\n    if #l2 == 0 then\
    \ return l1 end", "  if #l1 == 0 then return l2 end\n  if #l2 == 0 then return\
    \ l1 end\n  local i1, i2 = 1, #l1\n  local j1, j2 = 1, #l2\n  while i1 <= i2 do\n\
    \    j1, j2 = j2, j2 + 1\n    if l1[i1] == l2[j1] then i1, i2 = i2 + 1, #l1 end\n\
    \  end\n  return l1[j1]\nend", "  local a = {}\n  for _, v in pairs(l1) do\n \
    \   a[v] = true\n  end\n  for _, v in pairs(l2) do\n    if a[v] then return nil\
    \ end\n    a[v] = true\n  end\n  return table.concat(l1)\nend", "  local i1, i2\
    \ = 0, 0\n  local l1i = #l1\n  local l2i = #l2\n  local i, j, cur, cmp", "  local\
    \ ret = {}\n  for _, v1 in pairs(l1) do\n    for _, v2 in pairs(l2) do\n     \
    \ if v1 == v2 then\n        ret[#ret + 1] = v1\n      end\n    end\n  end\n  return\
    \ ret\nend", "    local i1, i2 = 1, #l1\n    local j1, j2 = 1, #l2\n    while\
    \ i1 <= i2 do\n        while j1 <= j2 do\n            if l1[i1] == l2[j1] then\n\
    \                j2 = j2 - 1\n            else\n                return l1[i1]\n\
    \            end\n        end\n        i1, i2 = i1 + 1, i2 + 1\n        j1, j2\
    \ = j1 + 1, j2 + 1\n    end\nend", "   local l3 = {}\n   for _,i in ipairs(l1)\
    \ do\n      l3[i] = true\n   end\n   for _,i in ipairs(l2) do\n      l3[i] = true\n\
    \   end\n   return table.sort(l3, true, function(t,t2)\n      return t < t2\n\
    \   end)\nend", "  local i = 1\n  local j = 1\n  local k = 1\n  while i <= #l1\
    \ and j <= #l2 do\n    if l1[i] == l2[j] then\n      k = k + 1\n      i = i +\
    \ 1\n      j = j + 1\n    elseif l1[i - 1] == l2[j - 1] then\n      k = k + 1\n\
    \      i = i + 1\n      j = j + 1\n    elseif l1[i - 1] < l2[j - 1] then\n   \
    \   k = k\n      i = i + 1\n    else\n      k = k\n      j = j + 1\n    end\n\
    \  end\n  if i <= #l1 then\n    k = k + 1\n  end\n  return l1:sub(1, k), l2:sub(1,\
    \ k)\nend", "  local table = {}\n  local i = 1", "  local i1\n  local i2", " \
    \ local i1, i2 = 1, #l1\n  while i2 > 0 do\n    if l1[i1] == l2[i2] then\n   \
    \   -- Append the second list element.\n      l1[#l1 + 1] = l2[i2]\n      -- Remove\
    \ first list element.\n      i1 = i1 + 1\n      -- Remove second list element.\n\
    \      i2 = i2 - 1\n    else\n      -- No match, go ahead and break out of the\
    \ loop.\n      break\n    end\n  end\n  return l1\nend", "  assert(type(l1) ==\
    \ 'table' and type(l2) == 'table', 'Input lists must be tables.')\n  local ret\
    \ = {}\n  local i, j, k\n  local l1 = #l1 or 0\n  local l2 = #l2 or 0\n  for i\
    \ = 1, l1 do\n    ret[i] = l1[i]\n  end\n  for j = 1, l2 do\n    ret[j] = l2[j]\n\
    \  end\n  for k = 1, #ret do\n    local ii = ret[k]\n    for i = 1, l1 do\n  \
    \    local jj = l1[i]\n      if j == ii then\n        l1[i] = nil\n        break\n\
    \      elseif jj ~= nil and jj == ii then\n        l1[i] = nil\n        break\n\
    \      end\n    end\n    local jj2 = l2[k]\n    for j = 1, l2 do\n      local\
    \ ii = ret[j]\n      if i == ii then\n        l2[k] = nil\n        break\n   \
    \   elseif ii~=nil and ii == jj then\n        l2[k] = nil\n        break\n   \
    \   end\n    end\n  end\n  return ret\nend", "  local c = {}\n  for i, v in ipairs(l1)\
    \ do\n    for j, vv in ipairs(l2) do\n      if v == vv then\n        table.insert(c,\
    \ v)\n      end\n    end\n  end\n  return c\nend", "  assert(#l1 <= #l2)\n  local\
    \ data = {}\n  local i = 1\n  for item in l1 do\n    if item ~= l2[i] then\n \
    \     data[#data + 1] = item\n    end\n    i = i + 1\n  end\n  return data\nend",
  "  local c1 = {}\n  local c2 = {}\n  for i, v in ipairs(l1) do\n    c1[v] = true\n\
    \  end\n  for i, v in ipairs(l2) do\n    c2[v] = true\n  end\n  return table.sort(c1,\
    \ function(a, b)\n    return #c2 > #c1 and #c2 > #a or #c2 < #c1 and #c2 < #a\
    \ end,\n      function(_, i2)\n        return #c2 < #c1 and #c2 < #c1 or #c2 <\
    \ #c1 and #c2 < #a end,\n          function(_, i1)\n            return c1[a] and\
    \ c1[a] == c2[b] and c2[b] == c1[b] end\n          end\n      end)\nend", "  \
    \  local hash = {}\n    for i=1, #l1, 1 do\n        hash[l1[i]] = true\n    end\n\
    \    for i=1, #l2, 1 do\n        if not hash[l2[i]] then\n            return l2\n\
    \        end\n    end\n    return nil\nend", "  local n1 = #l1\n  local n2 = #l2\n\
    \  local i, j, k", "    local hash = {}\n    for i = 1, #l1 do\n        local\
    \ v = l1[i]\n        hash[v] = v -- Add hash of each element to hash.\n    end\n\
    \    for i = 1, #l2 do\n        local v = l2[i]\n        if hash[v] ~= nil then\n\
    \            table.remove(hash, v)\n        end\n    end\n    local result\n \
    \   for k, v in pairs(hash) do\n        result = result or {}\n        result[k]\
    \ = v\n    end\n    return result or {}\nend", "   local common = {}\n   for _,\
    \ element in ipairs(l1) do\n      if #common == 0 then\n         common[element]\
    \ = true\n      else\n         local _, _, other_common = common[element] or common(),\
    \ element\n         common[other_common] = true\n      end\n   end\n   for _,\
    \ element in ipairs(l2) do\n      if #common == 0 then\n         common[element]\
    \ = true\n      else\n         local _, _, other_common = common[element] or common(),\
    \ element\n         common[other_common] = true\n      end\n   end\n   return\
    \ common\nend", "    if l1 == nil or l2 == nil then\n        return nil\n    end\n\
    \    local n1, n2 = #l1, #l2\n    if n1 == 0 or n2 == 0 then\n        return nil\n\
    \    end\n    local i = 0\n    local common = {}\n    while i < n1 do\n      \
    \  local v = l1[i]\n        if l2 == nil or v ~= l2[i] then\n            common[#common\
    \ + 1] = v\n        end\n        i = i + 1\n    end\n    return common\nend",
  "  local t = {}\n  for _, v1 in pairs(l1) do\n    if next(l2, v1) == nil then\n\
    \      t[v1] = true\n    else\n      for _, v2 in pairs(l2) do\n        if v1\
    \ == v2 and t[v1] == false then\n          t[v1] = true\n        end\n      end\n\
    \    end\n  end\n  return t\nend", "  local l1 = l1 or {}\n  local l2 = l2 or\
    \ {}\n  local common = {}\n  local i1, i2, j1, j2\n  local n = #l1\n  local m\
    \ = #l2\n  for i=1, n do\n    for j=1, m do\n      if l1[i] == l2[j] then\n  \
    \      common[#common+1] = l1[i]\n      end\n    end\n  end\n  table.sort(common)\n\
    \  return common\nend", "    local t = {l1, l2}\n    table.sort(t)\n    local\
    \ i1, i2 = 1, #l1 + 1\n    while i1 <= i2 do\n        local e1 = t[i1]\n     \
    \   if i1 > i2 then\n            local e2 = t[i2]\n            table.insert(l1,\
    \ e1)\n            table.insert(l2, e2)\n        elseif t[i1] == t[i2] then\n\
    \            table.insert(l1, e1)\n        end\n        i1 = i1 + 1\n    end\n\
    \    return table.concat(l1)\nend\nreturn common\nend", "  local set = {}\n  for\
    \ _, v in pairs(l1) do set[v] = true end\n  for _, v in pairs(l2) do set[v] =\
    \ true end\n  return set\nend", "  local c1 = {}\n  local c2 = {}\n  for i, v\
    \ in ipairs(l1) do\n    c1[v] = true\n  end\n  for i, v in ipairs(l2) do\n   \
    \ c2[v] = true\n  end\n  local i\n  for i, v in ipairs(c1) do\n    if not c2[v]\
    \ then break end\n  end\n  return i, v\nend", "  local l3 = {}\n  for _, v in\
    \ ipairs(l1) do l3[v] = true end\n  for _, v in ipairs(l2) do l3[v] = true end\n\
    \  return l3\nend", "  local common_elements = {}\n  local i1, i2, i3 = 1, 0,\
    \ 1\n  while i1 < #l1 and i2 < #l2 do\n    if l1[i1] == l2[i2] then\n      common_elements[#common_elements\
    \ + 1] = l1[i1]\n      i1, i2, i3 = i1 + 1, i2 + 1, i3 + 1\n    elseif l1[i1]\
    \ < l2[i2] then\n      i2, i3 = i2 + 1, i3 + 1\n    else\n      i1, i3 = i1 +\
    \ 1, i3 + 1\n    end\n  end\n  return common_elements\nend", "  local i1, i2,\
    \ j1, j2\n  local len1, len2, m, m1, m2\n  len1 = #l1\n  len2 = #l2\n  if len1\
    \ ~= len2 then\n    return nil\n  end\n  i1 = 1\n  i2 = 1\n  j1 = 1\n  j2 = 1\n\
    \  m1 = len1\n  m2 = len2\n  m = 0\n  while m1 < m2 do\n    if l1[m1] ~= l2[j1]\
    \ then\n      m = m + 1\n      if l1[m] < l2[j1] then\n        j = j1\n      \
    \  j1 = m\n      else\n        i = i1\n        i1 = m\n      end\n    end\n  \
    \  m1 = m1 + 1\n  end\n  if m1 > m2 then\n    while m1 < m2 do\n      m = m +\
    \ 1\n      i1 = i1 + 1\n      if l1[m] < l2[j1] then\n        j = j1\n       \
    \ j1 = m\n      end\n      m1 = m1 + 1\n    end\n  end\n  if m2 < len2 then\n\
    \    while m2 < len2 do\n      m = m + 1\n      i2 = i2 + 1\n      if l1[m] <\
    \ l2[j2] then\n        j = j2\n        j2 = m\n      end\n      m2 = m2 + 1\n\
    \    end\n  end\n  if i1 < len1 and j1 < len2 then\n    local i2, j2 = i2 + 1,\
    \ j2 + 1\n    if l1[m] < l2[j2] then\n      while i2 < len1 and j2 < len2 do\n\
    \        local t\n        if l1[m2] ~= l2[j2] then\n          t = l2[j2]\n   \
    \       l2[j2] = l1[m2]\n          l1[m2] = t\n        end\n        i2 = i2 +\
    \ 1\n        j2 = j2 + 1\n      end\n    end\n    common(l1, l2, i1, i2, j1, j2,\
    \ m)\n  end\n  if m1 < len1 and i1 < len2 then\n    local i2 = i1 + 1\n    if\
    \ l1[m] < l2[j1] then\n      while i2 < len1 do\n        local t\n        if l1[m2]\
    \ ~= l2[j1] then\n          t = l2[j1]\n          l2[j1] = t\n          l1[m2]\
    \ = l1[m2]\n        end\n        i2 = i2 + 1\n      end\n    end\n    common(l1,\
    \ l2, i1, i2, j1, len2, m)\n  end\n  return l1, l2, m, i1, i2, j1, j2\n", "  if\
    \ #l1 ~= #l2 then\n    return nil\n  end\n  local tbl = {}\n  for _, x in ipairs(l1)\
    \ do\n    for _, y in ipairs(l2) do\n      if x == y then\n        table.insert(tbl,\
    \ x)\n      end\n    end\n  end\n  return tbl\nend", "    local list1 = {}\n \
    \   local list2 = {}\n    for _, v in ipairs(l1) do\n        list1[#list1 + 1]\
    \ = v\n    end\n    for _, v in ipairs(l2) do\n        list2[#list2 + 1] = v\n\
    \    end\n    list1 = list1[#list1]\n    list2 = list2[#list2]\n    return setmetatable(list1,\
    \ {__index = function(t, i)\n        local v1 = list1[i]\n        local v2 = list2[i]\n\
    \        for j, k in ipairs(list1) do\n            if j == i then return k\n \
    \           elseif k == i then return j\n            elseif v1 <= k then\n   \
    \             list1[j] = list1[k]\n                list1[k] = v1\n           \
    \ elseif v2 <= k then\n                list2[j] = list2[k]\n                list2[k]\
    \ = v2\n            end\n        end\n    end})\nend", "  if l1 == nil or l2 ==\
    \ nil then\n    return nil\n  elseif #l1 == 0 or #l2 == 0 then\n    return nil\n\
    \  end\n  local set = {}\n  for i = 1, #l1 do\n    set[tostring(l1[i])] = true\n\
    \  end\n  for i = 1, #l2 do\n    set[tostring(l2[i])] = true\n  end\n  return\
    \ set\nend", "  local t1 = {}\n  local t2 = {}\n  for _, x in ipairs(l1) do\n\
    \    if t1[#t1] == x then\n      t1[#t1] = nil\n    else\n      t1[#t1] = x\n\
    \    end\n  end\n  for _, x in ipairs(l2) do\n    if t2[#t2] == x then\n     \
    \ t2[#t2] = nil\n    else\n      t2[#t2] = x\n    end\n  end\n  for k, x in pairs(t1)\
    \ do\n    if t2[#t2] ~= nil then\n      return x\n    end\n  end\n  return nil\n\
    end", "\tlocal common_elems = {}\n\tfor i=1,#l1 do\n\t\tcommon_elems[i] = l1[i]\n\
    \tend\n\tfor i=1,#l2 do\n\t\tcommon_elems[#common_elems + 1] = l2[i]\n\tend\n\t\
    common_elems[#common_elems + 1] = \"END\"\n\treturn table.unpack(table.sort(common_elems))\n\
    end", "  local rs = {}\n  for i = 1, #l1 do\n    for j = 1, #l2 do\n      if l1[i]\
    \ == l2[j] then\n        table.insert(rs, l1[i])\n      end\n    end\n  end\n\
    \  return table.sort(rs)\nend", "    if l1 == nil or l2 == nil then return nil\
    \ end\n    local i1, i2 = 1, #l1\n    local j1, j2 = 1, #l2\n    while i1 <= i2\
    \ do\n        if l1[i1] == l2[j1] then\n            local tmp1\n            if\
    \ i1 == i2 then\n                tmp1, i2 = i1 + 1, 1\n                j1, j2\
    \ = j1 + 1, 1\n            else\n                tmp1, i2 = i2, i1 + 1\n     \
    \       end\n            if j1 == j2 then\n                tmp2, j2 = j1 + 1,\
    \ 1\n            else\n                tmp2, j2 = j2, j1 + 1\n            end\n\
    \            while tmp1 <= tmp2 do\n                if l1[i1] == l2[j1] then\n\
    \                    if i1 == i2 then\n                        tmp1, i2 = i1 +\
    \ 1, 1\n                        j1, j2 = j1 + 1, 1\n                    else\n\
    \                        tmp1, i2 = i2, i1 + 1\n                    end\n    \
    \                if j1 == j2 then\n                        tmp2, j2 = j1 + 1,\
    \ 1\n                    else\n                        tmp2, j2 = j2, j1 + 1\n\
    \                    end\n                end\n            end\n            if\
    \ tmp1 < tmp2 then\n                table.remove(l1, tmp1)\n                table.remove(l2,\
    \ tmp2)\n                tmp1, i1, j1, i2, j2 = nil, 1, 0, 0, 1\n            elseif\
    \ tmp1 > tmp2 then\n                table.remove(l2, tmp2)\n                table.remove(l1,\
    \ tmp1)\n                tmp1, i1, j1, i2, j2 = nil, 1, 1, 0, 1\n            else\n\
    \                table.remove(l1, tmp1)\n                table.remove(l2, tmp2)\n\
    \                table.remove(l1, i1)\n                table.remove(l2, j1)\n\
    \                table.remove(l2, i2)\n                table.remove(l1, j2)\n\
    \                i1, i2, j1, j2 = 1, #l1, #l2, 1\n            end\n        end\n\
    \        i1, j1 = i1 + 1, j1 + 1\n    end\nend", "  local n1, n2 = #l1, #l2\n\
    \  if n1 == 0 then return l2 end\n  if n2 == 0 then return l1 end\n  if n1 > n2\
    \ then\n    local tmp = l2\n    l2 = l1\n    l1 = tmp\n    n1, n2 = n2, n1\n \
    \ end\n  local i1 = 1\n  local j1 = 1\n  local i2 = 1\n  local j2 = 1\n  local\
    \ i1last = n1 -- Last position of element i1 in the original list l1.\n  local\
    \ j1last = n2 -- Last position of element j1 in the original list l1.\n  local\
    \ ilast = n1 -- Last position of element i2 in the original list l2.\n  local\
    \ jlast = n2 -- Last position of element j2 in the original list l2.\n  local\
    \ common, ctr = {}, 0\n  for i2 = 1, n2 do\n    common[ctr] = l2[j2]\n    ctr\
    \ = ctr + 1\n    i2 = i2 + 1\n    if i2 == n2 then\n      break\n    end\n  end\n\
    \  for j2 = 1, n1 do\n    common[ctr] = l1[i1]\n    ctr = ctr + 1\n    j2 = j2\
    \ + 1\n    if j2 == n1 then\n      break\n    end\n  end\n  while i1 <= ilast\
    \ do\n    i1last = i1\n    for j2 = 1, n1 do\n      if common[ctr] == l1[i1] then\n\
    \        i1 = i1 + 1\n        break\n      elseif common[ctr] == l2[j2] then\n\
    \        j1 = j1 + 1\n        break\n      else\n        ctr = ctr + 1\n     \
    \ end\n    end\n  end\n  while j1 <= jlast do\n    j1last = j1\n    for i2 = 1,\
    \ n2 do\n      if common[ctr] == l2[j2] then\n        j1 = j1 + 1\n        break\n\
    \      elseif common[ctr] == l1[i2] then\n        i2 = i2 + 1\n        break\n\
    \      else\n        ctr = ctr + 1\n      end\n    end\n  end\n  return common\n\
    end\n</code>\nI hope that helps.\n<|/ a dscore=2 tags=math,permutation,sorting,lua,arrays\
    \ |>\n<| c |>\nThanks, this was helpful\n<|/ c |>\n<| c |>\n: This doesn't do\
    \ what you need. If you look closely at `l1 = common(array1,array2)`, you'll see\
    \ that you're trying to permute `array1` into `array2`, but `common` returns all\
    \ possible permutations of the elements of ", "  if #l1 == 0 then\n    return\
    \ l2\n  elseif #l2 == 0 then\n    return l1\n  end\n  local n = #l1\n  local m,\
    \ i = {}, 1\n  while i <= n do\n    local found = false\n    for j = 1, n do\n\
    \      if l1[i] == l2[j] then\n        if not found[j] then\n          m:insert(l2[j])\n\
    \          found[j] = true\n        end\n        break\n      end\n    end\n \
    \   if not found then\n      m:insert(l1[i])\n    end\n    i = i + n\n  end\n\
    \  return m\nend", "    local l = {}\n    for i, v in ipairs(l1) do\n        l[v]\
    \ = true\n    end\n    for i, v in ipairs(l2) do\n        if not l[v] then\n \
    \           return i\n        end\n    end\n    return nil\nend", "    local common\
    \ = {}\n    for _, elem in ipairs(l1) do\n        common[elem] = true\n    end\n\
    \    for _, elem in ipairs(l2) do\n        if not common[elem] then\n        \
    \    common[elem] = true\n        end\n    end\n    return pairs(common)\nend",
  "  if l1 == nil or l2 == nil then return end\n  if #l1 == 0 or #l2 == 0 then return\
    \ end\n  if #l1 < #l2 then return end", "  local hash1 = #l1\n  local hash2 =\
    \ #l2\n  if hash1 == 0 then return l2 end\n  if hash2 == 0 then return l1 end\n\
    \  local hash1vals = setmetatable({}, { __index = {} })\n  local hash2vals = setmetatable({},\
    \ { __index = {} })\n  for i = 1, hash1 do\n    hash1vals[i] = l1[i - 1]\n  end\n\
    \  for i = 1, hash2 do\n    hash2vals[i] = l2[i - 1]\n  end\n  local commonvals\
    \ = hash1vals\n  for k, v in pairs(hash2vals) do\n    commonvals[k] = v\n  end\n\
    \  local commonvalskeys = {}\n  for k in pairs(commonvals) do\n    commonvalskeys[k]\
    \ = true\n  end\n  for i = 1, hash1 do\n    if commonvalskeys[l1[i - 1]] then\n\
    \      commonvals[l1[i - 1]] = nil\n      commonvals[commonvals[l1[i - 1]]] =\
    \ l1[i - 1]\n    end\n  end\n  for i = 1, hash2 do\n    if commonvalskeys[l2[i\
    \ - 1]] then\n      commonvals[l2[i - 1]] = nil\n      commonvals[commonvals[l2[i\
    \ - 1]]] = l2[i - 1]\n    end\n  end\n  for k, v in pairs(commonvals) do\n   \
    \ if v then\n      return v\n    end\n  end\nend", "    if #l1 ~= #l2 then\n \
    \       return nil\n    end\n    local common = {}\n    for i=1,#l1 do\n     \
    \   local found = false\n        for j=1,#l2 do\n            if l1[i] == l2[j]\
    \ then\n                table.insert(common, l1[i])\n                found = true\n\
    \                break\n            end\n        end\n        if not found then\n\
    \            table.insert(common, l1[i])\n        end\n    end\n    return common\n\
    end", "    local result = {}\n    for _, v1 in pairs(l1) do\n        local found\
    \ = false\n        for _, v2 in pairs(l2) do\n            if v1 == v2 and found\
    \ == false then\n                table.insert(result, v1)\n                found\
    \ = true\n            end\n        end\n        if not found then\n          \
    \  table.insert(result, v1)\n        end\n    end\n    return result\nend", " \
    \ -- We use two hash tables to optimize performance.\n  local hash1 = {}\n  local\
    \ hash2 = {}", "  local table = {}\n  for k, v in pairs(l1) do\n    table.insert(table,\
    \ {k, v})\n  end\n  for k, v in pairs(l2) do\n    table.insert(table, {k, v})\n\
    \  end\n  table.sort(function(x, y) return x.value < y.value end)\n  return table.unpack(table.unpack(table.concat(table)))\n\
    end", "  local i\n  local i1, i2, j1, j2 = {}, {}, {}, {}\n  for i, v in ipairs(l1)\
    \ do\n    i1[v] = true\n  end\n  for i, v in ipairs(l2) do\n    i2[v] = true\n\
    \  end\n  for i, v in ipairs(i1) do\n    for j, v2 in ipairs(i2) do\n      if\
    \ not i[v2] and not i[v2] then\n        j1[v2] = true\n      end\n    end\n  end\n\
    \  for i, v in ipairs(j1) do\n    j2[v] = true\n  end\n  return j2\nend", "  \
    \ local hash = {}\n   for _, v in ipairs(l1) do\n      hash[v] = true\n   end\n\
    \   for _, v in ipairs(l2) do\n      if not hash[v] then\n         return nil\n\
    \      end\n   end\n   return l1, l2\nend\n</cell>\n<cell>", "  local num_common_elems\
    \ = 0\n  for i=1, #l1 do\n    local i2 = 1\n    while i2 < #l2 and l1[i] == l2[i2]\
    \ do\n      i2 = i2 + 1\n    end\n    if i2 == #l2 then num_common_elems = num_common_elems\
    \ + 1 end\n  end\n  return num_common_elems\nend", "    local len1 = #l1\n   \
    \ local len2 = #l2\n    local i, j, k\n    if len1 == 0 or len2 == 0 then\n  \
    \      return nil\n    end\n    local t = {}\n    for i = 1, len1 do\n       \
    \ t[i] = l1[i]\n    end\n    for j = 1, len2 do\n        t[j] = l2[j]\n    end\n\
    \    for i = 1, len2 do\n        for j = 1, len1 do\n            if t[i] == t[j]\
    \ then\n                k = k + 1\n                if k > 1 then\n           \
    \         t[k] = nil\n                end\n            end\n        end\n    end\n\
    \    return t\nend", "  assert(#l1 <= #l2)\n  local common = {}\n  local i = 1\n\
    \  while i <= #l1 do\n    common[i] = l1[i]\n    i = i + 1\n  end\n  for i=1,\
    \ #l2 do\n    assert(common[i] == l2[i])\n  end\n  return common\nend", "  local\
    \ l\n  local i1\n  local i2\n  local e\n  local n\n  local len", "  if #l1 ==\
    \ 0 or #l2 == 0 then return end\n  local t = {}\n  for i=1, #l1 do\n    t[l2[i]]\
    \ = true\n  end\n  for i=1, #l2 do\n    if not t[l2[i]] then return end\n  end\n\
    \  return t1\nend", "  local common = {}\n  for i = 1, #l1 do\n    for j = 1,\
    \ #l2 do\n      if l1[i] == l2[j] then\n        table.insert(common, l1[i])\n\
    \        break\n      end\n    end\n  end\n  return common\nend", "  local i1\
    \ = 0\n  local i2 = 0\n  local size1 = #l1\n  local size2 = #l2", "  local hash\
    \ = {}\n  local i = 1\n  while #l1 ~= 0 and #l2 ~= 0 do\n    if l1[#l1] ~= l2[#l2]\
    \ then\n      table.insert(hash, l1[#l1])\n      table.insert(hash, l2[#l2])\n\
    \    end\n    i = i + 1\n    if i == #l1 then\n      break\n    end\n  end\n \
    \ return hash\nend\nreturn common", "  local i = 1\n  local j = 1\n  local isize\
    \ = #l1\n  local jsize = #l2\n  local common = {}\n  local e1, e2\n  while i <\
    \ isize and j < jsize do\n    e1 = l1[i]\n    e2 = l2[j]\n    if e1 == e2 then\n\
    \      common[e1] = common[e1] + 1\n      i = i + 1\n      j = j + 1\n    else\n\
    \      if common[e1] > common[e2] then\n        common[e2] = common[e2] + 1\n\
    \      else\n        common[e1] = common[e1] + 1\n      end\n    end\n  end\n\
    \  if i == isize then\n    return l2\n  elseif j == jsize then\n    return l1\n\
    \  else\n    common[e1] = common[e1] + 1\n    return common\n  end\nend", "\t\
    local c1 = {}\n\tlocal c2 = {}\n\tfor i, v in pairs(l1) do\n\t\tc1[v] = i\n\t\
    end\n\tfor i, v in pairs(l2) do\n\t\tc2[v] = i\n\tend\n\tlocal common = {}\n\t\
    local common_i = 0\n\tfor k, v in pairs(c1) do\n\t\tif k ~= c2[v] then\n\t\t\t\
    common[common_i..\"_\"..k] = v\n\t\t\tcommon_i = common_i + 1\n\t\tend\n\tend\n\
    \treturn common\nend", "    local i1 = 1\n    local i2 = 1\n    local len1 = #l1\n\
    \    local len2 = #l2\n    local i, j, k, kl, el\n    local list = {}\n    for\
    \ i = 1, len1 do\n        el = l1[i]\n        for j = 1, len2 do\n           \
    \ if (l2[el] == l2[j]) then\n                table.insert(list, el)\n        \
    \        break\n            elseif (l2[j] < el) then\n                k = len1\n\
    \                for kl = i2, len2 do\n                    if (l2[kl] == el) then\n\
    \                        k = kl\n                        break\n             \
    \       end\n                end\n                if (k > i) then\n          \
    \          table.insert(list, el)\n                    i = k\n               \
    \ elseif (k == i) then\n                    table.insert(list, l2[j])\n      \
    \          end\n                break\n            elseif (el < l2[j]) then\n\
    \                k = len2\n                for kl = i1, len1 do\n            \
    \        if (l1[kl] == el) then\n                        k = kl\n            \
    \            break\n                    end\n                end\n           \
    \     if (k > i) then\n                    table.insert(list, el)\n          \
    \          i = k\n                elseif (k == i) then\n                    table.insert(list,\
    \ l1[j])\n                end\n                break\n            end\n      \
    \  end\n    end\n    return list\nend", "  local r1 = {}\n  local r2 = {}\n  for\
    \ i=1, #l1 do\n    if r1[l1[i]] ~= nil then\n      r2[l1[i]] = true\n    else\n\
    \      r1[l1[i]] = true\n    end\n  end\n  for i=1, #l2 do\n    if r2[l2[i]] ~=\
    \ nil then\n      r1[l2[i]] = true\n    else\n      r2[l2[i]] = true\n    end\n\
    \  end\n  return setmetatable({}, {__mode = \"v\"})\nend", "  if #l1 ~= #l2 then\n\
    \    return nil\n  end\n  local i1\n  local i2\n  local c1 = {}\n  local c2 =\
    \ {}\n  for i1 = 1, #l1 do\n    local v1 = l1[i1]\n    if c2[v1] then -- duplicate\
    \ in list1\n      return nil\n    end\n    c1[v1] = true\n  end\n  for i2 = 1,\
    \ #l2 do\n    local v2 = l2[i2]\n    if not c1[v2] then -- duplicate in list2\n\
    \      return nil\n    end\n    c2[v2] = true\n  end\n  local ret = {}\n  for\
    \ i1 = 1, #l1 do\n    local v1 = l1[i1]\n    if not c2[v1] then -- unique in list1\n\
    \      table.insert(ret, v1)\n    end\n  end\n  return ret\nend", "  if #l1 ==\
    \ 0 then return l2 end\n  if #l2 == 0 then return l1 end\n  if l1[#l1] == l2[#l2]\
    \ then return l1 end\n  local i1 = 1\n  local i2 = 0\n  local result = {}\n  local\
    \ len = #l1 + 1\n  while i1 <= len and i2 <= len do\n    if l1[i1] == l2[i2] then\n\
    \      table.insert(result, l1[i1])\n      i1 = i1 + 1\n      i2 = i2 + 1\n  \
    \  else\n      if i1 > i2 then\n        i2 = i2 + 1\n      else\n        i1 =\
    \ i1 + 1\n      end\n    end\n  end\n  if i1 > i2 then\n    while i1 < len do\n\
    \      table.insert(result, l1[i1])\n      i1 = i1 + 1\n    end\n  else\n    while\
    \ i2 < len do\n      table.insert(result, l2[i2])\n      i2 = i2 + 1\n    end\n\
    \  end\n  return result\nend", "  if #l1 == 0 then\n    return l2\n  end\n  if\
    \ #l2 == 0 then\n    return l1\n  end\n  local i = 1\n  local j = 1\n  local c\
    \ = 1\n  local len = #l1\n  local l3 = {}\n  while i <= len do\n    local k =\
    \ l2[j]\n    if l3[k] == nil then\n      l3[k] = l1[i]\n    else\n      c = c\
    \ * l3[k] % l1[i]\n    end\n    i = i + 1\n    j = j + 1\n  end\n  return l3\n\
    end", "\tlocal hash = {}\n\tfor i, v in ipairs(l1) do\n\t\thash[v] = i -- Store\
    \ indexes to avoid duplicates\n\tend\n\tfor i, v in ipairs(l2) do\n\t\tif not\
    \ hash[v] then\n\t\t\ttable.insert(l1, v)\n\t\tend\n\tend\n\treturn l1\nend",
  "  local sorted = table.sort(l1)\n  local i = 1\n  local j = 1\n  local common =\
    \ {}\n  repeat\n    common[i - 1] = sorted[j]\n    i = i + 1\n    j = j + 1\n\
    \  until not (i == #l1 or j == #l2)\n  table.sort(l2)\n  j = 1\n  repeat\n   \
    \ common[#common + 1] = l2[j]\n    j = j + 1\n  until not (j == #l2)\n  return\
    \ common\nend", "  local i1, i2, j1, j2\n  local len1, len2\n  len1 = #l1\n  len2\
    \ = #l2\n  local max = 0\n  local min = 0\n  local a1, a2, b1, b2, r\n  a1 = {}\n\
    \  a2 = {}\n  b1 = {}\n  b2 = {}\n  i1 = 0\n  i2 = 0\n  while i1 < len1 and i2\
    \ < len2 do\n    local l1 = l1[i1]\n    local l2 = l2[i2]\n    a1[l1] = l1 --\
    \ a to store common elements.\n    a2[l2] = l2 -- a to store common elements.\n\
    \    b1[l2] = l1 -- b to store uncommon elements.\n    b2[l1] = l2 -- b to store\
    \ uncommon elements.\n    i1 = i1 + 1\n    i2 = i2 + 1\n  end\n  i = i1\n  while\
    \ i < len1 do\n    r = a1[i] -- r to store uncommon elements.\n    j = i2\n  \
    \  while j < len2 do\n      if b1[l2[j]] then -- check whether b2[l1] is uncommon.\n\
    \        b2[l2[j]]\n        j = j + 1\n      else\n        a1[i] = r -- if uncommon,\
    \ a1 becomes common\n        j = j + 1\n      end\n    end\n    i = i + 1\n  end\n\
    \  i = i2\n  while i < len2 do\n    r = a2[i]\n    j = i1\n    while j < len1\
    \ do\n      if b2[l1[j]] then\n        b1[l1[j]]\n        j = j + 1\n      else\n\
    \        a2[i] = r\n        j = j + 1\n      end\n    end\n    i = i + 1\n  end\n\
    \  local t1 = {}\n  local t2 = {}\n  i1 = 0\n  i2 = 0\n  while i1 < len1 do\n\
    \    local e1 = a1[i1]\n    local e2 = a2[i2]\n    t1[e1] = e1 -- store common\
    \ elements.\n    t2[e2] = e2 -- store common elements.\n    i1 = i1 + 1\n    i2\
    \ = i2 + 1\n  end\n  i1 = 0\n  i2 = 0\n  while i2 < len2 do\n    local e1 = a2[len1\
    \ - 1 - i2]\n    local e2 = b2[len1 - 1 - i2]\n    t1[e1] = e1 -- store uncommon\
    \ elements.\n    t2[e2] = e2 -- store uncommon elements.\n    i2 = i2 + 1\n  end\n\
    \  local j1, j2\n  local commonSize = 0\n  j1 = 1\n  j2 = 1\n", "    assert(type(l1)\
    \ is \"table\" and type(l2) is \"table\")\n    local t1 = {}\n    local t2 = {}\n\
    \    for k,v in pairs(l1) do\n        if table.remove(t1, v) then t2[v] = true\
    \ end\n    end\n    for k,v in pairs(l2) do\n        if not table.remove(t2, v)\
    \ then t1[v] = true end\n    end\n    return table.values(t1)\nend", "  local\
    \ m1, n1 = #l1, #l1\n  local m2, n2 = #l2, #l2\n  local i, j, k\n  local l = {}\n\
    \  for i=1, n1 do\n    local tmp = {}\n    for j=1, n2 do\n      if l1[i] == l2[j]\
    \ then\n        if tmp[l2[j]] then table.insert(l, l2[j]) end\n        tmp[l2[j]]\
    \ = 1\n      end\n    end\n    for j=1, n2 do tmp[l2[j]] = 1 end\n    for j=1,\
    \ m2 do table.insert(l, l2[j]) end\n  end\n  for i=1, m1 do table.insert(l, l1[i])\
    \ end\n  return l\nend", "  local set1 = setmetatable({}, {__index = function()\
    \ return l1 end})\n  local set2 = setmetatable({}, {__index = function() return\
    \ l2 end})\n  for _, value in ipairs(set1) do\n    if set2[value] then return\
    \ end\n    set2[value] = true\n  end\n  return set2.keys()\nend", "  local hash1\
    \ = torch.hash(l1)\n  local hash2 = torch.hash(l2)", "  if #l1 == 0 then\n   \
    \ return l2\n  end\n  if #l2 == 0 then\n    return l1\n  end", "  local common\
    \ = {}\n  for _, v1 in ipairs(l1) do\n    for _, v2 in ipairs(l2) do\n      common[v1]\
    \ = v1 or v2\n    end\n  end\n  return common\nend", "  local common = {}\n  for\
    \ _, v in ipairs(l1) do\n    common[v] = true\n  end\n  for _, v in ipairs(l2)\
    \ do\n    if not common[v] then\n      common[v] = true\n    end\n  end\n  return\
    \ pairs(common)\nend", "    local result = {}\n    for _, v in ipairs(l1) do\n\
    \        for _, v2 in ipairs(l2) do\n            if v == v2 then\n           \
    \     table.insert(result, v)\n            end\n        end\n    end\n    return\
    \ table.sort(result)\nend", "  local i1, i2, i3, i4, j1, j2 = {}, {}, {}, {},\
    \ {}, {}\n  for i1, l1 in ipairs(l1) do\n    for j1, l2 in ipairs(l2) do\n   \
    \   i2[i1][j1] = i2[i1][j1] or (j1 <= j2 and l1[l1] == l2[j1])\n    end\n  end\n\
    \  for i1 in ipairs(i2) do\n    for j1, l2 in ipairs(i2) do\n      i2[i1][j1]\
    \ = i2[i1][j1] and i1[i1][j1]\n    end\n  end\n  return i2\nend", "  local tbl\
    \ = {}\n  local inboth = false\n  for _, v in ipairs(l1) do\n    if not inboth\
    \ then\n      inboth = true\n      tbl[v] = true\n    end\n    if not tbl[v] then\n\
    \      inboth = false\n      tbl[v] = true\n    end\n  end\n  local _, res\n \
    \ for _, v in ipairs(l2) do\n    if not tbl[v] then\n      res = v\n      break\n\
    \    end\n  end\n  return res\nend", "  local hash = {}\n  for _, v in ipairs(l1)\
    \ do hash[v] = true end\n  for _, v in ipairs(l2) do hash[v] = true end\n  return\
    \ table.concat(\n    table.sort(\n      pairs(\n        filter(\n          function(x)\
    \ return hash[x] ~= nil end,\n          hash\n        )\n      )\n    )\n  )\n\
    end", "   if #l1 ~= #l2 then return nil end\n   local tbl = {}\n   for i, v in\
    \ ipairs(l1) do\n      tbl[v] = true\n   end\n   for _, v in ipairs(l2) do\n \
    \     if not tbl[v] then\n         return nil\n      end\n   end\n   return l1\n\
    end", "    local tbl = setmetatable({}, {__mode = \"kv\"})\n    local _, v, i\
    \ = 1, #l1\n    while i <= #l2 do\n        local _, v2, i = i, #l2, i + 1\n  \
    \      if l2[i] and l2[i] ~= \"\" then tbl[v] = l2[i] end\n        while i <=\
    \ #l2 do\n            local _, v2, i = i, #l2, i + 1\n            if l2[i] and\
    \ l2[i] ~= \"\" then tbl[v] = l2[i] end\n        end\n    end\n    local j = 1\n\
    \    while j <= #l1 do\n        if tbl[l1[j]] then tbl[#tbl + 1] = tbl[l1[j]]\
    \ end\n        j = j + 1\n    end\n    return tbl\nend", "    local r1, r2 = {},\
    \ {}\n    for k, v in pairs(l1) do\n        r1[k] = v\n    end\n    for k, v in\
    \ pairs(l2) do\n        r2[k] = v\n    end\n    local k\n    local n = #r1\n \
    \   local m = #r2\n    local ret = {}\n    for k = 1, n do ret[#ret + 1] = k end\n\
    \    for k = 1, m do\n        if r1[k] ~= r2[k] then\n            for k = 1, n\
    \ do\n                if r1[k] == r2[k] then\n                    ret[#ret + 1]\
    \ = k\n                    n = n - 1\n                    break\n            \
    \    end\n            end\n        end\n    end\n    return ret\nend", "  local\
    \ v = {}\n  for _, x in ipairs(l1) do\n    if v[x] ~= nil then\n      v[x] = v[x]\
    \ + 1\n      if v[x] == 2 then return x end\n    else\n      v[x] = 1\n    end\n\
    \  end\n  for _, x in ipairs(l2) do\n    if v[x] ~= nil then\n      v[x] = v[x]\
    \ + 1\n      if v[x] == 2 then return x end\n    end\n  end\nend", "  if #l1 ==\
    \ 0 or #l2 == 0 then\n    return nil\n  end\n  local common = {}\n  local i1 =\
    \ 0\n  local i2 = 0\n  while i1 < #l1 and i2 < #l2 do\n    if l1[i1] == l2[i2]\
    \ then\n      table.insert(common, l1[i1])\n      i1 = i1 + 1\n      i2 = i2 +\
    \ 1\n    elseif l1[i1] > l2[i2] then\n      i1 = i1 + 1\n    else\n      i2 =\
    \ i2 + 1\n    end\n  end\n  return common\nend", "  local i1, i2, j1, j2 = {},\
    \ {}, {}, {}\n  for i = 1, #l1 do\n    i1[i] = l1[i]\n  end\n  for i = 1, #l2\
    \ do\n    i2[i] = l2[i]\n  end\n  for i = 1, #i1 do\n    for j = 1, #i2 do\n \
    \     j1[j] = i1[i]\n      j2[j] = i2[i]\n    end\n  end\n  for i = 1, #i1 do\n\
    \    if not i1[i] then\n      i1[i] = j1[i]\n    end\n    if not i2[i] then\n\
    \      i2[i] = j2[i]\n    end\n  end\n  return i1, i2\nend", "\tlocal set = {}\n\
    \tfor _, v in ipairs(l1) do set[v] = true end\n\tfor _, v in ipairs(l2) do set[v]\
    \ = true end\n\treturn set\nend", "  if #l1 == 0 then return l2 end\n  if #l2\
    \ == 0 then return l1 end\n  local common = {}\n  for idx = 1, #l1 do\n    for\
    \ other_idx = 1, #l2 do\n      if l1[other_idx] == l2[other_idx] then\n      \
    \  table.insert(common, l1[other_idx])\n      end\n    end\n  end\n  return common\n\
    end", "    if #l1 ~= #l2 then\n        return 0\n    end", "  -- Base case.\n\
    \  if #l1 ~= #l2 then return nil end\n  -- Union case: Lists have the same length\
    \ and they are\n  -- mutually exclusive.\n  if #l1 == 1 then return l1 end\n \
    \ if #l2 == 1 then return l2 end\n  -- Intersection case.\n  local result = {}\n\
    \  for i in ipairs(l1) do\n    for j, _ in ipairs(l2) do\n      if l1[i] == l2[j]\
    \ then table.insert(result, l1[i]) end\n    end\n  end\n  return result\nend",
  "  local tmp = {}\n  for i=1,#l1 do\n    for j=1,#l2 do\n      if l1[i] == l2[j]\
    \ then\n        table.insert(tmp, i)\n      end\n    end\n  end\n  return tmp\n\
    end", "   local i1 = 0\n   local i2 = 0\n   while i1 < #l1 and i2 < #l2 do\n \
    \     if l1[i1] == l2[i2] then\n         i1 = i1 + 1\n         i2 = i2 + 1\n \
    \     else\n         return false\n      end\n   end\n   if i1 == #l1 then return\
    \ true end\n   if i2 == #l2 then return true end\n   return common(l1[1:i1], l2[1:i2])\
    \ or common(l1[i1+1:], l2[i2+1:])\nend", "  local l3 = {}\n  for i, v in ipairs(l1)\
    \ do\n    if l3[v] ~= nil then\n      l3[v] = true\n    elseif l2[i] ~= nil then\n\
    \      l3[v] = true\n    end\n  end\n  return table.concat(table.sort(l3))\nend",
  "  -- Optimization: if the two lists are the same length, return them.\n  if #l1\
    \ ~= #l2 then\n    return l1, l2\n  end", "  if l1 then\n    if l2 then\n    \
    \  assert(#l1 == #l2, 'Lists must have the same length.')\n      local i = 1\n\
    \      local m = {}\n      for _, v in pairs(l1) do\n        m[v] = i\n      \
    \  i = i + 1\n      end\n      for _, v in pairs(l2) do\n        m[v] = i\n  \
    \      i = i + 1\n      end\n      local ret = {}\n      for i = 1, #l1 do\n \
    \       if m[l1[i]] == m[l2[i]] then\n          table.insert(ret, l1[i])\n   \
    \     end\n      end\n      return ret\n    else\n      return l1\n    end\n \
    \ else\n    return l2\n  end\nend", "  if #l1 ~= #l2 then return nil end\n  local\
    \ i1, i2 = 1, #l1\n  local cur, prev  = {}, {}\n  while i1 <= i2 do\n    local\
    \ e1 = l1[i1]\n    local e2 = l2[i2]\n    if e1 == e2 then\n      cur = cur\n\
    \    elseif prev[e1] == e2 then\n      cur[e1] = cur[e1] + 1\n    else\n     \
    \ table.insert(cur, e2)\n      prev[e2] = e1\n    end\n    i1 = i1 + 1\n    i2\
    \ = i2 + 1\n  end\n  return cur\nend", "    local list = {}\n    for _, i in ipairs(l1)\
    \ do\n        table.insert(list, i)\n    end\n    for _, i in ipairs(l2) do\n\
    \        table.insert(list, i)\n    end\n    table.sort(list)\n    return list\n\
    end", "  local seen = {}\n  local i = 1\n  for item in l1 do\n    seen[item] =\
    \ nil\n    if l2[i] ~= item and l2[i] ~= nil then\n      i = i + 1\n      if seen[l2[i]]\
    \ == nil then seen[l2[i]] = item end\n    end\n  end\n  for item in l2 do\n  \
    \  if seen[item] == nil then return item end\n  end\n  return nil\nend", "  if\
    \ #l1 <= 0 then return nil end\n  if #l2 <= 0 then return nil end\n  local common\
    \ = {}\n  for i = 1, #l1 do\n    for j = 1, #l2 do\n      if l1[i] == l2[j] then\n\
    \        if #common == 0 then\n          table.insert(common, l1[i])\n       \
    \ else\n          table.insert(common, common[#common] + l1[i])\n        end\n\
    \      end\n    end\n  end\n  return common\nend", "    if l1 == nil or l2 ==\
    \ nil then\n        return nil\n    end\n    local counts = {}\n    for _, v in\
    \ ipairs(l1) do\n        if counts[v] == nil then\n            counts[v] = 0\n\
    \        end\n        counts[v] = counts[v] + 1\n    end\n    for _, v in ipairs(l2)\
    \ do\n        if counts[v] == nil then\n            counts[v] = 0\n        end\n\
    \        counts[v] = counts[v] - 1\n    end\n    local ret = {}\n    for k, v\
    \ in pairs(counts) do\n        if k > 0 and k <= v then\n            ret[#ret\
    \ + 1] = k\n        end\n    end\n    return ret\nend", "  local common = {}\n\
    \  local i1, i2 = 1, #l1\n  while i1 < i2 do\n    local v1, v2 = l1[i1], l2[i1]\n\
    \    if v1 == v2 then table.insert(common, v1) else break end\n    i1 = i1 + 1\n\
    \  end\n  i1, i2 = 1, #l2\n  while i1 < i2 do\n    local v1, v2 = l1[i1], l2[i1]\n\
    \    if v1 ~= v2 then break end\n    i1 = i1 + 1\n  end\n  return common\nend",
  "  local i1, j1 = next(l1), next(l2)\n  local i2, j2 = next(l2), next(l1)\n  while\
    \ i1 <= i2 do\n    if l1[i1] == l2[j2] then\n      return l1[i1]\n    end\n  \
    \  i1, j1 = next(l1, j1)\n  end\n  while j1 <= j2 do\n    if l1[next(l1)] == l2[j2]\
    \ then\n      return l1[next(l1)]\n    end\n    j1, j2 = next(l1, j2)\n  end\n\
    \  return nil\nend", "  if l1 == nil then\n    return l2\n  elseif l2 == nil then\n\
    \    return l1\n  end", "  local list1 = {}\n  local list2 = {}\n  for idx, value\
    \ in pairs(l1) do\n    list1[value] = true\n  end\n  for idx, value in pairs(l2)\
    \ do\n    list2[value] = true\n  end\n  local common = {}\n  for idx, value in\
    \ pairs(list1) do\n    if list2[value] then\n      common[value] = true\n    end\n\
    \  end\n  return common\nend", "  local i = #l1\n  local j = 0\n  local k = 0\n\
    \  while i < #l2 and j < #l1 do\n    if l1[i] == l2[j] then\n      i = i + 1\n\
    \      j = j + 1\n    elseif l1[i] < l2[j] then\n      k = k + 1\n      local\
    \ tmp1 = l1[i]\n      l1[i] = l2[j]\n      l2[j] = tmp1\n      i = i + 1\n   \
    \ else\n      k = k + 1\n      local tmp2 = l2[j]\n      l2[j] = l1[i]\n     \
    \ l1[i] = tmp2\n      j = j + 1\n    end\n  end\n  if #l1 ~= #l2 then\n    return\
    \ nil\n  else\n    return l1\n  end\nend", "  local t1 = {}\n  local i = 1\n \
    \ for _, v in ipairs(l1) do\n    table.insert(t1, v)\n    i = i + 1\n  end\n \
    \ for _, v in ipairs(l2) do\n    i = i + 1\n    local found = false\n    for _,\
    \ v1 in ipairs(t1) do\n      if v == v1 then\n        found = true\n        break\n\
    \      end\n    end\n    if not found then\n      table.insert(t1, v)\n    end\n\
    \  end\n  return table.remove(t1)\nend", "  local common = {}\n  for k, v in pairs(l1)\
    \ do\n    if l2.find(k) == nil then\n      table.insert(common, v)\n    end\n\
    \  end\n  return common\nend", "  local ret = {}\n  for _, value in pairs(l1)\
    \ do\n    for _, value2 in pairs(l2) do\n      if value == value2 then\n     \
    \   ret[#ret + 1] = value\n      end\n    end\n  end\n  table.sort(ret)\n  return\
    \ ret\nend", "    local i1, i2 = 1, #l1\n    while i1 do\n        local j1, j2\
    \ = 1, #l2\n        while j1 do\n            if l1[i1] == l2[j1] then\n      \
    \          return l1, l2\n            elseif l2[j2] then\n                j2 =\
    \ j2 + 1\n            else\n                j1 = j1 + 1\n            end\n   \
    \     end\n        i1 = i1 + 1\n    end\n    return l1, l2\nend", "  if #l1 ==\
    \ 0 then\n    return l2\n  elseif #l2 == 0 then\n    return l1\n  elseif #l1 <=\
    \ #l2 then\n    local i\n    local j\n    local ans\n    local m\n    for i =\
    \ 1, #l1 do\n      m = i\n      for j = 1, #l2 do\n        if l1[i] == l2[j] then\n\
    \          m = i - 1\n          break\n        end\n      end\n      if m ~= i\
    \ then\n        ans = common(l1[i+(#l1-1)], l2)\n        if ans ~= nil then\n\
    \          return ans\n        end\n      end\n    end\n  end\nend", "  local\
    \ set = {}\n  for _, v in ipairs(l1) do\n    set[v] = true\n  end\n  for _, v\
    \ in ipairs(l2) do\n    set[v] = true\n  end\n  return set\nend", "    assert(l1\
    \ and l2, 'Both lists cannot be empty')\n    local ret = {}\n    local l1idx =\
    \ 1\n    local l2idx = 1\n    while l2idx <= #l2 do\n        local elem = l2[l2idx]\n\
    \        if elem ~= l1[l1idx] then\n            if l1idx > 1 then\n          \
    \      table.insert(ret, l1[l1idx - 1])\n            end\n            table.insert(ret,\
    \ elem)\n            l1idx = l1idx + 1\n        else\n            l1idx = l1idx\
    \ + 1\n        end\n        l2idx = l2idx + 1\n    end\n    if l1idx <= #l1 then\n\
    \        table.insert(ret, l1[l1idx])\n    end\n    return ret\nend", "    assert(l1)\n\
    \    assert(l2)\n    local n1 = #l1\n    local n2 = #l2\n    local result = {}\n\
    \    for i = 1, #l1 do\n        for j = 1, #l2 do\n            if l1[i] == l2[j]\
    \ then\n                table.insert(result, l1[i])\n            end\n       \
    \ end\n    end\n    -- Sorting the result is a bit more complicated since we want\
    \ to keep the\n    -- original order.\n    table.sort(result, function(val1, val2)\n\
    \        if val1 < val2 then return -1 else return 1 end\n    end)\n    return\
    \ table.concat(result)\nend", "  local l\n  for i = 1, #l1 do\n    l = l2[i]\n\
    \    if not l then break end\n  end\n  \n  for i = #l2, 1, -1 do\n    l = l1[i]\n\
    \    if not l then break end\n  end\n  \n  return l\nend", "  if l1 == nil then\
    \ return l2 end\n  if l2 == nil then return l1 end\n  local i = 1\n  local ilast\
    \ = #l1 + 1\n  local j = 1\n  local jlast = #l2 + 1\n  local k = 1\n  local klast\
    \ = #l2 + 1\n  while i < ilast and j < jlast and k < klast do\n    if l1[i] ==\
    \ l2[j] then\n      k = k + 1\n      l1 = l1[i:]\n      ilast = #l1 + 1\n    elseif\
    \ l1[i] < l2[j] then\n      i = i + 1\n    else\n      j = j + 1\n    end\n  end\n\
    \  if i < ilast then l1 = l1[i:]\n  if j < jlast then l2 = l2[j:]\n  k = k - klast\n\
    \  while k < klast do\n    l2 = l2 .. l1[((i + 1) % #l1) + 1]\n    k = k + 1\n\
    \  end\n  return l1 .. l2\nend", "  if #l1 ~= #l2 then\n    return nil\n  end\n\
    \  local set1 = {}\n  local set2 = {}\n  for i=1, #l1 do\n    set1[l1[i]] = true\n\
    \  end\n  for i=1, #l2 do\n    set2[l2[i]] = true\n  end\n  for i=1, #set1 do\n\
    \    if set2[set1[i]] then\n      return set1[set1[i]]\n    end\n  end\nend",
  "  local common = {}\n  for _, v1 in ipairs(l1) do\n    for _, v2 in ipairs(l2)\
    \ do\n      if v1 == v2 then\n        table.insert(common, v1)\n      end\n  \
    \  end\n  end\n  table.sort(common)\n  return common\nend", "  if l1 == nil then\n\
    \    return l2\n  elseif l2 == nil then\n    return l1\n  else\n    local common\
    \ = {}\n    for _, x in ipairs(l1) do\n      for _, y in ipairs(l2) do\n     \
    \   if x == y then\n          table.insert(common, x)\n        end\n      end\n\
    \    end\n    return common\n  end\nend", "    local set = setmetatable({__l =\
    \ {}}, l1)\n    for _, v in ipairs(l2) do\n        set.__l[v] = true\n    end\n\
    \    return unpack(set.__l)\nend", "    local set = {}\n    for i, x in ipairs(l1)\
    \ do\n        set[x] = true\n    end\n    for _, v in ipairs(l2) do\n        if\
    \ set[v] then\n            return v\n        end\n    end\nend", "  if l1 then\n\
    \    local i1, i2, i3 = 1, #l1, 1\n    while i1 <= i2 do\n      if l1[i1] == l2[i2]\
    \ then i3 = i3 + 1; end\n      i1 = i1 + 1\n    end\n    if i1 < i3 then\n   \
    \   local i3 = i3 - 1\n      local i2, i1 = i1, i3 + 1\n      while i1 <= i2 do\n\
    \        l1[i1] = l2[i1]\n        i1 = i1 + 1\n      end\n    end\n  end\n  return\
    \ l1 or l2\nend", "    local i = 0\n    local j = 1\n    local c = 0\n    local\
    \ ans = {}\n    if #l1 ~= #l2 then\n        return nil\n    end\n    while i <\
    \ #l1 and j < #l2 do\n        if l1[i] == l2[j] then\n            i = i + 1\n\
    \            j = j + 1\n            c = c + 1\n        elseif l1[i] < l2[j] then\n\
    \            i = i + 1\n        else\n            j = j + 1\n        end\n   \
    \ end\n    while i < #l1 do\n        ans[#ans + 1] = l1[i]\n        i = i + 1\n\
    \    end\n    while j < #l2 do\n        ans[#ans + 1] = l2[j]\n        j = j +\
    \ 1\n    end\n    return ans\nend\n</code>\n<|/ a dscore=3 tags=lua-table,lua\
    \ |>\n<| c |>\nI didn't know this was possible at all - I guess I didn't know\
    \ Lua could iterate through an object like that. Thanks.\n<|/ c |>\n<| c |>\n\
    It is not possible, as you can't iterate through an object in Lua, only through\
    \ array elements. If you want to iterate through the object, you have to define\
    \ its methods and call them manually, which means that you'll have to create new\
    \ methods for every new iteration step. This is not very efficient.\n<|/ c |>\n\
    <| c |>\n: No, Lua doesn't have methods. It has metatables and metamethods. Lua\
    \ tables are objects too.\n<|/ c |>\n<| a dscore=3 |>\nI used the method suggested\
    \ by Chris Dodd but modified it for my own purposes.\n<code>", "    if l1 == nil\
    \ or l2 == nil then\n        return nil\n    end\n    if l1 == l2 then\n     \
    \   return l1\n    end\n    local l = {}\n    for _, el in pairs(l1) do\n    \
    \    for _, el2 in pairs(l2) do\n            if el == el2 then\n             \
    \   l[#l + 1] = 1\n            end\n        end\n    end\n    return l\nend",
  "    local common = {}\n    for _, v in pairs(l1) do\n        common[v] = true\n\
    \    end\n    for _, v in pairs(l2) do\n        if common[v] then\n          \
    \  common[v] = nil\n        else\n            common[v] = true\n        end\n\
    \    end\n    return pairs(common)\nend", "    if #l1 == 0 then return l2 end\n\
    \    if #l2 == 0 then return l1 end\n    if l1[1] == l2[1] then\n        return\
    \ common(l1[2], l2[2])\n    end\n    if l1[2] and l2[2] then\n        return common(l1[2],\
    \ common(l1[3], l2[3]))\n    end\n    if l1[3] and l2[3] then\n        return\
    \ common(common(l1[3], l1[#l1]), l2[3])\n    end\n    return l1[#l1]\nend", " \
    \   local hash1 = torch.hash(l1)\n    local hash2 = torch.hash(l2)\n    local\
    \ common = {}\n    for i, v in ipairs(l1) do\n        local found = nil\n    \
    \    for i, v2 in ipairs(l2) do\n            if v == v2 then\n               \
    \ found = v2\n                break\n            end\n        end\n        if\
    \ found ~= nil then\n            table.insert(common, found)\n        end\n  \
    \  end\n    table.sort(common)\n    return common\nend", "  if #l1 ~= #l2 then\n\
    \    return nil\n  end\n  local common = {}\n  local j = 0\n  for i = 1, #l1 do\n\
    \    local found = false\n    for j = 1, #l2 do\n      if l1[i] == l2[j] then\n\
    \        common[i] = true\n        found = true\n        break\n      end\n  \
    \  end\n    if not found then\n      common[i] = true\n    end\n  end\n  return\
    \ table.concat(common)\nend", "  local common = {}\n  for _, v1 in pairs(l1) do\n\
    \    for _, v2 in pairs(l2) do\n      if v1 == v2 then\n        common[#common+1]\
    \ = v1;\n      end\n    end\n  end\n  table.sort(common)\n  return common\nend",
  "  local set1 = setmetatable({}, {__index = function(t, key)\n      rawset(t, key,\
    \ nil)\n    end})\n  local set2 = setmetatable({}, {__index = function(t, key)\n\
    \      rawset(t, key, nil)\n    end})", "  local i1\n  local i2\n  local i1i\n\
    \  local i2i\n  local i1j\n  local i2j\n  if l1 == nil then\n    return nil\n\
    \  end\n  if l2 == nil then\n    return l1\n  end\n  local count\n  if #l1 ~=\
    \ #l2 then\n    return nil\n  end\n  for i1 = 1, #l1 do\n    count = nil\n   \
    \ for i2 = 1, #l2 do\n      if l1[i1] == l2[i2] then\n        if count == nil\
    \ then\n          count = i1\n          i1i = i1\n          i2i = i2\n       \
    \   i1j = i1\n          i2j = i2\n        else\n          count = count + 1\n\
    \        end\n      end\n    end\n    if count then\n      --l1:insertBefore(l1[count],\
    \ l1[#l1])\n      --l2:insertBefore(l2[count], l2[#l2])\n      --l1:remove(l1[count])\n\
    \      --l2:remove(l2[count])\n      l1[#l1] = nil\n      l2[#l2] = nil\n    \
    \  return common(l1, l2)\n    end\n  end\n  return l1\nend\ncommon = common",
  "  local table = {}\n  for _, v1 in ipairs(l1) do\n    for _, v2 in ipairs(l2) do\n\
    \      if v1 == v2 then\n        table[v1] = true\n      end\n    end\n  end\n\
    \  return table\nend", "    local i, j, k\n    local l = #l1\n    local m = #l2\n\
    \    local common = {}\n    while l > 0 and m > 0 do\n        i = l1\n       \
    \ j = l2\n        k = i\n        while j > 0 and k < m do\n            k = k +\
    \ 1\n            if l1[k] ~= l2[k] then\n                common[k] = l1[k]\n \
    \               i = i + 1\n            else\n                j = j - 1\n     \
    \       end\n        end\n        l1 = l1[i..-1]\n        m = m-1\n    end\n \
    \   return common\nend", "  local i1, i2, i3 = 1, #l1, #l2\n  local l3, l4 = {},\
    \ {}\n  while i3 do\n    local v1 = l1[i1]\n    local v2 = l2[i2]\n    if v1 ==\
    \ v2 then return v1 end\n    if v1<v2 then\n      l3[#l3+1] = v1\n      i1 = i1\
    \ + 1\n    else\n      l4[#l4+1] = v2\n      i2 = i2 + 1\n    end\n    i3 = i3\
    \ - 1\n  end\n  if i1 == 1 then\n    return l2\n  else\n    return l4\n  end\n\
    end", "    local i1, i2 = 1, #l1\n    local j1, j2 = 1, #l2\n    while i1 <= i2\
    \ do\n        if l1[i1] == l2[j1] then\n            j1 = j1 + 1\n        elseif\
    \ l1[i1] > l2[j1] then\n            i1 = i1 + 1\n        else\n            i2\
    \ = i2 + 1\n        end\n    end\n    return l1[i1]\nend", "   -- Set up table\
    \ with counts of l1 elements.\n   local counts = { }\n   for _, v in ipairs(l1)\
    \ do\n      counts[v] = counts[v] + 1 or 1\n   end", "  local set = setmetatable({\
    \ __index = nil }, {})\n  for _, v in ipairs(l1) do\n    table.insert(set, v)\n\
    \  end\n  for _, v in ipairs(l2) do\n    table.insert(set, v)\n  end\n  return\
    \ set\nend", "  -- Create tables for traversal and auxiliary data structures.\n\
    \  local t = {}\n  local u = {}\n  local o", "\tlocal i = 1\n\tlocal j = 1\n\t\
    local common_elements = {}\n\twhile i <= #l1 and j <= #l2 do\n\t\tif l1[i] ==\
    \ l2[j] then\n\t\t\tcommon_elements[#common_elements + 1] = tonumber(i)\n\t\t\t\
    i = i + 1\n\t\t\tj = j + 1\n\t\telseif l1[i - 1] < l2[j] then\n\t\t\ti = i + 1\n\
    \t\telse\n\t\t\tj = j + 1\n\t\tend\n\tend\n\treturn common_elements\nend", " \
    \   local i1, i2 = 1, #l1\n    local i3, i4  = 1, #l2\n    while i1 <= i3 and\
    \ i2 <= i4 do\n        if l1[i1] == l2[i2] then\n            return l1[i1], l2[i2]\n\
    \        end\n        local d1, d2 = l1[i1] - l2[i2], l1[i2] - l2[i1]\n      \
    \  if d1 > 0 and d2 > 0 then\n            if d1 * d2 > 0 then\n              \
    \  return l1[i1], l2[i2]\n            else\n                i3, i4 = i4, i3\n\
    \            end\n        elseif d1 < 0 and d2 < 0 then\n            return l1[i1],\
    \ l2[i2]\n        elseif d1 < 0 and d2 < 0 then\n            return l1[i1], l2[i2]\n\
    \        end\n        i1, i2 = i2, i2 + 1\n    end\nend\n_G.unique = common.call",
  "   assert(type(l1) == 'table' and type(l2) == 'table')\n   local size = #l1 + 1\n\
    \   local common = {}\n   for i = 1, size do\n      if l1[i] == l2[i] then\n \
    \        common[i] = true\n      elseif l1[i] < l2[i] then\n         common[#common\
    \ + 1]  = l1[i]\n      else\n         common[#common + 1]  = l2[i]\n      end\n\
    \   end\n   return common\nend", "\tlocal i1, j1, k1\n\tlocal i2, j2, k2", " \
    \  local n1 = #l1\n   local n2 = #l2\n   local s = l1[math.random(n1)]\n   while\
    \ n1 <= n2 do\n      s = l1[math.random(n1)]\n   end\n   local e = l2[math.random(n2)]\n\
    \   while n1 <= n2 do\n      e = l2[math.random(n2)]\n   end\n   while s == e\
    \ do\n      e = l2[math.random(n2)]\n   end\n   return s, e\nend", "  local l1\
    \ = l1 or ({}):reverse()\n  local l2 = l2 or ({}):reverse()\n  local table = {}\n\
    \  for _, x in ipairs(l1) do table[x] = true end\n  for _, x in ipairs(l2) do\
    \ table[x] = true end\n  return table.keys()\nend", "  local common = {}\n  local\
    \ i1, i2 = 1, #l1\n  local j1, j2 = 1, #l2\n  while i1 <= i2 and j1 <= j2 do\n\
    \    if l1[i1] == l2[j1] then\n      table.insert(common, l1[i1])\n      i1 =\
    \ i1 + 1\n      j1 = j1 + 1\n    else\n      if l1[i2] < l2[j2] then\n       \
    \ i2 = i2 + 1\n      else\n        j2 = j2 + 1\n      end\n    end\n  end\n  if\
    \ i1 <= i2 then\n    for i = i2, #l1 do\n      table.insert(common, l1[i])\n \
    \   end\n  end\n  if j1 <= j2 then\n    for j = j2, #l2 do\n      table.insert(common,\
    \ l2[j])\n    end\n  end\n  return common\nend", "  local common = {}\n  local\
    \ i1 = 0\n  local i2 = 0\n  local i = 0\n  while i1 < #l1 and i2 < #l2 do\n  \
    \  local e1 = l1[i1]\n    local e2 = l2[i2]\n    common[i] = e1\n    i1 = i1 +\
    \ 1\n    i2 = i2 + 1\n    i = i + 1\n    if i == #l1 or i == #l2 then break end\n\
    \  end\n  return common\nend", "    if l1 == nil or l2 == nil then\n        return\
    \ nil\n    end", "    if l1 == nil then\n        return l2\n    end\n    if l2\
    \ == nil then\n        return l1\n    end\n    local n1, n2 = #l1, #l2\n    local\
    \ mt = type(l1)\n    if mt ~= 'table' and mt ~= 'userdata' then\n        return\
    \ nil\n    end\n    local d = {}\n    for i = 1, n1 do\n        d[l1[i]] = true\n\
    \    end\n    for i = 1, n2 do\n        if d[ l2[i] ] then\n            return\
    \ l1[i - 1]\n        end\n    end\n    return nil\nend", "  local t1 = {}\n  local\
    \ t2 = {}\n  for _, v in ipairs(l1) do\n    t1[v] = true\n  end\n  for _, v in\
    \ ipairs(l2) do\n    t2[v] = true\n  end\n  return table.concat(table.sort(table.keys(t1),\
    \ function(a, b) return t1[a] < t1[b] end),\n                       ', ') or 'None'\n\
    end", "  local i\n  if #l1 == 0 then\n    return l2\n  end\n  if #l2 == 0 then\n\
    \    return l1\n  end\n  for i = 1, #l1 do\n    for j = 1, #l2 do\n      if l1[i]\
    \ == l2[j] then\n        table.insert(l1, i)\n        return l1\n      end\n \
    \   end\n  end\nend", "  local n1 = #l1\n  local n2 = #l2\n  -- If either of the\
    \ lists is empty, they can't be compared. \n  if not n1 and not n2 then\n    return\
    \ nil\n  end\n  -- Both lists are empty.\n  if not n1 or not n2 then\n    return\
    \ []\n  end\n  -- At least one list has more items than the other.\n  if n1 >\
    \ n2 then\n    return common(l2, l1)\n  end\n  -- At least one list has fewer\
    \ items than the other.\n  if n1 < n2 then\n    return common(l1, l2)\n  end\n\
    \  -- Find the smallest number and remove it from the lists.\n  local pivot =\
    \ l1[1]\n  table.remove(l1, 1)\n  table.remove(l2, 1)\n  -- Compare the pivot\
    \ element to all the other elements.\n  local i = 1\n  while i <= n1 do\n    if\
    \ l1[i] ~= pivot then\n      if pivot > l2[i] then\n        table.remove(l1, i)\n\
    \      else\n        table.remove(l2, i)\n      end\n    else\n      i = i + 1\n\
    \    end\n  end\n  return l1 + l2\nend", "  local n1, m1 = #l1, {}\n  local n2,\
    \ m2 = #l2, {}\n  for i = 1, n1 do\n    table.insert(m1, l1[i])\n  end\n  for\
    \ i = 1, n2 do\n    table.insert(m2, l2[i])\n  end\n  local i = 1\n  local j =\
    \ 1\n  local k = 1\n  local temp\n  local ret = {}\n  while i <= n1 and j <= n2\
    \ do\n    if m1[i - 1] ~= m2[j - 1] then\n      if m1[i - 1] ~= nil then\n   \
    \     table.insert(ret, m1[i - 1])\n      end\n      if m2[j - 1] ~= nil then\n\
    \        table.insert(ret, m2[j - 1])\n      end\n      i = i + 1\n      j = j\
    \ + 1\n    else\n      if m1[i - 1] ~= nil then\n        k = k + 1\n        temp\
    \ = nil\n        while k <= n2 do\n          if m2[k - 1] == m1[i - 1] then\n\
    \            temp = m2[k - 1]\n          end\n          k = k + 1\n        end\n\
    \        if temp == nil then\n          table.insert(ret, m1[i - 1])\n       \
    \ end\n        i = i + 1\n      elseif m2[j - 1] ~= nil then\n        k = k +\
    \ 1\n        temp = nil\n        while k <= n1 do\n          if m1[i - 1] == m2[k\
    \ - 1] then\n            temp = m1[i - 1]\n          end\n          k = k + 1\n\
    \        end\n        if temp == nil then\n          table.insert(ret, m2[j -\
    \ 1])\n        end\n        j = j + 1\n      else\n        i = i + 1\n       \
    \ j = j + 1\n      end\n    end\n  end\n  return ret\nend", "  local l = {}\n\
    \  for _, x in ipairs(l1) do\n    for _, y in ipairs(l2) do\n      if x == y then\n\
    \        table.insert(l, x)\n      end\n    end\n  end\n  return l\nend", "  local\
    \ n = #l1 + 1\n  local m = #l2 + 1\n  local l = {}\n  for i = 1, n do\n    l[i]\
    \ = 0\n  end\n  for i = 1, m do\n    l[i] = 0\n  end\n  for i = 1, n do\n    for\
    \ j = 1, m do\n      if l1[i] == l2[j] then\n        l[i] = l[i] + 1\n      end\n\
    \    end\n  end\n  -- Only unique results.\n  -- We don't need to worry about\
    \ sorting if they are unique.\n  local results = {}\n  for i = 1, n do\n    if\
    \ l[i] == n then\n      table.insert(results, l1[i])\n    end\n  end\n  return\
    \ results\nend", "    local u = {}\n    for _, x in ipairs(l1) do\n        u[x]\
    \ = true\n    end\n    for _, x in ipairs(l2) do\n        if u[x] then\n     \
    \       u[x] = nil\n        else\n            return x\n        end\n    end\n\
    end", "  local i = 0\n  local j = 0\n  local l3", "    assert(l1 and l2, 'Common:\
    \ L1 or L2 not defined'..tostring(l1) ..' ' ..tostring(l2))\n    local common\
    \ = {}\n    local i = 1\n    for k in pairs(l1) do\n        common[k] = true\n\
    \        i = i + 1\n    end\n    for k in pairs(l2) do\n        if common[k] then\n\
    \            common[k] = nil\n        else\n            common[k] = true\n   \
    \     end\n        i = i + 1\n    end\n    for i=1, #common do\n        if common[i]\
    \ == nil then\n            return common\n        end\n    end\n    return common\n\
    end", "    local i1, j1, k1 = l1 ~= nil, #l1, 1\n    local i2, j2, k2 = l2 ~=\
    \ nil, #l2, 1\n    while i1 ~= i2 do\n        if l1[i1] == l2[j2] then\n     \
    \       for k = 1, k1 do\n                local v1 = l1[k]\n                local\
    \ v2 = l2[k]\n                if v1 < v2 then return false end\n            end\n\
    \            k1 = j1 + 1\n            k2 = j2 + 1\n        else if l2[j2] > l1[i1]\
    \ then return false end\n        else return false end\n        i1, j1, k1 = i1\
    \ + 1, j1 + 1, k1 + 1\n        i2, j2, k2 = i2 + 1, j2 + 1, k2 + 1\n    end\n\
    \    if k1 < k2 then return false end\n    local k1, k2 = k1 + 1, k2 + 1\n   \
    \ while k1 < k2 do\n        local v1 = l1[k1]\n        local v2 = l2[k1]\n   \
    \     if v1 < v2 then return false end\n        k1, k1 = k1 + 1, k1 + 1\n    end\n\
    \    return true\nend", "  if #l1 < 1 then return l2 end\n  if #l2 < 1 then return\
    \ l1 end\n  local l3 = {}\n  repeat\n    local i1, i2 = next(l1), next(l2)\n \
    \   if i1 == nil or i2 == nil then break end\n    if l3[i1] == nil then l3[i1]\
    \ = i2 end\n    if l3[i2] == nil then l3[i2] = i1 end\n  until false\n  return\
    \ table.sort(l3)\nend", "  local l1,l2,n1,n2 = {}, {}, {}, {}\n  for i=1,#l1 do\n\
    \    local n1 = n1[l1[i]] or n1[ l1[i] ] = i\n  end\n  for i=1,#l2 do\n    local\
    \ n2 = n2[ l2[i] ] or n2[ l2[i] ] = i\n  end\n  for k,v in pairs(n1) do\n    table.insert(l1,\
    \ v)\n  end\n  for k,v in pairs(n2) do\n    table.insert(l2, v)\n  end\n  return\
    \ table.remove(l1, #l1), table.remove(l2, #l2)\nend", "  local i1, i2, j1, j2\
    \ = {}, {}, {}, {}\n  for i=1, #l1 do\n    local e1 = l1[i]\n    if i2[e1] then\
    \ i1[e1] = nil else\n      j1[e1] = i1[e1] = i + 1\n    end\n  end\n  for i=1,\
    \ #l2 do\n    local e2 = l2[i]\n    if i1[e2] then i2[e2] = nil else\n      j2[e2]\
    \ = i2[e2] = i + 1\n    end\n  end\n  local result = {}\n  for _, v1 in i1 do\
    \ result[#result + 1] = v1 end\n  for _, v2 in i2 do result[#result + 1] = v2\
    \ end\n  table.sort(result)\n  for i=1, #result do result[i] = j2[result[i]] end\n\
    \  return result\nend", "  local m = {}\n  for i = 1, #l1 do\n    m[l1[i]] = nil\n\
    \  end\n  for i = 1, #l2 do\n    m[l2[i]] = nil\n  end\n  local t = {}\n  local\
    \ j = 0\n  for k in pairs(m) do t[j] = k end\n  table.sort(t)\n  local r = {}\n\
    \  local k\n  for j = 1, #t do\n    k = t[j]\n    r[#r + 1] = k\n  end\n  return\
    \ r\nend\n</cell>\n<cell>", "  local common = {}\n  for _, el1 in ipairs(l1) do\n\
    \    for _, el2 in ipairs(l2) do\n      if el1 == el2 then\n        table.insert(common,\
    \ el1)\n      end\n    end\n  end\n  return common\nend", "  local ret = {}\n\
    \  for i,v in ipairs(l1) do\n    for j,v2 in ipairs(l2) do\n      if v == v2 and\
    \ i ~= j then\n        ret[#ret+1] = v\n      end\n    end\n  end\n  return ret\n\
    end", "  local n1, n2 = #l1, #l2\n  assert(n1 > 0 and n2 > 0)\n  local i, j =\
    \ 1, n1 + 1\n  while i <= n1 and j <= n2\n    do\n      if l1[i] == l2[j] then\n\
    \        i, j = i + 1, j + 1\n      else\n        local k = i\n        while i\
    \ <= n1 and l2[k] == l1[i] do\n          i = i + 1\n        end\n        if i\
    \ <= n1 then\n          -- Repeat l2[k]\n          i = i + 1\n        end\n  \
    \      if j <= n2 then\n          -- Repeat l1[i]\n          j = j + 1\n     \
    \   end\n        if i == n1 then\n          -- Repeat l2[j]\n          j = j +\
    \ 1\n        end\n        return l2[j] if j == n2 else\n               l1[i] if\
    \ i == n1 end\n      end\n    end\n  assert(i <= n1 and j <= n2)\n  -- Repeat\
    \ last element(s)\n  local k = j\n  while i <= n1 do\n    l2[k] = l1[i]\n    i\
    \ = i + 1\n    k = k + 1\n  end\n  assert(k == n2)\n  -- Return as string\n  return\
    \ table.concat(l1, \"\"), table.concat(l2, \"\")\nend", "    local l3 = {}\n \
    \   for i = 1, #l2 do\n        for j = 1, #l1 do\n            if l1[j] == l2[i]\
    \ then\n                l3[#l3 + 1] = l1[j]\n            end\n        end\n  \
    \  end\n    return l3\nend", "  local t1 = {}\n  local t2 = {}\n  for _, v in\
    \ pairs(l1) do\n    t1[v] = true\n  end\n  for _, v in pairs(l2) do\n    t2[v]\
    \ = true\n  end\n  return pairs(t1)\nend", "    if l1 == nil then return nil end\n\
    \    if l2 == nil then return l1 end", "  local n = #l1\n  if n == 0 then\n  \
    \  return l2\n  end\n  local m = #l2\n  if m == 0 then\n    return l1\n  end\n\
    \  local i\n  local j\n  local k\n  local l\n  local l3\n  local l4\n  local l5\n\
    \  local l6\n  local l7\n  local l8\n  local l9\n  local l10\n  local l11\n  local\
    \ l12\n  local l13\n  local l14\n  local l15\n  local l16\n  local l17\n  local\
    \ l18\n  local l19\n  local l20\n  local l21\n  local l22\n  local l23\n  local\
    \ l24\n  local l25\n  local l26\n  local l27\n  local l28\n  local l29\n  local\
    \ l30\n  local l31\n  local l32\n  local l33\n  local l34\n  local l35\n  local\
    \ l36\n  local l37\n  local l38\n  local l39\n  local l40\n  local l41\n  local\
    \ l42\n  local l43\n  local l44\n  local l45\n  local l46\n  local l47\n  local\
    \ l48\n  local l49\n  local l50\n  local l51\n  local l52\n  local l53\n  local\
    \ l54\n  local l55\n  local l56\n  local l57\n  local l58\n  local l59\n  local\
    \ l60\n  local l61\n  local l62\n  local l63\n  local l64\n  local l65\n  local\
    \ l66\n  local l67\n  local l68\n  local l69\n  local l70\n  local l71\n  local\
    \ l72\n  local l73\n  local l74\n  local l75\n  local l76\n  local l77\n  local\
    \ l78\n  local l79\n  local l80\n  local l81\n  local l82\n  local l83\n  local\
    \ l84\n  local l85\n  local l86\n  local l87\n  local l88\n  local l89\n  local\
    \ l90\n  local l91\n  local l92\n  local l93\n  local l94\n  ", "    if l1 ==\
    \ nil or l2 == nil then return nil end\n    if type(l1) == 'table' and type(l2)\
    \ == 'table' then\n        if l1 == l2 then return l1 end\n        if l1 ~= l2\
    \ then return nil end\n    end\n    local i1 = 1\n    local i2 = 1\n    local\
    \ j = 1\n    local k = 1\n    while i1 <= #l1 and i2 <= #l2 do\n        local\
    \ i3 = l1[i1]\n        local i4 = l2[j-1]\n        if i3 == i4 then\n        \
    \    if j > k then\n                l1[k] = l1[j-1]\n                l1[j-1] =\
    \ i3\n            end\n            j = j + 1\n        elseif i3 > i4 then\n  \
    \          k = k + 1\n        end\n        i1 = i1 + 1\n        i2 = i2 + 1\n\
    \    end\n    if j <= k then\n        table.insert(l1, l1[k])\n    end\n    return\
    \ l1\nend", "  local sorted = {}\n  for i = 1, #l1 do\n    if sorted[l2[i]] then\
    \ break end\n    table.insert(sorted, l1[i])\n  end\n  return sorted\nend", "\t\
    local l1 = l1 or {}\n\tlocal l2 = l2 or {}\n\tlocal common = {}", "  local l3\
    \ = {}\n  for _,v in pairs(l1) do\n    l3[v] = true\n  end\n  for _,v in pairs(l2)\
    \ do\n    if not l3[v] then\n      return nil\n    end\n  end\n  return l3\nend",
  "    local i1, i2, i3, i4\n    local iL1, iL2, iL3, iL4\n    local l = #l1, #l2",
  "    local i = 1\n    local j = 1\n    while i < l1 and j < l2 do\n        if l1[i]\
    \ ~= l2[j] then\n            i = i + 1\n            j = j + 1\n        else\n\
    \            i = i + 1\n            j = j + 1\n        end\n    end\n    if i\
    \ < l1 then\n        if j < l2 then\n            return l1, l2\n        end\n\
    \    else\n        if j < l2 then\n            return l2, l1\n        end\n  \
    \  end\n    return l1, l2\nend", "    local n = #l1\n    local m = #l2\n    local\
    \ common = {}\n    for i = 1, n do\n        for j = 1, m do\n            if l1[i]\
    \ == l2[j] then\n                table.insert(common, l2[j])\n            else\n\
    \                break\n            end\n        end\n    end\n    return common\n\
    end", "  local i1 = 1\n  local i2 = 1\n  local i\n  local c = 0\n  for i = 1,\
    \ #l1 do\n    while (i2 < #l2 and l1[i] == l2[i2]) do\n      i2 = i2 + 1\n   \
    \ end\n    if i2 == #l2 then\n      if c == 1 then\n        return l1[i - 1]\n\
    \      end\n      c = 0\n      i2 = i2 + 1\n    end\n    if c == 0 then\n    \
    \  c = 1\n      i1 = i + 1\n    end\n  end\nend", "    local hash1 = common.getHash(l1)\n\
    \    local hash2 = common.getHash(l2)\n    for i = 1, #l1 do\n        if hash1[l1[i]]\
    \ == hash2[l2[i]] then\n            return l1[i]\n        end\n    end\nend",
  "\tlocal ret = {}\n\tfor i, el1 in ipairs(l1) do\n\t\tfor j, el2 in ipairs(l2) do\n\
    \t\t\tif el1 == el2 then\n\t\t\t\ttable.insert(ret, el1)\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn ret\nend", "  local l3 = {}\n  for _, v in ipairs(l1) do\n   \
    \ if l3[v] == nil then\n      l3[v] = true\n    else\n      return nil\n    end\n\
    \  end\n  for _, v in ipairs(l2) do\n    if l3[v] == nil then\n      l3[v] = true\n\
    \    else\n      return nil\n    end\n  end\n  return l3\nend", "  local l3 =\
    \ {}\n  for _, _, _ in ipairs(l1) do\n    for _, _, _ in ipairs(l2) do\n     \
    \ table.insert(l3, _)\n    end\n  end\n  return l3\nend", "    if l1 == nil or\
    \ l2 == nil then\n        return nil\n    end\n    local lLen = #l1\n    local\
    \ rLen = #l2\n    local i, j, k\n    if lLen < rLen then\n        i, j, k = lLen,\
    \ #l2, rLen\n    else\n        i, j, k = rLen, #l1, lLen\n    end\n    local set\
    \ = {}\n    for i = 1, k do\n        set[i] = true\n    end\n    for j = 1, i\
    \ do\n        if set[j] then\n            for k = 1, j do\n                if\
    \ not set[k] then\n                    table.insert(l1, l2[k])\n             \
    \   end\n            end\n            j = i - 1\n        end\n    end\n    return\
    \ l1\nend\n</code>\n<|/ a |>\n<| c |>\nThanks ! I've made a little change to make\
    \ it a little faster: instead of using table.insert at each iteration, it just\
    \ adds it to a result array. Then, it returns the array at the end. Maybe it will\
    \ help someone.\n<|/ c |>\n<| a tags=lua dscore=2 |>\nAn interesting approach,\
    \ albeit a bit slower than Pedro's solution:\n<code>", "  if l1 == nil or l2 ==\
    \ nil then\n    return nil\n  elseif l1 == l2 then return l1 end\n  local i1 =\
    \ 1\n  local i2 = 1\n  local common = {}\n  repeat\n    local c1 = l1[i1]\n  \
    \  local c2 = l2[i2]\n    if c1 == c2 then\n      common[#common+1] = c1\n   \
    \   i1 = i1 + 1\n      i2 = i2 + 1\n    else\n      i1 = i1 + 1\n    end\n  until\
    \ i1 < l1 \n  repeat\n    local c1 = l2[i2]\n    i2 = i2 + 1\n    if c1 == c2\
    \ then\n      common[#common+1] = c1\n    else\n      i2 = i2 + 1\n    end\n \
    \ until i2 < l2\n  return common\nend", "\tassert(#l1 >= 0 and #l2 >= 0)\n\tlocal\
    \ n1 = #l1\n\tlocal n2 = #l2\n\tif n1 <= 1 or n2 <= 1 then return nil end\n\t\
    local nMin = math.min(n1, n2)\n\tlocal i\n\tlocal j\n\tlocal tmp\n\tlocal tmp1\n\
    \tlocal tmp2\n\tlocal inBoth = true", "   local t1 = setmetatable({}, l1)\n  \
    \ local t2 = setmetatable({}, l2)\n   for k in pairs(t1) do\n      if t1[k] ==\
    \ t2[k] then\n         t1[k] = nil\n      end\n   end\n   return next(t1)\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| a |>\n<code>"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
