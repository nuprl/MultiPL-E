name: HumanEval_97_multiply
language: lua
prompt: "-- Complete the function that takes two integers and returns \n-- the product\
  \ of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n--\
  \ multiply(148, 412) should return 16.\n-- multiply(19, 28) should return 72.\n\
  -- multiply(2020, 1851) should return 0.\n-- multiply(14,-15) should return 20.\n\
  local function multiply(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = multiply\n\
  \    lu.assertEquals(candidate(148, 412), 16)\n    lu.assertEquals(candidate(19,\
  \ 28), 72)\n    lu.assertEquals(candidate(2020, 1851), 0)\n    lu.assertEquals(candidate(14,\
  \ -15), 20)\n    lu.assertEquals(candidate(76, 67), 42)\n    lu.assertEquals(candidate(17,\
  \ 27), 49)\n    lu.assertEquals(candidate(0, 1), 0)\n    lu.assertEquals(candidate(0,\
  \ 0), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if b == 0 then\n        return 0;\n    elseif b == 1 then\n   \
    \     return a;\n    else\n        local result = a;\n        while result > b\
    \ and result > 0 and result % b == 0 do\n            result = result / b;\n  \
    \      end\n        return result;\n    end\nend\n</cell>\n<cell>", "  if b ==\
    \ 0 then\n      return 0\n  end\n  \n  local r = a % b\n  return multiply(b, r)\n\
    end", "\tlocal result = 0\n\t\n\tfor i=1,10 do\n\t\t\n\t\tif b == nil then\n\t\
    \t\tresult = result * 10 + a\n\t\telse\n\t\t\tresult = result * 10 + b\n\t\tend\n\
    \tend", "    local result\n    -- Multiply without overflow\n    if b == 0 then\n\
    \        result = 0;\n    else\n        local a_digits = math.floor(a)\n     \
    \   local b_digits = math.floor(b)\n        if a_digits > b_digits then\n    \
    \        local temp = a\n            a = b\n            b = temp\n        end\n\
    \        result = a_digits * b_digits\n    end\n    -- Handle special cases\n\
    \    if a == 0 then\n        return b\n    elseif b == 0 then\n        return\
    \ a\n    elseif result == 0 then\n        return result\n    end\nend", "    --\
    \ Your code here.\n    return a * b\nend", "   assert(a > 0, \"First number cannot\
    \ be 0\")\n   assert(b > 0, \"Second number cannot be 0\")\n   local res, carry\n\
    \   for i=1, math.ceil(math.log(b,10)+1) do\n      local current = b / 10\n  \
    \    res = math.floor(res * 10 + current) + carry\n      carry = current - res\
    \ * 10\n      b = b - current\n   end\n   return res * 10 + carry\nend", "  --\
    \ Convert a and b to strings and return their product as string.\n  local res\
    \ = \"\"\n  local carry = false\n  repeat\n    res = string.format(\"%s%s\", res,\
    \ math.floor(a * b))\n    carry = res > 0\n    a, b = math.modf(a * b); \n  until\
    \ not carry and b > 0\n  return res\nend", "  if a == 0 then\n    return 0\n \
    \ elseif b == 0 then\n    return a\n  elseif b < a then\n    return multiply(b,\
    \ a)\n  else\n    local result = 1\n    while a > 0 do\n      result = result*10\
    \ + a%10\n      a = math.floor(a/10)\n    end\n    return result\n  end\nend",
  "  -- Your code here\n  local product = 1\n  for i = 1,10 do\n    product = product\
    \ * 10 + a\n  end\n  product = product * b\n  return product\nend", "    if a\
    \ == 0 then\n        return 0\n    else\n        if b == 0 then\n            return\
    \ 1\n        else\n            local sum = 0\n            while b ~= 0 do\n  \
    \              local remainder = a % b\n                a = b\n              \
    \  b = remainder\n                sum = sum + remainder\n            end\n   \
    \         return sum\n        end\n    end\nend", "  if a < 0 then a = a + 36\
    \ end\n  if b < 0 then b = b + 36 end\n  if a > 12 then return 0 end\n  if b >\
    \ 12 then return 0 end\n  return a * b\nend", "    assert(b < 0 and a or b, \"\
    Invalid inputs\")\n    local sum = 0\n    while a >= 0 do\n        local digit\
    \ = a % 10\n        sum = sum + digit * b\n        a = math.floor(a/10)\n    \
    \    b = b - digit\n    end\n    return sum\nend", "\tlocal sum = 0\n\tlocal carry\
    \ = false\n\twhile b do\n\t\tsum = sum + b%10 * 10 + carry * 1\n\t\tcarry = b/10\n\
    \t\tb = math.floor(b/10)\n\tend\n\treturn sum + carry * 1\nend", "    local temp\
    \ = 0\n    for i = 1, 10 do\n        local mul = a%10\n        a = a//10\n   \
    \     if a>0 then\n            temp = (mul * 10) + temp\n        end\n    end\n\
    \    if b > 0 then\n        return temp * b\n    else\n        return 0\n    end\n\
    end", "    -- Write your code here\n    local total = 0\n    local count = 0\n\
    \    while a > 0 or b > 0 do\n        if a > 0 then\n            count = count\
    \ + 1\n            total = total + (a % 10) * (b / 10)\n            a = math.floor(a/10)\n\
    \        elseif b > 0 then\n            count = count + 1\n            total =\
    \ total + (b / 10) * (a % 10)\n            b = math.floor(b/10)\n        else\n\
    \            count = count + 1\n            total = total * (a % 10)\n       \
    \     a = math.floor(a/10)\n            b = math.floor(b/10)\n        end\n  \
    \  end\n    return total\nend\nassert(multiply(148, 412) == 16)\nassert(multiply(19,\
    \ 28) == 72)\nassert(multiply(2020, 1851) == 0)\nassert(multiply(14,-15) == 20)",
  "  if b < 0 then\n    a = a - b\n    if a < 0 then \n      return 0\n    else\n\
    \      return math.floor(a * 1e6)\n    end\n  else\n    if a < 0 then \n     \
    \ return 0\n    else\n      return math.floor(a * 1e6)\n    end\n  end\nend",
  "  if a == 0 then return 0 end\n  \n  local carry = 1\n  local result = 0\n  local\
    \ carryOver = 1\n  \n  while (b > 0) do\n    local digitA = a % 10\n    local\
    \ digitB = b % 10\n    \n    if digitA == 1 then\n      if digitB == 1 then\n\t\
    result = result + digitB\n\tcarryOver = carryOver * 10\n      else\n\tresult =\
    \ result + digitB + carryOver\n\tcarryOver = carryOver * 10\n\tcarry = 1\n   \
    \   end\n    elseif digitB == 1 then\n      result = result + digitA + carry\n\
    \      carryOver = carryOver * 10\n      carry = 1\n    else\n      result = result\
    \ + digitA + carry\n      carry = 1\n    end\n    \n    a = a / 10\n    b = b\
    \ / 10\n  end\n  \n  if carry ~= 1 then\n    result = result + carry \n  end\n\
    \  \n  return result\nend", "   if a == nil or b == nil then\n      return nil\n\
    \   end\n   local ans = 10\n   for i = 1, 6 do\n      ans = ans * 10\n      ans\
    \ = ans + math.floor(b / 10)\n      b = b % 10\n   end\n   if b > 0 then\n   \
    \   return nil\n   end\n   return ans * 10\nend", "  local result = 1\n  local\
    \ carry = 0\n  local unitDigits = 1\n  local bUnitDigits = b / 10\n  for i = 1,\
    \ bUnitDigits do\n    if i < bUnitDigits - 1 then\n      result = result + carry\
    \ * unitDigits\n    end\n    carry = carry + a % 10\n    a = a / 10\n    unitDigits\
    \ = unitDigits * 10\n  end\n  if carry > 0 then\n    result = result + carry *\
    \ unitDigits\n  end\n  if b < 0 then\n    result = -result\n  end\n  if result\
    \ > 2147483647 then\n    return 0\n  end\n  return result\nend", "\t--assert(\"\
    number\"==type(a), \"First input must be a number\")\n\t--assert(\"number\"==type(b),\
    \ \"Second input must be a number\")\n\t--assert(a > 0, \"First input must be\
    \ greater than 0\")\n\t--assert(b > 0, \"Second input must be greater than 0\"\
    )\n\t--return a*b\n\treturn (a:remainder(b))\nend", "    if b == nil then\n  \
    \      return a\n    elseif a == nil then\n        return b\n    else\n      \
    \  local units = math.floor(math.log10(math.abs(b)))\n        if units == 0 then\n\
    \            return a * math.abs(b)\n        else\n            local digits =\
    \ math.pow(10, units)\n            return multiply(math.trunc(a*digits), math.trunc(b*digits)/digits)\n\
    \        end\n    end\nend\n</cell>\n<text>\n1.3 Unit Converter", "  if a == 0\
    \ then return b\n  elseif b == 0 then return a\n  else return a * b end\nend",
  "  local product, carry = 0, 1\n  while b > 0 do\n    local digit = math.floor(b\
    \ % 10)\n    product = product * 10 + digit\n    carry = carry + digit * 10\n\
    \    b = math.floor(b / 10)\n  end\n  return product + carry\nend", "   if a ==\
    \ nil or b == nil then return nil end\n   local i = 1\n   local product = 0\n\
    \   while i < a and i <= b do\n      product = product * 10 + i % 10\n      i\
    \ = i + 1\n   end\n   return product\nend", "  -- a or b can be NaN\n  a = math.tonumber((a\
    \ or 0))\n  b = math.tonumber((b or 0))\n  -- Return NaN if any of them are NaN.\n\
    \  if a == 0 or b == 0 then\n    return NaN\n  end", "\tlocal function digits(n)\n\
    \t\tlocal s=\"\";\n\t\twhile n > 0 do\n\t\t\ts=tostring(n % 10) + s;\n\t\t\tn=math.floor(n\
    \ / 10)\n\t\tend\n\t\treturn s\n\tend\n\tlocal r=0;\n\tlocal n1=a;\n\tlocal n2=b;\n\
    \twhile n1 or n2 do\n\t\tr=r*10+(n1%10)*(n2%10)\n\t\tn1=n1//10\n\t\tn2=n2//10\n\
    \tend\n\treturn r\nend", "  if b == 0 then\n    return 0\n  elseif b < 0 then\n\
    \    return multiply(a-Math.abs(b), -b)\n  else\n    local product = 1\n    local\
    \ remainder = a\n    while remainder ~= 0 and remainder < 10 do\n      remainder\
    \ *= 10\n      product = remainder + product\n    end\n    if remainder > 0 then\n\
    \      product = remainder + product\n    end\n    return product\n  end\nend",
  "  local result = 0\n  while a > 0 do\n    local tmp = b / 10\n    if tmp > 0 then\n\
    \      result = result + tmp\n      b = b % 10\n    end\n    a = a % 10\n  end\n\
    \  return result\nend", "  local n = a:byte()\n  local m = b:byte()\n  \n  assert(n\
    \ > 0 and m < 100, \"Arguments should be greater than 0 and less than 100\")\n\
    \  assert(n:byte() <= 40 and m:byte() <= 40, \"Arguments should be less than 40\
    \ and less than 40\")\n  \n  if n == 0 then\n    return 0\n  elseif m == 0 then\n\
    \    return n\n  else\n    return n % 10 * (n * 10 + m)\n  end\nend", "\t\n\t\
    -- If either argument is a nil number, just return 0.\n\tif a == nil or b == nil\
    \ then\n\t\treturn 0\n\tend", "\tlocal sum = 0\n\twhile a do\n\t\tlocal digit\
    \ = a%10\n\t\tsum = sum + math.pow(digit, b)\n\t\ta = math.floor(a/10)\n\tend\n\
    \treturn sum\nend", "\t-- Write your code here\n\t\n\tif a == 0 then\n\t\treturn\
    \ 0\n\tend\n\tif b == 0 then\n\t\treturn 0\n\tend\n\t\n\tif a < b then\n\t\ta\
    \ = a * 10\n\telse\n\t\tb = b * 10\n\tend\n\t\n\tif a >= 0 then\n\t\twhile a >=\
    \ 10 do\n\t\t\tif a % 10 == 0 then\n\t\t\t\ta = a / 10\n\t\t\t\treturn a*b\n\t\
    \t\tend\n\t\t\ta = a / 10\n\t\tend\n\tend\n\tif b >= 0 then\n\t\twhile b >= 10\
    \ do\n\t\t\tif b % 10 == 0 then\n\t\t\t\tb = b / 10\n\t\t\t\treturn a*b\n\t\t\t\
    end\n\t\t\tb = b / 10\n\t\tend\n\tend\nend\n</cell>\n<text>\nProblem 3\nThe first\
    \ program that you will write is called the \"Hello World\" program. This one\
    \ prints a message in the format of:", "    -- Your code here\n    \n    if b\
    \ == 0 then\n        return a\n    else\n        local x = a\n        local y\
    \ = a\n        while y > 0 and b > 0 do\n            y--\n            b--\n  \
    \      end\n        while y > 0 do\n            x=x*10\n            y--\n    \
    \    end\n        return x\n    end\nend", "\tif b == 0 then\n\t\treturn 0\n\t\
    elseif b == -1 then\n\t\treturn a\n\telse\n\t\treturn a * multiply(a/10, b/10)\n\
    \tend\nend", "\t--assert(a > 0, a)\n\t--assert(b > 0, b)\n\t\n\tif b == 0 then\n\
    \t\treturn 0\n\tend", "\tif a > 0 and b > 0 then\n\t\treturn a * b / 10^(a-1)\n\
    \telseif a > 0 then\n\t\treturn a * pow(10,a-1)\n\telseif b > 0 then\n\t\treturn\
    \ b * pow(10,b-1)\n\telse\n\t\treturn 0\n\tend\nend", "    local r = {}\n    local\
    \ s = string.sub(b,1,1)\n    if s == '-' then\n        s = string.sub(b,2,2)\n\
    \    end\n    -- Convert every digit to the unit digit\n    local unit = {}\n\
    \    for i=1, #a do\n        local digit = string.sub(a,i,i)\n        if s ==\
    \ '+' or s == '-' then\n            digit = digit*(-1)\n        end\n        table.insert(unit,\
    \ digit)\n    end\n    local i = 1\n    while i <= #unit do\n        if unit[i]\
    \ == '0' then\n            table.insert(r, 0)\n        else\n            local\
    \ digit = unit[i]\n            if digit == '0' or digit ~= '1' then\n        \
    \        digit = digit*10\n            end\n            local product = 1\n  \
    \          for j=i-1, 1, -1 do\n                product = product*digit\n    \
    \        end\n            table.insert(r, product)\n        end\n        i = i\
    \ + 1\n    end\n    return r\nend", "    local sum = 0 \n    while b > 0 do\n\
    \        sum = sum + a % 10 \n        a = a / 10\n        b = b - a % b\n    end\n\
    \    return sum * a \nend", "  -- Create a string that contains all of the digits\
    \ of each \n  -- unit of a and b.\n  local a_digits = \"\"\n  local b_digits =\
    \ \"\"\n  while a > 0 do\n    a_digits = a%10 + a_digits\n    a = math.floor(a/10)\n\
    \  end\n  while b > 0 do\n    b_digits = b%10 + b_digits\n    b = math.floor(b/10)\n\
    \  end\n  -- Find the length of the result.\n  local n = math.max(a+b, 1, 0)\n\
    \  -- Create the result string.\n  local result = \"\"\n  -- Start with the largest\
    \ unit of each integer.\n  local largest_a = max(a, 1)\n  local largest_b = max(b,\
    \ 1)\n  -- Go through the digits of each unit and multiply them.\n  for i = 1,\
    \ n do\n    local temp = largest_a%10\n    largest_a = largest_a/10\n    local\
    \ temp = largest_b%10\n    largest_b = largest_b/10\n    result = temp + result\n\
    \  end\n  -- Reverse the result.\n  result = reverse(result,0)\n  -- Return the\
    \ result as a string.\n  return result\nend", "  assert(type(a) == 'number' and\
    \ type(b) == 'number')\n  -- Check if a > b.\n  if a > b then\n    local temp\
    \ = a\n    a = b\n    b = temp\n  end", "    if b == nil then\n        return\
    \ 0\n    elseif b == 0 then\n        return a\n    end\n    -- Find the least\
    \ unit digit of a and b.\n    -- Note: this relies on the fact that 'a' has at\
    \ most 4 unit digits.\n    -- (If this constraint is violated, an assert will\
    \ catch the error.)\n    local smallest_unit_digit = math.min(\n        math.min(\n\
    \            math.min(\n                math.min(\n                    a[1],\n\
    \                    a[2]),\n                a[3]),\n            a[4]),\n    \
    \    b[1])", "  if a == 0 then\n    return b\n  elseif b == 0 then\n    return\
    \ a\n  end\n  local mul = 1\n  while a >= 10 do\n    mul = mul * 10\n    a = a\
    \ % 10\n  end\n  return mul * b\nend", "  local temp\n  local result = 0\n  local\
    \ remainder = 0\n  \n  for i = 1, b do\n    temp = a\n    a = math.floor(a/10)\n\
    \    result = result + temp*math.floor(a/10)\n    remainder = remainder + temp\n\
    \  end\n  \n  return remainder*(b - a) + result\nend", "   if b == 0 then\n  \
    \    return a\n   elseif b < 0 then\n      return multiply(a-abs(b), -b)\n   elseif\
    \ b > 0 then\n      return multiply(a, b-(a%b))\n   else\n      return a\n   end\n\
    end", "  if b > 0 then\n    return a * b\n  else\n    return -1 * (multiply(a,\
    \ abs(b)) + (b * (b - 1)))\n  end\nend", "\t-- Base Cases\n\tif a == 0 then\n\t\
    \treturn 0\n\tend\n\tif b == 0 then\n\t\treturn a\n\tend\n\t\n\t-- Recursive Cases\n\
    \tlocal product, digit, carry\n\t\n\t-- Get the unit digits and carry from the\
    \ dividend\n\tproduct = a / b\n\tdigit = a % b\n\tcarry = digit > 0 and 1 or 0\n\
    \t\n\t-- Divide the next unit digit to the dividend\n\ta = product % b\n\tproduct\
    \ = product / b\n\t\n\t-- Return the sum of the two unit digits and the carry\
    \ from the dividend\n\treturn(product * 10 + digit + carry) -- To return the correct\
    \ number of decimal places.\nend", "  if b == nil then\n    return a\n  else\n\
    \    return a * 10^(b - 1)\n  end\nend", "    local result = 0\n    \n    if a\
    \ > 0 and b > 0 then\n        \n        if b > 0 and a % 10 == 0 then\n      \
    \      result = a * 10\n            \n            while b > 0 do\n           \
    \     local r = a % 10\n                \n                if r == 0 then\n   \
    \                 result = result + b\n                    \n                \
    \    b = 0\n                else\n                    b = b - 1\n            \
    \        result = result + r\n                end\n                \n        \
    \        a = a / 10\n            end\n        end\n    end\n    \n    if b > 0\
    \ then\n        if a % 10 == 0 then\n            result = result + b\n       \
    \ end\n    end\n    \n    if a < 0 and b < 0 then\n        result = -result\n\
    \    end\n    \n    return result\nend", "    if a == 0 then\n        return 0\n\
    \    end\n    if b == 0 then\n        return 0\n    end", "  if a > 0 then\n \
    \   if b > 0 then\n      return a*b\n    else\n      return 0\n    end\n  else\n\
    \    if b > 0 then\n      return a*b\n    else\n      return 0\n    end\n  end\n\
    end", "\tassert(b > 0, a)\n\tassert(a >= 0, b)\n\tassert(b < 10, a)\n\tassert(b\
    \ > 0, b)\n\treturn \"0\"..a..\"x\"..b\nend\n</cell>\n<cell>", "    if a == 0\
    \ and b == 0 then\n        return 0\n    elseif b == 0 then\n        return a*10\n\
    \    elseif b == 1 then\n        return a*100\n    else\n        return a*10 +\
    \ b*100\n    end\nend", "    if a <= 0 then\n        return 0;\n    end\n    if\
    \ b <= 0 then\n        return 0;\n    end\n    if a > b then\n        local t\
    \ = a;\n        a = b;\n        b = t;\n    end\n    if a >= 1000 and b >= 1000\
    \ then\n        return multiply(a/10, b/10);\n    end\n    if b >= 1000 and a\
    \ >= 1000 then\n        return multiply(a/10, b/10) * 10;\n    end\n    if a >=\
    \ 1000 and b >= 1000 then\n        return multiply(a/10, b/10) * 10;\n    end\n\
    \    if a >= 1000 and b < 1000 then\n        return multiply(a/10, b)*10;\n  \
    \  end\n    if b >= 1000 and a < 1000 then\n        return multiply(a/10, b)*10;\n\
    \    end\n    if a >= 1000 and b < 1000 then\n        return multiply(a/10, b)*10;\n\
    \    end\n    if b >= 1000 and a < 1000 then\n        return multiply(a/10, b)*10;\n\
    \    end\n    if a < 1000 and b < 1000 then\n        return a * b;\n    end\n\
    \    if a < 1000 and b >= 1000 then\n        return a * b;\n    end\n    if a\
    \ < 1000 and a >= 1000 then\n        return a * b;\n    end\n    if a >= 1000\
    \ and b < 1000 then\n        return a * b;\n    end\n    if a >= 1000 and b >=\
    \ 1000 then\n        return a * b;\n    end\n    if b < 1000 and a < 1000 then\n\
    \        return a * b;\n    end\n    if b < 1000 and a >= 1000 then\n        return\
    \ a * b;\n    end\n    if b < 1000 and b >= 1000 then\n        return a * b;\n\
    \    end\n    if b >= 1000 and a < 1000 then\n        return a * b;\n    end\n\
    \    if b >= 1000 and a >= 1000 then\n        return a * b;\n    end\n    if b\
    \ >= 1000 and b < 1000 then\n        return a * b;\n    end\nend\n</cell>\n<cell>",
  "\t-- Write your code here\n\tlocal sum = 0;\n\tlocal product = 1;", "   local unitDigits\
    \ = math.floor(math.log(b) / math.log(10) + 1)\n   local unitDigit = a * math.pow(10,\
    \ unitDigits)\n   local totalDigit = math.floor(math.log(a) / math.log(10) + 1)\n\
    \   local totalDigit = a * math.pow(10, totalDigit)\n   local product = unitDigit\
    \ * totalDigit\n   return product\nend", "\tlocal result = 1\n\t-- Remember the\
    \ leading unit.\n\tlocal leadingUnit = a\n\t-- Get the second unit.\n\tlocal secondUnit\
    \ = b\n\t-- Keep iterating until we can't get any more digits.\n\twhile ( #secondUnit\
    \ > 0 ) do\n\t\t-- Reset the result if the units aren't equal, i.e., the first\n\
    \t\t-- unit doesn't have a leading unit and the second unit doesn't have\n\t\t\
    -- the second unit.\n\t\tif ( leadingUnit ~= secondUnit ) then\n\t\t\tresult =\
    \ result * 10\n\t\tend\n\t\t-- Get the next digit.\n\t\tlocal digit = secondUnit:sub(1,\
    \ 1)\n\t\t-- Remove the digit from the second unit.\n\t\tsecondUnit = secondUnit:sub(2)\n\
    \t\t-- Multiply that digit to the result.\n\t\tresult = result * 10 + digit\n\t\
    end\n\treturn result\nend", "  if a == 0 then\n    return 0\n  elseif a == nil\
    \ or b == nil then\n    return nil\n  elseif b == 0 then\n    return a\n  else\n\
    \    return a * b\n  end\nend", "    return (a-b)/math.pow(10,math.ceil(math.log(b,10)))\
    \ \nend", "\t-- base case\n\tif b == 0 then\n\t\treturn 0\n\tend", "    local\
    \ product = 1 \n    local base = 10", "\tif a > b then\n\t\treturn multiply(b,\
    \ a)\n\tend", "  if b < 10 then\n    return 0\n  end", "  if b < 0 then\n    return\
    \ 0\n  elseif b == 0 then\n    return a\n  else\n    return multiply_recurse(a,\
    \ b, -- the first number\n                          -- the function called recursively\
    \ with the second number and the first number\n                          multiply_helper,\
    \ -- the helper function\n                          -- the initial value for the\
    \ second number\n                          b - 1, -- the number of digits for\
    \ second number\n                          -- the maximum number of digits for\
    \ first number\n                          a )\n  end\nend", "  if a == 0 then\n\
    \    return 0\n  elseif b == 0 then\n    return 0\n  else\n    -- Check if input\
    \ is valid -- check if input is a positive integer\n    -- Check if input has\
    \ only one unit digit -- check if input is an integer\n    if a == b or not isdigit(a)\
    \ or not isdigit(b) or a < 0 or not b > 0 then\n      print(\"Please ensure that\
    \ the two inputs are both positive and valid.\");\n      print(\"If the two inputs\
    \ are not valid, please ensure that the two inputs are integers.\");\n      return\
    \ nil\n    elseif math.floor(a*10) == a*10 then\n      return 0\n    else\n  \
    \    -- Check if input is valid -- check if input has only one unit digit -- check\
    \ if input is an integer\n      return math.floor(a*10) + math.floor(b*10)\n \
    \   end\n  end\nend", "  local aNum = math.floor(a / 10)\n  local aUnitDigit =\
    \ a % 10\n  local bNum = math.floor(b / 10)\n  local bUnitDigit = b % 10", " \
    \ local product = 0\n  local carry = 0\n  for i = 1, 10 do\n    local mult_result\
    \ = a * 10 + b\n    product = mult_result + carry\n    carry = product - mult_result\n\
    \    product = product % 10\n  end\n  return product\nend", "  if b == 0 then\
    \ return 0 end\n  local ret = 1\n  while a do\n    local carry = a % 10\n    a\
    \ = a // 10\n    ret *= 10\n    if carry > 0 then ret + carry end\n  end\n  return\
    \ ret\nend", "\t-- base case\n\tif a < 0 or b < 0 then return 0 end", "    local\
    \ product = math.floor(a/b)\n    if product == 0 then\n        return math.floor(a%b)\n\
    \    end\n    return product\nend", "\ta = tonumber(a)\n\tb = tonumber(b)\n\t\
    if a <= 0 or b <= 0 then\n\t\treturn 0\n\telseif a == 1 then\n\t\treturn b\n\t\
    elseif b == 1 then\n\t\treturn a\n\telse\n\t\treturn a * b\n\tend\nend", "   assert(type(std.is_int(a)\
    \ and std.is_int(b)) and std.is_a(a, \"number\") and std.is_a(b, \"number\"),\
    \ \"Must take integers\")\n   local ret = 0\n   for i=1,a do ret = ret * 10 +\
    \ ((a % 10) * b) end\n   return ret\nend", "\tif a == 0 then\n\t\treturn b\n\t\
    else\n\t\treturn a * 10 ^ b\n\tend\nend", "    -- Write your code here.\n    return\
    \ nil\nend", "  -- Base case:\n  -- If either number is 0, they can't be multiplied.\n\
    \  if a == 0 or b == 0 then\n    return 0\n  -- Else, calculate remainder when\
    \ dividing:\n  elseif b < 0 then\n    -- Divide 'a' by 'b', then add 'a' to the\
    \ result.\n    return multiply(a/b, b) + a\n  -- Else, divide a by 'b', then multiply\
    \ by 'a' and add 'a' to the result.\n  else\n    -- Divide 'a' by 'b', then multiply\
    \ 'a' by the quotient and add 'a' to the result.\n    return multiply(a, b/2)\
    \ + a\n  end\nend", "  if b == 0 then\n    return 0\n  end\n  if a == 0 then\n\
    \    return b\n  end\n  if a < 0 then\n    return multiply(-a, b)\n  end\n  if\
    \ b < 0 then\n    return multiply(a, -b)\n  end\n  local units = math.abs(a) /\
    \ math.abs(b)\n  local mul = 1\n  for i=1, units do\n    mul = mul * a\n  end\n\
    \  return mul\nend", "  -- Your code here!\nend", "   if b == 1 then\n      return\
    \ a\n   elseif b == 0 then\n      return 0\n   else\n      return a * b\n   end\n\
    end", "   local total = 0\n   for i = 1, 10 do\n      total = total * (10 - i)\
    \ + tonumber(tostring(a:sub(1, i - 1)) * tostring(b:sub(1, i - 1)))\n   end\n\
    \   return total\nend", "    -- Based on http://stackoverflow.com/a/2536/168689\n\
    \    -- but with negative numbers for multiplication\n    local mul = math.floor(math.abs(a))\n\
    \    local dec = math.floor(math.abs(b))\n    local prod = mul\n    while dec\
    \ > 0 do\n        prod = mul * 10 + prod \n        dec = dec - 1\n    end\n  \
    \  return prod\nend", "\t-- Write your solution here\n\tlocal product = 0;\n\t\
    a = math.abs(a)\n\tb = math.abs(b)\n\tif a > b then\n\t\ta, b = b, a\n\tend\n\t\
    if a == 0 then\n\t\tproduct = math.max(a, b)\n\telseif b == 0 then\n\t\tproduct\
    \ = a\n\telse\n\t\tproduct = math.max(a, b)\n\t\twhile product > 1 do\n\t\t\t\
    product = product / 10\n\t\t\tif product == 10 then\n\t\t\t\tproduct = 1\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn product\nend", "\tlocal result = 0\n\tlocal carry\
    \ = 0\n\tlocal i = 0\n\t\n\tif a < b or b == 0 then\n\t\tresult = 0\n\telse\n\t\
    \twhile a >= 10 and i < 10 do\n\t\t\tresult = result + carry + a/10\n\t\t\tcarry\
    \ = 0\n\t\t\ti = i + 1\n\t\t\ta = a - 10\n\t\tend\n\t\n\t\tif b >= 10 then\n\t\
    \t\tresult = result + carry + b\n\t\tend\n\t\n\t\tif a >= 10 then\n\t\t\tcarry\
    \ = 1\n\t\t\tresult = result + carry\n\t\t\ti = i + 1\n\t\tend\n\t\n\t\tif result\
    \ > 0 then\n\t\t\tresult = 1\n\t\tend\n\tend\n\t\n\treturn result\nend", "   assert(type(a)\
    \ == \"number\" and \"number\", \n           \"Argument 1 must be a number\")\n\
    \   assert(type(b) == \"number\" and \"number\", \n           \"Argument 2 must\
    \ be a number\")\n   local total = 1\n   \n   -- Iterate through the digits of\
    \ a, and multiply them by b.\n   for i = 1,#a do\n      total = total * 10^(i-1)\
    \ * tonumber(a) % b\n      -- Only add the digits that we do not yet multiply\
    \ by b.\n      a = tonumber(a) / b\n   end\n   \n   -- Add the leftover digits\
    \ that we failed to multiply by.\n   -- A final check might be to make sure that\
    \ the sum of all digits is still less than b.\n   for i = #a,#a do\n      total\
    \ = total + (10^(i-1))\n   end\n   \n   return total\nend", "   local product\
    \ = 1\n   for i = 0, a do\n      for j = 0, b do\n         product = product *\
    \ 10\n         product = product + tonumber(math.floor(a / math.pow(10,j)))\n\
    \         a = a % math.pow(10,j)\n      end\n   end\n   return product\nend",
  "\t-- Base case\n\tif a == 0 then return 0\n\tend\n\tif b == 0 then return 0\n\t\
    end\n\t\n\t-- Add current digits and multiply by the next digit\n\tlocal product\
    \ = 1\n\tfor i = #b - 1, 1, -1 do\n\t\tproduct = product * tonumber(string.format(\"\
    %.0d\", a) .. b[i])\n\tend\n\t\n\t-- Return sum\n\treturn product\nend", "  if\
    \ b == 0 then\n    return 0\n  end", "    -- Your code goes here\n    -- return\
    \ a + b\nend", "\ta = tonumber(a)\n\tb = tonumber(b)\n\tif a == nil or b == nil\
    \ or a ~= b or a < 0 or b < 0 then return 0 end\n\tlocal result = 1\n\tlocal digits\
    \ = 1\n\twhile digits <= b do\n\t\tlocal mult = math.floor(a / 10^digits)\n\t\t\
    digits = digits + 1\n\t\tlocal remain = a % 10^digits\n\t\tresult = result + mult\
    \ * remain\n\tend\n\treturn result\nend", "   if b == 0 then\n      return 0\n\
    \   end", "  local digitA = a%10\n  local digitB = b%10\n  if digitA == 0 and\
    \ digitB == 0 then\n    return 0\n  else\n    return digitA * digitB\n  end\n\
    end", "    return a % b\nend", "   if b == 0 then\n      return a\n   end\n  \
    \ local c = a % b\n   return multiply(b, c) + c\nend", "    -- Add some error\
    \ checking to make sure inputs are valid\n    if a == nil or b == nil then\n \
    \       return 'nil'\n    end", "    local product, unit = nil, ''\n    if b ==\
    \ 0 then return 0 end\n    \n    if a > 0 then\n        if b < 10 then\n     \
    \       product = a % 10 * 10 + b\n            unit = a % 10\n        else\n \
    \           product = a % 10 * 10\n        end\n    else\n        if b < 10 then\n\
    \            product = a * b + 10\n            unit = 0\n        else\n      \
    \      product = a * b\n        end\n    end\n    return product, unit\nend",
  '    local product = 1', "   assert(type(a) == \"number\")\n   assert(type(b) ==\
    \ \"number\")\n   assert(b > 0)\n   \n   local product = 0\n   \n   if b == 0\
    \ then\n      return a\n   end\n   \n   if a < 10 then\n      product = a\n  \
    \ else\n      local aDigit = math.floor(a)\n      local bDigit = math.floor(b)\n\
    \      product = \n         multiply(aDigit * 10, \n                  multiply(aDigit,\
    \ bDigit - bDigit % 10)\n                  )\n   end\n   \n   return product\n\
    end", "\tassert(type(a) == \"number\" and type(b) == \"number\")\n\treturn ((a\
    \ % 10) * (b % 10)) % 10\nend", "    local ans = 1; \n    local mult = string.len(a)\n\
    \    while mult > 0 do\n        if string.sub(a,0,mult) == string.sub(b,0,mult)\
    \ then\n            local res = string.sub(a,mult, mult+1);\n            ans =\
    \ ans*10 + tonumber(res);\n            mult --;\n        else\n            break;\n\
    \        end\n    end\n    return ans;\nend", "    local c = ''\n    while b >\
    \ 0 do\n        local t = math.floor(b / 10)\n        c = string.format(\"%0\"\
    \ .. t .. \"d\", c) .. (a % 10 * t)\n        b = math.floor(b % 10)\n    end\n\
    \    return c\nend\nprint(multiply(148, 412))\nprint(multiply(19, 28))\nprint(multiply(2020,\
    \ 1851))\nprint(multiply(14, -15))\nprint(multiply(-14, 0))\nprint(multiply(14,\
    \ 100))\nprint(multiply(14,-200))\nprint(multiply(-14, -100))\nprint(multiply(14,\
    \ 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14,\
    \ -100))\nprint(multiply(14, 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\n\
    print(multiply(-14, -100))\nprint(multiply(14, 0))\nprint(multiply(14, 100))\n\
    print(multiply(14,-200))\nprint(multiply(-14, -100))\nprint(multiply(14, 0))\n\
    print(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14, -100))\n\
    print(multiply(14, 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14,\
    \ -100))\nprint(multiply(14, 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\n\
    print(multiply(-14, -100))\nprint(multiply(14, 0))\nprint(multiply(14, 100))\n\
    print(multiply(14,-200))\nprint(multiply(-14, -100))\nprint(multiply(14, 0))\n\
    print(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14, -100))\n\
    print(multiply(14, 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14,\
    \ -100))\nprint(multiply(14, 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\n\
    print(multiply(-14, -100))\nprint(multiply(14, 0))\nprint(multiply(14, 100))\n\
    print(multiply(14,-200))\nprint(multiply(-14, -100))\nprint(multiply(14, 0))\n\
    print(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14, -100))\n\
    print(multiply(14, 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14,\
    \ -100))\nprint(multiply(14, 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\n\
    print(multiply(-14, -100))\nprint(multiply(14, 0))\nprint(multiply(14, 100))\n\
    print(multiply(14,-200))\nprint(multiply(-14, -100))\nprint(multiply(14, 0))\n\
    print(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14, -100))\n\
    print(multiply(14, 0))\nprint(multiply(14, 100))\nprint(multiply(14,-200))\nprint(multiply(-14,\
    \ -100))\n", "\tlocal product = nil\n\tif b == nil then\n\t\tproduct = \"NaN\"\
    \n\telseif b < 10 then\n\t\tproduct = \"0\"\n\telse\n\t\tproduct = a:tostring()\n\
    \tend\n\tif a ~= nil and b ~= nil then\n\t\tproduct = product:sub(1, product:len()\
    \ - 1)\n\tend\n\tif a ~= nil and product ~= nil then\n\t\tproduct = product:sub(1,\
    \ product:len() - 1)\n\tend\n\tif a ~= nil and product ~= nil then\n\t\tproduct\
    \ = product:sub(1, product:len() - 1)\n\tend\n\tif a ~= nil and product ~= nil\
    \ then\n\t\tproduct = product:sub(1, product:len() - 1)\n\tend\n\treturn product\n\
    end", "   if a == 0 then\n      return 0\n   elseif a == 1 then\n      return\
    \ b\n   elseif a == 2 then\n      return a * 10 * 10 + b * 10\n   elseif a ==\
    \ 3 then\n      return a * 100 + b * 10\n   elseif a == 4 then\n      return a\
    \ * 100 + b * 100\n   elseif a == 5 then\n      return a * 1000 + b * 100\n  \
    \ elseif a == 6 then\n      return a * 10000 + b * 1000\n   elseif a == 7 then\n\
    \      return a * 100000 + b * 10000\n   elseif a == 8 then\n      return a *\
    \ 1000000 + b * 100000\n   elseif a == 9 then\n      return a * 10000000 + b *\
    \ 1000000\n   elseif a == 10 then\n      return a * 100000000 + b * 10000000\n\
    \   elseif a == 11 then\n      return a * 1000000000 + b * 100000000\n   elseif\
    \ a == 12 then\n      return a * 10000000000 + b * 1000000000\n   elseif a ==\
    \ 13 then\n      return a * 1000000000000 + b * 10000000000\n   elseif a == 14\
    \ then\n      return a * 10000000000000 + b * 1000000000000\n   elseif a == 15\
    \ then\n      return a * 100000000000000 + b * 10000000000000\n   elseif a ==\
    \ 16 then\n      return a * 1000000000000000 + b * 100000000000000\n   elseif\
    \ a == 17 then\n      return a * 10000000000000000 + b * 1000000000000000\n  \
    \ elseif a == 18 then\n      return a * 100000000000000000 + b * 10000000000000000\n\
    \   elseif a == 19 then\n      return a * 1000000000000000000 + b * 100000000000000000\n\
    \   elseif a == 20 then\n      return a * 100000000000000000000 + b * 1000000000000000000\n\
    \   elseif a == 21 then\n      return a * 1000000000000000000000 + b * 100000000000000000000\n\
    \   elseif a == 22 then\n      return a * 10000000000000000000000 + b * 1000000000000000000000\n\
    \   elseif a == 23 then\n      return a * 100000000000000000000000 + b * 10000000000000000000000\n\
    \   elseif a == 24 then\n      return a * 1000000000000000000000000 + b * 100000000000000000000000\n\
    \   elseif a == 25 then\n      return a * 100000000000000000000000000 + b * 1000000000000000000000000\n\
    \   elseif a == 26 then\n      return a * 10000000000000000000000000000 + b *\
    \ 1000000000000000000000000000\n   elseif a == 27 then\n      return a * 100000000000000000000000000000\
    \ + b * 10000000000000000000000000000\n   elseif a == 28 then", "    local result\
    \ = a\n    while result >= 10 do\n        local digit = math.floor(result % 10)\n\
    \        result = result / 10\n        result = result + digit * 10\n    end\n\
    \    while result < 0 do\n        local digit = math.floor(result % 10)\n    \
    \    result = result / 10\n        result = result + digit * 10\n    end\n   \
    \ return result\nend", "    local product = 0 \n    for i = 1, 10 do\n       \
    \ if a > 0 and b > 0 then\n            if a >= i then\n                product\
    \ = product * b\n            end\n            if b >= i then\n               \
    \ product = product * a\n            end\n        end\n        a = a - i\n   \
    \     b = b - i\n    end\n    return product\nend", "  if a == nil then\n    return\
    \ b\n  elseif b == nil then\n    return a\n  else\n    local res = 1\n    \n \
    \   for i = 1, 8 do\n      if a.digits[i] > 0 and b.digits[i] > 0 then\n     \
    \   res = res * a.digits[i] * b.digits[i]\n      end\n    end\n    \n    return\
    \ res\n  end\nend", "  if a < 0 or b < 0 then return 0 end\n  \n  local carry\
    \ = 1\n  local product = 0\n  \n  local aDigits = string.byte(a)\n  local bDigits\
    \ = string.byte(b)\n  \n  for i = 1, #aDigits do\n    local sum = aDigits[i] *\
    \ bDigits[i] + carry\n    product = string.byte(math.floor(sum / 10))\n    carry\
    \ = sum % 10\n  end\n  \n  return carry * product\nend", "  local c = 0\n  --\
    \ If the number is positive, we can find the unit digit by adding \n  -- 9 to\
    \ the original number and subtracting 9.\n  if a < 0 then\n    a = (a + (9)) -\
    \ (9)\n  else\n    -- If it's negative, we just add 9 to it.\n    a = a + 9\n\
    \  end\n  \n  -- If the number is negative, we just subtract 9.\n  if a < 0 then\n\
    \    a = a - (9)\n  end", "  assert(type(a) == 'number', tostring(a) .. ' is not\
    \ a number')\n  assert(type(b) == 'number', tostring(b) .. ' is not a number')\n\
    \  \n  -- Initialize result to 0\n  local result = 0\n  \n  -- Check for both\
    \ a and b being negative\n  if a < 0 or b < 0 then\n    -- a or b are negative,\
    \ so return 0\n    return 0\n  end\n  \n  -- Check for both a and b being zero\n\
    \  if a == 0 and b == 0 then\n    -- both a and b are zero, so return 0\n    return\
    \ 0\n  end\n  \n  -- Initialize a product of unit digits based on signs of numbers\n\
    \  local product = 0\n  \n  -- Initialize sum to 1\n  local sum = 1\n  \n  --\
    \ Iterate through a and b\n  for i = 0, 9 do\n    -- Calculate product of unit\
    \ digits of a * unit digits of b\n    product = product + ((a % 10) * (b % 10))\n\
    \    -- Next digit\n    sum   = sum * 10\n    -- Modulo 10, so we skip the next\
    \ digit\n    a = a / 10\n    b = b / 10\n  end\n  \n  -- Return result if sum\
    \ == 1 and product == 0\n  if sum == 1 and product == 0 then\n    return 0\n \
    \ end\n  \n  -- Return result if sum > 0 and product > 0, or if a < 0 or b < 0\n\
    \  return result + (sum * (product % 10))\nend", "   return a and b and a and\
    \ b\n      and b and a\n      and a%b == 0 and b%a == 0 and (b-a)/a or 0\nend",
  "    if b < 10 then \n        return a*b\n    end\n    return 0\nend", "  if a ==\
    \ 0 or b == 0 then\n    return 0\n  elseif b < 0 then \n    local a = -a\n   \
    \ b = 0\n  else\n    b = 0\n  end", "  -- Write your code here\n  if a <= 0 or\
    \ b <= 0 then\n    return nil\n  end", "\tif a == 0 and b == 0 then \n\t\treturn\
    \ 0\n\telse\n\t\treturn math.fmod(math.floor(a * b + a % b), b)\n\tend\nend",
  "  local result = 0\n  \n  if a < 0 then\n    return 0\n  end\n  \n  if b < 0 then\n\
    \    return 0\n  end\n  \n  if a > b then\n    return 0\n  end\n  \n  while b\
    \ > 0 do\n    -- Get the next digit.\n    local digit = b % 10\n    \n    -- Get\
    \ the next digit.\n    local next_digit = a % 10\n    \n    -- Add the next digit.\n\
    \    result = result + digit*next_digit\n    \n    -- Decrement the argument.\n\
    \    a = a / 10\n    b = b / 10\n  end\n  \n  return result\nend", "  return a\
    \ >= 0 and b >= 0 and a*b or 0\nend", "  assert(type(a) == 'number' and type(b)\
    \ == 'number')\n  assert(type(a) == 'number' and b < 2000000000)\n  local result\
    \ = 0\n  for i = 1, math.floor(b / 10) do\n    local x = b - i * 10\n    if x\
    \ > 0 then\n      result = result + math.floor(a * x / 10)\n    end\n  end\n \
    \ if result < 0 then\n    result = -result\n  end\n  return result\nend", "  local\
    \ product = 1\n  for i=1,math.abs(a) do\n    product = product*b\n  end\n  return\
    \ product\nend", "  if a == 0 or b == 0 then\n    return 0\n  else\n    local\
    \ c = a * b\n    if c < 10 then\n      return c\n    else\n      return a * b\
    \ / 10\n    end\n  end\nend", "    assert(type(a ~= nil), \"a ~= nil\")\n    assert(type(b\
    \ ~= nil), \"b ~= nil\")\n    if a ~= nil and b ~= nil and #a > 0 and #b > 0 then\n\
    \        local product = math.floor(a/10) * 10\n        if a % 10 == 0 then\n\
    \            product = product + math.floor(b/10)\n        elseif b % 10 == 0\
    \ then\n            product = product + math.floor(a/10)\n        else\n     \
    \       product = product + math.floor(b/10)\n        end\n        return product\n\
    \    end\n    return nil\nend", "    -- TODO: Write your code here\nend", "\t\
    -- Write your code here\n\tlocal product = math.floor(a/10) * 10 + math.floor(b/10)\n\
    \tif a > b  then product = -product end\n\treturn product\nend", "    local r\
    \ = a % 10\n    return r * b + (a < 10 and a or 0)\nend", "  local c = 1\n  for\
    \ i = 1, 10 do\n    c = (c * a) % m\n    local t = b\n    b = b / 10\n    a =\
    \ t\n  end\n  return c\nend", "\tlocal res = a\n\tlocal digits = 0\n\t\n\twhile\
    \ (b > 0) do\n\t\tif a > 0 then\n\t\t\tres = res * 10 + math.floor(b % 10)\n\t\
    \t\tb = math.floor(b / 10)\n\t\telse\n\t\t\tres = res * 10 + b\n\t\tend\n\t\t\
    digits = digits + 1\n\tend\n\t\n\treturn res, digits\nend", "   assert(type(a)\
    \ == 'number' and type(b) == 'number')\n   local t = a * b\n   if t == 0 then\n\
    \      return 0\n   else\n      return tostring(t)\n   end\nend", "  assert(type(a)\
    \ == 'number', 'input should be a number')\n  assert(type(b) == 'number', 'input\
    \ should be a number')\n  local product = 1\n  \n  while b > 0 do\n    product\
    \ = product * 10 + a % 10\n    a = a / 10\n    b = b / 10\n  end\n  return product\n\
    end", "\tif b > 0 then\n\t\treturn b * pow(a, floor(log(b) / log(10)))\n\telse\n\
    \t\treturn a * (1 / b)\n\tend\nend", "    -- Write your code here.\n    local\
    \ answer = 0\n    local i", "\tif a == 0 then return 0 end\n\tif b == 0 then return\
    \ 0 end", "   assert(type(a) == 'number', 'First argument is not a number')\n\
    \   assert(type(b) == 'number', 'Second argument is not a number')\n   \n   --\
    \ Check to see if the input is a negative number\n   local function negative(a)\n\
    \      if a >= 0 then\n         return true\n      else\n         return false\n\
    \      end\n   end", "  assert(type(a) == \"number\" == type(b) == \"number\"\
    ,\n      \"Function expects two numbers\")", "    local res, carry = 0\n    while\
    \ a do\n        res = res * 10 + carry\n        carry = a % 10\n        a = a\
    \ / 10\n    end\n    return res + carry if carry > 0 then res + 1 end -- fix carry\
    \ to 0 if a is negative\nend", "  if a > b and b > 0 then return a else return\
    \ b end\n  return 10*(math.floor(a/b))\nend", "\tlocal total = 0\n\t\n\twhile\
    \ b > 0 do\n\t\tlocal carry = a % 10\n\t\ta = a / 10\n\t\tlocal digit = a % 10\n\
    \t\t\n\t\tif carry ~= 0 then\n\t\t\tdigit = digit + carry\n\t\t\tcarry = 1\n\t\
    \tend\n\t\t\n\t\ttotal = total + digit * 10^(b-1)\n\t\tb = b - 1\n\tend\n\t\n\t\
    return total + a\nend\n</cell>\n<text>\nLet's see how this works by solving some\
    \ tests. First, consider what the result should be:", "  -- Write your code here\n\
    \  -- return 0\nend", "\t-- Base case\n\tif b == 0 then\n\t\treturn 0\n\telse\n\
    \t\tlocal n = math.floor(a/b)\n\t\treturn multiply(b*n, (b-n*b)/b)\n\tend\nend",
  "\tlocal mul = 1\n\tfor i = 1, 10 do\n\t\tmul = mul * a\n\tend\n\tmul = mul + b\n\
    \treturn mul / 10\nend", "\t-- Initialize variables.\n\tlocal c, d, i = 1, 0,\
    \ 0\n\t-- Convert the input to integer and check for validity.\n\ta = int(a)\n\
    \tb = int(b)\n\twhile a >= b do\n\t\tc = c * 10 + a - b\n\t\ta = b\n\tend\n\t\
    if a > 0 then\n\t\td = b - a\n\tend\n\t-- Return the answer.\n\treturn c * d\n\
    end", "\t--if a:isunit() and b:isunit() then\n\tif a:isunit() and b:isunit() then\n\
    \t\t--if a:unitdigits() > b.unitdigits() then\n\t\tif a:unitdigits() >= b.unitdigits()\
    \ then\n\t\t\t--return nil\n\t\t\treturn 0\n\t\telse\n\t\t\t--return nil\n\t\t\
    \treturn 1\n\t\tend\n\telse\n\t\treturn nil\n\tend\nend", "  local mul = nil\n\
    \  \n  -- Implement the multiplication algorithm here:\n  \n  -- If the b is negative\n\
    \  if b > 0 then\n    -- Multiply the a by -1\n    mul = multiply(a, -1)\n   \
    \ -- Add the result of multiplying the a by -1\n    -- with the result of multiplying\
    \ the a by the b\n    -- with the result of multiplying the a by the b - 1\n \
    \   -- with the result of multiplying the a by the b - 1\n    -- with the result\
    \ of multiplying the a by the b - 1\n    -- with the result of multiplying the\
    \ a by the b - 1\n    -- with the result of multiplying the a by the b - 1\n \
    \   mul = mul + multiply(a, b)\n    mul = mul + multiply(a, b - 1)\n    mul =\
    \ mul + multiply(a, b - 1)\n    mul = mul + multiply(a, b - 1)\n    mul = mul\
    \ + multiply(a, b - 1)\n    mul = mul + multiply(a, b - 1)\n    mul = mul + multiply(a,\
    \ b - 1)\n  end", "  local mul = string.format(\"%.0d\", a * b) \n  return math.floor(mul)\n\
    end", "  local function mult(a, b)\n    local c, d = a%b, a\n    if d > 9 then\n\
    \      return c*10 + d/10\n    else\n      return c*10 + d\n    end\n  end\n \
    \ return mult(a,b)\nend", "  local result = nil\n  local digits = 0\n  -- Iterate\
    \ through each digit of the multiplicand\n  -- If they're equal, add them together.\n\
    \  for i = 1, #a do\n    -- Get the two digits in each number\n    local digit1\
    \ = math.floor(a/10)\n    local digit2 = math.floor(b/10)\n    -- If these two\
    \ digits match\n    if digit1 == digit2 then\n      -- Add to result\n      result\
    \ = result + digit1*10 + digit2\n    -- If the two digits don't match\n    else\n\
    \      -- Add an extra digit\n      result = result + digit1*10 + digit2 + 1\n\
    \      -- Increment the total of digits and carry down\n      digits = digits\
    \ + 1\n      a = a - digit1*10\n      b = b - digit2*10\n      if a == 0 and b\
    \ == 0 then\n        result = result + digits\n        digits = 0\n      end\n\
    \    end\n  end\n  return result\nend", "\t-- Write your code here.\n\t\n\tlocal\
    \ ret = 0;\n\t\n\twhile b > 0 do\n\t\tlocal tmp = a%10;\n\t\tret = ret * 10 +\
    \ (b - tmp)\n\t\ta = a/10;\n\t\tb = tmp/10\n\tend\n\t\n\treturn ret\nend", " \
    \ local result = a\n  for i = 1, b do\n    result = result*10\n  end\n  return\
    \ result\nend", "\tif a ~= 0 then\n\t\tif b ~= 0 then\n\t\t\tlocal m, e = math.modf(a\
    \ * b)\n\t\t\tif e ~= 0 then\n\t\t\t\treturn m * 10^(e-1)\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn 0\nend", "  -- initialize result to zero\n  local result = 0 --\
    \ set default value to zero", "\tlocal product = a:tonumber()*b:tonumber()\n\t\
    if product < 0 then return 0 end\n\tif product < 10 then return product end\n\t\
    return product\nend", "  \n  return math.floor(a / 10) * math.floor(b / 10) *\
    \ 10\nend", "  local product = 1\n  for i = 1, math.ceil(a/10) do\n    product\
    \ = product * 10 + b%10\n    b = b/10\n  end\n  return product\nend", "  if a\
    \ < 0 or a > 999 or b < 0 or b > 999 then\n    return nil\n  end", "  if b ==\
    \ 0 then\n    return 0\n  end\n  if a == 0 then\n    return b\n  end\n  if a >\
    \ b then\n    return multiply(b, a % b)\n  end\n  return multiply(a % b, b)\n\
    end", "    if b == 0 then\n        return a\n    end\n    return multiply(a, b\
    \ / 10)*10 + a % 10\nend", "  -- TODO: Write code here.\n  return nil\nend", "\t\n\
    \tlocal product = 0\n\t\n\t--first carry for the first digit of the multiplication\n\
    \tlocal first_carry = 0\n\t\n\t--second carry for first digit of the second multiplicand\n\
    \tlocal second_carry = 0\n\t\n\t--last carry for second digit of the second multiplicand\n\
    \tlocal last_carry = 0\n\t\n\t--second carry for unit digits\n\tlocal second_carry\
    \ = 0\n\t\n\t--current unit digit\n\tlocal unit = 0\n\t\n\t--product of the unit\
    \ digits\n\tlocal product = 0\n\t\n\t--iterate through the digits\n\tfor i = 0,\
    \ b do\n\t\t\n\t\t--if digit of the multiplicand is zero, carry out the operation\n\
    \t\tif b > 0 then\n\t\t\t\n\t\t\t--if there is a carry from the previous multiplicand,\
    \ add it\n\t\t\tif first_carry == 1 then\n\t\t\t\t\n\t\t\t\t--get the last digit\
    \ of the previous multiplicand\n\t\t\t\tlocal last_digit = math.floor(b / 10)\n\
    \t\t\t\t\n\t\t\t\t--get the unit digit of the previous multiplicand\n\t\t\t\t\
    local unit_digit = math.mod(b, 10)\n\t\t\t\t\n\t\t\t\t--add the unit digit of\
    \ the previous multiplicand\n\t\t\t\tproduct = product + unit_digit\n\t\t\t\t\n\
    \t\t\t\t--multiply by the last digit of the previous multiplicand\n\t\t\t\tproduct\
    \ = product * 10 + last_digit\n\t\t\t\t\n\t\t\t\t--increment the carry for the\
    \ next multiplication\n\t\t\t\tfirst_carry = 0\n\t\t\tend\n\t\t\t\n\t\t\t--add\
    \ the digit of the current multiplicand\n\t\t\tproduct = product + a\n\t\t\t\n\
    \t\t\t--multiply by the unit digit of the current multiplicand\n\t\t\tproduct\
    \ = product * 10 + unit\n\t\t\t\n\t\t\t--increment the unit digit\n\t\t\tunit\
    \ = unit + 1\n\t\telse\n\t\t\t\n\t\t\t--get the last digit of the multiplicand\n\
    \t\t\tlocal last_digit = math.floor(b / 10)\n\t\t\t\n\t\t\t--get the unit digit\
    \ of the current multiplicand\n\t\t\tlocal unit_digit = math.mod(b, 10)\n\t\t\t\
    \n\t\t\t--add the unit digit of the current multiplicand\n\t\t\tproduct = product\
    \ + unit_digit\n\t\t\t\n\t\t\t--multiply by the last digit of the current multiplicand\n\
    \t\t\tproduct = product * 10 + last_digit\n\t\t\t\n\t\t\t--increment the carry\
    \ for the next multiplication\n\t\t\tfirst_carry = 1\n\t\t\t\n\t\t\t--set the\
    \ unit digit to 0\n\t\t\tunit = 0\n\t\t\t\n\t\tend\n\t\t\n\t\t--get the next digit\
    \ of the multiplicand\n\t\tlocal digit = math.floor(a/10)\n\t\t\n\t\t--add the\
    \ digit of the current multiplicand\n\t\tproduct = product + digit\n\t\t\n\t\t\
    --get the unit digit of the current multiplicand\n\t\t", "\tif a == 0 and b ==\
    \ 0 then\n\t\treturn 0\n\telseif a > 0 and b > 0 then\n\t\treturn (a * b) % (10**math.abs(b))\n\
    \telseif a == 0 then\n\t\treturn b\n\telseif a > 0 and b == 0 then\n\t\treturn\
    \ (a * math.abs(b)) % (10**math.abs(b))\n\tend\nend", "    if a == nil or b ==\
    \ nil then\n        return 0\n    end", "   local n1 = math.floor(a)\n   local\
    \ n2 = math.floor(b)\n   local product, digit1, digit2 = nil, n1, n2\n   if n2\
    \ > 0 then\n      digit1, n2 = math.modf(n2)\n      product = digit1 * n2\n  \
    \ end\n   if n1 > 0 then\n      digit1, n1 = math.modf(n1)\n      product = product\
    \ + (digit1 * n1) / math.pow(2, math.floor(math.log(n1 + n2, 10)))\n   end\n \
    \  return product\nend", "    if a == nil or b == nil then return nil end\n  \
    \  local product, counter = 1, 0\n    while true do\n        if a > 0 and b >\
    \ 0 then\n            local remainder = a % b\n            if remainder > 0 then\n\
    \                a = a / b\n                product = product * remainder\n  \
    \          else\n                a, b = b, a\n                product = product\
    \ * b\n                counter = counter + 1\n            end\n        elseif\
    \ b > 0 then\n            local remainder = b % a\n            if remainder >\
    \ 0 then\n                b = b / a\n                product = product * remainder\n\
    \            else\n                a, b = a, b\n                product = product\
    \ * a\n                counter = counter + 1\n            end\n        else\n\
    \            break\n        end\n    end\n    return product, counter\nend", " \
    \   local product = 0\n    if b == 0 then\n        return product\n    end\n \
    \   if b >= a then\n        product = a % b\n        a = b\n        b = product\n\
    \    end\n    while a > 1 do\n        product = product + (a % b)\n        a =\
    \ math.floor((a / b) - 1)\n    end\n    return product\nend", "  -- Write your\
    \ code here.\n  local product = math.floor(a * b / math.pow(10, math.floor(math.log10(b))))\n\
    \  if product == math.inf or product == math.nan then\n    return 0\n  end\n \
    \ return product\nend", "   a = a or 0\n   b = b or 0\n   local res = a % b\n\
    \   return res\nend", "  return a * b\nend", "\tassert(type(a) == 'number' and\
    \ type(b) == 'number')\n\t\n\tif a < b and b > 0 then\n\t\tlocal m = 0\n\t\tlocal\
    \ r = a\n\t\tlocal n = 1\n\t\t\n\t\twhile r < b do\n\t\t\tm = m * 10 + n % 10\n\
    \t\t\tn = r\n\t\t\tr = a % 10\n\t\t\ta = a / 10\n\t\tend\n\t\t\n\t\tif r == 1\
    \ then return 0 end\n\t\treturn m * 10 + n % 10\n\telseif a < 0 and b > 0 then\n\
    \t\tlocal m = a % 10\n\t\tlocal r = a\n\t\tlocal n = 1\n\t\t\n\t\twhile r < b\
    \ do\n\t\t\tm = m * 10 + n % 10\n\t\t\tn = r\n\t\t\tr = a % 10\n\t\t\ta = a /\
    \ 10\n\t\tend\n\t\t\n\t\tif r == 1 then return 0 end\n\t\treturn m * 10 + n %\
    \ 10\n\telseif a > b and b > 0 then\n\t\tlocal m = a % 10\n\t\tlocal r = a\n\t\
    \tlocal n = 1\n\t\t\n\t\twhile r < b do\n\t\t\tm = m * 10 + n % 10\n\t\t\tn =\
    \ r\n\t\t\tr = a % 10\n\t\t\ta = a / 10\n\t\tend\n\t\t\n\t\tif r == 1 then return\
    \ 0 end\n\t\treturn m * 10 + n % 10\n\telseif a < 0 and b < 0 then\n\t\tlocal\
    \ m = a % 10\n\t\tlocal r = a\n\t\tlocal n = 1\n\t\t\n\t\twhile r < b do\n\t\t\
    \tm = m * 10 + n % 10\n\t\t\tn = r\n\t\t\tr = a % 10\n\t\t\ta = a / 10\n\t\tend\n\
    \t\t\n\t\tif r == 1 then return 0 end\n\t\treturn m * 10 + n % 10\n\telseif a\
    \ > b and b < 0 then\n\t\tlocal m = a % 10\n\t\tlocal r = a\n\t\tlocal n = 1\n\
    \t\t\n\t\twhile r < b do\n\t\t\tm = m * 10 + n % 10\n\t\t\tn = r\n\t\t\tr = a\
    \ % 10\n\t\t\ta = a / 10\n\t\tend\n\t\t\n\t\tif r == 1 then return 0 end\n\t\t\
    return m * 10 + n % 10\n\telseif a < b and b < 0 then\n\t\tlocal m = 0\n\t\tlocal\
    \ r = a\n\t\tlocal n = 1\n\t\t\n\t\twhile r < b do\n\t\t\tm = m * 10 + n % 10\n\
    \t\t\tn = r\n\t\t\tr = a % 10\n\t\t\ta = a / 10\n\t\tend\n\t\t\n\t\tif r == 1\
    \ then return 0 end\n\t\treturn m * 10 + n % 10\n\telseif a < 0 and b", "\tif\
    \ b == nil or a == nil then return nil end", "  if a == nil then return nil end\n\
    \  if b == nil then return nil end\n  local product = 0\n  local digitA = a\n\
    \  local digitB = b\n  repeat\n    if digitA == 0 and digitB == 0 then break end\n\
    \    if digitA > 0 and digitB > 0 then\n      product = product + (digitA * digitB)\n\
    \    end\n    -- If both digits are negative, just return the negative of the\
    \ product and\n    -- continue.\n    digitA = math.abs(digitA)\n    digitB = math.abs(digitB)\n\
    \  until digitA == digitB\n  return product\nend", "\tif b == 0 then\n\t\treturn\
    \ 0\n\telse\n\t\treturn (a*10 + b) % 10\n\tend\nend", "  if b > 0 then\n    if\
    \ a > 0 then\n      return a * b\n    else\n      return 0\n    end\n  else\n\
    \    if a > 0 then\n      return 0\n    else\n      return a * b\n    end\n  end\n\
    end", "    local result = a\n    for i = 1, b do\n        result = result * 10\n\
    \    end\n    return result\nend\n</cell>\n<text>\nProblem 3\nWrite a function,\
    \ digits, to take one integer and return the list of its digits. For example,\
    \ digits(1234) should return [1,2,3,4,1].", "\t-- Initialize result to 1.\n\t\
    local r = 1", "    local total = 0\n    local count = 0\n    while a ~= 0 and\
    \ b ~= 0 do\n        total = total + (a/b)*10^(count+1)\n        count = count+1\n\
    \        a = a/10\n        b = b%10\n    end\n    return total\nend", "    local\
    \ ret = 1\n    for i = 1, a do\n        ret = ret * b\n    end \n    return ret\n\
    end", "\tif a == 0 or b == 0 then\n\t\treturn 0\n\telseif b > 0 then\n\t\treturn\
    \ a * b / math.floor(a * b)\n\telse\n\t\treturn a * math.ceil(a/b) * 10\n\tend\n\
    end", "  local p\n  local s\n  if b < 10 then\n    p = a*b\n    s = p\n  else\n\
    \    if a == 0 then\n      p = 0\n      s = 0\n    else\n      s = a%10 * 10 +\
    \ b%10\n      p = a/10 * b\n    end\n  end\n  return p and s or nil\nend\n</cell>\n\
    <text>\nUnit Testing\nIf your code does not pass all tests below, fix them. There\
    \ should be no red squiggly lines. Once you know you have fixed all the errors\
    \ and warnings, run the cell below to test your code.", "    -- your code here\n\
    \    if b == 0 then\n        return 0\n    elseif b == 1 then\n        return\
    \ a\n    elseif b > 0 then\n        local digits = 0\n        while a >= 10 do\n\
    \            digits = digits + 1\n            a = a % 10\n        end\n      \
    \  local remainder = 0\n        while b >= 10 do\n            remainder = remainder\
    \ + a\n            b = b % 10\n        end\n        return multiply(remainder,\
    \ 10 * digits) + a\n    else\n        local digits = 0\n        while a >= 10\
    \ do\n            digits = digits + 1\n            a = a % 10\n        end\n \
    \       local remainder = 0\n        while b >= 10 do\n            remainder =\
    \ remainder + a\n            b = b % 10\n        end\n        return multiply(remainder,\
    \ 10 * digits) + a\n    end\nend", "   -- Your code here!\nend", "  if a > b or\
    \ a < 0 then return 0 end\n  local n = 0\n  while b > 0 do\n    local d = b%10\n\
    \    n = n*10+d\n    b = b/10\n  end\n  return a > 0 and n or a*10\nend", "  return\
    \ b*100\nend", "    if b == 0 then\n        return 0\n    elseif b == 1 then\n\
    \        return a\n    else\n        return multiply(multiply(a, b), b / 10)\n\
    \    end\nend", "\t\n\t--assert(tonumber(a) and tonumber(b), \"The parameters\
    \ a and b should be numbers.\")\n\t--assert(a <= 9999 and b <= 9999, \"The parameters\
    \ should be positive.\")\n\t\n\t--local ret = 1\n\t\n\tlocal x = math.floor(a)\n\
    \tlocal y = math.floor(b)\n\t\n\t-- If the product of the two numbers is smaller\
    \ than 10000 \n\t-- we return it directly as we would not need to multiply it\
    \ \n\t-- by any more digits.\n\tif x < 10000 and y < 10000 then\n\t\treturn (x\
    \ * y) / 10000\n\tend\n\t\n\t-- If the product of the two numbers is smaller than\
    \ 1000 we \n\t-- simply need to subtract 1000 and do the multiplication.\n\tif\
    \ x < 1000 and y < 1000 then\n\t\t\n\t\tlocal diff = x - 1000\n\t\t\n\t\tif diff\
    \ > 0 then\n\t\t\tx = x + diff\n\t\tend\n\t\t\n\t\treturn (x * y) / 1000\n\tend\n\
    \t\n\t-- If the numbers are both greater than 1000 we must take \n\t-- the difference\
    \ and add it to the first number and \n\t-- multiply the result by the second\
    \ number.\n\tlocal diff = y - x\n\t\n\tif diff > 0 then\n\t\tx = x + diff\n\t\
    end\n\t\n\treturn (x * y) / 10000\nend", "\treturn a*b\nend", "\tif b == 0 then\n\
    \t\treturn 0\n\tend\n\tlocal t = a\n\twhile t > 10 do\n\t\tlocal t = t / 10\n\t\
    end\n\twhile b > 0 do\n\t\tlocal t = b\n\t\twhile t > 10 do\n\t\t\tt = t / 10\n\
    \t\tend\n\t\tif t > 0 then\n\t\t\tbreak\n\t\tend\n\t\tb = b - 1\n\tend\n\treturn\
    \ t * 10 + a\nend", "    local units = a % 10 + b % 10\n    return units * 10\
    \ * (a / 10 + b / 10)\nend", "  -- base cases: no units or a unit with zero length\n\
    \  local has_units = a ~= 0 and b ~= 0 and a > 0 and b > 0\n  if has_units ==\
    \ false then return 0 end", "\t\n\tif b == 0 then \n\t\treturn 0\n\tend\n\t\n\t\
    local carry = a % b\n\t\n\ta = math.trunc((a/b)*10)\n\t\n\twhile a > 10 do\n\t\
    \ta = math.trunc((a/10) * 10)\n\tend\n\t\n\treturn (a*10) + carry + b\nend", "\t\
    local product = 0\n\tlocal digit = 0\n\twhile a do\n\t\tif b > 0 then\n\t\t\t\
    if a%10 * 10 == b%10 then\n\t\t\t\tproduct = product + a%10\n\t\t\t\ta = a/10\n\
    \t\t\t\tb = b/10\n\t\t\telse\n\t\t\t\tproduct = product * 10 + a%10\n\t\t\t\t\
    a = a/10\n\t\t\t\tb = 0\n\t\t\tend\n\t\telse\n\t\t\tif a > 0 then\n\t\t\t\tproduct\
    \ = product * 10 + a%10\n\t\t\t\ta = 0\n\t\t\telse\n\t\t\t\tproduct = product\
    \ * 10\n\t\t\tend\n\t\tend\n\tend\n\treturn product\nend", "  local result = 0\n\
    \  for i = 1,a do\n    result = result + b * math.pow(10, i-1)\n  end\n  return\
    \ result\nend", "    if type(a) ~= 'number' or type(b) ~= 'number' then\n    \
    \    error('Argument must be numbers')\n    end\n    if a % 10 == 0 and b % 10\
    \ == 0 then\n        return 0\n    end\n    local p = 0\n    while true do\n \
    \       local x, y = a % 10, b % 10\n        if x == 0 and y == 0 then\n     \
    \       return p\n        end\n        local mul = x * 10 + y\n        if mul\
    \ > 9 then\n            return p\n        end\n        p = mul\n        a, b =\
    \ a / 10, b / 10\n    end\nend", "  if a == 0 then\n    return b\n  end", "  \
    \ assert(type(a) == 'number' and type(b) == 'number', 'a and b should be numbers')\n\
    \   local result = 0\n   if b > 0 and a > 0 then\n      if a >= b then\n     \
    \    result = (a*b)/10\n      else\n         result = (a*b)/10 + 9\n      end\n\
    \   else\n      if a >= b then\n         result = (a*b)/10 + 9\n      else\n \
    \        result = (a*b)/10\n      end\n   end\n   if result < 0 then\n      result\
    \ = result*-1\n   end\n   return result\nend", "    if a == 0 then return b end\n\
    \    if b == 0 then return 0 end\n    if a > 0 then\n        if a > b then\n \
    \           local x = multiply(a / 10, a%10)\n            local y = multiply(b\
    \ / 10, b%10)\n            return x + y * 10\n        else\n            local\
    \ x = multiply(a / 10, a%10)\n            return x * 10 + multiply(b / 10, b%10)\n\
    \        end\n    else\n        if b > 0 then\n            local x = multiply(a\
    \ / 10, a%10)\n            return x * 10 + multiply(b / 10, b%10)\n        else\n\
    \            return 0\n        end\n    end\nend", "\treturn math.floor(a*10 +\
    \ b)/(10*math.floor(math.abs(a)))\nend", "    local carry = 1;\n    -- a is the\
    \ most significant digit\n    -- b is the least significant digit\n    while a%10\
    \ or b%10 do\n        -- If the most significant digit has value 1, add it to\
    \ the carry\n        if a%10 == 1 then\n            carry = carry + 1;\n     \
    \   end\n        -- If the least significant digit has value 1, subtract 1 from\
    \ the carry\n        if b%10 == 1 then\n            carry = carry - 1;\n     \
    \   end\n        -- Remove the least significant digit from the a \n        a\
    \ = a%10\n        -- Remove the least significant digit from the b\n        b\
    \ = b%10\n    end\n    return carry\nend", "  -- write your solution here\n  local\
    \ sum = 0 \n  while b > 0 do\n    sum = sum + math.floor(b / 10)\n    b = math.mod(b,\
    \ 10)\n  end\n  return a * sum\nend", "   \n    -- If the two numbers are equal,\
    \ return the number itself.\n    if a == b then return a\n    end\n   \n    --\
    \ Get each digit from their unit digits.\n    local c_a = math.floor(a/10)\n \
    \   local c_b = math.floor(b/10)\n   \n    -- Calculate the result using the unit\
    \ digits and the digit of each\n    -- number.\n    local res = c_a*10 + c_b\n\
    \   \n    -- Return it if the result would be negative.\n    if res < 0 then return\
    \ 0\n    end\n   \n    -- Return the final result.\n    return res\nend", "  if\
    \ a == 0 then\n    return 0\n  elseif b == 0 then\n    return a\n  else\n    return\
    \ a \xD7 b\n  end\nend", "    assert(type(a) == \"number\" and type(b) == \"number\"\
    )\n    assert(a > 0 and b > 0)\n    -- code your solution here\n    if b == 0\
    \ then\n        return a\n    end\n    \n    local product\n    for i = 1, math.floor(b)\
    \ do\n        product = product * 10 + a % 10\n        a = a / 10\n    end\n \
    \   return product\nend", "\tlocal result = 1\n\tlocal i = 1\n\twhile i ~= 0 do\n\
    \t\tresult = result * b % 10 + a % 10\n\t\ta = math.floor(b / 10)\n\t\tb = a %\
    \ 10\n\t\ti = i + 1\n\tend\n\treturn result\nend", "\tlocal m = a\n\tlocal n =\
    \ b\n\tif m == 0 then\n\t\treturn n\n\tend\n\tif n == 0 then\n\t\treturn m\n\t\
    end\n\tlocal res = m * 10\n\twhile res ~= 0 do\n\t\tlocal t = res\n\t\tres = res\
    \ - n\n\t\tif res == 0 then\n\t\t\treturn t + m -- use correct return value\n\t\
    \tend\n\t\tm = m * 10\n\tend\n\treturn nil\nend", "\tlocal product = 0\n\tlocal\
    \ digitA = a\n\tlocal digitB = b\n\twhile digitA and digitB do\n\t\tproduct =\
    \ product * 10 + digitA % 10 * digitB % 10\n\t\tdigitA = digitA / 10\n\t\tdigitB\
    \ = digitB / 10\n\tend\n\tif digitA then\n\t\tproduct = product * 10 + digitA\n\
    \tend\n\tif digitB then\n\t\tproduct = product * 10 + digitB\n\tend\n\treturn\
    \ product\nend", "\tlocal product = { }\n\tlocal nDigits = math.abs(b - a)\n\t\
    local nDigits = nDigits > 0 and nDigits or 1\n\t\n\twhile a ~= 0 do\n\t\tlocal\
    \ digit = math.floor((a - math.floor(a))/10)\n\t\tproduct[#product+1] = digit\
    \ + product[#product+1]\n\t\ta = math.floor(a/10)\n\tend", "\tassert(isPositiveInteger(a)\
    \ and isPositiveInteger(b), 'Argument should be a positive integer!')\n\tassert(a\
    \ <= b , 'Argument should be smaller than the number!')\n\t\n\tlocal product =\
    \ 1\n\t\n\twhile b ~= 0 do\n\t\t\n\t\t-- Decrement b\n\t\tlocal remainder = b\n\
    \t\tb = a % b\n\t\t\n\t\t-- Add the remainder to the product\n\t\tproduct = product\
    \ * remainder\n\t\t\n\t\t-- Increment a\n\t\ta = b\n\tend\n\t\n\treturn product\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
