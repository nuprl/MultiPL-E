name: HumanEval_83_starts_one_ends
language: lua
prompt: "-- Given a positive integer n, return the count of the numbers of n-digit\n\
  -- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = starts_one_ends\n\
  \    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(2), 18)\n \
  \   lu.assertEquals(candidate(3), 180)\n    lu.assertEquals(candidate(4), 1800)\n\
  \    lu.assertEquals(candidate(5), 18000)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Return the count, or return 0 if n is 0.\n  return n == 0 or n\
    \ > 0 and (n % 10 == 0 or n % 10 == 1) or n % 10 == 2 or n % 10 == 3 or n % 10\
    \ == 4\nend", "    local count = 0\n    for i = 1, n do\n        if i % 100 ==\
    \ 1 then\n            if i % 10 == 1 then\n                count = count + 1\n\
    \            elseif i % 10 == 0 then\n                if i % 100 == 1 then\n \
    \                   count = count + 1\n                end\n            end\n\
    \        elseif i % 10 == 1 then\n            if i % 100 == 0 then\n         \
    \       count = count + 1\n            end\n        end\n    end\n    return count\n\
    end", "  if n < 10 then return 1 end\n  if n <= 100 then return n end\n  local\
    \ s = 0\n  while n >= 10 do\n    s, n = math.modf(n - math.floor(n / 10)) * 10,\
    \ s\n  end\n  return s\nend", "  local count = {}\n  local pos = 0\n  -- Iterate\
    \ over all digits in the input number.\n  for i=1, n do\n    local digit = n%10\n\
    \    -- If the digit is 1 or 0, increment the count.\n    if digit == 1 or digit\
    \ == 0 then\n      if pos > 0 then count[pos] = count[pos] + 1 end\n      pos\
    \ = 0\n    else\n      pos = pos + 1\n    end\n    -- Divide the input number\
    \ by 10.\n    n = math.floor(n/10)\n  end\n  return count\nend", "  if n == 1\
    \ then\n    return 0\n  end\n  local count = 0\n  for i = 1, n do\n    if i %\
    \ 10 == 1 or i % 10 == -1 + n then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "  if n == 0 then return 0 end\n  local function is_1_of_n(n)\n\
    \    local function ones_of(n)\n      local i, j = 1, n\n      repeat\n      \
    \  i = i + 1\n        if i < n then return i == j end\n        j = j + 1\n   \
    \   until j > n\n    end\n    local ones = ones_of(n)\n    return ones and is_1_of_n(n\
    \ - 1) or false\n  end\n  return is_1_of_n(n)\nend", "  if n == 0 then return\
    \ 0 end\n  if n < 0 then\n    error(\"count(): n must be non-negative.\")\n  end",
  "  local count = 0\n  for i = 1, math.floor(n*10+1) do\n    if i ~= n and i % 10\
    \ == 1 then\n      count = count + 1\n    end\n  end\n  return count\nend\n</cell>\n\
    <cell>\nprint(starts_one_ends(100))\nprint(starts_one_ends(1000))\nprint(starts_one_ends(10000))\n\
    print(starts_one_ends(10000))\nprint(starts_one_ends(20000))\nprint(starts_one_ends(2000000))\n\
    print(starts_one_ends(1000000000))\n</cell>\n<text>\nThe above function can be\
    \ written concisely, but the above function can be written more efficiently, and\
    \ in general, the following expression is a good approximation of n modulo 10:",
  "    if n == 0 then\n        return 0\n    end\n    return starts_one_ends(n-1)\
    \ + 1\nend", "  local i = 0\n  local total = 0\n  while i < n do\n    i = i +\
    \ 1\n    if i ~= n then\n      total = total + 1\n      if i ~= n - 1 then\n \
    \       if i % 2 == 1 then\n          total = total + 1\n        end\n      end\n\
    \    end\n  end\n  return total\nend", "  if n < 0 then return ends_one_ends(-n)\
    \ end\n  if n < 10 then return 0 end\n  local i = 2\n  local s = 0\n  while i\
    \ <= n do\n    if n % i == 0 then\n      if math.floor(n/i) == n then\n      \
    \  s = s + 1\n      end\n    end\n    i = i + 1\n  end\n  return s\nend", "  --\
    \ Return 1 if n is a one-digit number, or 0 if it is a zero-digit number.\n  if\
    \ n < 10 then\n    return 1\n  end", "   if n > 0 then\n      return 1 + starts_one_ends(math.floor(n/10))\n\
    \   elseif n < 0 then\n      return 1 + starts_one_ends(math.floor(-n/10))\n \
    \  else\n      return 0\n   end\nend", "  assert(n > 0 and n < 1e7)\n  local m\
    \ = math.floor(n)\n  if n < m then\n    return 1\n  else\n    return (m - n +\
    \ (n - m))\n  end\nend", "  local ndigits = math.ceil(math.log10(n))\n  local\
    \ count = 0\n  local nstart = math.floor(n/10)\n  local nend = math.floor(n/10\
    \ + 9)\n  for i = nstart, nend-1 do\n    if n <= 10*i then\n      count = count\
    \ + 1\n    end\n  end\n  return count, ndigits\nend", '  if n < 1 then return
    0 end', "    local count = 0\n    while n > 0 do\n        count = count + 1\n\
    \        n = n - 1\n    end\n    count = count + 1\n    return count\nend", " \
    \ if n == 0 then\n    return 1\n  end\n  if n == 1 then\n    return 0\n  end",
  "  return 1 + math.floor((math.log(n, 10) + math.log(n, 10^-n)) - math.log(n, 10^n))\n\
    end", "  local starts_one_ends = 0\n  local i = n\n  while i >= 1 do\n    i =\
    \ i / 10\n    starts_one_ends = starts_one_ends + 1\n  end\n  return starts_one_ends\n\
    end", "  assert(n > 1)\n  local ndigits = 1\n  local count = 1\n  while n > 0\
    \ do\n    count = count + n / ndigits\n    n = n % ndigits\n    ndigits = ndigits\
    \ + 1\n  end\n  return count\nend", "  if n == 0 then return 0 end\n  local one\
    \ = 0\n  for i = 1, n do\n    if i == 1 or n % i == 0 then one = one + 1 end\n\
    \  end\n  return one\nend", "  local count = {}\n  for i = 1, n do\n    table.insert(count,\
    \ math.floor((n-1) / i))\n    table.insert(count, 1)\n  end\n  return count\n\
    end", "  if n < 2 then\n    return 0\n  else\n    local s = math.floor(n)\n  \
    \  local e\n    if s - 1 ~= n then\n      e = s - 1\n    else\n      e = n\n \
    \   end\n    local count = 0\n    while s > 0 do\n      count = count + math.pow(10,\
    \ e - s)\n      if n ~= math.floor(math.pow(10, e - s)) then\n        return count\n\
    \      end\n      s = s - 1\n      e = e - 1\n    end\n    return count\n  end\n\
    end", "  assert(n > 0)\n  return -- (n*(n-1))/2\nend", "  if n == 0 then\n   \
    \ return 0\n  end\n  if n < 0 then\n    return error(\"negative number\", n)\n\
    \  end\n  local num_digits = math.floor(math.log10(n)) + 1\n  local count = 0\n\
    \  for i = 1, num_digits do\n    if n % 10 == 1 then\n      count = count + 1\n\
    \    end\n    n = n / 10\n  end\n  return count\nend", "  local function one_ends_loop(n)\n\
    \    if n == 1 then\n      return 1\n    elseif n == 2 then\n      return 1 +\
    \ one_ends_loop(n-1)\n    else\n      return one_ends_loop(n-1) + one_ends_loop(n-2)\n\
    \    end\n  end\n  return one_ends_loop(n)\nend", "  if n < 1 then return nil\
    \ end\n  local counts = {}\n  counts[1] = 1\n  for i = 2, n do\n    if counts[i\
    \ - 1] ~= 0 then counts[i - 1] += 1 end\n    if i == n then\n      if counts[n]\
    \ ~= 0 then counts[n] = 1 end\n    end\n  end\n  return counts\nend", "  if n\
    \ < 1 then\n    return 0\n  end\n  local count = 0\n  local i = 1\n  while i <=\
    \ n do\n    if i ~= n and i % n == 0 then\n      count = count + 1\n    end\n\
    \    i = i + 1\n  end\n  return count\nend", "  if n <= 1 then return 0 end\n\
    \  local digits = {}\n  digits[1] = 1\n  local i = 1\n  while i <= n do\n    digits[i]\
    \ = digits[i-1] + digits[i-1]\n    i = i * 10 + 1\n  end\n  return #digits[#digits]\n\
    end", "  local count = 0\n  while n ~= 0 do\n    if n == 1 then\n      count =\
    \ count + 1\n    else\n      if n == 1 then\n        n = n - 1\n      else\n \
    \       n = n/10\n      end\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "  local sum = 0\n  for i = 1, n do\n    if i ~= math.floor(i)\
    \ then\n      sum = sum + i - math.floor(i)\n    end\n  end\n  return sum\nend",
  "  local count = 0\n  for i = 1, n do\n    if i ~= 1 and i ~= n then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  -- The empty count is\
    \ zero and zero has one digit.\n  if n == 0 then\n    return 1\n  end", "  if\
    \ n < 0 then return ends_one_starts(-n) end\n  local count = 0\n  repeat\n   \
    \ if n <= 0 then return count end\n    local div, mod = div(n, 10)\n    if div\
    \ == 1 or mod > 0 then count = count + 1 end\n    n -- drop one digit\n  until\
    \ n == 0\n  return count\nend", "  if n < 0 then\n    return 0\n  else\n    local\
    \ num_1 = 1\n    local num_n = n\n    while num_n > num_1 do\n      local num_2\
    \ = math.floor((num_n * num_1) /\n                                (math.pow(2,\
    \ math.floor((num_n + 1) /\n                                                 num_n))))\n\
    \      num_n = num_n\n      num_1 = num_1 + num_2\n    end\n    return num_n -\
    \ num_1\n  end\nend", "    local function one_or_end(n)\n        -- Find all digits\
    \ that end with one.\n        local ones, ends = table.unpack(\n            string.gmatch(string.format(\"\
    %0d\", n), \"(..)($)\")\n        )\n        -- If the integer ends with one, then\
    \ all digits are there.\n        -- If the integer ends with zero, then there\
    \ are no more digits left.\n        return ends and #ones == 0\n    end\n    local\
    \ function count_digits(n)\n        return math.floor(math.log(n, 10) + 1)\n \
    \   end\n    local function n_digit(n)\n        return count_digits(n)\n    end\n\
    \    return table_sum(\n        map(\n            function() return starts_one_ends(n)\
    \ end,\n            filter((function(x) return x % 10 == 1 end), range(2, n +\
    \ 1)) -- Digits\n        )\n    )\nend", "  local sum = 0\n  local i = 1\n  while\
    \ i <= n do\n    if i ~= 1 and i mod 10 == 1 then\n      sum = sum + 1\n    end\n\
    \    i = i + 1\n  end\n  return sum\nend", "  if n > 0 then\n    local count =\
    \ 0\n    local i = 1\n    while i <= n do\n      if n % i == 0 then\n        count\
    \ = count + 1\n      elseif i == 1 then\n        if n /= i then\n          count\
    \ = count + 1\n        end\n      elseif i > n / i then\n        count = count\
    \ + 1\n      end\n      i = i + 1\n    end\n    return count\n  else\n    return\
    \ 0\n  end\nend", "  if n < 10 then\n    return 0\n  end", "  local count = 0\n\
    \  for i = 1, n do\n    if tostring(i:sub(1, 1)) == \"1\" then\n      count =\
    \ count + 1\n    end\n  end\n  return count\nend", "  if n < 10 then\n    return\
    \ 0\n  end\n  local count = 1\n  while n ~= 1 do\n    if n ~= math.floor(n) then\n\
    \      count = count + 1\n    end\n    n = math.floor(n)\n  end\n  return count\n\
    end", "  if n == 0 then\n    return 0\n  elseif n <= 1 then\n    return 1\n  else\n\
    \    return starts_one_ends(n - 1) + ends_one_starts(n - 1)\n  end\nend", "  if\
    \ n < 0 then\n    -- If the input is a negative number, there is no 1 to count.\n\
    \    return 0\n  elseif n < 10 then\n    -- If the input is a 10-digit number,\
    \ there is only 1 1 to count.\n    return 1\n  else\n    -- If the input is greater\
    \ than 10, there are two to count.\n    return 2\n  end\nend", "    if n < 10\
    \ then return 0 end\n    local s = math.floor(n/10)\n    local e = math.floor(n-(s*10))\n\
    \    if e > 9 then return ends_one_ends(s) end\n    return s + 1 + ends_one_ends(e)\n\
    end", "  if n == 0 then\n    return 1\n  elseif n < 0 then\n    return starts_one_ends(-n)\
    \ + 1\n  end\n  if n <= 9 then\n    return 1\n  end", "   if n < 10 then return\
    \ 1 end\n   if n < 100 then return 1 end\n   if n < 1000 then return 2 end\n \
    \  if n < 10000 then return 3 end\n   if n < 100000 then return 4 end\n   if n\
    \ < 1000000 then return 5 end\n   if n < 10000000 then return 6 end\n   if n <\
    \ 100000000 then return 7 end\n   if n < 1000000000 then return 8 end\n   if n\
    \ < 10000000000 then return 9 end\n   if n < 100000000000 then return 10 end\n\
    \   return nil\nend", "  -- If n is 0, return 0.\n  if n == 0 then\n    return\
    \ 0\n  end", "  if n == 1 then return ends end\n  local count = 0\n  for i = 1,\
    \ n do\n    if i%10 == 1 then count = count + 1\n    if i%10 == 2 then count =\
    \ count + ends\n  end\n  return count\nend", "  if n < 1 then return 0 end\n \
    \ local count = 0\n  for i = 1, n do\n    if i % 10 == 1 then\n      if i == 1\
    \ or i % 10 == 7 then\n        count = count + 1\n      else\n        count =\
    \ count + 1\n      end\n    elseif i % 10 == 0 then\n      count = count + 1\n\
    \    end\n  end\n  return count\nend", "  if n == 0 then\n    return 0\n  end\n\
    \  if n < 10 then\n    return 0\n  end\n  local digits = math.floor(math.log10(n))\
    \ + 1\n  local is_start = 1\n  local num_starts = 0\n  for i = 1, digits do\n\
    \    local digit = n % 10\n    if digit == 0 then\n      break\n    end\n    if\
    \ digit == 1 then\n      is_start = is_start * -1\n      num_starts = num_starts\
    \ + 1\n    end\n    n = n / 10\n  end\n  return num_starts\nend", "\tlocal count\
    \ = 0\n\tfor i = 1, n do\n\t\tif i ~= n and i % 10 == 1 then\n\t\t\tcount = count\
    \ + 1\n\t\tend\n\tend\n\treturn count\nend", "  if n <= 0 then return 0 end\n\
    \  local count = 1\n  local digit = math.floor(math.log(n, 10))\n  while n ~=\
    \ 0 and digit > 0 do\n    n = n / 10\n    count = count + 1\n    digit = digit\
    \ - 1\n  end\n  return count\nend", "  local count = 0\n  local n1 = math.floor(n)\n\
    \  local n2 = math.floor(n * 10) % 10", "  if n < 1 then return 0 end\n  local\
    \ count = 1\n  for i = 1, n do\n    if i ~= 1 then count = count + 1 end\n  end\n\
    \  return count\nend", "  if n < 0 then\n    return 0\n  end\n  local count =\
    \ 0\n  for i = 1, n do\n    if i ~= 1 and i ~= n - 1 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  local count = 0\n  for i=1,n do\n\
    \    if i ~= 1 and i ^ n == 0 then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "   assert(n >= 0, \"Negative inputs\")\n   -- Use binomial\
    \ coefficient to compute the number of ways of starting\n   -- and ending with\
    \ 1, the n-digit numbers that start with 1.\n   local function binomial_coeff(n,\
    \ k)\n      assert(n >= k)\n      return math.factorial(n) ~= math.factorial(k)\
    \ * math.factorial(n - k)\n   end", "  if n < 0 then\n    return nil\n  end",
  "    if n == 0 then\n        return 0\n    end\n    local ones, starts, ends = {},\
    \ 0, 1\n    while n >= 0 do\n        ones[ends] = ones[ends] + 1\n        if starts\
    \ == 0 and ends == 1 then\n            ones[ends] = ones[ends] - 1\n        end\n\
    \        -- This is how we decrement ends, because it can overflow.\n        --\n\
    \        -- We can't do `ends = ends - 1` in Lua because `ends` is a\n       \
    \ -- function, and a function can't be decremented (only integer can).\n     \
    \   ends = ends - 1\n        n = n - ends\n    end\n    return #ones\nend", " \
    \ local function one(i)\n    return n >= i and math.floor(n/i) == 1 or false\n\
    \  end\n  local function two(i)\n    return n >= i and math.floor(n/i/2.0) ==\
    \ math.floor(n/i/2.0) or false\n  end\n  local function three(i)\n    return n\
    \ >= i and math.floor(n/i/3.0) == math.floor(n/i/3.0) or false\n  end\n  local\
    \ function four(i)\n    return n >= i and math.floor(n/i/4.0) == math.floor(n/i/4.0)\
    \ or false\n  end\n  local function five(i)\n    return n >= i and math.floor(n/i/5.0)\
    \ == math.floor(n/i/5.0) or false\n  end\n  local function six(i)\n    return\
    \ n >= i and math.floor(n/i/6.0) == math.floor(n/i/6.0) or false\n  end\n  local\
    \ function seven(i)\n    return n >= i and math.floor(n/i/7.0) == math.floor(n/i/7.0)\
    \ or false\n  end\n  local function eight(i)\n    return n >= i and math.floor(n/i/8.0)\
    \ == math.floor(n/i/8.0) or false\n  end\n  local function nine(i)\n    return\
    \ n >= i and math.floor(n/i/9.0) == math.floor(n/i/9.0) or false\n  end\n  local\
    \ function ten(i)\n    return n >= i and math.floor(n/i/10.0) == math.floor(n/i/10.0)\
    \ or false\n  end\n  local function eleven(i)\n    return n >= i and math.floor(n/i/11.0)\
    \ == math.floor(n/i/11.0) or false\n  end\n  local function twelve(i)\n    return\
    \ n >= i and math.floor(n/i/12.0) == math.floor(n/i/12.0) or false\n  end\n  local\
    \ function thirteen(i)\n    return n >= i and math.floor(n/i/13.0) == math.floor(n/i/13.0)\
    \ or false\n  end\n  local function fourteen(i)\n    return n >= i and math.floor(n/i/14.0)\
    \ == math.floor(n/i/14.0) or false\n  end\n  local function fifteen(i)\n    return\
    \ n >= i and math.floor(n/i/15.0) == math.floor(n/i/15.0) or false\n  end\n  local\
    \ function sixteen(i)\n    return n >= i and math.floor(n/i/16.0) == math.floor(n/i/16.0)\
    \ or false\n  end\n  local function seventeen(i)\n    return n >= i and math.floor(n/i/17.0)\
    \ == math.floor(n/i/17.0) or false\n  end\n  local function eighteen(i)\n    return\
    \ n >= i and math.", "  if n < 1 then return 0 end\n  local count = 0\n  local\
    \ i = n\n  while i ~= 1 do\n    i = i / 10\n    count = count + 1\n  end\n  return\
    \ count\nend", "  -- The first part of the problem can be solved by\n  -- calculating\
    \ the number of positive integer that start with 1.\n  -- The second part can\
    \ be solved by finding out the number of positive\n  -- integer that end with\
    \ 1.\n  -- The difference between these two parts can be used to calculate the\n\
    \  -- number of digits that end in a 1 by subtracting the second part from\n \
    \ -- the first part.\n  local starts_one_ends = n - 1\n  local ends_with_one =\
    \ math.ceil(n / 10)\n  starts_one_ends = starts_one_ends + ends_with_one\n  return\
    \ ends_with_one\nend", "  if n < 10 then return 0 end\n  local total = 0\n  local\
    \ i = 1\n  for i = 1, n do\n    if i ~= n and i ~= 1 then\n      total = total\
    \ + 1\n    end\n    if i == 1 then\n      if n ~= 1 then\n        total = total\
    \ + 1\n      end\n    end\n    if i == n then\n      if n ~= 1 then\n        total\
    \ = total + 1\n      end\n    end\n    if i == n and n ~= 1 then\n      total\
    \ = total + 1\n    end\n  end\n  return total\nend", "  local count = 0\n  for\
    \ i = 1, n do\n    if i ~= 1 then count = count + 1 end\n    if i % 10 == 1 then\
    \ count = count + 1 end\n    if i % 10 == 0 then\n      if i % 100 == 0 then\n\
    \        if i % 1000 == 0 then\n          count = count + 1\n        elseif i\
    \ % 100 == 1 then\n          count = count + 1\n        else\n          count\
    \ = count + 1\n        end\n      elseif i % 1000 == 1 then\n        count = count\
    \ + 1\n      elseif i % 1000 == 0 then\n        count = count + 1\n      else\n\
    \        count = count + 1\n      end\n    end\n  end\n  return count\nend", "\t\
    local count = 0\n\tfor i = 2, n do\n\t\tif n % i == 0 then\n\t\t\tcount = count\
    \ + 1\n\t\tend\n\tend\n\treturn count\nend", "    local count = 0\n    for i =\
    \ 1, n do\n        if i == 1 then\n            if n % i == 0 then\n          \
    \      count = count + 1\n            end\n        else\n            if n % i\
    \ == 1 then\n                count = count + 1\n            end\n        end\n\
    \    end\n    return count\nend\n</cell>\n<cell>\nassert(starts_one_ends(12) ==\
    \ 5)\nassert(starts_one_ends(6) == 2)\nassert(starts_one_ends(7) == 3)\nassert(starts_one_ends(8)\
    \ == 2)\nassert(starts_one_ends(9) == 2)\nassert(starts_one_ends(10) == 2)\nassert(starts_one_ends(15)\
    \ == 2)\nassert(starts_one_ends(18) == 3)\nassert(starts_one_ends(21) == 3)\n\
    assert(starts_one_ends(22) == 3)\nassert(starts_one_ends(29) == 5)\nassert(starts_one_ends(30)\
    \ == 5)\nassert(starts_one_ends(35) == 5)\nassert(starts_one_ends(39) == 4)\n\
    </cell>\n<cell>", "  local num = 0\n  while n > 1 do\n    num = num + 1\n    n\
    \ = math.floor(n/10)\n  end\n  return num\nend", "    local count = 0\n    for\
    \ i = 1, n do\n        if i ~= 1 then\n            if i % 10 == 0 then\n     \
    \           count = count + 1\n            end\n        end\n    end\n    return\
    \ count\nend\n</cell>\n<cell>\nprint(starts_one_ends(100))\nprint(starts_one_ends(101))\n\
    print(starts_one_ends(153))\n</cell>\n<text>\nQuestion 2.6 (4 points): Using recursion,\
    \ implement the function count_starts_one_ends(n) that returns a count of the\
    \ numbers of n-digit positive integers that start or end with 1.", "  if n <=\
    \ 0 then return 0 end\n  local count = 0\n  while n ~= 1 do\n    count = count\
    \ + 1\n    n = math.floor(n/10)\n  end\n  return count\nend", "  if n < 1 then\
    \ return 0 end\n  local ones = n - 1\n  local digits = 1\n  local result = 1\n\
    \  for i = 2, n do\n    while digits < one do\n      digits *= 10\n      digits\
    \ -= 1\n    end\n    digits += 1\n    result = result + digits\n  end\n  return\
    \ result\nend", "  if n == 0 then return 0 end\n  local ndigits = math.floor(n)\n\
    \  -- Compute ndigits - 1 digits to the left of n\n  -- Add ndigits - 1 digits\
    \ to the right of n\n  local i = 1\n  while i <= ndigits - 1 and i ~= 0 do\n \
    \   if n % i == 1 then\n      return i\n    end\n    i = i + 1\n  end\n  -- If\
    \ i is greater than ndigits, it means n is less than or equal to ndigits.\n  return\
    \ ndigits\nend", "  local count = {}\n  for i = 1,n do\n    local j = i - 1\n\
    \    local digit = j - 1\n    count[j] = count[j] + 1 if (i ~= j) and (digit:sub(digit,1)\
    \ == 1) end\n  end\n  return count\nend", "  if n < 1 then\n    return 0\n  end\n\
    \  local ndigits = math.ceil(math.log10(n))\n  return math.floor(n/10**ndigits)\
    \ - math.floor(n/10**(ndigits+1))\nend", "  if n > 9 then return ends_one_starts(n)\
    \ end\n  local num_ones = 0\n  for i = (n - 1); i >= 1; i = i - n do num_ones\
    \ = num_ones + 1 end\n  return num_ones\nend", "  if n <= 0 then return 0 end\n\
    \  local count = 1\n  for i = 2, n do\n    if i ^ i == 1 then count = count +\
    \ 1 end\n  end\n  return count\nend", "  if n == 1 then return 1 end\n  if n <\
    \ 0 then return 0 end\n  local count = 0\n  while n ~= 0 do\n    count = count\
    \ + 1\n    local temp = math.floor(n/10)\n    if temp == 1 then\n      n = math.mod(n,\
    \ 10)\n      if n == 1 then return count + 1\n      else return count + 1 end\n\
    \    end\n    count = count + 1\n    n = temp\n  end\nend\n</cell>\n<text>\nTest",
  "  if n == 1 then\n    return 1\n  end", "  if n == 1 then\n    return 0\n  elseif\
    \ n == 2 then\n    return 1\n  else\n    return 1 + starts_one_ends(math.floor(n/2))\n\
    \  end\nend", "  if n < 1 then return 0 end\n  if n == 1 then return 1 end\n \
    \ local one = 0\n  local i = 0\n  while i < n do\n    i = i + 1\n    if i % 2\
    \ == 0 then\n      one = one + 1\n      if i == n then\n        return one\n \
    \     end\n    end\n  end\n  return 0\nend", "  if n <= 0 then return 0 end\n\
    \  local num = 1\n  local max = 1\n  while num < n do\n    if num == max then\
    \ return num + 1 end\n    max = math.max(max, num)\n    num = num * 10 + 1\n \
    \ end\n  return max\nend", "   -- If n < 10, the answer is trivial.\n   if n <\
    \ 10 then\n      return 0\n   end\n   -- For all n > 10, find how many n-digit\
    \ numbers of the form n000, n001, ...\n   -- that start or end with 1.\n   local\
    \ function count(n)\n      if n < 10 then\n         return 0\n      end\n    \
    \  if n % 10 == 0 and n > 1 then\n         return 1 + count(n / 10)\n      else\n\
    \         return count(n / 10) + 1\n      end\n   end\n   return count(n)\nend",
  "  -- Start with n = 1\n  local count = 0\n  while n >= 10 do\n    -- If the remainder\
    \ of n / 10 is greater than 1 then\n    if math.fmod(n, 10) > 1 then\n      --\
    \ Add one to the count\n      count = count + 1\n    end\n    -- Divide n by 10\n\
    \    n = math.floor(n/10)\n  end\n  -- Now n is less than 10 and we count the\
    \ number ending with 1\n  if n > 10 then\n    -- Add one to the count\n    count\
    \ = count + 1\n  end\n  -- Return the count\n  return count\nend", '  assert(n
    > 0)', "  local count = 0\n  local k = 1\n  local m = math.floor(n/10)\n  for\
    \ i = 1, m do\n    if n % k == 0 then\n      count = count + 1\n    end\n    k\
    \ = k + 1\n  end\n  return count\nend", "    if n == 1 then\n        return 1\n\
    \    end\n    return 1 + starts_one_ends(math.floor(n/10)) + (n % 10 == 1)\nend",
  "\tlocal count = 0\n\twhile n >= 10 do\n\t\tn = math.floor(n/10)\n\t\tcount = count\
    \ + 1\n\tend\n\treturn count\nend", "   if n < 1 then return 0 end\n   local n1\
    \ = math.floor(math.log(n,10))\n   if n1 == 0 then return 1 end\n   local n2 =\
    \ n - n1\n   return starts_one_ends(n1) + n2\nend", "  -- We have to start by\
    \ seeing if there's a 1-digit integer.\n  --\n  -- Note: this would work for a\
    \ lot of cases, but fails for\n  -- some cases: e.g. 101, 121, 111, 111010, 1010.\n\
    \  if n <= 1 then\n    return 0\n  end", "  -- This code is a bit messy, and it's\
    \ probably the most convoluted code\n  -- out there. Sorry.\n  if n >= 10 then\
    \ return 1 end\n  local count = 0\n  -- We're going to work by counting how many\
    \ numbers of n-digit\n  -- positive integers end with 1.\n  local function ends_one_count(n)\n\
    \    if n <= 0 then return 0 end\n    local count = 0\n    local i = 1\n    local\
    \ digits = math.ceil(n/10)\n    local digit\n    while i <= digits do\n      digit\
    \ = math.mod(i, 10)\n      if digit == 1 then count = count + 1 end\n      i =\
    \ i + 1\n    end\n    return count\n  end\n  -- The same for starting ones, except\
    \ that the count starts\n  -- at 1, not 0.\n  local function starts_one_count(n)\n\
    \    if n <= 0 then return 0 end\n    local count = 0\n    local i = 1\n    local\
    \ digits = math.ceil(n/10)\n    local digit\n    while i <= digits do\n      digit\
    \ = math.mod(i, 10)\n      if digit == 1 then count = count + 1 end\n      i =\
    \ i + 1\n    end\n    return count + 1\n  end\n  -- Now, we do the actual counting.\n\
    \  while n > 0 do\n    count = count + ends_one_count(n)\n    n = n - 1\n  end\n\
    \  -- This may happen when the number is odd.\n  if count == 0 then count = starts_one_count(n)\
    \ end\n  return count\nend", "  local count = 0\n  for _ = 1, n do\n    if i %\
    \ 10 == 1 then\n      count = count + 1\n      if i ~= math.floor(i) then\n  \
    \      if math.fmod(i, 10) == 0 then\n          count = count + 1\n        end\n\
    \      end\n    end\n    i = math.floor(i/10)\n  end\n  return count\nend", " \
    \ local count = 0\n  for i=1,n do\n    if number_to_bits(i) == 1 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  if n <= 0 then return\
    \ 0 end\n  local count = 0\n  for i=1,n do\n    if n % i == 0 then\n      if i\
    \ == 1 or n % i == n then\n        count = count + 1\n      end\n    end\n  end\n\
    \  return count\nend", "  if n < 1 then return 0 end\n  if n > math.floor(n) then\
    \ return 0 end\n  local count = 0\n  while n > 0 do\n    count = count + 1\n \
    \   local n1 = math.floor(n)\n    if n1 == 1 then break end\n    local n2 = math.floor(n/10)\n\
    \    if n2 == 1 then break end\n    if n2 < n1 then\n      if n % 10 ~= 1 then\
    \ break end\n    elseif n1 < n2 then\n      if n % 10 == 1 then break end\n  \
    \  end\n    n = math.floor(n/10)\n  end\n  return count\nend", "  local count\
    \ = 0\n  for i=1,n do -- count the numbers of n digits starting with 1\n    count\
    \ = count+n >= i and n or nil\n  end\n  return count\nend", "  -- This function\
    \ is adapted from count-one-ends.\n  -- For positive integers less than 10, the\
    \ answer is easy to calculate\n  -- (we count how many 1-end numbers are in there).\n\
    \  --\n  -- For 10 and above, however, there are multiple ways of counting them.\n\
    \  --\n  -- For example, if there are two 1-end numbers in a row, you can count\n\
    \  -- both of them as 1, and there are three 1-end numbers in a row, you\n  --\
    \ can count them as 3.\n  --\n  -- The simplest way of counting them is to count\
    \ how many times you\n  -- increment a number by 1.\n  --\n  -- For example, given\
    \ \"1234\", we consider \"12\" and increment it, so that\n  -- \"121\" becomes\
    \ 2, and then \"123\" becomes 3.\n  --\n  -- The complexity is O(n) because, for\
    \ each number, you iterate over\n  -- each of its digits.\n  --\n  -- To do this\
    \ efficiently, you should store the digits one by one in\n  -- an array, and then\
    \ compare the digit at a given index to 1.\n  --\n  -- At the end of the day,\
    \ we can just use a naive algorithm to count\n  -- the number of ways we can count\
    \ the number of 1-end numbers in a given\n  -- positive integer by incrementing\
    \ a number by one and counting the\n  -- number of ways that number can appear.\n\
    \  --\n  -- This can be calculated by using the fact that we can use one number\
    \ of\n  -- the digits to calculate how many of the other numbers we can count\
    \ as\n  -- \"1\".\n  --\n  -- The algorithm is as follows:\n  --\n  --      1.\
    \ Compute the number of 1-end numbers in the number by iterating\n  --       \
    \   over the digits.\n  --      2. Compute the number of ways to increment the\
    \ number by one by\n  --          iterating over the digits.\n  --      3. Calculate\
    \ the difference between the two of these.\n  --\n  --      For example, to count\
    \ the number of 1-end numbers in \"1234\", you\n  --      compute the number of\
    \ 1-end numbers by iterating over the digits:\n  --\n  --        1: 1\n  --  \
    \      2: 0\n  --        3: 2\n  --        4: 3\n  --        5: 4\n  --      \
    \  6: 6\n  --        7: 7\n  --        8: 0\n  --        9: 0\n  --        10:\
    \ 0\n  --\n  --      And for the other numbers, you compute the number of ways\
    \ to increment\n  --      the number by one by iterating over the digits:\n  --\n\
    \  --        0: 0\n  --        1: 0\n  --        2: 0\n  --        3: 0\n  --\
    \        4: 3\n  --        5: 1\n  --        6: 3", "  local count = 0\n  for\
    \ i = 1, n do\n    local c = math.floor((n - i) / 10)\n    if c == 1 then\n  \
    \    count = count + 1\n      i = math.ceil((n - i) / 10)\n    end\n  end\n  return\
    \ count\nend", "  local count = 0\n  for i = 1, n do\n    if i % 10 == 1 then\
    \ count = count + 1 end\n    if i % 10 == 2 then count = count + 1 end\n    if\
    \ i % 10 == 3 then count = count + 1 end\n    if i % 10 == 4 then count = count\
    \ + 1 end\n    if i % 10 == 5 then count = count + 1 end\n    if i % 10 == 6 then\
    \ count = count + 1 end\n    if i % 10 == 7 then count = count + 1 end\n    if\
    \ i % 10 == 8 then count = count + 1 end\n    if i % 10 == 9 then count = count\
    \ + 1 end\n  end\n  return count\nend", "    local ndigits = math.floor(n/math.pow(10,n))\n\
    \    return (ndigits - (ndigits % 2))\nend", "  local result = {}\n  for _ = 1,\
    \ n do\n    result[math.floor(n/10)] = result[math.floor(n/10)] or 0\n    if math.mod(n,\
    \ 10) == 0 then\n      result[math.floor(n/10)] = result[math.floor(n/10)] + 1\n\
    \    end\n    n = math.floor(n/10)\n  end\n  return result\nend", "  if n == 0\
    \ then return 0 end\n  local s = 0\n  local p = 1\n  for i = 2, n do\n    if n\
    \ % i == 0 then\n      s = s + 1\n      if n % p == 0 then s = s + 1 end\n   \
    \   if n % p == 1 then s = s + 1 end\n    end\n    p = p * 10 + 1\n  end\n  return\
    \ s\nend", "  local count = 0\n  for i = 1, math.floor(n * 10) + 1 do\n    if\
    \ n % i == 1 then\n      count = count + 1\n    end\n  end\n  return count\nend",
  "  -- Base cases\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return\
    \ 1\n  else\n    -- Iterate backwards from the middle and count the ones at the\
    \ end and\n    -- start.\n    local mid = math.ceil(math.log(n, 10))\n    local\
    \ count = 0\n    for i = mid, -1, -1 do\n      if n % i == 1 then\n        count\
    \ = count + 1\n      end\n    end\n    -- The final one at the start is just one\
    \ less than the final one at\n    -- end.\n    count = count + 1\n    -- Handle\
    \ the final one at the end.\n    if n ~= 2^mid then\n      count = count + 1\n\
    \    end\n    return count\n  end\nend", "  if n <= 0 then return 0 end\n  local\
    \ i = 1\n  local count = 0\n  while i <= n do\n    if i % 10 == 1 then count =\
    \ count + 1 end\n    i = i + 1\n  end\n  return count\nend", "  if n < 1 then\
    \ return 0 end\n  local ns = tostring(1):gsub('%a+', '')\n  local len = 0\n  for\
    \ i = 1, n do\n    if i == 1 then\n      if ns[i] == '1' then len = len + 1 end\n\
    \    elseif i == n then\n      if ns[i] == '1' then len = len + 1 end\n      if\
    \ ns[i-1] == '1' then len = len + 1 end\n    elseif ns[i] == '1' and ns[i-1] ==\
    \ '1' then\n      len = len + 1\n    elseif ns[i] == '0' then\n      if ns[i-1]\
    \ == '0' then len = len + 1 end\n      if ns[i-1] == '1' then len = len + 1 end\n\
    \    end\n  end\n  return len\nend", "  local count, result = 0, 1\n  for i =\
    \ 1, n do\n    if i % 10 == 1 then\n      result = result + 1\n    end\n    count\
    \ = count + 1\n  end\n  return count, result\nend", "   local count = 1\n   for\
    \ i = 1, n do\n      if i ~= n and i%10 ~= 1 then count = count + 1 end\n   end\n\
    \   return count\nend", "  assert(n > 0)\n  assert(n > 9)", "  if n <= 0 then\n\
    \    return 0\n  elseif n < 10 then\n    return 1\n  else\n    return 1 + starts_one_ends(math.floor(n/10))\
    \ +\n      starts_one_ends(math.ceil(n/10)) +\n      (n%10 > 0 and 1 or 0)\n \
    \ end\nend", "  if n < 10 then\n    return 0\n  end\n  return 10 + starts_one_ends(math.floor(n/10))\
    \ + 1\nend", "  if n < 10 then\n    return 1\n  else\n    return starts_one_ends(math.floor(math.log10(n))\
    \ + 1) +\n           math.floor(math.log10(math.abs(n - 1)))\n  end\nend", " \
    \ if n <= 0 then return 0 end\n  local count = 0\n  local i = 1\n  while i <=\
    \ n do\n    if i % 10 == 1 then\n      if i <= n then count = count + 1 end\n\
    \    else\n      if i >= n then count = count + 1 end\n    end\n    i = i + 1\n\
    \  end\n  return count\nend", "  if n <= 0 then return 0 end\n  local count =\
    \ 1\n  for i = 1, n do\n    if n ~= (i-1) then\n      count = count + 1\n    end\n\
    \  end\n  return count\nend", "  if n == 1 then return 1 end\n  local count =\
    \ 0\n  repeat\n    count = count + ends_one_ends(n - 1)\n  until n >= 10\n  return\
    \ count + 1\nend", "  if n <= 0 then\n    return nil\n  end\n  local num = math.floor(math.log10(n))\n\
    \  local count = 0\n  for i = 1, num do\n    if n <= 10^i then\n      return count\
    \ + 1\n    end\n  end\nend", "  if n < 0 then\n    return 0\n  else\n    local\
    \ count = 0\n    for i = 1, n do\n      if isinteger( string.sub( tostring(i),\
    \ 0, 1 ) ) then\n        count = count + 1\n      end\n    end\n    return count\n\
    \  end\nend", "  local count = n - 1\n  for i = 2, math.floor(n*10) + 1 do\n \
    \   if n % i == 0 then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  local count = 0\n  for i = 1, n do\n    if n % i == 0 then\n      count\
    \ = count + 1\n      if math.floor(n/i) == i then\n        break\n      end\n\
    \    end\n  end\n  return count\nend\n</cell>\n<text>\nExercise 2.17: Write a\
    \ recursive function count_digits that counts the number of digits in all positive\
    \ integers less than or equal to $n$. Test your function on the following inputs:",
  "  if n == 0 then\n    return 1\n  end\n  if n < 0 then\n    n = -n\n  end\n  local\
    \ i, k = 1, math.floor(n/10)\n  while i <= k do\n    local m = math.floor(n/math.pow(10,\
    \ i))\n    if m == 1 then\n      return i\n    end\n    i = i + 1\n  end\n  return\
    \ k\nend", "  -- Return the count of the numbers of n numbers that start or end\
    \ with 1.\n  if n == 1 then return 0 end\n  if n == 0 then return 0 end\n  if\
    \ n == -1 then return 0 end", "  if n == 1 then return 1 else return ends_one_ends(n-1)\
    \ + 1 end\nend", "  if n < 10 then return 1 end\n  local count = 0\n  while n\
    \ ~= 0 do\n    count = count + 1\n    local digit = math.floor(n / 10)\n    n\
    \ = n - (digit * 10)\n    if digit == 1 then break end\n  end\n  return count\n\
    end", "  if n < 10 then\n    return 0\n  end\n  local start, one = 1, 1\n  for\
    \ i = 1, n do\n    if i ~= start then\n      start = i\n      one = 1\n    end\n\
    \    if i == 1 then\n      one = 0\n    end\n    one = one or n % 10\n    n =\
    \ n / 10\n  end\n  return start + 1\nend", "    if n < 0 then return 0 end\n \
    \   if n < 10 then return 1 end", '  if n < 1 then return 0 end', "  if n == 1\
    \ then return 1 end\n  if n == 2 then return 0 end\n  if n < 10 then return 1\n\
    \  return 1 + starts_one_ends(n - 1)\nend", "   if n <= 0 then return 0 end\n\
    \   if n ~= 1 then\n      local num_ones = 1 + math.ceil(math.log10(n))\n    \
    \  return num_ones * starts_one_ends(n - num_ones)\n   else\n      return 1\n\
    \   end\nend", "  -- The count will be the sum of the number of integers that\
    \ start or end\n  -- with 1.\n  local count = 0\n  for i = 1, n do\n    count\
    \ = count + math.ceil(i * math.log(i, 2))\n  end\n  -- Round up to get the exact\
    \ count.\n  count = math.ceil(count)\n  return count\nend", "  local count = 0\n\
    \  for i=1,n do\n    count = count + 1\n    if starts_with(i) or ends_with(i)\
    \ then\n      count = count - 1\n    end\n  end\n  return count\nend", "    local\
    \ count = 0\n    for i = 1, n do\n        if (i == 1) then\n            if math.floor(i)\
    \ == i then\n                count = count + 1\n            end\n        else\n\
    \            if math.floor(i) ~= i then\n                count = count + 1\n \
    \           end\n        end\n    end\n    return count\nend", "  if n < 0 then\n\
    \    return \"0\"\n  end\n  local count = 0\n  for i = 1, math.floor(n) do\n \
    \   if n <= math.pow(10, i) then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "  if n < 1 then return 0 end\n  if n < 10 then return n end\n\
    \  if n == 10 or n % 10 == 1 then return n - 1 end\n  local m = math.ceil(math.log10(n))\n\
    \  return 1 + starts_one_ends(n / 10) * 10 ^ m\nend", "  local count = 0\n  for\
    \ i = 1, n do\n    count = count + math.floor(n/math.pow(10,i))\n  end\n  return\
    \ count\nend", "    local count = 0\n    while n > 0 do\n        count = count\
    \ + 1\n        n = math.ceil(n/10)\n    end\n    return count\nend", "  if n <\
    \ 1 then return 0 end\n  local ndigits = math.floor(math.log10(n)) + 1\n  local\
    \ count = 0\n  for i = 1, ndigits do\n    if math.fmod(n, 10) == 1 then\n    \
    \  if i == 1 then\n        count = count + 1\n      else\n        count = count\
    \ + 2\n      end\n    end\n    n = math.trunc(n/10)\n  end\n  return count\nend",
  "  if n < 10 then\n    return 0\n  end", "    if n < 0 then\n        return 0\n\
    \    end\n    local count = 0\n    for i = 1, n do\n        if i % 10 == 1 then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "    local n1 = math.floor(n)\n    if n1 == n then\n        return 1\n    end\n\
    \    local n2 = math.floor(n - n1)\n    if n2 == n then\n        return 1 + n1\n\
    \    end\n    local count = 0\n    for i = n1, n2 do\n        count = count +\
    \ starts_one_ends(i - 1)\n    end\n    return count\nend", "   local count = 0\n\
    \   for i = 1, math.floor(n) do\n      if i % 10 == 1 then\n         count = count\
    \ + 1\n      end\n      if i % 10 == 0 then\n         count = count + 1\n    \
    \     n = n / 10\n         if n == 1 then\n            return count\n        \
    \ end\n      end\n   end\n   return 0\nend", "  if n < 2 then return 1 end\n \
    \ local n2 = math.abs(n)\n  if n2 >= 10 then\n    if n2 >= 100 then\n      if\
    \ n2 >= 1000 then\n        if n2 >= 10000 then\n          return n2 - 10000 +\
    \ 1\n        end\n      else\n        return n2 - 100 + 1\n      end\n    else\n\
    \      return n2 - 10 + 1\n    end\n  else\n    return n2 - 1\n  end\nend", " \
    \   local count = 0\n    for i = 1, n do\n        if i ~= 1 and i ~= n then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  -- The count starts from 1 and ends with 1.\n  local starts = 1\n  local ends\
    \ = 1\n  -- A number starting with 1 is counted as a positive number.\n  if n\
    \ >= 1 then\n    starts = starts + 1\n  end\n  -- A number ending with 1 is counted\
    \ as a negative number.\n  if n % 10 == 1 then\n    ends = ends + 1\n  end\n \
    \ return starts, ends\nend", "   if n == 0 then\n      return 0\n   elseif n ==\
    \ 1 then\n      return 1\n   else\n      local count = 1\n      local k = math.floor(n/10)\n\
    \      for i = 1,k do\n         if n >= i * 10 then\n            count = count\
    \ + starts_one_ends(n - i * 10)\n         end\n      end\n      return count +\
    \ starts_one_ends(n - k * 10)\n   end\nend", "  if n < 10 then\n    return 1\n\
    \  end\n  local digits = math.floor(n/10)\n  if n % 10 == 0 then\n    return digits\n\
    \  end\n  return digits + starts_one_ends(n - (10 * digits))\nend", "  if n <\
    \ 10 then return 1 end\n  local count = 1\n  for i = 2, n do\n    if i % 10 ==\
    \ 1 or i % 10 == 9 then count = count + 1 end\n  end\n  return count\nend\n</cell>\n\
    <text>\nHere are some examples of usage:", "   -- The only even positive number\
    \ is 2.\n   if n % 2 == 0 then return 1 end", "  if n == 0 then return 0 end\n\
    \  if n < 0 or n % 10 == 1 then return 0 end\n  local count = 0\n  for i = 1,\
    \ n do\n    if i ~= n and i % 10 == 1 then count = count + 1 end\n  end\n  return\
    \ count\nend", "  -- If `n` is greater than `1`, there are no such n-digit numbers.\
    \ Return `0`.\n  if n > 1 then return 0 end", "  assert(n > 0)\n  local count\
    \ = 0\n  for i = 1, n do\n    if i ^ 1 = 0 then count = count + 1 end\n  end\n\
    \  return count\nend", "  local count = 1\n  while n > 1 do\n    count = count\
    \ + 1\n    n = n / 10\n  end\n  return count\nend", "  if n < 1 then\n    return\
    \ 0\n  else\n    return math.floor((n - 1) / 100) + math.floor((n - 1) % 100)\n\
    \  end\nend\n</cell>\n<cell>\nstarts_one_ends(3)\n</cell>\n<text>\n2.3 Write a\
    \ function that checks if a number is a power of two. Return True or False.",
  "  local ndigits = math.floor(math.log10(n)) + 1\n  local count = 0\n  for i = 1,\
    \ ndigits do\n    if n%10 == 1 then\n      count = count+1\n    end\n    n = n/10\n\
    \  end\n  return count\nend", "  if n <= 0 then return 0 end\n  if n == 1 then\
    \ return 1 end\n  if n > 1 and n % 10 == 1 then return starts_one_ends(n / 10)\
    \ end\n  return starts_one_ends(math.ceil(n / 10) * 10) + n % 10\nend", "  if\
    \ n <= 0 then return 0 end\n  return 1 + starts_one_ends(math.floor(n/10)) + starts_one_ends(math.mod(n,10))\n\
    end", "  local count = 0\n  local ndigits = math.floor(n/math.pow(10, math.floor(math.log10(n))))\n\
    \  while n > 1 do\n    if n == 1 then\n      count = count + 1\n    else\n   \
    \   n = n - math.pow(n, math.floor(math.log10(n)))\n      if math.floor(n/math.pow(10,\
    \ math.floor(math.log10(n)))) == ndigits then\n        count = count + 1\n   \
    \   end\n    end\n  end\n  return count\nend", "    if n <= 0 then return 0 end\n\
    \    local counts = {n}\n    if n < 100 then\n        for i = 1, 100 do\n    \
    \        if i == 1 then\n                table.insert(counts, i)\n           \
    \ elseif i > math.floor(n) then\n                table.insert(counts, i)\n   \
    \         end\n        end\n    end\n    local n = math.floor(n)\n    for i =\
    \ 2, math.floor(n) do\n        if n % i == 0 then\n            table.insert(counts,\
    \ i)\n        end\n    end\n    return #counts\nend", "    local count = 0\n \
    \   for i = 1, n do\n        if math.floor(i) == i then\n            count = count\
    \ + 1\n        end\n    end\n    return count\nend\n</code>\n<|/ a dscore=2 tags=lua-table,lua\
    \ |>\n<| c |>\nThank you for your input. This is very helpful, but as I'm still\
    \ learning lua, I was hoping I would be able to understand how the code worked.\n\
    <|/ c |>\n<| c |>\nI added comments to the code.  Note that `math.floor` rounds\
    \ the number down, not up, so the code will give different results if run on `-123`\
    \ and `-456`, but if the goal is to find out how many 1's there are for large\
    \ numbers, it will work fine.  If you want to find how many 1's there are for\
    \ small numbers, you'll have to change the code to `math.ceil` instead of `math.floor`.\n\
    <|/ c |>\n<| a tags=lua-table,lua |>\nHere's another way, using math.floor, math.ceil\
    \ and math.mod to work out the largest number possible in base 10 (i.e. digit-by-digit\
    \ sum and number of digits).  It uses O(log n) arithmetic operations.\n<code>",
  "  local count = 0\n  while n > 1 do\n    count = count + 1\n    if n / 10 <= 1\
    \ then\n      n = n / 10\n    else\n      n = math.floor(n)\n    end\n  end\n\
    \  return count\nend", "    local count = 0\n    local i = 1\n    while i <= n\
    \ do\n        -- Skip leading zeros.\n        if i > 1 then\n            if i\
    \ % 10 == 0 then\n                count = count + 1\n            end\n       \
    \ end\n        -- Skip trailing zeros.\n        if i % 10 == 0 then\n        \
    \    count = count + 1\n        end\n        -- Next digit.\n        i = i + 1\n\
    \    end\n    return count\nend", "  if n < 0 then\n    error(\"Given non-positive\
    \ number \" .. tostring(n))\n  end\n  if n == 1 then\n    return 1\n  end\n  local\
    \ count = 0\n  while n > 1 do\n    count = count + 1\n    n = n / 10\n  end\n\
    \  return count\nend", "  if n < 0 then return 0 end\n  local count = 0\n  while\
    \ n ~= 1 do\n    count = count + 1\n    n, i = div(n, 10)\n  end\n  return count\n\
    end", "  local count_ones = 0\n  local i = 2\n  repeat\n    if n >= i then count_ones\
    \ = count_ones + 1 end\n    n = math.floor(n / 10)\n    i = i + 1\n  until n ==\
    \ 0\n  return count_ones\nend", "  local count = 0\n  if n >= 0 then count = n\
    \ end\n  while n >= 10 do\n    count = count + 1\n    n = math.mod(n, 10)\n  end\n\
    \  return count\nend", "  local count = math.floor(n/10)\n  if count > 0 then\n\
    \    count = starts_one_ends(count)\n  end\n  return math.max(1,count+math.floor(math.log10(n)))\n\
    end", "  local count = 0\n  for i = 1, n do\n    if n % i == 0 then\n      count\
    \ = count + 1\n      if i ~= n then\n        count = count + 1\n      end\n  \
    \  end\n  end\n  return count\nend", "  local count = 0\n  repeat\n    -- Add\
    \ one to the count, but only if it ends with a 1.\n    count = count + 1\n   \
    \ -- But only if it starts with a 1.\n    if n ~= 1 then count = count + 1 end\n\
    \    -- Add the second digit, and see if it starts with a 1.\n    count = count\
    \ + 1\n    if n ~= 1 then count = count + 1 end\n    -- Move on to the next digit,\
    \ and see if it starts with a 1.\n    n = n / 10\n  until n == 0\n  return count\n\
    end", "  if n <= 1 then return 0 end\n  local count = 1\n  for i = 1, n do\n \
    \   count = count + 1\n    if i % 10 == 1 or i % 10 == 0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "   -- The goal is to count the digits\
    \ in binary representations.\n   -- For this task we convert the number into a\
    \ string and then count the digits in binary string.\n   -- For example 12345\
    \ becomes 10100111001 in binary and has 8 digits (1, 2, 3, 4, 5 are all 101 so\
    \ they count).\n   -- We also have to keep in mind that we don't want to count\
    \ the last digit (which is 1).\n   -- For example if we have 12345 we also don't\
    \ want to count the last one (which is 5).\n   -- This implies that we will need\
    \ to count from right to left.\n   local result = 0\n   local digits = math.floor(math.log(n)/math.log(2))\n\
    \   for i = digits, 1, -1 do\n      local b = math.floor(n/2**i)\n      -- We\
    \ want the sum of digits when converting into binary number. Because each number\
    \ has only 1 digit,\n      -- it's easy to convert it into binary number. The\
    \ sum of digits is the digits of binary number.\n      -- For example 10100111001\
    \ = 10 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 10100111.\n      -- We add digits of\
    \ binary number because each number has only 1 digit, we don't care about the\
    \ other.\n      -- We also add 1 because we start from right (last digit).\n \
    \     result = result + math.floor(b/math.pow(2,i))+1\n   end\n   return result\n\
    end", "  local count = -1\n  for i = 1, math.floor(n/DIGIT) do\n    if n % i ==\
    \ 0 then\n      if ((i - 1) % DIGIT == 0) or ((n - 1) % DIGIT == 0) then\n   \
    \     count = count + 1\n      end\n    end\n  end\n  return count\nend", "  --\
    \ If the n is 1, return 1. If the n is 0, return 0.\n  -- Otherwise, subtract\
    \ 1 from n.\n  return n == 0 or n - 1\nend", "    if n == 0 then\n        return\
    \ 0\n    end\n    local s = 0\n    local k = 1\n    while k*10 <= n do\n     \
    \   s = s + k\n        k = k + 1\n    end\n    return s\nend", "  local ndigits\
    \ = math.log(math.abs(n)) -- The last digit is 0.\n  local result = { }\n  for\
    \ i = 1, math.floor(ndigits + 0.5) do\n    -- Compute the range [1..i-1] where\
    \ i is the number of leading digits\n    -- (a power of two).\n    local start\
    \ = math.floor(ndigits * math.pow(2, i))\n    local stop = math.floor(ndigits\
    \ * math.pow(2, i+1))\n    local n = n - start -- The last digit is 0.\n    --\
    \ The count is the number of numbers from n to i.\n    local count = math.floor(n\
    \ / math.pow(2, i-start)) - 1\n    -- Add an entry (start, count) for each 1..i\
    \ starting from n.\n    if start ~= n then result[n - 1] = { start = start, count\
    \ = count } end\n  end\n  -- Add an entry (start, ndigits) for each ndigits +\
    \ 1..n starting from n.\n  result[n - 1] = { start = n, count = ndigits + 1 }\n\
    \  return result\nend", "    local count = 0\n    while n > 0 do\n        count\
    \ = count + 1\n        if n % 10 == 1 then\n            n = math.floor(n/10)\n\
    \        else\n            n = math.ceil(n/10)\n        end\n    end\n    return\
    \ count\nend", "  local count = 0\n  local index = 1\n  while index < n do\n \
    \   if index % 10 == 1 then\n      count = count + 1\n    end\n    index = index\
    \ * 10 + 1\n  end\n  return count\nend", "    local count = 1\n    for i = 1,\
    \ n do\n        if n % i == 1 then count = count + 1 end\n    end\n    return\
    \ count\nend", "  local count=0\n  for i=1,n do\n    if numbers[i] == 1 then\n\
    \      if i-count+1 > 1 then\n\tcount = count + 1\n      end\n    end\n  end\n\
    \  return count\nend", "  if n < 0 then\n    return 0\n  end\n  -- If the nth\
    \ digit is 1, we know all those numbers that start with 1 will have\n  -- an odd\
    \ number of digits\n  local n_digits = math.floor(n)\n  if math.floor(n) == n\
    \ then\n    return n_digits\n  end\n  -- If n is not a positive integer:\n  return\
    \ 0\nend", "  local count = 0\n  for i = 1, n do\n    if n <= 1 then\n      count\
    \ = count + 1\n    elseif n == 1 then\n      count = count + 1\n    elseif n ~=\
    \ 1 then\n      if i ~= n then count = count + 1 else count = count end\n    end\n\
    \  end\n  return count\nend", "   local ones = 0\n   local ends = 0\n   for i\
    \ = 1, n do\n      local digit = math.floor(n/math.pow(10,i))\n      if digit\
    \ == 1 then\n\t ones = ones + 1\n      elseif digit == 0 then\n\t ends = ends\
    \ + 1\n      else\n\t break\n      end\n   end\n   return ones, ends\nend", '  assert(n
    > 1)', "  local count = 0\n  for i = 1, n do\n    if i % 10 == 1 then\n      count\
    \ = count + 1\n    end\n    if n % 10 == 1 and i ~= 0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "    local count = 0\n    for i =\
    \ 1, n do\n        count = count + math.floor((math.floor(i * 10) / 10) % 2)\n\
    \    end\n    return count\nend", "  if n < 0 then\n    return 0\n  end\n  local\
    \ n = 1\n  repeat\n    n = n * 10 + 1\n  until n >= n\n  local count = 1\n  repeat\n\
    \    count = count + 1\n  until n % 10 == 0\n  return count\nend", "  if n < 10\
    \ then\n    return 0\n  end\n  local count = 0\n  while n > 0 do\n    count =\
    \ count + n % 10\n    local d = n % 10\n    n = n // 10\n  end\n  return count\n\
    end\n</cell>\n<cell>", "  local count = 0\n  while n > 1 do\n    if n mod 10 ==\
    \ 0 then\n      count = count + 1\n    end\n    n, n = n / 10, n\n  end\n  return\
    \ count\nend", "  assert(n > 1)\n  local count = 0\n  for i = 1, n do\n    if\
    \ i >= n and i % n = 0 then return end\n    if i <= n and i % n = 1 then count\
    \ = count + 1 end\n  end\n  return count\nend", "  local count = 0\n  for i =\
    \ 1, math.max(n, 10) do\n    if i > 1 and i % n == 0 then\n      count = count\
    \ + 1\n    end\n    if i >= 1 and i % n == 0 then\n      count = count + 1\n \
    \   end\n  end\n  return count\nend", "  assert(n > 0)\n  local count = 0\n  local\
    \ limit = math.floor(n/10)\n  while limit > 0 do\n    local test = math.floor(n/limit)\n\
    \    if test == 1 then\n      if n <= limit then\n        return count\n     \
    \ end\n      count = count + 1\n    end\n    limit = limit - 1\n  end\n  if n\
    \ == 0 then\n    return 1\n  elseif n > 0 then\n    return count\n  end\nend",
  "  local count = 0\n  -- The last digit is guaranteed to be 1 because we only check\
    \ up\n  -- to the second to last digit.\n  for i = 1, (n / 10) + 1 do\n    if\
    \ n <= 10 then\n      count = count + 1\n    elseif n > 10 then\n      if n %\
    \ 10 == 1 then\n        count = count + 1\n      elseif n % 10 == 0 then\n   \
    \     count = count + 1\n      else\n        count = count + 1\n      end\n  \
    \  end\n  end\n  -- The second to last digit is guaranteed to be 1 because we\
    \ only\n  -- check up to the last digit.\n  count = count + (n % 10 == 1 and 1\
    \ or 0)\n  return count\nend", "  if n == 0 then\n    return 0\n  end\n  if n\
    \ ~= 1 then\n    return 1 + starts_one_ends(math.floor(n))\n  end\n  local i =\
    \ 1\n  while i * i <= n do\n    if i % i == 0 then\n      return 1 + starts_one_ends(n\
    \ - i)\n    end\n    i = i * 2 + 1\n  end\nend", "  local count = 0\n  if n >=\
    \ 0 and n % 1 == 0 then count = count + 1 end\n  if n >= 1 and n % 1 == 1 then\
    \ count = count + 1 end\n  if n >= 2 and n % 1 == 1 then count = count + 1 end\n\
    \  if n >= 3 and n % 1 == 1 then count = count + 1 end\n  if n >= 4 and n % 1\
    \ == 1 then count = count + 1 end\n  if n >= 5 and n % 1 == 1 then count = count\
    \ + 1 end\n  if n >= 6 and n % 1 == 1 then count = count + 1 end\n  if n >= 7\
    \ and n % 1 == 1 then count = count + 1 end\n  if n >= 8 and n % 1 == 1 then count\
    \ = count + 1 end\n  if n >= 9 and n % 1 == 1 then count = count + 1 end\n  if\
    \ n >= 10 and n % 1 == 1 then count = count + 1 end\n  if n >= 11 and n % 1 ==\
    \ 1 then count = count + 1 end\n  if n >= 12 and n % 1 == 1 then count = count\
    \ + 1 end\n  if n >= 13 and n % 1 == 1 then count = count + 1 end\n  if n >= 14\
    \ and n % 1 == 1 then count = count + 1 end\n  if n >= 15 and n % 1 == 1 then\
    \ count = count + 1 end\n  if n >= 16 and n % 1 == 1 then count = count + 1 end\n\
    \  if n >= 17 and n % 1 == 1 then count = count + 1 end\n  if n >= 18 and n %\
    \ 1 == 1 then count = count + 1 end\n  if n >= 19 and n % 1 == 1 then count =\
    \ count + 1 end\n  if n >= 20 and n % 1 == 1 then count = count + 1 end\n  if\
    \ n >= 21 and n % 1 == 1 then count = count + 1 end\n  if n >= 22 and n % 1 ==\
    \ 1 then count = count + 1 end\n  if n >= 23 and n % 1 == 1 then count = count\
    \ + 1 end\n  if n >= 24 and n % 1 == 1 then count = count + 1 end\n  if n >= 25\
    \ and n % 1 == 1 then count = count + 1 end\n  if n >= 26 and n % 1 == 1 then\
    \ count = count + 1 end\n  if n >= 27 and n % 1 == 1 then count = count + 1 end\n\
    \  if n >= 28 and n % 1 == 1 then count = count + 1 end\n  if n >= 29 and n %\
    \ 1 == 1 then count = count + 1 end\n  if n >= 30 and n % 1 == 1 then count =\
    \ count + 1 end\n  if n >= 31 and n % 1 == 1 then count = count + 1 end\n  if\
    \ n >= 32 and n % 1 == 1 then count = count + 1 end\n  if n >= 33 and n % 1 ==\
    \ 1 then count = count + 1 end\n  if n ", "  return torch.range(1, n+1, 2)\nend",
  "  if n < 0 then\n    return 0\n  end\n  local count = 0\n  while n <= 1 do\n  \
    \  count = count + 1\n    local x = math.floor(n)\n    n = math.floor(n / 10)\n\
    \  end\n  return count\nend", "  assert(n > 0)\n  local i, count = 0\n  while\
    \ i <= n do\n    if i %% 10 == 1 then\n      count = count + 1\n    end\n    i\
    \ = i + 1\n  end\n  return count\nend", "    local count=0\n    for i=1,math.ceil(math.log10(n)-1)\
    \ do\n        if math.floor(math.pow(10,i-1)*n/(math.pow(10,i))+1)==1 then\n \
    \           count=count+1\n        end\n    end\n    return count\nend\nprint(\"\
    Number of positive integers that start or end with 1 are: \"..starts_one_ends(100))",
  "  if n < 0 then\n    return 0\n  end\n  local c = 0\n  for i = 1, n do\n    if\
    \ i > n or i ~= 1 or i ~= n - 1 then\n      c = c + 2\n    end\n  end\n  return\
    \ c\nend", "  local count = 0\n  local t = n\n  while t > 0 do\n    if t % 10\
    \ == 1 then\n      count = count + 1\n    end\n    t /= 10\n  end\n  return count\n\
    end", "  local count = 0\n  for _ = 1, n do\n    if n == 1 or n % 10 == 1 or n\
    \ % 100 == 1 or n % 1000 == 1 then\n      count = count + 1\n    end\n    n =\
    \ math.floor(n/10)\n  end\n  return count\nend", "  if n < 10 then\n    return\
    \ 1\n  end\n  local count = 0\n  for i = 1, n do\n    if i % 10 == 1 then\n  \
    \    count = count + 1\n    elseif i % 10 == 0 then\n      if i % 10 == 1 or i\
    \ % 10 == 0 then\n        count = count + 1\n      end\n    end\n  end\n  return\
    \ count\nend", "  if n < 10 then\n    return 0\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
