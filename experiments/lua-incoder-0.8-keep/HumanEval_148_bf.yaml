name: HumanEval_148_bf
language: lua
prompt: "-- There are eight planets in our solar system: the closerst to the Sun \n\
  -- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n-- Uranus,\
  \ Neptune.\n-- Write a function that takes two planet names as strings planet1 and\
  \ planet2. \n-- The function should return a tuple containing all planets whose\
  \ orbits are \n-- located between the orbit of planet1 and the orbit of planet2,\
  \ sorted by \n-- the proximity to the sun. \n-- The function should return an empty\
  \ tuple if planet1 or planet2\n-- are not correct planet names. \n-- Examples\n\
  -- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n-- bf(\"Earth\", \"\
  Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
  , \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function bf(planet1, planet2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
  \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n  \
  \  lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
  \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
  \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
  \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
  \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   local orbit1, orbit2 = get_orbits(planet1, planet2) \n   \n   return\
    \ sort({orbit1, orbit2}) \nend", "    if not planet1 or not planet2 then\n   \
    \     return ()\n    elseif planet1 == planet2 then\n        return planet1\n\
    \    elseif planet1 ~= planet2 then\n        return bf(planet1, planet2)\n   \
    \ else\n        local sun = orbit_sun(planet1)\n        local sun2 = orbit_sun(planet2)\n\
    \        local distance = math.sqrt(math.pow(math.sin(math.radians(sun.phi)),\
    \ 2) + \n            math.pow(math.sin(math.radians(sun.theta)), 2))\n       \
    \ return setmetatable(sun + sun2, {__index = function(self, planet)\n        \
    \    local sun = orbit_sun(planet)\n            local distance = math.sqrt(math.pow(math.sin(math.radians(sun.phi)),\
    \ 2) + \n                math.pow(math.sin(math.radians(sun.theta)), 2))\n   \
    \         local d = distance - math.sqrt((sun - sun2).dist * (sun - sun2).dist)\
    \ / 6378137\n            return d >= 0 and d <= 1 and planet\n        end})\n\
    \    end\nend", "   local jupiter = planet1 -- Planet names are passed in as a\
    \ string. \n   local neptune = planet2 -- planets are passed in as a string.\n\
    \   -- TODO: Write code here\n   \n   return \n   \nend", "\tlocal planet1Orbit\
    \ = Orbit:new(planet1, \"Sun\")\n\tlocal planet2Orbit = Orbit:new(planet2, \"\
    Sun\")\n\tif planet1Orbit:distanceTo(planet2Orbit) < 180 then\n\t\treturn ()\n\
    \telse\n\t\tlocal planets = { planet1, planet2 }\n\t\tfor i = 2, #planets, 2 do\n\
    \t\t\tlocal tempOrbit = Orbit:new(planets[i], planets[i-1])\n\t\t\tplanets[i]\
    \ = tempOrbit:distanceTo(planets[i-1]) < 180\n\t\t\t\tand planets[i-1]\n\t\t\t\
    end\n\t\tend\n\t\treturn table.sort(planets)\n\tend\nend", "\tlocal planet1_orbit\
    \ = orbit_table(planet1)\n\tlocal planet2_orbit = orbit_table(planet2)\n\t\n\t\
    -- Return the planets in the orbit of planet1\n\tlocal planets = planet1_orbit:filter(function(p)\
    \ return p == planet1 end):sort()\n\t\n\t-- Return an empty list if planet1 or\
    \ planet2 is not correct\n\tif not (#planets == 1 and #planets_orbit2 == 0) then\n\
    \t\treturn nil\n\tend", '    local sun = sys.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian.newtonian',
  "  local orbit1, orbit2 = get_orbit(planet1, planet2)\n  return orbit1:gsearch(function\
    \ (orbit)\n    return orbit2:gsearch(function (other_orbit)\n      return distance(orbit,\
    \ other_orbit) < 1\n    end)\n  end) or {}\nend", "  if planet1 == planet2 then\
    \ return false end\n  local a1 = tonumber(orbit_distance(planet1, \"Sun\"))\n\
    \  local a2 = tonumber(orbit_distance(planet2, \"Sun\"))\n  local b1 = tonumber(orbit_distance(planet1,\
    \ \"Earth\"))\n  local b2 = tonumber(orbit_distance(planet2, \"Earth\"))\n  local\
    \ c1 = tonumber(orbit_distance(planet1, \"Mars\"))\n  local c2 = tonumber(orbit_distance(planet2,\
    \ \"Mars\"))\n  local d1 = tonumber(orbit_distance(planet1, \"Mercury\"))\n  local\
    \ d2 = tonumber(orbit_distance(planet2, \"Mercury\"))\n  local e1 = tonumber(orbit_distance(planet1,\
    \ \"Venus\"))\n  local e2 = tonumber(orbit_distance(planet2, \"Venus\"))\n  local\
    \ f1 = tonumber(orbit_distance(planet1, \"Jupiter\"))\n  local f2 = tonumber(orbit_distance(planet2,\
    \ \"Jupiter\"))\n  local g1 = tonumber(orbit_distance(planet1, \"Saturn\"))\n\
    \  local g2 = tonumber(orbit_distance(planet2, \"Saturn\"))\n  local h1 = tonumber(orbit_distance(planet1,\
    \ \"Uranus\"))\n  local h2 = tonumber(orbit_distance(planet2, \"Uranus\"))\n \
    \ if a1 < b1 then return (a2, planet2) end\n  if a2 < b1 then return (a1, planet1)\
    \ end\n  if a1 < c1 then return (a2, planet2) end\n  if a2 < c1 then return (a1,\
    \ planet1) end\n  if a1 < d1 then return (a2, planet2) end\n  if a2 < d1 then\
    \ return (a1, planet1) end\n  if a1 < e1 then return (a2, planet2) end\n  if a2\
    \ < e1 then return (a1, planet1) end\n  if a1 < f1 then return (a2, planet2) end\n\
    \  if a2 < f1 then return (a1, planet1) end\n  if a1 < g1 then return (a2, planet2)\
    \ end\n  if a2 < g1 then return (a1, planet1) end\n  if a1 < h1 then return (a2,\
    \ planet2) end\n  if a2 < h1 then return (a1, planet1) end\n  if b2 < c1 then\
    \ return (b1, planet1) end\n  if b2 < d1 then return (b1, planet2) end\n  if b2\
    \ < e", "\tlocal sun = math.huge\n\tlocal sun_distance = 0\n\tlocal sun_planet1\
    \ = nil\n\tlocal sun_planet2 = nil\n\tlocal sun_planet3 = nil\n\tlocal sun_planet4\
    \ = nil\n\tlocal sun_planet5 = nil\n\tlocal sun_planet6 = nil\n\tlocal sun_planet7\
    \ = nil\n\tlocal sun_planet8 = nil\n\tlocal sun_planet9 = nil", "    local orbit1\n\
    \    local orbit2\n    \n    -- TODO: Replace this with proper inputs to the function\n\
    \    if planet1 == \"Mercury\" then\n        orbit1 = {150,938,747,390,170,912,738}\n\
    \        orbit2 = {150,918,743,390,170,916,737}\n    elseif planet1 == \"Venus\"\
    \ then\n        orbit1 = {150,938,747,390,170,912,738}\n        orbit2 = {150,938,747,390,170,912,738}\n\
    \    elseif planet1 == \"Earth\" then\n        orbit1 = {150,938,747,390,170,912,738}\n\
    \        orbit2 = {150,938,747,390,170,912,738}\n    elseif planet1 == \"Mars\"\
    \ then\n        orbit1 = {150,938,747,390,170,912,738}\n        orbit2 = {150,938,747,390,170,912,738}\n\
    \    elseif planet1 == \"Jupiter\" then\n        orbit1 = {150,938,747,390,170,912,738}\n\
    \        orbit2 = {150,938,747,390,170,912,738}\n    elseif planet1 == \"Saturn\"\
    \ then\n        orbit1 = {150,938,747,390,170,912,738}\n        orbit2 = {150,938,747,390,170,912,738}\n\
    \    elseif planet1 == \"Uranus\" then\n        orbit1 = {150,938,747,390,170,912,738}\n\
    \        orbit2 = {150,938,747,390,170,912,738}\n    elseif planet1 == \"Neptune\"\
    \ then\n        orbit1 = {150,938,747,390,170,912,738}\n        orbit2 = {150,938,747,390,170,912,738}\n\
    \    end", "    local p1 = planet1\n    local p2 = planet2\n    local c1 = false\n\
    \    local c2 = false\n    local p3 = {\n        pos = {\"SUN\", 0, \"SUN\", 0}\n\
    \    }\n    local p4 = {\n        pos = {\"SUN\", 0, \"SUN\", 0}\n    }\n    local\
    \ t = {}\n    while p1:match(\"^[a-b]+$\") do\n        local p5 = nil\n      \
    \  while p2:match(\"^[a-b]+$\") do\n            local p6 = nil\n            while\
    \ p3:match(\"^[a-b]+$\") do\n                local p7 = nil\n                while\
    \ p4:match(\"^[a-b]+$\") do\n                    local p8 = nil\n            \
    \        while p5:match(\"^[a-b]+$\") do\n                        local p9 = nil\n\
    \                        while p6:match(\"^[a-b]+$\") do\n                   \
    \         local p10 = nil\n                            while p7:match(\"^[a-b]+$\"\
    ) do\n                                local p11 = nil\n                      \
    \          while p8:match(\"^[a-b]+$\") do\n                                 \
    \   local p12 = nil\n                                    while p9:match(\"^[a-b]+$\"\
    ) do\n                                        local p13 = nil\n              \
    \                          while p10:match(\"^[a-b]+$\") do\n                \
    \                            local p14 = nil\n                               \
    \             if p11:match(\"^[a-b]+$\") then\n                              \
    \                  local p15 = nil\n                                         \
    \       if p12:match(\"^[a-b]+$\") then\n                                    \
    \                local p16 = nil\n                                           \
    \         while p13:match(\"^[a-b]+$\") do\n                                 \
    \                       local p17 = nil\n                                    \
    \                    while p14:match(\"^[a-b]+$\") do\n                      \
    \                                      local p18 = nil\n                     \
    \                                       while p15:match(\"^[a-b]+$\") do\n   \
    \                                                             local p19 = nil\n\
    \                                                                while p16:match(\"\
    ^[a-b]+$\") do\n                                                             \
    \       local p20 = nil\n                                                    \
    \                while p17:match(\"^[a-b]+$\") do\n                          \
    \                                              local p21 = nil\n             \
    \                                                           while p18:match(\"\
    ^[a-b]+$\") do\n                                                             \
    \               local p22 = nil\n                                            \
    \                                while p19:match(\"^[a-b]+$\") do\n          \
    \                                                                      local p23\
    \ = nil\n                                                                    \
    \            while p20:match(\"^[a-b]+$\") do\n                              \
    \                                                      local p24 = nil\n     \
    \                                                                            \
    \   if p21:match(\"^[a-", "\tlocal orbit1 = planet1:match(\"^([^ ]+) %s*(.*)$\"\
    )\n\tlocal orbit2 = planet2:match(\"^([^ ]+) %s*(.*)$\")\n\treturn (bf(orbit1[2],\
    \ orbit2[2])) \n\t\t+ ((orbit1[2] > orbit2[2] and planet1 < planet2) \n\t\t\t\
    or (orbit1[2] < orbit2[2] and planet1 > planet2)) \n\t\t\t-- Add all planets which\
    \ are located between the orbit of \n\t\t\t-- planet1 and the orbit of planet2\
    \ sorted by proximity to the sun.\nend", "  if planet1 == planet2 then\n    return\
    \ ()\n  end", "    \n    -- TODO: Implement this function\n    return \nend",
  "\tlocal sol1 = getSunOrbit(planet1)\n\tlocal sol2 = getSunOrbit(planet2)\n\tlocal\
    \ sol = {}\n\t-- Loop over all planets.\n\tfor i = 1, #planets do\n\t\tlocal o1\
    \ = getSunOrbit(planets[i])\n\t\tif o1 then\n\t\t\t-- Loop over all planets.\n\
    \t\t\tfor j = 1, #planets do\n\t\t\t\tlocal o2 = getSunOrbit(planets[j])\n\t\t\
    \t\tif o2 then\n\t\t\t\t\tif o1 == o2 then\n\t\t\t\t\t\tsol[j] = planets[i]\n\t\
    \t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(sol)\n\treturn\
    \ sol\nend\nreturn bf", "    local planet1 = planet1 or planet2\n    local planet2\
    \ = planet2 or planet1\n    \n    local sun = math.rad(math.pi/4)\n    local planets\
    \ = { }\n    \n    for i = 1, #planet1 do\n        local p1 = planet1\n      \
    \  local p2 = planet2\n        local rad = math.rad(p1 .. \" orbital of \" ..\
    \ p2)\n        \n        while rad < sun do\n            table.insert(planets,\
    \ p1)\n            p1 = p1 .. \"+\"\n            rad = rad + 2*math.rad(p1 ..\
    \ \" orbital of \" .. p2)\n        end\n    \n        while rad > sun do\n   \
    \         table.insert(planets, p2)\n            p2 = p2 .. \"-\"\n          \
    \  rad = rad - 2*math.rad(p1 .. \" orbital of \" .. p2)\n        end\n    end\n\
    \    \n    table.sort(planets)\n    \n    return planets\nend", "    local pl1\
    \ = get_planet_names(planet1)\n    local pl2 = get_planet_names(planet2)\n   \
    \ local pl1len = #pl1\n    local pl2len = #pl2\n    local pl1\n    local pl2\n\
    \    local i1\n    local i2\n    local pos1\n    local pos2\n    local dist",
  "   if type(planet1) ~= \"string\" or type(planet2) ~= \"string\" then\n      return\
    \ nil\n   end\n   local planet1 = planet1 or {}\n   local planet2 = planet2 or\
    \ {}\n   local sun = GetSun()\n   local planet1orbit, planet2orbit = GetOrbit(planet1),\
    \ GetOrbit(planet2)\n   local sunorbit = GetOrbit(sun)\n   local dist1, dist2\
    \ = GetDistance(planet1orbit, planet2orbit)\n   local distsun = GetDistance(sunorbit,\
    \ sunorbit)\n   if dist1 <= distsun and dist1 <= dist2 then\n      return (planet1,\
    \ planet2)\n   elseif dist2 <= distsun and dist2 <= dist1 then\n      return (planet2,\
    \ planet1)\n   end\n   return nil\nend", "    local mercury, venus = {}, {}\n\
    \    for i = 1, 8 do\n        local p, o = {}, {}\n        o.x, o.y = mercury[i]\
    \ or venus[i+1]\n        if o.x == nil then\n            o.x = mercury[i+1]\n\
    \        end\n        o.r, o.v = sun(planet1); o.i = sun(planet2); o.t = o.v -\
    \ o.i\n        if o.t > 0 then\n            p.x = mercury[i]\n            p.y\
    \ = mercury[i+1]\n            p.r = o.v\n            p.i = o.t\n            p.t\
    \ = o.i\n        else\n            p.x = venus[i]\n            p.y = venus[i+1]\n\
    \            p.r = o.r\n            p.i = o.t\n            p.t = o.v\n       \
    \ end\n        table.insert(p, planet1)\n        table.insert(p, planet2)\n  \
    \      table.insert(p, planet1)\n        table.insert(p, planet2)\n        table.insert(p,\
    \ planet1)\n        table.insert(p, planet2)\n        table.insert(p, planet1)\n\
    \        table.insert(p, planet2)\n        table.insert(p, planet1)\n        table.insert(p,\
    \ planet2)\n        table.insert(p, planet1)\n        table.insert(p, planet2)\n\
    \        table.insert(p, planet1)\n        table.insert(p, planet2)\n        table.insert(p,\
    \ planet1)\n        table.insert(p, planet2)\n        table.insert(p, planet1)\n\
    \        table.insert(p, planet2)\n        table.insert(p, planet1)\n        table.insert(p,\
    \ planet2)\n        table.insert(p, planet1)\n        table.insert(p, planet2)\n\
    \        table.insert(p, planet1)\n        table.insert(p, planet2)\n        table.insert(p,\
    \ planet1)\n        table.insert(p, planet2)\n        table.insert(p, planet1)\n\
    \        table.insert(p, planet2)\n        table.insert(p, planet1)\n        table.insert(p,\
    \ planet2)\n        table.insert(p, planet1)\n        table.insert(p, planet2)\n\
    \        table.insert(p, planet1)\n        table.insert(p, planet2)\n        table.insert(p,\
    \ planet1)\n        table.insert(p, planet2)\n        table.insert(p, planet1)\n\
    \        table.insert(p, planet2)\n        table.insert(p, planet1)\n        table.insert(p,\
    \ planet2)\n        table.insert(p, planet1)\n        table.insert(p, planet2)\n\
    \        table.insert(p, planet1)\n        table.insert(p, planet2)\n        table.insert(p,\
    \ planet1)\n", "    local orb1, orb2 = system.GetOrbitalElements(planet1, planet2)\n\
    \    local sun1, sun2 = system.GetPlanetFromName(system.GetSun())", "    local\
    \ a, b, c = {}, {}, {}\n    local distances = {}\n    for i, v in pairs(planets)\
    \ do\n        if v == planet1 then\n            table.insert(a, v)\n        elseif\
    \ v == planet2 then\n            table.insert(b, v)\n        else\n          \
    \  table.insert(c, v)\n        end\n        distances[v] = math.sqrt((planets[v].x\
    \ - sun.x) * (planets[v].x - sun.x) \n                                    + (planets[v].y\
    \ - sun.y) * (planets[v].y - sun.y) \n                                    + (planets[v].z\
    \ - sun.z) * (planets[v].z - sun.z))\n    end\n    table.sort(a)\n    table.sort(b)\n\
    \    table.sort(c)\n    \n    local distance1, distance2 = {}, {}\n    for i =\
    \ 1, #a do\n        distance1[a] = distances[a]\n    end\n    for i = 1, #b do\n\
    \        distance2[b] = distances[b]\n    end\n    \n    for i = 1, #a do\n  \
    \      if distance1[a] < distance2[b] then\n            return a\n        end\n\
    \    end\n    return c\nend", "\tlocal sun = GetSun()\n\tlocal planet1_orbit,\
    \ planet1_orbit_ra, planet1_orbit_dec = GetOrbit(planet1)\n\tlocal planet2_orbit,\
    \ planet2_orbit_ra, planet2_orbit_dec = GetOrbit(planet2)\n\t\n\tif IsInRange(sun,\
    \ planet1_orbit, planet2_orbit)\n\tthen\n\t\tlocal sdist = GetDistance(sun, planet1_orbit)\n\
    \t\tlocal odist = GetDistance(sun, planet2_orbit)\n\t\tlocal proximity = sdist\
    \ + odist\n\t\treturn {\n\t\t\tsdist,\n\t\t\todist,\n\t\t\tproximity,\n\t\t\t\
    GetProximity(planet1_orbit, planet2_orbit, sun),\n\t\t\tGetProximity(planet1_orbit_ra,\
    \ planet2_orbit_ra, sun),\n\t\t\tGetProximity(planet1_orbit_dec, planet2_orbit_dec,\
    \ sun)\n\t\t}\n\tend\n\t\n\treturn nil, nil, nil, nil, nil, nil, nil\nend", " \
    \   local list1 = tonumber(os.date(\"*t\"))\n    local list2 = tonumber(os.date(\"\
    *t\"))\n    list1.year = 1\n    list2.year = 1\n    list1.month = 1\n    list2.month\
    \ = 1\n    list1.day = 24\n    list2.day = 24\n    list1.hour = 0\n    list2.hour\
    \ = 0\n    list1.min = 0\n    list2.min = 0\n    list1.sec = 0\n    list2.sec\
    \ = 0\n    list1.wday = 6\n    list2.wday = 0\n    list1.yday = 29582\n    list2.yday\
    \ = 0\n    list1.isdst = nil\n    list2.isdst = nil\n    list1.zone = \"MIST\"\
    \n    list2.zone = \"MIST\"\n    list1.gmtoff = 0\n    list2.gmtoff = 0\n    list1.utc\
    \ = 0\n    list2.utc = 0\n    list1.dst = nil\n    list2.dst = nil\n    list1.yday\
    \ = 1\n    list2.yday = 1\n    list1.era = nil\n    list2.era = nil\n    list1.leap_year\
    \ = nil\n    list2.leap_year = nil\n    list1.epoch = nil\n    list2.epoch = nil\n\
    \    list1.year = 1\n    list2.year = 1\n    list1.month = 1\n    list2.month\
    \ = 1\n    list1.day = 24\n    list2.day = 24\n    list1.hour = 0\n    list2.hour\
    \ = 0\n    list1.min = 0\n    list2.min = 0\n    list1.sec = 0\n    list2.sec\
    \ = 0\n    list1.wday = 6\n    list2.wday = 0\n    list1.yday = 29582\n    list2.yday\
    \ = 0\n    list1.isdst = nil\n    list2.isdst = nil\n    list1.zone = \"MIST\"\
    \n    list2.zone = \"MIST\"\n    list1.gmtoff = 0\n    list2.gmtoff = 0\n    list1.utc\
    \ = 0\n    list2.utc = 0\n    list1.dst = nil\n    list2.dst = nil\n    list1.yday\
    \ = 1\n    list2.yday = 1\n    list1.era = nil\n    list2.era = nil\n    list1.leap_year\
    \ = nil\n    list2.leap_year = nil\n    list1.epoch = nil\n    list2.epoch = nil\n\
    \    local list1 = os.date(\"*t\")\n    local list2 = os.date(\"*t", "  -- Check\
    \ input\n  if planet1 == nil or planet2 == nil then\n    print(\"Error in bf(planet1,\
    \ planet2) function call\")\n    return nil\n  elseif typeof(planet1) ~= 'string'\
    \ or typeof(planet2) ~= 'string' then\n    print(\"Error in bf(planet1, planet2)\
    \ function call\")\n    return nil\n  elseif planet1 == planet2 then\n    return\
    \ nil\n  else\n    local orbits1, orbits2 = {}, {}\n    -- orbits1 contains the\
    \ planets orbiting planet1\n    orbits1[#orbits1 + 1] = {planet1}\n    -- orbits2\
    \ contains the planets orbiting planet2\n    orbits2[#orbits2 + 1] = {planet2}\n\
    \    -- Iterate through orbits1 \n    for _, x in ipairs(orbits1) do\n      --\
    \ Iterate through orbits2 \n      for _, y in ipairs(orbits2) do\n        -- Check\
    \ if planets orbiting each other are on or near the Sun\n        if distance(x,\
    \ y, SUN) > DISTANCE then\n          -- If so, remove them from the orbits\n \
    \         table.remove(orbits1, x)\n          table.remove(orbits2, y)\n     \
    \     -- If there are still orbits to iterate through, we're done\n          if\
    \ #orbits1 > 0 then\n            -- Continue iterating\n            continue\n\
    \          else\n            -- We're done\n            return orbits2\n     \
    \     end\n        end\n      end\n    end\n    -- We couldn't find any orbits,\
    \ so return empty tuple\n    return {}\n  end\nend", "    return ()\nend", " \
    \   -- Your code here\n    local mercury, venus, earth, mars, jupiter, saturn,\
    \ uranus, neptune = \n        math.modf(4 * math.pi * math.sqrt((mercury-venus)^2+(venus-earth)^2+(earth-mars)^2+(mars-jupiter)^2+(jupiter-saturn)^2+(saturn-uranus)^2+(uranus-neptune)^2))\n\
    \    \n    if math.abs(mercury - venus)<math.abs(earth -mars) then\n        if\
    \ math.abs(mercury - venus)<math.abs(earth - jupiter) then\n            if math.abs(mercury\
    \ - venus)<math.abs(earth - saturn) then\n                if math.abs(mercury\
    \ - venus)<math.abs(earth - uranus) then\n                    if math.abs(mercury\
    \ - venus)<math.abs(earth - neptune) then\n                        local bf =\
    \ (\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"\
    ,\"Neptune\")\n                        return (bf[math.abs(mercury-venus)], bf[math.abs(earth\
    \ -mars)], bf[math.abs(earth-jupiter)], bf[math.abs(earth-saturn)], bf[math.abs(earth-uranus)],\
    \ bf[math.abs(earth-neptune)])\n                    end\n                end\n\
    \            end\n        end\n    end\n    \n    \nend", "  if planet1 ~= planet2\
    \ then\n    return nil\n  end\n  local a, b, c\n  local i = 2\n  local orb = {}\n\
    \  local sun = sun(planet1)\n  while i <= 7 do\n    local planet = planets[i -\
    \ 2]\n    if sun == sun(planet) then\n      a = i - 1\n      b = i - 2\n     \
    \ c = i - 3\n      break\n    end\n    i = i + 1\n  end\n  local dist = distance(planets[a],\
    \ planets[b])\n  if dist > sun then\n    local dist = distance(planets[a], planets[c])\n\
    \    if dist > sun then\n      local dist = distance(planets[b], planets[c])\n\
    \      if dist > sun then\n        local dist = distance(planets[a], planets[b])\n\
    \        if dist > sun then\n          local dist = distance(planets[a], planets[c])\n\
    \          if dist > sun then\n            local dist = distance(planets[b], planets[c])\n\
    \            if dist > sun then\n              orb[1] = planets[a]\n         \
    \     orb[2] = planets[b]\n              orb[3] = planets[c]\n            end\n\
    \          end\n        end\n      end\n    end\n  end\n  if orb[1] ~= nil and\
    \ orb[2] ~= nil and orb[3] ~= nil then\n    table.sort(orb, function(a, b) return\
    \ distance(a, sun) - distance(b, sun) end)\n    return orb[1]\n  else\n    return\
    \ nil\n  end\nend", "    local function orbit(pl1, pl2)\n        return tonumber(pl1)\
    \ * (tonumber(pl2) - tonumber(pl1)) + tonumber(pl2)\n    end\n    local function\
    \ distance(planet1, planet2)\n        return abs(orbit(planet1, planet2) - planet1)\
    \ * planet2\n    end\n    \n    local function sortPlanets(pl1, pl2)\n       \
    \ return distance(pl1, pl2) / distance(pl1, planet1)\n    end\n    \n    local\
    \ distance = {}\n    \n    distance[planet1]=distance(planet2, planet1)\n    distance[planet2]=distance(planet1,\
    \ planet2)\n    \n    for i=1,8 do\n        if distance[planet1] ~= distance[planet2]\
    \ then\n            distance[planet2] = distance[planet1]\n        elseif distance[planet1]\
    \ > distance[planet2] then\n            distance[planet1] = distance[planet2]\n\
    \        end\n    end\n    \n    return table.sort(distance)\nend", "    local\
    \ planet1orbit = orbits[planet1]\n    local planet2orbit = orbits[planet2]\n \
    \   local sunorbit = orbits[\"Sun\"]\n    if planet1orbit == nil or planet2orbit\
    \ == nil or sunorbit == nil then return nil end\n    local distance = math.sqrt(\
    \ (planet1orbit.x - sunorbit.x) * (planet1orbit.x - sunorbit.x) +\n          \
    \                      (planet1orbit.y - sunorbit.y) * (planet1orbit.y - sunorbit.y)\
    \ +\n                                (planet1orbit.z - sunorbit.z) * (planet1orbit.z\
    \ - sunorbit.z) )\n    local orbit1, orbit2 = {}, {}\n    for i = 1, #planet1orbit\
    \ do\n        orbit1[i] = { x = planet1orbit[i].x, y = planet1orbit[i].y, z =\
    \ planet1orbit[i].z }\n    end\n    for i = 1, #planet2orbit do\n        orbit2[i]\
    \ = { x = planet2orbit[i].x, y = planet2orbit[i].y, z = planet2orbit[i].z }\n\
    \    end\n    return table.sort(orbit1, function(a,b) math.sqrt( (a.x - b.x)^2\
    \ + (a.y - b.y)^2 + (a.z - b.z)^2 ) end),\n           table.sort(orbit2, function(a,b)\
    \ math.sqrt( (a.x - b.x)^2 + (a.y - b.y)^2 + (a.z - b.z)^2 ) end)\nend\n</code>\n\
    <|/ a tags=lua,lua-table,sorting dscore=1 |>\n<| c |>\nThe code is a bit confused\
    \ at the moment, but I guess you've been on the right track. If I understand your\
    \ problem correctly, this approach only solves the case in which two planets are\
    \ within a small distance of each other. I assume that the OP wants to solve the\
    \ case in which a planet is within 100 AU or more of the sun (or something along\
    \ these lines).\n<|/ c |>\n<| c |>\nyeah that's right but the thing is we didn't\
    \ learn the math.sqrt and math.abs functions. So I guess we have to do it the\
    \ hard way. I'll definitely look into those functions. Thank you so much for taking\
    \ your time to help me!\n<|/ c |>\n<| c |>\nIt would be great if you could help\
    \ me with my second problem if you have time. I can't seem to figure it out on\
    \ my own. I have to find the planets that are within 100 AU of the sun on the\
    \ planet graph. I have a function that finds the closest point on the graph but\
    \ it is not work", "  local planet1, planet2 = string.lower(planet1), string.lower(planet2)\n\
    \  local pl1, pl2 = string.find(planet1, \" \"), string.find(planet2, \" \")\n\
    \  local planet1, planet2, sun, earth = string.sub(planet1, pl1, pl2), string.sub(planet2,\
    \ pl1, pl2)\n  if pl1 > 0 then\n    sun = string.sub(planet1, 1, pl1)\n  end\n\
    \  if pl2 > 0 then\n    earth = string.sub(planet2, 1, pl2)\n  end\n  if sun ==\
    \ nil then sun = \"sun\" end\n  if earth == nil then earth = \"earth\" end\n \
    \ sun, earth = string.lower(sun), string.lower(earth)\n  local planetsBetweenSun,\
    \ planetsBetweenEarth\n  local posSun, posEarth\n  local p1, p2\n  local pl1,\
    \ pl2, pl3, pl4\n  local p3, p4, p5, p6\n  local p7, p8, p9, p10\n  local p11,\
    \ p12, p13, p14\n  local p15, p16, p17, p18\n  local p19, p20, p21, p22", "  \
    \  if planet1 == \"Mercury\" then \n        return bf(\"Uranus\", planet2) \n\
    \    end\n    if planet1 == \"Venus\" then \n        return bf(\"Earth\", planet2)\n\
    \    end\n    if planet1 == \"Earth\" then \n        return bf(\"Mars\", planet2)\n\
    \    end\n    if planet1 == \"Mars\" then \n        return bf(\"Jupiter\", planet2)\n\
    \    end\n    if planet1 == \"Jupiter\" then \n        return bf(\"Saturn\", planet2)\n\
    \    end\n    if planet1 == \"Saturn\" then \n        return bf(\"Uranus\", planet2)\n\
    \    end\n    if planet1 == \"Uranus\" then \n        return bf(\"Neptune\", planet2)\n\
    \    end\n    if planet1 == \"Neptune\" then \n        return bf(\"Mercury\",\
    \ planet2)\n    end\n    return ()\nend", "  local planet1orbs = find_orbits(planet1)\n\
    \  local planet2orbs = find_orbits(planet2)\n  local planets = planet1orbs:merge(planet2orbs)\n\
    \  local sun = find_sun()\n  local result = {}\n  for i,planet in ipairs(planets)\
    \ do\n    local distance = distance(sun, planet)\n    if distance <= 1.5 then\
    \ -- We consider orbits on the sun \n      table.insert(result, planet)\n    end\n\
    \  end\n  table.sort(result)\n  return result\nend\n</code>\n<|/ a dscore=1 tags=lua-table,lua,lua-patterns,lua-api\
    \ |>\n<| c |>\nThank you for all the help! I ended up fixing it myself using another\
    \ function that was similar to the one you wrote up there. After I solved the\
    \ problem I did get back to posting this question and you were a big help.\n<|/\
    \ c |>\n<| a tags=lua-table,lua,lua-patterns,lua-api |>\nI've made my own program\
    \ with some help from your answers and this solved my problem. Thank you!\n<code>",
  "\tlocal s1,s2,o1,o2,m,a,b,e,i,h1,h2,m1,m2,m3,e1,e2,i1,i2,d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16,d17\n\
    \tlocal j=0\n\tif planet1 == \"Earth\" or planet2 == \"Earth\" then\n\t\treturn(())\n\
    \telseif planet1 == \"Mercury\" or planet2 == \"Mercury\" then\n\t\treturn((\"\
    Earth\", \"Venus\"))\n\telseif planet1 == \"Venus\" or planet2 == \"Venus\" then\n\
    \t\treturn((\"Earth\", \"Mars\"))\n\telseif planet1 == \"Mars\" or planet2 ==\
    \ \"Mars\" then\n\t\treturn((\"Earth\", \"Jupiter\", \"Saturn\"))\n\telseif planet1\
    \ == \"Jupiter\" or planet2 == \"Jupiter\" then\n\t\treturn((\"Earth\", \"Mercury\"\
    , \"Saturn\"))\n\telseif planet1 == \"Saturn\" or planet2 == \"Saturn\" then\n\
    \t\treturn((\"Earth\", \"Mercury\", \"Uranus\"))\n\telseif planet1 == \"Uranus\"\
    \ or planet2 == \"Uranus\" then\n\t\treturn((\"Earth\", \"Mercury\", \"Neptune\"\
    ))\n\telseif planet1 == \"Neptune\" or planet2 == \"Neptune\" then\n\t\treturn((\"\
    Earth\", \"Mercury\", \"Venus\"))\n\telse\n\t\terror(\"Planet name not correct\"\
    )\n\tend\n\tlocal h=math.atan(math.sin(planet1)/math.sin(planet2))\n\tlocal m=math.cos(planet1)*math.cos(planet2)*math.sin(planet1)+math.cos(planet1)*math.sin(planet2)*math.sin(planet1)*math.cos(planet2)\n\
    \tlocal e=math.acos(math.sin(planet1)*math.sin(planet2)+math.cos(planet1)*math.cos(planet2)*math.cos(planet1-planet2))\n\
    \tlocal i1=math.atan(math.sin(planet1)/math.sin(planet2))\n\tlocal i2=math.atan(math.sin(planet2)/math.sin(planet1))\n\
    \tlocal d1=math.cos(planet1)*math.cos(planet2)*math.cos(h-planet1)+math.sin(planet1)*math.sin(planet2)*math.sin(h-planet1)\n\
    \t", "\tlocal planet1 = planet1 .. \"_\" .. planet2\n\tlocal planet2 = planet2\
    \ .. \"_\" .. planet1\n\tlocal planet1_orbit = planet1\n\tlocal planet2_orbit\
    \ = planet2\n\tlocal san_orbit = planet1 .. \"_\" .. \"sun\"\n\tlocal earth =\
    \ planet1 .. \"_\" .. \"earth\"\n\tlocal mercury = planet1 .. \"_\" .. \"mercury\"\
    \n\tlocal venus = planet1 .. \"_\" .. \"venus\"\n\tlocal mars = planet1 .. \"\
    _\" .. \"mars\"\n\tlocal jupiter = planet1 .. \"_\" .. \"jupiter\"\n\tlocal saturn\
    \ = planet1 .. \"_\" .. \"saturn\"\n\tlocal uranus = planet1 .. \"_\" .. \"uranus\"\
    \n\tlocal neptune = planet1 .. \"_\" .. \"neptune\"\n\tlocal sun_or_earth_or_mercury_or_venus_or_saturn\
    \ = sun_or_earth_or_mercury_or_venus_or_saturn\n\tlocal planet_orbit\n\tlocal\
    \ orbit_distance", "\tlocal planet1_orbit_position = {}\n\tlocal planet2_orbit_position\
    \ = {}\n\tlocal sun_position_x = math.rad(math.pi/4)\n\tlocal sun_position_y =\
    \ math.rad(math.pi/2)", "    local function distance(planet1, planet2)\n     \
    \   -- This function returns the distance between the planets. \n        -- (This\
    \ code is not yet complete!)\n        -- If planet1 is bigger than planet2, the\
    \ function should return \n        -- -1 otherwise it should return the difference\
    \ in kilometers.\n        -- Example\n        --\n        -- distance(\"Mars\"\
    ,\"Earth\")   ==>  5\n        -- distance(\"Mars\",\"Jupiter\") ==>  5\n     \
    \   --\n        -- distance(planet1, planet2)   ==>  -1\n        -- distance(planet1,\
    \ planet2)   ==>  6\n        -- distance(planet2, planet1)   ==>  6\n        --\n\
    \        -- distance(planet1, planet2)   ==>  6\n        -- distance(planet2,\
    \ planet1)   ==>  -1\n        -- distance(planet1, planet2)   ==>  -1\n      \
    \  --\n        -- distance(planet1, planet2)   ==>  6\n        -- distance(planet2,\
    \ planet1)   ==>  -1\n        -- distance(planet1, planet2)   ==>  -1\n      \
    \  --\n        -- distance(planet1, planet2)   ==>  -1\n        -- distance(planet2,\
    \ planet1)   ==>  -1\n        -- distance(planet1, planet2)   ==>  -1\n    end\n\
    \    \n    -- This code is not yet complete!\n    -- If planet1 and planet2 are\
    \ not correct planet names, return empty \n    -- tuple like in the example above.\n\
    \    \n    local orbit1 = getOrbit(planet1)\n    local orbit2 = getOrbit(planet2)\n\
    \    \n    local distance = distance(planet1, planet2)\n    \n    local output\
    \ = {}\n    \n    -- TODO: iterate through all orbits and return all planets which\
    \ are \n    -- located between these two planets (orbits or distances).\n    \n\
    \    -- TODO: Sort the planets according to distance to the sun. \n    -- The\
    \ planets should be sorted according to the distance to the sun \n    -- closest\
    \ to first.\n    return output\nend", "\tif planet1 ~= planet2 or planet1 == \"\
    Earth or Mars\" or planet2 == \"Earth or Mars\" or planet1 == \"Mercury\" or planet2\
    \ == \"Mercury\" then return end\n\treturn (\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\nend\n</cell>\n\
    <text>\nPart Two\nConsider the function is_close_to_sun. This function takes two\
    \ planet names as strings as arguments.\nThe function returns true if the planet\
    \ is located between their orbits (if their distance\nto the sun is less than\
    \ some cutoff value), and returns false otherwise.", "  local M1 = tonumber(planet1)\n\
    \  local M2 = tonumber(planet2)\n  \n  if M1 < 0 then return \"Wrong planet name!\"\
    \ end\n  if M2 < 0 then return \"Wrong planet name!\" end\n  \n  local d\n  if\
    \ M1 < M2 then\n    d = (M1-M2)/(M2+M1)\n  else\n    d = (M1-M2)/(M1+M2)\n  end\n\
    \  \n  local Rd = math.pow( math.sin( math.deg(math.acos(d)) ), 2)\n  \n  local\
    \ d1, d2 = math.pow(math.acos(d), 2), math.pow(d,2)\n  \n  local M1, M2 = math.pow(M2,\
    \ 2), math.pow(M1, 2)\n  \n  local S1, S2 = M1/Rd, M2/Rd\n  \n  if S2 > S1 then\n\
    \    if d1 > d2 then\n      local d = math.pow(d1, 2)\n      \n      if math.abs(d)\
    \ > math.abs(S1-S2) then\n        local t = (S1-S2)/(math.pow(d1,2)+math.pow(d2,2))\n\
    \        return (\"Earth\", \"Mars\")\n      else\n        local t = math.abs(d1-d2)/math.sqrt(math.pow(d1,2)+math.pow(d2,2))\n\
    \        return (\"Earth\", \"Mars\")\n      end\n    elseif d1 < d2 then\n  \
    \    local d = math.pow(d2,2)\n      \n      if math.abs(d) > math.abs(S1-S2)\
    \ then\n        local t = (S1-S2)/(math.pow(d1,2)+math.pow(d2,2))\n        return\
    \ (\"Earth\", \"Mars\")\n      else\n        local t = math.abs(d1-d2)/math.sqrt(math.pow(d1,2)+math.pow(d2,2))\n\
    \        return (\"Earth\", \"Mars\")\n      end\n    else\n      if d1 > d2 then\n\
    \        local t = math.abs(S2-S1)/math.sqrt(math.pow(d1,2)+math.pow(d2,2))\n\
    \        return (\"Saturn\", \"Uranus\")\n      else\n        local t = math.abs(S1-S2)/math.sqrt(math.pow(d1,2)+math.pow(d2,2))\n\
    \        return (\"Saturn\", \"Uranus\")\n      end\n    end\n  elseif S2 < S1\
    \ then\n    if d1 > d2 then\n      local t = math.abs(S2-S1)/math.sqrt(math.pow(d1,2)+math.pow(d2,2))\n\
    \      return (\"Saturn\", \"Uranus\")\n    elseif d", "    return \nend", " \
    \ -- TODO: write your code here\nend", "  local planet1name = planet1.name\n \
    \ local planet2name = planet2.name\n  local planet1orbits = planet1.orbits\n \
    \ local planet2orbits = planet2.orbits\n  local sunorbit = math.pi/3\n  local\
    \ newplanets = {}\n  for i = 1, #planet1orbits do\n    local planet1orbit = planet1orbits[i]\n\
    \    for j = 1, #planet2orbits do\n      local planet2orbit = planet2orbits[j]\n\
    \      local dist = math.acos(math.sin(planet1orbit.pos)*math.sin(planet2orbit.pos)+math.cos(planet1orbit.pos)*math.cos(planet2orbit.pos)*math.cos(planet1orbit.vel-planet2orbit.vel))\n\
    \      if dist < sunorbit then\n        newplanets[#newplanets+1] = {\n      \
    \    name = planet1name .. ' vs ' .. planet2name,\n          pos = planet1orbit.pos\
    \ + planet2orbit.pos/dist*sunorbit,\n          vel = planet1orbit.vel + planet2orbit.vel/dist*sunorbit,\n\
    \          orbit = {\n            pos = {x = planet1orbit.pos, y = planet1orbit.vel,\
    \ z = planet1orbit.pos},\n            vel = {x = planet2orbit.vel, y = planet2orbit.vel,\
    \ z = planet2orbit.vel}\n          }\n        }\n      end\n    end\n  end\n \
    \ return newplanets\nend", "\tlocal planets = {}\n\tlocal sun = math.pi/2 - math.acos((math.cos(planet1)\
    \ +\n\t\tmath.cos(planet2))*math.cos(math.pi/2 - math.acos(\n\t\t(math.cos(planet1)+math.cos(planet2))\
    \ *\n\t\tmath.cos(math.pi/2 - math.acos((math.cos(planet1)+math.cos(planet2))\
    \ *\n\t\tmath.cos(math.pi/2 - math.acos((math.cos(planet1)+math.cos(planet2)))))))\n\
    \tfor i = 1, 8 do\n\t\tlocal dsun = math.acos(math.cos(planet1) +\n\t\t\tmath.cos(planet2))\
    \ *\n\t\tmath.cos(math.pi/2 - math.acos((math.cos(planet1)+math.cos(planet2))\
    \ *\n\t\tmath.cos(math.pi/2 - math.acos((math.cos(planet1)+math.cos(planet2)))))))\n\
    \t\tlocal distance = math.acos(dsun - sun)\n\t\tlocal index = distance*2 - 1\n\
    \t\tlocal x = math.cos(math.pi/2-dsun)*math.cos(math.pi/2-sun)\n\t\tlocal y =\
    \ math.cos(math.pi/2-dsun)*math.sin(math.pi/2-sun)\n\t\tlocal z = math.sin(math.pi/2-dsun)\n\
    \t\tif distance < 1 then\n\t\t\ttable.insert(planets, {name, index})\n\t\tend\n\
    \tend\n\treturn planets\nend", "  -- Create a list to store the results\n  local\
    \ results = {}\n  -- Create a list to store all planets of which we know the orbit\n\
    \  local knownPlanets = {}\n  -- Create a list to store the orbits of the two\
    \ planets\n  local orbit1\n  local orbit2\n  -- Iterate over the planets\n  for\
    \ planet1, orbit1 in pairs(orbits) do\n    -- Iterate over the planets of the\
    \ second planet\n    for planet2, orbit2 in pairs(orbits[planet1]) do\n      --\
    \ If the orbits are the same and the distance is smaller than\n      -- some threshold,\
    \ store them in the results list\n      if orbit1 == orbit2 and distance(orbit1,\
    \ orbit1) < thresholds[planet1] then\n        results[#results + 1] = planet2\n\
    \        -- Add the planet to the known planets list\n        table.insert(knownPlanets,\
    \ planet1)\n      end\n    end\n  end\n  return results, knownPlanets\nend", " \
    \ local planets = { [\"Mercury\"] = 2, [\"Venus\"] = 3, [\"Earth\"] = 4, \n\t\t\
    \t\t\t [\"Mars\"] = 3, [\"Jupiter\"] = 5, [\"Saturn\"] = 6, \n\t\t\t\t\t [\"Uranus\"\
    ] = 7, [\"Neptune\"] = 8 }\n  if planet1 == nil or planet2 == nil then\n    return\
    \ {}\n  elseif planets[planet1] == nil then\n    return {}\n  elseif planets[planet2]\
    \ == nil then\n    return {}\n  else\n    return { planet1, planet2, \n\t\t\t\
    \ planets[planet1], planets[planet2], \n\t\t\t planets[planet1], planets[planet1],\
    \ \n\t\t\t planets[planet1], planets[planet2] }\n  end\nend", "\tlocal function\
    \ calcDist(planet1, planet2)\n\t\tlocal planet1_orbit_sun, planet2_orbit_sun =\
    \ orbit_sun(planet1), orbit_sun(planet2)\n\t\tlocal dist1 = distance(planet1_orbit_sun,\
    \ planet2_orbit_sun)\n\t\tlocal dist2 = distance(planet2_orbit_sun, planet1_orbit_sun)\n\
    \t\treturn dist1, dist2\n\tend\n\tlocal orbits = {[planet1]=orbit_sun(planet1),\
    \ [planet2]=orbit_sun(planet2)}\n\tlocal sortfunc = sort\n\tif sortfunc ~= nil\
    \ then\n\t\tfor i=1,#planets do\n\t\t\tlocal planet = planets[i]\n\t\t\tif planet\
    \ ~= planet1 and planet ~= planet2 then\n\t\t\t\tlocal dist1, dist2 = calcDist(planet,\
    \ planet2)\n\t\t\t\tif dist1 < dist2 then\n\t\t\t\t\ttable.insert(orbits, planet)\n\
    \t\t\t\telse\n\t\t\t\t\ttable.insert(orbits, planet2)\n\t\t\t\tend\n\t\t\tend\n\
    \t\tend\n\t\tsortfunc = sortfunc\n\tend\n\treturn table.sort(orbits, sortfunc)\n\
    end", "\tlocal Sun = GetSun()\n\tlocal MercuryCoords = SolarPosition(planet1)\n\
    \tlocal VenusCoords = SolarPosition(planet2)\n\tlocal EarthCoords = SolarPosition(planet1)\n\
    \tlocal MercuryDistance = Distance(MercuryCoords, Sun)\n\tlocal VenusDistance\
    \ = Distance(VenusCoords, Sun)\n\tlocal EarthDistance = Distance(EarthCoords,\
    \ Sun)\n\tif MercuryDistance < VenusDistance and MercuryDistance < EarthDistance\
    \ then\n\t\treturn (planet1, planet2)\n\telseif VenusDistance < MercuryDistance\
    \ and VenusDistance < EarthDistance then\n\t\treturn (planet2, planet1)\n\telseif\
    \ EarthDistance < MercuryDistance and EarthDistance < VenusDistance then\n\t\t\
    return (planet1, planet2)\n\telse\n\t\treturn ()\n\tend\nend", "\tlocal sunOrbit\
    \ = math.rad(2*math.pi/8)\n\tlocal orbits = {}\n\tlocal earthOrbit = math.rad(-math.pi/4)\n\
    \tlocal sun = {\n\t\trad = math.rad(0),\n\t\tradius = math.rad(696),\n\t\tperiod\
    \ = math.rad(696000),\n\t\tdistance = math.rad(40000)\n\t}\n\torbits[\"Sun\"]\
    \ = sun\n\t\n\tif planet1 == planet2 then\n\t\treturn {}\n\tend", "   local p1\
    \ = string.match(planet1, \"^([A-Za-z]{3})$\")\n   local p2 = string.match(planet2,\
    \ \"^([A-Za-z]{3})$\")\n   if not (p1 and p2) or p1 ~= p2 then return end\n  \
    \ local planet1orbit = getOrbit(planet1)\n   local planet2orbit = getOrbit(planet2)\n\
    \   return \n      (planet1orbit[2] < planet2orbit[2])\n         and \n      \
    \   (planet1orbit[2] < planet2orbit[2])\n         or\n         (planet1orbit[2]\
    \ > planet2orbit[2])\n         and\n         (planet1orbit[1] < planet2orbit[1])\n\
    \         and \n         (planet1orbit[1] > planet2orbit[1])\n         and\n \
    \        (planet1orbit[0] < planet2orbit[0])\n         and\n         (planet1orbit[0]\
    \ > planet2orbit[0])\nend", "  -- TODO\n  return ()\nend", "   if planet1 ~= planet2\
    \ then\n      if get_planet_position(planet1).rad ~= get_planet_position(planet2).rad\
    \ then\n         return ()\n      elseif get_planet_position(planet2).rad == get_planet_position(planet1).rad\
    \ then\n         return get_planet_position(planet1).rad \n      else\n      \
    \   local xs = get_planet_position(planet1).rad + get_planet_position(planet2).rad\n\
    \         return sort(xs,xs)\n      end\n   else\n      return ()\n   end\nend",
  "\tlocal mercury = {distance = 1.4142, name = \"Mercury\", orbits = {}, distanceToSun\
    \ = 6.0908, orbit = {x = -0.007045864178855257, y = 0.00677154496725671, z = 0.996729272439468,\
    \ radius = 0.401060506033172}} \n\tlocal venus = {distance = 0.9992, name = \"\
    Venus\", orbits = {}, distanceToSun = 9.5735, orbit = {x = 0.00677154496725671,\
    \ y = -0.007045864178855257, z = -0.996729272439468, radius = 0.401060506033172}}\
    \ \n\tlocal earth = {distance = 0.9962, name = \"Earth\", orbits = {}, distanceToSun\
    \ = 10.435, orbit = {x = -0.00677154496725671, y = 0.00677154496725671, z = -0.996729272439468,\
    \ radius = 0.401060506033172}} \n\tlocal mars = {distance = 0.9989, name = \"\
    Mars\", orbits = {}, distanceToSun = 11.172, orbit = {x = 0.00677154496725671,\
    \ y = -0.00677154496725671, z = -0.996729272439468, radius = 0.401060506033172}}\
    \ \n\tlocal jupiter = {distance = 1.01, name = \"Jupiter\", orbits = {}, distanceToSun\
    \ = 11.978, orbit = {x = -0.00677154496725671, y = -0.00677154496725671, z = -0.996729272439468,\
    \ radius = 0.401060506033172}} \n\tlocal saturn = {distance = 1.09, name = \"\
    Saturn\", orbits = {}, distanceToSun = 13.611, orbit = {x = -0.00677154496725671,\
    \ y = -0.00677154496725671, z = -0.996729272439468, radius = 0.401060506033172}}\
    \ \n\tlocal uranus = {distance = 1.123, name = \"Uranus\", orbits = {}, distanceToSun\
    \ = 14.171, orbit = {x = -0.00677154496725671, y = -0.00677154496725671, z = -0.996729272439468,\
    \ radius = 0.401060506033172}} \n\tlocal neptune = {distance = 1.2, name = \"\
    Neptune", "   if planet1 == planet2 then\n      return (planet1, planet2)\n  \
    \ end\n   local sun = find_sun(planet1, planet2)\n   if sun then\n      local\
    \ sun1 = find_sun(planet2, planet1)\n      if sun1 then\n         if find_distance(sun,\
    \ sun1) <= find_distance(sun1, sun) then\n            return bf(sun1, sun)\n \
    \        else\n            return (sun1, sun)\n         end\n      else\n    \
    \     return (sun)\n      end\n   else\n      return (planet1, planet2)\n   end\n\
    end", "  if planet1 == planet2 then\n    return ()\n  end", "  -- Your code here\n\
    \  \n  if planet1 == planet2 then return (planet1, planet2)\n  elseif planet1\
    \ ~= planet2 then return () end", "    if planet1 ~= pln1 and planet2 ~= pln2\
    \ then\n        return nil\n    end\n    local l1 = pln1:lower()\n    local l2\
    \ = pln2:lower()\n    local s1,s2,e1,e2,m1,m2,j1,j2,n1,n2,u1,u2,i1,i2,o1,o2 =\
    \ \n        sun, earth, natural, observer, mercury, venus, earth, mars, jupiter,\n\
    \        saturn, uranus, neptune, venus, earth, mercury, venus, mars, jupiter,\n\
    \        saturn, uranus, neptune, mars, jupiter, saturn, uranus, neptune, \n \
    \       mercury, venus, earth, mars, jupiter, saturn, uranus, neptune, \n    \
    \    mercury, venus, earth, mars, jupiter, saturn, uranus, neptune\n    local\
    \ orb1 = orbs[l1]\n    local orb2 = orbs[l2]\n    local p1 = plns\n    local p2\
    \ = plns\n    if l1 == l2 then\n        p1,p2 = p2, p1\n    end\n    local t1,t2,o,o1,o2\
    \ = p1:range( 1,9 ), p2:range(1,9), o,orb1,orb2\n    for k in pairs(t1) do\n \
    \       if k:find( s1 ) then\n            o1 = o1-1\n        end\n    end\n  \
    \  for k in pairs(t2) do\n        if k:find( s2 ) then\n            o2 = o2-1\n\
    \        end\n    end\n    local o1 = math.abs(o1)\n    local o2 = math.abs(o2)\n\
    \    if o1 > o2 then\n        return o1, o2\n    else\n        return o2, o1\n\
    \    end\nend", "\tif pln1_orbs[planet1] then\n\t\tif pln2_orbs[planet2] then\n\
    \t\t\treturn {\n\t\t\t\tpln1, pln2,\n\t\t\t\tmath.abs((pln1_orbs[planet1] - pln2_orbs[planet2]))\
    \ \n\t\t\t}\n\t\telse\n\t\t\treturn {\n\t\t\t\tpln1,\n\t\t\t\tpln2,\n\t\t\t\t\
    math.abs(pln1_orbs[planet1] - sun_pos)\n\t\t\t}\n\t\tend\n\telse\n\t\treturn {\n\
    \t\t\tpln2,\n\t\t\tpln1,\n\t\t\tmath.abs(sun_pos - pln2_orbs[planet1])\n\t\t}\n\
    \tend\nend", "  -- your code here\nend", "    local planets = {}\n    for i=1,#solar\
    \ do\n        if math.abs(orbit[solar[i]] - orbit[planet1]) < math.abs(orbit[solar[i]]\
    \ - orbit[planet2]) then\n            table.insert(planets, solar[i])\n      \
    \  end\n    end\n    table.sort(planets, function(a,b) return distance[planet1][planet2]\
    \ < distance[planet1][b] and distance[planet1][a] > distance[planet1][b] end)\n\
    \    return planets\nend", "    local dist\n    local pos1\n    local pos2\n \
    \   \n    pos1 = getPos(planet1)\n    pos2 = getPos(planet2)\n    \n    if pos1\
    \ == nil or pos2 == nil then return end", "   if planet1 == planet2 then\n   \
    \   return ()\n   end\n   local sun = GetSun(GetPlayerPed(-1), 0)\n   local sunVector\
    \ = GetEntityCoords(sun)\n   local planet1Vector = GetEntityCoords(GetEntity(planet1))\n\
    \   local planet2Vector = GetEntityCoords(GetEntity(planet2))\n   local distance\
    \ = math.sqrt((planet1Vector.x - planet2Vector.x) * (planet1Vector.x - planet2Vector.x)\
    \ +\n      (planet1Vector.y - planet2Vector.y) * (planet1Vector.y - planet2Vector.y)\
    \ +\n      (planet1Vector.z - planet2Vector.z) * (planet1Vector.z - planet2Vector.z))\n\
    \   if distance < 200 then\n      return (planet1, planet2)\n   end\n   return\
    \ ()\nend", "  if planet1 ~= 'Jupiter' and planet1 ~= 'Earth' and planet1 ~= 'Mars'\
    \ \n  and planet1 ~= 'Venus' and planet1 ~= 'Mercury' and planet1 ~= 'Saturn'\
    \ \n  and planet1 ~= 'Uranus' and planet1 ~= 'Neptune' then\n    return ()\n \
    \ end\n  if planet2 ~= 'Jupiter' and planet2 ~= 'Earth' and planet2 ~= 'Mars'\
    \ \n  and planet2 ~= 'Venus' and planet2 ~= 'Mercury' and planet2 ~= 'Saturn'\
    \ \n  and planet2 ~= 'Uranus' and planet2 ~= 'Neptune' then\n    return ()\n \
    \ end", "    local orbit_jupiter, orbit_saturn = system.planets[planet1].orbit,\
    \ system.planets[planet2].orbit\n    local distance = jd_auc(system.stars, system.planets[planet1].mass,\
    \ system.planets[planet2].mass)\n    local jupiter_orbit_satellite, jupiter_orbit_planet\
    \ = orbit_jupiter.satellite, orbit_jupiter.planet\n    local saturn_orbit_planet,\
    \ saturn_orbit_satellite = orbit_saturn.planet, orbit_saturn.satellite\n    local\
    \ jupiter_orbit, saturn_orbit = jupiter_orbit_satellite, saturn_orbit_satellite\n\
    \    local planet_orbit, planet_orbit = system.planets[planet1].orbit, system.planets[planet2].orbit\n\
    \    local planet_distance, planet_distance = system.planets[planet1].distance,\
    \ system.planets[planet2].distance\n    local planet_planet_distance, planet_planet_distance\
    \ = system.planets[planet1].distance, system.planets[planet2].distance", "  if\
    \ planet1 ~= nil then\n    local planet1_r = os.date(\"*t\", os.time())\n    local\
    \ planet1_s = os.date(\"*t\", os.time())\n    local planet1_d = os.date(\"*t\"\
    , os.time())\n    local planet1_n = os.date(\"*t\", os.time())\n    local planet1_s\
    \ = os.date(\"*t\", os.time())\n    local planet1_e = os.date(\"*t\", os.time())\n\
    \    local planet1_r = os.date(\"*t\", os.time())\n    local planet1_h = os.date(\"\
    *t\", os.time())\n    local planet1_m = os.date(\"*t\", os.time())\n    local\
    \ planet1_a = os.date(\"*t\", os.time())\n    local planet1_j = os.date(\"*t\"\
    , os.time())\n    local planet1_r = os.date(\"*t\", os.time())\n    local planet1_i\
    \ = os.date(\"*t\", os.time())\n    local planet1_n = os.date(\"*t\", os.time())\n\
    \    local planet1_o = os.date(\"*t\", os.time())\n    local planet1_f = os.date(\"\
    *t\", os.time())\n    local planet1_w = os.date(\"*t\", os.time())\n    local\
    \ planet1_Y = os.date(\"*t\", os.time())\n    local planet1_M = os.date(\"*t\"\
    , os.time())\n    local planet1_T = os.date(\"*t\", os.time())\n    local planet1_D\
    \ = os.date(\"*t\", os.time())\n    local planet1_s = os.date(\"*t\", os.time())\n\
    \    local planet1_p = os.date(\"*t\", os.time())\n    local planet1_f = os.date(\"\
    *t\", os.time())\n    local planet1_y = os.date(\"*t\", os.time())\n    local\
    \ planet1_a = os.date(\"*t\", os.time())\n    local planet1_e = os.date(\"*t\"\
    , os.time())\n    local planet1_r = os.date(\"*t\", os.time())\n    local planet1_h\
    \ = os.date(\"*t\", os.time())\n    local planet1_m = os.date(\"*t\", os.time())\n\
    \    local planet1_j = os.date(\"*t\", os.time())\n    local planet1_r = os.date(\"\
    *t\", os.time())\n    local planet1_d = os.date(\"*t\", os.time())\n    local\
    \ planet1_p = os.", "    local sun = math.sqrt{(math.pow((math.pow((planet1-'Mercury'),2)+math.pow((planet1-'Venus'),2)+math.pow((planet1-'Earth'),2)+math.pow((planet1-'Mars'),2)+math.pow((planet1-'Jupiter'),2)+math.pow((planet1-'Saturn'),2)+math.pow((planet1-'Uranus'),2)+math.pow((planet1-'Neptune'),2)+math.pow((planet1-'Ceres'),2)+math.pow((planet1-'Phobos'),2)+math.pow((planet1-'Halley'),2)+math.pow((planet1-'Oberon'),2)+math.pow((planet1-'Uranus'),2)+math.pow((planet1-'Neptune'),2)+math.pow((planet1-'Ceres'),2)+math.pow((planet1-'Phobos'),2)+math.pow((planet1-'Halley'),2)+math.pow((planet1-'Oberon'),2)+math.pow((planet1-'Uranus'),2)+math.pow((planet1-'Neptune'),2)+math.pow((planet1-'Ceres'),2)+math.pow((planet1-'Phobos'),2)+math.pow((planet1-'Halley'),2)+math.pow((planet1-'Oberon'),2)),\
    \ 2)+math.pow((math.pow((planet2-'Mercury'),2)+math.pow((planet2-'Venus'),2)+math.pow((planet2-'Earth'),2)+math.pow((planet2-'Mars'),2)+math.pow((planet2-'Jupiter'),2)+math.pow((planet2-'Saturn'),2)+math.pow((planet2-'Uranus'),2)+math.pow((planet2-'Neptune'),2)+math.pow((planet2-'Ceres'),2)+math.pow((planet2-'Phobos'),2)+math.pow((planet2-'Halley'),2)+math.pow((planet2-'Oberon'),2)+math.pow((planet2-'Uranus'),2)+math.pow((planet2-'Neptune'),2)+math.pow((planet2-'Ce",
  "    local pl1v = planet1\n    local pl2v = planet2\n    local pl1 = tonumber(pl1v)\n\
    \    local pl2 = tonumber(pl2v)", "    if planet1 == planet2 then return () end\n\
    \    local M = {}\n    local P1 = getPlanet(planet1)\n    local P2 = getPlanet(planet2)\n\
    \    local p1 = P1\n    local p2 = P2\n    if P1 then\n        while p2 and not\
    \ p1 do\n            M.insert(p2)\n            p2 = getPlanet(p2)\n        end\n\
    \        while p1 and not p2 do\n            M.insert(p1)\n            p1 = getPlanet(p1)\n\
    \        end\n    else\n        return ()\n    end\n    if p1 then\n        p2\
    \ = p1 + 1\n        while p1 do\n            M.insert(p2)\n            p1 = getPlanet(p1)\n\
    \            p2 = p2 + 1\n        end\n    end\n    local i = 1\n    local x =\
    \ P1\n    local y = P2\n    local z = p1 .. \"~\" .. p2\n    while x or y or z\
    \ do\n        if x then\n            if x ~= y then\n                M.insert(x)\n\
    \            end\n            x = getPlanet(x)\n        end\n        if y then\n\
    \            if y ~= z then\n                M.insert(y)\n            end\n  \
    \          y = getPlanet(y)\n        end\n        if z then\n            M.insert(z)\n\
    \            z = nil\n        end\n        if P2 then\n            y = P2\n  \
    \          z = p2 .. \"~\" .. p1\n        end\n        -- The next two ifs are\
    \ to deal with Mercury and Venus\n        if y == p2 then\n            y = P1\n\
    \            z = p1 .. \"~\" .. p2\n        end\n        if y == p1 then\n   \
    \         y = P1\n            z = p1 .. \"~\" .. p2\n        end\n        i =\
    \ i + 1\n        if i > #M then break end\n    end\n    if i == 1 then return\
    \ () end\n    M.sort(function(a, b) return #a < #b end)\n    local i = 1\n   \
    \ local s = M\n    local n = #M\n    while i < n do\n        table.insert(s, M[i])\n\
    \        i = i + 1\n    end\n    table.sort(s, function(a, b) return #a < #b end)\n\
    \    local i = 1\n    local t = {}\n    while i < n do\n        table.insert(t,\
    \ s[i])\n        i = i + 1\n    end\n    return t\nend", "\tlocal sun = math.sqrt(math.pow(math.sin(math.rad(sun.azimuth)),\
    \ 2) + \n\t\tmath.pow(math.cos(math.rad(sun.azimuth)), 2))\n\t\n\tlocal planet1\
    \ = getPlanetName(planet1)\n\tlocal planet2 = getPlanetName(planet2)\n\tlocal\
    \ sol1 = getPlanetName(planet1)\n\tlocal sol2 = getPlanetName(planet2)\n\t\n\t\
    local dist1 = tonumber(math.floor(tonumber(math.sqrt(math.pow(math.sin(math.rad(sun.azimuth)),\
    \ 2) + \n\t\tmath.pow(math.cos(math.rad(sun.azimuth)), 2))*math.cos(math.rad(sun.longitude))),\
    \ 10))\n\tlocal dist2 = tonumber(math.floor(tonumber(math.sqrt(math.pow(math.sin(math.rad(sun.azimuth)),\
    \ 2) + \n\t\tmath.pow(math.cos(math.rad(sun.azimuth)), 2))*math.cos(math.rad(sun.longitude))),\
    \ 10))\n\t\n\tif planet1 == \"\" then\n\t\tprint(planet2)\n\t\treturn nil\n\t\
    elseif planet2 == \"\" then\n\t\tprint(planet1)\n\t\treturn nil\n\tend\n\t\n\t\
    if dist1 < dist2 then\n\t\tprint(sol1)\n\telseif dist1 == dist2 then\n\t\tprint(sol1,\
    \ sol2)\n\tend\n\t\n\treturn (sol1, sol2)\nend", "   \n   if planet1 == planet2\
    \ then\n      return ()\n   elseif planet1 == \"\" then\n      return (planet2)\n\
    \   elseif planet2 == \"\" then\n      return (planet1)\n   end", "    return\
    \ \nend", "  if planet1 ~= planet2 then\n    return ()\n  end\n  local distances,\
    \ distances_sorted = {}, {}\n  local orbit1, orbit2, orbit3, orbit4, orbit5, orbit6,\
    \ orbit7, orbit8\n  -- The distance between the planets is given by the formula\n\
    \  -- d = a^2 + b^2 where a = r^2 and b = r^3\n  local d = function(x, y, z) \n\
    \    local a = (x*x + y*y)\n    local b = (x*z + y*z)\n    return math.pow(a,\
    \ 2) + math.pow(b, 2)\n  end\n  local r = 6378.137\n  for i, p1 in pairs(planets)\
    \ do\n    local planet = p1\n    distances[planet] = 0.0\n    distances_sorted[planet]\
    \ = 0.0\n    orbit1 = p1 .. \" Sol\"\n    orbit2 = orbit1 .. \"d\"\n    orbit3\
    \ = orbit2 .. \"h\"\n    orbit4 = orbit3 .. \"a\"\n    orbit5 = orbit4 .. \"m\"\
    \n    orbit6 = orbit5 .. \"p\"\n    orbit7 = orbit6 .. \"h\"\n    orbit8 = orbit7\
    \ .. \"a\"\n    distances[planet] = d(orbit1, orbit2, orbit3, orbit4, orbit5,\
    \ orbit6, orbit7, orbit8)\n    distances_sorted[planet] = distances[planet]\n\
    \  end\n  for i, p2 in pairs(planets) do\n    if distances_sorted[p2] ~= distances_sorted[planets[i+1]]\
    \ then\n      local distance = distances[planets[i+1]]\n      local distance_sorted\
    \ = distances_sorted[planets[i+1]]\n      local a1 = orbit1 .. \"a\" .. distance\n\
    \      local a2 = orbit2 .. \"a\" .. distance\n      local a3 = orbit3 .. \"a\"\
    \ .. distance\n      local a4 = orbit4 .. \"a\" .. distance\n      local a5 =\
    \ orbit5 .. \"a\" .. distance\n      local a6 = orbit6 .. \"a\" .. distance\n\
    \      local a7 = orbit7 .. \"a\" .. distance\n      local a8 = orbit8 .. \"a\"\
    \ .. distance\n      local b1 = orbit1 .. \"b\" .. distance\n      local b2 =\
    \ orbit2 .. \"b\" .. distance\n      local b3 = orbit3 .. \"b\" .. distance\n\
    \      local b4 = orbit4 .. \"b\" .. distance\n      local b5 = orbit5 .. \"b\"\
    \ .. distance\n      local b6 = orbit6 .. \"b\" .. distance\n      ", "    local\
    \ orbit1, orbit2, orbit3, orbit4, orbit5, orbit6, orbit7, orbit8\n    local lp,\
    \ pl, ec, p1, p2\n    local n1, n2, n3, n4, n5, n6, n7, n8", "   -- \"Luke\" is\
    \ a planet in our solar system\n   if planet1 ~= \"Mercury\" and planet1 ~= \"\
    Venus\" and planet1 ~= \"Earth\" \n     and planet1 ~= \"Mars\" and planet1 ~=\
    \ \"Jupiter\" and planet1 ~= \"Saturn\"\n     and planet1 ~= \"Uranus\" and planet1\
    \ ~= \"Neptune\" then\n     return ()\n   end\n   if planet2 ~= \"Mercury\" and\
    \ planet2 ~= \"Venus\" and planet2 ~= \"Earth\" \n     and planet2 ~= \"Mars\"\
    \ and planet2 ~= \"Jupiter\" and planet2 ~= \"Saturn\"\n     and planet2 ~= \"\
    Uranus\" and planet2 ~= \"Neptune\" then\n     return ()\n   end\n   -- \"Luke\"\
    \ doesn't have orbit in our solar system\n   if #{\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \n      \"Uranus\", \"Neptune\"} <= 1 then\n\
    \      return ()\n   end\n   -- \"Luke\" doesn't have orbit in our planet system\n\
    \   if #{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \n      \"Uranus\", \"Neptune\"} <= 2 then\n      return ()\n   end\n   -- Planets\
    \ don't have orbits\n   if #{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \n      \"Uranus\", \"Neptune\"} <= 1 then\n      return ()\n  \
    \ end\n   -- Planet names aren't the same length\n   if #planet1 == #planet2 then\n\
    \      return ()\n   end\n   -- \"Luke\" doesn't have orbit in our planet system\n\
    \   if #{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \n      \"Uranus\", \"Neptune\"} <= 2 then\n      return ()\n   end\n   -- Planets\
    \ don't have orbits\n   if #{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \n      \"Uranus\", \"Neptune\"} <= 2 then\n      return ()\n  \
    \ end\n   -- \"Luke\" doesn't have orbit in our planet system\n   if #", "   \
    \ local distances, _, orbits = math.min(math.abs(planet1 - planet2), math.abs(planet1\
    \ - \"Earth\"), math.abs(planet2 - \"Earth\"), math.abs(planet2 - \"Mercury\"\
    ))\n    return table.sort(orbits, function(p)\n        return distances[math.abs(p[\"\
    position\"] - \"Sun\")]\n    end, function(p1, p2)\n        return p1 ~= p2\n\
    \    end)\nend", "\tlocal sunOrbit = planet1 .. \" orbits the Sun\"\n\tlocal solarOrbit\
    \ = planet1 .. \" orbits the Solar System\"\n\tlocal planetOrbit = planet2 ..\
    \ \" orbits the Solar System\"\n\t\n\tif planet1 == planet2 then\n\t\treturn {solarOrbit,\
    \ sunOrbit}\n\tend", "\tlocal function calcOrbit(planet, planet2)\n\t\tlocal a1\
    \ = system.getSunDistance(planet, planet2)\n\t\tlocal a2 = system.getSunDistance(planet2,\
    \ planet)\n\t\tif a1 > a2 then return a1 end -- planet1 orbits the sun \n\t\t\
    return a2 \n\tend\n\tlocal planets = {planet1, planet2}\n\tfor _, planet in pairs(planets)\
    \ do\n\t\tlocal orbit1 = calcOrbit(planet, planet2)\n\t\tlocal orbit2 = calcOrbit(planet2,\
    \ planet)\n\t\tif orbit1 > orbit2 then table.insert(planets, planet) end\n\tend\n\
    \ttable.sort(planets, function(a, b) return system.getSunDistance(a, system.getSunDistance(b))\
    \ end)\n\treturn planets\nend", "\tlocal function distance(x1,y1,x2,y2)\n\t\t\
    return math.sqrt((math.pow(x1-x2,2)+math.pow(y1-y2,2))) \n\tend\n\tlocal function\
    \ distance(x1,y1,x2,y2)\n\t\treturn math.sqrt((math.pow(x1-x2,2)+math.pow(y1-y2,2)))\
    \ \n\tend", "   if planet1 ~= planet2 then\n      return (planet1, planet2)\n\
    \   elseif planet1 ~= \"Earth\" then\n      return (planet1, \"Earth\")\n   elseif\
    \ planet1 ~= \"Mercury\" then\n      return (\"Earth\", \"Mercury\")\n   elseif\
    \ planet1 ~= \"Venus\" then\n      return (\"Earth\", \"Venus\")\n   elseif planet1\
    \ ~= \"Mars\" then\n      return (\"Earth\", \"Mars\")\n   elseif planet1 ~= \"\
    Jupiter\" then\n      return (\"Earth\", \"Jupiter\")\n   elseif planet1 ~= \"\
    Saturn\" then\n      return (\"Earth\", \"Saturn\")\n   elseif planet1 ~= \"Uranus\"\
    \ then\n      return (\"Earth\", \"Uranus\")\n   elseif planet1 ~= \"Neptune\"\
    \ then\n      return (\"Earth\", \"Neptune\")\n   end\n   return ()\nend", " \
    \ local planet1orbit = \n  {\n    [\"Venus\"] = { 47.01724907031, -29.9508176758\
    \ },\n    [\"Earth\"] = { 26.03492278672, 52.51807265479 },\n    [\"Mercury\"\
    ] = { 55.32951442692, -37.80627838672 },\n    [\"Mars\"] = { 48.55040327828, -12.60469706121\
    \ },\n    [\"Jupiter\"] = { 52.20898297912, 21.01248166688 },\n    [\"Saturn\"\
    ] = { 38.83260386957, 14.56584251958 },\n    [\"Uranus\"] = { 48.12303934743,\
    \ 16.37571030291 },\n    [\"Neptune\"] = { 41.20536739009, -0.598766204958 }\n\
    \  }[planet1]\n  local planet2orbit = \n  {\n    [\"Venus\"] = { 48.58383700939,\
    \ -12.76868533519 },\n    [\"Earth\"] = { 46.97785652411, -18.57009481567 },\n\
    \    [\"Mercury\"] = { 53.81185866089, -35.27651210271 },\n    [\"Mars\"] = {\
    \ 48.13097704139, -13.43716501688 },\n    [\"Jupiter\"] = { 52.89924586771, 26.59407341735\
    \ },\n    [\"Saturn\"] = { 38.44308788675, 14.37872900334 },\n    [\"Uranus\"\
    ] = { 47.84538663033, 16.39468007398 },\n    [\"Neptune\"] = { 43.48755331812,\
    \ -0.909391654591 }\n  }[planet2]\n  local sunorbit = \n  {\n    [\"Venus\"] =\
    \ { 49.92035675964, -12.67612701889 },\n    [\"Earth\"] = { 46.59904188786, -19.25574942768\
    \ },\n    [\"Mercury\"] = { 55.44984301086, -35.59708760244 },\n    [\"Mars\"\
    ] = { 48.16321352191, -13.38693454293 },\n    [\"Jupiter\"] = { 53.0918", "  \
    \  local planet1orb, planet2orb = findPlanetOrbit(planet1)\n    if not planet1orb\
    \ then\n        return nil\n    end\n    local planet2orb2, planet2orbit = findPlanetOrbit(planet2)\n\
    \    if not planet2orb2 then\n        return nil\n    end\n    local dist = distance(planet1orb,\
    \ planet2orb)\n    local dist2 = distance(planet1orb, planet2orb2)\n    if dist\
    \ <= dist2 then\n        -- Planet Orbits are on the same circle\n        local\
    \ orbits, order = findOrbits(planet1orb, planet2orb)\n        return (\n     \
    \       unpack(\n                orbits,\n                1,\n               \
    \ function (orbit)\n                    return distance(orbit, planet1orb) <=\
    \ dist\n                end,\n                order\n            )\n        )\n\
    \    end\n    if dist2 > dist then\n        -- Planet Orbits are on the different\
    \ circles\n        local orbits, order = findOrbits(planet1orb, planet2orb2)\n\
    \        return (\n            unpack(\n                orbits,\n            \
    \    1,\n                function (orbit)\n                    return distance(orbit,\
    \ planet1orb2) <= dist\n                end,\n                order\n        \
    \    )\n        )\n    end\n    return nil\nend", "  local n1, n2 = string.lower(planet1),\
    \ string.lower(planet2)\n  if n1 == n2 then return (n1)\n  elseif n1 ~= n2 then\
    \ return (planet1, planet2)\n  else return (planet1, planet2)\n  end -- End of\
    \ if n1 == n2 ... return (planet1, planet2)\nend -- End of function bf", "   \
    \ local l1 = system.getTime(planet1)\n    local l2 = system.getTime(planet2)\n\
    \    if l1 == nil then\n        return nil\n    end\n    if l2 == nil then\n \
    \       return nil\n    end\n    if l1 < l2 then\n        return bf(\"Earth\"\
    , planet2)\n    end\n    if l2 < l1 then\n        return bf(\"Jupiter\", planet1)\n\
    \    end\n    local s0 = system.getTime(\"Sun\")\n    local n1 = system.getPlanetPosition(planet1)\n\
    \    local n2 = system.getPlanetPosition(planet2)\n    local distance = (n1.lon\
    \ - n2.lon)^2 + (n1.lat - n2.lat)^2\n    distance = math.sqrt(distance)\n    local\
    \ n = system.getPlanetPosition(planet2)\n    n.distance = distance\n    n.angle\
    \ = math.atan2((n1.lat - n2.lat), (n1.lon - n2.lon))\n    local t = {}\n    for\
    \ i = 1, 8 do\n        t.[i] = n\n    end\n    table.sort(t, function(a, b) \n\
    \        return a.distance < b.distance\n    end)\n    local t1 = t[1]\n    local\
    \ t2 = t[8]\n    local distanceToSun = n2.distance - s0.distance\n    local angleToSun\
    \ = n2.angle - s0.angle\n    local angleDiff = angleToSun - math.floor(angleToSun)\n\
    \    if distanceToSun == 0 then\n        t.clear()\n        return t\n    end\n\
    \    local newAngle\n    if angleDiff < 0 then\n        newAngle = angleToSun\
    \ + 360\n    else\n        newAngle = angleToSun\n    end\n    if distanceToSun\
    \ >= 0 then\n        local newDistance = distanceToSun + math.floor(distanceToSun)\n\
    \        local newN = {\n            lat = n1.lat + math.floor(math.cos(math.radians(newAngle))*newDistance),\n\
    \            lon = n1.lon + math.floor(math.sin(math.radians(newAngle))*newDistance)\n\
    \        }\n        t.insert(1, newN)\n    end\n    if distanceToSun < 0 then\n\
    \        local newDistance = distanceToSun + math.floor(distanceToSun)\n     \
    \   local newN = {\n            lat = n1.lat - math.floor(math.cos(math.radians(newAngle))*newDistance),\n\
    \            lon = n1.lon - math.floor(math.sin(math.radians(newAngle))*newDistance)\n\
    \        }\n        t.insert(8, newN)\n    end\n    if distanceToSun < 0 then\n\
    \        t.clear()\n        return t\n    end\n    local new", "\tif planet1 ==\
    \ planet2 then return (planet1, planet2) end\n\tif planet1 == \"Sun\" or planet2\
    \ == \"Sun\" then return (planet1, planet2) end\n\tlocal planet1orbit = string.format(\"\
    %s%s\", \"Sun\", planet1)\n\tlocal planet2orbit = string.format(\"%s%s\", \"Sun\"\
    , planet2)\n\tlocal planet1orbitorbit = string.format(\"%s%s\", \"Sun\", planet1\
    \ .. \"orbit\")\n\tlocal planet2orbitorbit = string.format(\"%s%s\", \"Sun\",\
    \ planet2 .. \"orbit\")\n\tlocal planet1orbitorbitorbit = string.format(\"%s%s\"\
    , \"Sun\", planet1 .. \"orbitorbit\")\n\tlocal planet2orbitorbitorbit = string.format(\"\
    %s%s\", \"Sun\", planet2 .. \"orbitorbit\")\n\tlocal planet1orbitorbitorbitorbit\
    \ = string.format(\"%s%s\", \"Sun\", planet1 .. \"orbitorbitorbit\")\n\tlocal\
    \ planet2orbitorbitorbit = string.format(\"%s%s\", \"Sun\", planet2 .. \"orbitorbit\"\
    )\n\tlocal planet1orbitorbitorbitorbit = string.format(\"%s%s\", \"Sun\", planet1\
    \ .. \"orbitorbitorbit\")\n\tlocal planet2orbitorbitorbit = string.format(\"%s%s\"\
    , \"Sun\", planet2 .. \"orbitorbit\")\n\tlocal planet1orbitorbitorbitorbit = string.format(\"\
    %s%s\", \"Sun\", planet1 .. \"orbitorbitorbitorbit\")\n\tlocal planet2orbitorbitorbit\
    \ = string.format(\"%s%s\", \"Sun\", planet2 .. \"orbitorbit\")\n\tlocal planet1orbitorbitorbitorbit\
    \ = string.format(\"%s%s\", \"Sun\", planet1 .. \"orbitorbitorbitorbit\")\n\t\
    local planet2orbitorbitorbit = string.format(\"%s%s\", \"Sun\", planet2 .. \"\
    orbitorbitorbit\")\n\tlocal planet1orbitorbitorbitorbit = string.format(\"%s%s\"\
    , \"Sun\", planet1 .. \"orbitorbitorbitorbit\")\n\tlocal planet2orbitorbitorbit\
    \ = string.format(\"%s%s\", \"Sun\", planet2 .. \"orbitorbitorbit\")\n\tlocal\
    \ planet1orbitorbitorbitorbit = string.format(\"%s%s\", \"Sun\", planet1 .. \"\
    orbitorbitorbitorbit\")\n\tlocal planet2orbitorbitorbit = string.format(\"%s%s\"\
    , \"Sun\", planet2 .. \"orbitorbitorbit\")\n\tlocal planet1orbitorbitorbitorbit\
    \ = string.format(\"%s%s\", \"Sun\", planet", "  if planet1 ~= planet2 then return\
    \ end -- and return (planet2, planet1) end\n  local orbit1 = getOrbit(planet1)\n\
    \  local orbit2 = getOrbit(planet2)\n  local i\n  for i = 1, 8 do\n    if orbit1[i]\
    \ > orbit2[i] then\n      return (planet1, planet2)\n    end\n  end\n  return\
    \ ()\nend", "\tlocal j1 = getPlanet(planet1)\n\tlocal j2 = getPlanet(planet2)\n\
    \tlocal sun = getSun()\n\tlocal orbits", "\tlocal p1 = assert(cman.LookupPlanet(planet1),\
    \ \"Invalid planet1 name\")\n\tlocal p2 = assert(cman.LookupPlanet(planet2), \"\
    Invalid planet2 name\")\n\tlocal sun  = cman.LookupPlanet(\"sun\")\n\tlocal p12\
    \  = cman.OrbitOfPlanet(p1, p2)\n\tlocal p13  = cman.OrbitOfPlanet(p1, p3)\n\t\
    local p23  = cman.OrbitOfPlanet(p2, p3)", "\tlocal orbits1, orbits2 = {}, {}\n\
    \tfor planet in planet_by_name[planet1] or {}\n\tdo\n\t\tlocal orbit = planet1_orbit_by_name[planet][planet2]\n\
    \t\ttable.insert(orbits1, orbit)\n\tend\n\tfor planet in planet_by_name[planet2]\
    \ or {}\n\tdo\n\t\tlocal orbit = planet2_orbit_by_name[planet][planet1]\n\t\t\
    table.insert(orbits2, orbit)\n\tend\n\ttable.sort(orbits1, function(a,b)\n\t\t\
    return distance(a,b) < distance(b,a)\n\tend)\n\ttable.sort(orbits2, function(a,b)\n\
    \t\treturn distance(a,b) < distance(b,a)\n\tend)\n\tfor i = 1, #orbits1 do\n\t\
    \ttable.insert(orbits1, orbits1[i])\n\t\ttable.insert(orbits2, orbits2[i])\n\t\
    end\n\tif #orbits1 > #orbits2 then\n\t\treturn orbits1, orbits2\n\telse\n\t\t\
    return orbits2, orbits1\n\tend\nend", "\tlocal function get_orbit(planet)\n\t\t\
    local t = {}\n\t\tlocal i = 0\n\t\trepeat\n\t\t\tt[i] = orbit_sun(planet)\n\t\t\
    \ti = i + 1\n\t\t\tplanet = planet_name[planet]\n\t\tuntil not planet or planet_name[planet]\n\
    \t\treturn t\n\tend", "\tlocal sun=hs.sun({})\n\tlocal sun1=sun:position({\"sun\"\
    })\n\tlocal sun2=sun:position({\"sun\"})\n\tlocal SunDistance=hs.distance(sun1,\
    \ sun2)\n\tlocal planet=planet1 or planet2\n\tlocal Planet1=planet or planet1\n\
    \tlocal Planet2=planet or planet2\n\tlocal Planet1=hs.planets[Planet1]\n\tlocal\
    \ Planet2=hs.planets[Planet2]\n\tlocal Planet1=Planet1 or Planet1\n\tlocal Planet2=Planet2\
    \ or Planet2\n\tlocal Planet1Orbit=Planet1:orbit({})\n\tlocal Planet2Orbit=Planet2:orbit({})\n\
    \tlocal Planet1Sun=Planet1Orbit:position({})\n\tlocal Planet2Sun=Planet2Orbit:position({})\n\
    \tlocal Planet1SunDistance=hs.distance(Planet1Sun, sun1)\n\tlocal Planet2SunDistance=hs.distance(Planet2Sun,\
    \ sun2)\n\tlocal Planet1OrbitDistance=Planet1SunDistance-Planet1Orbit:distance({})\n\
    \tlocal Planet2OrbitDistance=Planet2SunDistance-Planet2Orbit:distance({})\n\t\
    if Planet1OrbitDistance < Planet1OrbitDistance then\n\t\tPlanet1OrbitDistance=Planet1OrbitDistance\n\
    \tend\n\tif Planet2OrbitDistance < Planet2OrbitDistance then\n\t\tPlanet2OrbitDistance=Planet2OrbitDistance\n\
    \tend\n\tlocal Planet1OrbitDistance=math.floor(Planet1OrbitDistance)\n\tlocal\
    \ Planet2OrbitDistance=math.floor(Planet2OrbitDistance)\n\tlocal Planet1OrbitDistanceDistance=math.floor(Planet1OrbitDistance\
    \ + Planet2OrbitDistance)\n\tlocal Planet2OrbitDistanceDistance=math.floor(Planet2OrbitDistance\
    \ + Planet1OrbitDistance)\n\tlocal Planet1OrbitDistanceDistanceDistance=math.floor(Planet1OrbitDistance\
    \ + Planet2OrbitDistance + Planet1OrbitDistance + Planet2OrbitDistance)\n\tlocal\
    \ Planet1OrbitDistanceDistanceDistanceDistance=math.floor(Planet1OrbitDistance\
    \ + Planet2OrbitDistance + Plan", "   if planet1 == planet2 then return (planet1,\
    \ planet2)\n   if plant1 == planet1 then return (planet2, planet1)\n   if plant2\
    \ == planet1 then return (planet1, planet2)\n   if plant1 == planet2 then return\
    \ (planet2, planet1)\n   if plant2 == planet1 then return (planet1, planet2)\n\
    \   if plant1 == planet2 then return (planet2, planet1)\n   if plant2 == planet1\
    \ then return (planet1, planet2)\n   if plant1 == planet2 then return (planet2,\
    \ planet1)\n   if plant2 == planet1 then return (planet1, planet2)\n   if plant1\
    \ == planet2 then return (planet2, planet1)\n   if plant2 == planet1 then return\
    \ (planet1, planet2)\n   if plant1 == planet2 then return (planet2, planet1)\n\
    \   if plant2 == planet1 then return (planet1, planet2)\n   if plant1 == planet2\
    \ then return (planet2, planet1)\n   if plant2 == planet1 then return (planet1,\
    \ planet2)\n   if plant1 == planet2 then return (planet2, planet1)\n   if plant2\
    \ == planet1 then return (planet1, planet2)\n   if plant1 == planet2 then return\
    \ (planet2, planet1)\n   if plant2 == planet1 then return (planet1, planet2)\n\
    \   if plant1 == planet2 then return (planet2, planet1)\n   if plant2 == planet1\
    \ then return (planet1, planet2)\n   if plant1 == planet2 then return (planet2,\
    \ planet1)\n   if plant2 == planet1 then return (planet1, planet2)\n   if plant1\
    \ == planet2 then return (planet2, planet1)\n   if plant2 == planet1 then return\
    \ (planet1, planet2)\n   if plant1 == planet2 then return (planet2, planet1)\n\
    \   if plant2 == planet1 then return (planet1, planet2)\n   if plant1 == planet2\
    \ then return (planet2, planet1)\n   if plant2 == planet1 ", "    local p1 = assert(loadPlanet(planet1))\n\
    \    local p2 = assert(loadPlanet(planet2))\n    \n    local orbit1, orbit2 =\
    \ p1:getOrbit(p2), p2:getOrbit(p1)\n    \n    local sun = loadSun()\n    \n  \
    \  local function findOrbit(planet)\n        local orbit = assert(loadOrbit(planet))\n\
    \        local sun_dist = dist(orbit:getPosition(), sun:getPosition())\n     \
    \   return orbit, sun_dist\n    end\n    \n    -- sort orbits\n    local sun_dist,\
    \ orbit1, orbit2 = findOrbit(planet1), findOrbit(planet2)\n    orbit1, orbit2\
    \ = orbit1, orbit2 \n    \n    -- find orbits of both planets\n    local _, sun_dist\
    \ = findOrbit(planet1), findOrbit(planet2)\n    \n    local distances = { sun_dist\
    \ }\n    \n    local i = 0\n    \n    for i = 1, #orbit2 do\n        local dist\
    \ = dist(orbit2[i]:getPosition(), orbit1:getPosition())\n        \n        if\
    \ dist <= sun_dist then\n            distances[i] = dist\n        end\n    end\n\
    \    \n    distances = table.sort(distances, function(a, b) return a < b end)\n\
    \    \n    -- return tuple\n    local tuple = { }\n    for i = 1, #distances do\n\
    \        tuple[i] = loadPlanet(distances[i]:tostring())\n    end\n    \n    return\
    \ tuple\nend\n    ", "    local planets = {planet1, planet2}\n    if #planets\
    \ < 2 then return end", "   if planet1 == \"Earth\" or planet2 == \"Earth\" then\n\
    \      return (planet1, planet2)\n   elseif planet1 == planet2 then\n      return\
    \ (planet1, planet1, planet1, planet1, planet1, planet1, planet1)\n   elseif planet1\
    \ == \"Mercury\" or planet2 == \"Mercury\" then\n      return (planet1, planet1,\
    \ planet1, planet1, planet1, planet1)\n   elseif planet1 == \"Venus\" or planet2\
    \ == \"Venus\" then\n      return (planet1, planet1, planet1, planet1, planet1)\n\
    \   elseif planet1 == \"Mars\" or planet2 == \"Mars\" then\n      return (planet1,\
    \ planet1, planet1, planet1)\n   elseif planet1 == \"Jupiter\" or planet2 == \"\
    Jupiter\" then\n      return (planet1, planet1, planet1, planet1, planet1, planet1)\n\
    \   elseif planet1 == \"Saturn\" or planet2 == \"Saturn\" then\n      return (planet1,\
    \ planet1, planet1, planet1, planet1, planet1)\n   elseif planet1 == \"Uranus\"\
    \ or planet2 == \"Uranus\" then\n      return (planet1, planet1, planet1, planet1,\
    \ planet1, planet1)\n   elseif planet1 == \"Neptune\" or planet2 == \"Neptune\"\
    \ then\n      return (planet1, planet1, planet1, planet1, planet1, planet1)\n\
    \   end\nend", "  -- The input planet names are validated\n  if planet1 == nil\
    \ or planet2 == nil then\n    return nil\n  elseif planet1 == \"Mercury\" and\
    \ planet2 == \"Earth\" then\n    return {\"Venus\"}\n  elseif planet1 == \"Mercury\"\
    \ and planet2 == \"Venus\" then\n    return {\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"}\n  elseif planet1 == \"Mercury\" and planet2 == \"Mars\" then\n\
    \    return {\"Jupiter\", \"Saturn\"}\n  elseif planet1 == \"Mercury\" and planet2\
    \ == \"Jupiter\" then\n    return {\"Saturn\"}\n  elseif planet1 == \"Mercury\"\
    \ and planet2 == \"Saturn\" then\n    return {\"Uranus\"}\n  elseif planet1 ==\
    \ \"Mercury\" and planet2 == \"Uranus\" then\n    return {\"Neptune\"}\n  elseif\
    \ planet1 == \"Venus\" and planet2 == \"Earth\" then\n    return {\"Earth\"}\n\
    \  elseif planet1 == \"Venus\" and planet2 == \"Mars\" then\n    return {\"Jupiter\"\
    , \"Saturn\"}\n  elseif planet1 == \"Venus\" and planet2 == \"Jupiter\" then\n\
    \    return {\"Saturn\"}\n  elseif planet1 == \"Venus\" and planet2 == \"Saturn\"\
    \ then\n    return {\"Uranus\"}\n  elseif planet1 == \"Venus\" and planet2 ==\
    \ \"Uranus\" then\n    return {\"Neptune\"}\n  elseif planet1 == \"Earth\" and\
    \ planet2 == \"Mars\" then\n    return {\"Jupiter\", \"Saturn\"}\n  elseif planet1\
    \ == \"Earth\" and planet2 == \"Jupiter\" then\n    return {\"Saturn\"}\n  elseif\
    \ planet1 == \"Earth\" and planet2 == \"Saturn\" then\n    return {\"Uranus\"\
    }\n  elseif planet1 == \"Earth\" and planet2 == \"Uranus\" then\n    return {\"\
    Neptune\"}\n  elseif planet1 == \"Mars\" and planet2 == \"Jupiter\" then\n   \
    \ return {\"Saturn\"}\n  elseif planet1 == \"Mars\" and planet2 == \"Saturn\"\
    \ then\n    return {\"Uranus\"}\n  elseif planet1 == \"Mars\" and planet2 == \"\
    Uranus\" then\n    return {\"Neptune\"}", "    local sun = math.pi/6\n    local\
    \ planet1Orbit = math.rad(90 - sun)\n    local planet2Orbit = math.rad(sun + 90)\n\
    \    local sunOrbit = math.rad(sun - sun)", "    if not tonumber(planet1) or not\
    \ tonumber(planet2) then\n        return {}\n    end", "    local planet1orbit\
    \ = planet1\n    local planet2orbit = planet2\n    local orbits = {}\n    \n \
    \   -- Planet 1\n    local planet1orbitorbit = planet2orbit\n    while true do\n\
    \        -- Planet 2\n        local planet2orbitorbit = planet1orbitorbit\n  \
    \      while true do\n            -- Solve the equation\n            if orbits:len()\
    \ == 0 then\n                return (planet1orbitorbit, planet2orbitorbit)\n \
    \           end\n            local distance\n            if distance == nil then\n\
    \                distance = ((planet1orbit - planet2orbitorbit)^2) / (2 * math.pow(planet1orbitorbit,\
    \ 2))\n            end\n            -- Add planets that close to sun\n       \
    \     if distance <= sun then\n                table.insert(orbits, planet1orbitorbit)\n\
    \                table.insert(orbits, planet2orbitorbit)\n            end\n  \
    \          -- Move to next planet\n            planet1orbitorbit = planet1orbit\n\
    \            planet2orbitorbit = planet2orbit\n        end\n        -- Move to\
    \ next planet\n        planet1orbit = planet1orbitorbit\n        planet2orbit\
    \ = planet2orbitorbit\n    end\nend", "    -- write your solution here\nend",
  "  return function()\n    local planet1, planet2, sun = planet1, planet2, sun\n\
    \    local orbit1 = get_orbit(planet1, sun)\n    local orbit2 = get_orbit(planet2,\
    \ sun)\n    local distance = distance2(orbit1, orbit2)\n    return \n      planet1,\n\
    \      planet2,\n      sun,\n      orbit1,\n      orbit2,\n      distance\n  end\n\
    end", "    if planet1 == \"Sun\" or planet2 == \"Sun\" then\n        return ()\n\
    \    end", "    local sun = math.rad(sun_angle)\n    local s12 = math.rad(sun_angle\
    \ - planet1Angle)\n    local s21 = math.rad(sun_angle - planet2Angle)\n    local\
    \ p1 = math.rad(planet1Angle)\n    local p2 = math.rad(planet2Angle)\n    local\
    \ p12 = math.rad(planet1Angle - planet2Angle)\n    local p22 = math.rad(planet2Angle\
    \ - planet1Angle)\n    local t = (sun - p12 + p22) / (p2 - p1 + p22)\n    local\
    \ d = math.sqrt(math.pow(p1 - p2, 2) + math.pow(p1 - p22, 2) + math.pow(p2 - p12,\
    \ 2))\n    local m12 = (p2 - p12) * (s12 - p12) * (s12 - p12) + p12 * (p12 - s12)\
    \ * (p12 - p12) + p12 * (p12 - s12) * (p12 - p12)\n    local m22 = (p12 - s12)\
    \ * (p22 - s21) * (p22 - s21) + (p12 - s12) * (s12 - p22) * (s12 - p22) + p12\
    \ * (p12 - s12) * (p12 - s12) + p12 * (p12 - s12) * (p12 - s21)\n    local m122\
    \ = (m12 + m22) / d\n    local m1 = m122 * t\n    local m2 = m122 * t * t\n  \
    \  local m3 = m122 * t * t * t\n    local m4 = (m2 + m3) * t\n    local m5 = m12\
    \ * (m3 - m4)\n    local m6 = m12 * (m4 - m5)\n    local m7 = (m6 + m5) * t\n\
    \    local m8 = m12 * (m6 - m7)\n    local m9 = (m7 + m8) * t\n    local m10 =\
    \ (m9 + m4) * t\n    local m11 = (m10 + m5) * t\n    local m12 = (m11 + m6) *\
    \ t\n    local m13 = (m12 + m7) * t\n    local m14 = (m13 + m8) * t\n    local\
    \ m15 = (m14 + m4) * t\n    local m16 = (m15 + m5) * t\n    local m17 = (m16 +\
    \ m6) * t\n    local m18 = (m17 + m7) * t\n    ", "    if planet1 ~= planet2 then\n\
    \        return ()\n    end\n    local p1 = planet1\n    local p2 = planet2\n\
    \    local p3 = p1 .. \"-Mercury\"\n    local p4 = p1 .. \"-Venus\"\n    local\
    \ p5 = p1 .. \"-Earth\"\n    local p6 = p1 .. \"-Mars\"\n    local p7 = p1 ..\
    \ \"-Jupiter\"\n    local p8 = p1 .. \"-Saturn\"\n    local p9 = p1 .. \"-Uranus\"\
    \n    local p10 = p1 .. \"-Neptune\"", "  if planet1 == planet2 then return ()\
    \ end\n  local p1, p2 = string.lower(planet1), string.lower(planet2)\n  if p1\
    \ ~= \"earth\" and p2 ~= \"earth\" then return () end\n  if p1 ~= \"mercury\"\
    \ and p2 ~= \"mercury\" then return () end\n  if p1 ~= \"venus\" and p2 ~= \"\
    venus\" then return () end\n  if p1 ~= \"mars\" and p2 ~= \"mars\" then return\
    \ () end\n  if p1 ~= \"jupiter\" and p2 ~= \"jupiter\" then return () end\n  if\
    \ p1 ~= \"saturn\" and p2 ~= \"saturn\" then return () end\n  if p1 ~= \"uranus\"\
    \ and p2 ~= \"uranus\" then return () end\n  if p1 ~= \"neptune\" and p2 ~= \"\
    neptune\" then return () end\n  if p1 ~= \"moon\" and p2 ~= \"moon\" then return\
    \ () end\n  local sP1, sP2 = orbit[string.lower(planet1)], orbit[string.lower(planet2)]\n\
    \  if sP1 == nil or sP2 == nil then return () end\n  local a1, a2 = -pi / 2, -pi\
    \ / 2\n  if sP1.distance < sP2.distance then\n    a1 = a1 + pi / 2 - sP1.distance\n\
    \    a2 = a2 + pi / 2 - sP2.distance\n  else\n    a1 = a1 + pi / 2 + sP2.distance\n\
    \    a2 = a2 + pi / 2 + sP1.distance\n  end\n  local planets = { p1, p2 }\n  local\
    \ n1 = 1\n  local n2 = 1\n  repeat\n    local t1 = a1 + n1 / 180 * pi\n    local\
    \ t2 = a2 + n2 / 180 * pi\n    local d1, d2 = planet.distance(t1, t2), planet.distance(t2,\
    \ t1)\n    if d1 ~= d2 then\n      table.insert(planets, planet1)\n      n1 =\
    \ n1 + 1\n    else\n      table.insert(planets, planet2)\n      n2 = n2 + 1\n\
    \    end\n  until d1 < d1\n  table.sort(planets)\n  return planets\nend\n</cell>\n\
    <cell>", "    local planets = {planet1, planet2}\n    local sun = sun_position(planets)\n\
    \    local orbits = planet_orbits(planets, sun)\n    local orbits1 = orbits[1]\n\
    \    local orbits2 = orbits[2]\n    local diff = {[planet1]={},[planet2]={}}\n\
    \    for i=1,#orbits1 do\n        local planet1 = orbits1[i]\n        local planet2\
    \ = orbits2[i]\n        local dist = math.sqrt((orbits1[i]-sun)^2+(orbits2[i]-sun)^2)\n\
    \        local i1 = getindex(diff, planet1)\n        if i1 == nil then\n     \
    \       table.insert(diff[planet1], dist)\n        else\n            table.insert(diff[planet1],\
    \ dist)\n        end\n        local i2 = getindex(diff, planet2)\n        if i2\
    \ == nil then\n            table.insert(diff[planet2], dist)\n        else\n \
    \           table.insert(diff[planet2], dist)\n        end\n    end\n    local\
    \ sortedDiff = sortn(diff, 1)\n    for i=1,#sortedDiff do\n        if sortedDiff[i]\
    \ > 0.2 then\n            if sortedDiff[i] < sortedDiff[#sortedDiff] then\n  \
    \              sortedDiff[i] = sortedDiff[#sortedDiff]\n            end\n    \
    \    end\n    end\n    for i=1,#sortedDiff do\n        sortedDiff[i] = math.floor(sortedDiff[i]*100)\n\
    \    end\n    return sortedDiff[1]\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=lua,lua-table,lua-patterns\
    \ |>\nThe original code was in Haskell. Here is a Haskell version of the BFS algorithm:\n\
    <code>\nbfs :: [String] -> [(String, Double)]\nbfs [] = []\nbfs [x] = [(x , 0)]\n\
    bfs (x:xs)\n    | x == sun = reverse $ sort $ map ((++x) . sort) $ bfs xs\n  \
    \  | otherwise = bfs (x:xs)\n</code>\nThe first line ([]) means an empty list\
    \ of planets, and the next line ([x]) means a list of one planet.\nThe second\
    \ line (x : xs) means a list that contains both planets. The x is included because\
    \ the function needs to recursively apply the function to the rest of the list.\n\
    The third line is conditional on the current planet being sun. sun has the type\
    \ [String]. So (++x) . sort means \"concatenate x to the end of a list of sorts.\"\
    \nThe fourth line is conditional on the ", "    local p1 = find(all_planets, planet1)\n\
    \    if p1 == nil then\n        print(\"Planet1 must be in \", all_planets)\n\
    \        return nil\n    end\n    local p2 = find(all_planets, planet2)\n    if\
    \ p2 == nil then\n        print(\"Planet2 must be in \", all_planets)\n      \
    \  return nil\n    end\n    local x1, y1 = p1[2], p1[3]\n    local x2, y2 = p2[2],\
    \ p2[3]\n    local d = sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)\n    local m = (y2\
    \ - y1) / (x2 - x1)\n    local r1 = (m * d)^0.5\n    local r2 = (r1 * d)^0.5\n\
    \    if r1 < (r1 + r2) then\n        return (x1, y1)\n    end\n    return (x2,\
    \ y2)\nend", "\tif planet1 == planet2 then return (planet1, planet2) end\n\t\n\
    \tlocal planet1_orbit = solarsystem.get_planet_orbit_info(planet1)\n\tlocal planet2_orbit\
    \ = solarsystem.get_planet_orbit_info(planet2)\n\t\n\tif planet1_orbit == nil\
    \ or planet2_orbit == nil then return () end\n\t\n\tlocal p1 = solarsystem.get_planet_position(planet1)\n\
    \tlocal p2 = solarsystem.get_planet_position(planet2)\n\t\n\t-- Define distance\
    \ between planet1 and planet2, using L1 norm\n\t-- -- This distance is measured\
    \ in AU, so is in units of astronomical units\n\t-- -- See Wikipedia article on\
    \ L1 norm for details\n\tlocal dist = solarsystem.distance(p1, p2) / 1e5\n\t\n\
    \t-- If distance is less than the Sun's distance, return empty tuple\n\tif dist\
    \ <= sun_distance then return () end\n\t\n\t-- Get planet orbits for planet1 and\
    \ planet2\n\tlocal planet1_orbit_info = solarsystem.get_planet_orbit_info(planet1)\n\
    \tlocal planet2_orbit_info = solarsystem.get_planet_orbit_info(planet2)\n\t\n\t\
    -- Define function to get distance between orbits of planet 1 and 2\n\tlocal function\
    \ distance_between_orbits(orbit1, orbit2)\n\t\t-- Convert from hours to seconds\n\
    \t\tlocal t = tonumber(orbit1.time) * 3600 + tonumber(orbit1.hour) * 60\n\t\t\n\
    \t\treturn tonumber(orbit2.time) * 3600 + tonumber(orbit2.hour) * 60 - t\n\tend\n\
    \t\n\t-- Define function to get time of transit of planet 1\n\tlocal function\
    \ time_between_orbits(orbit1, orbit2)\n\t\t-- Convert from hours to seconds\n\t\
    \tlocal t = tonumber(orbit1.time) * 3600 + tonumber(orbit1.hour) * 60\n\t\t\n\t\
    \treturn tonumber(orbit2.time) * 3600 + tonumber(orbit2.hour) * 60 + t\n\tend\n\
    \t\n\t-- If distance is less than the Sun's distance, return empty tuple\n\tif\
    \ dist <= sun_distance then return () end\n\t\n\t-- Define function to get time\
    \ of transit of planet 2\n\tlocal function time_of_transit_of_planet2(planet2,\
    \ orbit2)\n\t\t-- Convert from hours to seconds\n\t\tlocal t = tonumber(orbit2.time)\
    \ * 3600 + tonumber(orbit", "    if not planet1 or not planet2 then\n        return\
    \ nil\n    end\n    \n    local a1 = orbits(planet1)\n    local a2 = orbits(planet2)\n\
    \    \n    local n = #a1 + #a2\n    \n    local a = {}\n    local i = 0\n    \n\
    \    for i = 1, n do\n        if a1[i] and a2[i] then\n            table.insert(a,\
    \ {a1[i].distance:dist(planet1, planet2), a1[i].name}) \n            table.insert(a,\
    \ {a2[i].distance:dist(planet1, planet2), a2[i].name}) \n        else\n      \
    \      return nil\n        end\n    end\n    \n    return table.sort(a, function(a,\
    \ b) return a[1] <= b[1] end)\nend\n</cell>\n<text>\nExercise 5\nWrite a function\
    \ that returns the number of orbits of two planets belonging to \nthe same body\
    \ as their names. \nThe function should return nil if either of the arguments\
    \ are wrong. \nThe function should return nil if planet1 is not the name of any\
    \ planet. \nThe function should return nil if planet2 is not the name of any planet.\
    \ \nThe function should return nil if planet1 and planet2 belong to different\
    \ \nbodies. \nThe function should return a number if planet1 and planet2 belong\
    \ to the same \nbody, and -1 if they do not belong to the same body. \nExamples\n\
    bf(\"Jupiter\", \"Neptune\") ==> 1\nbf(\"Earth\", \"Mercury\") ==> -1\nbf(\"Mercury\"\
    , \"Uranus\") ==> -1\nbf(\"Earth\", \"Mercury\", \"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\") ==> 3\nbf(\"Earth\", \"Mercury\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\") ==> 2", "\tlocal orbit1, orbit2 = orbit_between(planet1,\
    \ planet2)\n\tlocal planet1_orbits = setmetatable({}, {__index = function(t,k)\n\
    \t\treturn function () \n\t\t\treturn orbit1(k) \n\t\tend\n\tend})\n\tlocal planet2_orbits\
    \ = setmetatable({}, {__index = function(t,k)\n\t\treturn function () \n\t\t\t\
    return orbit2(k) \n\t\tend\n\tend})\n\tlocal function compare_by_distance(planet_a,\
    \ planet_b)\n\t\treturn distance(orbit1(planet_a), orbit1(planet_b)) \n\tend\n\
    \tplanet1_orbits[planet1] = orbit1\n\tplanet2_orbits[planet2] = orbit2\n\tlocal\
    \ planets = pairs(planet1_orbits) \n\tlocal planets_copy = planets\n\tlocal planets_copy2\
    \ = planets\n\treturn (planets_copy, planets_copy2)\nend", "\tlocal p1 = g[planet1]\n\
    \tlocal p2 = g[planet2]\n\tif not p1 or not p2 then return end\n\tlocal sun =\
    \ g[\"Sun\"]", "   local m1 = tonumber(planet1)\n   local m2 = tonumber(planet2)\n\
    \   if m1 == nil or m2 == nil then return end\n   local r = math.sqrt(m1 * m1\
    \ + m2 * m2)\n   \n   local n1 = m1 - r\n   local n2 = m2 - r\n   if n1 ~= 0 then\n\
    \      return (m1,n1),(m2,n2)\n   else\n      if n2 ~= 0 then\n         return\
    \ (n2,m1),(m2,n1)\n      else\n         return (m1,m2),(m2,n1)\n      end\n  \
    \ end\nend\nprint(bf(\"Jupiter\", \"Neptune\"))\nprint(bf(\"Earth\", \"Mercury\"\
    ))\nprint(bf(\"Mercury\", \"Uranus\"))\nprint(bf(\"Venus\", \"Earth\"))\nprint(bf(\"\
    Jupiter\", \"Saturn\"))\nprint(bf(\"Mars\", \"Jupiter\"))\nprint(bf(\"Jupiter\"\
    , \"Saturn\"))\nprint(bf(\"Jupiter\", \"Uranus\"))\nprint(bf(\"Venus\", \"Earth\"\
    ))\nprint(bf(\"Earth\", \"Mercury\"))\nprint(bf(\"Venus\", \"Jupiter\"))\nprint(bf(\"\
    Earth\", \"Mars\"))\nprint(bf(\"Mars\", \"Earth\"))\nprint(bf(\"Mercury\", \"\
    Uranus\"))\nprint(bf(\"Uranus\", \"Saturn\"))\nprint(bf(\"Jupiter\", \"Saturn\"\
    ))\nprint(bf(\"Mars\", \"Jupiter\"))\nprint(bf(\"Venus\", \"Earth\"))\nprint(bf(\"\
    Mercury\", \"Uranus\"))\nprint(bf(\"Earth\", \"Mercury\"))\nprint(bf(\"Earth\"\
    , \"Mars\"))\nprint(bf(\"Earth\", \"Jupiter\"))\nprint(bf(\"Mars\", \"Earth\"\
    ))\nprint(bf(\"Jupiter\", \"Uranus\"))\nprint(bf(\"Venus\", \"Jupiter\"))\nprint(bf(\"\
    Mercury\", \"Uranus\"))\nprint(bf(\"Mercury\", \"Saturn\"))\nprint(bf(\"Mercury\"\
    , \"Jupiter\"))\nprint(bf(\"Mars\", \"Jupiter\"))\nprint(bf(\"Jupiter\", \"Uranus\"\
    ))\nprint(bf(\"Earth\", \"Mars\"))\nprint(bf(\"Mars\", \"Earth\"))\nprint(bf(\"\
    Mercury\", \"Saturn\"))\nprint(bf(\"Mercury\", \"Jupiter\"))\nprint(bf(\"Mars\"\
    , \"Jupiter\"))\nprint(bf(\"Jupiter\", \"Uranus\"))\nprint(bf(\"Earth\", \"Mars\"\
    ))\nprint(bf", "  if planet1 == planet2 then return (planet1, planet2)\n  elseif\
    \ planet1 == \"Sun\" or planet2 == \"Sun\" then return (planet1, planet2)\n  else\
    \ local p1, p2\n    p1 = bf(planet1, \"Mercury\")\n    if p1 then return p1 end\n\
    \    p2 = bf(planet2, \"Mercury\")\n    if p2 then return p2 end\n    p1 = bf(planet1,\
    \ \"Venus\")\n    if p1 then return p1 end\n    p2 = bf(planet2, \"Venus\")\n\
    \    if p2 then return p2 end\n    p1 = bf(planet1, \"Earth\")\n    if p1 then\
    \ return p1 end\n    p2 = bf(planet2, \"Earth\")\n    if p2 then return p2 end\n\
    \    p1 = bf(planet1, \"Mars\")\n    if p1 then return p1 end\n    p2 = bf(planet2,\
    \ \"Mars\")\n    if p2 then return p2 end\n    p1 = bf(planet1, \"Jupiter\")\n\
    \    if p1 then return p1 end\n    p2 = bf(planet2, \"Jupiter\")\n    if p2 then\
    \ return p2 end\n    p1 = bf(planet1, \"Saturn\")\n    if p1 then return p1 end\n\
    \    p2 = bf(planet2, \"Saturn\")\n    if p2 then return p2 end\n    p1 = bf(planet1,\
    \ \"Uranus\")\n    if p1 then return p1 end\n    p2 = bf(planet2, \"Uranus\")\n\
    \    if p2 then return p2 end\n    p1 = bf(planet1, \"Neptune\")\n    if p1 then\
    \ return p1 end\n    p2 = bf(planet2, \"Neptune\")\n    if p2 then return p2 end\n\
    \    return ()\n  end\nend", "    if planet1 == planet2 then\n        return (planet1,\
    \ planet2)\n    end", "    local sun = stars[star].orb[\"Sun\"]\n    local planet_1\
    \ = stars[planet1].orb\n    local planet_2 = stars[planet2].orb\n    local distance\
    \ = nil\n    local i\n    \n    -- Loop through all planets\n    for i = 1, #planets\
    \ do\n        -- If planet is Sun, skip it\n        if planet_1[i] == sun then\n\
    \            i = i + 1\n            continue\n        end\n        -- If planet\
    \ is Sun, skip it\n        if planet_2[i] == sun then\n            i = i + 1\n\
    \            continue\n        end\n        -- Distance between planet and sun\n\
    \        distance = distance or stars[planets[i]].real.distanceTo(sun)\n    end\n\
    \    \n    -- Sort the planets by distance to Sun\n    local sun_distance = distance\
    \ + sun_offset\n    table.sort(planets, function(a, b)\n        -- Distance between\
    \ a and b\n        local distance = stars[a].orb[a].distanceTo(sun) - stars[a].orb[b].distanceTo(sun)\n\
    \        -- If distance is negative, sort a\n        if distance < 0 then\n  \
    \          return true\n        end\n        -- If distance is positive, sort\
    \ b\n        if distance > 0 then\n            return false\n        end\n   \
    \     -- If distance is 0, sort a before b\n        if distance == 0 then\n  \
    \          return true\n        end\n        -- Otherwise, sort by distance to\
    \ Sun\n        return sun_distance - distance\n    end)\n    \n    return planets\n\
    end", "    if planet1 == planet2 then return () else return (planet1, planet2)\
    \ end\n    if planet2 ~= planet1 then return () end\n    local sun_position =\
    \ GetSunPosition()\n    local sun_distance = GetDistance(planet1, planet2, sun_position)\n\
    \    local planet_positions = {}\n    planet_positions[planet1] = GetPosition(planet1)\n\
    \    planet_positions[planet2] = GetPosition(planet2)\n    local distance = GetDistance(planet1,\
    \ planet2, sun_position)\n    for planet_name, planet_position in pairs(planet_positions)\
    \ do\n        local distance_planet = GetDistance(planet1, planet_name, sun_position)\n\
    \        if distance_planet < distance then\n            distance = distance_planet\n\
    \            planet_name = planet_position\n        end\n    end\n    if distance\
    \ == 0 then return () end\n    local sorted_orbits = pairs(planet_positions)\n\
    \    table.sort(sorted_orbits, function(a, b) return GetDistance(planet1, a, sun_position)\
    \ < GetDistance(planet1, b, sun_position) end)\n    return sorted_orbits\nend",
  "  local planets = {}\n  if planet1 == nil or planet2 == nil then\n    return planets\n\
    \  elseif planet1 ~= planet2 then\n    return planets\n  else\n    -- Mercury\
    \ is between Earth, Mars, Jupiter, Saturn, Uranus, Neptune\n    table.insert(planets,\
    \ planet1)\n    table.insert(planets, planet2)\n    table.insert(planets, planet1)\n\
    \    table.insert(planets, planet2)\n    table.insert(planets, planet1)\n    table.insert(planets,\
    \ planet2)\n    table.insert(planets, planet1)\n    table.insert(planets, planet2)\n\
    \    table.insert(planets, planet1)\n    table.insert(planets, planet2)", "  \
    \  local function distance(p1, p2)\n        -- This function calculates the distance\
    \ between two planets.\n        -- It uses the formula\n        -- dist(planet1,\
    \ planet2) = sqrt ( (x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2 )\n        local x1,\
    \ y1, z1 = p1.x, p1.y, p1.z\n        local x2, y2, z2 = p2.x, p2.y, p2.z\n   \
    \     return math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2) + math.pow(z1\
    \ - z2, 2))\n    end\n    local p1 = getPlanet(planet1)\n    local p2 = getPlanet(planet2)\n\
    \    -- We need the first planet to calculate the distance to the sun.\n    local\
    \ sun = getPlanet(\"Sun\")\n    -- The first planet of the tuple is always Mercury.\n\
    \    local planets = {p1}\n    -- We need to calculate the distance from the orbit\
    \ of the first planet to the \n    -- orbit of the sun\n    local sunOrbit = getPlanetOrbit(sun)\n\
    \    -- We need the second planet to calculate the distance to the orbit of the\
    \ \n    -- first planet.\n    local orbit = getPlanetOrbit(p1)\n    -- We calculate\
    \ the distance between the orbits of the two planets.\n    local dist = distance(orbit,\
    \ sunOrbit)\n    local orbits = {}\n    for i = 1, #planets do\n        -- We\
    \ calculate the distance between the orbits of the two planets.\n        local\
    \ dist = distance(orbit, getPlanetOrbit(planets[i]))\n        if dist < dist then\n\
    \            table.insert(orbits, {i = i, dist = dist})\n        end\n    end\n\
    \    -- We sort the planets by the distance to the sun and return the planets.\n\
    \    table.sort(orbits, function(a, b)\n        return a.dist > b.dist\n    end)\n\
    \    -- We return the first and the last planet of each orbit of planets.\n  \
    \  return table.concat(orbits, \" \"), table.concat(orbits, \" \")\nend", "  local\
    \ sun = calculate_sun()\n  \n  if planet1 ~= planet2 then\n    return ()\n  elseif\
    \ planet1 == \"Sun\" then\n    return (\"Sun\")\n  elseif planet1 == \"Earth\"\
    \ then\n    return (\"Earth\")\n  elseif planet1 == \"Mercury\" then\n    return\
    \ (\"Mercury\")\n  elseif planet1 == \"Venus\" then\n    return (\"Venus\")\n\
    \  elseif planet1 == \"Mars\" then\n    return (\"Mars\")\n  elseif planet1 ==\
    \ \"Jupiter\" then\n    return (\"Jupiter\", \"Saturn\")\n  elseif planet1 ==\
    \ \"Saturn\" then\n    return (\"Jupiter\", \"Saturn\", \"Uranus\")\n  elseif\
    \ planet1 == \"Uranus\" then\n    return (\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n  elseif planet1 == \"Neptune\" then\n    return (\"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\")\n  elseif planet1 == \"Pluto\"\
    \ then\n    return (\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\"\
    , \"Halley\")\n  elseif planet1 == \"Halley\" then\n    return (\"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\", \"Pluto\", \"Halley\", \"Asteroid\")\n  elseif\
    \ planet1 == \"Asteroid\" then\n    return (\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\", \"Pluto\", \"Halley\", \"Asteroid\", \"Phobos\")\n  elseif planet1\
    \ == \"Phobos\" then\n    return (\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    , \"Pluto\", \"Halley\", \"Asteroid\", \"Phobos\", \"Mesosphere\")\n  elseif planet1\
    \ == \"Mesosphere\" then\n    return (\"Jupiter\", \"Saturn\", \"Uranus\", \"\
    Neptune\", \"Pluto\", \"Halley\", \"Asteroid\", \"Phobos\", \"Mesosphere\", \"\
    Mars\")\n  elseif planet1 == \"Mars\" then\n    return (\"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\", \"Pluto\", \"Halley\", \"Asteroid\", \"Phobos\", \"\
    Mesosphere\", \"Mars\", \"Earth\")", "    local sun_pos = get_sun_pos()\n    local\
    \ sun_vel = get_sun_vel()\n    local planet_pos1 = get_planet_position(planet1,\
    \ sun_pos, sun_vel)\n    local planet_pos2 = get_planet_position(planet2, sun_pos,\
    \ sun_vel)\n    local planet_vel1 = get_planet_velocity(planet1, sun_pos, sun_vel)\n\
    \    local planet_vel2 = get_planet_velocity(planet2, sun_pos, sun_vel)\n    local\
    \ planet_dir1 = get_planet_dir(planet1, sun_pos, sun_vel)\n    local planet_dir2\
    \ = get_planet_dir(planet2, sun_pos, sun_vel)\n    local planet_orb_pos1 = get_planet_orbit_position(planet1,\
    \ planet_pos1, sun_pos, sun_vel)\n    local planet_orb_pos2 = get_planet_orbit_position(planet2,\
    \ planet_pos2, sun_pos, sun_vel)\n    local planet_orb_vel1 = get_planet_orbit_velocity(planet1,\
    \ planet_vel1, sun_pos, sun_vel)\n    local planet_orb_vel2 = get_planet_orbit_velocity(planet2,\
    \ planet_vel2, sun_pos, sun_vel)\n    local planet_orb_dir1 = get_planet_orbit_dir(planet1,\
    \ planet_dir1, sun_pos, sun_vel)\n    local planet_orb_dir2 = get_planet_orbit_dir(planet2,\
    \ planet_dir2, sun_pos, sun_vel)", "   if planet1 == planet2 then\n      return\
    \ nil\n   end\n   local planet1o = string.lower(planet1)\n   local planet2o =\
    \ string.lower(planet2)\n   if planet1o == \"mercury\" or planet1o == \"venus\"\
    \ or planet1o == \"earth\" then\n      local suno = math.atan2(math.sin(math.pi/180*180)*math.cos(math.pi/180*180),\
    \ math.cos(math.pi/180*180)*math.sin(math.pi/180*180))\n      local sunsun = math.atan2(math.sin(math.pi/180*180)*math.cos(math.pi/180*180),\
    \ math.sin(math.pi/180*180)*math.sin(math.pi/180*180))\n      local sunsuno =\
    \ math.atan2(math.sin(math.pi/180*180)*math.cos(math.pi/180*180), math.cos(math.pi/180*180)*math.sin(math.pi/180*180))\
    \ + math.pi/2\n      if planet1o == \"mercury\" then\n         suno = sunsuno\
    \ - math.pi/2\n      end\n      local mercury = math.atan2(math.sin(math.pi/180*180)*math.sin(math.pi/180*180),\
    \ math.cos(math.pi/180*180)*math.cos(math.pi/180*180))\n      local venus = math.atan2(math.sin(math.pi/180*180)*math.cos(math.pi/180*180),\
    \ math.sin(math.pi/180*180)*math.sin(math.pi/180*180))\n      local earth = math.atan2(math.sin(math.pi/180*180)*math.sin(math.pi/180*180),\
    \ math.cos(math.pi/180*180)*math.sin(math.pi/180*180))\n      local mars = math.atan2(math.sin(math.pi/180*180)*math.cos(math.pi/180*180),\
    \ math.sin(math.pi/180*180)*math.sin(math.pi/180*180))\n      local jupiter =\
    \ math.atan2(math.sin(math.pi/180*180)*math.cos(math.pi/180*180), math.cos(math.pi/180*180)*math.sin(math.pi/180*180))\n\
    \      local saturn = math.atan2(math.sin(math.pi/180*180)*math.cos(math.pi/180*180),\
    \ math.sin(math.pi/180*180)*math.sin(math.pi/180*180))\n      local uranus = math.atan2(math.sin(math.pi/180*180)*math.cos(math.pi/180*180),\
    \ math.cos(math.pi/180*180)*math.sin(math.pi/180*180))\n      local ne", "   if\
    \ planet1 == planet2 then\n      return ()\n   end\n   local orbits1 = getOrbits(planet1)\n\
    \   local orbits2 = getOrbits(planet2)\n   local orbs1 = orbits1[#orbits1]\n \
    \  local orbs2 = orbits2[#orbits2]\n   local sun = getSun()\n   local maxOrb =\
    \ orbs1[#orbs1]\n   for i = 1, #orbits1 do\n      local distance = math.sqrt((orbs1[i].x\
    \ - sun.x)^2 + (orbs1[i].y - sun.y)^2 + (orbs1[i].z - sun.z)^2)\n      if distance\
    \ <= maxOrb then\n         maxOrb = distance\n      end\n   end\n   for i = 1,\
    \ #orbits2 do\n      local distance = math.sqrt((orbs2[i].x - sun.x)^2 + (orbs2[i].y\
    \ - sun.y)^2 + (orbs2[i].z - sun.z)^2)\n      if distance <= maxOrb then\n   \
    \      maxOrb = distance\n      end\n   end\n   local sortedPlanets = {}\n   local\
    \ sortedOrbits = {}\n   local i = 0\n   while i < #orbits1 and i < #orbits2 do\n\
    \      sortedPlanets[#sortedPlanets + 1] = orbits1[i].name\n      sortedOrbits[#sortedOrbits\
    \ + 1] = orbs1[i].name\n      i = i + 1\n   end\n   i = 0\n   while i < #orbits2\
    \ and i < #orbits1 do\n      sortedPlanets[#sortedPlanets + 1] = orbits2[i].name\n\
    \      sortedOrbits[#sortedOrbits + 1] = orbs2[i].name\n      i = i + 1\n   end\n\
    \   for i = 1, #sortedPlanets do\n      sortedPlanets[i] = sortedPlanets[i]:toupper()\n\
    \   end\n   for i = 1, #sortedOrbits do\n      sortedOrbits[i] = sortedOrbits[i]:toupper()\n\
    \   end\n   for i = 1, #sortedOrbits do\n      if sortedOrbits[i] == sortedPlanets[i]\
    \ then\n         sortedOrbits[i]:sub(1, #sortedOrbits[i])\n      end\n   end\n\
    \   if #sortedOrbits > 1 then\n      return (sortedPlanets[1])\n   end\n   return\
    \ ()\nend", "   \n   \n   local planets = {}\n   for _,planet in pairs(planetList)\
    \ do\n      if planet:match(planet1) then\n         if planet:match(planet2) then\n\
    \            table.insert(planets,planet)\n         end\n      end\n   end\n \
    \  \n   if #planets == 0 then return end\n   \n   \n   local distance = nil\n\
    \   for i,planet in pairs(planets) do\n      local orb = planet:getOrbit(sun)\n\
    \      distance = distance or math.abs(orb - orb)\n   end\n   \n   table.sort(planets,\
    \ function(a, b) distance:minus(a:getOrbit(sun)):minus(b:getOrbit(sun)):minus(sun)\
    \ )\n   \n   return planets\nend", "\tlocal a1, a2 = orbit(planet1, planet2)\n\
    \tlocal d1, d2 = distance(planet1, planet2)\n\t\n\tif a1 and a2 then\n\t\tlocal\
    \ a1d2 = a1 \xF7 d2\n\t\tif a1<d2 then\n\t\t\treturn {a1[1], a2[1]} -- planets\
    \ orbiting planet2 are smaller than planet1 \n\t\telseif a1d2>0 then\n\t\t\tlocal\
    \ a = a1[1]\n\t\t\tlocal b = a2[1]\n\t\t\t\n\t\t\t-- return the first planet between\
    \ them \n\t\t\tlocal p = math.ceil(a+(d2-a)/a1d2)*a1[1]\n\t\t\treturn {p,p}\n\t\
    \telseif a1d2<0 then\n\t\t\tlocal a = a1[1]\n\t\t\tlocal b = a2[1]\n\t\t\t\n\t\
    \t\t-- return the first planet between them \n\t\t\tlocal p = math.ceil(a+(d2-a)/a1d2)*a1[1]\n\
    \t\t\treturn {p,p}\n\t\telse\n\t\t\treturn {a1[1], a2[1]} -- planets orbiting\
    \ planet2 are greater than planet1 \n\t\tend\n\telseif a1 then\n\t\treturn {a1[1],\
    \ a2[1]}\n\telseif a2 then\n\t\treturn {a1[1], a2[1]}\n\telse\n\t\treturn {nil,\
    \ nil}\n\tend\nend", "    local orbit1, orbit2 = findOrbit(planet1, planet2),\
    \ findOrbit(planet2, planet1)\n    local sun = findSun()\n    \n    return findPlanets(orbit1,\
    \ orbit2, sun)\nend\n</cell>\n<text>\n5.3 Finding distances between planets\n\
    In the previous exercises, we wrote a function that finds distances from one planet\
    \ to another one. \nIn this exercise we will write a function that calculates\
    \ distances between planets.", "    local a1 = planet1:lower()\n    local a2 =\
    \ planet2:lower()\n    local s1 = \"Mercury\"\n    local s2 = \"Venus\"\n    local\
    \ s3 = \"Earth\"\n    local s4 = \"Mars\"\n    local s5 = \"Jupiter\"\n    local\
    \ s6 = \"Saturn\"\n    local s7 = \"Uranus\"\n    local s8 = \"Neptune\"", " \
    \ local planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \n                  \"Uranus\", \"Neptune\"}\n  if planet1 == nil or\
    \ planet2 == nil then\n    return \"Please input two planet names as strings\"\
    \n  elseif planets[planet1] == nil or planets[planet2] == nil then\n    return\
    \ \"Please input two planet names as strings\"\n  else\n    local planet1, planet2,\
    \ planet1_orbit_distance, planet2_orbit_distance\n    -- calculate the orbit distances\
    \ \n    local planet1_orbit_distance = math.sqrt((planets[planet1].x - sun.x)\
    \ * (planets[planet1].x - sun.x) \n                                          \
    \  + (planets[planet1].y - sun.y) * (planets[planet1].y - sun.y) \n          \
    \                                  + (planets[planet1].z - sun.z) * (planets[planet1].z\
    \ - sun.z))\n    local planet2_orbit_distance = math.sqrt((planets[planet2].x\
    \ - sun.x) * (planets[planet2].x - sun.x) \n                                 \
    \           + (planets[planet2].y - sun.y) * (planets[planet2].y - sun.y) \n \
    \                                           + (planets[planet2].z - sun.z) * (planets[planet2].z\
    \ - sun.z))", "\tlocal distance1, distance2, distance3, distance4, distance5 =\
    \ \n\t\tmath.abs(moon1.x - moon2.x), math.abs(moon1.y - moon2.y), math.abs(moon1.z\
    \ - moon2.z), math.abs(moon1.r - moon2.r), math.abs(moon1.i - moon2.i)\n\tlocal\
    \ distance6, distance7 = math.abs(moon1.y - moon3.y), math.abs(moon1.z - moon3.z),\
    \ math.abs(moon1.r - moon3.r), math.abs(moon1.i - moon3.i)", "  local orbit1 =\
    \ get_orbit(planet1)\n  local orbit2 = get_orbit(planet2)", "    local planets\
    \ = { \n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \n        \"Uranus\", \"Neptune\", \"Ceres\"\n    }", "   local function dist(planet,\
    \ sun)\n      return math.abs((sun - planet):length())\n   end\n   local function\
    \ dist1(planet, sun)\n      return math.abs((sun - planet):length())\n   end\n\
    \   local function dist2(planet1, planet2)\n      return math.abs((planet1 - planet2):length())\n\
    \   end\n   local function f(planet)\n      local sun = planet:get_mass():length()\n\
    \      if sun > 0.1 then\n         return (sun, planet)\n      end\n      return\
    \ (math.abs(sun - 0.1), planet)\n   end\n   local p1 = f(planet1)\n   local p2\
    \ = f(planet2)\n   local p3 = f(planet1)\n   local p4 = f(planet2)", "  if planet1\
    \ ~= planet2 then return end\n  local pl_1 = tonumber(planet1)\n  local pl_2 =\
    \ tonumber(planet2)\n  if pl_1 == nil or pl_2 == nil then return end\n  local\
    \ planets = {pl_1, pl_2}\n  local sun = sun()\n  local coords = sun:get_coords()\n\
    \  local planet_1_id = tonumber(coords:get_value(pl_1, 1))\n  local planet_2_id\
    \ = tonumber(coords:get_value(pl_2, 1))\n  -- For each planet in the sun coordinates,\
    \ check its orbit in the sun\n  -- coordinates, and for each orbit in the sun\
    \ coordinates check whether\n  -- the two planets orbits were in orbit with each\
    \ other (i.e. the planet\n  -- coordinates are in the same orbit as the sun).\n\
    \  local orbits = {}\n  for i, plan in ipairs(planets) do\n    local planet_orbits\
    \ = sun:orbit_sun(plan)\n    for _, orbits in ipairs(planet_orbits) do\n     \
    \ for j = 1, #orbits do\n        local orb = orbits[j]\n        local planet_id\
    \ = tonumber(orb:get_value(plan, 1))\n        if planet_id == nil then return\
    \ end\n        if planet_id == planet_1_id then\n          orbits[i] = orb\n \
    \         break\n        end\n        if planet_id == planet_2_id then\n     \
    \     orbits[i] = orb\n          break\n        end\n      end\n    end\n    orbits[i]\
    \ = nil\n  end\n  -- Return all orbits that are in the same orbit as the sun\n\
    \  for _, orb in ipairs(orbits) do\n    local planets = orb:get_value(sun, 2)\n\
    \    if #planets == 1 then\n      return orb:get_value(sun, 1)\n    end\n  end\n\
    end", "\tlocal lPlanets = {planet1, planet2}\n\tlocal lNPlanets = {}\n\tlocal\
    \ lTemp = {}\n\tlocal lResult = {}\n\tlocal lMax = 0\n\tfor i = 1, #lPlanets do\n\
    \t\tlocal lDistance = GetDistanceBetweenTwoPlanets(\n\t\t\t\tlPlanets[i], lPlanets[(i\
    \ + 1) % #lPlanets])\n\t\tlocal lDistance2 = GetDistanceBetweenTwoPlanets(\n\t\
    \tlPlanets[i], lPlanets[(i - 1) % #lPlanets])\n\t\tif lDistance < lMax then\n\t\
    \t\tlResult[#lResult+1] = lPlanets[i]\n\t\tend\n\t\tif lDistance > lMax then\n\
    \t\t\tlResult[#lResult+1] = lPlanets[(i - 1) % #lPlanets]\n\t\tend\n\t\tif lDistance2\
    \ < lMax then\n\t\t\tlResult[#lResult+1] = lPlanets[i]\n\t\tend\n\t\tif lDistance2\
    \ > lMax then\n\t\t\tlResult[#lResult+1] = lPlanets[(i + 1) % #lPlanets]\n\t\t\
    end\n\t\tlNPlanets[#lNPlanets+1] = lPlanets[i]\n\t\tlNPlanets[#lNPlanets+1] =\
    \ lPlanets[(i + 1) % #lPlanets]\n\t\tlMax = lMax * 1.1\n\tend\n\tfor i = 1, #lResult\
    \ do\n\t\ttable.insert(lTemp, i)\n\tend\n\tfor i = 1, #lNPlanets do\n\t\tif lTemp[#lTemp]\
    \ == lNPlanets[i] then\n\t\t\ttable.insert(lTemp, #lTemp - 1)\n\t\tend\n\tend\n\
    \ttable.sort(lTemp, function(t1,t2)\n\t\tlocal lDistance1 = GetDistanceBetweenTwoPlanets(\n\
    \t\tlPlanets[t1], lPlanets[t2])\n\t\tlocal lDistance2 = GetDistanceBetweenTwoPlanets(\n\
    \t\tlPlanets[t1], lPlanets[(#lPlanets + t2 + 1) % #lPlanets])\n\t\tif lDistance1\
    \ < lDistance then\n\t\t\treturn 1\n\t\telseif lDistance1 > lDistance then\n\t\
    \t\treturn -1\n\t\telseif lDistance2 < lDistance then\n\t\t\treturn -1\n\t\telseif\
    \ lDistance2 > lDistance then\n\t\t\treturn 1\n\t\telse\n\t\t\treturn 0\n\t\t\
    end\n\tend)\n\ttable.insert(lResult, lPlanets[#lPlanets])\n\ttable.insert(lResult,\
    \ lPlanet", "  if planet1 == planet2 then\n    return {}\n  end", "    local dist1\
    \ = math.sqrt(math.pow(planet1.x - sun.x, 2) + math.pow(planet1.y - sun.y, 2)\
    \ + math.pow(planet1.z - sun.z, 2))\n    local dist2 = math.sqrt(math.pow(planet2.x\
    \ - sun.x, 2) + math.pow(planet2.y - sun.y, 2) + math.pow(planet2.z - sun.z, 2))\n\
    \    local dist3 = math.sqrt(math.pow(planet1.x - planet2.x, 2) + math.pow(planet1.y\
    \ - planet2.y, 2) + math.pow(planet1.z - planet2.z, 2))\n    local dist4 = math.sqrt(math.pow(planet1.x\
    \ - sun.x, 2) + math.pow(planet1.y - sun.y, 2) + math.pow(planet1.z - sun.z, 2))\n\
    \    local dist5 = math.sqrt(math.pow(planet2.x - sun.x, 2) + math.pow(planet2.y\
    \ - sun.y, 2) + math.pow(planet2.z - sun.z, 2))\n    local dist6 = math.sqrt(math.pow(planet1.x\
    \ - planet2.x, 2) + math.pow(planet1.y - planet2.y, 2) + math.pow(planet1.z -\
    \ planet2.z, 2))\n    local dist7 = math.sqrt(math.pow(planet1.x - sun.x, 2) +\
    \ math.pow(planet1.y - sun.y, 2) + math.pow(planet1.z - sun.z, 2))\n    local\
    \ dist8 = math.sqrt(math.pow(planet2.x - sun.x, 2) + math.pow(planet2.y - sun.y,\
    \ 2) + math.pow(planet2.z - sun.z, 2))\n    local dist9 = math.sqrt(math.pow(planet1.x\
    \ - planet2.x, 2) + math.pow(planet1.y - planet2.y, 2) + math.pow(planet1.z -\
    \ planet2.z, 2))\n    local dist10 = math.sqrt(math.pow(planet1.x - sun.x, 2)\
    \ + math.pow(planet1.y - sun.y, 2) + math.pow(planet1.z - sun.z, 2))\n    local\
    \ dist11 = math.sqrt(math.pow(planet2.x - sun.x, 2) + math.pow(planet2.y - sun.y,\
    \ 2) + math.pow(planet2.z - sun.z, 2))\n    local dist12 = math.sqrt(math.pow(planet1.x\
    \ - planet2.x, 2) + math.pow(planet1.y - planet2.y, 2) + math.pow(planet1.z -\
    \ planet2.z, 2))\n    local dist13 = math.sqrt(math.pow(planet1.x - sun.x, 2)\
    \ + math.pow(planet1.y - sun.y, 2) + math.pow(planet1.z - sun.z, 2))\n    local\
    \ dist14 = math.sqrt(math.pow(planet2.x - sun.x, 2) + math.pow(planet2.y - sun.y,\
    \ 2) + math.pow(planet2.z - sun.z, 2))\n    local dist15 = math.sqrt(math.pow(planet",
  "  local earth, mars, jupiter, saturn, uranus, neptune = {Earth = \"Earth\",\n\t\
    Mars = \"Mars\",\n\tJupiter = \"Jupiter\",\n\tSaturn = \"Saturn\",\n\tUranus =\
    \ \"Uranus\",\n\tNeptune = \"Neptune\"};\n  local planets = {}; \n  local a1,\
    \ a2 = {}, {};\n  if earth ~= planet1 then\n    planets[earth] = a1; \n  elseif\
    \ mars ~= planet1 then\n    planets[mars] = a1;\n  elseif jupiter ~= planet1 then\n\
    \    planets[jupiter] = a1;\n  elseif saturn ~= planet1 then\n    planets[saturn]\
    \ = a1;\n  elseif uranus ~= planet1 then\n    planets[uranus] = a1;\n  elseif\
    \ neptune ~= planet1 then\n    planets[neptune] = a1;\n  end\n  if earth ~= planet2\
    \ then\n    planets[earth] = a2;\n  elseif mars ~= planet2 then\n    planets[mars]\
    \ = a2;\n  elseif jupiter ~= planet2 then\n    planets[jupiter] = a2;\n  elseif\
    \ saturn ~= planet2 then\n    planets[saturn] = a2;\n  elseif uranus ~= planet2\
    \ then\n    planets[uranus] = a2;\n  elseif neptune ~= planet2 then\n    planets[neptune]\
    \ = a2;\n  end\n  if #planets ~= 0 then\n    for i = 1, #planets do\n      if\
    \ a1[i - 1] == a2[i - 1] then\n\tplanets[earth] = a1;\n\tplanets[mars] = a1;\n\
    \tplanets[jupiter] = a1;\n\tplanets[saturn] = a1;\n\tplanets[uranus] = a1;\n\t\
    planets[neptune] = a1;\n\tbreak; \n      end\n      if a1[i - 1] < a2[i - 1] then\n\
    \tplanets[earth] = a1;\n\tplanets[mars] = a1;\n\tplanets[jupiter] = a1;\n\tplanets[saturn]\
    \ = a1;", "    local sun = get_sun()\n    local planet1orbit = get_orbit(planet1)\n\
    \    local planet2orbit = get_orbit(planet2)", "\tlocal planets, sun\n\tsun =\
    \ require(\"sun\")\n\tplanets = {}\n\tlocal planet1, planet2 = planet1, planet2",
  "  return getOrbit(planet1, planet2)\nend", "    local l1 = tonumber(planet1):find('%w+')\
    \ \n    local l2 = tonumber(planet2):find('%w+')\n    if l1 ~= nil and l2 ~= nil\
    \ then\n        if l1 > l2 then\n            return bf(tonumber(planet1), tonumber(planet2))\n\
    \        elseif l2 > l1 then\n            return bf(tonumber(planet2), tonumber(planet1))\n\
    \        elseif l1 == l2 then\n            -- Planets are on the same orbit\n\
    \            return ()\n        else\n            -- Mercury orbits to Venus\n\
    \            return bf(tonumber(planet1), tonumber(planet2))\n        end\n  \
    \  else\n        return ()\n    end\nend\n</code>\n<|/ a dscore=1 tags=lua,sorting,lua-table,algorithm\
    \ |>\n<| a dscore=0 |>\nYou can use a dictionary to store each planet name as\
    \ key and its orbit as value:\n<code>", "  -- TODO: write your code here\n  return\
    \ nil\nend", "    local orbit1 = 0\n    local orbit2 = 0\n    local distance1\
    \ = 0\n    local distance2 = 0", "  local earth, mars, jupiter, saturn, uranus,\
    \ neptune =\n  {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n  \n  local planet1orbit, planet2orbit = {}, {}", "\tlocal p1 = tonumber(planet1)\n\
    \tlocal p2 = tonumber(planet2)\n\tif not p1 or not p2 then return end\n\tlocal\
    \ s = tonumber(getElementById(\"SunRadius\").value)\n\tlocal c = getElementById(\"\
    SunDistance\").value\n\tlocal t = getElementById(\"SunAngle\").value\n\t\n\tlocal\
    \ planets = {p1, p2}\n\t\n\tfor i=1,#planets do\n\t\tlocal planet = planets[i]\n\
    \t\tlocal p = tonumber(planet)\n\t\tif not p then break end\n\t\t\n\t\tlocal p2\
    \ = getElementById(string.gsub(\"%1$s%2$s\", planet, planet2, 1, 1))\n\t\tif not\
    \ p2 then break end\n\t\t\n\t\tlocal dist = distance(p.x, p.y, p.z, c * s.x, c\
    \ * s.y, c * s.z, s * t, s * t)\n\t\tlocal ang = math.acos((p.x - p2.x) * s.x\
    \ + (p.y - p2.y) * s.y + (p.z - p2.z) * s.z / ( dist * dist))\n\t\tif dist < c\
    \ / 2 then\n\t\t\ttable.insert(planets, p)\n\t\t\ttable.insert(planets, p2)\n\t\
    \tend\n\tend\n\t\n\ttable.sort(planets, function(a, b) return (distance(a.x, a.y,\
    \ a.z, c.x, c.y, c.z, s * t, s * t) - distance(a.x, a.y, a.z, b.x, b.y, b.z, s\
    \ * t, s * t)) < 0 end)\n\t\n\treturn planets\nend", "    if not (planet1 == \"\
    Mercury\" and planet2 == \"Neptune\") then\n        return ()\n    end\n    \n\
    \    local orbits1 = {\n        {\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"},\n        {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"},\n        {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"},\n        {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    },\n        {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"},\n        {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"},\n        {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    },\n        {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"},\n        {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    }", "\tlocal p1 = tonumber(planet1)\n\
    \tlocal p2 = tonumber(planet2)\n\tif p1 then\n\t\tif p2 then\n\t\t\treturn {}\n\
    \t\telse\n\t\t\treturn {planet1}\n\t\tend\n\telse\n\t\tif p2 then\n\t\t\treturn\
    \ {planet2}\n\t\telse\n\t\t\treturn {}\n\t\tend\n\tend\nend", "\tlocal orbit1\
    \ = orbit(planet1)\n\tlocal orbit2 = orbit(planet2)\n\tlocal distance1 = distance(orbit1,\
    \ sun)\n\tlocal distance2 = distance(orbit2, sun)\n\tif distance1 < distance2\
    \ then\n\t\ttable.sort(orbit1, function(a,b) return distance(a) < distance(b)\
    \ end)\n\t\ttable.sort(orbit2, function(a,b) return distance(a) < distance(b)\
    \ end)\n\t\treturn orbit1, orbit2\n\tend\n\tif distance1 > distance2 then\n\t\t\
    table.sort(orbit2, function(a,b) return distance(a) < distance(b) end)\n\t\ttable.sort(orbit1,\
    \ function(a,b) return distance(a) < distance(b) end)\n\t\treturn orbit2, orbit1\n\
    \tend\n\ttable.sort(orbit1, function(a,b) return distance(a) < distance(b) end)\n\
    \ttable.sort(orbit2, function(a,b) return distance(a) < distance(b) end)\n\treturn\
    \ orbit1, orbit2\nend", "  local M = {}\n  local S = {}", "    local planets =\
    \ {}\n    \n    for i=0,8 do\n        if (planet1 == planets[i]) then\n      \
    \      if (planet2 == planets[i+1]) then\n                planets[#planets+1]\
    \ = planets[i]\n                planets[#planets+1] = planets[i+1]\n         \
    \       planets[#planets+1] = planets[i+2]\n                planets[#planets+1]\
    \ = planets[i+3]\n                planets[#planets+1] = planets[i+4]\n       \
    \         planets[#planets+1] = planets[i+5]\n                planets[#planets+1]\
    \ = planets[i+6]\n                planets[#planets+1] = planets[i+7]\n       \
    \         planets[#planets+1] = planets[i+8]\n                return planets\n\
    \            end\n        end\n    end\n    return ()\nend", "    local orbits1\
    \ = {}\n    local orbits2 = {}\n    local sundist = math.sqrt((((getJupiter()^2)+getVenus()^2)^2)+getEarth()^2)\n\
    \    if planet1 ~= nil and planet2 ~= nil then\n        for i=1,#planet1,1 do\n\
    \            local p1 = tonumber(planet1[i])\n            local p2 = tonumber(planet2[i])\n\
    \            if p2 > p1 then\n                local sun1 = getSun(math.sin(p1\
    \ * (math.pi / 180))) \n                local sun2 = getSun(math.sin(p2 * (math.pi\
    \ / 180))) \n                local dist = math.abs(math.acos(math.sin(sun1)* math.sin(sun2)\
    \ + math.cos(sun1)* math.cos(sun2) * math.cos((p2-p1)*(math.pi/180))))\n     \
    \           \n                if dist < sundist then\n                    orbits1[#orbits1+1]\
    \ = p1\n                    orbits1[#orbits1+1] = p2\n                end\n  \
    \          else\n                local sun1 = getSun(math.sin(p1 * (math.pi /\
    \ 180))) \n                local sun2 = getSun(math.sin(p2 * (math.pi / 180)))\
    \ \n                local dist = math.abs(math.acos(math.sin(sun1)* math.sin(sun2)\
    \ + math.cos(sun1)* math.cos(sun2) * math.cos((p2-p1)*(math.pi/180))))\n     \
    \           \n                if dist < sundist then\n                    orbits2[#orbits2+1]\
    \ = p1\n                    orbits2[#orbits2+1] = p2\n                end\n  \
    \          end\n        end\n    end\n    if #orbits1 ~= #orbits2 then\n     \
    \   return nil\n    else\n        table.sort(orbits1)\n        table.sort(orbits2)\n\
    \        return orbits1, orbits2\n    end\nend", "\t\n\t-- Write your code here!\n\
    \t\n\treturn nil\nend", "   \n   if planet1 == nil then\n      return ()\n   end",
  "\tlocal sun = math.sqrt{Math.pow(Planets[planet1].mass, 2) + \n\t\tMath.pow(Planets[planet2].mass,\
    \ 2)}\n\tlocal planets = {}\n\t\n\tlocal p1 = Planets[planet1].pos\n\tlocal p2\
    \ = Planets[planet2].pos\n\tlocal delta = p2 - p1\n\t\n\tfor i = 0, #Planets do\
    \ \n\t\t\n\t\tlocal d = delta.x * Planets[i].pos.x + delta.y * Planets[i].pos.y\
    \ + delta.z * Planets[i].pos.z\n\t\tif d < 0 then\n\t\t\td = math.abs(d)\n\t\t\
    \tdelta.x = -delta.x\n\t\t\tdelta.y = -delta.y\n\t\t\tdelta.z = -delta.z\n\t\t\
    end\n\t\tif d < sun then\n\t\t\tplanets[i] = Planets[i]\n\t\tend\n\tend\n\t\n\t\
    planets = SortByProximity(planets)\n\treturn planets\nend", "  if planet1 == \"\
    Mercury\" and planet2 == \"Earth\" then\n    return (\"Venus\")\n  end\n  \n \
    \ if planet1 == \"Venus\" and planet2 == \"Earth\" then\n    return (\"Earth\"\
    )\n  end\n  \n  if planet1 == \"Mars\" and planet2 == \"Earth\" then\n    return\
    \ (\"Mercury\", \"Jupiter\")\n  end\n  \n  if planet1 == \"Jupiter\" and planet2\
    \ == \"Earth\" then\n    return (\"Mars\", \"Saturn\", \"Mercury\")\n  end\n \
    \ \n  if planet1 == \"Saturn\" and planet2 == \"Earth\" then\n    return (\"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Mercury\")\n  end\n  \n  if planet1 == \"Uranus\"\
    \ and planet2 == \"Earth\" then\n    return (\"Jupiter\", \"Saturn\", \"Mercury\"\
    )\n  end\n  \n  if planet1 == \"Neptune\" and planet2 == \"Earth\" then\n    return\
    \ (\"Jupiter\", \"Saturn\", \"Mercury\")\n  end\n  \n  if planet1 == \"Mercury\"\
    \ and planet2 == \"Earth\" then\n    return (\"Jupiter\", \"Saturn\", \"Mercury\"\
    )\n  end\n  \n  if planet1 == \"Venus\" and planet2 == \"Earth\" then\n    return\
    \ (\"Jupiter\", \"Saturn\", \"Mercury\")\n  end\n  \n  if planet1 == \"Mars\"\
    \ and planet2 == \"Earth\" then\n    return (\"Jupiter\", \"Saturn\", \"Mercury\"\
    )\n  end\n  \n  if planet1 == \"Jupiter\" and planet2 == \"Earth\" then\n    return\
    \ (\"Jupiter\", \"Saturn\", \"Mercury\")\n  end\n  \n  if planet1 == \"Saturn\"\
    \ and planet2 == \"Earth\" then\n    return (\"Jupiter\", \"Saturn\", \"Mercury\"\
    )\n  end\n  \n  if planet1 == \"Uranus\" and planet2 == \"Earth\" then\n    return\
    \ (\"Jupiter\", \"Saturn\", \"Mercury\")\n  end\n  \n  if planet1 == \"Neptune\"\
    \ and planet2 == \"Earth\" then\n    return (\"Jupiter\", \"Saturn\", \"Mercury\"\
    )\n  end\n  \n  if planet1 == \"Mercury\" and planet2 == \"Mars\" then\n    return\
    \ (\"Mercury\")\n  end\n  \n  if planet1 == \"Venus\" and planet2 == \"Mars\"\
    \ then\n    return (\"Mercury\", \"Venus\")\n  end\n  \n  if plan", "\tlocal function\
    \ distance(t1, t2)\n\t\treturn math.sqrt((t1.x - t2.x)^2 + (t1.y - t2.y)^2 + (t1.z\
    \ - t2.z)^2)\n\tend\n\t\n\tlocal planets = { \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" }\n\t\n\tif planet1\
    \ ~= nil and planet2 ~= nil then\n\t\tif planet1 == planet2 then\n\t\t\treturn\
    \ {planet2}\n\t\telseif planet1 == planets[1] then\n\t\t\treturn {planets[2],\
    \ planets[1], planets[2]}\n\t\telseif planet2 == planets[2] then\n\t\t\treturn\
    \ {planets[1], planets[3], planets[1]}\n\t\telseif planets[1] == planets[2] then\n\
    \t\t\treturn {planets[2], planets[1], planets[2]}\n\t\telseif planets[3] == planets[2]\
    \ then\n\t\t\treturn {planets[1], planets[4], planets[1]}\n\t\telseif planets[2]\
    \ == planets[3] then\n\t\t\treturn {planets[1], planets[4], planets[1]}\n\t\t\
    elseif planets[1] == planets[3] then\n\t\t\treturn {planets[2], planets[1], planets[4]}\n\
    \t\telseif planets[4] == planets[1] then\n\t\t\treturn {planets[3], planets[4],\
    \ planets[3]}\n\t\telseif planets[2] == planets[4] then\n\t\t\treturn {planets[1],\
    \ planets[4], planets[3]}\n\t\telseif planets[3] == planets[4] then\n\t\t\treturn\
    \ {planets[1], planets[2], planets[4]}\n\t\telseif planets[4] == planets[2] then\n\
    \t\t\treturn {planets[2], planets[4], planets[3]}\n\t\tend\n\tend\nend", "   \
    \ local planet1 = string.lower(planet1)\n    local planet2 = string.lower(planet2)\n\
    \    if planet1 ~= planet2 then\n        return ()\n    end\n    \n    if planet1\
    \ ~= \"mercury\" then\n        return ()\n    end\n    \n    if planet1 ~= \"\
    venus\" then\n        return ()\n    end\n    \n    if planet1 ~= \"earth\" then\n\
    \        return ()\n    end\n    \n    if planet1 ~= \"mars\" then\n        return\
    \ ()\n    end\n    \n    if planet1 ~= \"jupiter\" then\n        return ()\n \
    \   end\n    \n    if planet1 ~= \"saturn\" then\n        return ()\n    end\n\
    \    \n    if planet1 ~= \"uranus\" then\n        return ()\n    end\n    \n \
    \   if planet1 ~= \"neptune\" then\n        return ()\n    end\n    \n    if planet1\
    \ ~= \"mercury\" then\n        return ()\n    end\n    \n    if planet1 ~= \"\
    venus\" then\n        return ()\n    end\n    \n    if planet1 ~= \"earth\" then\n\
    \        return ()\n    end\n    \n    if planet1 ~= \"mars\" then\n        return\
    \ ()\n    end\n    \n    if planet1 ~= \"jupiter\" then\n        return ()\n \
    \   end\n    \n    if planet1 ~= \"saturn\" then\n        return ()\n    end\n\
    \    \n    if planet1 ~= \"uranus\" then\n        return ()\n    end\n    \n \
    \   if planet1 ~= \"neptune\" then\n        return ()\n    end\n    \n    \n \
    \   if planet2 ~= \"mercury\" then\n        return ()\n    end\n    \n    if planet2\
    \ ~= \"venus\" then\n        return ()\n    end\n    \n    if planet2 ~= \"earth\"\
    \ then\n        return ()\n    end\n    \n    if planet2 ~= \"mars\" then\n  \
    \      return ()\n    end\n    \n    if planet2 ~= \"jupiter\" then\n        return\
    \ ()\n    end\n    \n    if planet2 ~= \"saturn\" then\n        return ()\n  \
    \  end\n    \n    if planet2 ~= \"uranus\" then\n        return ()\n    end\n\
    \    \n    if planet2 ~= \"neptune\" then\n        return ()\n    end\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    ", "  if planet1 == planet2 then\n    return (planet1, planet2)\n \
    \ else\n    local planets = { planet1, planet2 }\n    for i=1, #planets do\n \
    \     local solar = math.sqrt((math.pow(planets[i][\"mass\"], 2)) + (math.pow(planets[i][\"\
    radius\"], 2)))\n      local distance = math.sqrt((math.pow(planets[i][\"orbital_distance\"\
    ], 2)) + (math.pow(planets[i][\"radius\"], 2)))\n      if distance < solar then\n\
    \        return planets\n      end\n    end\n  end\nend", "   assert(planet1 ~=\
    \ \"\", \"Must specify a planet.\")\n   assert(planet2 ~= \"\", \"Must specify\
    \ a planet.\")\n   -- TODO: write your code here\n   return {}\nend", "    --\
    \ The function should return a tuple containing all planets whose \n    -- orbits\
    \ are located between the orbit of planet1 and the orbit of \n    -- planet2,\
    \ sorted by the proximity to the sun. \n    -- The function should return an empty\
    \ tuple if planet1 or planet2\n    -- are not correct planet names.\n    if planet1\
    \ == nil or planet2 == nil then\n        return nil\n    end", "  local i1,i2=string.find(planet1,\"\
    (\"),string.find(planet2,\")\")\n  if i1 and i2 then\n    local planet1=string.sub(planet1,i1,i2-i1)\n\
    \    local planet2=string.sub(planet2,i1+1,i2-i1+1)\n    return \n  elseif i1\
    \ then return (string.sub(planet1,i1+1,-1),string.sub(planet2,i1+1,-1))\n  elseif\
    \ i2 then return (string.sub(planet2,i1+1,-1),string.sub(planet1,i1+1,-1))\n \
    \ else return (\"\",\"\")\n  end\nend", "\t-- Your code here\nend", "\tlocal p1\
    \ = string.match(planet1, \".*\")\n\tlocal p2 = string.match(planet2, \".*\")\n\
    \t\n\tif p1 == nil or p2 == nil then\n\t\treturn ()\n\tend\n\t\n\tlocal i, distance\
    \ = nil, nil\n\tfor i = 1, 8 do\n\t\tlocal distance = math.abs(getPlanetDistance(p1[i],\
    \ p2[i]))\n\t\tif distance <= 1 then\n\t\t\treturn (planet1, planet2, i)\n\t\t\
    end\n\tend\n\treturn ()\nend", "\tlocal j1, j2\n\tlocal i1, i2, i3, i4, i5, i6,\
    \ i7, i8, i9\n\tlocal l1, l2, l3, l4, l5, l6, l7, l8, l9\n\tlocal p1, p2\n\tlocal\
    \ r1, r2, r3, r4, r5, r6, r7, r8\n\tlocal s1, s2, s3, s4, s5, s6, s7, s8, s9",
  "    local orbit1, orbit2, distance, orbit1, orbit2, distance = {},{},{},{},{},{}\n\
    \    -- initialize distance dictionary\n    for i = 1, #Planet do\n        distance[Planet[i]]\
    \ = {}\n    end", "    return \nend", "  if planet1 ~= \"Earth\" and planet1 ~=\
    \ \"Mars\" and planet1 ~= \"Jupiter\" and planet1 ~= \"Saturn\" and planet1 ~=\
    \ \"Uranus\" and planet1 ~= \"Neptune\" and planet1 ~= \"Mercury\" then\n    return\
    \ ()\n  elseif planet2 ~= \"Earth\" and planet2 ~= \"Mars\" and planet2 ~= \"\
    Jupiter\" and planet2 ~= \"Saturn\" and planet2 ~= \"Uranus\" and planet2 ~= \"\
    Neptune\" and planet2 ~= \"Mercury\" then\n    return ()\n  elseif planet1 ~=\
    \ planet2 then\n    return ()\n  end", "    local planet1orbit = #orbits[planet1]\
    \ - 1\n    local planet2orbit = #orbits[planet2] - 1\n    local mindist", "  \
    \  local n1=planet1\n    local n2=planet2\n    local p1=orbs[planet1]\n    local\
    \ p2=orbs[planet2]\n    local s1=planet1\n    local s2=planet2\n    local d1=p1[1]\n\
    \    local d2=p2[1]\n    local t1=p1[2]\n    local t2=p2[2]\n    local t1=p1[3]\n\
    \    local t2=p2[3]\n    local d1=p1[1]\n    local d2=p2[1]\n    local t1=p1[2]\n\
    \    local t2=p2[2]\n    local t1=p1[3]\n    local t2=p2[3]\n    local t1=p1[4]\n\
    \    local t2=p2[4]\n    local t1=p1[5]\n    local t2=p2[5]\n    local t1=p1[6]\n\
    \    local t2=p2[6]\n    local t1=p1[7]\n    local t2=p2[7]\n    local t1=p1[8]\n\
    \    local t2=p2[8]\n    local t1=p1[9]\n    local t2=p2[9]\n    local t1=p1[10]\n\
    \    local t2=p2[10]\n    local t1=p1[11]\n    local t2=p2[11]\n    local t1=p1[12]\n\
    \    local t2=p2[12]\n    local t1=p1[13]\n    local t2=p2[13]\n    local t1=p1[14]\n\
    \    local t2=p2[14]\n    local t1=p1[15]\n    local t2=p2[15]\n    local t1=p1[16]\n\
    \    local t2=p2[16]\n    local t1=p1[17]\n    local t2=p2[17]\n    local t1=p1[18]\n\
    \    local t2=p2[18]\n    local t1=p1[19]\n    local t2=p2[19]\n    local t1=p1[20]\n\
    \    local t2=p2[20]\n    local t1=p1[21]\n    local t2=p2[21]\n    local t1=p1[22]\n\
    \    local t2=p2[22]\n    local t1=p1[23]\n    local t2=p2[23]\n    local t1=p1[24]\n\
    \    local t2=p2[24]\n    local t1=p1[25]\n    local t2=p2[25]", "    if planet1\
    \ == planet2 then return () end\n    if #planet1 == #planet2 then return (planet1,\
    \ planet2) end\n    local sun = math.rad(sun_pos)\n    local dist = sun_dist(planet1,\
    \ planet2)\n    local p1 = plns[planet1]\n    local p2 = plns[planet2]\n    local\
    \ o1 = p1 -- Planet 1 orbit\n    local o2 = p2 -- Planet 2 orbit\n    local o3\
    \ = p1 + dcos(sun - sun_pos) -- Planet 1 orbit in relation to sun\n    local o4\
    \ = p2 + dcos(sun - sun_pos) -- Planet 2 orbit in relation to sun\n    local p3\n\
    \    local p4\n    local s\n    if o3 > o4 then\n        s = o3 - (o4 - o3)\n\
    \        p3 = p1\n        p4 = p2\n    else\n        s = o4 - (o3 - o4)\n    \
    \    p3 = p2\n        p4 = p1\n    end\n    if s > 0 then\n        p3 = p1 + dcos(sun\
    \ - sun_pos - s)\n        p4 = p2 + dcos(sun - sun_pos - s)\n    end\n    local\
    \ i1 = p3 * dcos(sun_pos) - p4 * dsin(sun_pos)\n    local i2 = p3 * dsin(sun_pos)\
    \ + p4 * dcos(sun_pos)\n    local i3 = p2 * dcos(sun_pos) + p1 * dsin(sun_pos)\n\
    \    local i4 = p2 * dsin(sun_pos) - p1 * dcos(sun_pos)\n    local i5 = i3 - i4\n\
    \    local i6 = i1 + i5\n    local i7 = i2 + i5\n    local i8 = i1 - i5\n    return\
    \ i6 < i7 or (i6 < i8 and (i7 < i1 or i7 < i2) and (i1 < i2 or i1 < i3)) and i6\
    \ < i8\nend", "  assert(type(planet1) == \"string\" and type(planet2) == \"string\"\
    )\n  local orbit1, orbit2 = get_orbit(planet1), get_orbit(planet2)\n  local sun_orbit\
    \ = get_orbit(get_planet_by_name(\"Sun\"))\n  local sun_distance = get_distance(orbit1,\
    \ sun_orbit)\n  local planet_distance = {}\n  for k, v in pairs(orbit1) do\n \
    \   local dist_sun = get_distance(k, sun_orbit)\n    local dist_planet = get_distance(k,\
    \ orbit2)\n    if dist_sun > dist_planet and dist_sun < sun_distance then\n  \
    \    table.insert(planet_distance, k)\n    end\n  end\n  table.sort(planet_distance,\
    \ function(a, b)\n    return get_distance(get_orbit(a), get_orbit(b))\n  end)\n\
    \  if #planet_distance == 0 then\n    return {}\n  else\n    return planet_distance\n\
    \  end\nend", "  local distances = {}\n  local orbits  = {}\n  \n  for i = 0,\
    \ #planets do\n    local distance  = distanceFromSun(planets[i], planet1, planet2)\n\
    \    local orbit      = planets[#planets]", "    -- Your code here\n    local\
    \ dist = {}\n    \n    for i=1, #planets do\n        if planets[i] == planet1\
    \ then\n            local temp = distance.new(0, math.floor(planets[i].lon - jupiter[i].lon),\
    \ math.floor(planets[i].lat - jupiter[i].lat))\n            table.insert(dist,\
    \ temp)\n        end\n        if planets[i] == planet2 then\n            local\
    \ temp = distance.new(0, math.floor(planets[i].lon - jupiter[i].lon), math.floor(planets[i].lat\
    \ - jupiter[i].lat))\n            table.insert(dist, temp)\n        end\n    end",
  "\tlocal results = {}\n\t\n\tlocal planet1 = get_planet(planet1)\n\tlocal planet2\
    \ = get_planet(planet2)", "    -- Your code here\n    \n    return planet1, planet2\n\
    end", "    local orbit1, orbit2, temp = {}, {}, {}\n    local distance = 0\n \
    \   local distance1 = math.abs(math.sin(math.deg2rad(math.rad(zenith.deg)))) \n\
    \    local distance2 = math.abs(math.cos(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance3 = math.abs(math.sin(math.deg2rad(math.rad(inclination.deg))))\n\
    \    local distance4 = math.abs(math.cos(math.deg2rad(math.rad(inclination.deg))))\n\
    \    local distance5 = math.abs(math.sin(math.deg2rad(math.rad(longitude.deg))))\n\
    \    local distance6 = math.abs(math.cos(math.deg2rad(math.rad(longitude.deg))))\n\
    \    local distance7 = math.abs(math.sin(math.deg2rad(math.rad(latitude.deg))))\n\
    \    local distance8 = math.abs(math.cos(math.deg2rad(math.rad(latitude.deg))))\n\
    \    local distance9 = math.abs(math.sin(math.deg2rad(math.rad(longitude.deg))))\n\
    \    local distance10 = math.abs(math.cos(math.deg2rad(math.rad(longitude.deg))))\n\
    \    local distance11 = math.abs(math.sin(math.deg2rad(math.rad(latitude.deg))))\n\
    \    local distance12 = math.abs(math.cos(math.deg2rad(math.rad(latitude.deg))))\n\
    \    local distance13 = math.abs(math.sin(math.deg2rad(math.rad(inclination.deg))))\n\
    \    local distance14 = math.abs(math.cos(math.deg2rad(math.rad(inclination.deg))))\n\
    \    local distance15 = math.abs(math.sin(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance16 = math.abs(math.cos(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance17 = math.abs(math.sin(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance18 = math.abs(math.cos(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance19 = math.abs(math.sin(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance20 = math.abs(math.cos(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance21 = math.abs(math.sin(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance22 = math.abs(math.cos(math.deg2rad(math.rad(zenith.deg))))\n\
    \    local distance23 = math.abs(math.sin(math.deg2rad(math.rad(zenith", "   \
    \ -- TODO: your code here\n    return ()\nend", "\tlocal a = {planet1, planet2}\n\
    \tlocal m = {}\n\tfor _, v in pairs(a) do\n\t\ttable.insert(m, v)\n\tend\n\tlocal\
    \ i = 2\n\tfor _, v in pairs(m) do\n\t\tlocal n = {}\n\t\tfor i=0,6 do\n\t\t\t\
    local x = math.sqrt( (((v[i] - m[i]) / 2)^2) )\n\t\t\tif x <= 1 then\n\t\t\t\t\
    table.insert(n, m[i])\n\t\t\tend\n\t\tend\n\t\tif #n >= 2 then\n\t\t\ttable.sort(n)\n\
    \t\t\ttable.insert(m, n[1])\n\t\t\ttable.insert(m, n[2])\n\t\tend\n\tend\n\tif\
    \ #m == 2 then\n\t\treturn {m[1], m[2]}\n\telse\n\t\treturn nil\n\tend\nend",
  "   if planet1 == nil or planet2 == nil then\n      return nil\n   end\n   local\
    \ planet1Orbit, planet2Orbit = #getOrbit(planet1), #getOrbit(planet2)\n   local\
    \ sunOrbit = #getOrbit(\"Sun\")", "  local sun_distance = calcSunDistance(planet1,\
    \ planet2)\n  local sun_angle = calcSunAngle(planet1, planet2)\n  local planet_distances\
    \ = nil\n  local planet_angles = nil\n  \n  if sun_distance ~= nil then\n    planet_distances\
    \ = {}\n    for i=1,8 do\n      local dist = calcPlanetDistance(planet1, planet2,\
    \ i)\n      if dist > sun_distance then\n        planet_distances[i] = dist\n\
    \      end\n    end\n    table.sort(planet_distances, function(a,b) return a <\
    \ b end)\n    table.sort(planet_distances, function(a,b) return a > b end)\n \
    \ end", "  -- Check that the parameters are valid names\n  if planet1 == \"Mercury\"\
    \ or planet1 == \"Venus\" or planet1 == \"Earth\" \n    or planet1 == \"Mars\"\
    \ or planet1 == \"Jupiter\" or planet1 == \"Saturn\" \n    or planet1 == \"Uranus\"\
    \ or planet1 == \"Neptune\" then return end\n  if planet2 == \"Mercury\" or planet2\
    \ == \"Venus\" or planet2 == \"Earth\" \n    or planet2 == \"Mars\" or planet2\
    \ == \"Jupiter\" or planet2 == \"Saturn\" \n    or planet2 == \"Uranus\" or planet2\
    \ == \"Neptune\" then return end\n  \n  -- For each planet in the system store\
    \ the orbit information in an array\n  local orbits = {}\n  for i=0, 8 do\n  \
    \  local planet = planet1\n    if i < 8 then\n      planet = planet2\n    end\n\
    \    local planetOrbit = sys.getOrbit(planet)\n    if planetOrbit ~= nil then\n\
    \      local distance = sys.distance(planetOrbit)\n      local degrees = math.rad(math.atan2(planetOrbit[1],\
    \ planetOrbit[2]))\n      local radians = math.rad(degrees)\n      orbits[i] =\
    \ {planet, distance, degrees, radians}\n    end\n  end\n  \n  -- Sort the planets\
    \ by their proximity to the sun\n  table.sort(orbits)\n  \n  -- Return the sorted\
    \ planets\n  for i = 0, #orbits - 1 do\n    if orbits[i][1] == planet1 then\n\
    \      -- Skip this planet\n    elseif orbits[i][1] == planet2 then\n      --\
    \ Skip this planet\n    else\n      return orbits[i]\n    end\n  end\nend", " \
    \ local orbit1 = planet1 .. \" orbit\"\n  local orbit2 = planet2 .. \" orbit\"\
    \n  local planets = {planet1, planet2}\n  local sun = \"sun\"\n  local min1, max1\
    \ = 0, #planets\n  local min2, max2 = 0, #planets\n  local distances = {}\n  local\
    \ temp = {}\n  local j = 0\n  for i = 1, #planets do -- For each planet\n    local\
    \ planet = planets[i]\n    local distances[planet] = {}\n    local count = 0\n\
    \    while count ~= 1 do\n      distance = math.sqrt((getDistance(sun, planet)\
    \ / 100) * 100)\n      distance = distance * distances[planet][count]\n      distance\
    \ = distance / 100\n      distances[planet][count] = distance\n      if distance\
    \ <= distances[planet][count] then\n        temp[count] = distances[planet][count]\n\
    \        break\n      else\n        count = count + 1\n      end\n    end\n  \
    \  distance = temp[1]\n    if distance > distances[planet][count] then\n     \
    \ min1, max1 = i, i\n      min2, max2 = j, j\n    else\n      if i > j then min2,\
    \ max2 = j, j end\n      if i < j then min1, max1 = i, i end\n    end\n    j =\
    \ i + 1\n  end\n  if min1 == max1 then return end\n  if min2 == max2 then return\
    \ end\n  local temp1 = distances[planet1]\n  local temp2 = distances[planet2]\n\
    \  local distance1 = temp1[min1]\n  local distance2 = temp2[min2]\n  local distance\
    \ = distance1 - distance2\n  distances[planet1][min1] = distance1\n  distances[planet2][min2]\
    \ = distance2\n  return distances\nend", "\tlocal a = {}\n\tlocal b = {}\n\t\n\
    \t-- The two planets are close to each other, so return an empty tuple\n\tif planet1\
    \ ~= planet2 then return end\n\t\n\t-- Return an empty tuple if either planet\
    \ name is not correct\n\tif planet1 == nil or planet2 == nil then return end\n\
    \t\n\t-- Get orbital data for each planet in our solar system\n\tlocal sun, mercury,\
    \ venus, earth, mars, jupiter, saturn, uranus, neptune =\n\t\tSun(planet1), Mercury(planet1),\
    \ Venus(planet1), Earth(planet1), \n\t\tMars(planet1), Jupiter(planet1), Saturn(planet1),\
    \ Uranus(planet1), \n\t\tNeptune(planet1)\n\t\n\t-- Get orbital data for each\
    \ planet in our solar system\n\tlocal sun, mercury, venus, earth, mars, jupiter,\
    \ saturn, uranus, neptune =\n\t\tSun(planet2), Mercury(planet2), Venus(planet2),\
    \ Earth(planet2), \n\t\tMars(planet2), Jupiter(planet2), Saturn(planet2), Uranus(planet2),\
    \ \n\t\tNeptune(planet2)\n\t\n\t-- The planets are close to each other, so return\
    \ an empty tuple\n\tif sun == nil or mercury == nil or venus == nil or earth ==\
    \ nil or \n\t\tmars == nil or jupiter == nil or saturn == nil or uranus == nil\
    \ or \n\t\tneptune == nil then return end\n\t\n\t-- Return the orbital data for\
    \ the two planets\n\tlocal sun, mercury, venus, earth, mars, jupiter, saturn,\
    \ uranus, neptune =\n\t\tSun(planet1), Mercury(planet1), Venus(planet1), Earth(planet1),\
    \ \n\t\tMars(planet1), Jupiter(planet1), Saturn(planet1), Uranus(planet1), \n\t\
    \tNeptune(planet1)\n\tlocal sol1, sol2 = Sun(planet2), Mercury(planet2), Venus(planet2),\
    \ \n\t\tEarth(planet2), Mars(planet2), Jupiter(planet2), Saturn(planet2), \n\t\
    \tUranus(planet2), Neptune(", "  local planet1Orbit, planet2Orbit = solarSystem(planet1),\
    \ solarSystem(planet2)\n  local sunOrbit = planet2Orbit[1]\n  \n  local startOrbit,\
    \ stopOrbit = math.min(planet1Orbit[1], planet2Orbit[1]), math.max(planet1Orbit[1],\
    \ planet2Orbit[1])\n  \n  -- The first part is easy: return the orbits of both\
    \ planets if the distance from the sun is more than 1.5 times the distance.\n\
    \  if math.abs(math.sin(math.rad(sunOrbit[2])) - math.sin(math.rad(startOrbit[2])))\
    \ > 1.5*math.abs(math.sin(math.rad(sunOrbit[2])) - math.sin(math.rad(startOrbit[2])))\
    \ then\n    return {}, {}\n  else\n    local sunPos = getPosition(sunOrbit)\n\
    \    local startPos = getPosition(startOrbit)\n    local stopPos = getPosition(stopOrbit)\n\
    \    \n    local planet1 = {name = planet1, orbit = startOrbit}\n    local planet2\
    \ = {name = planet2, orbit = stopOrbit}\n    \n    local orbits = {}\n    local\
    \ i = 0\n    \n    while i < 8 do\n      local planetPos = {\n        name = \"\
    unknown\",\n        orbit = math.rad(startOrbit[i]) + math.rad(math.random() *\
    \ math.rad(360)),\n      }\n      \n      if planetPos == startPos then\n    \
    \    planetPos = startPos\n      elseif planetPos == stopPos then\n        planetPos\
    \ = stopPos\n      else\n        planetPos = getPosition(planetPos)\n      end\n\
    \      \n      if planetPos.orbit == sunPos then\n        table.insert(orbits,\
    \ {\n          name = planetPos.name,\n          orbit = planetPos.orbit,\n  \
    \      })\n      end\n      \n      i = i + 1\n    end\n    \n    -- For each\
    \ element in the table of orbits sorted by distance to the sun, \n    -- put those\
    \ elements in a table of pairs and sort that table by \n    -- distance to the\
    \ sun, ascending. Return an empty table if \n    -- there aren't enough orbits.\n\
    \    local sortedOrbits = {}\n    local sortedOrbitsSortedByDistance = table.sort(orbits,\
    \ function(orbit1, orbit2)\n      if orbit1.orbit > orbit2.orbit then\n      \
    \  return true\n      elseif orbit1.orbit < orbit2.orbit then\n        return\
    \ false\n      else\n        return ", "    local planet1orbit, planet1radius\
    \ = orbits(planet1)\n    local planet2orbit, planet2radius = orbits(planet2)\n\
    \    if not (planet1radius < planet2radius) then\n        return (planet1orbit,\
    \ planet2orbit)\n    end\n    local difference = planet1radius - planet2radius\n\
    \    if difference > 0.1 then\n        return ()\n    end\n    local closestplanet1\
    \ = planet1\n    local closestplanet2 = planet2\n    if difference < -0.1 then\n\
    \        return ()\n    end\n    local closestplanet1orbit, closestplanet1radius\
    \ = orbits(closestplanet1)\n    local closestplanet2orbit, closestplanet2radius\
    \ = orbits(closestplanet2)\n    if closestplanet1orbit ~= closestplanet2orbit\
    \ then\n        return ()\n    end\n    if closestplanet1radius < closestplanet2radius\
    \ then\n        return ()\n    end\n    if closestplanet1radius > closestplanet2radius\
    \ then\n        return ()\n    end\n    local closestplanet1orbit, closestplanet1radius\
    \ = orbits(closestplanet1)\n    local closestplanet2orbit, closestplanet2radius\
    \ = orbits(closestplanet2)\n    if closestplanet1orbit ~= closestplanet2orbit\
    \ then\n        return ()\n    end\n    if closestplanet1radius < closestplanet2radius\
    \ then\n        return ()\n    end\n    if closestplanet1radius > closestplanet2radius\
    \ then\n        return ()\n    end\n    local closestplanet1orbit, closestplanet1radius\
    \ = orbits(closestplanet1)\n    local closestplanet2orbit, closestplanet2radius\
    \ = orbits(closestplanet2)\n    if closestplanet1orbit ~= closestplanet2orbit\
    \ then\n        return ()\n    end\n    if closestplanet1radius < closestplanet2radius\
    \ then\n        return ()\n    end\n    if closestplanet1radius > closestplanet2radius\
    \ then\n        return ()\n    end\n    return (bf(closestplanet1, closestplanet2),\
    \ bf(closestplanet2, closestplanet1))\nend", "   local distances = {}\n   for\
    \ i=1,8 do\n      local distance = getDistance(planet1, planet2)\n      local\
    \ index = math.abs(distances[i]-distance)\n      if index > 0 then\n         distances[i]\
    \ = distance\n         distances[#distances+1] = index\n      else\n         break\n\
    \      end\n   end\n   local index\n   local tuple = ()\n   for i=1,#distances\
    \ do\n      index = distances[i]\n      if index == 1 then\n         tuple = tuple\
    \ .. planet1\n      elseif index == #distances then\n         tuple = tuple ..\
    \ planet2\n      else\n         tuple = tuple .. getPlanet(index)\n      end\n\
    \   end\n   return tuple\nend", "  local planets1 = get_all_planet_names()\n \
    \ if planet1 == nil then\n    return planets1\n  elseif planet1 == planet2 then\n\
    \    return {}\n  end", "   if planet1 == planet2 then return (planet1,) end\n\
    \   local planets = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \n      \"Uranus\", \"Neptune\" }\n   if planet1 ~= nil then \n\
    \      if planet2 ~= nil then\n         local planet1 = planets:find(planet1)\n\
    \         local planet2 = planets:find(planet2)\n         if planet1 ~= nil and\
    \ planet2 ~= nil then\n            local tx = acos(cos(pi()/4)*sin(planet1.lon\
    \ - planet2.lon))\n            local ty = asin(sin(planet1.lon)*cos(planet2.lon)\
    \ - \n               cos(planet1.lon)*sin(planet2.lon)*cos(planet1.lat - planet2.lat))\n\
    \            local tz = asin(sin(planet1.lat)*cos(planet2.lat) + \n          \
    \     cos(planet1.lat)*sin(planet2.lat)*cos(planet1.lon - planet2.lon))\n    \
    \        return planets[(tz <= ty)*(tz <= tx)*(ty <= tx)], planets[(ty <= ty)*(tz\
    \ <= tx)]\n         elseif planet2 ~= nil then\n            return bf(nil, planet2)\n\
    \         elseif planet1 ~= nil then\n            return bf(nil, planet1)\n  \
    \       else\n            return ()\n         end\n      elseif planet1 ~= nil\
    \ then\n         return bf(planet1, planets:nth(#planets))\n      else\n     \
    \    return ()\n      end\n   elseif planet2 ~= nil then\n      return bf(planets,\
    \ planet2)\n   else\n      return ()\n   end\nend", "   local function distance(planet1,\
    \ planet2)\n      return math.sqrt(((planet1.x - planet2.x) * (planet1.x - planet2.x))\
    \ +\n                      ((planet1.y - planet2.y) * (planet1.y - planet2.y))\
    \ +\n                      ((planet1.z - planet2.z) * (planet1.z - planet2.z)))\n\
    \   end", "\t-- Check whether the planet names are correct and exist.\n\tif not\
    \ (is_string(planet1) and is_string(planet2)) then\n\t\tprint('The arguments are\
    \ not correct planet names')\n\t\treturn ()\n\tend\n\tif not (is_string(planet1)\
    \ and is_string(planet2)) then\n\t\tprint('The arguments are not correct planet\
    \ names')\n\t\treturn ()\n\tend", "    \n    local sun = GetSun()\n    \n    local\
    \ planet1 = Planets[planet1]\n    local planet2 = Planets[planet2]", "  local\
    \ function get_planet_name(planet)\n    if planet == \"Mercury\" then\n      planet\
    \ = \"Mercury\" \n    elseif planet == \"Venus\" then\n      planet = \"Venus\"\
    \ \n    elseif planet == \"Earth\" then\n      planet = \"Earth\" \n    elseif\
    \ planet == \"Mars\" then\n      planet = \"Mars\" \n    elseif planet == \"Jupiter\"\
    \ then\n      planet = \"Jupiter\" \n    elseif planet == \"Saturn\" then\n  \
    \    planet = \"Saturn\" \n    elseif planet == \"Uranus\" then\n      planet\
    \ = \"Uranus\" \n    elseif planet == \"Neptune\" then\n      planet = \"Neptune\"\
    \ \n    end\n    return planet\n  end", "\tif planet1 == \"Earth\" then\n\t\t\
    return {}\n\telseif planet2 == \"Earth\" then\n\t\treturn {}\n\telse\n\t\treturn\
    \ {\n\t\t\t[planet1] = bf(planet1, planet2),\n\t\t\t[planet2] = bf(planet2, planet1),\n\
    \t\t}\n\tend\nend", "    local planet1_orbit, planet2_orbit, sun_orbit =\n   \
    \         orbits(planet1, planet2) ", "    local orbit1 = system.newtonian.planets[planet1]\n\
    \    local orbit2 = system.newtonian.planets[planet2]\n    if not orbit1 or not\
    \ orbit2 then return end\n    local sun = system.newtonian.sun\n    local sun_radius\
    \ = sun:distance(orbit1, orbit2)\n    local planet1_orbit_distance = system.newtonian.earth_orbit_distances[planet1]\n\
    \    local planet2_orbit_distance = system.newtonian.earth_orbit_distances[planet2]\n\
    \    if sun_radius < planet1_orbit_distance and sun_radius < planet2_orbit_distance\
    \ then return {planet1, planet2}\n    elseif sun_radius < planet1_orbit_distance\
    \ then return {planet2}\n    elseif sun_radius < planet2_orbit_distance then return\
    \ {planet1}\n    end \nend", "\tlocal iplanet1 = get_index(planet1) or -1 \n\t\
    local iplanet2 = get_index(planet2) or -1\n\tif iplanet1 ~= iplanet2 then\n\t\t\
    error(\"Planet names must be different\")\n\tend\n\tif iplanet1 == -1 or iplanet2\
    \ == -1 then\n\t\treturn ()\n\tend\n\tlocal orbit_sun = math.rad(get_orbit_sun())\n\
    \tlocal sun_planet = get_sun()\n\tlocal radius = sun_planet[2]\n\tlocal distance\
    \ = sun_planet[3]\n\tif get_index(planet1) ~= iplanet1 then\n\t\tlocal r1 = sun_planet[4]\
    \ + sun_planet[5]\n\t\tlocal r2 = sun_planet[4] + sun_planet[6]\n\t\treturn ({\n\
    \t\t\tget_index(planet1) .. \"@\" .. get_index(planet2) .. \"@\" .. distance,\n\
    \t\t\tget_index(planet1) .. \"@\" .. get_index(planet2) .. \"@\" .. radius\n\t\
    \t})\n\tend\n\tif iplanet1 == 1 then\n\t\tlocal r1 = sun_planet[4] - sun_planet[5]\n\
    \t\tlocal r2 = sun_planet[4] - sun_planet[6]\n\t\treturn ({\n\t\t\tget_index(planet2)\
    \ .. \"@\" .. get_index(planet1) .. \"@\" .. distance,\n\t\t\tget_index(planet2)\
    \ .. \"@\" .. get_index(planet1) .. \"@\" .. radius\n\t\t})\n\tend\n\tif iplanet1\
    \ == iplanet2 then\n\t\tlocal r1 = sun_planet[4] - sun_planet[5]\n\t\tlocal r2\
    \ = sun_planet[4] - sun_planet[6]\n\t\treturn ({\n\t\t\tget_index(planet1) ..\
    \ \"@\" .. get_index(planet2) .. \"@\" .. distance,\n\t\t\tget_index(planet1)\
    \ .. \"@\" .. get_index(planet2) .. \"@\" .. radius\n\t\t})\n\tend\n\tif iplanet1\
    \ > iplanet2 then\n\t\tlocal r1 = sun_planet[4] - sun_planet[5]\n\t\tlocal r2\
    \ = sun_planet[4] + sun_planet[6]\n\t\tlocal r3 = sun_planet[4] + sun_planet[7]\n\
    \t\treturn ({\n\t\t\tget_index(planet1) .. \"@\" .. get_index(planet2) .. \"@\"\
    \ .. distance,\n\t\t\tget_index(planet1) .. \"", "\tlocal pos1 = get_orbit(planet1)\n\
    \tlocal pos2 = get_orbit(planet2)\n\tlocal pos3 = {}\n\tlocal pos4 = {}\n\t\n\t\
    for i=1,8 do\n\t\tlocal temp = get_orbit(math.random(1,#pos1+1))\n\t\tif pos1[temp]\
    \ == nil then\n\t\t\tpos1[temp] = pos1[1]\n\t\tend\n\t\tif pos2[temp] == nil then\n\
    \t\t\tpos2[temp] = pos2[1]\n\t\tend\n\t\tpos3[temp] = pos3[temp] or pos1[temp]\
    \ + pos2[temp]\n\tend\n\t\n\tpos3[1] = pos3[1] + pos1[1]\n\tpos4[1] = pos4[1]\
    \ + pos2[1]\n\tfor i=2,8 do\n\t\tpos3[i] = math.min(pos3[i-1], pos3[i])\n\t\t\
    pos4[i] = math.min(pos4[i-1], pos4[i])\n\tend\n\t\n\tfor i=1,8 do\n\t\tif pos3[i]\
    \ == pos3[i-1] then\n\t\t\tpos3[i] = pos3[i-1]\n\t\tend\n\t\tif pos4[i] == pos4[i-1]\
    \ then\n\t\t\tpos4[i] = pos4[i-1]\n\t\tend\n\tend\n\t\n\treturn pos3[1], pos4[1]\n\
    end", "   local earthOrbit = getOrbit(planet1)\n   local earthOrbit2 = getOrbit(planet2)\n\
    \   local MercuryOrbit = getOrbit(\"Mercury\")\n   local VenusOrbit = getOrbit(\"\
    Venus\")\n   local EarthOrbit = getOrbit(\"Earth\")\n   local MarsOrbit = getOrbit(\"\
    Mars\")\n   local JupiterOrbit = getOrbit(\"Jupiter\")\n   local SaturnOrbit =\
    \ getOrbit(\"Saturn\")\n   local UranusOrbit = getOrbit(\"Uranus\")\n   local\
    \ NeptuneOrbit = getOrbit(\"Neptune\")", "\tlocal planets = {}\n\t\n\tlocal solar\
    \ = GetSunPosition()\n\t\n\tif planet1 == planet2 then\n\t\treturn {planet1}\n\
    \telseif GetDistanceBetweenEarthPosition(planet1, solar) ~= 0 then\n\t\treturn\
    \ {planet1, planet2}\n\telse\n\t\tif GetDistanceBetweenEarthPosition(planet2,\
    \ solar) ~= 0 then\n\t\t\treturn {planet2, planet1}\n\t\tend\n\tend", "    local\
    \ sun = math.sqrt(math.pow(planet1.ra, 2)+math.pow(planet1.dec, 2))\n    local\
    \ orbit1 = get_orbit_info(planet1)\n    local orbit2 = get_orbit_info(planet2)\n\
    \    local orbitsBetween = {}\n    for i=1,8 do\n        local deltaRa = math.fabs(orbit1.ra\
    \ - orbit2.ra)\n        local deltaDec = math.fabs(orbit1.dec - orbit2.dec)\n\
    \        if deltaRa <= sun and deltaDec <= sun then\n            table.insert(orbitsBetween,{orbit1,\
    \ orbit2, math.fabs(orbit1.ra - orbit2.ra)})\n        end\n    end\n    table.sort(orbitsBetween,function(a,b)\n\
    \        if a[3] > b[3] then\n            return 1\n        else\n           \
    \ return -1\n        end\n    end)\n    return orbitsBetween[1][1]\nend", "  \
    \  if #planet1 == 0 or #planet2 == 0 then\n        return ()\n    end\n    local\
    \ sat_orbit, uran_orbit = planets[planet1], planets[planet2]\n    local sun_dist\
    \ = #planet1 + #planet2 + #planets[sun]\n    local sorted = {}\n    for i = 0,\
    \ #sat_orbit do\n        table.insert(sorted, sat_orbit[i]-sun_dist) -- this needs\
    \ to be sorted\n    end\n    table.sort(sorted)\n    local i = 0\n    local planets\
    \ = []\n    while i < #sorted and sorted[i] <= #uran_orbit do\n        table.insert(planets,\
    \ uran_orbit[i])\n        i = i + 1\n    end\n    if i == #sorted then\n     \
    \   return ()\n    end\n    return planets\nend", "    return \nend", "\t-- Fill\
    \ in your code below", "    local m1 = {\n        name = \"Mercury\",\n      \
    \  orbits = {\n            -- Mercury orbits with Jupiter and Neptune orbits \n\
    \            -- Mercury orbits with Earth \n            { name = \"Jupiter\",\
    \ orb = {\n                name = \"Neptune\",\n                orbits = {\n \
    \                   -- Neptune orbits with Earth\n                    { name =\
    \ \"Earth\", orb = {} } } }\n        } }\n    local m2 = {\n        name = \"\
    Venus\",\n        orbits = {\n            -- Mercury orbits with Venus and Earth\
    \ \n            { name = \"Earth\", orb = {} } } }\n    local e1 = {\n       \
    \ name = \"Earth\",\n        orbits = {\n            -- Mercury orbits with Earth\
    \ \n            { name = \"Mercury\", orb = {\n                name = \"Venus\"\
    ,\n                orbits = {\n                    -- Mercury orbits with Venus\
    \ \n                    { name = \"Earth\", orb = {\n                        name\
    \ = \"Mars\",\n                        orbits = {\n                          \
    \  -- Mercury orbits with Earth orbits with Mars\n                           \
    \ { name = \"Jupiter\", orb = {\n                                name = \"Saturn\"\
    ,\n                                orbits = {\n                              \
    \      -- Mercury orbits with Earth orbits with \n                           \
    \         -- Jupiter and Saturn \n                                    { name =\
    \ \"Uranus\", orb = {} } } } } } } } } } }\n    local e2 = {\n        name = \"\
    Mars\",\n        orbits = {\n            -- Mercury orbits with Earth orbits with\
    \ Mars \n            { name = \"Earth\", orb = {\n                name = \"Jupiter\"\
    ,\n                orbits = {\n                    -- Mercury orbits with Earth\
    \ orbits with Jupiter \n                    { name = \"Saturn\",\n           \
    \             orbits = {\n                            -- Mercury orbits with Earth\
    \ orbits with Jupiter and \n                            -- Saturn \n         \
    \                   { name = \"Uranus\", orb = {} } } } } } } }\n    local j1\
    \ = {\n        name = \"Jupiter\",\n        orbits = {\n            -- Jupiter\
    \ orbits with Earth\n            { name = \"Earth\", orb = {\n               \
    \ name = \"Mars\",\n                orbits = {\n                    -- Jupiter\
    \ orbits with Earth orbits with Mars\n                    { name = \"Jupiter\"\
    , orb = {\n                        name = \"Saturn\",\n                      \
    \  orbits = {\n                            -- Jupiter orbits with Earth orbits\
    \ with Jupiter and \n                            -- Saturn \n                \
    \            { name = \"Uranus\", orb = {} } } } } } } }\n"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
