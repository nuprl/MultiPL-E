name: HumanEval_99_closest_integer
language: lua
prompt: "-- Create a function that takes a value (string) representing a number\n\
  -- and returns the closest integer to it. If the number is equidistant\n-- from\
  \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
  10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
  \ from zero means that if the given number is equidistant\n-- from two integers,\
  \ the one you should return is the one that is the\n-- farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nlocal function closest_integer(value)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
  \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
  \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
  \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    -- If it's a number, then just round it\n    if type(value) ==\
    \ \"number\" then\n        return math.round(value)\n    end", "  -- Return closest\
    \ integer, for rounding away from zero.\n  return math.floor((math.floor(value\
    \ / 1) + 1)) * math.sign(value)\nend", "  value = tonumber(value)\n  if not value\
    \ or value == 0 then\n    return nil\n  end", "  return math.floor(math.abs(value)\
    \ + 0.5)\nend", "  local function is_equidistant(a, b)\n    return math.abs(a\
    \ - b) <= 1\n  end\n  if value:match('^-?%d+') then\n    local value = tonumber(value)\n\
    \    local difference, closest\n    -- Round away from zero\n    if value >= 0\
    \ then\n      difference, closest = value - 0.5, value + 0.5\n    else\n     \
    \ difference, closest = value - 0.5, value - 0.5\n    end\n    -- Handle edge\
    \ case\n    if difference == 0 then\n      difference, closest = 1, 0\n    end\n\
    \    -- Check if value is equidistant to two integers\n    if difference == 0\
    \ then\n      if closest == 0 then\n        difference, closest = 1, 0\n     \
    \ elseif closest == 1 then\n        difference, closest = -1, 0\n      else\n\
    \        difference, closest = 0, 1\n      end\n    end\n    -- Check if value\
    \ is equidistant to an integer\n    if difference == 0 then\n      if closest\
    \ == 0 then\n        difference, closest = 1, 0\n      elseif closest == 1 then\n\
    \        difference, closest = -1, 0\n      end\n    end\n    -- Check if value\
    \ is equidistant to a floating point number\n    if difference == 0 then\n   \
    \   if closest == 0 then\n        difference, closest = 1, 0\n      end\n    end\n\
    \    -- Round the closest value to nearest integer\n    closest = int(closest)\n\
    \    return closest\n  else\n    local sign = value:match('^-?%d+(-?%d)?')\n \
    \   if sign == '' then\n      local sign = value:match('^%d+(-?%d)?')\n    end\n\
    \    local difference, closest, round\n    local value = tonumber(value)\n   \
    \ local difference, closest = value - 0.5, value + 0.5\n    -- Handle edge case\n\
    \    if difference == 0 then\n      difference, closest = 1, 0\n    end\n    --\
    \ Check if value is equidistant to two integers\n    if difference == 0 then\n\
    \      if closest == 0 then\n        difference, closest = 1, 0\n      elseif\
    \ closest == 1 then\n        difference, closest = -1, 0\n      end\n    end\n\
    \    -- Check if value is equidistant to an integer\n    if difference == 0 then\n\
    \      if closest == 0 then\n        difference, closest = 1, 0\n      end\n \
    \   end\n    -- Check if value is equidistant to a floating point number\n   \
    \ if difference == 0 then\n      if closest == 0 then\n        difference, closest\
    \ = 1, 0\n      end\n    end\n    -- Round the closest value to nearest integer\n\
    \    closest = int(closest)\n    if sign ~= '-' then\n      closest = math.abs(",
  "  local number = tonumber(value)\n  if number then\n    number = math.round(number)\n\
    \  else\n    number = nil\n  end\n  if number ~= nil then\n    local left, right\
    \ = math.floor(number), math.ceil(number)\n    if left == left and right == right\
    \ then\n      return number\n    elseif left > 0 and right < 0 then\n      return\
    \ right\n    elseif left < 0 and right > 0 then\n      return left\n    else\n\
    \      return nil\n    end\n  end\nend", "  local closest\n  for _, val in ipairs(values)\
    \ do\n    if val == value then\n      break\n    end\n    closest = val\n  end\n\
    \  if closest == nil then\n    return nil\n  end\n  if closest < value then\n\
    \    return closest\n  end\n  return closest+1\nend", "   assert(type(value) ==\
    \ 'string')\n   local numbers = string.gmatch(value, \"(%d*)%.?(%d*)\")\n   assert(#numbers\
    \ == 2)\n   local digits = tonumber(numbers[1])\n   local fract = tonumber(numbers[2])\n\
    \   -- Round digits to the closest integer.\n   -- If fract is 0, we return the\
    \ nearest integer to the whole number.\n   -- Otherwise, return fract - digits\
    \ + 1.\n   if fract == 0 then\n      return tonumber(numbers[1]):round()\n   end\n\
    \   return tonumber(numbers[1]):round(digits)\nend", "   local _, closest = nil,\
    \ nil -- The number closest to value, the closest\n   for _, v in ipairs(value)\
    \ do\n      if closest == nil then\n         closest, closest = v, v\n      else\n\
    \         local d = abs(v - closest)\n         if d < closest then\n         \
    \   closest, closest = v, d\n         end\n      end\n   end\n   return closest\n\
    end", "  if value == \"-\" then return -math.floor(math.abs(value)) end\n  local\
    \ num = tonumber(value)\n  if num == nil then\n    if value == \"inf\" then return\
    \ math.inf end\n    if value == \"nan\" then return math.nan end\n    error(\"\
    Given value is not numeric: \" .. value)\n  end\n  local lower, upper = 0, math.floor(num)\n\
    \  if math.abs(num - lower) < math.abs(num - upper) then\n    return lower\n \
    \ end\n  return upper\nend", "    if value == nil then\n        return nil\n \
    \   end", "  -- We assume that all positive numbers are equidistant from zero\n\
    \  if tonumber(value) >= 0 then\n    -- The difference between the value and 0\
    \ is also the difference\n    -- of that value from one thousand, therefore dividing\
    \ by 1000\n    local difference = tonumber(value) - 1000\n    -- If the number\
    \ is above the difference of two thousands, round down\n    -- to the closest\
    \ integer\n    if difference > 0 then\n      return tonumber(math.ceil(difference))\n\
    \    else\n      return tonumber(math.floor(difference))\n    end\n  end\nend",
  "  if value == nil then\n    return \"nil\"\n  end", "  -- The first if statement\
    \ is for the case where value is nil.\n  if value == nil then\n    -- The second\
    \ if statement is for the case where value is a string.\n    if type(value)~='string'\
    \ then\n      -- Return a nil value.\n      return nil\n    end\n    -- If the\
    \ given value is an empty string, return nil.\n    if value == '' then\n     \
    \ return nil\n    end\n    -- If the given value is a number, return it.\n   \
    \ return tonumber(value)\n  end\n  -- The second if statement is for the case\
    \ where value is a number.\n  if type(value)~='number' then\n    -- Return a nil\
    \ value.\n    return nil\n  end\n  -- If the given value is greater than the largest\
    \ representable integer,\n  -- return nil.\n  if tonumber(value)>1e11 then\n \
    \   return nil\n  end\n  -- If the given value is less than the smallest representable\
    \ integer,\n  -- return nil.\n  if tonumber(value)<-1e11 then\n    return nil\n\
    \  end\n  -- If the given value is equidistant from two integers, round it away\n\
    \  -- from zero.\n  if tonumber(value)==1e11 then\n    return tonumber(math.floor(value))\n\
    \  elseif tonumber(value)==-1e11 then\n    return tonumber(math.ceil(value))\n\
    \  else\n    return tonumber(math.round(value))\n  end\nend", "  return math.floor((value\
    \ + math.pi/2) / math.pi)\nend", "  local function round(value)\n    if value\
    \ == nil then return nil end\n    local sign = value < 0 and -1 or 1\n    local\
    \ factor = math.pow(10, math.floor(math.log10(value)))\n    return value * factor\
    \ + sign * (factor / 2)\n  end", "    local difference = math.abs(value - math.floor(number))\n\
    \    return math.floor(number) + difference + 1\nend", "  if value == nil then\
    \ return nil end\n  local num = tonumber(value)\n  if num == nil then return nil\
    \ end\n  local n1 = math.floor(num)\n  local n2 = num - n1\n  local diff = n1\n\
    \  if n2 ~= 0 then\n    diff = -diff\n  end\n  if diff < 0 then\n    return n1\n\
    \  else\n    return n2\n  end\nend", "    local string_value = str(value) -- Ensure\
    \ that value is a string\n    local result = tonumber(string_value) -- Use tonumber\
    \ to convert it to a number", "  -- If no number is given, return nil.\n  if value\
    \ == nil then return end", "  local function closest(a, b)\n    if a == nil then\n\
    \      return b\n    elseif b == nil then\n      return a\n    end\n    local\
    \ abs = math.abs(a - b)\n    if abs < 0.5 then\n      return a\n    else\n   \
    \   return b\n    end\n  end\n  local function round_away_from_zero(n)\n    local\
    \ m = math.abs(n)\n    if m % 1 == 0 then\n      return m\n    end\n    return\
    \ m - 0.5\n  end\n  local result = value\n  local pos = #value\n  while pos do\n\
    \    local substr = value[pos:find(\"-\")]\n    if substr == \"\" then\n     \
    \ break\n    end\n    local digit = tonumber(substr)\n    if digit == nil then\n\
    \      return nil\n    end\n    local round_to = round_away_from_zero(digit)\n\
    \    result = closest(result,round_to)\n    pos = pos-1\n  end\n  return result\n\
    end", "\tlocal difference = math.abs(value - closest_integer(value))\n\treturn\
    \ math.floor(difference + 0.5) -- Round to nearest integer.\nend", "  local int_value\
    \ = tonumber(value)\n  local int_max = math.max(int_value)\n  if int_max > 0 then\n\
    \    local diff = (int_value - int_max)\n    -- if diff is even return 0\n   \
    \ if diff % 2 == 0 then\n      return int_max\n    end\n    -- if diff is odd,\
    \ return the smallest int value that is larger than 0\n    -- or diff/2\n    local\
    \ diff2 = diff / 2\n    -- if diff2 even, return diff / 2\n    if diff2 % 2 ==\
    \ 0 then\n      return (int_max + diff2)/2\n    end\n    -- if diff2 odd, return\
    \ the smallest int value that is larger than 0\n    -- or diff2/2\n    local diff22\
    \ = diff2 / 2\n    return ((int_max + diff22) + diff22)/2\n  end\n  return int_max\n\
    end", "\tlocal x0 = tonumber(value)\n\tif x0 == value then return x0 end\n\tlocal\
    \ x1, x2, x3, x4 = tonumber(string.sub(value, 1, -1))\n\tif x1 == x2 or x1 ==\
    \ x3 then x0 = x1 end\n\tif x4 == x2 or x4 == x3 then x0 = x4 end\n\treturn x0\n\
    end", "    local difference = tonumber(value) - tonumber(tonumber(value))\n  \
    \  if difference < 0 then\n        return tonumber(tonumber(value) - difference\
    \ + 1)\n    else\n        return tonumber(value)\n    end\nend", "  local closest\
    \ = 1\n  local rounding_threshold = math.floor((math.floor(value) + math.floor(value))\
    \ * 0.5)", "  if value:match(\"^%d%d+$\") then\n    return tonumber(value)\n \
    \ end\n  if value:match(\"^%d-%d+$\") then\n    value = value:gsub(\"-\", \"+\"\
    ):gsub(\"^%d+\", \"0\"):gsub(\"%d+$\", \"\")\n    return tonumber(value)\n  end\n\
    \  if value:match(\"^%d+$\") then\n    return tonumber(value)\n  end\n  if value:match(\"\
    ^%d-$\") then\n    value = value:gsub(\"-\", \"+\"):gsub(\"^%d+\", \"0\"):gsub(\"\
    %d-$\", \"\")\n    return tonumber(value)\n  end\n  return value\nend", "    local\
    \ difference = value - math.floor(value)\n    if difference < 0 then return value\
    \ else return math.floor(value) end\nend", "    local function f(x)\n        if\
    \ x <= value then return x end\n        if value < x then return x end\n     \
    \   if x > value then return value end\n        return x\n    end\n    local function\
    \ fd(x)\n        if x <= value then return x end\n        if value < x then return\
    \ value end\n        if x > value then return x end\n        return x\n    end\n\
    \    return (fd(f(value))) / 2\nend", "  if value == \"-\" then return -0 end\n\
    \  local num, err = tonumber(value)\n  if num == nil then\n    local _, err2 =\
    \ tonumber(string.format(\"%.9f\", value))\n    if err2 == nil then return nil,\
    \ \"Could not convert \" .. value .. \" to an integer.\" end\n    return nil,\
    \ err2\n  end\n  if value == \"\" then return nil, \"Value must not be empty.\"\
    \ end\n  if num == 0 then return nil, \"Cannot return an integer.\" end", "  \
    \  local closestInteger\n    for _, v in ipairs(value) do\n        if v ~= \"\"\
    \ then\n            closestInteger = tonumber(v)\n            break\n        end\n\
    \    end\n    -- The first value was not a number, but we assume it was a string\n\
    \    -- so we can return this value instead.\n    if closestInteger == nil then\n\
    \        closestInteger = tonumber(value)\n    end\n    -- If value is equidistant,\
    \ return the first integer\n    if closestInteger == value then\n        closestInteger\
    \ = tonumber(value)\n    end\n    return closestInteger\nend", "  -- If the given\
    \ number is equidistant from two integers, return the one\n  -- that is farthest\
    \ from zero.\n  if math.abs(value - math.floor(value)) > math.abs(value - math.ceil(value))\
    \ then\n    return math.floor(value)\n  end\n  -- If the given number is equidistant\
    \ from two integers, return the one\n  -- that is closest to zero.\n  if math.abs(value\
    \ - math.floor(value)) < math.abs(value - math.ceil(value)) then\n    return math.ceil(value)\n\
    \  end\n  -- If the given number is equidistant from two integers, return the\
    \ one\n  -- that is closest to zero.\n  return math.floor(value)\nend", "  local\
    \ function round_away_from_zero(n)\n    return math.floor(n - math.floor(n))\n\
    \  end\n  local result = tonumber(value)\n  if result ~= nil then\n    if result\
    \ == 0 then\n      -- Special case for zero\n      return 0\n    elseif result\
    \ < 0 then\n      -- Special case for negative numbers\n      return round_away_from_zero(-result)\n\
    \    else\n      -- Special case for positive numbers\n      return round_away_from_zero(result)\n\
    \    end\n  end\n  local closest_result = nil\n  local smallest_diff = nil\n \
    \ for i = 1, #_integers do\n    local diff = abs(result - _integers[i])\n    if\
    \ smallest_diff == nil then\n      closest_result = _integers[i]\n      smallest_diff\
    \ = diff\n    elseif smallest_diff > diff then\n      smallest_diff = diff\n \
    \     closest_result = _integers[i]\n    end\n  end\n  if smallest_diff ~= nil\
    \ then\n    return round_away_from_zero(smallest_diff)\n  end\n  -- No integer\
    \ was equidistant from any integer\n  return nil\nend\n_integers = {}", "    local\
    \ result = value\n    for i=0,2 do\n        result = math.floor(result / 10) *\
    \ 10\n        if result == 0 then\n            break\n        end\n    end\n \
    \   if result == 0 then\n        return 0\n    end\n    return result\nend", " \
    \ local difference = value\n  local difference1 = difference\n  if difference\
    \ >= 0 then\n    -- If difference is positive or 0, add it to the difference of\
    \ its two\n    -- neighbors\n    difference1 = difference + 1\n  end\n  difference1\
    \ = math.floor(difference1)\n  -- Calculate the difference between neighboring\
    \ integers\n  difference = math.abs(value - difference1)\n  if difference > 1\
    \ then\n    -- If difference is more than 1, return the closest integer\n    --\
    \ that does not equal value\n    return difference1\n  end\n  return difference\n\
    end", "  if value == nil then\n    -- Special case for the value being nil.\n\
    \    return nil\n  elseif value == true then\n    -- Special case for truthy values.\n\
    \    return 1\n  elseif value == false then\n    -- Special case for falsy values.\n\
    \    return 0\n  else\n    -- Return the closest integer.\n    return math.floor(math.abs(value))\n\
    \  end\nend", "  local n = tonumber(value)\n  if n then\n    local sign = math.sign(n)\n\
    \    local int_num = abs(n)\n    local int_diff1 = int_num - 1\n    local int_diff2\
    \ = int_num + 1\n    local rounding = 0\n    local rounding_diff1 = 0\n    local\
    \ rounding_diff2 = 0\n    if int_num > 0 then\n      if int_diff1 < n and n ~=\
    \ 0 then\n        rounding = int_diff1\n        rounding_diff1 = sign * int_diff1\n\
    \      end\n      if int_diff2 < n and n ~= 0 then\n        rounding = int_diff2\n\
    \        rounding_diff2 = sign * int_diff2\n      end\n    end\n    -- The above\
    \ logic could also be written as follows:\n    --\n    -- rounding = sign * (abs(int_diff1)\
    \ - abs(int_diff2))\n    --\n    -- However, that may introduce rounding errors,\
    \ since abs(int_diff1) can\n    -- have more digits than abs(int_diff2).\n   \
    \ local rounding_diff\n    if int_diff1 < int_diff2 and int_diff1 >= 0 then\n\
    \      rounding_diff = sign * (int_diff1 - int_diff2)\n    elseif int_diff2 <\
    \ int_diff1 and int_diff2 >= 0 then\n      rounding_diff = sign * (int_diff2 -\
    \ int_diff1)\n    end\n    if rounding ~= 0 then\n      return sign * round(rounding\
    \ / rounding_diff)\n    end\n  else\n    return 0\n  end\nend", "  local sign,\
    \ value = string.reverse(type(value)), tonumber(value)\n  if sign ~= \"d\" then\n\
    \    error(\"argument must be a string\")\n  elseif value < 0 then\n    error(\"\
    argument cannot be negative\")\n  elseif sign == \"d\" then\n    -- Decimal number\n\
    \    local div = math.floor(value)\n    local mult = math.abs(value) - div\n \
    \   if mult < .5 then\n      return div - 1\n    else\n      return div + 1\n\
    \    end\n  else\n    -- Floating point\n    local div = math.floor(value / 2)\n\
    \    local mult = math.abs(value - div)\n    if mult < .5 then\n      return div\
    \ + 1\n    else\n      return div - 1\n    end\n  end\nend", "  if value == nil\
    \ then return nil end\n  local tok = tonumber(value)\n  if tok ~= nil and tok\
    \ ~= tostring(value) then\n    return tok\n  end", "  local function is_close_to_zero(v)\n\
    \    return v - math.floor(v) < 0.01\n  end\n  local function is_equidistant(v1,\
    \ v2)\n    return math.abs(v1 - v2) < 0.01\n  end\n  if type(value) ~= \"string\"\
    \ then\n    error(\"[closest_integer] expects a string but got a \" .. type(value))\n\
    \  end\n  local match = string.find(value, \"[^.-]\")\n  if match == nil then\n\
    \    error(\"[closest_integer] expects a number but got a \" .. value)\n  end\n\
    \  local integer = tonumber(string.sub(value, 1, match))\n  if type(integer) ~=\
    \ \"number\" or integer < 0 then\n    error(\"[closest_integer] expects a number\
    \ but got a \" .. value)\n  end\n  if math.floor(integer) == integer then\n  \
    \  error(\"[closest_integer] expects a number but got a \" .. value)\n  end\n\
    \  local diff\n  if integer == math.floor(integer) then\n    diff = math.abs(integer\
    \ - math.floor(integer))\n  else\n    diff = math.abs(integer - math.floor(integer))\n\
    \  end\n  if diff == 0 then\n    local last_decimal_value = math.floor(integer)\n\
    \    local last_integer = math.floor(last_decimal_value)\n    local next_last_decimal_value\
    \ = math.floor(last_decimal_value + 0.1)\n    local next_integer = math.floor(next_last_decimal_value)\n\
    \    if next_integer ~= last_integer then\n      diff = math.abs(last_integer\
    \ - next_integer)\n    end\n  end\n  if diff < 0.1 then\n    integer = math.floor(integer)\n\
    \  else\n    integer = math.ceil(integer)\n  end\n  return integer\nend", "  if\
    \ value == nil then\n    error(\"You cannot use nil as a number.\")\n  end\n \
    \ local result\n  -- If we have a positive value, then subtract that value and\
    \ see if the\n  -- remainder is positive or zero.\n  if type(value) ~= 'string'\
    \ or string.find(value, \"^%-?%d+%.?%d+$\") then\n    if value ~= nil and type(value)\
    \ ~= 'number' then\n      error(\"Value must be of type string or number. Got\
    \ \" .. type(value))\n    end\n    result = value\n  else\n    -- Otherwise, check\
    \ if the value is between one and minus one\n    local num = tonumber(value)\n\
    \    if num ~= nil and num > 0 then\n      if num ~= -1 and num ~= 1 and num ~=\
    \ -num then\n        result = num\n      else\n        -- Get the remainder after\
    \ the number has been rounded down\n        local remainder = math.modf(num)[1]\n\
    \        if remainder == 0 then\n          result = num\n        else\n      \
    \    -- Get the number before the first decimal place after rounding\n       \
    \   local firstDbl = math.floor(num / 10)\n          -- Subtract the remainder\n\
    \          result = firstDbl - remainder\n        end\n      end\n    else\n \
    \     result = nil\n    end\n  end\n  return result\nend", "  -- Use tointeger\
    \ because tonumber will give error if value is\n  -- nil or not a string.\n  return\
    \ math.round(tointeger(value))\nend", "  local function is_equidistant(value1,\
    \ value2)\n    if value1 > value2 then\n      return true\n    elseif value2 >\
    \ value1 then\n      return false\n    elseif value1 == value2 then\n      return\
    \ true\n    else\n      return math.floor((value1 + value2) / 2) ~= value1\n \
    \   end\n  end", "  local function abs(x)\n    if x ~= nil then\n      return\
    \ math.abs(x)\n    else\n      return nil\n    end\n  end", "  local function\
    \ is_equidistant(v1, v2)\n    return math.abs(v1 - v2) <= 1\n  end\n  local function\
    \ round_away_from_zero(number)\n    if math.abs(number) <= 1 then\n      return\
    \ number\n    else\n      return math.floor(number)\n    end\n  end", "  local\
    \ function find_closest_integer(value)\n    if value == nil then\n      print(\"\
    error: value cannot be nil\")\n      return\n    end\n    if value == \"-inf\"\
    \ or value == \"inf\" then\n      return 0\n    end\n    -- This algorithm doesn't\
    \ work well for numbers close to zero.\n    if value == 0 then\n      return 0\n\
    \    end", "  local num = tonumber(value)\n  local diff = num - math.floor(num)\n\
    \  if diff < 0 then\n    return math.floor(num)\n  else\n    return math.ceil(num)\n\
    \  end\nend", "  local sign = math.sign\n  local absvalue = math.abs(value)\n\
    \  if absvalue < 1 then\n    return value\n  else\n    local divisor\n    if absvalue\
    \ <= 10 then\n      divisor = 10\n    else\n      divisor = 20\n    end\n    local\
    \ factor\n    repeat\n      factor = divisor / 2\n      if sign(value) ~= sign(value*factor)\
    \ then\n        return factor\n      else\n        divisor = factor\n      end\n\
    \    until divisor == 0\n  end\nend", "  local x = 0\n  local y = 0\n  local distance\
    \ = 0\n  for i = 1, #value do\n    local digit = string.byte(string, value:sub(i,\
    \ i))\n    local sign = 1\n    if digit == \"-\" then\n      digit = digit[1]\n\
    \      sign = -1\n    end\n    local digit = tonumber(digit)\n    if digit then\n\
    \      x = x - digit*sign\n      y = y + digit*sign\n      distance = distance\
    \ + 1\n    end\n  end\n  if y == 0 then\n    x = math.max(x, math.floor(x))\n\
    \  else\n    x = math.min(x, math.ceil(x))\n  end\n  return x * sign\nend", " \
    \ local difference = abs(value - floor(value))\n  local rounded_difference = math.floor(difference)\n\
    \  if rounded_difference == difference then\n    return value\n  end\n  return\
    \ round(value - rounded_difference)\nend", "  return math.floor((math.abs(value)+0.5)+0.5)\n\
    end", "  return math.floor((math.abs(value) - math.abs(tonumber(value))) / 2)\
    \ + tonumber(value)\nend", "    if value == nil then\n        return \"nil\"\n\
    \    end", "  return math.floor(value) + math.abs(value - math.floor(value))\n\
    end", "  -- Check whether the value is in the table of integer values.\n  if not\
    \ int_table then\n    int_table = {}\n    for i = 1, #INT_VALUES do\n      int_table[tostring(i)\
    \ = tostring(i)]:insert(INT_VALUES[i])\n    end\n  end\n  -- Check whether the\
    \ value is in the integer table.\n  if int_table[tostring(value)] then\n    --\
    \ Return the value if it is in the integer table.\n    return int_table[tostring(value)]:nth(1)\n\
    \  end\n  -- Round the value towards the closest integer.\n  return math.round(math.abs(value))\n\
    end", "  local difference = math.abs(value - floor(value))\n  local closest_integer\
    \ = math.floor(difference + 0.5)\n  if value == closest_integer then\n    return\
    \ closest_integer\n  elseif closest_integer == 0 then\n    return 0\n  end\n \
    \ return closest_integer\nend", "  local value_as_number = tonumber(value)\n \
    \ -- Handle integers, round away from zero\n  if value_as_number ~= nil and value_as_number\
    \ ~= false then\n    value_as_number = math.floor(value_as_number + 0.5)\n  end\n\
    \  return value_as_number\nend", "    local value = tonumber(value)\n    local\
    \ closest = 1\n    local closest = math.floor(value + 0.5)\n    while closest\
    \ ~= value do\n        closest = math.ceil(value + 0.5)\n    end\n    return closest\n\
    end", "  if value == nil then return nil end\n  local difference = tonumber(value)\
    \ - tonumber(value)\n  if difference < 0 then\n    difference = difference * -1\n\
    \  end\n  if difference < 0 then return nil end\n  return tonumber(value) + math.floor(difference)\n\
    end", "  return math.floor((math.abs(value - math.ceil(value)) + 0.5))\nend",
  "  return tonumber(\n    string.format(\n      \"%.*g\",\n      math.max(\n    \
    \    1,\n        math.ceil(\n          (value - math.floor(value - 0.5, -1)):ld(value)\n\
    \          / math.abs(math.floor(value - 0.5, -1) - math.floor(value - 0.5, -1))\n\
    \        )\n      )\n    )\n  )\nend", "  if type(value) ~= 'string' then\n  \
    \  local message = string.format('Given value is not a string %s.', type(value))\n\
    \    error(message)\n  end", "    if value == nil then return nil end\n    local\
    \ sign = 1\n    if value ~= value then\n        sign = -1\n    end\n    local\
    \ num\n    if value == (value % 1) then\n        num = value\n    else\n     \
    \   local mult = math.floor(math.abs(value))\n        local div\n        if mult\
    \ > 0 then\n            div = math.modf(value*mult)[0]\n        else\n       \
    \     div = math.modf(-value*mult)[0]\n        end\n        num = value + div\
    \ + 1\n    end\n    if sign == 1 and num < 0 then\n        num = -num\n    end\n\
    \    return num\nend", "    local closest = 0\n    for i = 1, #value do\n    \
    \    local x = tonumber(value[i])\n        if not x then\n            break\n\
    \        end\n        if x > closest then\n            closest = x\n        end\n\
    \    end\n    return closest\nend", "    local factor = 1\n    while value % factor\
    \ ~= 0 do\n        factor = factor * 10\n    end\n    if factor > 99999999999\
    \ then\n        factor = factor * 100\n    end\n    local diff = 10\n    local\
    \ closest\n    local factors = factor..\n        { 10, 100, 1000, 10000, 100000,\
    \ 1000000, 10000000, 100000000, 1000000000}\n    for _, f in ipairs(factors) do\n\
    \        if diff > f then\n            closest = f / diff\n            diff =\
    \ f % diff\n        else\n            break\n        end\n    end\n    return\
    \ closest + 1\nend", "    local difference = value - math.floor(value)\n    if\
    \ math.abs(difference) < 0.00000000000001 then\n        return math.floor(math.ceil(value))\n\
    \    else\n        if difference >= 0 and difference < 0.5 then\n            return\
    \ math.floor(value)\n        elseif difference < 0 and difference > -0.5 then\n\
    \            return math.ceil(math.ceil(value))\n        else\n            return\
    \ math.ceil(math.floor(value))\n        end\n    end\nend", "\t-- If value is\
    \ close enough to zero to consider it an integer,\n\t-- then just return that.\n\
    \tif math.abs(value) < 1 then return value end\n\t-- Get a sequence of integers\
    \ from 1 to value, where the difference\n\t-- of each integer is exactly 1.\n\t\
    local diff = value:range(1, value - 1):map(function(x) return x - 1 end)\n\t--\
    \ Sort them and return the one with the smallest difference.\n\treturn diff[1]:min()\n\
    end", "    local closest = tonumber(value)\n    -- We use integer division to\
    \ find which side of the interval we are\n    -- closer to than the other side.\n\
    \    for _, interval in ipairs(integer_intervals) do\n        local diff = interval[1]\
    \ -  closest\n        local min = diff * interval[0]\n        local max = diff\
    \ * interval[1]\n        local mid = closest + (diff / 2)\n        if min <= mid\
    \ <= max then return mid end\n    end\n    return closest\nend", "  local closest_int\n\
    \  if value:find('-') then\n    closest_int  = closest_integer:gsub('(%d+)$',\n\
    \        function(x) return tonumber(x:gsub('-%d+$', '%d'):reverse()) end\n  \
    \  )\n    closest_int -- Ignore result so that we can use \"else\" below.\n  else\n\
    \    closest_int = tonumber(value)\n  end\n  if closest_int then\n    if closest_int\
    \ ~= value then\n      return math.floor(closest_int)\n    else\n      return\
    \ closest_int\n    end\n  end\nend", "    -- Convert to float and round to nearest\
    \ integer\n    -- This may cause the fractional part to be rounded up in some\
    \ cases,\n    -- but that should be okay because \"15.5\" rounds to 15 and \"\
    16.5\"\n    -- rounds to 16. Not sure if this behaviour is guaranteed though.\n\
    \    local num = tonumber(value)\n    local f = math.floor(num)\n    local s =\
    \ num - f\n    if f == s then\n        return f + 1\n    end\n    return f\nend",
  "    local function distance(a, b)\n        local ab = abs(a - b)\n        if ab\
    \ <= 0.5 then return ab end\n        return ab - (ab % 2)\n    end", "    local\
    \ function dist(one, two)\n        return math.abs(one - two)\n    end\n    local\
    \ closest = 0\n    for i = 1, #value, 1 do\n        local candidate = tonumber(string.format(\"\
    %g\", tonumber(value)))\n        if candidate < closest then closest = candidate\
    \ end\n    end\n    return closest\nend", "    local result = tonumber(value)\n\
    \    if result == nil then\n        result = -value\n    end\n    local diff1\
    \ = abs(result)\n    local diff2 = abs(result - 1)\n    if diff1 <= diff2 then\n\
    \        return result\n    else\n        return result + 1\n    end\nend", " \
    \ local is_negative, integer, multiplier = value:match(\"^(-)?([1-9][0-9]+)(\\\
    .[0-9]+)?\")\n  local sign = is_negative and -1 or 1", "  local integers = unpack(\n\
    \    stringx.Split(\",\", value)\n  )\n  local closest = integers[1]\n  for i\
    \ = 2, #integers do\n    local diff = math.abs(integers[i] - closest)\n    if\
    \ diff < math.abs(closest - integers[i]) then\n      closest = integers[i]\n \
    \   end\n  end\n  return closest\nend", "  local value = tonumber(value)\n  if\
    \ value == nil then\n    return nil\n  end\n  local min_abs = abs(value)\n  local\
    \ min_abs_index = min_abs\n  local min_index = 1\n  local closest_index = 1\n\
    \  for i = 2, #values do\n    local abs_i = abs(values[i])\n    if abs_i > min_abs\
    \ and abs_i < min_abs_index then\n      min_abs_index = abs_i\n      min_index\
    \ = i\n      closest_index = i\n    end\n  end\n  local abs_closest\n  if value\
    \ == min_abs_index then\n    abs_closest = \"0\"\n  else\n    abs_closest = \"\
    -\" .. tostring(min_index - closest_index)\n  end\n  -- Return the closest integer\n\
    \  return tonumber(abs_closest)\nend", "    local number = tonumber(value)\n \
    \   local diff = math.abs(number - math.floor(number))\n    if diff < 0.5 then\n\
    \        return math.floor(number)\n    elseif diff > 0.5 then\n        return\
    \ math.floor(number) + 1\n    else\n        return number\n    end\nend", "  if\
    \ value == nil then\n    return nil\n  end\n  local number = tonumber(value)\n\
    \  if number == nil then\n    return nil\n  end\n  if number == 0 then\n    return\
    \ 0\n  end\n  local nearest_integer = number\n  local current_distance = tonumber(string.sub(number,\
    \ 2))\n  if current_distance > 0 then\n    local current_nearest_integer = tonumber(string.sub(number,\
    \ 3))\n    if current_nearest_integer == nil then\n      current_nearest_integer\
    \ = number\n    else\n      local max_distance = (\n        current_nearest_integer\
    \ - current_distance\n      ):abs()\n      if max_distance < nearest_integer then\n\
    \        nearest_integer = max_distance\n      end\n    end\n  end\n  return nearest_integer\n\
    end", "  local difference = math.abs(tonumber(value)) - tonumber(value)\n  if\
    \ difference < 0 then\n    difference = -difference\n  elseif difference == 0\
    \ then\n    return value\n  end\n  local round = math.floor\n  if tonumber(value)\
    \ > tonumber(math.round(math.abs(difference)))\n  then\n    return round(tonumber(math.round(difference)))\n\
    \  else\n    return round(tonumber(math.round(math.abs(difference))))\n  end\n\
    end", "  if type(value) ~= 'string' then\n    error('Usage: closest_integer(value)')\n\
    \  end\n  -- First we strip any leading and trailing whitespace\n  value = value:gsub('(^%s*(.-)%s*$)'):gsub('(.-)%s*(^%s*)',\
    \ '\\1\\2')\n  value = tonumber(value)\n  if value == nil then\n    return nil\n\
    \  end\n  -- Make sure the value is an integer\n  if value ~= math.floor(value)\
    \ then\n    return nil\n  end\n  -- If the number is equidistant from two integers,\
    \ round it away from zero\n  if math.fmod(value, 2) ~= 0 then\n    local mod =\
    \ math.floor(value)\n    if mod ~= value then\n      return mod\n    end\n  end\n\
    \  -- The number is equidistant from two integers so we just return the closest\n\
    \  -- integer between the two numbers.\n  return math.floor(value)\nend", "  \
    \  if value == nil then return nil end\n    local min, max = tonumber(value),\
    \ tonumber(math.abs(value))\n    if min < 0 then\n        min = -min\n       \
    \ max = -max\n    end\n    if min == max then\n        return min\n    end\n \
    \   if min > max then\n        local temp = min\n        min = max\n        max\
    \ = temp\n    end\n    -- If the value is equidistant, round it away from zero.\n\
    \    if min - max > 0.5 then\n        local temp = min\n        min = max\n  \
    \      max = temp\n    end\n    return math.round(min + (max - min) / 2)\nend",
  "  local value_string = string.gsub(value, \"-\", \"\"):gsub(\"%.\", \"\")\n  if\
    \ value_string:match(\"%d*\") then\n    local digits = value_string:match(\"%d*\"\
    )\n    local num_digits = tonumber(digits[1])\n    if num_digits == nil then\n\
    \      print(\"[warning] Number conversion failed when converting string \"..\n\
    \        value_string..\" to a number. Returning nil...\")\n      return nil\n\
    \    end\n    return tonumber(string.sub(digits, 1, num_digits))\n  else\n   \
    \ print(\"[warning] Number conversion failed when converting string \"..\n   \
    \   value_string..\" to a number. Returning nil...\")\n    return nil\n  end\n\
    end", "    if value == nil then\n        return 0\n    end\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return value\n    end\n    -- Handle the case\
    \ where num does not have a fractional component\n    local ints, fraction = math.modf(num)\n\
    \    if num == ints then\n        return ints + math.ceil(tonumber(fraction))\n\
    \    end\n    return ints + math.floor(tonumber(fraction))\nend", "  local diff1\
    \ = math.abs(tonumber(value) - tonumber(value))\n  local diff2 = math.abs(tonumber(value)\
    \ - tonumber(math.ceil(value)))\n  local diff3 = math.abs(tonumber(value) - tonumber(math.floor(value)))\n\
    \  local min_diff = diff1 + diff2 + diff3\n  if diff1 < min_diff then\n    return\
    \ tonumber(value)\n  elseif diff2 < min_diff then\n    return tonumber(math.ceil(value))\n\
    \  else\n    return tonumber(math.floor(value))\n  end\nend", "  if math.abs(value\
    \ - floor(value)) <= math.abs(value - ceil(value)) then\n    return round(value)\n\
    \  end", "  local value_string = value\n  local value_number = tonumber(value)\n\
    \  local difference\n  -- If the number is equidistant, round away from zero.\n\
    \  if value_number then\n    difference = math.abs(value_number - round(value_number))\n\
    \    value_number = round(value_number)\n  else\n    -- If the number is not a\
    \ number, just return the number.\n    value_number = tonumber(value)\n  end",
  "  if type(value) == \"string\" then\n    local value = tonumber(value)\n  elseif\
    \ type(value) ~= \"number\" then\n    error(\"value is not a string or number\"\
    )\n  end\n  local minimum = math.min(value, math.ceil(value))\n  return math.ceil(value\
    \ - minimum)\nend", "    -- This function will return the closest integer to the\
    \ given value.\n    -- It works by looking at the remainder after dividing the\n\
    \    -- input value by one more than the largest integer that it can\n    -- divide.\n\
    \    if value == \"+inf\" or value == \"-inf\"  then\n        return nil\n   \
    \ end", "  -- Calculate the absolute value of the number.\n  local absolute_value\
    \ = \"abs\"\n  .. table.concat({\"floor\", value}, \" \")\n  .. \"*|\"\n  .. table.concat({\"\
    ceiling\", value}, \" \")\n  .. \"*|\"\n  .. table.concat({\"round\", value},\
    \ \" \")\n  .. \"*|\"\n  .. table.concat({\"round\", value}, \" ceiling\")", " \
    \   local x = tonumber(value)\n    local y = tonumber(value + 1)\n    if x ==\
    \ y and x > 0 and y > 0 then\n        return x - 1\n    else\n        return x\n\
    \    end\nend", "  local function closest_number(value)\n    local function is_closest(value,\
    \ other)\n      return abs(value - other) < 0.0001\n    end\n    local number\
    \ = tonumber(value)\n    if number == nil then\n      return nil\n    end\n  \
    \  local lower, upper = math.floor(number), math.ceil(number)\n    if is_closest(lower,\
    \ upper) then\n      return lower\n    end\n    if is_closest(number, lower) then\n\
    \      return number\n    end\n    if is_closest(number, upper) then\n      return\
    \ upper\n    end\n  end\n  return closest_number(value)\nend", "  if value ==\
    \ nil then\n    return nil\n  end\n  local num = tonumber(value)\n  if num ==\
    \ 0 then\n    return 0\n  end\n  if num % 2 == 0 then\n    return round(num +\
    \ (num - 1) / 2)\n  else\n    return round(num)\n  end\nend", "    local difference\
    \ = math.abs(value - math.floor(math.abs(value)))\n    if difference <= 0.5 then\n\
    \        return math.floor(math.abs(value))\n    else\n        return math.ceil(math.abs(value))\n\
    \    end\nend", "\tlocal closest\n\t\n\t-- Find out where the value fits within\
    \ the integer boundaries\n\tvalue = math.ceil(value)\n\tif value == math.floor(value)\
    \ then \n\t\tclosest = -value -- The number is equidistant to both sides\n\telse\n\
    \t\tclosest = math.floor(value)\n\tend\n\t\n\t-- Round it away from zero\n\tclosest\
    \ = math.ceil(closest)\n\t\n\treturn closest\nend", "\tlocal diff = value-math.floor(value)\n\
    \tif diff > 0 then\n\t\treturn math.floor(value+0.5)\n\telseif diff < 0 then\n\
    \t\treturn math.ceil(value-0.5)\n\telse\n\t\treturn value\n\tend\nend", "    local\
    \ difference = math.abs(tonumber(value) - value)\n    if math.abs(difference)\
    \ == 0 then return value else return tonumber(value) end\n    difference = difference\n\
    \    -- if the difference is greater than or equal to one, the difference\n  \
    \  -- must be greater than or equal to zero. Conversely, if the difference\n \
    \   -- was negative, then (if the difference is negative) there must be\n    --\
    \ another integer greater than or equal to the difference and the\n    -- difference\
    \ must be less than or equal to zero.\n    if difference <= 1 then\n        if\
    \ difference > 0 then return value + 1 end\n        return value - 1 -- this also\
    \ happens to be what Python does for negative numbers\n    elseif difference >\
    \ 1 then\n        return math.ceil(value + difference - 0.5) -- round away from\
    \ zero\n    else\n        return math.floor(value + difference - 0.5) -- round\
    \ away from zero\n    end\nend", "    local function closest_integer(value)\n\
    \        local sign = math.sign(value)\n        local power = math.pow(10, math.floor(math.log10(value)))\n\
    \        local difference = math.abs(value - sign * math.floor(sign * value))\n\
    \        local difference2 = math.abs(value - sign * math.floor(sign * value))\
    \ * power\n        if difference < difference2 then\n            return sign *\
    \ math.floor(sign * value)\n        else\n            return math.floor(sign *\
    \ value)\n        end\n    end\n    return closest_integer(value)\nend", "   \
    \ local difference = math.abs(value - tonumber(value))\n    if difference <= 0.5\
    \ then\n        return tonumber(value)\n    end", "  return math.floor(value)\
    \ + math.abs(value - math.floor(value))\nend", "  local function compare(x, y)\n\
    \    return x < y then\n      or x == y then\n      or y > x then\n        then\
    \ 1\n        then -1\n        else None\n    end\n  end\n  assert(type(value)\
    \ == 'string')\n  value = tonumber(value)\n  local x, y = value, value\n  while\
    \ x ~= nil do\n    x, y = y, x\n  end\n  x = math.round(x)\n  if x > value then\n\
    \    return value + x - 1\n  else\n    return x\n  end\nend", "\tlocal closest",
  "    local diff = math.abs(value - math.floor(value))\n    if diff > 0.5 then\n\
    \        return math.floor(value - diff + 0.5)\n    else\n        return math.floor(value\
    \ + diff)\n    end\nend", "  local value = tonumber(value)\n  if value == nil\
    \ then return nil end\n  local delta = (value - math.floor(value))\n  if delta\
    \ ~= 0 then return math.floor(value) end\n  if value ~= math.floor(value) then\
    \ return nil end\n  return math.ceil(value)\nend", "\tlocal value_str = tostring(value)\n\
    \tlocal value_int = tonumber(value_str)\n\tif value_int > 0 and value_int < 2147483647\
    \ then\n\t\treturn value_int\n\telse\n\t\treturn tonumber(string.format(\"%.\"\
    \ .. (math.abs(value_int) - 1) .. \"f\", value_int))\n\tend\nend", "\tvalue =\
    \ tonumber(value)\n\tif not value then\n\t\terror(\"Value must be a number\")\n\
    \tend\n\tlocal rounded = math.round(value)\n\tif rounded == value then\n\t\treturn\
    \ value\n\telse\n\t\tif rounded - math.floor(value) == 0 then\n\t\t\treturn math.floor(value)\n\
    \t\telse\n\t\t\treturn math.floor(rounded)\n\t\tend\n\tend\nend", "  return math.round(math.abs(value\
    \ - math.floor(value)))\nend", "  local closest_val = value\n  local closest_d\
    \ = 1\n  for _, value in pairs(value) do\n    local value = tonumber(value)\n\
    \    local d = math.abs(value - closest_val)\n    if d < closest_d then\n    \
    \  closest_val = value\n      closest_d = d\n    end\n  end\n  return closest_val\n\
    end", '   local diff, low, high = tonumber(value), 0, math.abs(tonumber(value))',
  "    local num = tonumber(value)\n    local sign = math.floor(num)\n    if num -\
    \ sign < 0.5 then\n        return sign + 0.5\n    elseif num - sign > 0.5 then\n\
    \        return sign - 0.5\n    else\n        return sign\n    end\nend", "  \
    \  -- The original code was designed to find the closest integer to the value\n\
    \    -- and to find the closest integer is fairly useless in many cases\n    --\
    \ (where it returns the integer itself). Therefore we instead find\n    -- whichever\
    \ integer is closest to the value with some tolerance.\n    -- This is based on\
    \ our previous work on linear programming.\n    -- We use \"abs(value - closest_integer)\"\
    \ as a measure of tolerance.\n    -- We use \"ceil(closest_integer)\" as a way\
    \ to round up the closest\n    -- integer to make life easier when comparing integers.\n\
    \    -- We use a threshold of 5 digits just to keep things simple.\n    -- Our\
    \ threshold of 5 digits can be adjusted if it turns out that\n    -- numbers have\
    \ a much higher tolerance when compared to floats.\n    local threshold = 5 *\
    \ math.pow( 10, -5 )\n    local closest = 0\n    for _, x in ipairs( values )\
    \ do\n        if abs(x - closest) < threshold then\n            closest = x\n\
    \        else\n            -- We need to increase the closest integer by 1 so\
    \ that we\n            -- don't have to check the entire loop.\n            closest\
    \ = closest\n        end\n    end\n    -- In case there are no integers close\
    \ enough, return 0\n    if closest = 0 then\n        return 0\n    else\n    \
    \    return math.ceil(closest)\n    end\nend", "    if value == nil then return\
    \ nil end\n    value = tonumber(value)", "  local diff = math.abs(value - closest_integer(value))\n\
    \  local is_negative = value < 0\n  if diff < .000000000000000000000000000000000001\
    \ then\n    return is_negative and -value or value\n  elseif diff < .000000000000000000000000000000000000000001\
    \ then\n    return value\n  elseif diff < .00000000000000000000000000000000000000000000001\
    \ then\n    return math.floor(value)\n  else\n    return math.ceil(value)\n  end\n\
    end", "  local function is_closest(num, closest)\n    if closest == 0 then\n \
    \     return num\n    end\n    if num - closest <= 0.000000001 then\n      return\
    \ closest\n    end\n    local factor\n    if closest ~= num and closest ~= closest\
    \ * 2 then\n      factor = closest - num\n    end\n    return closest + num /\
    \ factor\n  end\n  local closest\n  local closestValue = value\n  if type(closestValue)\
    \ == \"number\" then\n    closest = closestValue\n  else\n    closestValue = closestValue[1]\n\
    \    closest = closestValue[2]\n  end\n  local currentValue = value\n  local currentDiff\
    \ = closestValue - closest\n  while currentDiff > 0 do\n    closest = is_closest(currentValue,\
    \ closest)\n    currentValue = currentValue + closest\n    currentDiff = currentDiff\
    \ - closest\n  end\n  return closest\nend", "  -- Convert the value to an integer,\
    \ then subtract it from itself to\n  -- find the distance between itself and value.\n\
    \  local value_as_number = tonumber(value)\n  return value_as_number - value_as_number\n\
    end", "  return math.floor(value) + math.abs(value - math.floor(value))\nend",
  "   local function closest(a, b)\n      return a < b and b\n         or b < a and\
    \ a\n         or b\n         and a\n         and b\n         or a\n   end", " \
    \ -- If the value is a string, replace the leading digit with '0' and then\n \
    \ -- convert it into an integer.\n  local is_string = type(value) == 'string'\n\
    \  if is_string then\n    value = value:gsub('%-?%d+', '0%'):tonumber()\n  end",
  "  local function distance(a, b) return math.abs(a - b) end\n  local i = 1\n  local\
    \ last_diff = -1000\n  while i do\n    local diff = distance(value, int_to_string(math.floor(value)))\n\
    \    if diff < last_diff then\n      return int_to_string(math.floor(value))\n\
    \    end\n    last_diff = diff\n    i = i * 10\n  end\n  return int_to_string(math.floor(value))\n\
    end", "  local factor = 1\n  local difference = 0", "  -- If the given number\
    \ is negative, return its absolute value.\n  if value then\n    if value < 0 then\n\
    \      return abs(value)\n    end\n  else\n    -- If the given number is positive,\
    \ return zero.\n    return 0\n  end\n  -- Divide the given number by two until\
    \ it equals zero. Divide it by two until\n  -- the quotient is even.\n  local\
    \ divisor = 2\n  local quotient = 0\n  while quotient ~= 0 do\n    quotient =\
    \ value / divisor\n    -- If the quotient is even, divide it by two and return\
    \ the quotient.\n    if quotient % 2 == 0 then\n      divisor = divisor * 2\n\
    \      return quotient\n    end\n    -- If the quotient is odd, subtract one from\
    \ the divisor and divide it\n    -- by two.\n    divisor = divisor - 1\n  end\n\
    end", "  local num_digits = #value\n  local decimal_places = math.remainder(value,\
    \ 1)\n  local rounded_away_from_zero = math.floor(decimal_places)\n  if rounded_away_from_zero\
    \ ~= decimal_places then\n    return rounded_away_from_zero\n  end\n  -- If decimal_places\
    \ is even, we need to return decimal_places +1.\n  if decimal_places == 0 then\n\
    \    return num_digits + 1\n  end\n  -- If decimal_places is odd, we need to return\
    \ decimal_places - 1.\n  return decimal_places - 1\nend", "\tlocal num = tonumber(value)",
  "  local num = tonumber(value)\n  -- Check that the given value is a number.\n \
    \ if not num then return nil end\n  -- If value is zero, return zero.\n  if num\
    \ == 0 then return 0 end\n  -- If value is negative, return the same value.\n\
    \  if num < 0 then return -num end\n  -- If value is close to 0, return it.\n\
    \  if num <= 0.000001 then return num end\n  -- Create a table of numbers around\
    \ the current value.\n  local delta = {\n    [1] = num - 0.00000001, -- 1\n  \
    \  [2] = num - 0.00000002, -- 2\n    [3] = num - 0.00000004, -- 3\n    [4] = num\
    \ - 0.00000008, -- 4\n    [5] = num - 0.00000016, -- 5\n    [6] = num - 0.00000032,\
    \ -- 6\n    [7] = num - 0.00000064, -- 7\n    [8] = num - 0.00000128, -- 8\n \
    \   [9] = num - 0.0000256, -- 9\n    [10] = num - 0.000512, -- 10\n    [11] =\
    \ num - 0.001280, -- 11\n    [12] = num - 0.002560, -- 12\n    [13] = num - 0.004096,\
    \ -- 13\n    [14] = num - 0.008192, -- 14\n    [15] = num - 0.016384, -- 15\n\
    \    [16] = num - 0.032768, -- 16\n    [17] = num - 0.065536, -- 17\n    [18]\
    \ = num - 0.131072, -- 18\n    [19] = num - 0.262144, -- 19\n    [20] = num -\
    \ 0.524288, -- 20\n    [21] = num - 0.796816, -- 21\n    [22] = num - 1.073743,\
    \ -- 22\n    [23] = num - 1.346939, -- 23\n    [24] = num - 1.725188, -- 24\n\
    \    [25] = num - 2.018688, -- 25\n    [26] = num - 2.302516, -- 26\n    [27]\
    \ = num - 2.594986, -- 27\n    [28] = num - 2.897435, -- 28\n    [29] = num -\
    \ 3.196875, -- 29\n    [30] = num - 3.490666, -- 30\n    [31] = num - 3.802184,\
    \ -- 31\n    [32] = num - 4.094512, -- 32\n    [33] = num - 4.410560, -- 33\n\
    \    [34] = num - 4.713896, -- 34\n    [35] = num - 5.114510, -- 35\n    [36]\
    \ = num - 5.41764", "\tlocal factor\n\tlocal closest\n\t-- Get a number close\
    \ to `value` that is factors of 10 and larger.\n\tfactor = math.floor(math.log(abs(value))\
    \ / math.log(10))\n\t-- Get the number that is closest to `value`.\n\tclosest\
    \ = (value - factor * 10) * 10\n\t-- Return 0 if the number close to `value` is\
    \ equidistant from two\n\t-- integers (i.e. the number is far away from zero).\n\
    \tif math.abs(closest) == math.abs(value) then\n\t\treturn 0\n\tend\n\treturn\
    \ closest\nend", "   local diff1 = math.abs(value - math.floor(value))\n   local\
    \ diff2 = math.abs(value - math.ceil(value))\n   if diff1 ~= diff2 then return\
    \ math.floor(value) end\n   return math.ceil(value)\nend", "  if value[0] == '-'\
    \ then\n    return math.floor(value * 100 / 2) + 100\n  end\n  return math.floor(value)\
    \ + math.ceil(value)\nend", "  if value == nil then\n    return nil\n  end", " \
    \  local closest_integer = math.ceil(value)\n   return (value - closest_integer)\
    \ or closest_integer\nend", '  local float_value = tonumber(value)', "    -- First,\
    \ convert value to float.\n    local value_as_number = tonumber(value)", "\tlocal\
    \ num = tonumber(value)\n\tif num == nil then\n\t\treturn nil\n\tend\n\tif num\
    \ < 0 then\n\t\treturn math.max(num, 0) + math.abs(num) / 2\n\telse\n\t\treturn\
    \ math.max(num, 0) - math.abs(num) / 2\n\tend\nend", "  local diff, nearest_int\
    \ = 0, value\n  for i = 1, 100 do\n    local _, n = value:match('(-?)(%d*)')\n\
    \    if n and tonumber(n) then\n      local n_int = tointeger(n)\n      if diff\
    \ > n_int - nearest_int then\n        nearest_int = n_int\n        diff = n_int\
    \ - nearest_int\n      end\n    end\n  end\n  return nearest_int + diff\nend",
  "\tlocal int_value = tonumber(value)\n\tif int_value == nil then\n\t\treturn nil\n\
    \tend", "  -- If value is nil, return 0\n  if value == nil then\n    return 0\n\
    \  end", "    local difference = math.abs(value - closest_integer(value))\n  \
    \  if difference < 1e-10 then\n        return math.round(value)\n    end\n   \
    \ return math.round(value/2.0 + 0.5)\nend", "\tlocal function closest_integer_helper(value,\
    \ low, high)\n\t\tif low > high then\n\t\t\treturn low\n\t\tend\n\t\tif math.abs(value\
    \ - low) < math.abs(value - high) then\n\t\t\treturn math.floor(value)\n\t\telse\n\
    \t\t\treturn math.ceil(value)\n\t\tend\n\tend", '  if value == nil then return
    nil end', "\tlocal function is_close(a, b, epsilon)\n\t\t-- Check if b has already\
    \ been compared to a\n\t\tif b > a then\n\t\t\tlocal diff = b - a\n\t\t\treturn\
    \ diff <= epsilon or diff >= -epsilon\n\t\tend\n\t\t\n\t\t-- Check if b is less\
    \ than a\n\t\tlocal diff = b - a\n\t\treturn diff <= epsilon or diff >= -epsilon\n\
    \tend\n\t\n\t-- Check if value is an integer, and if so,\n\t-- return the integer.\n\
    \tif type(tostring(value)) ~= \"number\" then\n\t\treturn nil\n\tend\n\t\n\t--\
    \ Check if value is an integer.\n\tlocal ok = value == math.floor(value)\n\tif\
    \ not ok then\n\t\treturn nil\n\tend\n\t\n\t-- Check if the given number is equidistant\
    \ from two integers.\n\tlocal closest = math.floor(value / 2.0)\n\tlocal a = value\
    \ - closest\n\tlocal b = value + closest\n\tif is_close(a, b, 1e-10) then\n\t\t\
    return closest\n\tend\n\t\n\treturn nil\nend", "  -- If value is an integer, just\
    \ return it\n  -- Otherwise create a string representation of it\n  if tonumber(value)\
    \ == value then\n    return value\n  else\n    return tonumber(string.format(\"\
    %0.1f\", value))\n  end\nend", "\tif value:match('^-?%d+$') then\n\t\treturn tonumber(math.floor(tonumber(value)))\
    \ + 1\n\tend\n\treturn math.floor(tonumber(value)) + 1\nend", "  if value <= 0\
    \ then return 0 end\n  local sign = math.sign(value)\n  local base_value = value",
  "  local value = tonumber(value)\n  if value == nil then return nil end\n  -- Get\
    \ all possible integers within one less than the given value.\n  -- If no integers\
    \ exist, return nil.\n  local integers = math.floor(value / 1) - 1\n  if #integers\
    \ == 0 then return nil end\n  -- Return first integer that is\n  -- the closest\
    \ to zero.\n  local closest = integers[1]\n  for i = 2, #integers do\n    local\
    \ difference = integers[i] - closest\n    if difference < 0 then\n      closest\
    \ = integers[i]\n    else\n      -- If difference is positive and closest\n  \
    \    -- is negative, return closest negative.\n      closest = closest + (difference\
    \ > 0 and 1 or -1)\n    end\n  end\n  return closest\nend", "   local result\n\
    \   value = tonumber(value)\n   if value == nil then return nil end\n   if value\
    \ == 0 then return 0 end\n   if value < 0 and math.abs(value) < math.abs((value+1):max())\
    \ then return -value end\n   if value > 0 and math.abs(value) < math.abs((value-1):min())\
    \ then return value end\n   if math.abs(value) == 0 then\n      result = 0\n \
    \  else\n      result = tonumber(string.format(\"%.*f\", math.ceil(math.log10(value)),\
    \ value))\n   end\n   return result\nend", "  -- If the number is equal to or\
    \ less than zero, return zero.\n  return value <= 0 and 0 or math.floor(math.abs(value));\n\
    end", "  local num_int = tonumber(value)\n  local difference\n  -- If the number\
    \ is less than or equal to zero, return zero.\n  if not num_int then\n    return\
    \ 0\n  end\n  -- If the number is equidistant, return either one or the other\
    \ integer\n  -- that is closest to zero.\n  if num_int == num_int - 0.5 then\n\
    \    return num_int\n  else\n    difference = num_int - math.floor(num_int)\n\
    \    if difference > -0.5 then\n      return math.floor(num_int)\n    else\n \
    \     return math.ceil(num_int)\n    end\n  end\nend", "  local differences =\
    \ {}\n  for i = 1, 9 do\n    local difference = math.abs(tonumber(value) - tonumber(string.format(\"\
    %.f\", i)))\n    table.insert(differences, difference)\n  end", "    local function\
    \ find_closest(v)\n        -- This function returns two values:\n        -- *\
    \ The closest number\n        -- * The distance from 0 to the closest number\n\
    \        local closest_num, closest_dist = -math.huge, math.huge\n        for\
    \ i = 1, #value do\n            local num = tonumber(value[i])\n            if\
    \ num < 0 then\n                num = -num\n            end\n            local\
    \ diff = closest_num + num\n            if diff < closest_dist then\n        \
    \        closest_num, closest_dist = num, diff\n            end\n        end\n\
    \        return closest_num, closest_dist\n    end\n    local value, distance\
    \ = find_closest(value)\n    if distance < 0 then\n        -- If the number is\
    \ equidistant from two integers, return the\n        -- integer that is farthest\
    \ from zero.\n        local first_num, first_dist = value[1], distance[1]\n  \
    \      for i = 2, #value do\n            local second_num, second_dist = value[i],\
    \ distance[i]\n            if first_dist > second_dist then\n                return\
    \ first_num\n            elseif first_dist == second_dist then\n             \
    \   local delta = second_num - first_num\n                if delta > 0 then\n\
    \                    return first_num + delta\n                else\n        \
    \            return first_num - delta\n                end\n            end\n\
    \        end\n    end\n    return value\nend", "    if type(value) ~= \"string\"\
    \ then\n        return nil\n    end\n    -- TODO: This won't handle rounding down\
    \ in certain cases like\n    -- 12.6 -> 13. Need to fix it by making it 12.7 and\
    \ 12.8 -> 13\n    -- by changing the first condition and the first condition.\n\
    \    -- If value is less than 10, use 10.\n    if value < \"10\" then\n      \
    \  local v = \"10\"\n    else\n        v = value\n    end", "  local function\
    \ helper(num)\n    if num == 0 then\n      error(\"Can't divide by zero\")\n \
    \   end\n    local closest_value\n    for i = 1, (#num / 2) do\n      local left\
    \ = string.sub(num, 0, i-1)\n      local right = string.sub(num, (#num), i)\n\
    \      local left_number = tonumber(left)\n      local right_number = tonumber(right)\n\
    \      if left_number and right_number then\n        if left_number < right_number\
    \ then\n          closest_value = left_number\n        else\n          closest_value\
    \ = right_number\n        end\n      else\n        if left_number then\n     \
    \     closest_value = left_number\n        else\n          closest_value = right_number\n\
    \        end\n      end\n    end\n    return closest_value\n  end\n  return helper(tostring(val))\n\
    end", "  local function integer_abs(n)\n    if n == nil then\n      error(\"can't\
    \ call math.abs on nil\")\n    end\n    return math.abs(n)\n  end\n  local function\
    \ round_to_even(n)\n    return math.floor(n / 2) * 2\n  end\n  local function\
    \ round_to_zero(n)\n    if n == nil then\n      error(\"can't call math.abs on\
    \ nil\")\n    end\n    if n < 0 then\n      return round_to_even(math.ceil(n))\n\
    \    else\n      return round_to_even(math.floor(n))\n    end\n  end\n  local\
    \ function divide_then_round_to_even(n, p)\n    return round(n / p) * p\n  end\n\
    \  local function round(n) -- Round a number to an even number\n    return round_to_even(n)\n\
    \  end", "  if value == nil then return nil end\n  local sign = math.sign(value)\n\
    \  if sign == 0 then return 0 end\n  -- Convert string to float\n  value = tonumber(value)\n\
    \  -- Check if value is an integer\n  if value == value then\n    -- If value\
    \ is an integer with no other numbers, return the integer\n    if value == int(value)\
    \ then\n      return value\n    else\n      -- If value is an integer, return\
    \ the integer with value rounded\n      -- away from zero.\n      return math.ceil(value)\n\
    \    end\n  else\n    -- If the value is not a number, return nil\n    return\
    \ nil\n  end\nend", "    if value == nil then\n        return nil\n    end\n \
    \   -- Make sure value is numeric.\n    local value = tonumber(value)\n    if\
    \ value == nil then\n        return value\n    end\n    -- If the value is an\
    \ integer, return it.\n    if value == math.floor(value) then\n        return\
    \ value\n    end\n    -- If the value is negative, it's an error.\n    if value\
    \ >= 0 then\n        return nil\n    end\n    -- If the value is less than -100,\
    \ it's an error.\n    if value <= -100 then\n        return nil\n    end\n   \
    \ -- Get the closest integer.\n    local closest_integers = math.ceil(value /\
    \ 100) * 100\n    -- If the value is greater than (-100 ~< closest_integers <\
    \ 100), return it.\n    if value < closest_integers then\n        return closest_integers\n\
    \    end\n    -- If the value is less than -100, it's an error.\n    if value\
    \ >= -100 then\n        return nil\n    end\n    -- If the value is less than\
    \ -100, it's an error.\n    if value <= -100 then\n        return nil\n    end\n\
    \    -- Else, return it rounded towards zero.\n    return math.floor(value)\n\
    end", '    local float_value = tonumber(value)', "  if value == nil then return\
    \ nil end\n  local diff, err = tonumber(value) - 1, nil\n  if diff == nil then\
    \ return nil end\n  local closest, err = math.floor(diff + 0.5), nil\n  if closest\
    \ == nil then return nil end\n  local digits = math.pow(10, math.floor(math.log10(diff\
    \ + 1))) -- get number of digits after the decimal point\n  if digits > 6 then\
    \ return nil end\n  return closest\nend", "   -- If the given value is a string\
    \ or nil, return nil.\n   if type(value) == \"string\" then\n      return nil\n\
    \   end", "  if value == nil then return nil end\n  local sign = 1\n  if value\
    \ ~= value then sign = -1 end\n  local value = tonumber(value)\n  if value ==\
    \ nil then return nil end\n  local lower = math.floor(value)\n  local upper =\
    \ math.ceil(value)\n  -- If the number is not equidistant from two integers, return\
    \ nil.\n  if lower == value or upper == value then return nil end\n  -- If the\
    \ number is equidistant from two integers, return the largest\n  -- integer.\n\
    \  if lower < upper then\n    return math.max(lower, upper)\n  -- If the number\
    \ is equidistant from two integers, return the smallest\n  -- integer.\n  else\n\
    \    return math.min(lower, upper)\n  end\nend", "  return math.floor(\n    (abs(tonumber(value)\
    \ - tonumber(value)))\n  )\nend", "  local function closest_integer(value)\n \
    \   local digits = string.rep(\"0123456789\", math.floor(math.log10(value)))\n\
    \    local diff = digits - tonumber(string.sub(value, 1, -1))\n    return tonumber(string.rep(\"\
    0\", diff) + value) or 0\n  end", "  local num = tonumber(value)\n  assert(num,\
    \ \"Expected a number for closest_integer\")", "    if tonumber(value) >= tonumber(0)\
    \ then\n        return tonumber(value)\n    elseif tonumber(value) >= tonumber(1)\
    \ then\n        return tonumber(0)\n    elseif tonumber(value) >= tonumber(-1)\
    \ then\n        return tonumber(-1)\n    end", "  local diff = tonumber(value)\n\
    \  local diff1 = tonumber(value)\n  local diff2 = tonumber(value)\n  if type(value)\
    \ == \"string\" then\n    value = tonumber(value)\n  end\n  diff1 = math.floor(diff1)\n\
    \  diff2 = math.floor(diff2)\n  diff = math.abs(diff1 - diff2)\n  if diff < 1\
    \ then\n    diff, diff1 = diff1, diff\n  end\n  return diff1\nend", "  if value\
    \ == nil then\n    return nil\n  end", "    local closest\n    local closest_dist\n\
    \    if type(value) ~= 'number' then\n        return nil\n    end\n    local value\
    \ = tonumber(value)\n    local max_dist = 0\n    local max_int = 0\n    for _,\
    \ other in ipairs(values) do\n        if other > 0 then\n            local other_dist\
    \ = math.abs(value - other)\n            if other_dist > max_dist then\n     \
    \           max_dist = other_dist\n                closest_int = other\n     \
    \       elseif other_dist == max_dist then\n                if other_dist < max_dist\
    \ then\n                    closest_int = other\n                end\n       \
    \     end\n        end\n    end\n    closest\nend", "  if value == nil then\n\
    \    return nil\n  end\n  if value:sub(1, 1) ~= \"\" then -- Only one character\n\
    \    local divisor, num = tonumber(value), tonumber(string.sub(value, 2))\n  \
    \  if num == nil then -- Not a valid number\n      return nil\n    end\n    return\
    \ tonumber(math.ceil(num / divisor))\n  end\n  local divisor, num = tonumber(value),\
    \ tonumber(string.sub(value, 1))\n  if num == nil then -- Not a valid number\n\
    \    return nil\n  end\n  return tonumber(math.ceil(num / divisor))\nend", " \
    \ local function closest_integer(value)\n    -- Get a list of the digits in value\
    \ as a list of integers.\n    local digits = value:gsub(\"%d+\", function(digit)\n\
    \      return tonumber(digit)\n    end)", "    local num = tonumber(value)\n \
    \   if not num then\n        return\n    end\n    local num = num + 0.0\n    if\
    \ num < 0 then\n        num = math.floor(num)\n    else\n        num = math.ceil(num)\n\
    \    end\n    return num\nend", "  -- Return the closest integer to the given\
    \ value.\n  return math.round(math.floor((math.abs(value) + 0.5)))\nend", '    if
    value == nil then return nil end', "  if type(value) ~= \"string\" then return\
    \ end\n  local digits = value:gsub(\".\", \"\")\n  local min = 0\n  local max\
    \ = #digits - 1\n  while min < max do\n    local mid = (min + max) / 2\n    local\
    \ current_value = tonumber(digits[mid])\n    if current_value == nil then return\
    \ end -- Not a number\n    if min == mid then return current_value end\n    if\
    \ current_value ~= nil then\n      if current_value < value then min = mid + 1\
    \ else max = mid end\n    else -- current_value == nil\n      if value == 0 then\
    \ return 0 end\n      min = mid\n    end\n  end\n  return tonumber(digits[min])\n\
    end", "\tif value == nil then return nil end\n\tlocal sign = value == \"-\" and\
    \ -1 or 1\n\tlocal difference = tonumber(value)\n\tif difference == nil then\n\
    \t\treturn nil\n\tend\n\tlocal limit = math.max(math.abs(difference), 1e-6)\n\t\
    local limit = math.ceil(limit) -- Round to nearest\n\tif math.abs(difference)\
    \ < limit then\n\t\treturn value\n\tend\n\tlocal limit = math.floor(limit)\n\t\
    if difference < 0 then\n\t\treturn sign - limit\n\telse\n\t\treturn limit + sign\n\
    \tend\nend", "  local closest\n  if value == \"0\" then\n    return 0\n  end\n\
    \  closest = (math.floor(math.abs(value)) + math.floor(math.abs(value - (math.floor(math.abs(value)))))\
    \ - 1)\n  if closest < 0 then\n    closest = 0\n  end\n  return closest\nend",
  "    -- Handle negative numbers by finding the closest integer to the negated number\n\
    \    if value == \"-\" then\n        value = value\n        for i=2,#args do\n\
    \            if tonumber(args[i]) < tonumber(value) then\n                value\
    \ = args[i]\n            end\n        end\n    end\n    -- Handle positive numbers\
    \ by finding the closest integer to the negated number\n    if value == \"+\"\
    \ then\n        value = value\n        for i=2,#args do\n            if tonumber(args[i])\
    \ > tonumber(value) then\n                value = args[i]\n            end\n \
    \       end\n    end\n    return tonumber(value)\nend", "    local is_negative\
    \ = value:sub(-1, 1, 1):lt(0)\n    if is_negative then\n        value = -value:sub(1,\
    \ 1)\n    end\n    return math.floor(value)\nend", "  local function is_equidistant(integer1,\
    \ integer2)\n    local difference = math.abs(integer1 - integer2)\n    return\
    \ difference <= 1\n  end", "  if value == nil then\n    return nil\n  end\n  if\
    \ type(value) ~= 'string' then\n    return nil\n  end\n  if value == \"\" then\n\
    \    return 0\n  end\n  local _, num, _, _, _ = value:match(\"^([+-]?(?:(?:0x)?-?(?:0x)?[0-9a-f]+)|(?:0x)?-?[0-9]+)([.][0-9]+)?$\"\
    )\n  if num == nil then\n    return nil\n  end\n  local sign, digits, decimals\
    \ = num:match(\"^([+-])([-+]?[0-9]*)(?:(\\\\.[0-9]*))?$\")\n  if sign == nil then\n\
    \    sign = string.sub(num, 1, 1)\n    digits = string.sub(num, 2)\n    decimals\
    \ = nil\n  end\n  if decimals == nil then\n    decimals = string.sub(num, -1,\
    \ -1)\n  end\n  local factor = 1\n  local precision = 0\n  if digits == nil then\n\
    \    digits = string.sub(num, -2)\n    if decimals == nil then\n      return sign\
    \ * tonumber(digits) * factor\n    end\n  end\n  local decimals_str = string.sub(decimals,\
    \ 1, 1)\n  local decimals_strlen = string.len(decimals_str)\n  if decimals_strlen\
    \ == 2 then\n    local decimals_decimal = tonumber(decimals)\n    if decimals_decimal\
    \ ~= nil then\n      precision = decimals_decimal\n    end\n  elseif decimals_strlen\
    \ == 1 and decimals_str == \"0\" then\n    precision = 1\n  end\n  if digits ==\
    \ nil then\n    digits = string.sub(num, -2)\n  end\n  local digits_str = string.sub(digits,\
    \ 1, 1)\n  local digits_strlen = string.len(digits_str)\n  if digits_strlen ==\
    \ 2 then\n    local digits_decimal = tonumber(digits)\n    if digits_decimal ~=\
    \ nil then\n      factor = digits_decimal\n    end\n  end\n  local decimals_decimal\
    \ = tonumber(decimals)\n  if decimals_decimal ~= nil then\n    factor = decimals_decimal\
    \ * factor\n  end\n  if digits == nil then\n    digits = string.sub(num, -2)\n\
    \  end\n  if decimals == nil then\n    decimals = string.sub(num, -1, -1)\n  end\n\
    \  local digits_decimal = tonumber(digits)\n  if digits_decimal ~= nil then\n\
    \    factor = digits_decimal * factor\n  end\n  if factor == nil then\n    return\
    \ nil\n  end\n  if sign == \"-\" then\n    return math.floor(-math.abs(tonumber(digits)\
    \ * factor))\n  end\n", "    local ints = {}\n    for i = -1000, 1000 do\n   \
    \     local val = tonumber(string.format(\"%.2g\", value + i * 0.0001))\n    \
    \    if val ~= nil then\n            table.insert(ints, val)\n        end\n  \
    \  end\n    local last = ints[1]\n    for _, v in ipairs(ints) do\n        if\
    \ v - last <= 0.000001 then\n            return last\n        end\n        last\
    \ = v\n    end\n    return nil\nend", "  local value = tonumber(value)\n  if value\
    \ == nil then return nil end\n  local sign = math.abs(value)\n  if sign == 0 then\n\
    \    if value < 0 then\n      return value\n    end\n    return 0\n  end\n  local\
    \ factor = 1\n  while sign * factor < sign do\n    factor *= 10\n  end\n  -- Now\
    \ we know the closest number to `value` is `value/factor` closest\n  -- to zero.\n\
    \  if sign == -1 and value < 0 then\n    -- Value is negative, factor is positive.\n\
    \    sign = sign * -1\n    factor = sign * factor\n  end\n  -- Value is positive,\
    \ factor is negative.\n  -- So this should work since `value/factor` is closer\
    \ to zero than `value`.\n  local remainder = (value - sign * factor) / factor\n\
    \  assert(remainder >= 0 and remainder <= 1)\n  -- Return the closest integer.\n\
    \  return sign * factor * remainder\nend", "   -- The idea is to find two closest\
    \ numbers:\n   --   1) The first that is bigger then the given number\n   -- \
    \  2) The first that is smaller  then the given number\n   -- If these two numbers\
    \ are equidistant from zero, then the number\n   -- itself is returned.\n   local\
    \ function find_closest(a, b)\n      if a > b then\n         return a\n      else\n\
    \         return b\n      end\n   end\n   local function distance(a, b)\n    \
    \  if a < b then\n         return b - a\n      else\n         return b - a\n \
    \     end\n   end", "  value = tonumber(value)\n  if value == nil then\n    return\
    \ nil\n  elseif value == math.floor(value) then\n    -- Don't allow the argument\
    \ to be zero.\n    if value == 0 then\n      return nil\n    else\n      return\
    \ value\n    end\n  else\n    -- Calculate the difference between value and the\
    \ next integer.\n    -- Note that this formula doesn't take into account that\
    \ value\n    -- is an integer already.\n    return math.floor(value) + math.ceil(value)\
    \ - value\n  end\nend", "  local int_value = value\n  local closest\n  -- If the\
    \ number is not equidistant from two integers, return it.\n  if int_value ~= tonumber(int_value)\
    \ then\n    closest = (tonumber(int_value) or 0)\n  else\n    -- Find the difference\
    \ between the given value and the integer\n    -- closest to it.\n    closest,\
    \ _ = math.modf(abs(tonumber(int_value) - int_value))\n  end\n  -- If we are rounding\
    \ away from zero, round the closest integer.\n  if closest < 0 then\n    closest\
    \ = 1\n  end\n  -- Return the closest integer.\n  return closest\nend", "    local\
    \ closest\n    local values = {}\n    for _, i in ipairs(string.gmatch(value,\
    \ \"%d*$\") do table.insert(values, i) end)\n    \n    local minimum = math.min(values)\n\
    \    local maximum = math.max(values)\n    if minimum == maximum then return 0\
    \ end", "  local closest\n  local delta = tonumber(value) - tonumber(closest)\n\
    \  if delta < 0 then\n    closest = \"-\"..closest\n  else\n    closest = \"+\"\
    ..closest\n  end\n  if delta < 0.5 then\n    return tonumber(closest .. \"+0\"\
    )\n  elseif delta >= 0.5 then\n    return tonumber(closest .. \"-0)\")\n  else\n\
    \    -- The number is equidistant to two other numbers, round it away from zero.\n\
    \    local closest = tonumber(closest)\n    local toAdd = 0.5\n    while tonumber(closest\
    \ + toAdd) ~= closest do\n      toAdd = toAdd + 0.5\n    end\n    return tonumber(closest\
    \ + toAdd)\n  end\nend", "\tlocal int1 = tonumber(value)\n\tlocal int2 = tonumber(value)\n\
    \tlocal diff1 = int1 - int2\n\tlocal diff2 = int2 - int1\n\tlocal rounded = round(diff1\
    \ / diff2)\n\tif rounded ~= int1 then\n\t\treturn rounded\n\telse\n\t\treturn\
    \ int1\n\tend\nend", "  if value == nil then return nil end\n  local num = tonumber(value)\n\
    \  local divisor = 2\n  -- First try an exact match\n  if num == 0 then\n    return\
    \ 0\n  end\n  -- Next try a non-exact match\n  while true do\n    local next_divisor\
    \ = divisor\n    while next_divisor ~= 0 do\n      num = num / next_divisor\n\
    \      if not num then break end\n      next_divisor = next_divisor + 1\n    end\n\
    \    -- Now try a number divisible by two\n    if tonumber(string.format(\"%.f\"\
    , num)) % 2 == 0 then\n      num = num + 1\n      if tonumber(string.format(\"\
    %.f\", num)) % 2 == 0 then\n        divisor = divisor + 1\n      end\n    end\n\
    \  end\n  -- Now return the integer value nearest the original value\n  return\
    \ tonumber(string.format(\"%.f\", num))\nend\nreturn closest_integer", "   local\
    \ closest_val = value\n   if closest_val == 0 then\n      return 0\n   end\n \
    \  local is_odd = math.floor(value / 2.0) == value\n   if is_odd then\n      return\
    \ math.floor(value / 2.0)\n   else\n      local is_even = math.floor(value / 2.0)\
    \ == 0\n      if is_even then\n         return math.floor(value / 2.0)\n     \
    \ else\n         return math.ceil(value)\n      end\n   end\nend", "  local difference\
    \ = math.abs(value - math.floor(value + 0.5))\n  local closest_integer = math.floor(value\
    \ + 0.5)\n  if difference <= 0.5 then\n    return closest_integer\n  else\n  \
    \  return closest_integer - 1\n  end\nend", "    -- If the value is zero or the\
    \ value is below zero, return zero.\n    if value == 0 or value < 0 then\n   \
    \     return 0\n    end", "    local difference = math.abs(value - math.floor(value))\n\
    \    if value == math.floor(value) then\n        return value -- This is the same\
    \ as the closest integer.\n    elseif difference <= .5 then\n        return math.floor(value)\n\
    \    elseif difference >= 1 then\n        return math.ceil(value)\n    else\n\
    \        -- The number is far from two integers, round it away from zero.\n  \
    \      return math.floor(value) + math.ceil(value) / 2\n    end\nend", "\t-- Create\
    \ a function to round to the nearest integer.\n\tlocal function round_away_from_zero(v)\n\
    \t\treturn math.floor(value + 0.5)\n\tend", "    local factor\n    local max",
  "\tlocal function distance(x, y)\n\t\treturn math.abs(x - y)\n\tend", "  local int_value\
    \ = tonumber(value)\n  local delta\n  if int_value == nil then\n    ngx.log(ngx.DEBUG,\
    \ \"No valid integer value found in value '\" ..\n      value .. \"'\")\n    return\
    \ value\n  elseif int_value < 0 then\n    delta = 1\n  else\n    delta = math.abs(int_value)\
    \ ^ 2\n  end\n  if delta == 0 then\n    ngx.log(ngx.DEBUG, \"Nearby integers are\
    \ equidistant\")\n    return int_value\n  else\n    local div = delta\n    local\
    \ rem = math.floor(int_value / div)\n    local closest_int\n    while div > 1\
    \ do\n      div = div / 2\n      rem = math.floor(rem / 2)\n      if rem == 0\
    \ then\n        closest_int = div\n        break\n      end\n    end\n    return\
    \ closest_int + rem\n  end\nend", "\tlocal function closest(num, max)\n\t\tif\
    \ num == nil then return nil end\n\t\tif num == max then return num end\n\t\t\
    if num > max then return nil end\n\t\tlocal m = math.floor(num / max)\n\t\tif\
    \ m == num then\n\t\t\treturn max\n\t\telseif m > num then\n\t\t\treturn closest(max,\
    \ num)\n\t\telseif m == num - 1 then\n\t\t\treturn num\n\t\tend\n\t\treturn closest(m,\
    \ max)\n\tend", "  local result = tonumber(value)\n  if tonumber(result) then\n\
    \    if result > 0 and tonumber(result) == result then\n      result = tonumber(result)\n\
    \    else\n      -- If the given number is equidistant from two integers, return\
    \ the\n      -- one that is farthest from zero.\n      local difference = abs(result\
    \ - tonumber(value))\n      for i=1, #integers do\n        local current_difference\
    \ = abs(tonumber(integers[i]) - result)\n        if current_difference > difference\
    \ then\n          difference = current_difference\n          result = tonumber(integers[i])\n\
    \        end\n      end\n    end\n  else\n    error(\"Unable to parse number as\
    \ number.\")\n  end", "  return math.max(math.floor(value), math.ceil(value))\n\
    end", "    local difference = value - tonumber(value)\n    if difference == 0\
    \ then\n        return tonumber(value)\n    end\n    if difference < 0 then\n\
    \        return tonumber(value) + 1\n    end\n    return tonumber(value)\nend",
  "  local diff = value - closest_integer(math.floor(value))\n  if diff < 0 then\n\
    \    return math.ceil(value)\n  else\n    return math.floor(value)\n  end\nend",
  "  if value == nil then\n    return \"nil\"\n  end\n  local pos = tonumber(value)\n\
    \  if pos ~= nil and math.abs(pos - pos) == 1 then\n    -- If the number is a\
    \ float or double, round it to an integer before\n    -- doing math.abs().\n \
    \   pos = math.floor(pos)\n  elseif pos ~= nil then\n    -- If its an integer,\
    \ return it if it is equidistant from two integers.\n    local max_dist = #integers\
    \ - 1\n    local max_val = nil\n    for i=1,#integers do\n      if pos - integers[i]\
    \ < max_dist then\n        max_dist = -(pos - integers[i])\n        max_val =\
    \ integers[i]\n      end\n    end\n    return max_val\n  end\n  return \"nil\"\
    \nend", "  local value = tonumber(value)\n  local value_diff = value\n  local\
    \ i = 1\n  local closest_integer\n  do\n    closest_integer = tonumber(string.format(\"\
    %.1f\", value_diff))\n    value_diff = value_diff - closest_integer\n    i = i\
    \ + 1\n  end\n  while value_diff ~= 0 and i >= 2 do\n    value_diff = value_diff\
    \ - closest_integer\n    i = i - 1\n  end\n  return closest_integer\nend", " \
    \ local integer = 0\n  local is_equidistant = false\n  local diff = 1"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
