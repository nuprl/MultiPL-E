name: HumanEval_103_rounded_avg
language: lua
prompt: "-- You are given two positive integers n and m, and your task is to compute\
  \ the\n-- average of the integers from n through m (including n and m). \n-- Round\
  \ the answer to the nearest integer and convert that to binary.\n-- If n is greater\
  \ than m, return -1.\n-- Example:\n-- rounded_avg(1, 5) => \"0b11\"\n-- rounded_avg(7,\
  \ 5) => -1\n-- rounded_avg(10, 20) => \"0b1111\"\n-- rounded_avg(20, 33) => \"0b11010\"\
  \nlocal function rounded_avg(n, m)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rounded_avg\n\
  \    lu.assertEquals(candidate(1, 5), '0b11')\n    lu.assertEquals(candidate(7,\
  \ 13), '0b1010')\n    lu.assertEquals(candidate(964, 977), '0b1111001010')\n   \
  \ lu.assertEquals(candidate(996, 997), '0b1111100100')\n    lu.assertEquals(candidate(560,\
  \ 851), '0b1011000010')\n    lu.assertEquals(candidate(185, 546), '0b101101110')\n\
  \    lu.assertEquals(candidate(362, 496), '0b110101101')\n    lu.assertEquals(candidate(350,\
  \ 902), '0b1001110010')\n    lu.assertEquals(candidate(197, 233), '0b11010111')\n\
  \    lu.assertEquals(candidate(7, 5), -1)\n    lu.assertEquals(candidate(5, 1),\
  \ -1)\n    lu.assertEquals(candidate(5, 5), '0b101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if m < n then return -1 end\n  local avg = 0\n  for i = n, m do\n\
    \    avg = avg + i\n  end\n  return avg / 2\nend", "  -- Return the average of\
    \ the numbers from n through m\n  if n > m then\n    return -1\n  end\n  \n  --\
    \ Compute rounded average\n  local rounded_average = (n + (m - n)) / (2 * m) \n\
    \  \n  -- Convert result to binary string\n  local binary_average = ffi.string(tostring(rounded_average))\n\
    \  \n  -- Round the average to nearest integer\n  local rounded_integer = round(rounded_average)\n\
    \  \n  -- Return rounded integer if rounded integer is less than n\n  -- or return\
    \ -1 if rounded integer is greater than m\n  return rounded_integer < n or rounded_integer\
    \ > m and -1\nend", "\tlocal bin1 = \"0\"\n\tlocal bin2 = \"0\"\n\tlocal sum =\
    \ 0\n\tlocal i", "  if n > m then\n    return -1\n  end\n  local n_bin = tonumber(tostring(n))\n\
    \  local m_bin = tonumber(tostring(m))\n  if n_bin and m_bin then\n    return\
    \ string.gsub(tostring(round(n_bin + m_bin)), \"%d%d\", \"\")\n  end\nend", " \
    \ local nm = math.tostring(n, 'b') .. math.tostring(m, 'b')\n  local nm_length\
    \ = len(nm)\n  local nm_digits = math.floor(nm_length / 2)\n  if nm_length > nm_digits\
    \ then\n    local diff = nm_length - nm_digits\n    nm = nm .. \"0\"\n    for\
    \ i = 0, diff do\n      nm = nm .. \"1\"\n    end\n  end\n  return nm\nend", " \
    \  if m == 0 then return 0\n   elseif n == m then return tostring(m)\n   elseif\
    \ n > m then return -1\n   else\n      local s = math.floor((n+m) / 2)\n     \
    \ local avg = (s + m) / 2;\n      local ans = \"\"\n      for i = s, m do ans\
    \ = ans + tostring(i) end\n      return avg + ans\n   end\nend", "\tif m < n then\
    \ return -1\n\tend\n\t\n\tlocal n = tonumber(n)\n\tlocal m = tonumber(m)\n\t\n\
    \tif m < n then return -1\n\tend\n\t\n\tlocal avg = m\n\tlocal count = m\n\t\n\
    \tlocal i = n -1\n\t\n\twhile count > 0 and i >= 1 do\n\t\tavg = avg - 1 \n\t\t\
    count = count - 1\n\t\ti = i - 1\n\tend\n\t\n\tif count < 1 then return -1\n\t\
    end\n\t\n\treturn string.format(\"%b\", avg)\nend", "  -- If n is less than m,\
    \ return -1\n  if n < m then return -1\n  else\n    -- Otherwise, find the middle\
    \ of the range\n    local start = n\n    local end = m\n    while start < end\
    \ do\n      start = math.floor(start / 2) + 1\n      end = math.floor(end / 2)\n\
    \    end\n    -- Convert to binary\n    local bin_start = 1\n    local bin_end\
    \ = math.pow(2,math.ceil(math.log2(m-n)))\n    local binary_sum = 0\n    while\
    \ bin_start <= bin_end do\n      binary_sum = binary_sum + ((2**bin_start)*n)\n\
    \      bin_start = bin_start + 1\n    end\n    binary_sum = binary_sum + n\n \
    \   return binary_sum/math.pow(2, math.ceil(math.log2(m-n)))\n  end\nend", " \
    \   if n < m then\n        return -1\n    end\n    local r = n - m\n    if r >\
    \ 1 then\n        local rr = math.floor(r * 0.4)\n        if rr > n then\n   \
    \         rr = n\n        end\n        return rr .. math.ceil(r * 0.5)\n    end\n\
    \    if m == n then\n        return m\n    end\n    local rr = math.floor(r *\
    \ 0.2)\n    if rr > n then\n        rr = n\n    end\n    return rr .. math.ceil(r\
    \ * 0.5)\nend", "  assert(n >= 0 and m >= 0)\n  if m == 0 then\n    return -1\n\
    \  elseif n == m then\n    return \"0b\" .. to_binary(n)\n  else\n    return (\"\
    0b\" .. to_binary(n)) .. to_binary(m)/to_binary(n) \n  end\nend", "   if n ==\
    \ m then\n      return n\n   elseif n < m then\n      return -1\n   end\n   \n\
    \   local mid = n + (m / 2)", "  if n > m then\n    return -1\n  end\n  local\
    \ num = ''\n  for i in (m - n + 1) do\n    num = num .. ('0' .. math.floor(n/math.pow(2,i)))\n\
    \    n = n - num * math.pow(2,i)\n  end\n  if n == 0 then\n    return num\n  else\n\
    \    return num .. '1' -- return binary string where 1 is moved to left\n  end\n\
    end", "    -- Your code here\n    -- end\nend", "  if n >= m then return -1 end\n\
    \  local i, acc = 0, 1\n  while i < n do\n    i, acc = i+1, ((acc*10) + m/10)\
    \ + m/m\n  end\n  return \"0b\" .. tostring(acc)\nend", "    if n == m then return\
    \ \"0b0\"\n    elseif m == 0 then return \"0b0\"\n    elseif n <= m then return\
    \ \"0b\" .. tostring(n .. \"/\" .. m)\n    else return \"-1\" end\nend", "  local\
    \ result = \"\"\n  if m < n then \n    return -1\n  elseif m == n then \n    result\
    \ = \"0b0\"\n  else\n    -- Find the least and most significant bits.\n    local\
    \ m = math.floor(math.log(m) / math.log(2)) \n    local n = math.floor(math.log(n)\
    \ / math.log(2))\n    local m = 2^m\n    local n = 2^n", "  assert(n > 0, \"n\
    \ must be positive\")\n  assert(m > 0, \"m must be positive\")\n  local n = tostring(n)\n\
    \  local m = tostring(m)\n  local avg, n, m\n  local i\n  if n <= m then\n   \
    \ avg = tonumber(string.format(\"%b\", n .. m))\n  else\n    avg = -1\n    for\
    \ i = 1, m do\n      n = n - 1\n      avg = tonumber(string.format(\"%b\", n ..\
    \ m))\n    end\n  end\n  \n  return avg\nend", "  if n < m then \n    return -1\n\
    \  end\n  \n  local avg = nil\n  for i = n, m, -1 do\n    local d = i/2\n    if\
    \ d % 2 == 1 then\n      avg = (avg or 0) + d\n    end\n  end\n  \n  if avg ==\
    \ nil then\n    return -1\n  end\n  \n  return bin_to_dec(((avg * 2) - n) + 1)\n\
    end", "  if n < m then return -1\n  end\n  if n == m then return \"0b\" .. n\n\
    \  else\n    local avg = 0\n    while n > 0 do\n      avg = avg * 2 + n % 10\n\
    \      n = math.floor(n/10)\n    end\n    return \"0b\" .. math.floor(avg / 2)\n\
    \  end\nend", "\t-- Write your code here\n\tlocal num = \"\"\n\tlocal sum = 0\n\
    \tlocal i = 0\n\twhile i <= m do\n\t\tsum = sum + i\n\t\ti = i + 1\n\tend\n\t\
    num = sum / m\n\tnum = math.floor(num)\n\tnum = tostring(num)\n\tlocal i = 2\n\
    \twhile i < n do\n\t\tnum = num..\"0b\"\n\t\ti = i + 1\n\tend\n\treturn num\n\
    end", "  local count = 0\n  local avg = 0", "  if m < n then\n    return -1\n\
    \  end\n  local result = \"\"\n  local count = 0\n  for i = n, m do\n    count\
    \ = count + 1\n    result = result .. math.floor(i/2) + math.mod(i, 2)\n  end\n\
    \  if count < 8 then\n    result = \"0b\"\n  end\n  return result .. math.ceil(count/8)\n\
    end", "    if n > m then\n        return -1\n    end\n    local str = \"\"\n \
    \   for i = 1, n do\n        str = str .. \"1\"\n    end\n    for i = m, n+1 do\n\
    \        str = str .. \"0\"\n    end\n    local x = str:reverse()\n    local re\
    \ = \"\"\n    for i = 1, #x do\n        re. = #x\n    end\n    return re:reverse()\n\
    end", "  -- TODO: implement me\nend", "\tlocal s = math.abs(n) - math.abs(m)\n\
    \ts = s + 1 if s > 0 else s\n\ts = s << 1\n\treturn s\nend", "  if n > m then\n\
    \    return -1\n  end", '  if n < m then return -1 end', "\tif m == 0 then\n\t\
    \treturn \"0b0\"\n\tend", "  local bins = string_format(\"%0*b\", [\"m\", bin(m+n-1)])\n\
    \  local result = bins:gsub(\"%d%d*\", \"%1\")\n  if #result > 0 then\n    return\
    \ bin\n  end\n  return -1\nend", "  if m == 0 then\n    return -1\n  end", " \
    \ n = tonumber(n)\n  m = tonumber(m)\n  if n > m then\n    return -1\n  end\n\
    \  local sum = 0\n  local n = n\n  while m ~= 0 do\n    sum = sum + m\n    n =\
    \ n - 1\n    m = m - 1\n  end\n  return format(\"%b\", sum / n)\nend", "  if n\
    \ < m then return -1 end\n  local avg = ((m * 2) / 2) + n\n  return bit.lshift(bit.rshift(avg,\
    \ 16), 4) -- 0b111111\nend\n</cell>\n<code language=xeus-cling-cpp14>\nprint(rounded_avg(1,\
    \ 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20,\
    \ 33))\n</cell>\n<code language=xeus-cling-cpp14>", "    local sum = 0\n    local\
    \ avg = 0.0\n    for i=n, m-1 do\n        sum = sum + i\n        avg = sum / m\n\
    \    end\n    if n > m then\n        return -1\n    end\n    avg = (avg - math.floor(avg))\n\
    \    local bin = (avg - math.floor(avg)) * 10\n    bin = math.floor(bin)\n   \
    \ bin = bin:band(10)\n    return bin\nend", "\tlocal nn = n + m\n\tlocal mn =\
    \ math.floor(nn)\n\tlocal um = math.floor((n - mn) * 2)\n\t\n\tif um > 0 then\n\
    \t\treturn \"0b\" .. bin(um)\n\telse\n\t\treturn \"-1\"\n\tend\nend", "   if m\
    \ < n then\n      return -1\n   end\n   local count = 0\n   for i=n, m+1, 1 do\n\
    \      count = count + i\n   end\n   count = count / 2\n   return tostring(count)\n\
    end", "  local n1, m1 = n, m\n  local x = n1 - (m1 + 1) / 2\n  if x > m1 then\n\
    \    return -1\n  end\n  local n2 = n - m1\n  local m2 = m - n1\n  local t = n2\
    \ * m2 - n1\n  if t >= 0 then\n    return m * t + n1\n  else\n    return -1\n\
    \  end\nend", "    local a = math.ceil(n / m) * m\n    local b = n % m\n    return\
    \ format( a .. \"b\" , b )\nend", "  assert(n >= m, \"n must be greater than m.\"\
    )\n  if n <= m then\n    return math.floor((n + m) / 2)\n  else\n    return -1\n\
    \  end\nend", "    if n > m then return -1 end\n    local s = 10^(math.log10(m/2-1)\
    \ + 1)\n    local t = n/s\n    local result = (t - t%2)*s\n    if result < m then\
    \ return result end\n    return m\nend", "\tlocal nn = math.min(n, m)\n\tlocal\
    \ mm = math.max(m, n)\n\tlocal n_tok = math.floor nn\n\tlocal m_tok = math.ceil\
    \ mm\n\tlocal res = n_tok .. m_tok\n\tlocal bin = res:band(0)\n\tlocal bin1 =\
    \ bin:band(#bin)\n\treturn bin1:bit()\nend", "  if m > n then return -1 end\n\
    \  local digits = math.max(math.floor((m - n) / 2), 0)\n  return string.format('%b',\
    \ math.floor(n/digits)) .. string.format('%b', n - n*digits - digits)\nend", " \
    \   local bin = {}\n    for i = 1, n do\n        table.insert(bin, math.floor(i\
    \ / m)*m + (i % m))\n    end\n    if n <= m then return -1 end\n    return table.concat(bin)\n\
    end\nassert(rounded_avg(1, 5) == \"0b11\", \"case 1\")\nassert(rounded_avg(7,\
    \ 5) == -1, \"case 2\")\nassert(rounded_avg(10, 20) == \"0b1111\", \"case 3\"\
    )\nassert(rounded_avg(20, 33) == \"0b11010\", \"case 4\")\n</cell>\n<text>\nExercise\
    \ 4\nThe following function implements the Fibonacci sequence using an array\n\
    The function takes an integer as an input and stores the result in an array as\
    \ you go through\nthe sequence\nThe function returns the number stored in the\
    \ array\nThe Fibonacci sequence is defined by the following relation:\n    fib(i)\
    \ = ( fib(i-1) + fib(i-2) ) / 2", "    local n = tonumber(n)\n    local m = tonumber(m)\n\
    \    if n < m then\n        return m\n    end\n    if n == m then\n        return\
    \ n\n    end\n    if n > m then\n        return -1\n    end\n    local n = math.abs(n)\
    \ \n    local m = math.abs(m)\n    local a = tonumber(\"0b\"..string.rep(\"1\"\
    ,(n+m-1)*2))\n    local b = tonumber(\"0b\"..string.rep(\"1\",(m+n-1)*2))\n  \
    \  return string.format(\"%0*b%s\", n+1, a, b) \nend\nprint(rounded_avg(1, 5))\
    \ -- 0b11\nprint(rounded_avg(7, 5)) -- -1\nprint(rounded_avg(10, 20)) -- 0b1111\n\
    print(rounded_avg(20, 33)) -- 0b11010\nprint(rounded_avg(22, 99)) -- -1\nprint(rounded_avg(100,\
    \ 3)) -- -1", "  n = tonumber(n)\n  m = tonumber(m)\n  if n == m then\n    return\
    \ tonumber(string.format(\"%b\", n))\n  end\n  -- If n is greater than m, return\
    \ -1.\n  if n > m then\n    return -1\n  end\n  local s = 0.0\n  local i = 1\n\
    \  repeat\n    s = s + i\n    i = i + 1\n  until (n % i == 0) and (n /= i)\n \
    \ return tonumber(string.format(\"%b\", s)) * power(2, #s - 1)\nend", "   if n\
    \ < m then\n      return -1\n   end\n   return \"0b\" .. tonumber( string.format(\"\
    %x\", string.sub(\"%x\", string.sub(\"%x\", string.sub(\"%x\", math.ceil(m/2)..n,\
    \ math.ceil(m/2)..m, m, 1), 1, math.floor(m/2)-1)), 16, 2))\nend", "    local\
    \ sum = 0\n    for _ = n, m do\n        sum = sum + _\n    end\n    return sum\
    \ / 2\nend", "    if m > n then return -1 end\n    \n    if m <= 1 then return\
    \ n end", "   -- Your code here\n   return \"0b\" .. tostring(string.char(n %\
    \ 2^m + n/2^m))\nend", '  if n < m then return -1 end', "  -- If the number is\
    \ between 0 and m, return that number. Otherwise,\n  -- return the average of\
    \ n and m.\n  if m <= n then\n    return n\n  end\n  return m / (n - m) * 10\n\
    end", "    if n <= m then\n        return math.floor(n / m) * m \n    else\n \
    \       return -1\n    end\nend\n</cell>\n<text>\nProblem 7", "  return math.floor(n\
    \ / (m + 1.0))\nend", "    local n = math.floor(n)\n    local m = math.floor(m)\n\
    \    local avg = m * (m + 1) / 2\n    local one = math.floor(math.pow(10, math.ceil(math.log(avg)\
    \ / math.log(10))))\n    return ((n / m) * one)\nend", "  -- If n is greater than\
    \ m, return -1.\n  if n > m then return -1 end", "\t-- TODO: implement the solution\n\
    end", "  if m == nil then return -1\n  else if n == m then return \"0b0\" else\
    \ return \"0b\" .. math.floor((n - m) / 2) end\nend\nprint(rounded_avg(1,5))\n\
    print(rounded_avg(7,5))\nprint(rounded_avg(10,20))\nprint(rounded_avg(20,33))\n\
    print(rounded_avg(12,15))\nprint(rounded_avg(12,-1))\nprint(rounded_avg(12,99))\n\
    print(rounded_avg(12,10))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,10))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(rounded_avg(12,20))\nprint(rounded_avg(12,20))\n\
    print(rounded_avg(12,20))\nprint(roun", "\tlocal n = tonumber(n)\n\tlocal m =\
    \ tonumber(m)\n\t\n\tif (n > m) then\n\t\treturn(-1)\n\tend\n\t\n\tlocal n1 =\
    \ math.floor(n)\n\tlocal n2 = math.ceil(n)\n\t\n\tlocal m1 = math.floor(m)\n\t\
    local m2 = math.ceil(m)\n\t\n\tlocal n1 = tonumber(string.format('%0d', n1))\n\
    \tlocal n2 = tonumber(string.format('%0d', n2))\n\t\n\tlocal m1 = tonumber(string.format('%0d',\
    \ m1))\n\tlocal m2 = tonumber(string.format('%0d', m2))\n\t\n\tlocal sum = (n2-n1)*(m2\
    \ - m1)\n\t\n\treturn (string.format(\"0b%.2x%.2x\", n1, sum))\nend", "  local\
    \ sum = 0\n  local i = m\n  while i <= n do\n    sum = sum + i\n    i = i + 1\n\
    \  end\n  if sum > n then\n    return -1\n  end\n  local n = math.floor(sum /\
    \ 2)\n  local result = bin(n) + bin(n + 1)\n  -- Remove \"0b\" prefix\n  result\
    \ = string.gsub(result, \",0,1\", \"\")\n  return result\nend", "    if n > m\
    \ then\n        return -1\n    end\n    return bit.rshift(bit.bor(bit.band(m,\
    \ bit.rshift(n-1, 1)), bit.rshift(n, 1)), -1)\nend", "\tlocal sum = 0\n\tlocal\
    \ count = 0\n\tfor i = n, m do \n\t\tsum = sum + i \n\t\tcount = count + 1\n\t\
    end\n\tlocal avg\n\tif sum > m then\n\t\tavg = '-1'\n\telse\n\t\tavg = string.format('%010b',\
    \ sum / count)\n\tend\n\treturn avg \nend", "    if n >= m then return -1 end\n\
    \    local count = 0\n    local s = 0\n    for i = n, m do\n        s = s + i\n\
    \        count = count + 1\n    end\n    return tonumber(string.format('%b', s/count)[2:])\n\
    end", "  if n == m then\n    return nil\n  end\n  local avg = 0\n  local cnt =\
    \ 0\n  for i = n, m-1, -1 do\n    cnt = cnt + 1\n    avg = avg + i\n  end\n  if\
    \ cnt % 2 == 0 then\n    avg = (avg / 2) \n  else\n    avg = avg / 2\n  end\n\
    \  return \"0x\" .. string.gsub(tostring(avg), \"0*$\", \"\") \nend\nprint(rounded_avg(1,\
    \ 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20,\
    \ 33))\nprint(rounded_avg(33, 100))\nprint(rounded_avg(100, 10000))\nprint(rounded_avg(10000,\
    \ 100000))", "   if n == m then\n      -- Avoid division by zero\n      if n <\
    \ 1 then return \"0b\" .. \"0\" .. \"1\" end\n      -- Round up\n      local mult\
    \ = 1\n      local sum = 0\n      local i = 1\n      while i <= n do\n       \
    \  if i % 2 == 1 then\n            sum = sum + i * mult\n         end\n      \
    \   mult = mult*10\n         i = i * 10 + 1\n      end\n      return \"0b\" ..\
    \ \"0\" .. \"1\" .. \"0\" .. sum .. \"0\"\n   elseif n < m then\n      -- Round\
    \ down\n      return rounded_avg(m, n)\n   else\n      -- Round up\n      return\
    \ \"0b\" .. \"0\" .. \"1\" .. \"0\" .. m * 10 .. \"0\"\n   end\nend", "  if m\
    \ < n then return -1\n  else return tostring(bit.band(n, n-m)) + tostring(bit.band(m-n,\
    \ m-n)) / 2\n  end\nend", "  local nstr, mstr\n  local nn, mm\n  if n < m then\n\
    \    nstr = string.format(\"%b\", n)\n    mstr = string.format(\"%b\", m)\n  \
    \  nn = (tonumber(nstr))\n    mm = (tonumber(mstr))\n    if nn == nil or mm ==\
    \ nil then\n      ngx.log(ngx.ERR, \"cannot convert %b to number\", nstr)\n  \
    \    return nil\n    end\n    local retbin\n    local retbinstr\n    local sum\
    \ = 0\n    local sumbin = 0\n    local nstrlen = #nstr\n    local mstrlen = #mstr\n\
    \    for i = 1, nstrlen do\n      sum = sum + tonumber(string.format(\"%b\", sumbin))\n\
    \      sumbin = sumbin + nstrlen - i - 1\n    end\n    for i = 1, mstrlen do\n\
    \      sum = sum + tonumber(string.format(\"%b\", sumbin))\n      sumbin = sumbin\
    \ + mstrlen - i - 1\n    end\n    sumbin = sumbin + mstrlen - 1 - 1\n    if sumbin\
    \ < 1 then\n      return nil\n    end\n    retbin = string.format(\"%b\", sum)\n\
    \    retbinstr = string.format(\"%b\", sum)\n    for i = 1, mstrlen do\n     \
    \ retbin = retbin .. string.format(\"%b\", sumbin - i - 1)\n    end\n    retbinstr\
    \ = retbin .. retbinstr\n    return retbinstr\n  else\n    ngx.log(ngx.ERR, \"\
    wrong parameters\")\n    return nil\n  end\nend", "   if m > n then return -1\
    \ end\n   if m == n then\n      return \"0b\" .. tostring(n)\n   else\n      local\
    \ mid = math.floor(n / 2)\n      local high = rounded_avg(mid, m) \n      if high\
    \ == -1 then\n         high = m + 1\n      end\n      local low = rounded_avg(mid,\
    \ m) \n      if low == -1 then\n         low = m - 1\n      end\n      return\
    \ \"0b\" .. tostring(low) .. high .. tostring(n - mid)\n   end\nend\n</cell>\n\
    <text>\nExercise 4\nWrite a function called bits_set which takes a number and\
    \ returns the number of binary digits of that number which are set.", "  n = tonumber(n)\n\
    \  m = tonumber(m)\n  if n > m then\n    return -1\n  end\n  local bin, i = 1,\
    \ 0\n  repeat\n    bin = std.int2bit(round(n/m), i) + 1\n    n = n - bin*m\n \
    \   i = i + 1\n  until n < 1\n  bin = std.int2bit(round(n/bin), i) + bin\n  return\
    \ bin\nend", "    if m == nil then\n        return -1\n    end\n    if n == m\
    \ then\n        return math.floor(m) + 1\n    end", "\t-- Write your code below\
    \ this line\n\tlocal bin = string.rep(\"0\", n+m)\n\tbin = bin:gsub(\"%.\", \"\
    \")\n\treturn bin\nend", "    assert(n > 0 and m > 0 and n <= m, \n          \
    \  \"n (%d) is greater than m (%d)\")\n    if n > m then\n        return -1\n\
    \    end\n    local sum = 0\n    local i\n    local s = math.ceil(n / 2)\n   \
    \ for i = s, m, 1 do\n        sum = sum + i\n    end\n    return tostring(sum)\n\
    end", "  if m > n then\n    return -1\n  else\n    local sum = 0\n    local digit\
    \ = 0\n    while n <= m do\n      sum = sum + n\n      n = n + 1\n    end\n  \
    \  digit = sum / 2\n    return math.floor(tonumber(bin(digit, 2)) + 0.5)\n  end\n\
    end", "    local res = 0\n    local div = math.floor(n/m)\n    if div > 0 then\n\
    \        res = div * m\n    else \n        local mod = n % m\n        local remain\
    \ = n - mod\n        rem = math.floor(math.floor(remain / m) * m)\n        res\
    \ = res + rem\n    end \n    return res\nend\nprint(rounded_avg(6, 10))\nprint(rounded_avg(6,\
    \ 1))", "   local s, t, s = n, m, 0\n   while t < m do\n      s = s + 1\n    \
    \  t = t + 1\n   end\n   if s < m then\n      return -1\n   else\n      s = math.floor(s\
    \ / 2)\n      t = math.floor(t / 2)\n      s = (s * (m - t) + n) / (t - s)\n \
    \     s = string.char(math.floor(s / 2))\n      t = string.char(math.floor(t /\
    \ 2))\n      return string.sub(s, 1, math.min(#s, #t) + 1)\n   end\nend\nprint(rounded_avg(1,\
    \ 5)) -- 0b11\nprint(rounded_avg(7, 5)) -- -1\nprint(rounded_avg(10, 20)) -- 0b1111\n\
    print(rounded_avg(20, 33)) -- 0b11010\nprint(rounded_avg(100, 31)) -- 0b11111\n\
    print(rounded_avg(50, 25)) -- 0b111100\nprint(rounded_avg(50, 5)) -- 0b111101\n\
    print(rounded_avg(50, 15)) -- 0b1111001\nprint(rounded_avg(50, 75)) -- 0b11110001111\n\
    print(rounded_avg(50, 50)) -- 0b1111100\nprint(rounded_avg(50, 25)) -- 0b111100\n\
    print(rounded_avg(100, 75)) -- 0b11111001111\nprint(rounded_avg(50, 55)) -- 0b11111010\n\
    print(rounded_avg(50, 25)) -- 0b111100\nprint(rounded_avg(100, 75)) -- 0b11111001111\n\
    print(rounded_avg(50, 55)) -- 0b11111010\nprint(rounded_avg(50, 25)) -- 0b111100\n\
    print(rounded_avg(100, 75)) -- 0b11111001111\nprint(rounded_avg(50, 55)) -- 0b11111010\n\
    print(rounded_avg(50, 25)) -- 0b111100\nprint(rounded_avg(100, 75)) -- 0b11111001111\n\
    print(rounded_avg(50, 55)) -- 0b11111010\nprint(rounded_avg(50, 25)) -- 0b111100\n\
    print(rounded_avg(100, 75)) -- 0b11111001111\nprint(rounded_avg(50, 55)) -- 0b11111010\n\
    print(rounded_avg(50, 25)) -- 0b111100\nprint(rounded_avg(100, 75)) -- 0b11111001111\n\
    print(rounded_avg(50, 55)) -- 0b11111010\nprint(rounded_avg(50, 25)) -- 0b111100\n\
    print(rounded_avg(100, 75)) -- 0b11111001111\nprint(rounded_avg(50, 55)) -- 0b11111010",
  "  return math.floor(n / m) * m or -1\nend", "  local avg_n = 0\n  local avg_m =\
    \ 0\n  local num = 0", "  -- The average of n through m is (n + m) / 2.\n  return\
    \ (n + m) / 2\nend\n</code>\n<code>", "    return tostring(string.format(\"%b\"\
    , ((m + 1) / (n + 1))))\nend\n</code>\n<|/ a tags=math,binary,lua |>\n<| a dscore=0\
    \ |>\n<code>", "\tlocal result = math.floor(n / m) * m\n\tif n > m then\n\t\t\
    result = -1\n\tend\n\t\n\tlocal resultBin = result:byte()\n\tlocal length = math.floor(string.len(resultBin)\
    \ / 2)\n\tlocal resultBinLeft = \"\"\n\tlocal resultBinRight = \"\"\n\tfor i =\
    \ 1, length do\n\t\tresultBinLeft = string.sub(resultBin, i*2, i*2+1) .. resultBinLeft\n\
    \t\tresultBinRight = string.sub(resultBin, i*2+1, i*2+2) .. resultBinRight\n\t\
    end\n\t\n\treturn resultBinLeft..resultBinRight\nend", "   if n >= m then return\
    \ -1 end\n   local s = \"\"\n   for i = 1, n do\n      s = s .. \"1\"\n   end\n\
    \   local c = 0\n   for i = m + 1, n do\n      s = s .. \"0\"\n      c = (c +\
    \ 1)\n      if c == 2 then\n         s = s .. \"1\"\n         c = 0\n      end\n\
    \   end\n   return s .. '0'\nend", "  if m == nil then \n    m = 0 \n  end\n \
    \ if n == m then\n    return tostring(n & 'b')\n  end\n  local n = n or 0\n  local\
    \ m = m or 0\n  if n > m then\n    return -1\n  end\n  local i = n - 1\n  local\
    \ j = 1\n  local total = 0\n  while i ~= m do\n    total = total + i\n    i =\
    \ i + 1\n    j = j + 1\n  end\n  total = total / j\n  return tostring(total &\
    \ 'b')\nend", "  return tonumber(string.format(\"%b\", round_to_binary(n, m)))\
    \ or -1\nend", "    local round = math.floor\n    local res = 0\n    repeat\n\
    \        local diff = n - m\n        res, m = m + round(diff/2), n - diff\n  \
    \      -- print('n is ' .. n .. ' m is ' .. m)\n    until n < m\n    return res\n\
    end", "   if n > m then\n      return -1\n   end\n   \n   local sum = 0\n   for\
    \ i = n, m do\n      sum = sum + i\n   end\n   \n   return sum / 2\nend", "  if\
    \ m > n then\n    return -1\n  end\n  local result = \"0b\" .. math.floor((n -\
    \ m) / 2) + math.floor((m / 2))\n  return result .. \"0\"\nend\n</cell>\n<code\
    \ language=julia-1.0>\n@time rounded_avg(1_000_000, 1_000_000)\n</cell>\n<code\
    \ language=julia-1.0>\n@time rounded_avg(1_000_000, 1_000_001)\n</cell>\n<code\
    \ language=julia-1.0>\n@time rounded_avg(1_000_000, 1_000_000)\n</cell>\n<code\
    \ language=julia-1.0>", "   if m >= n then return -1 end\n   local a = n + (m\
    \ - n) / 2\n   if a > m then a = m end\n   local b = 1\n   while a > 0 do\n  \
    \    b = b * 10\n      a = a - b + 1\n   end\n   return b\nend\n   ", "  if m\
    \ < n then\n    return -1\n  end", "\tlocal s = #n - (#n - m + 1)\n\tif s <= 0\
    \ then\n\t\treturn nil\n\tend\n\treturn (\"%b\"):format(math.floor(((n + m - 1):round()\
    \ / s) * s))\nend", "  if n <= m then\n    return \"0b\" .. math.floor((n+m-1)/2)*2\n\
    \  end\n  return -1\nend", "   local sum = 0\n   for i = n, m do sum = sum + i\
    \ end\n   if sum > m then return -1 end\n   return \"0b\" .. tostring(sum / 2)\n\
    end", "    if n > m then\n        return -1\n    end\n    local sum = 0\n    for\
    \ i = n, m do\n        sum = sum + i\n    end\n    \n    -- Round the result of\
    \ the sum.\n    local rounded_sum = math.floor(sum/2) + 1\n    \n    -- Convert\
    \ the result of the sum to binary.\n    local bin = string.format(\"0b%x\", rounded_sum)\n\
    \    \n    return bin\nend", "\tlocal s = n\n\tlocal i\n\twhile s ~= m do\n\t\t\
    i = s\n\t\ts = s + 1\n\tend\n\treturn s\nend", "  if n <= m then\n    local s\
    \ = \"\"\n    for i = n, m, 1 do\n      s = s .. string.format(\"%d\", 1)\n  \
    \  end\n    return s\n  else\n    return -1\n  end\nend\n</cell>\n<code language=julia-1.5>\n\
    round(avg(8, 9))\n</cell>\n<code language=julia-1.5>\nround(avg(8, 9), 2)\n</cell>\n\
    <code language=julia-1.5>\nround(avg(8, 9), digits=2)\n</cell>\n<text>\nBinary\
    \ Arithmetic", "    local avg = ((n or 1) - 1) / 2 + ((m or 1) - 1) / 2 + 1\n\
    \    return string.format(\"%b\", avg)\nend", "    local num_digits = math.max(math.max(m,\
    \ n)-math.min(n, m), 0, 0)\n    local digits = {}\n    \n    for i = 1, num_digits\
    \ do\n        table.insert(digits, '0')\n    end\n    \n    if num_digits == 1\
    \ then\n        table.insert(digits, 0)\n    end\n    \n    -- Handle negative\
    \ numbers.\n    if m <= 0 then\n        table.insert(digits, -1)\n        m =\
    \ -m + 1\n    end\n    \n    if n <= m then\n        table.insert(digits, 1)\n\
    \        return table.concat(digits)\n    end\n    \n    -- Handle the case of\
    \ just one number.\n    if n == m then\n        table.insert(digits, 0)\n    \
    \    return table.concat(digits)\n    end\n    \n    -- Handle a case where we\
    \ round up, where n is greater than m.\n    if num_digits == 0 then\n        local\
    \ r = math.ceil(n/m) + 1\n        local digit, num = r, m\n        while num >\
    \ 0 do\n            table.insert(digits, digit)\n            -- Remove any remaining\
    \ digits that could have gone into n.\n            local remaining = math.floor(num/10)\n\
    \            num = num - remaining * 10\n            digit = remaining + 1\n \
    \       end\n        \n        -- Add -1 to the end to signify rounding to an\
    \ odd number.\n        table.insert(digits, -1)\n        \n        return table.concat(digits)\n\
    \    end\n    \n    -- Otherwise, perform the rounding.\n    local r = math.ceil(n/m)\
    \ + 1\n    \n    -- Add digits to digits.\n    while r > 1 do\n        local digit,\
    \ num = r, m\n        while num > 0 do\n            table.insert(digits, digit)\n\
    \            -- Remove any remaining digits that could have gone into n.\n   \
    \         local remaining = math.floor(num/10)\n            num = num - remaining\
    \ * 10\n            digit = remaining + 1\n        end\n        \n        -- Add\
    \ -1 to the end to signify rounding to an odd number.\n        table.insert(digits,\
    \ -1)\n        \n        r = r - 1\n    end\n    \n    -- Add any remaining digits\
    \ that didn't fit into n.\n    local remaining = math.floor(n/10)\n    table.insert(digits,\
    \ remaining)\n    \n    return table.concat(digits)\nend", "  if n > m then\n\
    \    return -1\n  elseif n < m then\n    return -1\n  else\n    return math.floor(m/2)\
    \ + (n-m)/2\n  end\nend", "  n = tonumber(n)\n  m = tonumber(m)\n  if n > m then\n\
    \    return -1\n  end\n  \n  local n1 = m\n  local n2 = n\n  local m = n1 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2\
    \ \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\ (n2 \\", "  -- Write your code here!\n\
    \  return nil\nend", "    local n1 = math.min(n, m)\n    local n2 = math.max(m,\
    \ n)\n    local n3 = n2 - n1\n    local m = n1 - 1\n    return tostring(n1 - (n3\
    \ % n2)) * '0' + tostring(n3 % n2)\nend\n</cell>\n<text>\nThe function rounded_avg()\
    \ takes two integers as arguments, one for n, the other for m. It then computes\
    \ the average of the integers from n through m. It rounds the result to the nearest\
    \ integer and converts that to binary. If the integer value of n is greater than\
    \ m, it returns -1; otherwise, it returns the average of the integers from n through\
    \ m.", "    if n <= m then return -1\n    else return (n >> 1) + 1\n    end\n\
    end", "  -- Initialize our return value with -1 to signify we haven't yet seen\
    \ the \n  -- first m numbers.\n  if m == 0 then return -1 end", "  if n > m then\n\
    \    return -1\n  end", "  n = math.floor(n) \n  m = math.floor(m)\n  if n <=\
    \ m then\n    return math.mod(n+m, 2)\n  else\n    return -1\n  end\nend", " \
    \ local avg = math.floor(m/2) or -1\n  if n < m then\n    return math.floor(avg\
    \ + (n/2) or -1)\n  else\n    return -1\n  end\nend", "  local avg = 0.0\n  local\
    \ i = 0\n  while i <= n and i <= m do\n    avg = (avg + i) / 2.0\n    i = i +\
    \ 1\n  end\n  if i < n then\n    return -1\n  else\n    return string.format(\"\
    0b%.2X\", avg)\n  end\nend", "    -- Add one to n to handle case when n is 0 or\
    \ negative\n    n = n + 1", "  if n == m then\n    return \"0b0\"\n  end\n  if\
    \ m > n then\n    return -1\n  end\n  local avg = (n - m) / 2\n  local bits =\
    \ string.gsub(format(\"%0*d\", math.ceil(math.log2(avg)), avg), \"%d\", \".\"\
    )\n  return string.sub(bits, -2)\nend", "  local result = nil\n  if m > n then\n\
    \    local n2 = n + 1\n    local m2 = m + 1\n    result = \"0b\" .. string.format(\"\
    %b\", tonumber(string.format(\"%x\", tonumber(bin(n)) .. bin(m))) * tonumber(string.format(\"\
    %x\", tonumber(bin(n2))) * tonumber(bin(m2))) / tonumber(string.format(\"%x\"\
    , tonumber(bin(n))) * tonumber(bin(m2))))\n  else\n    result = \"0b\" .. string.format(\"\
    %b\", tonumber(string.format(\"%x\", tonumber(bin(n)) .. bin(m)) * tonumber(string.format(\"\
    %x\", tonumber(bin(n)))))\n  end\n  return result\nend", "  if n > m then return\
    \ -1 end\n  local avg = 0\n  for i = n, m-1 do\n    avg = avg + i\n  end\n  avg\
    \ = avg / (m - n)\n  avg = math.floor(avg * 2) / 2\n  return tostring(avg)\nend\n\
    </cell>\n<text>\nLet's test our implementation:", "  if m >= n then\n    return\
    \ -1\n  end\n  local average = (n + m) / 2.0\n  return tonumber(string.format(\"\
    %.1f\", average))\nend", "  local ret\n  n = math.floor(n)\n  m = math.floor(m)\n\
    \  ret = n .. m .. 0\n  ret = ret:gsub(\"(%d%d%d)%d%d%d\", \"%2$b%2$d%2$b%2$d\"\
    )\n  return ret\nend", "  local sum = 0\n  for i = n, m + 1 do sum = sum + i end\n\
    \  local average = sum / 2\n  if average < 0 then\n    return -1\n  end\n  local\
    \ res = 0\n  local pos = 1\n  while pos < average do\n    res = res .. \"1\"\n\
    \    pos = pos + 1\n  end\n  return res\nend", "  if n == m then\n    return n\n\
    \  end", "  if n > m then\n    return -1\n  end", "    local n2 = math.min(n,\
    \ m)\n    local n1 = math.max(n, m)\n    return math.floor(n1 + n2 / 2) * '1'\
    \ + math.floor(n1 / 2) * '0'\nend", "    local count=1\n    local sum=0\n    for\
    \ i=n,m-1 do\n        sum=sum+i\n        count=count+1\n    end\n    if count==0\
    \ then\n        return -1\n    else\n        return tostring(sum/count)\n    end\n\
    end", "  if m < n then return -1 end\n  local nm = tostring(n - m), nm = string.match(nm,\
    \ \".\");\n  if nm == nil then return -1 end\n  return \"0b\" .. math.floor(math.log2(n)\
    \ + 1) .. nm\nend", "   if m > n then\n      return -1\n   end\n   local one =\
    \ math.floor(n/m)\n   local two = math.modf(n/m * 2)\n   if two > 0 then\n   \
    \   local t = one * two\n      two = math.floor(t / 2)\n      one = t - two\n\
    \   end\n   return one:bit(math.max(2,math.ceil(math.log(two,2))+1))\nend", " \
    \ if n <= m then\n    return n and (\"0b\" .. math.floor((n - 1) / 2) + math.floor((n\
    \ - 1) % 2))\n  else\n    return -1\n  end\nend", "  if n <= m then\n    return\
    \ \"0b\" .. math.floor((math.floor(n / 2) + math.floor(m / 2)) / 2)\n  end\n \
    \ return -1\nend", "  -- The sum of m and n is m plus n. Divide that by two: m\
    \ / 2.\n  -- Add n: n to that number: n + (m / 2). \n  -- Divide that by two:\
    \ n / 2.\n  -- Add m: m to that number: n + (m / 2) + (m / 2). \n  -- Round down.\
    \ \n  return math.floor(n + (m / 2) + (m / 2) / 2)\nend", "    local result =\
    \ -1\n    if (n > m) then\n        result = -1\n    else\n        local num =\
    \ 0\n        for i = n, m do\n            num = num + math.floor(i) / 2\n    \
    \    end\n        result = \"0b\" .. tonumber(num)\n    end\n    return result\n\
    end", "    return math.floor( (n + m)/2 )\n    and string.format(\"%b\", rounded_avg(n,\
    \ m))\nend", "  local avg_str = '0b00000000000000'\n  local n = tonumber(n)\n\
    \  local m = tonumber(m)\n  if n < m then\n    local sum = 0\n    for i = n, m\
    \ do\n      sum = sum + i\n      avg_str = avg_str .. i\n    end\n    local avg\
    \ = sum / 2\n    if n <= m then\n      return tostring(round(avg))\n    else\n\
    \      return -1\n    end\n  else\n    return -1\n  end\nend", "\tlocal num =\
    \ 0\n\twhile n > m do\n\t\tn = n - m\n\t\tnum = num + 1\n\tend\n\treturn \"0b\"\
    \ .. (math.floor(n / num)) * num\nend", "  if m == 0 then\n    return \"0b0\"\
    \ .. tostring(m)\n  else\n    if n < m then\n      return -1\n    end\n    local\
    \ sum = 0\n    local count = 0\n    for i = n, m do\n      sum = sum + i\n   \
    \   count = count + 1\n    end\n    return \"0b\" .. tostring(sum / count)\n \
    \ end\nend", "    local average = 0;\n    local i = 1;\n    local sum = 0;\n \
    \   while i <= n do\n        sum = sum + i;\n        i = i + 1;\n    end\n   \
    \ average = sum / n;\n    local binary = tostring(average);\n    return binary;\n\
    end", "\tlocal n = n or 1\n\tlocal m = m or 1\n\tlocal result = -1\n\tlocal n\
    \ = math.floor(n)\n\tlocal m = math.floor(m)\n\twhile m > n do\n\t\tm = m - 1\n\
    \t\tresult = result + 1\n\tend\n\tif n == m then\n\t\tresult = result + 1\n\t\
    end\n\treturn tostring(result)\nend", "  if n > m then\n    return -1\n  end\n\
    \  local avg = ((n+m)/2)\n  return bit.rshift(tostring(avg), -string.len(tostring(avg))+2)\n\
    end", "    return math.floor(n + (m and math.floor(m))/2) * '1';\nend\n</cell>\n\
    <cell>\nrounded_avg(1, 5)\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\n\
    rounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nWrite\
    \ a program to count how many times a value appears in a list:", "  if n > m then\
    \ return -1 end\n  return math.floor(n + (m and m - 1) / 2.0 * 0.5)\nend", " \
    \  if n == m then\n      print(\"Error! Both n and m can't be equal to n!\")\n\
    \   end\n   if n < m then\n      print(\"Error! n is greater than m!\")\n   end\n\
    \   if n % 2 == 0 then\n      return -1\n   end\n   if m % 2 == 0 then\n     \
    \ return -1\n   end\n   local num1 = math.floor(n)\n   local num2 = math.floor(m)\n\
    \   if num1 == num2 then\n      return bin(round(num1/2))\n   end\n   return bin(round(num1/2))\
    \ + bin(round(num2/2)) \nend\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\n\
    print(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\nprint(rounded_avg(100,\
    \ 1000))\nprint(rounded_avg(101, 1000))\nprint(rounded_avg(102, 1000))\nprint(rounded_avg(103,\
    \ 1000))\nprint(rounded_avg(104, 1000))\nprint(rounded_avg(105, 1000))\nprint(rounded_avg(106,\
    \ 1000))\nprint(rounded_avg(107, 1000))\nprint(rounded_avg(108, 1000))\nprint(rounded_avg(109,\
    \ 1000))\nprint(rounded_avg(110, 1000))\nprint(rounded_avg(111, 1000))\nprint(rounded_avg(112,\
    \ 1000))\nprint(rounded_avg(113, 1000))\nprint(rounded_avg(114, 1000))\nprint(rounded_avg(115,\
    \ 1000))\nprint(rounded_avg(116, 1000))\nprint(rounded_avg(117, 1000))\nprint(rounded_avg(118,\
    \ 1000))\nprint(rounded_avg(119, 1000))\nprint(rounded_avg(120, 1000))\nprint(rounded_avg(121,\
    \ 1000))\nprint(rounded_avg(122, 1000))\nprint(rounded_avg(123, 1000))\nprint(rounded_avg(124,\
    \ 1000))\nprint(rounded_avg(125, 1000))\nprint(rounded_avg(126, 1000))\nprint(rounded_avg(127,\
    \ 1000))\nprint(rounded_avg(128, 1000))\nprint(rounded_avg(129, 1000))\nprint(rounded_avg(130,\
    \ 1000))\nprint(rounded_avg(131, 1000))\nprint(rounded_avg(132, 1000))\nprint(rounded_avg(133,\
    \ 1000))\nprint(rounded_avg(134, 1000))\nprint(rounded_avg(135, 1000))\nprint(rounded_avg(13",
  "\tif m < n then return -1 end\n\t\n\tlocal sum = (n + m) / 2\n\tlocal avg = sum\
    \ * 8\n\tlocal remainder, bin = math.modf(avg)\n\t\n\t-- If the remainder is not\
    \ an integer, return the original sum\n\t-- This can happen when sum is odd, which\
    \ would make avg * 8 not\n\t-- an integer.\n\tif remainder ~= 0.0 then\n\t\tlocal\
    \ num = sum - remainder\n\t\tlocal power = math.floor(math.log(num, 2) + 1)\n\t\
    \tlocal bin = bin:reverse():sub(1, power - 1):reverse()\n\t\tbin = bin:reverse():sub(1,\
    \ #bin):reverse()\n\t\t\n\t\treturn tostring(bin)\n\tend\n\t\n\treturn tostring(bin)\n\
    end", "  if m > n then\n    return -1\n  end", "  local r = 0\n  local i = n\n\
    \  while i <= m do\n    r = r + math.floor(i / 2)\n    i = math.floor(math.pow(2,\
    \ math.log2(i)) - math.log2(r))\n  end\n  return r\nend", "  return math.floor((n\
    \ + m) / 2)\nend", "  local avg = 0.0\n  local nm = n + m\n  while nm > 0 do\n\
    \    avg = avg + n / nm\n    local nm = nm - 1\n  end\n  avg = avg + m / nm\n\
    \  avg = math.round(avg)\n  return tostring(avg * 2)\nend", "    -- Write your\
    \ code here.\n    if n == m then\n        return tostring(2^n)\n    elseif n >\
    \ m then\n        return -1\n    end\n    local avg = (2^n - 1)/(2^m - 1)\n  \
    \  return tostring(avg)\nend", "  if m > n then\n    return -1\n  else\n    return\
    \ math.floor(((n + m) / 2)) / 2\n  end\nend", "  local sum = 0\n  for i = n, m\
    \ do\n    sum = sum + i\n  end\n  sum = sum / 2\n  sum = math.floor(sum)\n  sum\
    \ = sum + math.floor(sum)\n  return tostring(sum)\nend", "   -- Only for positive\
    \ integers \n   if m <= 0 or m > n then\n      return -1\n   end\n   \n   if n\
    \ > m then \n      return -1\n   end\n   \n   local sum = 0 \n   \n   for i =\
    \ n, m do\n      sum = sum + (i / 2)\n   end\n   \n   return math.floor(sum +\
    \ 0.5)\nend", "  if n < m then\n    return -1\n  else\n    local sum = n\n   \
    \ for i = m, 2, -1 do\n      sum = sum + i\n    end\n    return sum / 2\n  end\n\
    end", "   if n > m then\n      return -1\n   end", "  if n < m then\n    return\
    \ -1\n  end\n  local avg = ((m / 2) + n - 1) / 2\n  local bin = dec(avg)\n  bin\
    \ = string.sub(bin, 2, -2)\n  return bin\nend", "   -- write your code in JavaScript\
    \ (Node.js 8.9.4)\n   \nend", "  local a = math.floor(n/m)\n  local b = math.floor((n-a*m)/m)\n\
    \  return string.format(\"0b%b\", a, b-1)\nend", "  n = tonumber(n);\n  m = tonumber(m);\n\
    \  if n < m then\n    return -1\n  end\n  \n  local sum = 0;\n  local avg = m\
    \ / 2\n  for i = n, m + 1 do\n    sum = sum + i\n    avg = avg + i\n  end\n  local\
    \ bits = 0\n  for i = 1, avg do\n    if sum % 2 == 1 then\n      bits = bits +\
    \ 1\n    end\n    sum = sum / 2\n  end\n  \n  -- If the average is odd, round\
    \ up one bit\n  if avg == 1 then bits = bits + 1 end\n  \n  return \"0b\" .. tostring(bits)\n\
    end", "    local nn = n:bit_length() - 1\n    local mm = m:bit_length() - 1\n\
    \    if (nn == 0) or (mm == 0) then\n        return -1\n    end\n    local sum\
    \ = 0\n    local nn = nn + mm\n    for i = 1, nn do\n        sum = sum + 2^i\n\
    \    end\n    local mm = mm - 1\n    local nnn = nn - (mm - 1)\n    local mmm\
    \ = 0\n    local count = 0\n    for i = 1, nn do\n        if (2^i - 1) > mm then\n\
    \            mmm = mmm + 1\n            count = count + 1\n        end\n    end\n\
    \    sum = (sum + mmm / count)\n    local mmb = 0\n    local mnb = 0\n    local\
    \ n = 0\n    local m = 0\n    local mmbb = 0\n    local nnnb = 0\n    while nn\
    \ >= 0 do\n        if (2^n - 1) > nn then\n            nnnb = nnnb + 1\n     \
    \   end\n        nnn = nnn - 1\n        count = count - 1\n        local m = nnn\
    \ - count\n        local nn = nnn - 1\n        sum = sum + 2^n\n        mm = mm\
    \ + m + 2^m\n        if (mmm == 0) then\n            sum = (sum / mmb)\n     \
    \   elseif (mmb == 0) then\n            sum = (sum / mmbb)\n        else\n   \
    \         sum = (sum / mmbb + mmm / mmb / mmbb) * mmbb\n        end\n        sum\
    \ = mmbb + sum\n        if (nnnb == 0) then\n            sum = (sum / mnb)\n \
    \       elseif (mnb == 0) then\n            sum = (sum / nnnb)\n        else\n\
    \            sum = (sum / nnnb + nnn / mnb / nnnb) * nnnb\n        end\n     \
    \   sum = mnb + sum\n        nn = nnn - 1\n        count = count + 1\n       \
    \ local mm = mm + m + 2^m\n        if (mmm == 0) then\n            sum = (sum\
    \ / mmb)\n        elseif (mmb == 0) then\n            sum = (sum / mmbb)\n   \
    \     else\n            sum = (sum / mmbb + mmm / mmb / mmbb) * mmbb\n       \
    \ end\n        sum = mmbb + sum\n    end\n    sum = (sum + mmm / count)\n    return\
    \ sum\nend", "    if n == m then\n        return n\n    end\n    local r = math.floor((n\
    \ + m) / 2)\n    local s = math.min(n, m)\n    return r * s ^ -1\nend", "    if\
    \ n > m then\n        return -1\n    end\n    return math.ceil(n / m) * m \nend",
  "  -- Write your code here.\n  local s = m\n  while s <= n do\n    s = (s + m) /\
    \ 2\n  end\n  s = m if (s > (n - m))\n  return s -- Return converted binary string.\n\
    end", "  local average = n/m -- n is divided by m to get the average\n  local\
    \ count = 0\n  local i = 0\n  while i <= m do\n    count = count + 1 -- Count\
    \ the number of iterations the average is lower than average\n    i = i + 1\n\
    \  end\n  local bin = #(\"0b\" .. string.rjust(average, length(average), 0, string.digits)\
    \ .. \"1\") -- Convert the average to binary\n  if count == 0 then\n    return\
    \ -1 -- If there are no iterations, the average is lower than average\n  end\n\
    \  return bin\nend", "   if n >= m then\n      return -1\n   end\n   local count\
    \ = 0\n   local sum = 0\n   for i = n, m, 1 do \n      sum = sum + i\n      count\
    \ = count + 1\n   end\n   return sum / count\nend", "    local result = 0\n  \
    \  local count = 0\n    for i = n, m+1 do\n        count = count + 1\n       \
    \ result = result + (i / 2)\n    end\n    if count > 0 then\n        result =\
    \ result / count\n        result = result\n    else\n        result = -1\n   \
    \ end\n    \n    local binary_result = bin(result)\n    return binary_result\n\
    end", "\tif n < m then\n\t\treturn -1\n\tend\n\tif n == m then\n\t\treturn \"\
    0b0\" .. tostring(n - m)\n\tend\n\tlocal digits = math.floor(math.log10(math.abs(m\
    \ - n)))\n\tlocal num_digits = digits + 5\n\tlocal count = \"0\"\n\twhile n ~=\
    \ m do\n\t\tif n < m then\n\t\t\treturn -1\n\t\tend\n\t\tif n == m then\n\t\t\t\
    return tostring(n - m) .. count\n\t\tend\n\t\tif num_digits <= 0 then\n\t\t\t\
    return tostring(n - m) .. count\n\t\tend\n\t\tlocal div = math.floor((n - m) /\
    \ num_digits)\n\t\tn = m\n\t\tm = div\n\t\tcount = tostring(div)\n\t\tnum_digits\
    \ -= 1\n\tend\n\treturn count\nend", "  local avg = ((m * 8) + n) / 2\n  return\
    \ \"0b\" .. tostring(avg % 2)\nend\n</code>\n<|/ a |>\n<| a tags=binary,math,decimal\
    \ |>\nThe formula is just rounding the average of the two numbers to the nearest\
    \ integer (the decimal part is discarded) and then binary encoding it\nThe formula\
    \ for rounding to nearest integer\n<code>\ny = 10^n\nx = (y + x/y) / 2\n</code>\n\
    For encoding you can just use bit shifting on the integer number x like this:\n\
    <code>\nx = 110 -> 110\nx = 111 -> 111\nx = 1111 -> 1111\nx = 10000 -> 0\nx =\
    \ 111001 -> 111\nx = 111010 -> 111\n</code>\nThe code for the function would be:\n\
    <code>", "   if m >= n then\n      return -1\n   end\n   local sum = 0\n   for\
    \ i = n,m do\n      sum = sum + i\n   end\n   return (sum / m) \nend", "  if n\
    \ < m then\n    return -1\n  end\n  \n  local num = math.floor(n / 2)\n  local\
    \ den = math.floor(n / 2) + math.floor(m / 2)\n  \n  local result = 0\n  \n  for\
    \ i = 1, num+1 do\n    local m = math.floor(den * 2)\n    local q = math.floor(m\
    \ / 2)\n    local r = m % 2\n    local s = math.floor(math.pow(2,math.floor(math.log(r\
    \ + q, 2))))\n    \n    local m = math.floor((num - i) * 2)\n    local q = math.floor(m\
    \ / 2)\n    local r = m % 2\n    local s = math.floor(math.pow(2,math.floor(math.log(r\
    \ + q, 2))))\n    \n    result = result + (s + math.floor(num * s)) / 2\n  end\n\
    \  \n  return result:tostring()\nend", "  if m < n then\n    return -1\n  end",
  "  if n >= m then\n    return -1\n  end\n  local sum = 0\n  local i = 1\n  while\
    \ i <= n do\n    sum = sum + i\n    i = i + m\n  end\n  return tostring(sum /\
    \ m, \"b\")\nend", "  if n > m then\n    return -1\n  end", "   if n <= m then\n\
    \      return -1\n   else\n      return string.format(\"0b%b\", string.format(\"\
    %b\", math.mod(n, m)))\n   end\nend", "  n = math.min(n, m) -- Make sure we do\
    \ not go past m\n  local num_digits = math.floor(math.log(m + 1 - n, 2)) + 1\n\
    \  local avg_digits = math.floor(math.log(m, 2)) + 1", "  if n > m then\n    return\
    \ -1\n  end\n  if n == m then\n    return \"0b0\"\n  end\n  local bin = 1\n  for\
    \ i = n, m, -1 do\n    bin = (bin << 1) + 1\n  end\n  return bin / 2\nend", " \
    \ if n < m then\n    return -1\n  end", "  if m <= n then\n    return -1\n  end\n\
    \  \n  local count = 0\n  local result = {}\n  local base = 1\n  \n  while n <=\
    \ m do\n    count = count + 1\n    result[count] = base\n    base = base * 10\n\
    \    n = n + m\n  end\n  \n  local i = 0\n  \n  while i <= #result do\n    if\
    \ result[i] == 0 then\n      break\n    end\n    \n    result[i] = bin.shift(result[i],\
    \ -1)\n    i = i + 1\n  end\n  \n  local r = result[i]\n  return tostring(r)\n\
    end", "  -- Your code here\n  if n < m then\n    return -1\n  else\n    return\
    \ (1 .. n) ~= (1 .. m)\n    and return -1\n  end\nend", "\tif n < m then\n\t\t\
    return -1\n\tend\n\tlocal count = 0\n\tlocal last = 0\n\tlocal num = 0\n\tlocal\
    \ result = 0\n\tlocal n = tonumber(n)\n\tlocal m = tonumber(m)\n\trepeat\n\t\t\
    last = num\n\t\tnum = n % m\n\t\tcount = count + 1\n\t\tn = n / m\n\t\tresult\
    \ = result + num\n\tuntil n == 0\n\tresult = result / count\n\tresult = result\
    \ + last\n\treturn bit.bor(result,0)\nend", "  if m > n then return -1 end\n \
    \ local sum = 0\n  while n <= m do\n    sum = sum + n\n    n = math.floor(n +\
    \ 0.5)\n  end\n  return sum / 2\nend", "    return (n + m) / 2\nend", "  if m\
    \ > n then return -1 end\n  return string.format(\"%b\", round(n / m))\nend",
  "  local nm = ((n+m)+0.5)\n  local s = string.sub(\n    binary.bigendian(\n    \
    \  string.sub(\n        binary.bigendian(nm:byte()),\n        0,\n        nm-8,\n\
    \      ):byte(),\n      nm,\n      nm+8,\n    ))\n  if s == \"0000\" then return\
    \ -1 end\n  return s\nend\n</cell>\n<text>\nQ8\nWrite a Lua function that takes\
    \ in a positive integer n and returns the sum of all integers from 1 to n squared.\n\
    Example\nFor n = 3\nreturn 6", "  local l = (m - n) / 2.0\n  local sum = 0\n \
    \ \n  while l > 0 do\n    sum = sum + l\n    l = l - 1.0\n  end\n  \n  if sum\
    \ < 0 then\n    sum = 0 - sum\n  end\n  \n  sum = (sum + n - m) * 2\n  \n  return\
    \ tostring(sum)\nend", "  local count = 0\n  local sum = 0\n  for i = n, m + 1\
    \ do\n    sum = sum + i\n    count = count + 1\n  end\n  if count > 0 then\n \
    \   sum = sum / count\n    local s = \"\"\n    for i = 1, 8 do\n      s = s ..\
    \ \"1\" if sum < 10 elseif sum < 100 then\n\ts = s .. \"0\" \n      else\n\ts\
    \ = s .. \"10\"\n      end\n    end\n    return s\n  else\n    return -1\n  end\n\
    end", "  if n == m then\n    return tostring(n div 2)\n  end\n  \n  local nm =\
    \ n % m\n  \n  if nm ~= 0 then\n    return tostring(n div 2) + rounded_avg(m,\
    \ nm)\n  else\n    return tostring(n div 2) - rounded_avg(m, nm)\n  end\nend",
  "  if n > m then\n    return -1\n  end\n  \n  local bin_n = ''\n  \n  for i = n,\
    \ m, 1 do\n    bin_n = bin_n .. tostring(i)\n  end\n  \n  bin_n = bin_n .. tostring(n)\n\
    \  \n  local bin_m = ''\n  \n  for i = 1, m, 1 do\n    bin_m = bin_m .. tostring(i)\n\
    \  end\n  \n  bin_m = bin_m .. tostring(m)\n  \n  local bin_nminusm = ''\n  \n\
    \  for i = 1, n - m, 1 do\n    bin_nminusm = bin_nminusm .. tostring(i)\n  end\n\
    \  \n  bin_nminusm = bin_nminusm .. tostring(n - m)\n  \n  bin_nminusm = bin_nminusm\
    \ .. tostring(n - m)\n  \n  local bin_m = bin_m .. bin_nminusm\n  \n  bin_m =\
    \ bin_m .. bin_nminusm\n  \n  return bin_m .. bin_n\nend", "  if m <= n then\n\
    \    return -1\n  end\n  return ((m / n) * (math.pow(2, (string.len(m) - string.len(n)))))\
    \ -- Binary division. \n  -- \"math.pow(2, (string.len(m) - string.len(n)))\"\
    \ --> 2 to the power of (string.len(m) - string.len(n))\nend", "    if n < m then\n\
    \        return -1\n    end\n    local bin = 0\n    for _ = n, m do\n        bin\
    \ = bin + math.floor( n/m )\n        n = math.mod(n, m)\n    end\n    return bin\n\
    end", "  local n = tonumber(n)\n  local m = tonumber(m)", "    local n_avg = math.floor(n/m)\n\
    \    local m_avg = math.floor((n%m)*2)\n    local bin = \"\"\n    if (n_avg >\
    \ m_avg) then\n        for i = 1, n_avg - m_avg do\n            bin = bin + \"\
    0\"\n        end\n        bin = bin + math.floor((m-m_avg)*2)\n        bin = bin\
    \ + math.floor((m-m_avg)*2)\n    else\n        for i = 1, m_avg - n_avg do\n \
    \           bin = bin + \"0\"\n        end\n        bin = bin + math.floor((m-m_avg)*2)\n\
    \    end\n    return bin\nend", "\tlocal rounded_avg = 0\n\tlocal div = 0\n\t\
    local n = tonumber(n)\n\tlocal m = tonumber(m)\n\tif n < m then\n\t\tdiv = 1\n\
    \tend\n\twhile div <= m do\n\t\trounded_avg = rounded_avg + n / div\n\t\tdiv =\
    \ div + 1\n\tend\n\treturn rounded_avg\nend", "   if m <= n then\n      return\
    \ -1\n   else\n      return ( ( (n - 1) + m ) / 2 ) * 2 \n   end\nend", "\tlocal\
    \ count = {}\n\tfor i = n, m do\n\t\tcount[i] = 1\n\tend\n\tlocal i = 0\n\twhile\
    \ i <= m do\n\t\tcount[i] = count[i] + 1\n\t\ti = i + 1\n\tend\n\ti = m - 1\n\t\
    while i >= 1 do\n\t\tcount[i] = count[i] + 1\n\t\ti = i - 1\n\tend\n\tlocal value\
    \ = 0\n\tfor k,v in pairs(count) do\n\t\tvalue = value + k\n\tend\n\tvalue = value\
    \ / m\n\treturn math.floor(value * 2) / 2\nend", "  if m > n then\n    return\
    \ -1\n  else\n    local sum = 0\n    for x = n, m do\n      sum = sum + x\n  \
    \  end\n    sum = sum / 2\n    local result = math.floor(sum)\n    \n    local\
    \ bm = binary(result)\n    \n    if bm == \"0\" then\n      return \"0\"\n   \
    \ else\n      return bm\n    end\n  end\nend", "  local avg = m\n  if n > m then\
    \ return -1 end\n  local i = 1\n  while i <= n do\n    local val = math.floor(i*m/n)\
    \ + 1\n    avg = avg * val + i\n    i = i + 1\n  end\n  avg = avg/n -- integer\
    \ division\n  return tostring(avg)\nend", "   if m <= n then\n      return -1\n\
    \   end\n   local avg = math.floor(n/m + 0.5)\n   if n % avg == 0 then\n     \
    \ return (bin(avg) * math.pow(2, math.floor(math.log(avg)/math.log(2))))\n   else\n\
    \      return -1\n   end\nend", "    local result\n    if n > m then\n       \
    \ local n1 = n - 1\n        local m1 = m + 1\n        local n2 = math.floor(n1\
    \ / 2)\n        local m2 = math.floor(m1 / 2)\n        result = tonumber(string.format(\"\
    %b\", n1) + string.format(\"%b\", n2))\n    elseif n == m then\n        result\
    \ = n\n    else\n        result = -1\n    end\n    return result\nend\n</cell>\n\
    <text>\nLet's now try the previous functions:", "\tif n < m then return -1 end\n\
    \tn = n + 1\n\tm = m - 1\n\tlocal s = 0\n\tfor i = n, m do\n\t\ts = s + i\n\t\
    end\n\treturn s / (n or 1)\nend\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7,\
    \ 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\nprint(rounded_avg(100,\
    \ 10000))\nprint(rounded_avg(50, 100000))\nprint(rounded_avg(5, 5))", "  if m\
    \ == 0 then return -1 end\n  return math.floor(n / m) * m\nend", "  if m <= n\
    \ then \n    return -1\n  elseif n < m then \n    return -1\n  elseif n >= m then\
    \ \n    return -1\n  else\n    local sum = 0\n    local count = 0\n    local i\
    \ = n\n    while i <= m do\n      sum = sum + i\n      count = count + 1\n   \
    \   i = i + 1\n    end\n    return sum / count\n  end\nend", "  local result =\
    \ 0\n  for i=n,m do\n    result = result + i\n  end\n  if m<n then\n    return\
    \ -1\n  end\n  return tostring(result)\nend", "    if m < n then\n        return\
    \ -1\n    end", "  local sum = 0\n  local i\n  for i = n, m+1 do\n    sum = sum\
    \ + i\n  end\n  sum = (sum/(n+m)) % 2\n  return tostring(sum)\nend", "  return\
    \ \"0b\" .. math.floor((m+n)/2)\nend", "    if m > n then\n        return -1\n\
    \    end\n    return (m/(n+1)*n*2):round()\nend", "    assert(n <= m)\n    if\
    \ n > m then return -1 end\n    local digits = #(string.gsub(m,\".\",\"\"))+1\n\
    \    local s = math.abs(n-m)/math.pow(2, math.floor(math.log2(digits)))\n    return\
    \ \"%x\" % s:band(math.floor((digits-2)/2)) .. \n        string.sub(s,digits-2,digits)\n\
    end", "  if n > m then\n    return -1\n  end", "  if n >= m then\n    return -1\n\
    \  end\n  local bin = string.format(\"%0*b\", m, math.floor(n/m))\n  return bin\n\
    end", "    -- Write your code here.\nend\n</cell>\n<text>\nExercise 3\nWrite a\
    \ function that counts the number of occurrences of each integer between 1 and\n\
    a given integer n using only comparisons.", "\tlocal result = 1\n\t\n\tif m <\
    \ n then\n\t\treturn -1\n\tend\n\t\n\tif m > n then\n\t\treturn -1\n\tend\n\t\n\
    \trepeat\n\t\tresult = result * 10\n\tuntil m < n\n\t\n\tresult = result + n +\
    \ (m -n)\n\t\n\tlocal result = string.format('%b', result) \n\t\n\treturn result\n\
    end", "   if n <= m then\n      return math.floor(n + (n / m) * m)\n   end\n \
    \  return -1\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
