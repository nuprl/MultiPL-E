name: HumanEval_120_maximum
language: lua
prompt: "-- Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- Input:\
  \ arr = [-3, -4, 5], k = 3\n-- Output: [-4, -3, 5]\n-- Example 2:\n-- Input: arr\
  \ = [4, -4, 4], k = 2\n-- Output: [4, 4]\n-- Example 3:\n-- Input: arr = [-3, 2,\
  \ 1, 2, -1, -2, 1], k = 1\n-- Output: [2]\n-- Note:\n-- 1. The length of the array\
  \ will be in the range of [1, 1000].\n-- 2. The elements in the array will be in\
  \ the range of [-1000, 1000].\n-- 3. 0 <= k <= len(arr)\nlocal function maximum(arr,\
  \ k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n\
  \    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4,\
  \ -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1),\
  \ {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20,\
  \ 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n\
  \    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3,\
  \ 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n  \
  \  lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4,\
  \ -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n \
  \   lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- Base case\n\tif k == 1 then\n\t\treturn arr\n\tend\n\t-- Divide\
    \ and conquer algorithm\n\tlocal arr = maximum(arr, k / 2)\n\tlocal max_max_arr\
    \ = arr[#arr + 1]\n\tif k%2 == 1 then\n\t\tmax_max_arr = arr[#arr + 1]\n\tend\n\
    \treturn arr .. max_max_arr\nend", "    local result = {}\n    local j = 0\n \
    \   for i = 1, k do\n        if arr[j] < arr[i] then\n            result[i] =\
    \ arr[j]\n        else\n            result[i] = arr[i]\n        end\n        j\
    \ = j + 1\n    end\n    for i = k + 1, #arr do\n        if arr[i] > result[i +\
    \ 1] then\n            result[i + 1] = arr[i]\n        end\n    end\n    return\
    \ result\nend", "    local out = {}\n    for i = 1, k do\n        table.insert(out,\
    \ math.max(arr))\n        table.sort(arr)\n        arr[1] = arr[2]\n    end\n\
    \    return out\nend", "   local tempArray = {}\n   for i = 1,k do\n      tempArray[i]\
    \ = arr[i]\n   end\n   local maxArray = {}\n   local max = 0\n   local count =\
    \ 1\n   for i = 1,k do\n      if tempArray[i] > max then\n         max = tempArray[i]\n\
    \         for j = i,k do\n            tempArray[j] = tempArray[j]\n         end\n\
    \         count = k\n      else\n         count = count + 1\n         if count\
    \ > k then\n            count = k\n         end\n         for j = i,count do\n\
    \            tempArray[j] = tempArray[j]\n         end\n      end\n   end\n  \
    \ for i = 1,k do\n      maxArray[i] = max\n   end\n   for i = 1,k do\n      arr[i\
    \ - 1] = tempArray[i]\n   end\n   return maxArray\nend", "  assert(k > 0, 'The\
    \ parameter k should greater than 0')\n  assert(#arr > k, 'The parameter k should\
    \ less than the length of array')\n  \n  local output = {}\n  local length = #arr\n\
    \  for i = 1, k do\n    table.insert(output, arr[i])\n  end\n  table.sort(output)\n\
    \  for i = k + 1, length do\n    table.insert(output, arr[i])\n  end\n  return\
    \ output\nend", "  -- Write your code here\n  local max = {}\n  local i = 1 \n\
    \  while i < k do \n    local temp = nil\n    for i = 1,#arr do\n      if temp\
    \ == nil then\n        temp = arr[i]\n      else\n        if arr[i] > temp then\
    \ \n          temp = arr[i]\n        end\n      end\n    end\n    table.insert(max,\
    \ temp)\n    i = i + 1\n  end\n  return max\nend", "  if k == 0 then\n    return\
    \ arr\n  else\n    local maximum = arr[1]\n    for i = 2, k do\n      maximum\
    \ = maximum > arr[i] and arr[i] or maximum\n    end\n    local maxArr = {arr[1],\
    \ maximum}\n    for i = 2, k do\n      table.insert(maxArr, arr[i])\n    end\n\
    \    return maxArr\n  end\nend", "   if k > #arr then\n      return nil\n   end",
  "  local temp = {}\n  local count = 0\n  local max = 0\n  for _, value in pairs(arr)\
    \ do\n    if value < 0 then\n      count = count + 1\n    else\n      count =\
    \ count - 1\n    end\n    if count < 0 then\n      temp = temp or {value}\n  \
    \  else\n      temp = temp or {value, temp[#temp] + 1}\n    end\n    if temp[#temp]\
    \ > max then\n      max = temp[#temp]\n    end\n  end\n  \n  if k < 1 then\n \
    \   return temp\n  end\n  \n  local temp = temp or {0, 0}\n  count = count - 1\n\
    \  for i, v in pairs(temp) do\n    if count < 0 then\n      temp = temp or {v}\n\
    \    else\n      temp = temp or {v, temp[#temp] + 1}\n    end\n    if temp[#temp]\
    \ > max then\n      max = temp[#temp]\n    end\n  end\n  \n  if max > k then\n\
    \    k = max\n  end\n  \n  local i, value\n  temp = {}\n  for i = 1, k do\n  \
    \  for _, value in pairs(temp) do\n      table.insert(arr, value)\n    end\n \
    \ end\nend", "    if k == 0 then return arr end\n    local result = {}\n    local\
    \ i = 1 -- initialize the max of first k\n    for i = 1, k do\n        result[i]\
    \ = -math.inf\n    end\n    for i = 1, #arr do\n        if result[i] > -arr[i]\
    \ then result[i] = -arr[i] end\n        if result[i] < arr[i] then result[i] =\
    \ arr[i] end\n        if i > 1 then\n            result[i] = result[i-1]\n   \
    \     end\n    end\n    if k > #result then k = #result end\n    for i = k+2,\
    \ #result do\n        result[i] = -result[i]\n    end\n    return result\nend",
  "  local max_array = {}\n  local index = 1", "  local result = {}\n  local count\
    \ = 1\n  for _ in arr:gmatch(\"%d*\") do\n    table.insert(result, count)\n  \
    \  count = count + 1\n  end\n  table.sort(result)\n  local max = result[k-1]\n\
    \  local i = 0\n  for i = k - 1, k - 1, -1 do\n    if max < result[i] then\n \
    \     max = result[i]\n    end\n  end\n  return max\nend", "  if k == 0 then\n\
    \    return arr\n  elseif k > #arr then\n    k = #arr\n  end\n  local max_list\
    \ = []\n  for i = 1, k do\n    max_list = max_list .. arr[i]\n  end\n  return\
    \ max_list\nend", "    local maxArr = {} --array to store the max numbers\n  \
    \  local index = 1\n    local maxLength = 1 --k\n    for i = 1, k do\n       \
    \ if index == k or maxArr[1] < arr[index] then\n            table.insert(maxArr,\
    \ arr[index])\n            index = 1\n        elseif index == 1 then\n       \
    \     index = index + 1 \n        elseif arr[index] > arr[index - 1] then\n  \
    \          table.insert(maxArr, arr[index])\n            index = index + 1 \n\
    \        end\n    end\n    return maxArr\nend", "    local max_array = {}\n  \
    \  if k == 0 then\n        return arr\n    end\n    for i = 1, k do\n        table.insert(max_array,\
    \ arr[i])\n    end\n    table.sort(max_array, function(a, b) return a > b end)\n\
    \    return max_array\nend", "    local max = {}\n    local posMax = {}\n    for\
    \ i = 1, k do\n        max[i] = math.max(arr[i])\n        posMax[i] = i\n    end\n\
    \    for i = k + 1, #arr do\n        local temp = max[posMax[1]]\n        max[posMax[1]]\
    \ = max[i]\n        max[i] = temp\n        posMax[1] = posMax[1] + 1\n    end\n\
    \    return max\nend", "    local num = 0\n    local max = 0\n    local max_index\
    \ = 0\n    for i = 1, k do\n        for j = 1, #arr do\n            if arr[j]\
    \ > max then\n                max = arr[j]\n                num = j\n        \
    \    end\n        end\n        arr[num] = arr[num] - 1\n        if arr[num] ~=\
    \ 0 then\n            max_index = num\n        end\n    end\n    return arr\n\
    end", "    local max = -math.huge\n    local maxIndex = 0", "  -- write your code\
    \ here\n  local max_val = 0\n  local max_idx = nil\n  local max_val_idx = -1\n\
    \  for idx = 1, k do\n    local val = arr[idx]\n    if val > max_val then\n  \
    \    max_val = val\n      max_idx = idx\n      max_val_idx = idx\n    end\n  end\n\
    \  if max_val == max_idx then\n    return arr\n  elseif max_val_idx ~= k then\n\
    \    return arr\n  else\n    local new_arr = {}\n    for idx = 1, k do\n     \
    \ new_arr[idx] = arr[max_idx]\n    end\n    return new_arr\n  end\nend", "  --\
    \ The answer is stored in answer but arr is unchanged.\n  local answer\n  -- Base\
    \ case: length of the list is less than or equal to k.\n  if #arr <= k then\n\
    \    answer = arr\n  -- Base case: length of the list is greater than or equal\
    \ to k.\n  else\n    -- Find the maximum among first k elements.\n    -- This\
    \ can be done by finding the maximum element among the first k elements,\n   \
    \ -- then removing it and finding its maximum among remaining elements.\n    local\
    \ max = arr[1]\n    for i = 2, #arr do\n      if arr[i] > max then\n        max\
    \ = arr[i]\n      end\n    end\n    -- Remove the maximum element among first\
    \ k elements.\n    for i = 1, k do\n      arr[i] = arr[#arr]\n    end\n    --\
    \ Find the maximum element among remaining elements.\n    max = arr[#arr]\n  \
    \  for i = #arr + 2, #arr + k + 1 do\n      if arr[i] > max then\n        max\
    \ = arr[i]\n      end\n    end\n    -- Add the maximum element among remaining\
    \ elements.\n    for i = #arr + k + 2, #arr + #arr + k + 1 do\n      arr[i] =\
    \ max\n    end\n    -- Reverse the order of the remaining elements.\n    for i\
    \ = 0, #arr + k + 1 do\n      arr[i], arr[#arr + k + 1 - i] = arr[#arr + k + 1\
    \ - i], arr[i]\n    end\n    -- The maximum is now in arr[k], remove that and\
    \ add all the elements \n    -- except that to answer\n    arr[k] = arr[k] + arr[#arr\
    \ + k + 1] - arr[#arr + 1]\n    answer = arr\n  end\n  return answer\nend", "\t\
    -- Base case\n\tif k == 1 then\n\t\treturn arr\n\telseif k == 0 or k > #arr then\n\
    \t\treturn nil\n\tend", "\tassert(k > 0 and k <= #arr, \"Parameter k out of range\"\
    )", "  -- Create a list of unique elements. To do this, we will use the \n  --\
    \ hash map data structure to store every unique element we've seen in \n  -- our\
    \ arr so far. Since we don't want to repeat the same element,\n  -- we will use\
    \ the hash map value as a flag to determine whether the \n  -- element has been\
    \ seen before.\n  -- We start by setting every element in our arr hash map to\
    \ true.\n  local seen = {}\n  for i = 1, #arr do\n    seen[arr[i]] = true\n  end\n\
    \  \n  -- Create a list to store the results. We will begin with the first \n\
    \  -- element of arr and then pop it off of arr when we get to the end of\n  --\
    \ arr. At this point, the last element of our arr will be the \n  -- element we\
    \ need to put in the output list since it is the largest\n  -- element in the\
    \ arr. After we pop the last element of arr off the list,\n  -- we will push the\
    \ element in the output list onto the list by \n  -- popping off the last element\
    \ of arr off the list one by one until we\n  -- can no longer pop elements from\
    \ arr. Since we don't need to keep \n  -- any elements in arr, we will pop every\
    \ element from arr that \n  -- hasn't been seen before from arr until we reach\
    \ the end of arr.\n  local output = {}\n  \n  repeat\n    -- If the hash map value\
    \ is true (i.e. the element has not been seen\n    -- before in arr), then add\
    \ it to the output list.\n    if seen[arr[1]] then\n      table.insert(output,\
    \ arr[1])\n      -- Pop the first element off of arr and set its hash map value\
    \ to false.\n      arr[1] = arr[2]\n      seen[arr[1]] = false\n    end\n  until\
    \ #arr == 1\n  \n  return output\nend", "    local arr_size = #arr\n    \n   \
    \ assert(k > 0, 'k should be positive')\n    assert(k <= arr_size, 'k should be\
    \ smaller than the number of elements')\n    assert(k == 1 or (k == 2 and arr_size\
    \ % 2 == 0) or (k == 3 and arr_size % 3 == 0), 'k should be either 1, 2 or 3')\n\
    \    \n    local max_array = Array{Float64}(arr_size)\n    \n    for i = 1, arr_size\
    \ do\n        local min_element = arr[i]\n        \n        for j = i + 1, arr_size\
    \ do\n            local element = arr[j]\n            \n            if element\
    \ > min_element then\n                min_element = element\n            end\n\
    \        end\n        \n        max_array[i] = min_element\n    end\n    \n  \
    \  return max_array\nend", "  if k == 1 then\n    return arr[1]\n  elseif k ==\
    \ 0 then\n    return arr\n  else\n    local result = {}\n    local length = #arr\n\
    \    local i = 2\n    local maxi\n    while i <= length do\n      maxi = i\n \
    \     for k = 1, i do\n        if arr[i] > arr[maxi] then\n          maxi = i\n\
    \        end\n        i = i + 1\n      end\n      if maxi == i then\n        result[#result\
    \ + 1] = arr[maxi]\n      else\n        result[#result + 1] = arr[maxi - 1]\n\
    \      end\n    end\n    result[#result + 1] = arr[length - 1]\n    return result\n\
    \  end\nend", "  -- We create a vector 'result' with length k and fill it with\
    \ -infinity\n  -- until we find a non-negative element of arr. Then we iterate\
    \ over the\n  -- array to find this max-element, and finally the result vector\
    \ is returned.\n  -- This algorithm is O(k lg k).\n  -- If the array has less\
    \ than k elements, the result vector will be empty.\n  local result = {}\n  if\
    \ #arr < k then\n    return nil\n  end", "  local ans = {}\n  for i = 1, k do\n\
    \    local max_i = i\n    local max_val = arr[i]\n    for j = i + 1, k do\n  \
    \    local v = arr[j]\n      if v > max_val then\n        max_i = j\n        max_val\
    \ = v\n      end\n    end\n    ans[max_i..1] = max_val\n  end\n  return ans\n\
    end", "    if k == 0 then return {} end\n    local max_element = arr[1]\n    local\
    \ max_count = 0\n    for i = 2, k do\n        if arr[i] > max_element then \n\
    \            max_element = arr[i]\n            max_count = i\n        end\n  \
    \  end\n    return {arr[1], max_element, max_count}\nend", "  if k == 0 then\n\
    \    return arr\n  else\n    local i, j, max_i, max_j, max_k, max_arr = [], {},\
    \ {}, {}, {}", "  local maximum = nil\n  local tmp = {}\n  local i = 1\n  while\
    \ i <= #arr do\n    if maximum == nil or maximum < arr[i] then\n      tmp[i] =\
    \ arr[i]\n      maximum = arr[i]\n    end\n    i = i + 1\n  end\n  \n  if k >\
    \ #tmp then\n    return tmp\n  end\n  \n  local j = k - 1\n  while j <= #tmp do\n\
    \    maximum = math.max(maximum, tmp[j])\n    j = j - 1\n  end\n  \n  return tmp\n\
    end", "\tif k < 1 or k > #arr then return end", "  -- Build a result array that\
    \ has k elements, each of which will\n  -- be the max element of that subarray\n\
    \  local result, maxNum = { arr[1] }, arr[1]\n  \n  for i=2, #arr do\n    if arr[i]\
    \ > maxNum then\n      maxNum = arr[i]\n    end\n    if i == k then\n      result[k+1]\
    \ = maxNum\n      maxNum = arr[i]\n    else\n      result[k+1] = arr[i]\n    end\n\
    \  end\n  \n  return result\nend", "    local result = {}\n    for i = 1, k do\n\
    \        for j = 1, #arr do\n            if arr[j] > result[#result] then \n \
    \               result[#result] = arr[j]\n            end\n        end\n    end\n\
    \    return result\nend", "  -- Write your code here\n  local arr_c = table.remove_by_ref(arr,\
    \ k)\n  if arr_c then\n    local max = arr_c[1]\n    for i = 2, k do\n      if\
    \ max < arr_c[i] then\n        max = arr_c[i]\n      end\n    end\n    return\
    \ arr_c, max\n  else\n    return nil\n  end\nend", "  if k <= 0 then return nil\
    \ end\n  if k > #arr then return nil end\n  local max,l,r,s = arr[1],1,#arr,0\n\
    \  while s <= k do\n    max = arr[l] if max < arr[l] else max end\n    l = r\n\
    \    while r > 0 and arr[l] > max do\n      r = r - 1\n    end\n    s = s + 1\n\
    \  end\n  return arr[l+1 .. r]\nend", "   -- base case\n   if (k == 0) then\n\
    \      return arr\n   end", "    local result = {nil}\n    if #arr < k or k <\
    \ 1 then\n        return result\n    end\n    \n    local i, max = 0, -1\n   \
    \ for i = 1, k do\n        if arr[i] > max then\n            max = arr[i]\n  \
    \      end\n    end\n    \n    for i = k + 1, #arr do\n        if arr[i] > max\
    \ then\n            result[#result + 1] = arr[i]\n        end\n    end\n    \n\
    \    return result\nend", "  local new_arr = {}\n  local cur_max = 0\n  local\
    \ cur_max_index = 0\n  \n  for i=1, #arr do \n    if cur_max == 0 then\n     \
    \ new_arr[i] = arr[i]\n      cur_max = arr[i]\n      cur_max_index = i\n     \
    \ \n    elseif arr[i] > cur_max then\n      cur_max = arr[i]\n      cur_max_index\
    \ = i\n    end\n  end", "  -- Base case\n  if k == 1 then\n    return arr\n  end",
  "    if k == 1 then\n        -- Base Case\n        return arr\n    end\n    local\
    \ n = #arr\n    local sortedArr\n    local maxIndex\n    \n    if k > n then\n\
    \        -- Base Case\n        maxIndex = k - 1\n        sortedArr = arr\n   \
    \ else\n        -- Divide & Conquer\n        maxIndex = math.floor(n / 2)\n  \
    \      sortedArr = _maximum(arr, maxIndex, n - 1)\n    end\n    \n    -- Return\
    \ the array\n    return sortedArr\nend", "\t-- Your code here\n    local ret =\
    \ {}\n    for i = 1, k do\n        table.insert(ret, arr[i])\n    end\n    table.sort(ret)\n\
    \    return ret\nend", "  assert(k > 0 and k <= #arr, \"k is out of range\")\n\
    \  -- sort is stable so sort the list\n  table.sort(arr)\n  -- get the first k\
    \ elements of the sorted list\n  -- then remove the largest element k times.\n\
    \  local ret = {arr[1]}\n  for i = 2, #arr do\n    table.insert(ret, arr[i])\n\
    \    arr[i] = arr[1]\n  end\n  -- remove all elements in the kth position\n  for\
    \ i = k + 1, #ret do\n    local v = ret[i]\n    table.insert(ret, v)\n  end\n\
    \  return ret\nend", "    local n = #arr\n    local index = 0\n    if k < 1 or\
    \ n > k then\n        return nil\n    end\n    \n    local heap = {}\n    for\
    \ i = 1, n do\n        heap[i] = arr[i]\n    end", "\t-- Base case: If the length\
    \ of the array is less than or equal to k, just return the array as is.\n\tif\
    \ k == 1 or #arr == k then\n\t\treturn arr\n\tend", "  assert(type(k) == 'number'\
    \ and k > 0 and k <= #arr, 'k is expected to be an integer and k > 0 and k <=\
    \ #arr')\n  \n  -- Base case\n  if k == 1 then\n    return arr\n  end\n  \n  --\
    \ Recursion step\n  local new_max = maximum(arr, k-1)\n  for i = 1, #new_max do\n\
    \    if new_max[i] > arr[#arr] then\n      new_max[i], arr[#arr] = arr[#arr],\
    \ new_max[i]\n    end\n  end\n  \n  return new_max\nend", "\tif k > #arr then\
    \ return arr end\n\t\n\tlocal maxk = k - 1\n\t\n\tfor i = 1, #arr do\n\t\tlocal\
    \ m = -math.abs(arr[i])\n\t\tif m > maxk then\n\t\t\tmaxk = m\n\t\tend\n\tend\n\
    \t\n\treturn arr:sort(function(a, b) return -math.abs(a-b) end)[maxk + 1]\nend",
  "  -- TODO: Write your code here\n  local max_arr = []\n  for i = 1, k do\n    max_arr\
    \ = max_arr .. arr[i]\n  end\n  return max_arr\nend", "\t-- base case\n\tif k\
    \ == 0 then\n\t\treturn arr\n\tend", "  -- write your code here\n  local temp\
    \ = {}\n  for i = 1, k do\n    for j = 1, #arr do\n      if arr[j] > arr[i] then\n\
    \        temp[#temp + 1] = arr[j]\n      end\n    end\n  end\n  return temp\n\
    end", "  local max_arr = {}\n  local length = #arr", "   -- Your code here\n \
    \  local max = 0 \n   local max_arr = {} -- to store elements with max values\
    \ in it\n   for _,v in pairs(arr) do\n      if v > max then\n         max = v\n\
    \         max_arr = {v}\n      elseif v == max then\n         max_arr = {v, max_arr[1]}\n\
    \      end\n   end\n   if k > #max_arr then\n      k = #max_arr\n   end\n   return\
    \ max_arr\nend", "\tif k >= #arr then\n\t\treturn nil\n\tend", "  if k > #arr\
    \ then return end\n  local result = {}\n  local max_val = math.max(arr[k])\n \
    \ for i = k, #arr do\n    if arr[i] ~= max_val then\n      if #result == k then\
    \ table.insert(result, max_val) end\n      table.insert(result, arr[i])\n    \
    \  max_val = arr[i]\n    end\n  end\n  if #result > k then\n    local diff = #result\
    \ - k\n    table.insert(result, max_val)\n    for i = k, #result do\n      result[i]\
    \ = max_val - diff\n    end\n  end\n  return result\nend", "    local max_array\
    \ = {}\n    local max_i = 0\n    local max_j = k\n    while max_j < #arr do\n\
    \        if arr[max_i] > arr[max_j] then\n            max_array[#max_array + 1]\
    \ = arr[max_i]\n        else\n            max_array[#max_array + 1] = arr[max_j]\n\
    \        end\n        max_i = max_i + 1\n        max_j = max_j - 1\n    end\n\
    \    return max_array\nend", "    local maxLength = 0\n    local maxNum = nil\n\
    \    for _, num in ipairs(arr) do\n        if maxLength < k then\n           \
    \ maxLength = k\n            maxNum = num\n        elseif num > maxNum then\n\
    \            maxNum = num\n        end\n    end\n    return maxNum\nend", "\t\
    assert(k <= #arr, 'Error: the value of k exceeds the length of the array')", " \
    \ assert(k > 0 and k > arr[1], \"k should be > 0\")\n  assert(arr[1] > -math.inf\
    \ and arr[1] < math.inf, \"arr[1] should be between -Inf and Inf\")\n  assert(k\
    \ < math.min(#arr), \"k should be < length of arr\")", "    local output = {}\n\
    \    for _ = 1,k do\n        local max = 0\n        local max_index = 0\n    \
    \    for i = 1,#arr do\n            if arr[i] > max then\n                max\
    \ = arr[i]\n                max_index = i\n            end\n        end\n    \
    \    output[#output+1] = max\n    end\n    return output\nend", "    if k == 0\
    \ then\n        return arr\n    end\n    local new_arr = {}\n    local max_val\
    \ = -math.inf -- Initialize max value\n    for _, value in pairs(arr) do\n   \
    \     if value >= max_val then\n            max_val = value\n        end\n   \
    \ end\n    for _, value in pairs(arr) do\n        if value >= max_val - k then\n\
    \            new_arr[#new_arr + 1] = value\n        end\n    end\n    return new_arr\n\
    end", "    if k == 0 then\n        return arr\n    end\n    local max_arr = arr[1]\n\
    \    for i = 2, k do\n        if arr[i] > max_arr then\n            max_arr =\
    \ arr[i]\n        end\n    end\n    return max_arr\nend", "  assert(k > 0, 'K\
    \ should be positive.')\n  assert(#arr > k, 'Given array is too small.')\n  \n\
    \  local ans = {}\n  local i = 0\n  local largest = -math.inf -- initialize largest\
    \ element as -infinity\n  \n  for element in arr do\n    i = i + 1\n    if i ==\
    \ k then\n      table.insert(ans, element)\n      i = i - 1\n      largest = element\n\
    \    end\n    if largest > element then\n      largest = element\n    end\n  end\n\
    \  \n  return ans\nend", "  local max = arr[1]\n  for i = 2, k do\n    max = arr[#arr\
    \ + 1] > max and arr[i] or max\n  end\n  return max\nend", "    if k == 1 then\n\
    \        return arr\n    end", "    local i, j = 1, k\n    local res = { }\n \
    \   \n    while j <= #arr do\n        if arr[i] > arr[j] then\n            res[#res+1]\
    \ = arr[i]\n            i = i + 1\n        else\n            res[#res+1] = arr[j]\n\
    \            j = j + 1\n        end\n    end\n    \n    return res\nend", "  --\
    \ Base case\n  if k == 1 then\n    return arr\n  end\n  -- Increase k\n  local\
    \ result = {}\n  for i = 1, k do\n    local index = math.max(0, i - 1)\n    local\
    \ value = arr[i]\n    for j = 1, k do\n      if value < arr[j] then\n        value\
    \ = arr[j]\n        index = j\n      end\n    end\n    if i == index then\n  \
    \    table.insert(result, value)\n    end\n  end\n  return result\nend", "  --\
    \ Base case\n  if k == 1 then\n    return {arr[1]}\n  end\n  \n  -- Find the max\
    \ k-1 elements\n  local maxElements = maximum(arr, k - 1)\n  \n  -- Sort the elements\
    \ and return the max of them\n  return table.concat(maxElements, table.max)\n\
    end", "    local result = {}\n    local temp\n    for i = 1, k do\n        temp\
    \ = math.max(arr[i])\n        result[i] = temp\n    end\n    return result\nend",
  "  if k == 0 then\n    return arr\n  end\n  if k >= #arr then\n    return arr\n\
    \  end\n  local newArr = {arr[1]}\n  for i = 2, k do\n    local m\n    for j =\
    \ 1, i do\n      if m == nil or arr[j] > m then\n        m = arr[j]\n      end\n\
    \    end\n    newArr[#newArr+1] = m\n  end\n  return newArr\nend", "\tassert(k\
    \ <= #arr, \"Error: k must not greater then number of elements\")\n\tlocal result\
    \ = {}\n\tlocal pos = 0\n\tlocal max = -math.inf", "  assert(k > 0 and k + 1 <=\
    \ #arr)\n  local sorted = {}\n  local maxNum = arr[1]\n  for i = 2, k do\n   \
    \ if arr[i] > maxNum then\n      maxNum = arr[i]\n    end\n  end\n  table.insert(sorted,\
    \ maxNum)\n  for i = k + 1, #arr do\n    table.insert(sorted, arr[i])\n  end\n\
    \  return sorted\nend", "  if k > #arr then return nil end\n  if k == 0 then return\
    \ arr end\n  \n  local max_val = -999999999999\n  local max_index\n  for index,\
    \ x in ipairs(arr) do\n    if x > max_val then\n      max_val, max_index = x,\
    \ index\n    end\n  end\n  \n  table.insert(arr, max_index)\n  return maximum(arr,\
    \ k-1)\nend", "    local aMax = arr[1]\n    for i = 2, k do\n        if aMax <\
    \ arr[i] then\n            aMax = arr[i]\n        end\n    end\n    return aMax\n\
    end", "\tlocal size = #arr\n\tif k > size or k == 0 then\n\t\treturn nil\n\tend\n\
    \t\n\tlocal max_so_far = math.max(arr[1], arr[2])\n\t\n\tfor i = 4, size, k do\n\
    \t\tlocal current_max = math.max(arr[i], arr[i+1])\n\t\t\n\t\tif current_max >\
    \ max_so_far then\n\t\t\tmax_so_far = current_max\n\t\tend\n\tend\n\t\n\treturn\
    \ max_so_far\nend", "    local arr_size = #arr\n    if arr_size <= 0 or arr_size\
    \ ~= math.floor(k) then\n        return arr\n    end\n    local maximum, minimum\
    \ = arr[1], arr[1]\n    for index = 2, arr_size do\n        if arr[index] > maximum\
    \ then\n            maximum, minimum = arr[index], maximum\n        elseif arr[index]\
    \ < minimum then\n            minimum, maximum = arr[index], minimum\n       \
    \ end\n    end\n    if minimum >= maximum then\n        return minimum, maximum\n\
    \    else\n        return minimum, maximum\n    end\nend", "    local sorted_arr\
    \ = {}\n    local n = 1\n    local k2 = k\n    while n > 0 and k2 > 0 do\n   \
    \     local max_count = 0\n        for i = 1, n do\n            if arr[i] > arr[max_count]\
    \ then\n                max_count = i\n            end\n        end\n        sorted_arr[k]\
    \ = arr[max_count]\n        n = n - 1\n        k2 = k2 - 1\n    end\n    for i\
    \ = 1, k2 do\n        sorted_arr[i] = arr[i]\n    end\n    return sorted_arr\n\
    end", "    if k == nil then\n        return arr\n    end\n    if k > #arr then\n\
    \        return nil\n    end\n    local a = {}\n    for i = 1, k do\n        local\
    \ max\n        for j = 1, #arr do\n            if arr[j] > arr[i] then\n     \
    \           if max ~= nil then\n                    arr[i] = max\n           \
    \     end\n                max = arr[j]\n            end\n        end\n      \
    \  a[i] = max\n    end\n    return a\nend", "  if k == 0 then return arr end\n\
    \  if k == 1 then return arr end\n  if k > #arr then return arr end", "\t-- write\
    \ your code here\n\t-- write your code here\n\t-- write your code here\nend",
  "  assert(type(k) == 'number')\n  assert(k > 0 and k <= math.floor(#arr))\n  \n\
    \  local max_set = terralib.newlist()\n  local max_value = -math.huge\n  for i\
    \ = 1, k do\n    local value = arr[i]\n    if value > max_value then\n      max_value\
    \ = value\n    end\n    max_set:insert(value)\n  end\n  \n  local function find_largest(value)\n\
    \    local new_list = terralib.newlist()\n    for _, v in ipairs(max_set) do\n\
    \      if value == v then\n        new_list:insert(v)\n      end\n    end\n  \
    \  return new_list\n  end\n  return terralib.newlist(max_set), find_largest(max_value)\n\
    end", "    local result = {} -- the output array\n    local size = #arr -- The\
    \ size of output array\n    local i = 0\n    \n    -- sort the array\n    for\
    \ i=1, size do\n        table.insert(result, arr[i])\n    end\n    \n    -- find\
    \ the k biggest number\n    for i = 1, k do\n        if size > k then\n      \
    \      size = size -1\n        else\n            table.insert(result, arr[i])\n\
    \            size = size + 1\n        end\n    end\n    \n    return result\n\
    end", "   if k > #arr then return arr end\n   local result = {}\n   local maxValue\
    \ = arr[1]\n   for i = 2, k do\n      if arr[i] > maxValue then\n         maxValue\
    \ = arr[i]\n      end\n      table.insert(result, maxValue)\n   end\n   return\
    \ result\nend\n</cell>\n<cell>", "  local result = {}\n  local count = 1\n  local\
    \ max = arr[1]\n  for i = 2, #arr do\n    if arr[i] > max then\n      max = arr[i]\n\
    \    end\n  end\n  local i = 1\n  while i <= k do\n    local elem = arr[i]\n \
    \   if elem > max then\n      count = count + 1\n      if count == k then\n  \
    \      result[#result+1] = max\n      else\n        result[#result+1] = elem\n\
    \      end\n    end\n    i = i + 1\n  end\n  if count > k then\n    result[#result+1]\
    \ = max\n  end\n  return result\nend", "    if k == nil then\n        return arr\n\
    \    end\n    \n    local a = {}\n    local i = 0\n    local max = math.max(arr[0],\
    \ arr[1])\n    while i < #arr do\n        if arr[i] > max then\n            max\
    \ = arr[i]\n        end\n        \n        table.insert(a, max)\n        \n  \
    \      if i == k then\n            i = i + 1\n            max = arr[i]\n     \
    \   end\n        \n        i = i + 1\n    end\n    \n    return a\nend", "   \
    \ local result = {}\n    for i = 1, k do\n        local maxNum = 0\n        for\
    \ j=1, #arr do\n            if arr[j] > maxNum then\n                maxNum =\
    \ arr[j]\n            end\n        end\n        result[i] = maxNum\n    end\n\
    \    return result\nend\n    ", "    local arrLen = #arr\n    local maxArr\n \
    \   local result\n    \n    if k > arrLen then\n        return nil\n    end\n\
    \    \n    if k == arrLen then\n        maxArr = arr\n        \n        if maxArr\
    \ == arr then\n            if arrLen > 1 then\n                result = arr\n\
    \            else\n                result = nil\n            end\n        else\n\
    \            result = arr[k]\n        end\n    else\n        maxArr = arr\n  \
    \      for i = arrLen + 1 - k - 1, 1, -1 do\n            if maxArr[i] > maxArr[i\
    \ - 1] then\n                maxArr[i] = maxArr[i - 1]\n            else\n   \
    \             maxArr[i] = maxArr[i]\n            end\n        end\n        result\
    \ = maxArr\n    end\n    \n    return result\nend", "   -- Write your code here\n\
    \   -- arr is a list of integers\n   -- k is an integer\n   if k > #arr or k <\
    \ 0 then\n      return nil\n   else\n      local maxElement = arr[1]\n      local\
    \ newArray = {}\n      for i = 2, #arr do\n         if arr[i] > maxElement then\n\
    \            maxElement = arr[i]\n         end\n         table.insert(newArray,\
    \ maxElement)\n      end\n      return newArray\n   end\nend", "  local i = 0\n\
    \  local maxArr = {} --  create a new array called maxArr\n  local max = -math.inf\n\
    \  while i <= #arr do\n    if arr[i] > max then\n      max = arr[i]\n    end\n\
    \    if i == k then\n      table.insert(maxArr, max)\n    end\n    i = i + 1\n\
    \  end\n  return maxArr\nend", "    if k == 1 then\n        return {arr[1]}\n\
    \    end\n    \n    local max = -math.inf\n    local max_index = 1\n    for i\
    \ = 2, #arr do\n        if arr[i] > max then\n            max = arr[i]\n     \
    \       max_index = i\n        end\n    end\n    \n    local rest = maximum(arr,\
    \ k - 1)\n    \n    return {arr[max_index], max}\nend", "    local max_ele = math.inf\n\
    \    local max_ele_pos = -1\n    for i = 1,k do\n        if max_ele > arr[max_ele_pos]\
    \ then\n            max_ele = arr[max_ele_pos]\n        end\n        max_ele_pos\
    \ = i\n    end\n    local max_ele_pos = max_ele_pos\n    local result = {max_ele}\n\
    \    local i = 1\n    while i <= k do\n        if max_ele > arr[max_ele_pos] then\n\
    \            max_ele = arr[max_ele_pos]\n        end\n        result[i] = max_ele\n\
    \        i = i + 1\n        if i >= k then\n            break\n        end\n \
    \       max_ele_pos = max_ele_pos + 1\n    end\n    return result\nend", "  local\
    \ max = []\n  local i = 0\n  local j = 0\n  while i < k do\n    j = j + 1\n  \
    \  if arr[i] > arr[j] then\n      table.insert(max, arr[i])\n      i = i + 1\n\
    \    else\n      table.insert(max, arr[j])\n      j = j + 1\n    end\n  end\n\
    \  if j < k then\n    for i = j, k + 1 do\n      table.insert(max, arr[i])\n \
    \   end\n  end\n  return max\nend", "  assert(k, \"k should be integer > 0\")\n\
    \  local result = {}\n  for i = 0, k - 1 do\n    if arr[i] ~= arr[i + 1] then\n\
    \      result[i] = arr[i]\n    end\n  end\n  table.insert(result, arr[k])\n  return\
    \ result\nend", "  local len = _getLengthOfArray(arr)\n  if k > len then return\
    \ nil end\n  local max = _getMaxElement(arr, len)\n  \n  local i = len - k + 1\n\
    \  while i > 0 do\n    local val = arr[i]\n    local j = len - i - 1\n    while\
    \ j >= 0 and arr[j] > val do\n      arr[j + 1] = arr[j]\n      j = j - 1\n   \
    \ end\n    arr[j + 1] = val\n    i = i - 1\n  end\n  \n  return arr\nend\n  ",
  "    local ans = {}\n    local len = 0\n    local pos = 0\n    local count = 0\n\
    \    for i = 1, k do\n        if arr[pos] < 0 then\n            count = count\
    \ + 1\n        elseif count > len then\n            len = count\n        end\n\
    \        if arr[pos] <= arr[len] and arr[pos] <= arr[len - 1] and arr[pos] <=\
    \ arr[len - 2] then\n            pos = pos + 1\n        elseif arr[pos] > arr[len]\
    \ and arr[pos] > arr[len - 1] and arr[pos] > arr[len - 2] then\n            pos\
    \ = pos + 2\n        else\n            pos = pos + 1\n            count = count\
    \ + 1\n        end\n    end\n    for i = k, 1, -1 do\n        if arr[pos] < 0\
    \ then\n            count = count + 1\n        elseif count > len then\n     \
    \       len = count\n        end\n        if arr[pos] <= arr[len] and arr[pos]\
    \ <= arr[len - 1] and arr[pos] <= arr[len - 2] then\n            pos = pos + 1\n\
    \        elseif arr[pos] > arr[len] and arr[pos] > arr[len - 1] and arr[pos] >\
    \ arr[len - 2] then\n            pos = pos + 2\n        else\n            pos\
    \ = pos + 1\n            count = count + 1\n        end\n    end\n    pos = k\n\
    \    count = 0\n    ans[#ans+1] = arr[pos]\n    while pos <= #arr do\n       \
    \ if arr[pos] >= arr[len] and arr[pos] >= arr[len - 1] and arr[pos] >= arr[len\
    \ - 2] then\n            pos = pos + 1\n        elseif arr[pos] <= arr[len] and\
    \ arr[pos] <= arr[len - 1] and arr[pos] <= arr[len - 2] then\n            pos\
    \ = pos + 2\n        elseif arr[pos] > arr[len] and arr[pos] > arr[len - 1] and\
    \ arr[pos] > arr[len - 2] then\n            pos = pos + 1\n        else\n    \
    \        pos = pos + 1\n            count = count + 1\n        end\n        ans[#ans+1]\
    \ = arr[pos]\n    end\n    return ans\nend", "    if k == 0 then\n        return\
    \ arr\n    end\n    local arr = arr or {}\n    local length = #arr\n    local\
    \ result\n    if length > k then\n        local maximum = maximum(arr, length\
    \ - k)\n        local arr = {}\n        local i = 0\n        while i < k do\n\
    \            arr[#arr + 1] = maximum[i]\n            i = i + 1\n        end\n\
    \        result = arr\n    else\n        result = {arr[length - 1]}\n    end\n\
    \    return result\nend", "  -- Write your code here\n  if k <= #arr then\n  \
    \  return arr[k]:sort(function(a,b) return a > b end)\n  else\n    return arr:sort(function(a,b)\
    \ return a > b end):reverse()\n  end\nend", "  if k == nil then k = 0 end\n  if\
    \ k >= #arr then k = #arr end\n  local max_arr = {}\n  local max_val = nil\n \
    \ for i in 1, k do\n    if arr[i] ~= nil and max_val ~= nil and\n      arr[i]\
    \ > max_val then\n      max_val = arr[i]\n    end\n    max_arr[i] = arr[i]\n \
    \ end\n  return max_arr\nend", "    assert(k <= #arr)\n    local maxes = {}\n\
    \    local max_len = 0\n    for i = 1, k do\n        local tmp_arr = {}\n    \
    \    local tmp_max = -1\n        for j = 1, #arr do\n            local cur_max\
    \ = arr[#arr + j]\n            if cur_max > tmp_max then\n                tmp_max\
    \ = cur_max\n            end\n        end\n        if tmp_max > -1 then\n    \
    \        tmp_arr[1] = tmp_max\n            for j = 2, #arr do\n              \
    \  tmp_arr[j] = arr[#arr + j]\n            end\n            table.insert(maxes,\
    \ tmp_arr)\n        end\n    end\n    for i = 1, k do\n        if #maxes == i\
    \ then\n            table.insert(maxes, arr[i])\n        else\n            table.insert(maxes,\
    \ arr[i], maxes[i])\n        end\n    end\n    table.sort(maxes)\n    local res\
    \ = {}\n    for i = 1, k do\n        table.insert(res, maxes[i])\n    end\n  \
    \  return res\nend\nassert(maximum(arr1, k) == maximum(arr1, k2))", "  assert(k\
    \ > 0 and k and type(k) == 'number')\n  assert(#arr <= 1000)\n  assert(0 <= arr\
    \ and arr <= 1000)\n  \n  -- Use binary search to find the k largest values.\n\
    \  local function binary_search(arr, low, high, key)\n    local pivot = (low +\
    \ high) / 2\n    local current_max = arr[pivot]", "  if k == 0 then\n    return\
    \ arr\n  else\n    local max_index = 0\n    local max_val = -math.inf", "    local\
    \ ret = {}\n    for i=1,k do\n        local max_val = -10000\n        for j=1,#arr\
    \ do\n            if arr[j] > max_val then\n                max_val = arr[j]\n\
    \            end\n        end\n        ret[#ret+1] = max_val\n    end\n    return\
    \ ret\nend", "  -- Write your code here.\n  local max_idx = 1\n  for i = 1,k do\n\
    \    if arr[i-1] > arr[max_idx] then\n      max_idx = i\n    end\n  end\n  return\
    \ arr[max_idx:k]\nend", "  if k == nil then\n    return arr\n  end\n  local max_arr\
    \ = {}\n  local count = 0\n  \n  for i, x in ipairs(arr) do\n    if x > max_arr[k]\
    \ then\n      max_arr[k] = x\n      count = count + 1\n    end\n  end\n  \n  if\
    \ count > k then\n    return max_arr\n  else\n    return maximum(arr, k - 1)\n\
    \  end\nend", "\t-- First sort by absolute value, then by value, then by index\n\
    \t-- Since negative values are less than positive values,\n\t-- sorting by absolute\
    \ value will place negative numbers\n\t-- to the end of the result list.\n\tarr\
    \ = table.sort(arr,\n\t\tfunction(a, b) return -a < -b or math.abs(a) < math.abs(b)\
    \ end)", "  -- Build a suffix tree and do in-order traversal\n  -- with recursion\n\
    \  -- Runtime: O(n)\n  local size = #arr\n  local preffix = {}\n  for i = 1, size\
    \ do\n    if preffix[i] == nil then\n      preffix[i] = i\n    else\n      local\
    \ j = preffix[i] + 1\n      while j < size do\n        preffix[j] = j\n      \
    \  j = preffix[j] + 1\n      end\n    end\n  end\n  local max = 0\n  local maxidx\
    \ = nil\n  local largest = arr[size]\n  local idx = 0\n  preffix[size] = size\n\
    \  while idx < size do\n    local idx = preffix[idx]\n    if largest < arr[idx]\
    \ then\n      largest = arr[idx]\n      maxidx = idx\n    end\n    preffix[idx]\
    \ = nil\n  end\n  -- Build a suffix tree and do in-order traversal\n  -- with\
    \ recursion\n  -- Runtime: O(n)\n  local size = #arr\n  local preffix = {}\n \
    \ for i = 1, size do\n    if preffix[i] == nil then\n      preffix[i] = i\n  \
    \  else\n      local j = preffix[i] + 1\n      while j < size do\n        preffix[j]\
    \ = j\n        j = preffix[j] + 1\n      end\n    end\n  end\n  local max = 0\n\
    \  local maxidx = nil\n  local largest = arr[size]\n  local idx = 0\n  preffix[size]\
    \ = size\n  while idx < size do\n    local idx = preffix[idx]\n    if largest\
    \ < arr[idx] then\n      largest = arr[idx]\n      maxidx = idx\n    end\n   \
    \ preffix[idx] = nil\n  end\n  assert(k == 1 or maxidx == nil)\n  if maxidx ~=\
    \ nil then\n    arr = arr[maxidx+k+1]\n    return maximum(arr, k)\n  else\n  \
    \  return largest\n  end\nend", "  -- base case\n  if k == 0 then\n    return\
    \ arr\n  end", "\tif k == 0 then\n\t\treturn arr\n\telseif k == 1 then\n\t\treturn\
    \ arr[1]\n\telse\n\t\tlocal m\n\t\tm = maximum(arr, k - 1) \n\t\tfor i = 1, k\
    \ do\n\t\t\tif arr[i] > m then\n\t\t\t\tm = arr[i]\n\t\t\tend\n\t\tend\n\t\treturn\
    \ m\n\tend\nend", "    if k == 0 then\n        return 0\n    else\n        local\
    \ arr2 = {}\n        for i = 1, k do\n            if arr[i] > arr2[i] then\n \
    \               arr2[i] = arr[i]\n            end\n        end\n        return\
    \ arr2\n    end\nend", "  -- base case\n  if k < 1 then\n    return arr\n  end\n\
    \  \n  -- partition\n  local pivot = arr[1]\n  local max_list = { pivot }\n  local\
    \ i = 1\n  \n  for i = 2, #arr do\n    if arr[i] > pivot then\n      arr[i], arr[i\
    \ - 1] = arr[i - 1], arr[i]\n      i = i-1\n    end\n    max_list[i] = arr[i]\n\
    \  end\n  \n  -- merge the two lists\n  max_list[i], arr[i] = arr[i - 1], arr[i]\n\
    \  \n  return max_list\nend", "\tlocal result, currentMax = arr or {}, nil\n\t\
    for i = 1, k do\n\t\tlocal element = currentMax\n\t\tlocal pos = 1\n\t\tlocal\
    \ i\n\t\trepeat\n\t\t\ti = i+1\n\t\t\telement = element[1]\n\t\t\tif element[1]\
    \ > current and i ~= k then\n\t\t\t\tpos = pos+1\n\t\t\tend\n\t\tuntil not element\
    \ or i==k\n\t\tresult[#result+1] = element\n\t\tif pos == 1 then currentMax =\
    \ element end\n\tend\n\treturn result\nend", "  if k == 0 then\n    return arr\n\
    \  else\n    local maxs = { arr[1], arr[2], arr[3] }\n    for i = 4, k:len(arr)\
    \ do\n      local max_value = arr[i]\n      for _, v in ipairs(maxs) do\n    \
    \    if v > max_value then\n          max_value = v\n        end\n      end\n\
    \      maxs[i] = max_value\n    end\n    return maxs\n  end\nend", "    local\
    \ maxArray = Array.new();\n    local maxIndex = 0;\n    local maxVal = nil;\n\
    \    for i = 1, k do\n        for j = 1, k do\n            if arr[j] > arr[maxIndex]\
    \ then\n                maxIndex = j;\n                maxVal = arr[j];\n    \
    \        end\n        end\n        maxArray[i] = maxVal;\n        maxIndex = 0;\n\
    \        maxVal = nil;\n    end\n    for i = 1, k do\n        maxArray[i] = arr[maxIndex];\n\
    \    end\n    return maxArray;\nend", "  if k == 1 then\n    arr[1]\n  else\n\
    \    local max = arr[1]\n    for i = 2, k do\n      if arr[i] > max then\n   \
    \     max = arr[i]\n      end\n    end\n    arr[k]:max(max)\n  end\nend", "  \
    \  local max = {} --\u3000\u6700\u5927\u6570\u7EC4\n    for i = 1, k do\n    \
    \    for ii = 2, #arr do\n            if arr[ii] >= arr[i] then\n            \
    \    arr[i], arr[ii] = arr[ii], arr[i]\n                max[i], max[ii] = arr[i],\
    \ arr[ii]\n            end\n        end\n    end\n    return max\nend", "    local\
    \ sorted_arr = table.sort(arr)\n    if k > #sorted_arr then \n        return sorted_arr\
    \ \n    end \n    local max_val = 0 \n    local max_element = sorted_arr \n  \
    \  local max_index = 1 \n    for i = 2, k do\n        if sorted_arr[i] > sorted_arr[i\
    \ - 1] then\n            max_val = sorted_arr[i - 1]\n            max_index =\
    \ i\n        elseif sorted_arr[i] < sorted_arr[i - 1] and max_val < sorted_arr[i]\
    \ then\n            max_val = sorted_arr[i]\n            max_index = i\n     \
    \   end \n    end \n    \n    return max_element[max_index]\nend", "    local\
    \ new_arr = {}\n    local max_count = 0", "\tassert(k > 0 and k <= #arr, \"invalid\
    \ k\")\n\tlocal result = {}\n\tfor i = k, 1, -1 do\n\t\tlocal max_element = math.max(1,\
    \ arr[i])\n\t\tfor j = i - 1, k, -1 do\n\t\t\tif arr[j] > max_element then\n\t\
    \t\t\ttable.insert(result, max_element)\n\t\t\t\tbreak\n\t\t\tend\n\t\t\ttable.insert(result,\
    \ arr[j])\n\t\tend\n\tend\n\treturn result\nend", "  if k > #arr then\n    return\
    \ nil\n  end\n  if k == 0 then\n    return arr\n  end\n  local pivot = arr[1]\n\
    \  local ans, i, j = 0, 2, 1\n  while i < #arr do\n    if pivot < arr[i] then\n\
    \      ans[#ans + 1] = arr[i]\n      i = i + 1\n    else\n      if arr[i] > pivot\
    \ then\n        arr[#arr + 1] = arr[j]\n        j = j + 1\n      else\n      \
    \  arr[#arr + 1] = pivot\n        i = i + 1\n      end\n    end\n  end\n  arr[#arr\
    \ + 1] = pivot\n  return maximum(arr, k - 1)\nend\nprint(maximum([-3, 2, 1, 2,\
    \ -1, -2, 1], 1))", "\tassert(k == nil or k > 0 and k <= #arr, \"Invalid input\"\
    )\n\tlocal results = {}\n\tlocal posMax = nil\n\tlocal maxNum = nil", "  -- start\
    \ with the array with the largest number\n  local maxElement = arr[#arr]\n  --\
    \ start with the first element in the array and work through the rest\n  for i=1,\
    \ k do\n    -- check if the next number in the array is greater or equal to the\
    \ current max\n    if arr[i] >= maxElement then\n      -- if the next number is\
    \ greater, replace the max\n      maxElement = arr[i]\n    end\n  end\n  -- return\
    \ the maxElement\n  return maxElement\nend", "    local max_index = 1\n    local\
    \ max_value = arr[1]\n    for index = 2, k do\n        if arr[index] > max_value\
    \ then\n            max_value = arr[index]\n            max_index = index\n  \
    \      end\n    end\n    return arr[k - 1], max_index\nend", "\t-- Write your\
    \ code here.\n\t\n\tlocal output = {}\n\t\n\tif k > #arr then\n\t\treturn output\n\
    \telseif k == #arr then\n\t\ttable.insert(output, arr[1])\n\t\treturn output\n\
    \telse\n\t\tlocal i = 1\n\t\tlocal max_value = arr[1]\n\t\t\n\t\twhile i <= #arr\
    \ do\n\t\t\tif arr[i] > max_value then\n\t\t\t\toutput[k] = max_value\n\t\t\t\t\
    max_value = arr[i]\n\t\t\t\ti = i + 1\n\t\t\telse\n\t\t\t\tlocal j = 1\n\t\t\t\
    \t\n\t\t\t\twhile j <= #arr do\n\t\t\t\t\tif arr[j] >= max_value and arr[i] >\
    \ arr[j] then\n\t\t\t\t\t\toutput[k] = max_value\n\t\t\t\t\t\tmax_value = arr[j]\n\
    \t\t\t\t\t\ti = i + 1\n\t\t\t\t\telse\n\t\t\t\t\t\tj = j + 1\n\t\t\t\t\tend\n\t\
    \t\t\tend\n\t\t\tend\n\t\tend\n\t\n\t\treturn output\n\tend\nend", "  -- Base\
    \ case: array has length 0 or 1.\n  if k == 1 then\n    return arr\n  end", " \
    \ local result = {}\n  local j = 0\n  for i = 1,k do\n    result[j] = arr[j]\n\
    \    j = j + 1\n  end\n  for i = 1,k do\n    if arr[i] > result[j] then\n    \
    \  result[j] = arr[i]\n      j = j + 1\n    end\n  end\n  return result\nend",
  "    local i = 0\n    local j = 0\n    local temp", '    if k > #arr then return
    nil end', "   assert(type(k) == \"number\")\n   assert(k > 0 and k <= #arr)",
  "  assert(type(arr) == \"table\" and k > 0 and k and type(k) == \"number\")\n  local\
    \ maxArray = {}\n  for i = 1, k do\n    maxArray[i] = arr[i]\n  end\n  for i =\
    \ k + 2, #arr do\n    maxArray[i] = arr[i - 1]\n  end\n  return maxArray\nend",
  "  if k < 1 then\n    error(\"k must be positive\")\n  end\n  local max = {}\n \
    \ local i = 1\n  while i <= #arr do\n    if i > k then\n      break\n    end\n\
    \    if arr[i] > max[i - 1] then\n      table.insert(max, arr[i])\n    end\n \
    \   i = i + 1\n  end\n  return max\nend", "    local max = Array()\n    for i\
    \ = 1, k do\n        table.insert(max, arr[math.min(i + 1, #arr)])\n    end\n\
    \    return max\nend", "  local max_num = arr[1]\n  local max_index = 1 -- The\
    \ position of the max_num in the array\n  for i = 2, #arr do\n    -- If the current\
    \ element is larger than the max, store it\n    if arr[i] > max_num then\n   \
    \   max_num = arr[i]\n      max_index = i\n    end\n    -- If the current element\
    \ is equal to the max, move the max to the front\n    -- of the array and overwrite\
    \ the current element with the new max.\n    if arr[i] == max_num then\n     \
    \ arr[i] = max_num\n      arr[1] = max_num\n      max_index = 2\n    end\n  end\n\
    \  -- If there are enough numbers in the array, return the kth number\n  if max_index\
    \ <= k then\n    return arr\n  else\n    -- Return everything after the kth number\n\
    \    return arr:sub(1, max_index) -- Note the use of sub\n  end\nend", "  local\
    \ result = {}\n  local pos = k - 1\n  if k > #arr then\n    return arr\n  end\n\
    \  while pos > 0 and #result < k do\n    if arr[pos] > arr[pos-1] then\n     \
    \ table.insert(result, arr[pos])\n    end\n    pos = pos - 1\n  end\n  if pos\
    \ > 0 then\n    table.insert(result, arr[pos])\n  end\n  return result\nend",
  "    if k > #arr then \n        return arr\n    end\n    if k == 0 then\n      \
    \  return {arr[1]}\n    end\n    local sorted_arr = sort(arr)\n    local max_arr\
    \ = {}\n    local max_index = #sorted_arr\n    for i = 1, k do\n        max_arr[max_index]\
    \ = sorted_arr[i]\n        max_index = max_index - 1\n    end\n    return max_arr\n\
    end", "  assert(k > 0, 'k should be positive.')\n  assert(k and type(k) == 'number',\
    \ 'k should be number.')\n  assert(k and k > 0, 'k should be positive.')\n  assert(k\
    \ and type(k) == 'number', 'k should be number.')\n  assert(arr and type(arr)\
    \ == 'table', 'arr should be table.')\n  assert(arr and arr and type(arr) == 'table',\
    \ 'arr should be table.')\n  assert(arr and arr and #arr >= k, 'k should be larger\
    \ than the length of arr.')\n  assert(arr and arr and #arr >= 1, 'arr should be\
    \ non-empty.')\n  assert(arr and arr and #arr <= 1000, 'arr should be at most\
    \ 1000 elements.')\n  assert(arr and arr and (#arr > 0 or #arr == 1), 'arr should\
    \ be non-empty.')\n  assert(arr and arr and (#arr > 0 or #arr == 1), 'arr should\
    \ be non-empty.')\n  assert(arr and arr and (#arr >= -1000 and #arr <= 1000),\
    \ 'arr should be non-empty.')\n  assert(arr and arr and (#arr >= -1000 and #arr\
    \ <= 1000), 'arr should be non-empty.')\n  assert(arr and arr and (#arr >= -1000\
    \ and #arr <= 1000), 'arr should be non-empty.')\n  assert(arr and arr and (#arr\
    \ >= -1000 and #arr <= 1000), 'arr should be non-empty.')\n  assert(arr and arr\
    \ and (#arr >= -1000 and #arr <= 1000), 'arr should be non-empty.')\n  assert(arr\
    \ and arr and (#arr >= -1000 and #arr <= 1000), 'arr should be non-empty.')\n\
    \  assert(arr and arr and (#arr >= -1000 and #arr <= 1000), 'arr should be non-empty.')\n\
    \  assert(arr and arr and (#arr >= -1000 and #arr <= 1000), 'arr should be non-empty.')\n\
    \  assert(arr and arr and (#arr >= -1000 and #arr <= 1000), 'arr should be non-empty.')",
  "   assert(k > 0 and k < #arr, 'invalid k')\n   if k == 0 then return arr end\n\
    \   local max_array = { }\n   for i = 1, k do\n      max_array[i] = arr[i]\n \
    \  end\n   for i = k + 2, #arr do\n      local tmp_max = max_array[1]\n      for\
    \ j = 2, k do\n         if tmp_max < max_array[j] then\n            tmp_max =\
    \ max_array[j]\n         end\n      end\n      max_array[k] = tmp_max\n   end\n\
    \   return max_array\nend", "  if k < 0 or k >= #arr then\n    return nil\n  end\n\
    \  \n  local result = {}\n  \n  local max_idx = 1\n  local max_val = arr[1]\n\
    \  local max_idx = 1\n  for idx = 2, #arr do\n    if arr[idx] > max_val then\n\
    \      max_val = arr[idx]\n      max_idx = idx\n    end\n  end\n  \n  for idx\
    \ = 1, k do\n    result[idx] = arr[max_idx]\n    max_idx = max_idx + 1\n  end\n\
    \  \n  return result\nend", "    local i, j = 0, k - 1\n    local maxArr = {}",
  "    local max = {}\n    for i = 1, k do\n        table.insert(max, -math.inf)\n\
    \    end", "  local largest, count = {}, 0\n  for i = 1, #arr do\n    if arr[i]\
    \ > largest[k] then\n      largest[k] = arr[i]\n      count = 1\n    elseif arr[i]\
    \ == largest[k] then\n      count = count + 1\n    end\n  end\n  return largest,\
    \ count\nend", "  assert(k>0 and k<=#arr, 'Input error!')\n  \n  local max = 0\n\
    \  local result = {}\n  \n  -- O(n) time\n  for i=1,k do -- O(1) time\n    if\
    \ arr[i] > max then\n      max = arr[i]\n    end\n  end", "  -- Base Case\n  if\
    \ k == 0 then\n    return arr\n  end\n  \n  -- Solution using divide and conquer\
    \ method\n  local max_len = math.floor((k - 1) / 2)\n  local left_max = maximum(arr,\
    \ k)\n  local right_max = maximum(arr, max_len)\n  \n  -- Merge the two arrays\n\
    \  local result = {}\n  local new_len = 1\n  for i = 1, #left_max do\n    if left_max[i]\
    \ > right_max[i] then\n      result[new_len] = left_max[i]\n      new_len = new_len\
    \ + 1\n    else\n      result[new_len] = right_max[i]\n      new_len = new_len\
    \ + 1\n    end\n  end\n  \n  -- return the result array\n  return result\nend",
  "\tif k == 0 then\n\t\treturn arr\n\tend\n\tlocal arr1 = {}\n\tlocal i = 1\n\twhile\
    \ i < k do\n\t\tlocal m = 0\n\t\tlocal m1 = i\n\t\twhile m < k do\n\t\t\tm = m\
    \ + 1\n\t\t\tif arr[i - m] > arr[i - m + 1] then\n\t\t\t\tm1 = i - m\n\t\t\tend\n\
    \t\tend\n\t\tarr1 = table.insert(arr1, arr[i - m1])\n\t\ti = i + 1\n\tend\n\t\
    return arr1\nend", "  local max = 1\n  local max_arr = {} -- The array to store\
    \ the maximum k numbers\n  for i = 1, k do\n    max_arr[i] = 0\n  end\n  for i\
    \ = 1, #arr do\n    for j = 1, k do\n      if arr[i] > max_arr[j] then\n     \
    \   max_arr[j] = arr[i]\n      end\n    end\n  end\n  for i = 1, k do\n    if\
    \ max_arr[i] > max then\n      max = max_arr[i]\n    end\n  end\n  return max_arr\n\
    end", "  local out = {}\n  local cnt = 0\n  local max_value = nil\n  local max_idx\
    \ = nil\n  for i = 1, k do\n    max_idx = cnt\n    max_value = arr[max_idx]\n\
    \    for j = 1, k do\n      if arr[j] > max_value then\n        max_value = arr[j]\n\
    \        max_idx = j\n      end\n    end\n    out[#out + 1] = max_value\n    cnt\
    \ = cnt + 1\n  end\n  return out\nend", "  local maxArray = {}\n  local max =\
    \ arr[1]\n  local i = 1\n  while i <= k do\n    if max < arr[i] then\n      max\
    \ = arr[i]\n    end\n    maxArray[i] = max\n    i = i + 1\n  end\n  \n  return\
    \ maxArray\nend", "\tassert(k > 0, \"k must be positive\")\n\tassert(k < len(arr),\
    \ \"k must be less than or equal to len(arr)\")\n\tlocal sorted_arr = {}\n\tlocal\
    \ max_value = -1000\n\tfor _, v in ipairs(arr) do\n\t\tlocal cur_max = v\n\t\t\
    local max_pos = k\n\t\tfor i=max_pos-1,0,-1 do\n\t\t\tif cur_max > sorted_arr[i]\
    \ then\n\t\t\t\tsorted_arr[i], cur_max = cur_max, sorted_arr[i]\n\t\t\telse\n\t\
    \t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn sorted_arr\nend", "\tlocal _len\
    \ = #arr\n\tlocal max_count = 0\n\t\n\t-- Find the k most frequent items in the\
    \ array\n\tfor i = 1, k do\n\t\tlocal temp = 0\n\t\t\n\t\tfor j = 1, _len, 1 do\n\
    \t\t\tif arr[j] == arr[i] then\n\t\t\t\ttemp = temp + 1\n\t\t\tend\n\t\tend\n\t\
    \t\n\t\tif temp > max_count then\n\t\t\tmax_count = temp\n\t\tend\n\tend\n\t\n\
    \treturn max_count, arr\nend", "  local result = {} -- the result list\n  local\
    \ biggest, current -- biggest and current element\n  for i = 1, k do\n    biggest\
    \ = nil\n    current = nil\n    for j = 1, #arr do\n      if biggest == nil or\
    \ current < arr[j] then\n        biggest, current = current, arr[j]\n      else\n\
    \        break -- out of for loop\n      end\n    end\n    table.insert(result,\
    \ current)\n  end\n  return result\nend", "    local results = {}\n    local max\
    \ = arr[1]\n    for i = 2, k do\n        if arr[i] > max then\n            max\
    \ = arr[i]\n        end\n    end\n    for i = 1, k do\n        if arr[i] > max\
    \ then\n            results[i] = arr[i]\n        end\n    end\n    return results\n\
    end", "    if k > #arr then return nil end\n    if k == 0 then return arr end\n\
    \    local max_index = 1\n    local max_value = arr[max_index]\n    for i = 2,\
    \ k do\n        if arr[i] > max_value then\n            max_value = arr[i]\n \
    \           max_index = i\n        end\n    end\n    return arr[max_index]\nend",
  "    local max_so_far = {}\n    local max_so_far_index = 0\n    local max_length\
    \ = k\n    local length = 0", "  -- Write your code here.\n  assert(k > 0 and\
    \ k <= #arr)\n  if k == 0 then return arr\n  elseif k == 1 then return arr[1]\n\
    \  else\n    local result = {}\n    local max_so_far = arr[1]\n    for i=2,k do\n\
    \      if arr[i] > max_so_far then\n        max_so_far = arr[i]\n      end\n \
    \   end\n    result[1] = max_so_far\n    local i = 1\n    while i < k do\n   \
    \   result[i+1] = arr[i]\n      i = i + 1\n    end\n    result[k] = arr[k]\n \
    \   return result\n  end\nend", "    local max_num = arr[1]\n    local max_index\
    \ = 1\n    for i = 2, k do\n        if arr[i] > max_num then\n            max_num\
    \ = arr[i]\n            max_index = i\n        end\n    end\n    return arr[max_index\
    \ + 1]\nend", "    local maxNums, maxVals = {}, 0\n    for _, v in ipairs(arr)\
    \ do\n        if v > maxVals then\n            maxNums = {}\n            maxVals\
    \ = v\n        end\n        if k ~= nil then\n            if v > maxVals then\n\
    \                maxNums = {}\n                maxVals = v\n            end\n\
    \            if v == maxVals then\n                table.insert(maxNums, v)\n\
    \            end\n        end\n    end\n    return maxNums\nend", "  local max\
    \ = []\n  local maxcount = 0\n  for i = 1,k do\n    local num = 0\n    for j =\
    \ 1, #arr do\n      if arr[j] > num then\n        num = arr[j]\n      end\n  \
    \  end\n    table.insert(max, num)\n    maxcount = maxcount + 1\n    if maxcount\
    \ == k then\n      return max\n    end\n  end\n  return max\nend", "  local max_arr\
    \ = {} -- store the max numbers in each k\n  local k_index = math.ceil(k /2) --\
    \ index of k\n  local n = #arr -- total number of numbers in arr\n  \n  assert(k\
    \ > 0 and k <= n)\n  \n  for i=1,n-1 do\n    if arr[i] > max_arr[k_index] and\
    \ k_index > 0 then\n      max_arr[k_index] = arr[i]\n      k_index = k_index -\
    \ 1\n    elseif arr[i] > max_arr[k_index] then\n      max_arr[k_index] = arr[i]\n\
    \    end\n  end\n  \n  if k_index > 0 then\n    max_arr[k_index] = arr[n - 1]\n\
    \  else\n    max_arr[k_index] = arr[n - 1]\n  end\n  \n  return max_arr\nend\n\
    \  ", '  local ans = { }', '  if k < 1 then return end', "    if k > #arr then\n\
    \        return nil\n    end\n    if k == 1 then\n        return {arr[1]}\n  \
    \  end", "  -- Base case: when we have already sorted all elements, return the\
    \ sorted array.\n  if k == 1 then\n    return arr\n  end\n  -- If k is greater\
    \ than or equal to the length of arr then just return the\n  --  sorted array.\n\
    \  if k > #arr then\n    return arr\n  end\n  -- Otherwise, iterate through the\
    \ sorted array and find the max of\n  --  the current element and the next element\
    \ and replace the current element\n  --  with the max of the two.\n  local max1,\
    \ max2 = arr[1], arr[2]\n  for i = 2, #arr do\n    -- Compare arr[i] and arr[i-1]\
    \ to see if they are bigger. If they are \n    --  bigger, then save arr[i-1]\
    \ as the new max and arr[i] as the old max.\n    if arr[i] > max1 then\n     \
    \ max1, max2 = arr[i], max2\n    elseif arr[i] > max2 then\n      max1, max2 =\
    \ arr[i], max1\n    end\n  end\n  return max1 .. arr[k] .. max2\nend", "    local\
    \ sorted_arr = {}\n    local max_count = 0\n    for i=1,k do\n        local max_val\
    \ = -math.inf\n        for j=1,#arr do\n            if arr[j] > max_val then\n\
    \                max_val = arr[j]\n            end\n        end\n        table.insert(sorted_arr,\
    \ max_val)\n        if max_count == 0 and max_val > 0 then\n            max_count\
    \ = max_val\n        end\n    end\n    return sorted_arr\nend", "    if k > #arr\
    \ then\n        return nil\n    end", "\tif k > #arr then return arr end\n\tif\
    \ k == 0 then return arr end\n\tlocal newArr = {arr[1]}\n\tlocal rest = arr[2:]\n\
    \tfor i = 2, k do\n\t\tlocal current = newArr[1]\n\t\tfor _, v in ipairs(rest)\
    \ do\n\t\t\tif v > current then\n\t\t\t\tcurrent = v\n\t\t\tend\n\t\tend\n\t\t\
    newArr[#newArr + 1] = current\n\tend\n\treturn newArr\nend", "  if k == 0 then\n\
    \    return arr\n  end\n  local m = {}\n  for i = 1, k do\n    m[#m+1] = arr[i]\n\
    \  end\n  local res = {}\n  for i = 1, k do\n    res[i] = arr[math.max(1,i-1)]\n\
    \  end\n  return res\nend\n ", "    local maxElem = 0\n    local maxPos = 0\n\
    \    local maxNeg = 0\n    local len = 0\n    for i = 1, k do\n        if arr[i]\
    \ > arr[maxPos] then\n            maxPos = i\n        elseif arr[i] > arr[maxNeg]\
    \ then\n            maxNeg = i\n        elseif arr[i] > arr[maxElem] then\n  \
    \          maxElem = i\n        else\n            len = i\n        end\n    end\n\
    \    return maxElem, maxPos, maxNeg, len\nend", "   -- write your code here\n\
    \   return arr\nend", "  -- The length of arr.\n  local lenArr = #arr", "\tlocal\
    \ maxLength = 1\n\tlocal maxElement\n\tlocal maxElementValue = -1\n\tlocal newArray\
    \ = { }\n\tfor i = 1, k do\n\t\tlocal maxElementValue = -1\n\t\tlocal maxElementIndex\
    \ = -1\n\t\tlocal maxElementValueInArray\n\t\tfor j = 1, #arr do\n\t\t\tif arr[j]\
    \ > maxElementValue then\n\t\t\t\tmaxElementValue = arr[j]\n\t\t\t\tmaxElementValue\
    \ = j\n\t\t\t\tmaxElementIndex = j\n\t\t\tend\n\t\tend\n\t\tnewArray[maxElementIndex]\
    \ = arr[k]\n\t\tarr[k] = -1\n\t\tmaxLength += 1\n\tend\n\treturn newArray\nend",
  "    local out = {} --out: sorted list\n    local n = #arr\n    for i = 1, k do\n\
    \        local m\n        for j = 1+i, n, 1 do\n            if arr[j] > arr[j\
    \ - 1] then\n                m = j\n            end\n        end\n        table.insert(out,\
    \ arr[m])\n        n = n - 1\n    end\n    return out\nend", "    assert(k > 0\
    \ and k and #arr > 0 and #arr <= 1000, \"invalid input\")\n    local new_arr =\
    \ {}\n    for i = 1, k do\n        new_arr[i] = arr[1]\n    end\n    for i = 2,\
    \ #arr do\n        if arr[i] > new_arr[i] then\n            for j = 1, k do\n\
    \                new_arr[j] = arr[j]\n            end\n        end\n    end\n\
    \    return new_arr\nend", "  local ans = {}\n  for i = 1, k do\n    ans[i] =\
    \ arr[math.max(0, i - 1)]\n  end\n  for i = k, #arr do\n    ans[i] = arr[i - 1]\n\
    \  end\n  return ans\nend", "  if k == 0 then\n    return arr\n  end\n  local\
    \ m = math.floor(#arr / k)\n  local new_arr = {}\n  for i in 1, k do\n    local\
    \ max = 0\n    for j = 1, m do\n      if arr[j] > max then\n        max = arr[j]\n\
    \      end\n    end\n    new_arr[i] = max\n  end\n  return new_arr\nend", "  if\
    \ k > #arr or k < 1 then\n    return arr\n  end\n  \n  local new_arr = {arr[#arr]}\n\
    \  \n  for i = k, 1, -1 do\n    local min_value = new_arr[1]\n    \n    for j\
    \ = 1, #new_arr do\n      if new_arr[j] < min_value then\n        min_value =\
    \ new_arr[j]\n      end\n    end\n    \n    new_arr[1] = min_value\n    new_arr\
    \ = new_arr:sub(2)\n  end\n  \n  return new_arr\nend", "    if k > #arr then return\
    \ end\n    local i, j, max = 1, k, arr[1]\n    for i = 2, #arr do\n        if\
    \ arr[i] > max then\n            max = arr[i]\n            j = i\n        elseif\
    \ arr[i] < arr[j] and arr[i] > arr[j - 1] then\n            j = i\n        end\n\
    \    end\n    return arr[j]:reverse()\nend", "    if k == 0 then\n        return\
    \ arr\n    end\n    \n    local maxList = {}\n    local len = #arr\n    \n   \
    \ for idx = 1, k do\n        -- if the current item is not in the max list yet,\
    \ add it\n        if not(_G.G.include(maxList, arr[idx])) then\n            maxList[#maxList\
    \ + 1] = arr[idx]\n        end\n    end\n    \n    -- return the max list in the\
    \ end\n    return maxList\nend", "  if k > #arr then\n    return arr\n  else\n\
    \    if k == 1 then\n      local max = arr[1]\n      for i = 2, #arr do\n    \
    \    if arr[i] > max then\n          max = arr[i]\n        end\n      end\n  \
    \    return max\n    else\n      local max_val = -math.inf\n      local max_idx\
    \ = nil\n      for i = 1, k do\n        local cur_val = arr[i]\n        if cur_val\
    \ > max_val then\n          max_val = cur_val\n          max_idx = i\n       \
    \ end\n      end\n      return arr[(max_idx + 1):(#arr)]\n    end\n  end\nend",
  "    if k == 0 then\n        local result = {}\n        local index = 1\n      \
    \  for i = 1, #arr do\n            if arr[i] > arr[index] then\n             \
    \   result[index] = arr[i]\n                index = i\n            end\n     \
    \   end\n        return result\n    end\n    local big = math.inf\n    local result\
    \ = {}\n    for i = 1, k do\n        if #result < i then\n            result[i]\
    \ = arr[math.min(i, #arr)]\n        else\n            if arr[i] > big and arr[i]\
    \ > result[i] then\n                big = arr[i]\n            end\n        end\n\
    \    end\n    return result\nend", "\tif k > #arr then return arr end\n\tlocal\
    \ results = {}\n\tlocal i = 1\n\twhile i < k do\n\t\tlocal max_element = arr[1]\n\
    \t\tlocal max_i = 2\n\t\twhile max_i < k do\n\t\t\tlocal element = arr[max_i]\n\
    \t\t\tif element > max_element then\n\t\t\t\tmax_element = element\n\t\t\t\tmax_i\
    \ = max_i + 1\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\ttable.insert(results,\
    \ max_element)\n\t\ti = i + 1\n\tend\n\treturn results\nend", "    local i = 0\n\
    \    local j = 0\n    local max_ele = 0\n    while i < k and j < k do\n      \
    \  if arr[i] > arr[j] then\n            max_ele = arr[i]\n            i = i +\
    \ 1\n        else\n            max_ele = arr[j]\n            j = j + 1\n     \
    \   end\n    end\n    return max_ele\nend", "   assert(k > 0 and k <= #arr)\n\
    \   local max = {}\n   local maxIdx = {}\n   for idx = 1, k do\n      local value\
    \ = nil\n      if idx > 1 then\n         value = arr[maxIdx[idx-1]]\n      end\n\
    \      if value < arr[idx] then\n         value = arr[idx]\n      end\n      max[idx]\
    \ = value\n      maxIdx[idx] = idx\n   end\n   return maxIdx\nend", "\tlocal max\
    \ = []\n\tfor _, x in ipairs(arr) do\n\t\ttable.insert(max, x)\n\tend\n\ttable.sort(max)\n\
    \treturn max[k]\nend", "  local max,max_index = 0,0\n  local result,result_index\
    \ = {},{}\n  for index,value in ipairs(arr) do\n    if index > max_index then\
    \ \n      max_index = index\n      max = value\n    elseif value == max then\n\
    \      table.insert(result, max)\n      table.insert(result_index, index)\n  \
    \  end\n  end\n  if k > #result then\n    return nil\n  end\n  return result,result_index\n\
    end", "  if k == 0 then\n    return arr\n  end", "    if k > #arr then return\
    \ nil end\n    local result = {}\n    local maxValue = arr[1]\n    for i = 2,\
    \ k do\n        if arr[i] > maxValue then\n            maxValue = arr[i]\n   \
    \     end\n    end\n    for i = 1, k do\n        if arr[i] > maxValue then\n \
    \           result[i] = arr[i]\n        end\n    end\n    return result\nend",
  "  local maxList = {}\n  for i = 1, k do\n    if maxList[#maxList + 1] == nil then\n\
    \      maxList[#maxList + 1] = arr[i]\n    else\n      if arr[i] > maxList[#maxList]\
    \ then\n        maxList[#maxList] = arr[i]\n      end\n    end\n  end\n  return\
    \ maxList\nend", "  assert(k > 0, 'The k parameter should greater than 0.')\n\
    \  assert(k == nil or k > 1, 'The k parameter should less than or equal to 1.')\n\
    \  assert(k == nil or arr:len() >= k, 'The k parameter should less than or equal\
    \ to len(arr).')\n  assert(arr:len() >= 1, 'The input list should not be empty.')\n\
    \  local out = {}\n  for i = 1, arr:len() - k + 1 do\n    table.insert(out, -math.max(arr[i],\
    \ -arr[i]))\n  end\n  return out\nend", "  assert(k > 0 and k and #arr > 0, 'Input\
    \ k should be positive!')\n  local function helper(i, j, k)\n    if i >= j or\
    \ j >= k then\n      return arr[k]\n    end\n    return max(arr[i], arr[j]) or\
    \ helper(i + 1, j - 1, k)\n  end\n  return helper(0, 0, k)\nend", "  if k == 1\
    \ then\n    return arr\n  end\n  local biggest = arr[1]\n  for i = 2, #arr do\n\
    \    if biggest > arr[i] then\n      biggest = arr[i]\n    end\n  end\n  return\
    \ maximum(arr, k - 1) + biggest\nend", "    local result = {}\n    local count\
    \ = 0\n    for i = 1, k do\n        if arr[i] > arr[count] then\n            result[#result\
    \ + 1] = arr[i]\n            count = count + 1\n        elseif count == #result\
    \ then\n            count = count + 1\n        else\n            result[#result\
    \ + 1] = arr[count]\n        end\n    end\n    return result\nend", "  -- Use\
    \ an auxiliary data structure to store the current maximum\n  local curMax = -10000\n\
    \  local curMaxIndex = -1\n  -- Create a temporary storage to store the current\
    \ maximum number\n  local tmp = nil\n  for i = 1, k do\n    -- Reset the temp\
    \ storage if the current max number is greater than the max number\n    if arr[i]\
    \ > tmp then\n      tmp = arr[i]\n      curMaxIndex = i\n    end\n  end\n  return\
    \ arr[curMaxIndex + 1] -- Return the current maximum number\nend", "    if k ==\
    \ 0 then\n        return arr\n    end\n    if k == 1 then\n        return arr[1]\n\
    \    end\n    local arr = arr\n    local max_arr = []\n    local max_num = arr[1]\n\
    \    local max_idx = 1\n    for idx = 2, k do\n        local temp = 0\n      \
    \  for i = 1, idx do\n            temp = temp + arr[i]\n        end\n        if\
    \ temp > max_num then\n            max_num = temp\n            max_arr = arr\n\
    \            max_idx = idx\n        end\n    end\n    return max_arr\nend\nprint(maximum(arr))\n\
    end", "  local arrLen = 0\n  for i = 1, k do\n    arrLen = arrLen + 1\n  end\n\
    \  arrLen = arrLen + k\n  local sortedArr = [arrLen]\n  local count = 1\n  for\
    \ i = 1, k do\n    if arr[i] > sortedArr[count + 1] - 1 then\n      count = count\
    \ + 1\n      sortedArr[count] = arr[i]\n    else\n      count = count + 1\n  \
    \    sortedArr[count] = sortedArr[count - 1]\n    end\n  end\n  return sortedArr\n\
    end", "  assert(k and #arr >= k, 'bad argument: k')\n  \n  local result = {}\n\
    \  local pos = k + 1\n  \n  while pos <= #arr do\n    local value = arr[pos]\n\
    \    if value < arr[pos+1] then\n      table.insert(result, value)\n    end\n\
    \    pos = pos + 1\n  end\n  \n  return result\nend", "    if k == nil then k\
    \ = 0 end\n    local maxArr = {} -- to store the maximum of array (all elements\
    \ are initialized to nil)\n    local maxValue = nil\n    local index = 0", " \
    \ assert(k > 0)\n  assert(k == 1 or k == 2)", '    local result = {}', "  local\
    \ sorted_arr = {}\n  local max_num = math.max(arr[1], arr[2])\n  for i=3,k,1 do\n\
    \    local num = math.max(arr[i], arr[i-1], arr[i-2], arr[i-3])\n    if num >\
    \ max_num then\n      max_num = num\n    end\n  end\n  if k == 1 then\n    sorted_arr[1]\
    \ = max_num\n    return sorted_arr\n  end\n  local new_arr = {max_num}\n  for\
    \ i=2,k,1 do\n    local num = math.max(arr[i], arr[i-1], arr[i-2], arr[i-3])\n\
    \    new_arr[i] = num\n  end\n  sorted_arr = new_arr\n  return sorted_arr\nend",
  "    if k > #arr then\n        return arr\n    end\n    local max_so_far = arr[k]\n\
    \    local max_at = k\n    for i=k+1,#arr do\n        if arr[i] > max_so_far then\n\
    \            max_so_far = arr[i]\n            max_at = i\n        end\n    end\n\
    \    return arr[k]:gsub('%d*',tostring(max_so_far))..tostring(max_at)\nend", " \
    \ if k == nil then k = #arr end\n  local new_arr = {}\n  for i = 1, k do\n   \
    \ local max_idx = 1\n    for j = 1, k do\n      if arr[j] < arr[max_idx] then\n\
    \        max_idx = j\n      end\n    end\n    new_arr[i] = arr[max_idx]\n  end\n\
    \  return new_arr\nend", "\tassert(k > 0 and k and arr, \"Invalid input\")\n\t\
    local size = #arr\n\tlocal maxArr\n\tif k == 1 then\n\t\tmaxArr = arr\n\telse\n\
    \t\tmaxArr = {}\n\t\tfor i = 1,k do\n\t\t\tlocal tmp = {}\n\t\t\tfor j = 1,size\
    \ do\n\t\t\t\tif arr[j] >= arr[tmp[1]] then\n\t\t\t\t\ttable.insert(tmp, j)\n\t\
    \t\t\tend\n\t\t\tend\n\t\t\tmaxArr = table.concat(maxArr, tmp)\n\t\tend\n\tend\n\
    \treturn maxArr\nend", "    local ans = {}\n    local size = #arr\n    local i,\
    \ j, index\n    for i = 1, k do\n        -- First pass.\n        ans[i] = -1000\n\
    \        index = 1\n        \n        -- Second pass.\n        while index < size\
    \ do\n            j = index + 1\n            \n            -- For each element\
    \ in the subarray arr[i] to arr[j],\n            -- compare it with the maximum\
    \ element in the previous subarray.\n            while j < size do\n         \
    \       local element = arr[j]\n                if element > ans[i] then\n   \
    \                 ans[i] = element\n                    index = j\n          \
    \      end\n                j = j + 1\n            end\n        end\n    end\n\
    \    return ans\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
