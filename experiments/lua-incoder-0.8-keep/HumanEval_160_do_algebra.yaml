name: HumanEval_160_do_algebra
language: lua
prompt: "-- Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n-- the second list is a list of integers. Use the two given\
  \ lists to build the algebric \n-- expression and return the evaluation of this\
  \ expression.\n-- The basic algebra operations:\n-- Addition ( + ) \n-- Subtraction\
  \ ( - ) \n-- Multiplication ( * ) \n-- Floor division ( // ) \n-- Exponentiation\
  \ ( ** ) \n-- Example:\n-- operator['+', '*', '-']\n-- array = [2, 3, 4, 5]\n--\
  \ result = 2 + 3 * 4 - 5\n-- => result = 9\n-- Note:\n-- The length of operator\
  \ list is equal to the length of operand list minus one.\n-- Operand is a list of\
  \ of non-negative integers.\n-- Operator list has at least one operator, and operand\
  \ list has at least two operands.\nlocal function do_algebra(operator, operand)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = do_algebra\n\
  \    lu.assertEquals(candidate({'**', '*', '+'}, {2, 3, 4, 5}), 37)\n    lu.assertEquals(candidate({'+',\
  \ '*', '-'}, {2, 3, 4, 5}), 9)\n    lu.assertEquals(candidate({'//', '*'}, {7, 3,\
  \ 4}), 8)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tif #operand ~= #operator then\n\t\tprint('Incorrect operand or operator\
    \ number')\n\t\treturn nil\n\tend\n\tif #operand == 1 then\n\t\treturn operand[1]\n\
    \telse\n\t\tlocal result_exp = 1\n\t\tfor i = 1, #operand do\n\t\t\tresult_exp\
    \ = result_exp * operand[i] \n\t\tend\n\t\tresult_exp = result_exp ^ -1\n\t\t\
    local result = operand[1]\n\t\tfor i = 2, #operand do\n\t\t\tresult = operator[operator[1]](result,\
    \ operand[i])\n\t\tend\n\t\treturn result\n\tend\nend", "  local length = #operand\
    \ + #operator - 1\n  local operators = {}\n  local index = 1\n  \n  -- Fill in\
    \ the operator list\n  for i = 1, #operator do\n    table.insert(operators, operator[i])\n\
    \    index = index + 1\n    if index <= length then\n      table.insert(operators,\
    \ nil)\n    end\n  end\n  \n  -- Fill in the operand list \n  for i = 1, #operand\
    \ do\n    table.insert(operators, operand[i])\n  end\n  \n  -- Return the result\n\
    \  return operators[#operator]\nend", "    local result = 0\n    for i = 1, #operator\
    \ do\n        local op = operator[i]\n        local p = operand[i-1]\n       \
    \ if op == \"-\" then\n            result = result - p\n        elseif op == \"\
    +\" then\n            result = result + p\n        elseif op == \"*\" then\n \
    \           result = result * p\n        elseif op == \"/\" then\n           \
    \ result = result / p\n        elseif op == \"//\" then\n            result =\
    \ result // p\n        elseif op == \"**\" then\n            result = result ^\
    \ p\n        else\n            result = nil\n        end\n    end\n    return\
    \ result\nend", "\tlocal function do_op_by_op(operator, operand)\n\t\tlocal result\
    \ = {}\n\t\tfor i=1,#operator do\n\t\t\tlocal op = operator[i]\n\t\t\tlocal op_operand\
    \ = operand[i]\n\t\t\tlocal op_value = op_operand * op\n\t\t\ttable.insert(result,\
    \ op_value)\n\t\tend\n\t\treturn table.concat( result, 0 )\n\tend\n\tlocal function\
    \ do_op_by_ops(operator, operand)\n\t\tlocal result = {}\n\t\tfor i=1,#operator\
    \ do\n\t\t\tlocal op = operator[i]\n\t\t\tlocal op_operand = operand[i]\n\t\t\t\
    local op_value = do_op_by_op(op, op_operand)\n\t\t\ttable.insert(result, op_value)\n\
    \t\tend\n\t\treturn table.concat( result, 0 )\n\tend", "  -- Add some code here.\n\
    \  local op = operator[#operator]\n  local res = #operand[1]\n  local i = 1\n\
    \  while i < #operand do\n    if op == \"+\" then\n      res = res + operand[1]\n\
    \    elseif op == \"*\" then\n      res = res * operand[1]\n    elseif op == \"\
    -\" then\n      res = res - operand[1]\n    elseif op == \"//\" then\n      res\
    \ = res // operand[1]\n    elseif op == \"**\" then\n      res = res ^ operand[1]\n\
    \    end\n    i = i + 1\n  end\n  return res\nend", "  local function do_add(op,\
    \ x)\n    return op(x, operand[1]) + do_algebra(op, nil, operand[2:])\n  end\n\
    \  local function do_sub(op, x)\n    return op(x, operand[1]) - do_algebra(op,\
    \ nil, operand[2:])\n  end\n  local function do_mul(op, x)\n    return op(x, operand[1])\
    \ * do_algebra(op, nil, operand[2:])\n  end\n  local function do_div(op, x)\n\
    \    return op(x, operand[1]) // do_algebra(op, nil, operand[2:])\n  end\n  local\
    \ function do_exp(op, x)\n    return op(x, operand[1]) ^ do_algebra(op, nil, operand[2:])\n\
    \  end\n  local do_rest\n  if #operator == 2 then\n    do_rest = do_add\n  elseif\
    \ #operator == 3 then\n    do_rest = do_mul\n  elseif #operator == 4 then\n  \
    \  do_rest = do_div\n  else\n    do_rest = do_exp\n  end\n  return do_rest\nend",
  "    local temp = 0\n    for i = 0, #operand - 1 do\n        temp = temp + operand[i]\
    \ * operator[i]\n    end\n    return temp\nend", "   local result = 0\n   for\
    \ i = 0, #operand - 1 do\n      result = result + operand[i] * operator[i]\n \
    \  end\n   return result\nend", "\tlocal result = 1\n\tlocal count = 0\n\tlocal\
    \ is_variable = false\n\tfor index, value in ipairs(operand) do\n\t\tif count\
    \ < 2 then\n\t\t\tif operator[count] ~= '^' then\n\t\t\t\tresult = result .. value\n\
    \t\t\telse\n\t\t\t\tresult = result ^ value\n\t\t\tend\n\t\telse\n\t\t\tif operator[count]\
    \ == '^' then\n\t\t\t\tif is_variable then\n\t\t\t\t\tresult = result ^ value\n\
    \t\t\t\telse\n\t\t\t\t\tresult = result ^ value\n\t\t\t\tend\n\t\t\telse\n\t\t\
    \t\tif is_variable then\n\t\t\t\t\tresult = result ^ value\n\t\t\t\telse\n\t\t\
    \t\t\tresult = result ^ value\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tcount = count\
    \ + 1\n\t\tif count == #operator then\n\t\t\tbreak\n\t\tend\n\t\tis_variable =\
    \ true\n\tend\n\treturn result\nend", "  -- Base case:\n  if not operator  or\
    \ not operand then\n    return nil\n  end", "    local function add(lhs, rhs)\n\
    \        if lhs == nil then\n            return rhs\n        elseif rhs == nil\
    \ then\n            return lhs\n        else\n            return lhs + rhs\n \
    \       end\n    end\n    local function sub(lhs, rhs)\n        if lhs == nil\
    \ then\n            return -rhs\n        elseif rhs == nil then\n            return\
    \ -lhs\n        else\n            return lhs - rhs\n        end\n    end\n   \
    \ local function mul(lhs, rhs)\n        if lhs == nil then\n            return\
    \ 0\n        elseif rhs == nil then\n            return 0\n        else\n    \
    \        return lhs * rhs\n        end\n    end\n    local function div(lhs, rhs)\n\
    \        if lhs == nil then\n            return 0\n        elseif rhs == nil then\n\
    \            return 0\n        else\n            return lhs / rhs\n        end\n\
    \    end\n    local function pow(lhs, rhs)\n        if lhs == nil then\n     \
    \       return 0\n        elseif rhs == nil then\n            return 0\n     \
    \   else\n            return lhs ^ rhs\n        end\n    end\n    local function\
    \ exp(lhs, rhs)\n        if lhs == nil then\n            return 0\n        elseif\
    \ rhs == nil then\n            return 0\n        else\n            return pow(lhs,\
    \ rhs)\n        end\n    end\n    local function eval(lhs, rhs)\n        if lhs\
    \ == nil then\n            return 0\n        elseif rhs == nil then\n        \
    \    return 0\n        else\n            if lhs == 0 then\n                return\
    \ rhs == 0 and -1 or 1\n            else\n                return (operator[operator](eval(sub(rhs,\
    \ lhs), lhs), eval(add(rhs, lhs), lhs))) \n            end\n        end\n    end\n\
    \    local function get_val(lhs)\n        if lhs == nil then\n            return\
    \ 0\n        elseif rhs == nil then\n            return 0\n        else\n    \
    \        return lhs\n        end\n    end\n    return eval(get_val(operand[#operand]),\
    \ get_val(operand[#operand] + 1))\nend", "  local result\n  for i = 1, #operand\
    \ do\n    if operator[i] == '+' then\n      result = result + operand[i]\n   \
    \ elseif operator[i] == '-' then\n      result = result - operand[i]\n    elseif\
    \ operator[i] == '*' then\n      result = result * operand[i]\n    elseif operator[i]\
    \ == '/' then\n      result = result // operand[i]\n    elseif operator[i] ==\
    \ '^' then\n      result = result ^ operand[i]\n    end\n  end\n  return result\n\
    end", "  if #operator == 0 then return nil end\n  if #operand == 0 then return\
    \ nil end\n  local expr = {}\n  for i = 1, #operator do\n    local op\n    local\
    \ op = operator[i]\n    if op == \"+\" then\n      expr[i] = operand[#operand]\
    \ + operand[#operand+1]\n    elseif op == \"-\" then\n      expr[i] = operand[#operand]\
    \ - operand[#operand+1]\n    elseif op == \"*\" then\n      expr[i] = operand[#operand]\
    \ * operand[#operand+1]\n    elseif op == \"//\" then\n      expr[i] = operand[#operand]\
    \ // operand[#operand+1]\n    elseif op == \"**\" then\n      expr[i] = operand[#operand]\
    \ ** operand[#operand+1]\n    end\n  end\n  return expr\nend", "\tlocal res =\
    \ {}\n\tlocal i = 0\n\t\n\tfor i = 1, #operator do\n\t\tlocal op = operator[i]\n\
    \t\tlocal res = res\n\t\t\n\t\tfor j = 1, #operand do\n\t\t\tif j > i then\n\t\
    \t\t\tres = res[op] + operand[j]\n\t\t\telse\n\t\t\t\tres = res[op]\n\t\t\tend\n\
    \t\tend\n\tend\n\t\n\treturn res\nend", "  local result = 0\n  for _, v in ipairs(operand)\
    \ do\n    result = result + v\n  end\n  for _, v in ipairs(operator) do\n    result\
    \ = v * result\n  end\n  return result\nend", "  local function do_operator(operator,\
    \ operand)\n    local result = operand[1]\n    for i = 2, #operand do result =\
    \ operator[i](result, operand[i]) end\n    return result\n  end\n  return do_operator(operator,\
    \ operand)\nend", "\tlocal expression = operand[1]\n\tfor i = 2, #operand do\n\
    \t\tlocal operator = operator\n\t\tlocal operand = operand[i]\n\t\texpression\
    \ = expression[operator](expression, operand)\n\tend\n\treturn expression\nend",
  "    local op = {}\n    for i = 1, #operator - 1 do\n        local a = operand[i]\n\
    \        local op = operator[i]\n        local b = operand[i + 1]\n        local\
    \ c = operand[i + 2]\n        if op == \"+\" then\n            local result =\
    \ a + b\n            if c ~= nil then\n                -- If the next operation\
    \ is non-negative, return it directly.\n                if c > 0 then\n      \
    \              return result\n                else\n                    -- If\
    \ next operation is negative, use it.\n                    local neg = true\n\
    \                    local result = a * b\n                    local c2 = c <\
    \ 0\n                    if c2 then\n                        -- Negate the result.\n\
    \                        result = - result\n                        neg = false\n\
    \                    end\n                    return result * neg\n          \
    \      end\n            else\n                return result\n            end\n\
    \        elseif op == \"-\" then\n            local result = a - b\n         \
    \   if c ~= nil then\n                -- If the next operation is non-negative,\
    \ return it directly.\n                if c > 0 then\n                    return\
    \ result\n                else\n                    -- If next operation is negative,\
    \ use it.\n                    local neg = true\n                    local result\
    \ = a * b\n                    local c2 = c < 0\n                    if c2 then\n\
    \                        -- Negate the result.\n                        result\
    \ = - result\n                        neg = false\n                    end\n \
    \                   return result * neg\n                end\n            else\n\
    \                return result\n            end\n        elseif op == \"*\" then\n\
    \            local result = a * b\n            if c ~= nil then\n            \
    \    -- If the next operation is non-negative, return it directly.\n         \
    \       if c > 0 then\n                    return result\n                else\n\
    \                    -- If next operation is negative, use it.\n             \
    \       local neg = true\n                    local result = a * c\n         \
    \           local c2 = c < 0\n                    if c2 then\n               \
    \         -- Negate the result.\n                        result = - result\n \
    \                       neg = false\n                    end\n               \
    \     return result * neg\n                end\n            else\n           \
    \     return result\n            end\n        elseif op == \"/\" then\n      \
    \      local result = a / b\n            if c ~= nil then\n                --\
    \ If the next operation is non-negative, return it directly.\n               \
    \ if c > 0 then\n                    return result\n                else\n   \
    \                 -- If next operation is negative, use it.\n                \
    \    local neg = true\n                    local result = a / c\n            \
    \        local c2 = c < 0\n                    if c2 then\n                  \
    \      -- Negate the result.\n                        result = - result\n    \
    \                    neg = false\n                    end\n                  \
    \  return result * neg\n                end\n            else\n              \
    \  return result\n            end\n        elseif op == \"", "    local operator_count\
    \ = #operator\n    local result_operator_count = #operand\n    local result =\
    \ 1\n    for i = 1, #operand do\n        result = result * (operator[i - 1] ~=\
    \ operand[i]) * (operand[i])\n    end\n    if #operand == 1 then\n        result\
    \ = -result\n    end\n    local result_operand = operand[1]\n    if #operand >\
    \ 1 then\n        result = -result\n    end\n    if operator_count = #result_operator_count\
    \ then\n        result = -result\n    end\n    return result, result_operand\n\
    end", "    local res = {}\n    for i = 1, #operator - 1 do\n        local left\
    \ = res[i - 1]\n        local right = operand[i]\n        if operator[i] == '+'\
    \ then\n            left = left + right\n        elseif operator[i] == '-' then\n\
    \            left = left - right\n        elseif operator[i] == '*' then\n   \
    \         left = left * right\n        elseif operator[i] == '//' then\n     \
    \       left = left // right\n        elseif operator[i] == '**' then\n      \
    \      left = left ** right\n        end\n        res[i + 1] = left\n    end\n\
    \    return res[#res]\nend", "    assert(type(operator) == 'table' and #operator\
    \ == #operand)\n    -- No need for error handling because arithmetic is assumed.\n\
    \    -- This code relies on the fact that all valid operands are non-negative\
    \ integers.\n    return operand[1]\nend", "\tlocal result = 0\n\tfor _, v in pairs(operand)\
    \ do\n\t\tresult = v * operator\n\tend\n\treturn result\nend", "  if #operator\
    \ < 1 or #operand < 1 then\n    return nil\n  end", "    local result = 0\n  \
    \  for i = 1, #operator do\n        result = result + operand[#operand + i - 1]\
    \ * operator[i]\n    end\n    return result\nend", "\t-- Initialise the result\
    \ to 0.\n\t-- Initialise the total to 0.\n\t-- Iterate through the operator list\
    \ to compute the result.\n\t-- Iterate through the operand list to compute the\
    \ total.\n\tlocal result = 0\n\tlocal total = 0\n\tfor i in ipairs(operator) do\n\
    \t\t-- Add the operator (i+1) to the total and evaluate it.\n\t\ttotal = total\
    \ + i\n\t\tif i == 1 then\n\t\t\t-- If we're on the first operator, multiply the\
    \ operand by itself and evaluate the total.\n\t\t\tresult = result * operand[#operand]\n\
    \t\t\tresult = result + total\n\t\telse\n\t\t\t-- Otherwise, multiply the operand\
    \ by the current total and evaluate the total.\n\t\t\tresult = result * total\n\
    \t\t\tresult = result + operand[#operand]\n\t\tend\n\tend\n\t-- Return the final\
    \ result.\n\treturn result\nend", "   local result, operation\n   for _, operation\
    \ in ipairs(operator) do\n      if operand[#operand] == nil then\n         --\
    \ operation is an unary operation\n         if operation == \"-\" then\n     \
    \       -- If operand list is empty, return the evaluation of the negation of\
    \ the\n            -- expression. Otherwise, return the negative of the evaluated\
    \ expression.\n            if #operand == 0 then\n               return \"-\"\n\
    \            else\n               return \"-\" + do_algebra(operator, operand)\n\
    \            end\n         else\n            -- Evaluate the expression.\n   \
    \         operand[#operand] = do_algebra(operation, operand)\n         end\n \
    \     else\n         -- operand list is not empty\n         -- operation is an\
    \ arithmetic operation\n         if #operand == 1 then\n            -- If operand\
    \ list is empty, return the evaluation of that operand.\n            if #operand\
    \ == 0 then\n               return operand[1]\n            else\n            \
    \   -- If there is more than one operand and at least one is a variable, \n  \
    \             -- then evaluate the expression.\n               if #operand > 1\
    \ then\n                  if #operand==2 then\n                     -- If there\
    \ is only one operand, then evaluate it as the variable \n                   \
    \  -- name.\n                     return operand[1]\n                  else\n\
    \                     -- If there are more than one operand, use arithmetic operation.\
    \ \n                     -- Operator list has one element, and operand list has\
    \ two elements.\n                     -- The element at index 1 of operand list\
    \ is evaluated as the variable\n                     -- name. The element at index\
    \ 2 of operand list is evaluated as the \n                     -- operand.\n \
    \                    return \"(\" .. operation .. \" \" .. do_algebra(operator,\
    \ operand) .. \")\"\n                  end\n               else\n            \
    \      -- If there is only one operand, then evaluate it as the variable \n  \
    \                -- name.\n                  return operand[1]\n             \
    \  end\n            end\n         else\n            -- If there is more than one\
    \ operand and at least one is a variable, \n            -- then evaluate the expression.\n\
    \            if #operand > 1 then\n               if #operand==2 then\n      \
    \            -- If there is only one operand, then evaluate it as the variable\
    \ \n                  -- name.\n                  return operand[1]\n        \
    \       else\n                  -- If there are more than one operand, use arithmetic\
    \ operation. \n                  -- Operator list has one element, and operand\
    \ list has two elements.\n                  -- The element at index 1 of operand\
    \ list is evaluated as the variable\n                  -- name. The element at\
    \ index 2 of operand list is evaluated as the \n                  -- operand.\n\
    \                  return \"(\" .. operation .. \" \" .. do_algebra(operator,\
    \ operand) .. \")\"\n               end\n            else\n               -- If\
    \ there is only one operand, then evaluate it as the variable \n", "    local\
    \ result = 0\n    for i = 1, #operator do\n        result = result + (operand[#operand]\
    \ - 1) * operator[i]\n    end\n    return result\nend", "  local result\n  if\
    \ type(operator) ~= 'table' then\n    error('Operator should be table.')\n  end",
  "  local operator_list = operator\n  local result = operand[1]\n  for i=1, #operand\
    \ do\n    local operand = operand[i]\n    result = eval(operator .. operator ..\
    \ \"(\" .. operand .. \")\", result)\n  end\n  return result\nend", "    local\
    \ index = 1\n    local expression = nil\n    local result = nil\n    if #operand\
    \ < 2 then\n        return nil\n    end\n    for i = 1, #operator do\n       \
    \ local op = operator[i]\n        local x = operand[index]\n        local y =\
    \ operand[index + 1]\n        \n        if op == \"+\" then\n            expression\
    \ = x + y\n        elseif op == \"-\" then\n            expression = x - y\n \
    \       elseif op == \"*\" then\n            expression = x * y\n        elseif\
    \ op == \"/\" then\n            if y ~= 0 then\n                expression = x\
    \ / y\n            else\n                expression = x\n            end\n   \
    \     elseif op == \"**\" then\n            if y ~= 0 then\n                expression\
    \ = x ^ y\n            else\n                expression = x\n            end\n\
    \        end\n        index = index + 2\n        result = expression\n    end\n\
    \    return result\nend", "   -- We must make sure both operand and operator lists\
    \ are non-empty.\n   if #operand == 0 then return nil end\n   if #operator ==\
    \ 0 then return nil end\n   -- If the length of operand list is one less than\
    \ the length of operator list then there\n   -- was an error and we have to report\
    \ it.\n   if #operand > #operator then \n      error(\"Invalid operand list: \"\
    \ .. #operand .. \" elements while operator list has only \" .. #operator .. \"\
    \ elements.\")\n   end\n   local sum = 0\n   for i=1, #operand do\n      -- We\
    \ must use arithmetic operators only in operand list and only in operator list.\n\
    \      if operator[i] == \"+\" then\n         sum = sum + operand[i]\n      elseif\
    \ operator[i] == \"-\" then\n         sum = sum - operand[i]\n      elseif operator[i]\
    \ == \"*\" then\n         sum = sum * operand[i]\n      elseif operator[i] ==\
    \ \"/\" then\n         -- We use floor division if both operands are integers.\n\
    \         if type(operand[i]) == 'number' and type(operand[i+1]) == 'number' then\n\
    \            sum = sum // operand[i]\n         else\n            sum = sum --\
    \ Floor division between two non-integer types.\n         end\n      elseif operator[i]\
    \ == \"**\" then\n         -- We use exponentiation only if operand and operator\
    \ are numbers.\n         if type(operand[i]) == 'number' then\n            sum\
    \ = sum ** operand[i]\n         end\n      end\n   end\n   return sum\nend\n</code>\n\
    Example of usage:\n<code>", "   -- TODO: Write your code here.\nend", "    local\
    \ result\n    if type(operator[1]) == \"table\" then\n        if #operand > #operator[1]\
    \ then\n            error(\"Too many operands!\", 2)\n        else\n         \
    \   local op1 = operator[1][#operator[1]]\n            if op1 ~= nil then\n  \
    \              local op2 = operator[2][#operator[2]]\n                if op2 ~=\
    \ nil then\n                    if type(op1) == \"string\" then\n            \
    \            -- TODO: error handling\n                        result = 0\n   \
    \                 else\n                        result = op1 + op2\n         \
    \           end\n                else\n                    error(\"No operand\
    \ 2!\", 2)\n                end\n            else\n                error(\"No\
    \ operand 1!\", 2)\n            end\n        end\n    else\n        error(\"Invalid\
    \ operator!\", 2)\n    end\n    return result\nend", "\t-- We use two stacks to\
    \ keep track of both operands and operators\n\tlocal stack1, stack2 = {}, {}\n\
    \tlocal operator_index = 0\n\t-- We iterate through both lists in parallel\n\t\
    for i, op in pairs(operator) do\n\t\t-- Push the current operator onto the stack\n\
    \t\tstack1[#stack1 + 1] = op\n\t\t-- We check the first operand for the operator\n\
    \t\tif operand[i] ~= nil then\n\t\t\t-- If there is an operator, we apply it\n\
    \t\t\tif stack1[#stack1] ~= nil then\n\t\t\t\t-- If the current operator is positive,\
    \ push operand onto the stack\n\t\t\t\tif op == \"+\" then\n\t\t\t\t\tstack2[#stack2\
    \ + 1] = operand[i]\n\t\t\t\t-- If the current operator is negative, pop operand,\
    \ push it to the stack, and negate the current operator\n\t\t\t\telseif op ==\
    \ \"-\" then\n\t\t\t\t\tstack2[#stack2 + 1] = -operand[i]\n\t\t\t\t\tstack1[#stack1\
    \ + 1] = op\n\t\t\t\t-- If current operator is 0, push the current operand to\
    \ the stack\n\t\t\t\telseif op == \"0\" then\n\t\t\t\t\tstack2[#stack2 + 1] =\
    \ operand[i]\n\t\t\t\t-- If current operator is 1 or -1, push the current operand\
    \ and negate it to the stack\n\t\t\t\telseif op == \"+\" or op == \"-\" then\n\
    \t\t\t\t\tstack2[#stack2 + 1] = -operand[i]\n\t\t\t\t\tstack1[#stack1 + 1] = op\n\
    \t\t\t\t-- If current operator is *, pop the top two elements from the stack,\
    \ and push the result onto the stack\n\t\t\t\telseif op == \"*\" then\n\t\t\t\t\
    \tlocal value1 = stack1[#stack1]\n\t\t\t\t\tlocal value2 = stack2[#stack2]\n\t\
    \t\t\t\tstack2[#stack2 + 1] = (value1 * value2)\n\t\t\t\t\tstack1[#stack1 + 1]\
    \ = op\n\t\t\t\t-- If current operator is /, pop the top two elements from the\
    \ stack, and push the result onto the stack\n\t\t\t\telseif op == \"/\" then\n\
    \t\t\t\t\tlocal value1 = stack1[#stack1]\n\t\t\t\t\tlocal value2 = stack2[#stack2]\n\
    \t\t\t\t\tstack2[#stack2 + 1] = (value1 / value2)\n\t\t\t\t\tstack1[#stack1 +\
    \ 1] = op\n\t\t\t\t-- If current operator is ^, pop the top two elements from\
    \ the stack, and push the result onto the stack\n\t\t\t\telseif op == \"^\" then\n\
    \t\t\t\t\tlocal value1 = stack1[#stack1]\n\t\t\t\t\tlocal value2 = stack2[#stack2]\n\
    \t\t\t\t\tstack2[#stack2 + 1] = (value1 ^ value2)\n\t\t\t\t\tstack1[#stack1 +\
    \ 1] = op\n\t\t\t\t-- If current operator is %, pop the top two elements from\
    \ the stack, and push the result onto the ", "\t-- If operand list length is zero,\
    \ return operand list\n\t-- (The only operator list would be empty list, not nil)\n\
    \tif #operand == 0 then\n\t\treturn operand\n\tend", "    local res = 0\n    for\
    \ i = 1, #operator do\n        local operation = operator[i]\n        local operand1\
    \ = operand[i - 1]\n        local operand2 = operand[i]\n        if operation\
    \ == \"+\" then\n            res = res + operand1\n        elseif operation ==\
    \ \"-\" then\n            res = res - operand1\n        elseif operation == \"\
    *\" then\n            res = res * operand1\n        elseif operation == \"//\"\
    \ then\n            res = res // operand1\n        elseif operation == \"**\"\
    \ then\n            res = res ^ operand1\n        end\n    end\n    return res\n\
    end", "  local expr = {}\n  for i, op in pairs(operator) do\n    local left =\
    \ operand[i]\n    local right = operand[i+1]\n    local op = op\n    local op\
    \ = tonumber(op)\n    if op > 0 and op < 5 then\n      if op == 1 then\n     \
    \   expr = expr .. '(' .. left .. '+ ' .. right .. ')'\n      elseif op == 2 then\n\
    \        expr = expr .. '(' .. left .. '- ' .. right .. ')'\n      elseif op ==\
    \ 3 then\n        expr = expr .. '(' .. left .. ' * ' .. right .. ')'\n      elseif\
    \ op == 4 then\n        expr = expr .. '(' .. left .. ' // ' .. right .. ')'\n\
    \      elseif op == 5 then\n        expr = expr .. '(' .. left .. ' ** ' .. right\
    \ .. ')'\n      else\n        print('error')\n      end\n    else\n      expr\
    \ = expr .. ' ' .. op\n    end\n  end\n  return expr\nend", "  local alg = { }\n\
    \  for i=0,#operand-1 do \n    if operator[i] ~= '^' then\n      alg[operator[i]]\
    \ = operand[i] \n    end\n  end\n  return alg\nend", "  local result = operand[1]\n\
    \  local length = #operand\n  local i = 2\n  for i = 2, length do\n    result\
    \ = operator[operator](result, operand[i])\n  end\n  return result\nend\n</cell>\n\
    <text>\nExercise: Write a function that takes a list 'operation' which is a list\
    \ of two operators as defined above and a list of integers and returns the evaluated\
    \ result of the list using the above operators.", "    assert(#operator == #operand)\n\
    \    local value = 0\n    for i = 1, #operator do\n        value = value + operand[i-1]\
    \ * operator[i]\n    end\n    return value\nend", "\tlocal op_len = #operator\
    \ - 1\n\tlocal operand_len = #operand - 2\n\tlocal result = 0\n\tif op_len > 0\
    \ and operand_len > 0 then\n\t\tfor i=0,operand_len-1 do\n\t\t\tlocal left = operand[i]\n\
    \t\t\tlocal right = operand[i+1]\n\t\t\tlocal op = operator[i]\n\t\t\tresult =\
    \ math.fadd(left, right)\n\t\t\tresult = math.fmul(result, op)\n\t\tend\n\tend\n\
    \treturn result\nend", "\t-- assert(operator:len() > 1, 'Invalid operator: operator\
    \ list must have at least one element.')\n\t-- assert(operand:len() > 2, 'Invalid\
    \ operand: operand list must have at least two elements.')\n\t-- assert(type(operand[1])\
    \ == 'number', 'Invalid operand: operand element must be number.')\n\t-- assert(type(operator[1])\
    \ == 'string', 'Invalid operator: operator element must be a string.')\n\tlocal\
    \ result = nil\n\t\n\t-- Check first element of operator list is a valid operation\n\
    \tlocal operator1 = operator[1]\n\t\n\t-- Check first element of operand list\
    \ is a valid operand\n\tlocal operand1 = operand[1]\n\t\n\t-- If first two elements\
    \ in both lists are valid operators, perform the operation on operand1\n\tif operator1\
    \ == '+' or operator1 == '-' or operator1 == '*' or operator1 == '/' or operator1\
    \ == '//' or operator1 == '**' then\n\t\tresult = operand1 + operand2\n\telse\n\
    \t\t-- Otherwise, perform the operation on operand2\n\t\tlocal operator2 = operator[2]\n\
    \t\t\n\t\t-- assert(operator2:len() > 1, 'Invalid operator: operator list must\
    \ have at least one element.')\n\t\t-- assert(operand2:len() > 2, 'Invalid operand:\
    \ operand list must have at least two elements.')\n\t\t-- assert(type(operand2[1])\
    \ == 'number', 'Invalid operand: operand element must be number.')\n\t\t-- assert(type(operator2)\
    \ == 'string', 'Invalid operator: operator element must be a string.')\n\t\t\n\
    \t\tlocal operand2 = operand[2]\n\t\t\n\t\t-- assert(operator2 == '+' or operator2\
    \ == '-' or operator2 == '*' or operator2 == '/' or operator2 == '//' or operator2\
    \ == '**', 'Invalid operator: operator element must be a valid operation.')\n\t\
    \t-- assert(operand2:len() > 2, 'Invalid operand: operand list must have at least\
    \ two elements.')\n\t\t-- assert(type(operand2[1]) == 'number', 'Invalid operand:\
    \ operand element must be number.')\n\t\t-- assert(type(operator2) == 'string',\
    \ 'Invalid operator: operator element must be a string.')\n\t\t\n\t\tresult =\
    \ operand2 + operand1\n\tend\n\t\n\treturn result\nend", "   local result_string\
    \ = \"\"\n   local result = 1\n   for i,v in pairs(operand) do\n      if i > 1\
    \ then \n         local operand2 = operand[i-1]\n         result = result .. \"\
    \ \" .. operator .. \" \" .. operand2\n      end\n   end\n   return result\nend",
  "\tlocal new_operand = operand[1]\n\tlocal new_operator = operator[1]\n\tlocal result\
    \ = new_operand\n\tlocal i = 2\n\twhile i <= #operand do\n\t\tlocal operand =\
    \ operand[i]\n\t\tlocal operator = operator[i]\n\t\tresult = new_operator .. result\n\
    \t\tif operator == '+' then\n\t\t\tnew_operand = operand + new_operand\n\t\telseif\
    \ operator == '-' then\n\t\t\tnew_operand = operand - new_operand\n\t\telseif\
    \ operator == '*' then\n\t\t\tnew_operand = operand * new_operand\n\t\telseif\
    \ operator == '//' then\n\t\t\tnew_operand = operand // new_operand\n\t\telseif\
    \ operator == '**' then\n\t\t\tnew_operand = operand ^ new_operand\n\t\telse\n\
    \t\t\terror('Invalid operation')\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn result\n\
    end\n</cell>\n<text>\nTests", "    local res = {}\n    for i = 1, #operator -\
    \ 1 do\n        local op = operator[i]\n        local exp = operand[i]\n     \
    \   local v = res\n        for j = 1, #operand - 1 do\n            v = v[op](v,\
    \ operand[j])\n        end\n        if i == 1 then\n            res = v\n    \
    \    else\n            res = op == '-' and -v or v\n        end\n    end\n   \
    \ return res\nend", "    local num_ops = #operator-1\n    local num_operands =\
    \ #operand-2\n    local num_vars = #operand-2\n    local num_vars2 = #operand-1\n\
    \    local var1, var2 = {}, {}\n    \n    -- Initialize var 1 and var 2 with zero\n\
    \    local i = 1\n    while i < num_vars do\n        var1[i] = 0\n        var2[i]\
    \ = 0\n        i=i+1\n    end\n    \n    -- Assign var 1 with first operand\n\
    \    var1[num_vars] = operand[1]\n    \n    -- Assign var 2 with the second operand\n\
    \    var2[num_vars+1] = operand[2]\n    \n    -- Assign var 1 with var2\n    var1[num_vars+2]\
    \ = var2[num_vars]\n    \n    -- Assign var 2 with var1\n    var2[num_vars2+1]\
    \ = var1[num_vars]\n    \n    -- Assign var 1 with var1\n    var1[num_vars+3]\
    \ = var1[num_vars]\n    \n    -- Assign var 2 with var2\n    var2[num_vars2+2]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 1 with var2\n    var1[num_vars+4]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 2 with var1\n    var2[num_vars2+3]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 1 with var2\n    var1[num_vars+5]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 2 with var1\n    var2[num_vars2+4]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 1 with var2\n    var1[num_vars+6]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 2 with var1\n    var2[num_vars2+5]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 1 with var2\n    var1[num_vars+7]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 2 with var1\n    var2[num_vars2+6]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 1 with var2\n    var1[num_vars+8]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 2 with var1\n    var2[num_vars2+7]\
    \ = var2[num_vars2+1]\n    \n    -- Assign var 1 with var2\n    var1[num_vars+9]\
    \ = var2[num_var", "  local result = 0\n  for i = 0, #operator - 1 do\n    local\
    \ op = operator[i]\n    local left = operand[#operand + 1 - i]\n    local right\
    \ = operand[#operand + i - 1]\n    if op == \"+\" then\n      result = result\
    \ + left\n    elseif op == \"-\" then\n      result = result - left\n    elseif\
    \ op == \"*\" then\n      result = result * left\n    elseif op == \"//\" then\n\
    \      result = result // left\n    elseif op == \"**\" then\n      result = result\
    \ ** left\n    end\n  end\n  return result\nend", "    assert(#operator == #operand\
    \ - 1)\n    \n    -- TODO: implement the algebraic expression\n    return 0\n\
    end", "\tlocal expression = nil\n\tlocal result = operand[1]\n\tfor i = 2, #operand\
    \ do\n\t\tlocal value = operand[i]\n\t\tif operator == \"+\" then\n\t\t\tresult\
    \ = result + value\n\t\telseif operator == \"-\" then\n\t\t\tresult = result -\
    \ value\n\t\telseif operator == \"*\" then\n\t\t\tresult = result * value\n\t\t\
    elseif operator == \"/\" then\n\t\t\tresult = result // value\n\t\telseif operator\
    \ == \"**\" then\n\t\t\tresult = result ^ value\n\t\tend\n\tend\n\tlocal sign\
    \ = 1\n\tif operator[1] == \"-\" then\n\t\tsign = -1\n\tend\n\tlocal result_sign\
    \ = sign * result\n\treturn result_sign\nend", "    assert(#operand >= 1)\n  \
    \  assert(#operator > 0)\n    assert(#operand > 1)", "\tlocal i, j, k\n\tlocal\
    \ result = operand[1]\n\tfor i = 1, #operator do\n\t\tif result ~= nil and result\
    \ % 2 == 1 then\n\t\t\tresult = result / 2\n\t\tend\n\t\t\n\t\tif operand[i] ~=\
    \ nil and result ~= nil and operand[i] ~= result then\n\t\t\tresult = result ^\
    \ operand[i]\n\t\tend\n\tend\n\treturn result\nend", "    if #operator == #operand\
    \ - 1 then\n        return operator[#operand]\n    end\n    return nil\nend",
  "    assert(#operator >= 2)\n    assert(#operand >= 1)\n    local res = operand[1]\n\
    \    for i = 2, #operand do\n        res = operator[res]\n    end\n    return\
    \ res\nend", "    local op1 = operand[1]\n    local op2 = operand[2]\n    if operator['+']\
    \ then\n        return op1 + op2\n    elseif operator['-'] then\n        return\
    \ op1 - op2\n    elseif operator['*'] then\n        return op1 * op2\n    elseif\
    \ operator['//'] then\n        return op1 // op2\n    elseif operator['**'] then\n\
    \        return op1 ** op2\n    else\n        return nil\n    end\nend", "  local\
    \ result = operand[1]\n  for i = 2, #operand do\n    if operator[#operator] ==\
    \ nil then\n      error(\"Invalid operator\")\n    end\n    result = operator[#operator](result,\
    \ operand[i])\n  end\n  return result\nend", "\tlocal result = 0 \n\tfor i=0,#operand-1\
    \ do \n\t\tresult = result + operand[i] * operator[i] \n\tend \n\treturn result\
    \ \nend", "    -- Your code here\n    local new_operator = nil\n    local new_operand\
    \ = nil\n    for i=0,#operator,1 do\n        new_operator = operand[i]\n     \
    \   new_operand = operand[i+1]\n        operand[i+1] = operand[i]\n        operand[i]\
    \ = new_operand\n    end\n    return operand[1]\nend", "  -- Operand list has\
    \ at least one operand\n  local i = 1\n  local length\n  local result\n  while\
    \ i < #operand do -- Iterate until operand list is exhausted\n    -- Get the value\
    \ of the ith operand\n    length = #operand-i+1 -- Number of operands minus one\
    \ (since the first element is the operator)\n    if #operand-i+1 == 1 then --\
    \ If the list has only one element, then the operation is basic, and just add\
    \ two lists\n      result = operand[i] + operand[i+1]\n    elseif #operand-i+2\
    \ == 1 then -- If the list has two elements, then the operation is algebraic,\
    \ and use the two lists to do algebra\n      result = operand[i](operand[i+1],\
    \ operand[i+2])\n    elseif #operand-i+3 == 1 then -- If the list has three elements,\
    \ then the operation is geometric and use the three lists to do algebra\n    \
    \  result = operand[i](operand[i+1], operand[i+2], operand[i+3])\n    elseif #operand-i+4\
    \ == 1 then -- If the list has four elements, then the operation is logarithmic\
    \ and use the four lists to do algebra\n      result = operand[i](operand[i+1],\
    \ operand[i+2], operand[i+3], operand[i+4])\n    end\n    -- Return result of\
    \ algebraic operation\n    return result\n  end\nend", "   local function eval_algebra(operator,\
    \ operand)\n      local result\n      local function eval_expr(expr)\n       \
    \  if type(expr) == 'table' then\n            local operation = expr.operator\n\
    \            local arg1 = expr.arg1\n            local arg2 = expr.arg2\n    \
    \        if operation == '+' and type(arg1) == 'number' and type(arg2) == 'number'\
    \ then\n               result = result + arg1 + arg2\n            elseif operation\
    \ == '-' and type(arg1) == 'number' and type(arg2) == 'number' then\n        \
    \       result = result - arg1 - arg2\n            elseif operation == '*' and\
    \ type(arg1) == 'number' and type(arg2) == 'number' then\n               result\
    \ = result * arg1 * arg2\n            elseif operation == '/' and type(arg1) ==\
    \ 'number' and type(arg2) == 'number' then\n               if arg2 ~= 0 then\n\
    \                  result = result / arg1 / arg2\n               else\n      \
    \            result = nil\n               end\n            elseif operation ==\
    \ '%' and type(arg1) == 'number' and type(arg2) == 'number' then\n           \
    \    if arg2 ~= 0 then\n                  result = result % arg1 % arg2\n    \
    \           else\n                  result = nil\n               end\n       \
    \     elseif operation == '**' and type(arg1) == 'number' and type(arg2) == 'number'\
    \ then\n               result = result ^ arg1 ^ arg2\n            else\n     \
    \          result = nil\n            end\n         end\n      end\n      if type(operator)\
    \ == 'string' then\n         if #operand == 0 then\n            return nil\n \
    \        end\n         if #operator == 0 then\n            return nil\n      \
    \   end\n         if #operand == 1 then\n            eval_expr(operand[1])\n \
    \        else\n            local op\n            local arg1\n            local\
    \ arg2\n            for i = 1, #operand, 2 do\n               op, arg1, arg2 =\
    \ operand[i], operand[i + 1], operand[i + 2]\n               if op == '+' then\n\
    \                  result = result + arg1 + arg2\n               elseif op ==\
    \ '-' then\n                  result = result - arg1 - arg2\n               elseif\
    \ op == '*' then\n                  result = result * arg1 * arg2\n          \
    \     elseif op == '/' then\n                  if arg2 ~= 0 then\n           \
    \          result = result / arg1 / arg2\n                  else\n           \
    \          result = nil\n                  end\n               elseif op == '%'\
    \ then\n                  if arg2 ~= 0 then\n                     result = result\
    \ % arg1 % arg2\n                  else\n                     result = nil\n \
    \                 end\n               elseif op == '**", '  local result', " \
    \   if #operand == 0 then\n        return 0\n    end\n    if #operator == 0 then\n\
    \        return 0\n    end", "  local result = 0\n  for _, v in ipairs(operand)\
    \ do\n    result = v\n    for _, v2 in ipairs(operator) do\n      result = result\
    \ .. v\n    end\n  end\n  return result\nend", "    if #operator == 0 then return\
    \ 0 end\n    if #operand == 1 then return operand[1] end\n    if #operand == 0\
    \ then return 0 end\n    if #operator == 1 and #operand == 0 then return 0 end\n\
    \    local operation = operator[1]\n    local result = do_algebra(operator, operand)\n\
    \    local op1 = do_algebra(operator, operand[1])\n    if #operand == 2 then \n\
    \        return operation .. \"(\" .. op1 .. \", \" .. result .. \")\"\n    else\n\
    \        return operation .. \"(\" .. op1 .. \")\"\n    end\nend", "  -- Base\
    \ cases\n  if #operator == 0 then \n    return operand[1]\n  elseif #operand ==\
    \ 0 then\n    return 0\n  -- Recursive case\n  else\n    local left = do_algebra(operator,\
    \ operand:sub(1, #operand))\n    local right = do_algebra(operator:sub(1, #operator),\
    \ operand:sub(2, #operand))\n    return operator[#operator](left, right)\n  end\n\
    end", "   local result = 0\n   for i = 1, #operator do\n      result = result\
    \ + operator[i] * operand[i]\n   end\n   return result\nend", "   local first_op,\
    \ second_op, first_operand, second_operand = unpack(operator, operand)\n   local\
    \ result = operand[#operand] \n   for i = 1, #operand-1 do\n      result = first_op(result,\
    \ operand[i])\n   end\n   return result\nend", "  local result = nil\n  for i\
    \ = 1, #operand do\n    result = result + operator[#operator - i - 1] * operand[i]\n\
    \  end\n  return result\nend", "    -- Handle error case\n    if not (#operand\
    \ > 1) then\n        return nil\n    end\n    if not (#operator > 1) then\n  \
    \      return nil\n    end\n    -- Handle empty expression\n    if not #operand\
    \ then\n        return 0\n    end\n    -- Handle case where there is only 1 operand\n\
    \    if not #operand == 1 then\n        return operand[1]\n    end\n    -- Handle\
    \ case where there are only 2 operands\n    if not #operand == 2 then\n      \
    \  return operand[1]\n    end\n    -- Handle case where there are only 3 operands\n\
    \    if not #operand == 3 then\n        return operand[1] + operand[2]\n    end\n\
    \    -- Handle case where there are only 4 operands\n    if not #operand == 4\
    \ then\n        return operand[1] + operand[2] + operand[3]\n    end\n    -- Handle\
    \ case where there are only 5 operands\n    if not #operand == 5 then\n      \
    \  return operand[1] + operand[2] + operand[3] + operand[4]\n    end\n    -- Handle\
    \ case where there are only 6 operands\n    if not #operand == 6 then\n      \
    \  return operand[1] + operand[2] + operand[3] + operand[4] + operand[5]\n   \
    \ end\n    -- Handle case where there are only 7 operands\n    if not #operand\
    \ == 7 then\n        return operand[1] + operand[2] + operand[3] + operand[4]\
    \ + operand[5] + operand[6]\n    end\n    -- Handle case where there are only\
    \ 8 operands\n    if not #operand == 8 then\n        return operand[1] + operand[2]\
    \ + operand[3] + operand[4] + operand[5] + operand[6] + operand[7]\n    end\n\
    \    -- Handle case where there are only 9 operands\n    if not #operand == 9\
    \ then\n        return operand[1] + operand[2] + operand[3] + operand[4] + operand[5]\
    \ + operand[6] + operand[7] + operand[8]\n    end\n    -- Handle case where there\
    \ are only 10 operands\n    if not #operand == 10 then\n        return operand[1]\
    \ + operand[2] + operand[3] + operand[4] + operand[5] + operand[6] + operand[7]\
    \ + operand[8] + operand[9]\n    end\n    -- Handle case where there are only\
    \ 11 operands\n    if not #operand == 11 then\n        return operand[1] + operand[2]\
    \ + operand[3] + operand[4] + operand[5] + operand[6] + operand[7] + operand[8]\
    \ + operand[9] + operand[10]\n    end\n    -- Handle case where there are only\
    \ 12 operands\n    if not #operand == 12 then\n        return operand[1] + operand[2]\
    \ + operand[3] + operand[4] + operand[5] + operand[6] + operand[7] + operand[8]\
    \ + operand[9] + operand[10] + operand[11]\n    end\n    -- Handle case where\
    \ there are only 13 operands\n    if not #operand == 13 then\n        return operand[1]\
    \ + operand[2] + operand[3] + operand[4] + operand", "    if #operator == 0 then\n\
    \        return 1\n    end\n    local result = 1\n    for i = 1, #operand do\n\
    \        result = result * operand[i]\n    end\n    return result \nend\n</cell>\n\
    <code language=julia-0.6>\ndo_algebra('+', [1, 3, 5])\n</cell>\n<code language=julia-0.6>\n\
    do_algebra('+', [1, 3, 5, 8, 13, 21])\n</cell>\n<text>\n4.5 The recursive function\n\
    The recursive function will recursively evaluate the expression and return the\
    \ result of the expression.\nA recursive function is a function that calls itself.\
    \ \nIf your function takes a value as a parameter (for example, factorial) and\
    \ you want the function to calculate the factorial of a given number, then you\
    \ first call the function with the number itself:", "   local result = 0\n   local\
    \ tmp\n   for _, v in pairs(operand) do\n      tmp = ( result * v ) + result\n\
    \      result = tmp % (( operand:len() - 1 ) * operand:len() + 1)\n   end\n  \
    \ return result\nend", "\tlocal result = 0\n\tlocal i = #operator + 1\n\twhile\
    \ i <= #operand and #operator > 0 do\n\t\tif operand[i - 1] == 0 then\n\t\t\t\
    break\n\t\telse\n\t\t\tlocal tmp = operand[i - 1] * operator[i]\n\t\t\tresult\
    \ = result + tmp\n\t\tend\n\t\ti = i\n\tend\n\t\n\tif i == #operand then\n\t\t\
    return result\n\telse\n\t\treturn nil\n\tend\nend", "  local result = 0\n  for\
    \ i = 1, #operand - 1 do\n    local temp_operand = operand[i]\n    local temp_operator\
    \ = operator[i]\n    -- Evaluate algebra operations\n    local temp_result = temp_operand\n\
    \    if temp_operator == '*' then\n      temp_result = temp_result * temp_operand\n\
    \    end\n    if temp_operator == '+' then\n      temp_result = temp_result +\
    \ temp_operand\n    end\n    if temp_operator == '-' then\n      temp_result =\
    \ temp_result - temp_operand\n    end\n    if temp_operator == '/' then\n    \
    \  temp_result = temp_result / temp_operand\n    end\n    if temp_operator ==\
    \ '//' then\n      temp_result = temp_result // temp_operand\n    end\n    if\
    \ temp_operator == '**' then\n      temp_result = temp_result ^ temp_operand\n\
    \    end\n    -- Update the result variable\n    result = result + temp_result\n\
    \  end\n  return result\nend", "   local result = 0\n   for i = 1, #operand do\n\
    \      result = result + operand[i]\n   end\n   for i = 1, #operator do\n    \
    \  result = result and operator[operator[i]]\n   end\n   return result\nend",
  "  local result = operand[1]\n  for i=2,#operator do\n    result = operator[operator[i]](result,\
    \ operand[i])\n  end\n  return result\nend", "\tif #operator ~= #operand then\n\
    \t\treturn nil\n\tend\n\tlocal result = operand[1]\n\tfor i = 2, #operand do\n\
    \t\tlocal operand1 = operand[i]\n\t\tif #operator == 1 then\n\t\t\tresult = result\
    \ .. operator[1] .. operand1\n\t\telseif #operator == 2 then\n\t\t\tresult = result\
    \ .. operator[2] .. operand1\n\t\telseif #operator == 3 then\n\t\t\tresult = result\
    \ .. operator[3] .. operand1\n\t\tend\n\tend\n\treturn result\nend", "    local\
    \ i, j, k = 0, #operand, 0\n    local operations = {\n        ['+'] = function(left,\
    \ right)\n            local left_value, right_value = 0, 0\n            for i\
    \ = 1, #left do\n                left_value = left_value + left[i]\n         \
    \   end\n            for i = 1, #right do\n                right_value = right_value\
    \ + right[i]\n            end\n            return left_value + right_value\n \
    \       end,\n        ['-'] = function(left, right)\n            local left_value,\
    \ right_value = 0, 0\n            for i = 1, #left do\n                left_value\
    \ = left_value - left[i]\n            end\n            for i = 1, #right do\n\
    \                right_value = right_value - right[i]\n            end\n     \
    \       return left_value - right_value\n        end,\n        ['*'] = function(left,\
    \ right)\n            local left_value, right_value = 0, 0\n            for i\
    \ = 1, #left do\n                left_value = left_value * left[i]\n         \
    \   end\n            for i = 1, #right do\n                right_value = right_value\
    \ * right[i]\n            end\n            return left_value * right_value\n \
    \       end,\n        ['/'] = function(left, right)\n            if #left == 0\
    \ then\n                return nil\n            end\n            if #right ==\
    \ 0 then\n                local left_value = left[0]\n                for i =\
    \ 1, #left do\n                    left_value = left_value / left[i]\n       \
    \         end\n                return left_value\n            end\n          \
    \  local left_value = left[0]\n            for i = 1, #left do\n             \
    \   left_value = left_value / left[i]\n            end\n            return left_value\
    \ / right[0]\n        end,\n        ['//'] = function(left, right)\n         \
    \   if #left == 0 then\n                return nil\n            end\n        \
    \    if #right == 0 then\n                local left_value = left[0]\n       \
    \         for i = 1, #left do\n                    left_value = left_value //\
    \ left[i]\n                end\n                return left_value\n          \
    \  end\n            local left_value = left[0]\n            for i = 1, #left do\n\
    \                left_value = left_value // left[i]\n            end\n       \
    \     return left_value // right[0]\n        end,\n        ['**'] = function(left,\
    \ right)\n            if #left == 0 then\n                return nil\n       \
    \     end\n            if #right == 0 then\n                local left_value =\
    \ left[0]\n                for i = 1, #left do\n                    left_value\
    \ = left_value ** left[i]\n                end\n                return left_value\n\
    \            end\n            local left_value = left[0]\n            for i =\
    \ 1, #left do\n                left_value = left_value ** left[i]\n          \
    \  end\n            return left_value ** right[0]\n        end\n    }\n    local\
    \ result, error\n    for _, op in ipairs(operator) do\n        if k ~= 0 then\n\
    \            ", "\t-- Base case:\n\tif not operator then\n\t\treturn operand[1]\n\
    \tend", "    -- Write your code here.\n    \n    local new_array = nil\n    for\
    \ i=1,#operand do\n        new_array = (new_array) + (operand[i] * operator[#operator])\n\
    \    end\n    \n    return new_array\nend", "   -- If the lengths of operator\
    \ and operand lists are not equal, then return\n   -- nil.\n   if #operator ~=\
    \ #operand then\n      return nil\n   end", "   local result = nil\n   for i =\
    \ 0, operand[1]-1 do\n      local operation = operator[i]\n      local operand2\
    \ = operand[i+1]\n      if operand == nil then\n         return nil\n      elseif\
    \ i == 0 then\n         result = operation\n      elseif result == nil then\n\
    \         result = operation .. operand2\n      else\n         result = operation\
    \ .. operand2 .. result\n      end\n   end\n   return result\nend", "\tlocal a\
    \ = {}\n\tlocal r\n\tlocal i = 1\n\twhile i <= #operand-1 do\n\t\tif i > 1 then\n\
    \t\t\ta[#a + 1] = operand[i-1]\n\t\tend\n\t\ta[#a + 1] = (#a > 1) and operator[i-1]\
    \ or 0\n\t\ti = i+1\n\tend\n\tif #a >= 1 then\n\t\tlocal b = #operand-1 - #a\n\
    \t\tif b > 1 then\n\t\t\ta[#a + 1] = (#a > 1) and operator[b-1] or 0\n\t\tend\n\
    \t\tr = a[#a]\n\t\tfor i = 1, #a do\n\t\t\tr = r * operand[i]\n\t\tend\n\telse\n\
    \t\tr = #operand\n\tend\n\treturn r\nend", "   -- Base case: operand list is empty,\
    \ and operator list has only one operator.\n   if #operand == 0 then\n      return\
    \ operand[1]\n   end\n   -- Base case: Operand list is empty, and operator list\
    \ has only one operator.\n   if #operator == 0 then\n      return operand[1] operator[#operand]\n\
    \   end\n   -- If the first operand of the operation is 0, then the second operand\
    \ is 1, and the \n   -- operation is negated.\n   if operand[1] == 0 then\n  \
    \    return operand[1] operator[#operand]\n   end\n   -- Otherwise, apply the\
    \ operation to the first operand.\n   return operand[1] operator[#operand] do_algebra(operator,\
    \ operand[2:])\nend", "    local result = operand[1]\n    for i, x in ipairs(operand)\
    \ do\n        if operator[i] == '+' then\n            result = result + x\n  \
    \      elseif operator[i] == '-' then\n            result = result - x\n     \
    \   elseif operator[i] == '*' then\n            result = result * x\n        elseif\
    \ operator[i] == '/' then\n            result = result / x\n        elseif operator[i]\
    \ == '//' then\n            result = result // x\n        elseif operator[i] ==\
    \ '**' then\n            result = result ** x\n        else\n            return\
    \ nil\n        end\n    end\n    return result\nend", "\tlocal res, expr\n\t\n\
    \t-- TODO: Write a loop to loop through the whole expression\n\t-- TODO: Handle\
    \ error if operator list is not valid\n\t-- TODO: Handle errors if operand lists\
    \ have different sizes", "  -- Convert the operand list to a list of expressions.\n\
    \  local operands = assert({})\n  local i = 0\n  repeat\n    -- Append the operand\
    \ to the operand list if it is a number.\n    operands[i+1] = operand[i] and operand[i]\n\
    \    i = i + 1\n  until operand[i] = nil", "\tlocal _table = {\n\t\t['+'] = function\
    \ (a, b) return a + b end,\n\t\t['-'] = function (a, b) return a - b end,\n\t\t\
    ['*'] = function (a, b) return a * b end,\n\t\t['/'] = function (a, b) return\
    \ a / b end,\n\t\t['^'] = function (a, b) return a ** b end,\n\t\t\n\t\t['//']\
    \ = function (a, b) return math.floor(a/b) end,\n\t\t['**'] = function (a, b)\
    \ return a**b end,\n\t}\n\t\n\tlocal result = {}\n\tfor i = 1, #operand do\n\t\
    \tlocal _expr = _table[operator[i]](operand[i-1], operand[i])\n\t\ttable.insert(result,\
    \ tostring(_expr))\n\tend\n\treturn tostring(result[1]..result[#result])\nend",
  "\tlocal op_len = #operator\n\tlocal op_count = #operand\n\tlocal i = 0\n\tlocal\
    \ result", "  local result = operand[1]\n  for i = 2, #operand do\n    result\
    \ = operator[#operator][result][operand[i]]\n  end\n  return result\nend\nprint(do_algebra(operator,\
    \ array))", "\tlocal total = 1\n\tfor i=1,#operator do\n\t\ttotal = total * operand[#operand-i]\
    \ + operator[operator[i]]\n\tend\n\treturn total\nend", "  local operand_len =\
    \ #operand\n  local operator_cnt = #operator\n  local result = 0\n  local op_stack\
    \ = tablex.new(operator)", "   local operands = {}\n   local result = nil\n  \
    \ local num_ops = #operator", "  -- Calculate the length of operator list\n  local\
    \ operator_length = #operator\n  -- Calculate the length of operand list\n  local\
    \ operand_length = #operand", "    local result = 0\n    for i = 1, #operand,\
    \ 1, -1 do\n        result = result + operand[i] * operator[i]\n    end\n    return\
    \ result\nend", "    local result_exp = operand[1]\n    for i=2, #operand do\n\
    \        result_exp = operators[operator](result_exp, operand[i])\n    end\n \
    \   return result_exp\nend", "\tlocal result = operand[1]\n\t\n\t-- Add the operators.\n\
    \tfor i = 2, #operand do\n\t\tresult = operators[operator](result, operand[i])\n\
    \tend\n\t\n\t-- Return the result of the algebra.\n\treturn result\nend", "  \
    \ local result = 0\n   local operation_index = 1\n   while operation_index <=\
    \ #operator do\n      local operation_symbol = operator[operation_index]\n   \
    \   local operation\n      if operation_symbol == '+' then\n         operation\
    \ = binary_operation(operation, add_operation)\n      elseif operation_symbol\
    \ == '-' then\n         operation = binary_operation(operation, subtract_operation)\n\
    \      elseif operation_symbol == '*' then\n         operation = binary_operation(operation,\
    \ multiply_operation)\n      elseif operation_symbol == '//' then\n         operation\
    \ = binary_operation(operation, floor_div_operation)\n      elseif operation_symbol\
    \ == '**' then\n         operation = binary_operation(operation, exponentiate_operation)\n\
    \      else\n         return nil\n      end\n      local operand_index = 1\n \
    \     while operand_index <= #operand do\n         local operand = operand[operand_index]\n\
    \         result = operation(result, operand)\n         operand_index = operand_index\
    \ + 1\n      end\n      operation_index = operation_index + 1\n   end\n   return\
    \ result\nend", "\tlocal result = 1\n\tlocal i = 1\n\twhile i <= #operand do\n\
    \t\tif operator[i] == '+' then\n\t\t\tresult = result + operand[i]\n\t\telseif\
    \ operator[i] == '*' then\n\t\t\tresult = result * operand[i]\n\t\telseif operator[i]\
    \ == '-' then\n\t\t\tresult = result - operand[i]\n\t\telseif operator[i] == '/'\
    \ then\n\t\t\tresult = result / operand[i]\n\t\telseif operator[i] == '%' then\n\
    \t\t\tresult = result % operand[i]\n\t\telseif operator[i] == '**' then\n\t\t\t\
    result = result ** operand[i]\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn result\n\
    end", "  local total = 0\n  for i=1,#operator do \n    total = total + operator[i](operand[i-1],\
    \ operand[i]) \n  end\n  return total \nend", "    local result\n    -- If the\
    \ length of operator list is less than the length of operand list, \n    -- we\
    \ do nothing\n    if #operator < #operand then \n        error('Length of operator\
    \ list is shorter than operand list length')\n    end", "    local stack = { }\n\
    \    for i=1, #operator do\n        local op = operator[i]\n        local right\
    \ = operand[#operand]\n        if op == \"+\" then\n            local result =\
    \ left + right\n            table.insert(stack, result)\n            left = result\n\
    \        elseif op == \"-\" then\n            local result = left - right\n  \
    \          table.insert(stack, result)\n            left = result\n        elseif\
    \ op == \"*\" then\n            local result = left * right\n            table.insert(stack,\
    \ result)\n            left = result\n        elseif op == \"/\" then\n      \
    \      local result = left // right\n            table.insert(stack, result)\n\
    \            left = result\n        elseif op == \"%\" then\n            local\
    \ result = left % right\n            table.insert(stack, result)\n           \
    \ left = result\n        elseif op == \"**\" then\n            local result =\
    \ left ^ right\n            table.insert(stack, result)\n            left = result\n\
    \        end\n    end\n    return stack[1]\nend", "  local result\n  if #operand\
    \ == 0 then -- operand list is empty\n    result = nil\n  elseif #operand == 1\
    \ then -- operand list has only one element\n    result = operand[0] -- result\
    \ will be that element\n  elseif #operand == 2 then\n    if operand[1] == '+'\
    \ then -- addition\n      result = operand[0] + operand[2]\n    elseif operand[1]\
    \ == '-' then -- subtraction\n      result = operand[0] - operand[2]\n    elseif\
    \ operand[1] == '*' then -- multiplication\n      result = operand[0] * operand[2]\n\
    \    elseif operand[1] == '//' then -- floor division\n      result = operand[0]\
    \ / operand[2]\n    elseif operand[1] == '**' then -- exponentiation\n      result\
    \ = operand[0] ** operand[2]\n    else\n      -- TODO\n    end\n  else\n    --\
    \ TODO\n  end", "\tlocal result = 0\n\tfor i = 1, #operator do\n\t\tlocal op =\
    \ operator[i]\n\t\tlocal a = operand[i-1]\n\t\tif op == \"+\" then\n\t\t\tresult\
    \ = result + a\n\t\telseif op == \"*\" then\n\t\t\tresult = result * a\n\t\telseif\
    \ op == \"-\" then\n\t\t\tresult = result - a\n\t\telseif op == \"//\" then\n\t\
    \t\tresult = result // a\n\t\telseif op == \"**\" then\n\t\t\tresult = result\
    \ ** a\n\t\tend\n\tend\n\treturn result\nend", "\tlocal left_operand = operand[1]\n\
    \tlocal right_operand = operand[2]", "\tlocal op = {\n\t\tadd = function(a, b)\
    \ return a + b end,\n\t\tsub = function(a, b) return a - b end,\n\t\tmul = function(a,\
    \ b) return a * b end,\n\t\tdiv = function(a, b) return a / b end,\n\t\tpow =\
    \ function(a, b) return a ** b end,\n\t}", "\tif #operand == 1 then\n\t\treturn\
    \ operand[0]\n\telseif #operand == 0 then\n\t\treturn '0'\n\tend\n\tlocal stack\
    \ = { }\n\tlocal value = do_algebra(operator[1], operand[1])\n\tfor i=2,#operand\
    \ do\n\t\tlocal new_value = do_algebra(operator[i], operand[i])\n\t\tvalue = new_value\n\
    \t\tif value == operand[i] then -- If the result is equal to the current operand,\
    \ break the loop.\n\t\t\tbreak\n\t\tend\n\t\tif type(stack) ~= 'table' then --\
    \ If the stack is not a table, create a new table and push it onto the stack.\n\
    \t\t\tstack = { value }\n\t\telse\n\t\t\ttable.insert(stack, value)\n\t\tend\n\
    \tend\n\treturn stack[1]\nend", "    if #operand == 1 then\n        if #operator\
    \ == 1 then\n            if #operand == 1 then\n                return operand[0]\n\
    \            else\n                local result = operand[1]\n               \
    \ for i = 2, #operand do\n                    result = operator[1](result,operand[i])\n\
    \                end\n                return result\n            end\n       \
    \ else\n            local result = operand[1]\n            for i = 2, #operand\
    \ do\n                result = operator[1](result,operand[i])\n            end\n\
    \            return result\n        end\n    else\n        local result = operand[1]\n\
    \        for i = 2, #operand do\n            result = operator[1](result,operand[i])\n\
    \        end\n        return result\n    end\nend", "\tlocal operator_index =\
    \ 1\n\tlocal function op_list()\n\t\tlocal function build_op_list(op_list)\n\t\
    \t\tfor i = 1, #op_list do\n\t\t\t\tif operator_index ~= #operand then\n\t\t\t\
    \t\top_list[operator_index] = op_list[operator_index] + operand[operand_index]\
    \ + operator\n\t\t\t\telse\n\t\t\t\t\top_list[operator_index] = op_list[operator_index]\
    \ + operand[operand_index]\n\t\t\t\tend\n\t\t\t\toperator_index = operator_index\
    \ + 1\n\t\t\tend\n\t\tend\n\t\tlocal build_op_list({})\n\tend\n\tlocal function\
    \ eval_list(list)\n\t\tif #list == 0 then\n\t\t\treturn 0\n\t\tend\n\t\tlocal\
    \ last_operand = list[#list]\n\t\tlist[#list] = nil\n\t\treturn last_operand\n\
    \tend\n\tlocal function check_operator(list)\n\t\tfor i = 1, #list do\n\t\t\t\
    if operator[list[i]] ~= nil then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\
    \treturn true\n\tend\n\tlocal function check_operand(list)\n\t\tfor i = 1, #list\
    \ do\n\t\t\tif operand[list[i]] ~= nil then\n\t\t\t\treturn false\n\t\t\tend\n\
    \t\tend\n\t\treturn true\n\tend\n\top_list()\n\tif #operator > #operand then\n\
    \t\treturn nil\n\tend\n\tif check_operator(operator) ~= true or check_operand(operand)\
    \ ~= true then\n\t\treturn nil\n\tend\n\treturn eval_list(operator)\nend", "\t\
    -- Initialize result to 0.\n\tlocal result = 0\n\t-- Loop through the operand\
    \ list \n\tfor i = 0, #operand - 1 do\n\t\t-- Loop through the operator list\n\
    \t\tfor j = 0, #operator - 1 do\n\t\t\t-- Evaluate expression using operator and\
    \ operand.\n\t\t\tlocal operation = operator[j]\n\t\t\tlocal operand1 = operand[i]\n\
    \t\t\tlocal operand2 = operand[i + 1]\n\t\t\t-- Perform operation on operands.\n\
    \t\t\tif operation == '+' or operation == '-' or operation == '*' or operation\
    \ == '/' then\n\t\t\t\tresult = result + operand1 * operand2\n\t\t\telseif operation\
    \ == '**' then\n\t\t\t\tresult = result ^ operand1\n\t\t\telse\n\t\t\t\tassert(false,\
    \ 'Invalid algebra operation \"' .. operation .. '\"')\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn result\nend", "    local result\n    for i = 0, #operator - 1 do\n\
    \        local left = operand[i]\n        local right = operand[i + 1]\n     \
    \   if operator[i] == \"+\" then\n            result = result + left\n       \
    \ elseif operator[i] == \"-\" then\n            result = result - left\n     \
    \   elseif operator[i] == \"*\" then\n            result = result * left\n   \
    \     elseif operator[i] == \"/\" then\n            result = result // left\n\
    \        elseif operator[i] == \"**\" then\n            result = result ^ left\n\
    \        end\n    end\n    return result\nend", "    assert(#operator == #operand,\
    \ 'operator and operand lists should be of same length')\n    assert(all(type(elem)\
    \ == 'number' for elem in operator), 'operator list should be a list of non-negative\
    \ integers')\n    assert(#operand == 1, 'operand list should have at least one\
    \ operand')\n    local result = operand[1]\n    for i=2, #operand do\n       \
    \ local operand_value = operand[i]\n        result = operator[operator](result,\
    \ operand_value)\n    end\n    return result\nend", "    local operations = {\n\
    \        ['+'] = function (a, b)\n            return a + b\n        end,\n   \
    \     ['-'] = function (a, b)\n            return a - b\n        end,\n      \
    \  ['*'] = function (a, b)\n            return a * b\n        end,\n        ['/']\
    \ = function (a, b)\n            return a / b\n        end,\n        ['//'] =\
    \ function (a, b)\n            return a // b\n        end,\n        ['**'] = function\
    \ (a, b)\n            return a ** b\n        end,\n    }", "    assert(operator:len()\
    \ >= 1 and operator:len() <= 4)\n    assert(operand:len() >= 1 and operand:len()\
    \ <= 2)", "   local result = operand[1]\n   for i = 2, #operand, 1 do\n      local\
    \ x = operand[i]\n      local y = operand[i-1]\n      local operation = operator[i-1]\n\
    \      assert(not math.isnan(y), \"Division by zero not allowed\")\n      assert(not\
    \ math.isnan(x), \"Division by zero not allowed\")\n      assert(not math.isnan(operation),\
    \ \"Division by zero not allowed\")\n      result = operation(x, y)\n   end\n\
    \   return result\nend", "   local result = {}\n   for i=1, #operand do\n    \
    \  local value = operand[i]\n      for _, operator in ipairs(operator) do\n  \
    \       local result = value\n         value = operator(value, value)\n      \
    \   if value == nil then break end\n      end\n      table.insert(result, value)\n\
    \   end\n   return result\nend", "    if #operand == 0 then\n        return nil\n\
    \    elseif #operator == 0 then\n        return operand[1]\n    else\n       \
    \ local op = operator[1]\n        if op == \"+\" then\n            return operand[1]\
    \ + do_algebra(operator, operand[2:])\n        elseif op == \"-\" then\n     \
    \       return operand[1] - do_algebra(operator, operand[2:])\n        elseif\
    \ op == \"*\" then\n            return operand[1] * do_algebra(operator, operand[2:])\n\
    \        elseif op == \"//\" then\n            return operand[1] // do_algebra(operator,\
    \ operand[2:])\n        elseif op == \"**\" then\n            return operand[1]\
    \ ** do_algebra(operator, operand[2:])\n        end\n    end\nend", "    assert(#operand\
    \ == (#operator - 1))\n    assert(#operand > 0)", "    local result\n    \n  \
    \  if #operand == 1 then\n        result = operand[1]\n    else\n        local\
    \ result = operand[1]\n        for i = 2, #operand do\n            assert(type(result)\
    \ == \"number\", \"Result must be a number\")\n            result = operator[operator](result,\
    \ operand[i])\n        end\n    end\n    assert(type(result) == \"number\", \"\
    Result must be a number\")\n    return result\nend", "    -- TODO: Implement the\
    \ algebraic operation.\n    -- TODO: Think of a better name for do_algebra.\n\
    end", "\tif #operator == 0 then\n\t\terror()\n\tend", "    local result = 0\n\
    \    for i=1,#operator do\n        local op = operator[i]\n        local operand1\
    \ = operand[i-1]\n        local operand2 = operand[i]\n        if op == \"+\"\
    \ then\n            result = result + operand1 + operand2\n        elseif op ==\
    \ \"-\" then\n            result = result - operand1 - operand2\n        elseif\
    \ op == \"*\" then\n            result = result * operand1 * operand2\n      \
    \  elseif op == \"/\" then\n            if operand2 ~= 0 then\n              \
    \  result = result / operand1 / operand2\n            else\n                print(\"\
    Error: dividing by zero\")\n            end\n        elseif op == \"//\" then\n\
    \            if operand2 ~= 0 then\n                result = result // operand1\n\
    \            else\n                print(\"Error: dividing by zero\")\n      \
    \      end\n        elseif op == \"**\" then\n            result = result ** operand1\n\
    \        else\n            print(\"Error: invalid operator\")\n        end\n \
    \   end\n    return result\nend", "\tlocal result = operand[1]\n\tfor i = 2, #operand\
    \ do result = operator[operator](result, operand[i]) end\n\treturn result\nend",
  "    local result = 1\n    local length = #operand\n    for i = 1, #operator, 1\
    \ do\n        local op1 = operator[i]\n        local op2 = operator[i +1]\n  \
    \      local num1 = operand[i-1]\n        local num2 = operand[i  +1]\n      \
    \  result = num1 .. op1 .. num2 .. op2 .. result\n    end\n    return result\n\
    end", "    local result = {}\n    for i = 0, #operand - 1 do\n        local op1\
    \ = operator[i]\n        local op2 = operator[(i + 1) % #operator]\n        local\
    \ op3 = operator[(i + 2) % #operator]\n        local op4 = operator[(i + 3) %\
    \ #operator]\n        if op1 == '+' then\n            result[i + 1] = op2 * operand[i]\
    \ + op3 * operand[i + 1]\n        elseif op1 == '-' then\n            result[i\
    \ + 1] = op2 * operand[i] - op3 * operand[i + 1]\n        elseif op1 == '*' then\n\
    \            result[i + 1] = op2 * operand[i] * op3 * operand[i + 1]\n       \
    \ elseif op1 == '/' then\n            if op2 == '-' then\n                result[i\
    \ + 1] = (op2 * operand[i] + op3) / -op4\n            else\n                result[i\
    \ + 1] = op2 * operand[i] / op3 * operand[i + 1]\n            end\n        elseif\
    \ op1 == '//' then\n            if op2 == '-' then\n                result[i +\
    \ 1] = (op2 * operand[i] + op3) // -op4\n            else\n                result[i\
    \ + 1] = op2 * operand[i] // op3 * operand[i + 1]\n            end\n        elseif\
    \ op1 == '**' then\n            result[i + 1] = op2 * operand[i] ** op3 * operand[i\
    \ + 1]\n        end\n    end\n    return result[1]\nend", "    local operation\
    \ = operator\n    local result = operand[1]", "\tlocal index1, index2 = 1, 1\n\
    \tlocal index\n\t\n\t-- If any operand is a string, assume that it's a variable\
    \ name\n\t-- and return the variable value. Otherwise, assume that it's a number.\n\
    \tfor index, value in ipairs(operand) do\n\t\tif type(value) ~= 'string' then\n\
    \t\t\treturn value\n\t\tend\n\tend\n\t-- Return 0 for the operation if the operation\
    \ is not in operator\n\tif operator.nil then\n\t\treturn 0\n\telseif #operator\
    \ ~= #operand then\n\t\treturn 0\n\tend", "    local ops = {}\n    local stack\
    \ = {}\n    local last\n    local index\n    local op\n    local op\n    local\
    \ incr = 1\n    for i = 1, #operand, 1 do\n        if last then \n           \
    \ op = operator[incr]\n            if op == '+' then\n                stack[#stack\
    \ + 1] = stack[#stack + 1] + operand[i]\n            elseif op == '*' then\n \
    \               stack[#stack + 1] = stack[#stack + 1] * operand[i]\n         \
    \   elseif op == '-' then\n                stack[#stack + 1] = stack[#stack +\
    \ 1] - operand[i]\n            elseif op == '//' then\n                stack[#stack\
    \ + 1] = stack[#stack + 1] // operand[i]\n            elseif op == '**' then\n\
    \                stack[#stack + 1] = stack[#stack + 1] ** operand[i]\n       \
    \     end\n        else\n            stack[#stack + 1] = operand[i]\n        end\n\
    \        last = (i == #operand)\n        index = #stack\n        if index > #operators\
    \ then \n            index = 1\n        end\n        ops[#ops + 1] = { op, index\
    \ }\n    end\n    return stack[1]\nend", "   local result, index1, index2 = 0,\
    \ 0, 0\n   \n   -- For each operator and operand\n   for _, op in pairs(operator)\
    \ do\n      -- For each operand\n      for index2 = 1, #operand do\n         --\
    \ If the current operator is equal with the current operand\n         if op ==\
    \ operand[index2] then\n            result=result+operand[index1]\n         --\
    \ If the current operator is different from the current operand\n         else\n\
    \            result=result-operand[index2]\n         end\n         -- Increase\
    \ the index by one to compare with the next operand\n         index1 = index1\
    \ + 1\n      end\n   end", "\tlocal stack = {{0,0}}\n\tfor index, i in ipairs(operand)\
    \ do\n\t\tlocal op = operator:sub(1, 1)\n\t\tstack[index] = stack[index] + (i\
    \ - stack[index] * op)\n\tend\n\treturn stack[1]\nend", "  local result = math.NaN\n\
    \  for i = 1, #operator do\n    result = result + operand[i-1] * operator[i]\n\
    \  end\n  return result\nend", "    local ops = {}\n    for i=1,#operator do\n\
    \        table.insert(ops, operator[i])\n    end\n    local result = nil\n   \
    \ if #ops > 0 and #operand > 0 then\n        for i=1,#operand do\n           \
    \ local exp = operand[i]\n            for j=1,#ops do\n                local op\
    \ = ops[j]\n                -- Only allow one operator at a time, otherwise, bad\
    \ luck\n                if op == '-' and result ~= nil then\n                \
    \    error('Too many operator in expression')\n                end\n         \
    \       if op == '-' and result == nil then\n                    result = 0\n\
    \                end\n                if op == '*' and result == nil then\n  \
    \                  result = 1\n                end\n                if op == '/'\
    \ and result == nil then\n                    if exp % 2 == 0 then\n         \
    \               result = exp\n                    else\n                     \
    \   result = 1\n                    end\n                end\n               \
    \ if op == '*' and result ~= nil then\n                    result = result * exp\n\
    \                elseif op == '/' and result ~= nil then\n                   \
    \ if exp % 2 == 0 then\n                        result = result / exp\n      \
    \              else\n                        error('Cannot divide by an odd number')\n\
    \                    end\n                elseif op == '**' and result ~= nil\
    \ then\n                    result = result ^ exp\n                end\n     \
    \       end\n        end\n    end\n    return result\nend", "    local i = 0\n\
    \    local j = 0\n    local result = 0\n    local count = 0\n    while i < #operator\
    \ and j < #operand do\n        local left_value = operator[i]\n        local right_value\
    \ = operand[j]\n        local operator_type = operator[i]\n        local right_operand\
    \ = operand[j + 1]\n        if operator_type == '+' and right_operand > 0 then\n\
    \            count = count + 1\n            local temp_value = left_value + right_value\n\
    \            if temp_value > 0 then\n                result = result + temp_value\n\
    \            end\n            i = i + 1\n            j = j + 1\n        elseif\
    \ operator_type == '-' and right_operand > 0 then\n            count = count +\
    \ 1\n            local temp_value = left_value - right_value\n            if temp_value\
    \ > 0 then\n                result = result + temp_value\n            end\n  \
    \          i = i + 1\n            j = j + 1\n        elseif operator_type == '*'\
    \ and right_operand > 0 then\n            count = count + 1\n            local\
    \ temp_value = left_value * right_value\n            if temp_value > 0 then\n\
    \                result = result + temp_value\n            end\n            i\
    \ = i + 1\n            j = j + 1\n        elseif operator_type == '//' and right_operand\
    \ > 0 then\n            count = count + 1\n            local temp_value = left_value\
    \ // right_value\n            if temp_value > 0 then\n                result =\
    \ result + temp_value\n            end\n            i = i + 1\n            j =\
    \ j + 1\n        elseif operator_type == '**' and right_operand > 0 then\n   \
    \         count = count + 1\n            local temp_value = left_value ** right_value\n\
    \            if temp_value > 0 then\n                result = result + temp_value\n\
    \            end\n            i = i + 1\n            j = j + 1\n        else\n\
    \            count = count + 1\n            i = i + 1\n            j = j + 1\n\
    \        end\n    end\n    \n    while i < #operator do\n        count = count\
    \ + 1\n        i = i + 1\n    end\n    while j < #operand do\n        count =\
    \ count + 1\n        j = j + 1\n    end\n    if count > 0 then\n        result\
    \ = result / count\n    end\n    \n    return result\nend", "  -- If either list\
    \ is empty return the empty list\n  if not operator or not operand\n  or #operator\
    \ == 0 or #operand == 0 then\n    return []\n  end", "  -- The first operand is\
    \ assumed to be the base, which is always 1.\n  local base = operand[1]\n  --\
    \ If there are no operands then the result is zero.\n  if not #operand == 2 then\n\
    \    return 0\n  elseif #operator == 0 then\n    return do_algebra(operator, operand)\n\
    \  else\n    local result = 0\n    local last_index = #operand\n    for i = 1,\
    \ #operand do\n      -- If the last item is a constant, then we do not need to\
    \ evaluate the expression\n      if i == last_index then\n        result = result\
    \ + base * operand[i]\n      else\n        -- Add the last expression's result\
    \ to the current expression's result, then \n        -- reset the last expression's\
    \ result and add this expression's result to \n        -- the current expression's\
    \ result.\n        result = result + do_algebra(operator, operand, last_index)\
    \ + base * operand[i]\n      end\n      -- Set last_index to the index of the\
    \ current expression.\n      last_index = i - 1\n    end\n    return result \n\
    \  end\nend", "    local result = 1\n    for i = 0, #operand - 1 do\n        result\
    \ = result * operand[i] + operator[i]\n    end\n    \n    if #operator > #operand\
    \ then\n        result = result * operand[#operand]\n    end\n    \n    return\
    \ result\nend", "   -- local stack = stack or {}\n   -- local stack = stack or\
    \ {}\n   -- local stack = stack or {}\n   -- local stack = stack or {}\n   --\
    \ local stack = stack or {}\n   -- local stack = stack or {}\n   -- local stack\
    \ = stack or {}", "    local operator_function = {\n        ['+'] = function(x,y)\
    \ return x + y end,\n        ['-'] = function(x,y) return x - y end,\n       \
    \ ['*'] = function(x,y) return x * y end,\n        ['//'] = function(x,y) return\
    \ x // y end,\n        ['**'] = function(x,y) return x ** y end\n    }\n    local\
    \ expression_stack = {}\n    local result_stack = {}\n    local result_expression_stack\
    \ = {}\n    local result_result_stack = {}", "  local res = operand[1]\n  for\
    \ i = 2, #operand do\n    res = math_operators[operator](res, operand[i])\n  end\n\
    \  return res\nend", "   -- Start with a '0' and an '1', and add the first two\
    \ operands onto the end \n   -- of the first list and the second list respectively.\
    \ \n   local result = { [0] = '0', [1] = '1' }\n   for i=1,#operand,1 do\n   \
    \   -- Add the operand to the result list onto the end of the operand list, \n\
    \      -- and append the result onto the end of the result list. \n      local\
    \ operand = operand[i]\n      result[#result+1] = result[#result+1] + operand\
    \ \n      -- Since the operator list has at least one operator, we can \n    \
    \  -- simply return the result list. \n      if i == 1 then\n         return result\n\
    \      end\n      -- Otherwise, loop through the operator list until we find \n\
    \      -- one that matches the current operator we are on \n      for j=1,#operator,1\
    \ do\n         -- If the current operator matches the current operator \n    \
    \     -- in the operator list, we know we have a match. \n         if operator[j]\
    \ == operator[j] then\n            -- If the current operand matches the current\
    \ operand \n            -- in the operand list, we know we have a match. \n  \
    \          if operand[j] == operand[j] then\n               -- We have a match!\
    \ Let's reset the result \n               -- list and append the result onto the\
    \ end of the result \n               -- list. \n               result = { [0]\
    \ = '0', [1] = '1' }\n               result[#result+1] = result[#result+1] + operand\n\
    \               return result\n            end\n         end\n      end\n   end\n\
    \   -- If we reach this point, we did not have a match. \nend\n</cell>\n<text>\n\
    The function do_algebra takes in two lists -- operator and operand -- where operator\
    \ and operand are lists. \nThe first list in operator and operand are basic algebra\
    \ operations. \nThe second list operand is a list of integers. \nThe function\
    \ do_algebra returns the value of the given algebraic expression.\nThe basic algebra\
    \ operations: Addition ( + ), Subtraction ( - ), Multiplication ( * ), \nFloor\
    \ division ( // ), Exponentiation ( ** ). The length of the operator list is equal\
    \ to the length of operand list minus one. \nOperand is a list of of non-negative\
    \ integers.\nOperator list has at least one operator, and operand list has at\
    \ least two operands.", "    local n1 = #operand\n    local n2 = #operator\n \
    \   if n1 > 0 and n2 > 0 then\n        local result = nil\n        local i = 1\n\
    \        while i <= n1 do\n            local a1 = operand[i]\n            local\
    \ b1 = operand[i + 1]\n            local op = operator[i]\n            local b2\
    \ = operand[i + 2]\n            local r = \"\"\n            if op == \"+\" then\n\
    \                r = r + a1 + b1\n            elseif op == \"-\" then\n      \
    \          r = r - a1\n            elseif op == \"*\" then\n                r\
    \ = r * a1\n            elseif op == \"/\" then\n                r = r / a1\n\
    \            elseif op == \"//\" then\n                r = r // a1\n         \
    \   elseif op == \"**\" then\n                r = r ** a1\n            else\n\
    \                print(\"Unknow Operator: \" .. op)\n                return nil\n\
    \            end\n            i = i + 3\n            if i == n1 then\n       \
    \         result = r\n                i = i + 1\n            end\n        end\n\
    \        while i <= n2 do\n            local a2 = operand[i]\n            local\
    \ b2 = operand[i + 1]\n            local op = operator[i]\n            local r\
    \ = \"\"\n            if op == \"+\" then\n                r = r + a2 + b2\n \
    \           elseif op == \"-\" then\n                r = r - a2\n            elseif\
    \ op == \"*\" then\n                r = r * a2\n            elseif op == \"/\"\
    \ then\n                r = r / a2\n            elseif op == \"//\" then\n   \
    \             r = r // a2\n            elseif op == \"**\" then\n            \
    \    r = r ** a2\n            else\n                print(\"Unknow Operator: \"\
    \ .. op)\n                return nil\n            end\n            i = i + 2\n\
    \            if i == n2 then\n                result = r\n                i =\
    \ i + 1\n            end\n        end\n        return result\n    elseif n1 ==\
    \ 0 and n2 == 0 then\n        return true\n    else\n        return nil\n    end\n\
    end", "    local result = {}\n    for i,v in pairs(operand) do\n        table.insert(result,\
    \ v)\n    end\n    for i,v in pairs(operator) do\n        local operand_value\
    \ = result\n        for ii=1,#operand,2 do \n            local next_value = operand_value[ii]\n\
    \            operand_value[ii] = next_value opv next_value \n        end\n   \
    \     result[i] = operand_value[1]\n    end\n    return table.concat(result)\n\
    end\n</cell>\n<cell>", "   local stack = {}\n   for i = 1, #operator do\n    \
    \  table.insert(stack, operator[i])\n   end\n   table.insert(stack, '+')\n   table.insert(stack,\
    \ operand[1])\n   if #operand>1 then\n      table.insert(stack, '*')\n      table.insert(stack,\
    \ operand[2])\n   end\n   if #operand>2 then\n      table.insert(stack, '-')\n\
    \      table.insert(stack, operand[3])\n   end\n   if #operand>3 then\n      table.insert(stack,\
    \ '/')\n      table.insert(stack, operand[4])\n   end\n   if #operand>4 then\n\
    \      table.insert(stack, '**')\n      table.insert(stack, operand[5])\n   end\n\
    \   \n   return stack\nend\n</code>\n<|/ a |>\n<| a tags=parsing,lua,expression,functional-programming\
    \ |>\nThis answer does not focus on functional programming but rather how one\
    \ can create simple evaluators using recursive descent parsing. \nThis approach\
    \ is based on two observations:", "\tlocal result = 0\n\tfor i = 1, #operator\
    \ do\n\t\tif i > 1 then\n\t\t\tresult = result .. \" + \" .. operand[i]\n\t\t\
    else\n\t\t\tresult = result .. \" \" .. operator[i] .. \" \" .. operand[i]\n\t\
    \tend\n\tend\n\treturn result\nend", "  local function add_operand_and_operator(operand,\
    \ operator)\n    local result\n    \n    if #operand > 0 then\n      local i =\
    \ 1\n      repeat\n        if i == 1 then\n          result = operand[1]\n   \
    \     else\n          result = result .. operator[1] .. operand[i]\n        end\n\
    \        i = i + 2\n      until #operand > i\n    end", "  local result = 0\n\
    \  local op = operator[1]\n  local i = 2\n  while i <= #operator do\n    if operand[i]\
    \ ~= nil then\n      if op == '+' then\n        result = result + operand[i]\n\
    \      elseif op == '-' then\n        result = result - operand[i]\n      elseif\
    \ op == '*' then\n        result = result * operand[i]\n      elseif op == '/'\
    \ then\n        result = result // operand[i]\n      elseif op == '**' then\n\
    \        result = result ** operand[i]\n      end\n    end\n    i = i + 1\n  end\n\
    \  return result\nend", "    local value = 0\n    local i = 0\n    local operands_count\
    \ = #operand\n    for k in pairs(operator) do\n        i = i + 1\n        local\
    \ op = operator[k]\n        if op == \"-\" then\n            value = value - operands[i]\n\
    \        elseif op == \"*\" then\n            value = value * operands[i]\n  \
    \      elseif op == \"//\" then\n            value = value // operands[i]\n  \
    \      elseif op == \"**\" then\n            value = value ^ operands[i]\n   \
    \     else\n            print(\"Wrong operation in algebra function\")\n     \
    \   end\n    end\n    return value\nend", "    local result = operand[1]\n   \
    \ for i=2,#operand do\n        result = result operator[i-1] operand[i]\n    end\n\
    \    return result\nend", "  local ops = {}\n  for _, v in pairs(operator) do\n\
    \    table.insert(ops, v)\n  end\n  local result = operand[1]\n  for _, v in pairs(operand)\
    \ do\n    result = ops[v](result, operand[2])\n  end\n  return result\nend", "\t\
    local res = nil\n\tlocal operator_list = {\n\t\t'+', \n\t\t'-', \n\t\t'*', \n\t\
    \t'/', \n\t\t'//', \n\t\t'**', \n\t}\n\tlocal operand_list = {\n\t\t2, \n\t\t\
    3, 4, \n\t\t5,\n\t}\n\tlocal op_list = table.insert(operator_list, operator)\n\
    \tlocal op_list2 = table.insert(operand_list, operand)\n\tlocal op_list3 = table.insert(operator_list,\
    \ operator)\n\tlocal op_list4 = table.insert(operand_list, operand)\n\tlocal op_list5\
    \ = table.insert(operator_list, operator)\n\tlocal op_list6 = table.insert(operand_list,\
    \ operand)", "    local operand_size = #operand\n    local operator_size = #operator\n\
    \    \n    if operand_size == 0 and operator_size == 0 then\n        return nil\n\
    \    end\n    \n    local left_operand = operand[1]\n    local right_operand =\
    \ operand[2]\n    \n    local function try_operand_one(operand)\n        if operand\
    \ == nil then\n            return nil\n        end\n        \n        if operand_size\
    \ ~= 1 then\n            return nil\n        end\n        \n        local result_operand\
    \ = operand[1]\n        \n        if result_operand ~= nil then\n            return\
    \ result_operand\n        end\n        \n        return operand\n    end\n   \
    \ \n    local function try_operand_two(operand)\n        if operand == nil then\n\
    \            return nil\n        end\n        \n        if operand_size ~= 2 then\n\
    \            return nil\n        end\n        \n        local left_operand = try_operand_one(operand)\n\
    \        if left_operand == nil then\n            return nil\n        end\n  \
    \      \n        local right_operand = try_operand_one(operand)\n        if right_operand\
    \ == nil then\n            return nil\n        end\n        \n        local result_operand\
    \ = left_operand + right_operand\n        \n        if result_operand ~= nil then\n\
    \            return result_operand\n        end\n        \n        return nil\n\
    \    end\n    \n    local function try_operand_three(operand)\n        if operand\
    \ == nil then\n            return nil\n        end\n        \n        if operand_size\
    \ ~= 3 then\n            return nil\n        end\n        \n        local left_operand\
    \ = try_operand_one(operand)\n        if left_operand == nil then\n          \
    \  return nil\n        end\n        \n        local right_operand = try_operand_one(operand)\n\
    \        if right_operand == nil then\n            return nil\n        end\n \
    \       \n        local left_operand2 = try_operand_one(operand)\n        if left_operand2\
    \ == nil then\n            return nil\n        end\n        \n        local right_operand2\
    \ = try_operand_one(operand)\n        if right_operand2 == nil then\n        \
    \    return nil\n        end\n        \n        local result_operand = left_operand\
    \ + right_operand + left_operand2 + right_operand2\n        \n        if result_operand\
    \ ~= nil then\n            return result_operand\n        end\n        \n    \
    \    return nil\n    end\n    \n    local function try_operand_four(operand)\n\
    \        if operand == nil then\n            return nil\n        end\n       \
    \ \n        if operand_size ~= 4 then\n            return nil\n        end\n \
    \       \n        local left_operand = try_operand_one(operand)\n        if left_operand\
    \ == nil then\n", "  local value1 = operand[1]\n  local value2 = operand[2]\n\
    \  local result\n  local operands", "    local total = 0\n    for i = 1, #operand-1\
    \ do\n        local tmp = 0\n        for j = 1, #operator do\n            local\
    \ op = operator[j]\n            local arg = operand[i+j]\n            local tmp2\
    \ = arg\n            \n            if op == \"+\" then\n                tmp2 =\
    \ arg + tmp2\n            elseif op == \"-\" then\n                tmp2 = arg\
    \ - tmp2\n            elseif op == \"*\" then\n                tmp2 = arg * tmp2\n\
    \            elseif op == \"//\" then\n                tmp2 = arg // tmp2\n  \
    \          elseif op == \"**\" then\n                tmp2 = arg ** tmp2\n    \
    \        else\n                error(\"Unknown operator \" .. op)\n          \
    \  end\n            \n            tmp = tmp + tmp2\n        end\n        total\
    \ = total + tmp\n    end\n    return total\nend", "\tlocal result = operand[1]\n\
    \tfor i = 2, #operand do\n\t\tresult = operator[#operator]( result, operand[i]\
    \ )\n\tend\n\treturn result\nend", "\tassert(#operator > 0, 'Operator list has\
    \ zero or negative operators')\n\tassert(#operand > 0, 'Operand list has zero\
    \ or negative operands')\n\tlocal result = 0\n\t\n\tlocal operandCount = #operand\n\
    \t\n\t-- Iterate through the operand list from left to right.\n\t-- The leftmost\
    \ operator acts on the leftmost operand and so on.\n\tlocal i = 1\n\twhile i <=\
    \ operandCount do\n\t\t\n\t\t-- Check if we are at the end of operand list.\n\t\
    \tif operandCount == i then\n\t\t\tresult = result\n\t\t\t\n\t\t\t-- Iterate through\
    \ the operator list from right to left.\n\t\t\t-- The rightmost operator acts\
    \ on the rightmost operand and so on.\n\t\t\ti = operandCount\n\t\telse\n\t\t\t\
    \n\t\t\t-- Calculate the result by applying the operator at the current index\n\
    \t\t\t-- to the operand.\n\t\t\tlocal operatorName = operator[i]\n\t\t\tresult\
    \ = result + operand[i-1]\n\t\t\t\n\t\t\t-- Check if the operator is a basic algebra\
    \ operation and apply it to\n\t\t\t-- the current operand.\n\t\t\tif operatorName\
    \ == '+' or operatorName == '-' or operatorName == '*' or operatorName == '/'\
    \ or operatorName == '^' then\n\t\t\t\tresult = result + do_algebra(operator,\
    \ operand[i])\n\t\t\telse\n\t\t\t\t-- Check if the operator is an exponentiation\
    \ operator and apply it to\n\t\t\t\t-- the current operand.\n\t\t\t\tif operatorName\
    \ == '**' then\n\t\t\t\t\tresult = result + operand[i] ** 2\n\t\t\t\tend\n\t\t\
    \tend\n\t\t\t\n\t\tend\n\t\t\n\t\ti = i + 1\n\tend\n\t\n\t-- Return the evaluated\
    \ result.\n\treturn result\nend", "    local op = operator[1]\n    local op =\
    \ operand[#operand]\n    if op == \"+\" then\n        -- Addition\n        return\
    \ operand[#operand]\n    elseif op == \"-\" then\n        -- Subtraction\n   \
    \     return -operand[#operand]\n    elseif op == \"*\" then\n        -- Multiplication\n\
    \        return operand[#operand] * operand[#operand]\n    elseif op == \"/\"\
    \ then\n        -- Floor division\n        return operand[#operand] // operand[#operand]\n\
    \    elseif op == \"**\" then\n        -- Exponentiation\n        return operand[#operand]\
    \ ** operand[#operand]\n    end\nend", "\tlocal total = 0\n\tlocal op1 = operator[1]\n\
    \tlocal op2 = operator[2]\n\tlocal op3 = operator[3]\n\tlocal op4 = operator[4]\n\
    \tlocal op5 = operator[5]\n\tlocal op6 = operator[6]\n\tlocal op7 = operator[7]\n\
    \tlocal op8 = operator[8]\n\tlocal op9 = operator[9]\n\tlocal op10 = operator[10]\n\
    \tlocal op11 = operator[11]\n\tlocal op12 = operator[12]\n\tlocal op13 = operator[13]\n\
    \tlocal op14 = operator[14]\n\tlocal op15 = operator[15]", "  -- First we must\
    \ convert the lists into numbers\n  local num_operand = tonumber(operand[1])\n\
    \  local num_operator = tonumber(operator)\n  -- If either list is nil, return\
    \ nil\n  if num_operand == nil or num_operator == nil then\n    return nil\n \
    \ else\n    -- If the first list is not an algebraic expression (valid operator)\
    \ then return nil\n    if num_operator ~= num_operand - 1 then\n      return nil\n\
    \    end\n    -- If the length of the operand list is 1, then the operand must\
    \ be the only operand of the algebraic expression\n    if num_operand == 1 then\n\
    \      return tonumber(operand[0])\n    else\n      -- The first list is the operand\n\
    \      local result = tonumber(operand[0])\n      -- The first operator is the\
    \ operator and must not exceed the number of operands \n      local operator =\
    \ tonumber(operator)\n      -- The second list is the operand\n      local operand2\
    \ = tonumber(operand[1])\n      -- If there is no second list or the second list\
    \ is not an algebraic expression\n      if operand2 == nil or num_operator ~=\
    \ num_operand - 1 then\n        return result\n      else\n        -- If the first\
    \ list is greater than or equal to the second list then the two operands cannot\
    \ be\n        -- added together as it will cause an integer overflow\n       \
    \ if operator >= num_operand then\n          return nil\n        else\n      \
    \    -- Add the two operands together and return the result\n          return\
    \ tonumber(result) + tonumber(operand2)\n        end\n      end\n    end\n  end\n\
    end", "\tif #operator == 0 then\n\t\treturn operand\n\telseif #operand == 0 then\n\
    \t\treturn nil\n\tend", "\t-- Your code here\n\t\n\t-- Return result\n\t\nend",
  "    -- TODO: Implement doAlgebra function here\n    return 0 -- Replace this dummy\
    \ return statement with your code.\nend", "   if #operand == 0 then\n      print('Operator\
    \ list must have at least one operand.')\n      return nil\n   end\n   if #operator\
    \ == 0 then\n      print('Operator list must have at least one operator.')\n \
    \     return nil\n   end\n   if #operand ~= #operator then\n      print('Operator\
    \ list and operand list must have the same number of elements.')\n      return\
    \ nil\n   end\n   local expr = 1\n   for _, op in ipairs(operator) do\n      expr\
    \ = expr * op * operand\n   end\n   return expr\nend", "  local result = operand[1]\n\
    \  for i = 2, #operand do\n    if operator[i - 2] ~= '^' then\n      result =\
    \ operand[i] .. operator .. operand[i - 1]\n    else\n      result = operand[i]\
    \ .. result .. '**' .. operand[i - 1]\n    end\n  end\n  return result\nend",
  "\t-- Get the two lists' lengths first.\n\tlocal numOperators = #operator\n\tlocal\
    \ numOperands = #operand", "\tlocal function do_algebric_expression(expression,\
    \ index, array)\n\t\tif index < #array then\n\t\t\tlocal value = array[index]\n\
    \t\t\t\n\t\t\t-- Multiply a number\n\t\t\tif value == operand:get(index) then\n\
    \t\t\t\tlocal left = do_algebric_expression(expression, index + 1, array)\n\t\t\
    \t\tlocal right = do_algebric_expression(expression, index + 1, array)\n\t\t\t\
    \treturn left + right\n\t\t\tend\n\t\t\t\n\t\t\t-- Add a number\n\t\t\tif value\
    \ == operator then\n\t\t\t\tlocal left = do_algebric_expression(expression, index\
    \ + 1, array)\n\t\t\t\tlocal right = do_algebric_expression(expression, index\
    \ + 1, array)\n\t\t\t\treturn left + right\n\t\t\tend\n\t\t\t\n\t\t\t-- Subtract\
    \ a number\n\t\t\tif value == operator:reverse() then\n\t\t\t\tlocal left = do_algebric_expression(expression,\
    \ index + 1, array)\n\t\t\t\tlocal right = do_algebric_expression(expression,\
    \ index + 1, array)\n\t\t\t\treturn left - right\n\t\t\tend\n\t\tend\n\tend\n\t\
    \n\treturn do_algebric_expression({}, 0, operand)\nend", "  local result = operand[1]\n\
    \  for _, i in pairs(operator) do\n    result = operator[i](result, operand[i..-1])\n\
    \  end\n  return result\nend", "\tlocal function do_basic(operator, operand)\n\
    \t\tif (#operator == 0) then\n\t\t\treturn operand[1]\n\t\telseif (#operand ==\
    \ 1) then\n\t\t\treturn operand[#operand] * operand[1]\n\t\telse\n\t\t\t-- The\
    \ length of the operator list equals to the length of the operand list minus one\n\
    \t\t\tlocal left, right = operand[1], operand[#operand]\n\t\t\tlocal length =\
    \ #operator - 1\n\t\t\tlocal result\n\t\t\t-- The index of the left most operator\
    \ is 1, and the index of the right most operator is length - 1\n\t\t\tfor index\
    \ = 1, #operator - 1 do\n\t\t\t\tlocal operation = operator[index]\n\t\t\t\t--\
    \ Do the basic arithmetic operation\n\t\t\t\tif operation == '+' then\n\t\t\t\t\
    \tresult = result + left\n\t\t\t\telseif operation == '-' then\n\t\t\t\t\tresult\
    \ = result - left\n\t\t\t\telseif operation == '*' then\n\t\t\t\t\tresult = result\
    \ * left\n\t\t\t\telseif operation == '//' then\n\t\t\t\t\tresult = result //\
    \ left\n\t\t\t\telseif operation == '**' then\n\t\t\t\t\tresult = result ** left\n\
    \t\t\t\tend\n\t\t\t\tleft = right\n\t\t\t\tright = result\n\t\t\t\tresult = nil\n\
    \t\t\tend\n\t\t\treturn result\n\t\tend\n\tend\n\tlocal function do_power(operator,\
    \ operand)\n\t\tif (#operator == 1) then\n\t\t\treturn operand[1]\n\t\telse\n\t\
    \t\t-- The length of the operator list equals to the length of the operand list\
    \ minus one\n\t\t\tlocal left, right = operand[1], operand[#operand]\n\t\t\tlocal\
    \ length = #operator - 1\n\t\t\tlocal result\n\t\t\t-- The index of the left most\
    \ operator is 1, and the index of the right most operator is length - 1\n\t\t\t\
    for index = 1, #operator - 1 do\n\t\t\t\tlocal operation = operator[index]\n\t\
    \t\t\t-- Do the basic arithmetic operation\n\t\t\t\tif operation == '**' then\n\
    \t\t\t\t\tresult = result ** left\n\t\t\t\tend\n\t\t\t\tleft = right\n\t\t\t\t\
    right = result\n\t\t\t\tresult = nil\n\t\t\tend\n\t\t\treturn result\n\t\tend\n\
    \tend\n\tlocal function do_power(operator, operand)\n\t\tif (#operator == 1) then\n\
    \t\t\treturn operand[1]\n\t\telse\n\t\t\t-- The length of the operator list equals\
    \ to the length of the operand list minus one\n\t\t\tlocal left, right = operand[1],\
    \ operand[#operand]\n\t\t\tlocal length = #operator - 1\n\t\t\tlocal result\n\t\
    \t\t-- The index of the left most operator is 1, and the index of the right most\
    \ operator is length - 1\n\t\t\tfor index = 1, #operator - 1 do\n\t\t\t\tlocal\
    \ operation = operator[index]\n\t\t\t\t-- Do the basic arithmetic operation\n\t\
    \t\t\tif operation == '**' then\n\t\t\t\t\tresult = result ** left\n\t\t\t\tend\n\
    \t\t\t\tleft = right\n\t\t\t\tright = result\n\t\t\t\tresult = nil\n\t\t\tend\n\
    \t\t\treturn result\n\t\tend\n\tend\n\tlocal ", "   local i = 1\n   local ops\
    \ = {}\n   local op", "   local result = 0\n   for i = 1,#operand do\n      result\
    \ = result + operand[i]\n   end\n   for i = 1,#operator do\n      result = result\
    \ + operator[i]\n   end\n   return result\nend", "\tlocal op = operator[1]\n\t\
    local op = operator[2]", "\t-- assert(type(operator) == 'table')\n\t-- assert(type(operand)\
    \ == 'table')\n\t-- assert(type(operator) == type(operand))\n\t-- assert(#operand\
    \ > 1)\n\t-- assert(#operator > 1)", "  local function add_ops(ops, operands)\n\
    \    local results = {}\n    for i, v in pairs(ops) do\n      local rv = operands[i]\n\
    \      results[i] = rv * v\n    end\n    return results\n  end", "   if #operator\
    \ ~= #operand then\n      print('error: #operator ~= #operand');\n      return\
    \ 0;\n   end\n   local result = 0;\n   for i = 1, #operand do\n      local temp\
    \ = operand - 1;\n      result = result + do_algebra(operator[i], operand[temp]);\n\
    \   end\n   return result;\nend", "  local result = 0\n  \n  for i = 2, #operator\
    \ do\n    result = result + operand[i - 2] * operator[i - 1]\n  end\n  return\
    \ result\nend\n</cell>\n<text>\nProblem 8 - Part 1\nA function is a named entity,\
    \ meaning it is an entity which can be referenced by name. Functions are used\
    \ to encapsulate pieces of code which share state and functionality. Write a function,\
    \ is_five(x) which checks whether a number is an integer and is an integer multiple\
    \ of five (i.e 5*x).", "  -- Write your code here!\nend", "  local function do_basic(operator,\
    \ operand)\n    local function to_str(op, op1, op2)\n      if op == nil then return\
    \ nil end\n      if op2 == nil then return \"(\" .. op .. op1 .. \")\" else return\
    \ \"(\" .. op .. op1 .. \" \" + op2 .. \")\" end\n    end\n    local function\
    \ to_expr(op, op1, op2)\n      if op == nil then return nil end\n      if op2\
    \ == nil then return \"(\" .. op .. op1 .. \")\" else return \"(\" .. op .. op1\
    \ .. \" \" + op2 .. \")\" end\n    end\n    local function to_op(op1, op2)\n \
    \     if op1 == nil then return nil end\n      if op2 == nil then return \"(\"\
    \ .. op1 .. \")\" else return \"(\" .. op1 .. \" \" + op2 .. \")\" end\n    end\n\
    \    local function to_op2(op1)\n      if op1 == nil then return nil end\n   \
    \   if op2 == nil then return \"(\" .. op1 .. \")\" else return \"(\" .. op1 ..\
    \ \" \" + op2 .. \")\" end\n    end\n    local function to_op3(op1, op2, op3)\n\
    \      if op1 == nil then return nil end\n      if op2 == nil then return \"(\"\
    \ .. op1 .. \")\" else return \"(\" .. op1 .. \" \" + op2 .. \" \" + op3 .. \"\
    )\" end\n    end\n    local function to_op4(op1, op2, op3, op4)\n      if op1\
    \ == nil then return nil end\n      if op2 == nil then return \"(\" .. op1 ..\
    \ \")\" else return \"(\" .. op1 .. \" \" + op2 .. \" \" + op3 .. \" \" + op4\
    \ .. \")\" end\n    end\n    local function to_op5(op, op1, op2, op3, op4, op5)\n\
    \      if op == nil then return nil end\n      if op2 == nil then return \"(\"\
    \ .. op .. op1 .. \")\" else return \"(\" .. op .. op1 .. \" \" + op2 .. \" \"\
    \ + op3 .. \" \" + op4 .. \" \" + op5 .. \")\" end\n    end\n    local function\
    \ to_op6(op, op1, op2, op3, op4, op5, op6)\n      if op == nil then return nil\
    \ end\n      if op2 == nil then return \"(\" .. op .. op1 .. \")\" else return\
    \ \"(\" ", "  local result, i = 1, #operand\n  repeat\n    if i == 1 then\n  \
    \    result = operand[i]\n    else\n      result = operator[i](result, operand[i])\n\
    \    end\n    i = i + 1\n  until i == #operand\n  return result\nend", "    assert(#operator\
    \ == #operand - 1)\n    \n    -- If the operator list has only one element, then\
    \ it must be the identity operator (*)\n    if #operator == 1 then\n        return\
    \ operand[1]\n    end\n    \n    -- Perform the actual algebraic operation\n \
    \   local result\n    if #operand == 1 then\n        result = do_algebra(operator[1],\
    \ operand[1])\n    else\n        result = do_algebra(operator[1], do_algebra(operator[2],\
    \ operand[1]))\n    end\n    \n    -- Perform the second algebraic operation\n\
    \    if #operand > 1 then\n        return do_algebra(operator[2], result)\n  \
    \  else\n        return result\n    end\nend", "  local result, operand1, operand2\
    \ = 0, 0, 0\n  for i = 1, #operator do\n    operand1 = operand1 + operand[i]\n\
    \    operand2 = operand2 + operand[#operand]\n  end\n  result = operator[1] *\
    \ operand1 + operator[2] * operand2 + operator[3]\n  return result\nend", "  \
    \ local result = operand[1]\n   local index = 1\n   for i = 2, #operand do\n \
    \     result = operator[operator] .. result\n      index = index + 1\n   end\n\
    \   return result\nend\n</cell>\n<cell>", "  local result\n  local i\n  for i\
    \ = 1, #operator do \n    local left = operand[i-1]\n    local right = operand[i]\n\
    \    if operator[i] == '+' then result = result + right end\n    if operator[i]\
    \ == '-' then result = result - right end\n    if operator[i] == '*' then result\
    \ = result * right end\n    if operator[i] == '/' then result = result / right\
    \ end\n    if operator[i] == '**' then result = result ^ right end\n  end\n  return\
    \ result\nend", "\tlocal result = operand[1]\n\tfor i = 2, #operand do\n\t\tresult\
    \ = operator[operand[i-1]](result, operand[i])\n\tend\n\treturn result\nend",
  "  local result = operand[1]\n  for i = 2, #operand do\n    local op1, op2 = unpack(operator,\
    \ i - 1, i - 1)\n    result = result + op1 * operand[i]\n  end\n  return result\n\
    end", "   local num_operator = #operator - 1\n   local num_operand = #operand\
    \ - 1\n   local result = 0\n   if num_operator == 0 then\n      result = 0\n \
    \  elseif num_operand == 0 then\n      result = 0\n   else\n      for i=1,num_operand\
    \ do\n         local operand1 = operand[i]\n         local operand2 = operand[i+1]\n\
    \         local operand_i = operand1\n         local operand_f = operand2\n  \
    \       local operator_index = num_operator\n         while operator_index > 0\
    \ do\n            local operator = operator[operator_index] \n            if operator\
    \ == '+' then\n               result = result + operand_i\n               operand_i\
    \ = operand_f\n               operand_f = operand_i + 1\n            elseif operator\
    \ == '-' then\n               result = result - operand_i\n               operand_i\
    \ = operand_f\n               operand_f = operand_i + 1\n            elseif operator\
    \ == '*' then\n               result = result * operand_i\n               operand_i\
    \ = operand_f\n               operand_f = operand_i + 1\n            elseif operator\
    \ == '/' then\n               result = result / operand_i\n               operand_i\
    \ = operand_f\n               operand_f = operand_i + 1\n            elseif operator\
    \ == '**' then\n               result = result ^ operand_i\n               operand_i\
    \ = operand_f\n               operand_f = operand_i + 1\n            else\n  \
    \             return nil\n            end\n            operator_index = operator_index\
    \ - 1\n         end\n      end\n   end\n   return result\nend", "   -- The first\
    \ element is the operator, the rest is the operand.\n   local operator_list =\
    \ operator\n   local operand_list = operand", "    local function do_addition(lhs,\
    \ rhs)\n        return lhs + rhs\n    end\n    local function do_subtraction(lhs,\
    \ rhs)\n        return lhs - rhs\n    end\n    local function do_multiplication(lhs,\
    \ rhs)\n        return lhs * rhs\n    end\n    local function do_division(lhs,\
    \ rhs)\n        return lhs / rhs\n    end\n    local function do_power(lhs, rhs)\n\
    \        return lhs ^ rhs\n    end\n    local function do_exponentiation(lhs,\
    \ rhs)\n        return lhs ^ rhs\n    end", "    local operand_length = #operand\n\
    \    local operator_list = { }\n    for _, v in ipairs(operator) do\n        operator_list[#operator_list+1]\
    \ = v\n    end\n    local result = { }\n    if operand_length == 0 then\n    \
    \    return result\n    end\n    if operand_length > 1 then\n        if operator_list[#operator_list]\
    \ == nil then\n            error(\"operator list is too short\")\n        end\n\
    \    end\n    if operand_length == 1 then\n        local first  = operand[1]\n\
    \        if operator_list[#operator_list] == nil then\n            error(\"operator\
    \ list is too short\")\n        end\n        if operator_list[#operator_list]\
    \ == '+' then\n            local second = operand[1]\n            result = operand_length\
    \ - 1\n            local tmp = first\n            for i = 1, operand_length -\
    \ 1 do\n                tmp = operand_length - i - 1 -- Multiplying by -1 is like\
    \ multiplying by -1\n                result[#result+1] = first + second * tmp\n\
    \            end\n            result[#result+1] = first + second * operand_length\n\
    \        elseif operator_list[#operator_list] == '-' then\n            local second\
    \ = operand[1]\n            result = operand_length - 1\n            local tmp\
    \ = first\n            for i = 1, operand_length - 1 do\n                tmp =\
    \ operand_length - i - 1 -- Multiplying by -1 is like multiplying by -1\n    \
    \            result[#result+1] = first - second * tmp\n            end\n     \
    \       result[#result+1] = first - second * operand_length\n        elseif operator_list[#operator_list]\
    \ == '*' then\n            local second = operand[1]\n            result = operand_length\
    \ - 1\n            local tmp = first\n            for i = 1, operand_length -\
    \ 1 do\n                tmp = operand_length - i - 1 -- Multiplying by -1 is like\
    \ multiplying by -1\n                result[#result+1] = first * second * tmp\n\
    \            end\n            result[#result+1] = first * second * operand_length\n\
    \        elseif operator_list[#operator_list] == '/' then\n            local second\
    \ = operand[1]\n            result = operand_length - 1\n            local tmp\
    \ = first\n            for i = 1, operand_length - 1 do\n                tmp =\
    \ operand_length - i - 1 -- Multiplying by -1 is like multiplying by -1\n    \
    \            result[#result+1] = first / second * tmp\n            end\n     \
    \       result[#result+1] = first / second * operand_length\n        elseif operator_list[#operator_list]\
    \ == '**' then\n            local second = operand[1]\n            result = operand_length\
    \ - 1\n            local tmp = first\n            for i = 1, operand_length -\
    \ 1 do\n                tmp = operand_length - i - 1 -- Multi", "  if #operator\
    \ ~= #operand then\n    return \"Wrong # of operands in do_algebra\"\n  end\n\
    \  for i = 1, #operator do \n    if #operand ~= 1 then\n      return \"Wrong #\
    \ of operands in do_algebra\"\n    end\n    if #operator[i] == 2 then\n      local\
    \ op1 = operator[i]\n      local op2 = operator[i+1]\n      local op1val = operand[i]\n\
    \      local op2val = operand[i+1]\n      if op1 == \"+\" then\n        operand[i]\
    \ = op1val + op2val\n      elseif op1 == \"-\" then\n        operand[i] = op1val\
    \ - op2val\n      elseif op1 == \"*\" then\n        operand[i] = op1val * op2val\n\
    \      elseif op1 == \"//\" then\n        operand[i] = math.floor(op1val / op2val)\n\
    \      elseif op1 == \"**\" then\n        operand[i] = math.pow(op1val, op2val)\n\
    \      end\n    end\n  end\n  return operand[1]\nend", "    assert(#operator ==\
    \ #operand)\n    local result = 0\n    for i=1, #operator do\n        local op\
    \ = operator[i]\n        local operand = operand[i]\n        local left, right\
    \ = operand:split(op)\n        result = result + (left * right)\n    end\n   \
    \ return result\nend", "    local result = 0\n    for i, v in ipairs(operand)\
    \ do\n        result = result + (v * operator[i])\n    end\n    return result\n\
    end", "    local result = operand[1]\n    local i = 2\n    while i < #operand\
    \ do\n        result = operator[operator[1]](result, operand[i])\n        i=i+1\n\
    \    end\n    return result\nend", "    -- Write your code here\n    \n    local\
    \ result = operand[1]\n    \n    for i = 2, #operand do\n        -- Write your\
    \ code here\n        result = operator[#operator](result, operand[i])\n    end\n\
    \    \n    return result\nend", "  local index = 1\n  local result = 0", "  local\
    \ function helper(oplist, operand)\n    local res = operand[1]\n    for i = 2,\
    \ #operand do\n      res = operator[oplist[i - 2]](res, operand[i])\n    end\n\
    \    return res\n  end\n  local oplist = unpack(operator)\n  return helper(oplist,\
    \ unpack(operand))\nend", "  -- Write your code here\n  -- Example\n  -- -- Write\
    \ your code here\n  -- Example\n  -- -- Write your code here\n  -- Example\n \
    \ -- -- Write your code here\n  -- Example\n  -- -- Write your code here\nend",
  "\tlocal result = 1\n\tfor i, v in ipairs(operator) do\n\t\tresult = (v ^ operand[i])\
    \ * result\n\tend\n\treturn result\nend", "    local result = {}\n    local i\
    \ = 1 -- Start at 1 to avoid having the last operator evaluate to zero\n    for\
    \ k = #operand, 1 do\n        -- If the operand list is empty, return zero\n \
    \       if i == 1 then\n            table.insert(result, 0)\n        else\n  \
    \          local op1 = operand[i-1]\n            local op2 = operand[i]\n    \
    \        local op1_idx = i - 1\n            local op2_idx = i\n            if\
    \ op1 == operator[op2] then\n                table.insert(result, operand[op2_idx]\
    \ * operand[op1_idx])\n            elseif op1 == operator['/'] then\n        \
    \        table.insert(result, operand[op2_idx] / operand[op1_idx])\n         \
    \   elseif op1 == operator['**'] then\n                table.insert(result, operand[op2_idx]\
    \ ** operand[op1_idx])\n            elseif op1 == operator['^'] then\n       \
    \         table.insert(result, operand[op2_idx] ** (operand[op1_idx]))\n     \
    \       else\n                table.insert(result, 0)\n            end\n     \
    \   end\n        i = i + 1\n    end\n    return unpack(result)\nend", "  local\
    \ left_operand = operand[1]\n  local right_operand = operand[2]\n  \n  local left_operator\
    \ = operator[1]\n  local right_operator = operator[2]\n  \n  local left_operands\
    \ = operand[1]\n  local right_operands = operand[2]\n  \n  local left_operands_length\
    \ = left_operands:size()\n  local right_operands_length = right_operands:size()\n\
    \  \n  -- If there is only one operand a + b, then a + b = a * b.\n  -- If there\
    \ is only one operand a + a, then a + a = a + a.\n  -- If there is only one operand\
    \ a + a * b, then a + a * b = a + a.\n  -- If there is only one operand a + a\
    \ * b, then a + a * b = a + a * b.\n  -- If there is more than one operand, then\
    \ a + b + c * d + e is equivalent to a + b + c * d + e, \n  -- where the addition\
    \ happens after the multiplication, rather than before.\n  -- That is to say,\
    \ the evaluation of this expression is simply the sum of the operands.\n  if left_operands_length\
    \ == 1 and right_operands_length == 1 then\n    if left_operands[1] == right_operands[1]\
    \ then\n      return left_operands[1]\n    end\n  end\n  \n  -- If there is only\
    \ one operand a + b, then a + b + c + d = a * b + c * d + d.\n  if left_operands_length\
    \ == 1 and right_operands_length == 2 then\n    if left_operands[1] == right_operands[1]\
    \ then\n      return left_operands[1] * right_operands[2] + left_operands[2] *\
    \ right_operands[1]\n    end\n  end\n  \n  -- If there is only one operand a +\
    \ a, then a + a + d = a + d.\n  if left_operands_length == 1 and right_operands_length\
    \ == 1 then\n    return left_operands[1] + left_operands[1] + left_operands[1]\n\
    \  end\n  \n  -- If there is only one operand a + a * b, then a + a * b = a +\
    \ a * b.\n  if left_operands_length == 1 and right_operands_length == 2 then\n\
    \    if left_operands[1] == right_operands[1] then\n      return left_operands[1]\
    \ * right_operands[2]\n    end\n  end\n  \n  -- If there is only one operand a\
    \ + a * b, then a + a * b = a + a * b.\n  if left_operands_length == 2 and right_operands_length\
    \ == 1 then\n    if left_operands[1] == right_operands[1] then\n      return left_operands[1]\n\
    \    end\n  end\n  \n  -- If there is only one operand a + a * b, then a + a *\
    \ b = a + a * b.\n  if left_operands_length == 2 and right_operands_length ==\
    \ 2 ", "  local operators = { } -- Dictionary of operators \n  local operands\
    \ = { } -- Dictionary of operands \n  local result = { } -- Temporary storage\
    \ to build the result.", "   -- The function will return result in a recursive\
    \ manner\n   if #operator == 1 then\n      return operand[1] + operand[2]\n  \
    \ elseif #operator == 2 then\n      return operand[1] * operand[2]\n   elseif\
    \ #operator == 3 then\n      return operand[1] * operand[2] + operand[3]\n   elseif\
    \ #operator == 4 then\n      return operand[1] * operand[2] + operand[3] * operand[4]\n\
    \   elseif #operator == 5 then\n      return operand[1] * operand[2] + operand[3]\
    \ * operand[4] * operand[5]\n   elseif #operator == 6 then\n      return operand[1]\
    \ * operand[2] + operand[3] * operand[4] * operand[5] + operand[6]\n   elseif\
    \ #operator == 7 then\n      return operand[1] * operand[2] + operand[3] * operand[4]\
    \ * operand[5] + operand[6] * operand[7]\n   elseif #operator == 8 then\n    \
    \  return operand[1] * operand[2] + operand[3] * operand[4] * operand[5] + operand[6]\
    \ * operand[7] * operand[8]\n   end\nend", "\tlocal op = {}\n\tfor _, oper in\
    \ ipairs(operator) do\n\t\tif op == \"+\" then table.insert(oper, 0)\n\t\tif op\
    \ == \"-\" then table.insert(oper, -1)\n\t\tif op == \"*\" then table.insert(oper,\
    \ 1)\n\t\tif op == \"/\" then table.insert(oper, 2)\n\t\tif op == \"%\" then table.insert(oper,\
    \ 2)\n\t\tif op == \"**\" then table.insert(oper, 4)\n\t\tif op == \"%*\" then\
    \ table.insert(oper, 2)\n\t\tend\n\tend\n\tlocal expr = 0\n\tfor _, oper in ipairs(operator)\
    \ do\n\t\tlocal operand1 = operand[1]\n\t\tlocal operand2 = operand[2]\n\t\tif\
    \ oper == 0 then expr = expr + operand1 + operand2\n\t\tif oper == 1 then expr\
    \ = expr - operand1 - operand2\n\t\tif oper == 2 then expr = expr * operand1 *\
    \ operand2\n\t\tif oper == 3 then expr = expr / operand1 / operand2\n\t\tif oper\
    \ == 4 then expr = expr % operand1\n\t\tif oper == 5 then expr = expr ** operand1\n\
    \t\tend\n\tend\n\treturn expr\nend", "  -- TODO: Improve error checking.\n  if\
    \ #operator ~= #operand then\n    return nil\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
