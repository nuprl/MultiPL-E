name: HumanEval_48_is_palindrome
language: lua
prompt: "-- Checks if given string is a palindrome\n-- >>> is_palindrome('')\n-- True\n\
  -- >>> is_palindrome('aba')\n-- True\n-- >>> is_palindrome('aaaaa')\n-- True\n--\
  \ >>> is_palindrome('zbcd')\n-- False\nlocal function is_palindrome(text)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_palindrome\n\
  \    lu.assertEquals(candidate(''), true)\n    lu.assertEquals(candidate('aba'),\
  \ true)\n    lu.assertEquals(candidate('aaaaa'), true)\n    lu.assertEquals(candidate('zbcd'),\
  \ false)\n    lu.assertEquals(candidate('xywyx'), true)\n    lu.assertEquals(candidate('xywyz'),\
  \ false)\n    lu.assertEquals(candidate('xywzx'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  text = text:gsub(\"([%s])\", \"%%%1\"):gsub(\"([%%s])\", \"%%%1\"\
    ):gsub(\"%%%1\", \"%1\"):gsub(\"%%%1\", \"%1\")\n  local i, j = 1, #text\n  while\
    \ i < j do\n    if text:sub(i, i) ~= text:sub((j - i - 1), (j - i - 1)) then\n\
    \      return false\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return true\n\
    end", "  return text:reverse():sub(1, #text * #text) == text\nend\n</cell>\n<text>\n\
    Strings Length", "  return text:reverse():sub(#text):reverse() == text\nend",
  "    local index, length = 1, #text\n    while index ~= 0 do\n        local char\
    \ = text[index]\n        if char ~= \" \" and char ~= \"\\n\" and char ~= \"\\\
    t\" then\n            local isPalindrome = string.lower(text) == string.lower(text:sub(1,\
    \ index))\n            if not isPalindrome then break end\n        end\n     \
    \   index, length = index + 1, length - index - 1\n    end\n    return true\n\
    end", "  local cb = string.gsub(text, \"[\" .. string.char(13) .. \"]\", \"\"\
    )\n  return cb == cb:reverse()\nend", "  return text:reverse():sub(1, #text -\
    \ 1) ~= text\nend", "  return text:reverse():sub(1, #text) == text\nend", "  \
    \ if text ~= text then return false end\n   local lower = text:lower()\n   local\
    \ upper = text:upper()\n   for i = 1, #text do\n      if lower[i] ~= upper[i]\
    \ then\n         return false\n      end\n   end\n   return true\nend", "  local\
    \ start = 0\n  local length = text\n  while start < length do\n    local middle\
    \ = start + (length - start) / 2\n    if text[middle] == text[middle] then\n \
    \     start = middle + 1\n    else\n      return false\n    end\n  end\n  return\
    \ true\nend", "\tlocal start = 1\n\tlocal end = text:len()\n\twhile start <= end\
    \ do\n\t\tlocal mid = start + (end - start) / 2;\n\t\tif text[mid] ~= text[mid]\
    \ then\n\t\t\treturn False\n\t\tend\n\t\tstart = mid + 1;\n\t\tend = mid - 1;\n\
    \tend\n\treturn True\nend", "    if text == nil then\n        return nil\n   \
    \ end\n    local i = text:len()\n    if i == 0 then\n        return true\n   \
    \ end\n    local j = i - 1\n    local mid = text:sub(i, i)\n    while j > 0 and\
    \ not text:sub(i, j) == mid do\n        j = j - 1\n    end\n    return j == 0\
    \ and text == text:reverse()\nend", "  return text:reverse() == text\nend", " \
    \   return text:reverse() == text\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Can you explain the `i` variable here? `for i = 1, #text` doesn't look right to\
    \ me.\n<|/ c |>\n<| c |>\nThat variable is the for loop variable. Since it is\
    \ looping over the string character by character, it is incremented each time\
    \ it goes through the loop\n<|/ c |>\n<| c |>\nI edited the answer to include\
    \ a link to a tutorial that explains the loop variable in more detail.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nJust a little bit more compact version with \"i\" variable:\n\
    <code>", "  return text == text:reverse()\nend", "  if text == nil then return\
    \ end\n  if text:len() ~= 1 then\n    return false\n  elseif text:sub(1,1) ==\
    \ text:sub(text-1:len()) then\n    return true\n  else\n    return false\n  end\n\
    end", "    if text == text then\n        return true\n    end", "  for i, v in\
    \ ipairs(text) do\n    if v and v ~= string.subv(text, i - 1, i) then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  local function reverse(text)\n\
    \    local s, i, j = text:find('%')\n    while s do\n      if text:sub(i, i) ==\
    \ text:sub(j, j) then\n        return text:sub(i, i + 1)\n      end\n      s,\
    \ i, j = text:find('%', i + 1)\n    end\n    return text\n  end\n  return reverse(text)\
    \ == text\nend", "   -- Check if text is empty or just whitespace\n   if not text\
    \ or text:match('^%s*$') then\n      return true\n   end", "  return string.gsub(text,\
    \ \"%d%d\", function(left, right)\n    if left ~= right then return false end\n\
    \  end)\nend", "  local length = text:len()\n  if length == 0 then return true\
    \ end\n  local first = tolower(text:sub(1, length / 2)):reverse()\n  if first\
    \ == text then return true end\n  return false\nend", "  local function is_palindrome_aux(text,\
    \ left, right)\n    if right < left then\n      return false\n    elseif text[left]\
    \ == text[right] then\n      return is_palindrome_aux(text, left + 1, right -\
    \ 1)\n    else\n      return false\n    end\n  end\n  return is_palindrome_aux(text,\
    \ 1, #text - 1)\nend\n</cell>\n<cell>", "    local text = text or ''\n    local\
    \ i, j = #text, 0\n    while i < j do\n        local letter = text:sub(i, j)\n\
    \        i = i - 1\n        j = j - 1\n        if letter ~= letter:reverse() then\n\
    \            return false\n        end\n    end\n    return true\nend\n</code>\n\
    <|/ a tags=lua |>\n<| a tags=lua |>\nYou can get all words in a string using string.gmatch.\
    \ For example\n<code>", "  return text:gsub(\"([^\" .. reverse(\"a-z\") .. \"\
    ]+)\", function (x)\n    return string.lower(x) == x:reverse() and x or nil\n\
    \  end)\nend", "   local n = #text\n   if n <= 1 then return true end\n   if n\
    \ <= 2 then\n      local first = text[1]\n      local last = text[n]\n      return\
    \ first == last and first ~= '%'\n   end\n   if text == text then return true\
    \ end\n   local middle = text:sub(1, #text / 2)\n   local reversed = middle:reverse()\n\
    \   return reverse(text, 0, #text / 2) == reversed\nend", "    local text = text\
    \ or ''\n    local t = text:gsub('.', function(s) return s:lower() end)\n    local\
    \ reverse = t:reverse()\n    return reverse == t\nend", "   return text\n   :gsub(\"\
    .\", function(ch)\n      local s = string.sub(text, 1, string.len(text) - string.len(ch))\n\
    \      return s == string.sub(text, 1, string.len(s) - 1) or s\n   end)\n   :gsub(\"\
    (.)(.)\", function(_, l1, l2)\n      return l2 == l1 or \"A\" == l1 and \"Z\"\
    \ == l2 or l1 == l2 or \"a\" == l1 and \"z\" == l2\n   end)\n   :gsub(\"(.)(.).\"\
    , function(_, l1, l2, l3)\n      return l2 == l3 and l1 == l3 or \"A\" == l1 and\
    \ \"Z\" == l2 and \"a\" == l3 and \"z\" == l3\n   end)\n   :sub(1,-1)\nend", " \
    \   local _text = text\n    if text == nil then\n        error('string required')\n\
    \    end\n    local length = #text\n    if length == 0 then\n        return true\n\
    \    end\n    if length ~= #_text then\n        -- palindrome is when same text\
    \ is reversed\n        return _text == _text:reverse()\n    end\n    -- if text\
    \ is equal or smaller than 2 character string then it is palindrome\n    if length\
    \ <= 2 then\n        return true\n    end\n    -- loop to check every character\
    \ in text string\n    for i = 1, (length / 2) do\n        local first = string.sub(text,\
    \ (i - 1), i)\n        local second = string.sub(text, (length - (i - 1)), i)\n\
    \        -- check for empty string\n        if first == nil or second == nil then\n\
    \            return true\n        end\n        -- check for non alphabet\n   \
    \     if first:match('[^a-zA-Z]') then\n            return false\n        end\n\
    \        -- check for non alphabet\n        if second:match('[^a-zA-Z]') then\n\
    \            return false\n        end\n        -- check for same character with\
    \ reverse\n        if first == second:reverse() then\n            return false\n\
    \        end\n    end\n    return true\nend", "    return text == reverse(text)\
    \ or is_palindrome(reverse(text))\nend", "  if text == nil then return false end\n\
    \  if text == \"\" then return true end\n  local length = #text\n  local start\
    \ = 1\n  local end = (length - 1) / 2\n  while start <= end do\n    if text[start]\
    \ ~= text[end] then\n      return false\n    end\n    start = start + 2\n    end\
    \ = end - 2\n  end\n  return true\nend", "    local text_reversed = text:reverse()\n\
    \    return text_reversed == text\nend", "    if text:len() <= 1 then return true\
    \ end\n    local reversed = text:reverse()\n    return text:sub(1, 1):sub(1, 1)\
    \ == reversed:sub(1, 1)\nend", "    local text = text:gsub(\"[%z%d%c%s]\", function(c)\
    \ -- replace anything that is not a letter, digit or symbol with \"z\"\n     \
    \   return c == \"z\" and \"%Z\" or c == \"%z\" and \"%Z\" or c == \"%z\" and\
    \ \"%Z\" or c == \"z\" and \"%z\"\n    end):reverse() -- reverse string", "  if\
    \ text == nil or text == \"\" then\n    return true\n  end", "    return text:reverse()\
    \ == text\nend", "  return text:reverse() == text\nend", "  if text == nil then\n\
    \    return false\n  end\n  text = text:lower()\n  text = text:gsub(\"[%z\\1-\\\
    127\\194-\\244\\255-\\357\\361-\\377]\", \"\")\n  text = text:gsub(\"[^a-zA-Z0-9\
    \ ]\", \"\")\n  local i, j, k\n  for i = 0, text:len(), 1 do\n    j = text:len()\n\
    \    while j > 0 and text[i] == \" \" do\n      i = i + 1\n      j = j - 1\n \
    \   end\n    if text[i] == \" \" then\n      i = i + 1\n      j = j - 1\n    end\n\
    \    for k = 1, j:len(), 1 do\n      if text[k] != text[i] then\n        return\
    \ false\n      end\n      i = i + 1\n      k = k + 1\n    end\n  end\n  return\
    \ true\nend", "    for i = 1,#text,1 do\n        if text[i] ~= text[i-1] then\n\
    \            return false\n        end\n    end\n    return true\nend\n</cell>\n\
    <text>\n6. Palindromic Numbers\nWrite a function to determine if a number is palindromic\
    \ or not.", "  return text:reverse():sub(1, text) ~= text:reverse()\nend", " \
    \ -- Check if the string is one character long\n  if #text < 2 then\n    return\
    \ true\n  end", "    return string.gsub(text, \"([^\" .. string.char(126) .. \"\
    ]+)\", function (c)\n        local first, last = string.find(text, c)\n      \
    \  if not first or not last then return nil end\n        if first < last then\n\
    \            return first..last-1\n        else\n            return first..last\n\
    \        end\n    end)\nend", "  local i, j = 1, #text - 1;\n  while i < j do\n\
    \    if text[i] ~= text[j] then\n      -- The character at position i isn't the\
    \ same as character at position j\n      return False;\n    end\n    i = i + 1;\n\
    \    j = j - 1;\n  end\n  return True;\nend", "    local text = text:lower()\n\
    \    return text == text:reverse()\nend", "\treturn text:reverse():find(text)\
    \ == 0 and 1 or 0\nend", "  for i = 1, (#text - 1) do\n    if text:sub(i, i) ~=\
    \ text:sub((i - 1), (i - 1)) then\n      return false\n    end\n  end", "  for\
    \ i = 1, (#text) do\n    if text:sub(i, i) ~= text:sub((#text) - i, #text - i)\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  -- TODO: Should\
    \ we care about case?\n  return text:reverse() == text -- TODO: Can we avoid creating\
    \ a copy of string?\nend\n</cell>\n<text>\nExercises\nImplement is_palindrome\
    \ using filter and map. Hint: filter takes a function and returns a new function.",
  "    local start = text:len()\n    local middle = text:len()\n    while middle ~=\
    \ start do\n        if text[middle] != text[start - middle] then\n           \
    \ return false\n        end\n        middle = middle - 1\n        start = start\
    \ - 1\n    end\n    return true\nend", "  local n = #text\n  local rev = ''\n\
    \  for i in string.gsub(string.reverse(text), '%s%s+$', '') do\n    rev = rev..i\n\
    \  end\n  return rev == text\nend", "    local _, backwards_index = text:find('^')\n\
    \    local _, forwards_index = text:find('$')\n    if backwards_index and forwards_index\
    \ then\n        return backwards_index == forwards_index\n    end\n    return\
    \ false\nend", "  text = text:lower()\n  return text:sub(1, #text) == text:sub(#text,\
    \ 1)\nend", "  -- TODO: Add cases where `text` is longer than one character\n\
    \  -- TODO: Optimize this with [SBOL]\n  return text:gsub('.', function(c) \n\
    \    local reversed = string.reverse(c)\n    return reversed == c\n  end)\nend\n\
    </cell>\n<text>\nStrings\nLet's take a look at some string related functions in\
    \ Lua:", "    if text == nil then\n        return false\n    end", "  local i,\
    \ j = 1, #text - 1;\n  while (i < j) do\n    if text[i] ~= text[j] then return\
    \ false end\n    i = i + 1;\n    j = j - 1;\n  end\n  return true;\nend", "  \
    \ text = text:lower()\n   for i = 1,#text do\n      if text:sub(i,i) == text:sub(-i,-i)\
    \ then return false end\n   end\n   return true\nend", "    return string.gsub(text,\
    \ \"[%z\\1-\\3]\", function(c) \n        return string.char(tonumber(c))\n   \
    \ end) == text\nend", "  if text == nil then\n    return false\n  end\n  return\
    \ text:sub(1, #text) == text:sub((#text - 1), #text) -- Reverse the string and\
    \ compare it to the original\nend", "  local index = 1\n  local reversed_string\
    \ = ''", "  local i, j = #text, 1, 1\n  while i < j do\n    if text[i] ~= text[j]\
    \ then\n      j = j - 1\n    else\n      i = i + 1\n    end\n  end\n  return j\
    \ == 1\nend", "  text = text:gsub('.', function(c) return t:byte(c) end):reverse()\n\
    \  return text == text\nend", "  text = text:gsub('^[+-]', '')\n  text = text:gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d',\
    \ '')\n  text = text:gsub('%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d%%%%d',\
    \ '')\n  local is_palindrome = true\n  for i = 1, #text do\n    if text:sub(i,\
    \ i) == text:sub((i - 1), (i - 1)) then\n      is_palindrome = false\n      break\n\
    \    end\n  end\n  return is_palindrome\nend", "    local t = text:lower()\n \
    \   local i, j = 1, #t\n    while i <= j do\n        if t[i] ~= t[j] then\n  \
    \          return false\n        end\n        i = i + 1\n        j = j - 1\n \
    \   end\n    return true\nend", "    local strlen = text:len()\n    local half\
    \ = math.floor(strlen/2)\n    local firsthalf = str:sub(1,half)\n    local secondhalf\
    \ = str:sub(half,strlen-1)\n    return firsthalf == secondhalf\nend\n</cell>\n\
    <text>\n3. \uBB38\uC81C\n\uB2E4\uC74C\uC758 \uBB38\uC81C\uC5D0\uC11C\uB294 \uAC19\
    \uC740 \uBB38\uC790\uC758 \uC591\uC744 \uC90C \uC218 \uC788\uC73C\uBA70, \uC591\
    \uC758 \uAC1C\uC218\uB97C \uC124\uC815\uD569\uB2C8\uB2E4. \uBB38\uC790\uC758 \uC591\
    \uC744 \uD55C\uBC88\uC5D0 \uC90C\uC73C\uB85C \uD45C\uC2DC\uD558\uAE30 \uC804\uC5D0\
    \ \uC591\uC758 \uAC1C\uC218\uB97C \uC124\uC815\uD574\uC57C \uD569\uB2C8\uB2E4.",
  "    return text:reverse():lower() == text:lower()\nend", "    local function reverse(text,\
    \ start, end)\n        start = start or 0\n        end = end or #text\n      \
    \  local new_text = \"\"\n        for i = start, end do\n            new_text\
    \ = new_text .. text[i]\n        end\n        return new_text\n    end", "\tlocal\
    \ i, j = 1, #text - 1\n\twhile i <= j do\n\t\tif text[i] ~= text[j] then\n\t\t\
    \treturn false\n\t\tend\n\t\ti = i + 1\n\t\tj = j - 1\n\tend\n\treturn true\n\
    end", "  for i=1,#text do\n    if text[i] ~= text[-i] then\n      return false\n\
    \    end\n  end\n  return true\nend", "    local start, end = text:len(), text:len()\n\
    \    for i = 1, start do\n        if text:sub(i, i) == text:sub(end - i, end -\
    \ i) then\n            start = end - 1\n        else\n            end--\n    \
    \    end\n    end\n    return start == 1 and text:sub(1, 1) == text:sub(end -\
    \ 1, 1)\nend", "  if text == nil then return false end\n  return string.gsub(text,\
    \ \"[\" .. string.rep(\"]\", #text - 1) .. \"]\", \"\")\n    == string.gsub(text,\
    \ \"[\" .. string.rep(\"[\", #text - 1) .. \"]\", \"\")\nend", "  return text:gsub('.',\
    \ function(c) return c:reverse() end)\n  :gsub('^.', '')\n  :gsub('$', ''):reverse()\n\
    \  :len()\n  :le(1)\nend", "   if text == nil then return false end\n   for i\
    \ = #text, 1, -1 do\n      local c = text:sub(i, i)\n      if c ~= c then\n  \
    \       return false\n      end\n   end\n   return true\nend", "    local start,\
    \ stop = text:len(), text:len() -1\n    for i = start, stop do\n        if text:sub(i,\
    \ i) ~= text:sub(stop, i) then\n            return false\n        end\n    end\n\
    \    return true\nend", "\tlocal s, e, i, j = text:reverse():find(' ')\n\tif s\
    \ == nil then\n\t\treturn text == text:reverse()\n\telse\n\t\treturn is_palindrome(text:sub(0,\
    \ s))\n\tend\nend", "  -- Remove all occurrences of \"Z\" because that means no\
    \ character in the text\n  -- is a palindrome\n  text = text.replace('z', '')\n\
    \  -- Get the number of characters in the text\n  local num_chars = #text\n  --\
    \ If text is empty, text is a palindrome\n  if num_chars == 0 then\n    return\
    \ true\n  end\n  -- If there are more than one characters in the text, return\
    \ false\n  if num_chars > 1 then\n    return false\n  end\n  -- For each character\
    \ in the text, compare it to the first and last\n  -- characters in the text,\
    \ and return true if they are equal\n  for i, character in ipairs(text) do\n \
    \   if character ~= text[num_chars - i] then\n      return false\n    end\n  end\n\
    \  return true\nend", "    if text == nil then return false end\n    if text:len()\
    \ < 2 then return true end\n    local half = text:len() / 2\n    for i = 1, half\
    \ do\n        if text:sub(i, i) ~= text:sub((i - half), i) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    local i, j = 1, #text\
    \ - 1;\n    while i <= j do\n        if text[i] ~= text[j] then\n            return\
    \ false\n        end\n        i = i + 1;\n        j = j - 1;\n    end\n    return\
    \ true\nend", "    if text == nil then\n        return false\n    end\n    local\
    \ start = text:len()\n    local middle = text:len()\n    while middle > 0 do\n\
    \        middle = middle / 2\n        if text[middle] ~= text[middle - 1] then\n\
    \            return false\n        end\n    end\n    return true\nend", "\ttext\
    \ = text:lower()\n\tlocal start, end = text:len(), text:len()", "    if text ==\
    \ nil then return false end\n    local text2, text1 = text:gsub(\"[%z%s]\", \"\
    %%%%\")\n    return text1 == text2\nend", "  local ok, first, middle, last = true,\
    \ 1, text:reverse():gsub('(.-)' .. middle, '%1*'):match('(.-)' .. last)\n  if\
    \ ok then\n    return last == middle\n  else\n    return false\n  end\nend", " \
    \ local i, j = 1, #text - 1\n  while i < j do\n    if text[i] ~= text[j] then\n\
    \      return false\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return true\n\
    end", "    local index = #text / 2\n    while index do\n        local char = text:sub(1,\
    \ index)\n        local index2 = text:find(char, index - 1, 1)\n        if index2\
    \ == 1 then\n            index = index - 1\n        elseif index2 == nil then\n\
    \            return true\n        end\n    end\n    return false\nend", '    local
    text_length = #text', "  local i, j = 1, #text\n  while i < j do\n    if text[i]\
    \ ~= text[j] then\n      return false\n    end\n    i = i + 1\n    j = j - 1\n\
    \  end\n  return true\nend", "  return text:reverse():sub(1, text:len()) == text\n\
    end", "   local function reverse(text)\n      local rev = text:reverse()\n   \
    \   return rev:sub(1,#text)\n   end\n   text = text:lower()\n   if text == reverse(text)\
    \ then\n      return true\n   else\n      return false\n   end\nend", "\tlocal\
    \ s = text:lower()\n\ts = s:gsub(\"%s+\",\"\")\n\ts = s:gsub(\"[abcdefghijklmnopqrstuvwxyz]\"\
    ,\"\")\n\ts = s:gsub(\"[!^%$#@!%*]\",\"\")\n\treturn s == s:reverse()\nend", "\t\
    return string.gsub(text, string.lower(string.sub(text, 1, #text)), '') == text\n\
    end", "  local s, p = text:reverse():find(text)\n  return s == p and s ~= 0\n\
    end", "    -- Split text into characters\n    local characters = {}\n    for i\
    \ = 1, #text, 1 do table.insert(characters, string.sub(text, i, i)) end\n    --\
    \ Sort characters alphabetically\n    table.sort(characters)\n    -- Iterate backwards\
    \ through characters\n    for i = #characters, 1, -1 do\n        -- Compare current\
    \ character with previous character\n        if characters[i]~=characters[i -\
    \ 1] then return false end\n    end\n    return true\nend", "  for _,v in pairs(text)\
    \ do\n    if string.sub(v,1,1) ~= string.sub(v,-1,1) then\n      return false\n\
    \    end\n  end\n  return true\nend\n</cell>\n<text>\nTests", "  text = text:lower()\n\
    \  if text:len() <= 1 then\n    return true\n  end", "\t-- base case\n\t-- base\
    \ case\n\t-- base case\n\tif text == \"\" then\n\t\treturn true\n\tend", "   \
    \ for i = 1, #text do -- iterate through text ignoring first character\n     \
    \   if (text:sub(i, i) == text:sub#(-2, -2)) then -- check if the current character\
    \ is the same as the previous character\n            return False end\n    end\n\
    \    return true\nend", "    local i, j = 1, #text\n    while i < j do\n     \
    \   if text[i] ~= text[j] then\n            j = j - 1\n        else\n        \
    \    i = i + 1\n            j = j - 1\n        end\n    end\n    return text ==\
    \ string.reverse(text)\nend", "  if text == nil then\n    return false\n  end",
  "   for i = 1,#text do\n      if not string.sub(text, i, i)==string.sub(text, i-1,\
    \ i-1) then return false end\n   end\n   return true\nend", "\t-- check if its\
    \ string contains letters or numbers\n\t-- if not than it is not a palindrome\n\
    \t-- if string contains letters than first convert it to number\n\tif text:match('^[a-z]*$')\
    \ then\n\t\ttext = text:lower()\n\tend\n\tlocal i, length = text:len(), 0\n\t\
    local temp, last, letter\n\tfor i = 1, length / 2 do\n\t\tletter = text:sub(i,\
    \ i)\n\t\ttemp = text:sub(i + 1, i + 1)\n\t\tif temp:lower() == letter then\n\t\
    \t\tlength = length + 1\n\t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\tlast\
    \ = text:sub(length - 1, length)\n\treturn last == last:lower()\nend", "  local\
    \ start = text\n  local middle\n  local end = text\n  local reverse", "    local\
    \ s, p, srev\n    local i, c, l, imax\n    s, srev, i, c, l, imax = text:gsub('([a-z])',\
    \ string.upper)\n    i = #text\n    while i > 0 do\n        if text[i] ~= s[c\
    \ - 1] then\n            return false\n        end\n        c, i = i - 1, c\n\
    \    end\n    return true\nend", "  return text:reverse():sub(1,#text) == text:sub(1,#text)\n\
    end", "  if text == nil then return false end\n  text = tostring(text)", "  --\
    \ reverse the string and check if it is the same as original string\n  local reversed_string\
    \ = text:reverse()\n  return text == reversed_string\nend\n</cell>\n<text>\nStrings,\
    \ Arrays, and Tables\nStrings are immutable and are simply collections of characters.\
    \ Strings can be manipulated with the char() function that returns a single character\
    \ of a string.", "  -- Create a reversed copy of the text\n  local reversed_text\
    \ = text:reverse()\n  -- Check the first and last characters for equality with\
    \ the reversed text\n  return text == reversed_text\nend", "  local i, j = text:len(),\
    \ 1\n  while i > 0 and text:sub(i,i) == text:sub(1,i) do\n    i = i - 1\n    j\
    \ = j - 1\n  end\n  return j > 0 and text:sub(i+1,i+1) == text:sub(1,i)\nend\n\
    </cell>\n<text>\nNext we add some utility functions to the library:", "    local\
    \ index = text:len()\n    if text == text:reverse() then\n        return true\n\
    \    end\n    -- Check if given text is a palindrome by going through the whole\
    \ string\n    -- starting from the end and going back until the middle of string\n\
    \    while index do\n        if text:sub(1, index) ~= text:sub(index, index) then\n\
    \            return false\n        end\n        index = index - 1\n    end\n \
    \   return true\nend", "   local lenText = text:len()\n   if lenText < 2 then\n\
    \      return true\n   elseif lenText > 256 then\n      return false\n   end\n\
    \   local start = text:sub(1,1)\n   local end = text:sub(lenText,lenText)\n  \
    \ return start == end:reverse()\nend\n</code>\n<|/ a tags=lua,string |>\n<| a\
    \ tags=lua,string dscore=1 |>\n<code>", "  for i = 1, #text do -- Traverse the\
    \ string one by one\n    if text:sub(i, i) == text:sub((#text - 1) - i, #text)\
    \ then\n      return true\n    end\n  end\n  return false\nend", "    if text\
    \ == \"\" then\n        return true\n    end\n    local text_reversed = text\n\
    \    text_reversed = string.gsub(text_reversed, \"[^\" .. string.char(127) ..\
    \ \"]\", \"\")\n    if text == text_reversed then\n        return true\n    end\n\
    \    return false\nend", "    local index = 1\n    local length = #text\n    while\
    \ index <= length / 2 do\n        local char = text:sub(1, index)\n        local\
    \ next_char = text:sub(index + 1, length)\n        if char == next_char then\n\
    \            return false\n        end\n        index = index + 1\n    end\n \
    \   return true\nend", "    if text ~= text then\n        local split = text:gmatch(\"\
    [^\" .. string.char(32) .. \"]+\")\n        if split:len() <= 1 then return true\
    \ end\n        local left, right = string.find(text, split[1], 1, true), string.find(split{1},\n\
    \            text, 1, true)\n        return left > 0 and right > 0 and text[left\
    \ - 1] = split[right - 1]\n    end\n    return false\nend", "    return text ==\
    \ string.gsub(text, string.char(0x00, 0x80 - string.len(text)), \"\")\nend\n</cell>\n\
    <text>\nPart 3: Extract n-grams from text\nLet's use these functions to extract\
    \ the n-grams (ordered sequences of characters) that are most correlated with\
    \ Swadesh in the reviews. \nWe will compute n-grams from the reviews with order\
    \ 4. We use the function get_n_grams_from_text. This function will return a table\
    \ of the form (word_idx, n_gram, corr) with each row corresponding to a review.\
    \ \nWe will keep only the n_gram that has the highest correlation with the Swadesh\
    \ word (corr > 0.9).", "  return text:reverse() == text\nend", "   if text ==\
    \ nil then\n      return false\n   end", "  for i = #text, 1, -1 do\n    if text:sub(i,\
    \ i) ~= text:sub(i + 1, i + 1) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "    return text == string.reverse(text) and true or false\nend",
  "    local t = text:lower()\n    return t:sub(1, #t) == t\nend", "  return string.gsub(text,\
    \ \"[\\n\\r]+\", \" \") ==\n    string.gsub(string.lower(text), \"[\\n\\r]+\"\
    , \" \") and\n    (string.gsub(text, \"^%s*(.-)%s*$\", \"%1\") ~= text or text\
    \ == '')\nend", "  if text:len() <= 1 then\n    return true\n  end", "  local\
    \ function compare(text1, text2)\n    if text1 == nil or text2 == nil then\n \
    \     return text1 == text2\n    elseif text1 == text2 then\n      return true\n\
    \    else\n      local i = 0\n      local j = 1\n      while i < #text1 and j\
    \ < #text2 do\n        if text1[i] == text2[j] then\n          i = i + 1\n   \
    \       j = j + 1\n        else\n          return false\n        end\n      end\n\
    \      return true\n    end\n  end\n  if text==nil or text=='' then\n    return\
    \ true\n  end\n  local start = 1\n  local end = 1\n  local i = 1\n  while i <\
    \ #text do\n    if text[i] ~= ' ' then\n      if start > end then\n        return\
    \ false\n      end\n      start = end + 1\n    end\n    i = i + 1\n  end\n  if\
    \ start > end then\n    return false\n  end\n  local left_index = start\n  local\
    \ right_index = end\n  while left_index > 0 do\n    if right_index == #text then\n\
    \      return true\n    end\n    if text[left_index] ~= ' ' then\n      if text[left_index-1]\
    \ ~= ' ' then\n        return false\n      end\n      left_index = left_index\
    \ - 1\n    end\n    left_index = left_index - 1\n  end\n  while right_index >\
    \ 0 do\n    if left_index == 0 then\n      return true\n    end\n    if text[right_index]\
    \ ~= ' ' then\n      if text[right_index-1] ~= ' ' then\n        return false\n\
    \      end\n      right_index = right_index - 1\n    end\n    right_index = right_index\
    \ - 1\n  end\n  return compare(text, reverse(text))\nend", "\tlocal s = text:lower()\n\
    \ts = s:gsub(\"%s+\", function(c)\n\t\treturn string.sub(c, 1, 1):reverse():sub(1,\
    \ 1)\n\tend)\n\treturn s == text\nend", "   if text == nil then return False end\n\
    \   local text_reversed = text:reverse()\n   if text == text_reversed then return\
    \ True end\n   return false\nend", "  return text:gsub('(.)([^%z])', function(c,\
    \ c2, c3)\n    return string.char(tonumber(c2))..c3 == string.char(tonumber(c))..c3\n\
    \  end)\nend", "  local i = 0\n  while text:sub(i,i) ~= text then i=i+1 end\n\
    \  return text == text:sub(i,i) and i==2 or text~=reverse(strsub(text,1,i-1))\
    \ and false\nend", "  text = string.lower(text)\n  -- Remove non-alphanumeric\
    \ characters\n  text = text:gsub('%w+%w+','') -- Zbcd => zbcd\n  -- Remove non-ascii\
    \ characters\n  text = text:gsub('[\\128-\\191]+','') -- Zbcd => zbcd\n  -- Remove\
    \ leading and trailing whitespace\n  text = text:gsub('%s+$','')\n  -- Remove\
    \ trailing whitespace\n  text = text:gsub('(%s+)%s+$','%1')\n  -- Remove leading\
    \ whitespace\n  text = text:gsub('(%s+)%s+','%1')\n  -- Replace all other whitespaces\
    \ with single whitespace\n  text = text:gsub('%s+',' ') -- Zbcd => z b c\n  return\
    \ text == string.sub(text,1,#text) and true or false\nend", "  text = text:lower()\n\
    \  local palindrome = ''\n  for i = 1, #text do\n    if text:sub(i, i) ~= text:sub((#text)\
    \ - i, (#text) - i) then\n      return False\n    end\n    palindrome = palindrome\
    \ .. text:sub(i, i)\n  end\n  return palindrome == text\nend", "   for i = #text,\
    \ 1, -1 do\n      local char = text:sub(i, i)\n      text = text:gsub(char, char:reverse())\n\
    \   end\n   return text == text\nend", "  if text == nil then return false end\n\
    \  local index, length = 1, #text\n  for i = 1, length do\n    if text[index]\
    \ ~= text[(length - index - 1)] then\n      return false\n    end\n    index =\
    \ index + 1\n  end\n  return true\nend", "    if text == nil then return false\
    \ end\n    for i = 1, #text do\n        if string.sub( text, i, i ) == string.sub(\
    \ text, i - 1, i - 1 ) then\n            return false\n        end\n    end\n\
    \    return true\nend", "   text = text:lower()\n   for i = 1,#text,1 do\n   \
    \   local c = text:sub(i,i)\n      if c ~= c:reverse() then\n         return false\n\
    \      end\n   end\n   return true\nend", "  -- If it's not a string, return False\
    \ immediately\n  if not type(text) == 'string' then\n    return false\n  end",
  "  text = text:lower() -- Converts string to lower case\n  local middle, left, right\
    \ = text:find(string.reverse(text))\n  return middle ~= nil and middle ~= text\n\
    end", "\t-- We don't need to check if string length is 0 since it's already a\
    \ palindrome\n\t-- This also takes care of odd length palindromes\n\ttext = text:lower()\n\
    \t-- Split string by spaces and reverse it\n\ttext = text:gsub(\"(.-)\", string.reverse)\n\
    \t-- If there are any spaces, we can't determine it's a palindrome\n\t-- If there\
    \ is no spaces, we know it's a palindrome\n\t-- In case there are spaces, it's\
    \ safe to assume it's a palindrome\n\treturn text ~= '' and\n\t\ttext:sub(#text\
    \ - 1) ~= ' ' and\n\t\ttext:sub(#text - 2) ~= ' '\nend", "  text = string.lower(text)\n\
    \  local start, stop = text:len()/2, text:len()-1\n  local sub = text:sub(1, stop)\n\
    \  return start ~= stop and sub == text:sub((stop-1), start)\nend", "    local\
    \ i = 0\n    local j = text.length - 1\n    local isPal = True", "  return string.sub(text,\
    \ 1, string.len(text)) ~= string.sub(text, 1, string.len(text) -1)\nend", "  \
    \  local is_palindrome = true\n    if text ~= text:lower() then\n        for i\
    \ = #text, 1, -1 do\n            if not text[i] == text[i-1] then\n          \
    \      is_palindrome = false\n                break\n            end\n       \
    \ end\n    end\n    return is_palindrome\nend", "\ttext = text:gsub('\\%z','%#z'):gsub('%z','%#z'):gsub('\\\
    %Z','%#Z'):gsub('%Z','%#Z')\n\tlocal p1 = text:reverse()\n\tlocal p2 = text:reverse():reverse()\n\
    \treturn p1 == p2\nend", "  text = text:lower()\n  text = string.gsub(text, '[!-~]',\
    \ '')\n  local half = text:len()/2\n  text = text:sub(1,half)\n  text = text:reverse()\n\
    \  return text == text\nend", "   return text:gsub(\"(\" .. table.concat({\"z\"\
    , \"Z\", \"y\", \"Y\", \"x\", \"X\"}, \"\") .. \")\"):reverse():sub(1, #text)\
    \ == text\nend", "  local function str_split(input)\n    local result = {}\n \
    \   for i = 1, #input do\n      table.insert(result, string.sub(input, i, i))\n\
    \    end\n    return result\n  end\n  local str_arr = str_split(text)\n  for i,\
    \ v in pairs(str_arr) do\n    if str_arr[i] ~= str_arr[(str_arr.length - 1 - i)]\
    \ then\n      return false\n    end\n  end\n  return true\nend", "   return string.gsub(text,\
    \ '([^' .. string.letters .. '-])', function(c) return c == '-' and ' ' or c end)\
    \ == text\nend", "  return string.lower(text) == string.lower(text, 1, #text)\
    \ and is_palindrome_helper(text, 1, #text)\nend", "   -- Empty text --> True because\
    \ 0 is palindromic by definition\n   return text == reverse(text) or is_palindrome(translate(text,\
    \ \"abcdefghijklmnopqrstuvwxyz\", \"zyxwvutsrqponmlkjihgfedcba\"))\nend", "  \
    \  local lower = text:lower()\n    local reversed = lower:reverse()\n    return\
    \ lower == reversed\nend", "  -- Reverse the string\n  text = string.gsub(text,\
    \ \"(%D)(%d%d)\", \"%1%2\")", "    local i, j, s\n    local size = #text / 2\n\
    \    for i = 1, size do\n        s = text[i]\n        j = size - 1\n        while\
    \ j > 0 and text[j] != s do\n            text = text:sub(1, j - 1)\n         \
    \   j = j - 1\n        end\n        if text[i] == s then\n            return true\n\
    \        end\n    end\n    return false\nend", "  local t = ''\n  for i = 1, #text\
    \ do\n    local c = text:sub(i,i)\n    t = t .. c:reverse()\n  end\n  return t\
    \ == text\nend\n</cell>\n<cell>", "    if text == '' then\n        return true\n\
    \    end\n    local start, end = 1, #text\n    \n    repeat\n        start = start\
    \ - 1\n        end = end - 1\n        if text[start] ~= text[end] then\n     \
    \       return false\n        end\n    until start == 1\n    return true\nend",
  "  local start, end = 1, #text - 1\n  while start < end do\n    local letter = text:sub(start,\
    \ end)\n    if letter ~= letter:reverse() then\n      return false\n    end\n\
    \    start = start + 1\n    end = end - 1\n  end\n  return true\nend", "  text\
    \ = text:lower()\n  local index = text:len()\n  local is_palindrome = true\n \
    \ for i = index, 1, -1 do\n    if text:sub(i, i) ~= text:sub((i - 1), i) then\n\
    \      is_palindrome = false\n      break\n    end\n  end\n  return is_palindrome\n\
    end", "  local i, j, s\n  text = text:gsub('([^' .. table.concat(chars, '') ..\
    \ ']:)([^' .. table.concat(chars, '') .. ']+)', function(word)\n    -- Strip off\
    \ trailing characters\n    word = word:sub(2)\n    -- Handle non-ascii chars\n\
    \    word = string.gsub(word, '%c', '?')\n    -- Return palindrome when no chars\
    \ are left\n    return word ~= ''\n  end)\n  -- Check middle chars, reversing\
    \ if necessary\n  for i = 1, #text - 1, 2 do\n    -- Handle non-ascii chars\n\
    \    s = string.gsub(text[i + 2], '%c', '?')\n    -- Replace all chars that don't\
    \ belong to the palindrome\n    s = string.gsub(s, '%c', function(char)\n    \
    \  char = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.g",
  "  local sz = text:len()\n  if sz == 0 then return true end\n  local start = text:sub(1,\
    \ sz / 2)\n  local end = text:sub(sz / 2 + 1, sz)\n  if start ~= text or end ~=\
    \ text then\n    return false\n  end\n  local left = text:sub(1, sz - 1)\n  local\
    \ right = text:sub(sz + 1, sz)\n  if left ~= right then\n    return false\n  end\n\
    \  return true\nend", "    for i = 1, #text do\n        if text:sub(i, i) ~= text:sub(i,\
    \ i-1) then\n            return false\n        end\n    end", "  return string.sub(text,\
    \ 1, #text) == string.sub(text, 1, #text-1)\nend", "  return text == string.reverse(text)\n\
    end", "  if text == nil or text:len() < 1 then\n    return true\n  end\n  local\
    \ first = text:sub(1, 1)\n  if first == last then\n    return true\n  end\n  local\
    \ i, j = 1, text:len() - 1\n  while i < j do\n    local c = text:sub(i, i + 1)\n\
    \    j = i - 1\n    if c == first then\n      return false\n    end\n    if c\
    \ == last then\n      break\n    end\n  end\n  return true\nend", "  local s,\
    \ e = text:reverse():find(text)\n  return s >= 0 and e == text:len() - 1 and s\
    \ == e or s == e and is_palindrome(text)\nend", "\tlocal index, length = 1, #text\n\
    \twhile index >= 0 do\n\t\tif not string.sub(text, index, index + length) then\n\
    \t\t\tbreak\n\t\tend\n\t\tlength = length - 1\n\t\tindex = index - 1\n\tend\n\t\
    return index == 0 or string.sub(text, index, 1) == string.sub(text, length - 1,\
    \ length)\nend", "  local i = 0\n  local j = text", "  -- https://stackoverflow.com/questions/2623329/reverse-a-string-in-place-in-python\n\
    \  text = text:gsub(\"%l\", function()\n    -- https://stackoverflow.com/questions/49463227/how-do-i-convert-a-string-to-lowercase-in-place-in-a-gsub\n\
    \    local lc = string.lower(string.sub(string.sub(string.sub(text, \"%l\", 1,\
    \ 1), \"^.\", 1, 1), \"^.\", 1, 1))\n    return lc\n  end)\n  return text:gsub(\"\
    ^\" .. text:sub(-1) .. \"$\", \"%l\"):lower() == text\nend", "    local i, j =\
    \ 1, #text - 1\n    while i <= j do\n        if text[i] ~= text[j] then\n    \
    \        return false\n        end\n        i = i + 1\n        j = j - 1\n   \
    \ end\n    return true\nend", "  return text == string.Reverse(text)\nend", " \
    \   return text == string.gsub(text, \"[^\" .. string.char(127) .. \"]\", \"\"\
    )\nend", "\ttext = text:lower()\n\tlocal start = 1\n\tlocal end = text:len()\n\
    \t-- Iterates through given string backwards\n\t-- >>> is_palindrome('aabcba')\n\
    \t-- False\n\t-- >>> is_palindrome('abcba')\n\t-- True\n\twhile start < end do\n\
    \t\tif text:sub(1, start) ~= text:sub(end - 1, end) then\n\t\t\treturn false\n\
    \t\tend\n\t\tstart = start + 1\n\t\tend = end - 1\n\tend\n\treturn true\nend",
  "\tif text ~= text then return false end\n\tlocal index, count = 1, #text\n\twhile\
    \ count > 0 do\n\t\tindex = #text - 1 - index\n\t\tif text:sub(1, index) ~= text:sub((index\
    \ + 1), #text) then return false end\n\t\tcount = count - 1\n\tend\n\treturn true\n\
    end", "   for i = #text, 1, -1 do\n      local char1 = text:sub(i, i)\n      local\
    \ char2 = text:sub(i, i-1)\n      if char1 == char2 then\n         return false\n\
    \      end\n   end\n   return true\nend", "    if not text or #text < 1 then\n\
    \        error('Text to check for palindrome must have 1 or more characters.')\n\
    \    end\n    if #text == 1 then\n        return true\n    end\n    local start\
    \ = 1\n    local end = #text\n    while start < end do\n        local char = text[start]\n\
    \        local reversed = string.gsub(string.sub(text, start, end), '(.)(.)',\
    \ function(match) return match[2] .. match[1] end)\n        if char == reversed\
    \ then\n            start = start + 2\n        else\n            start = start\
    \ + 1\n        end\n        end = end - 1\n    end\n    return false\nend", " \
    \ return text:reverse():upper() == text:reverse()\nend", "  text = text:lower()\n\
    \  local i = 0\n  local j = text:len()\n  while i < j and text:sub(i, i) == text:sub(j,\
    \ j) do\n    i = i + 1\n    j = j - 1\n  end\n  return i == j\nend", "  text =\
    \ string.lower(text)\n  local i, j = 1, #text - 2\n  while i <= j and text[i]\
    \ == text[j] do\n    i = i + 1\n    j = j - 1\n  end\n  return j >= 0 and text[i]\
    \ == text[j]\nend", "    local function is_palindrome_helper(text)\n        local\
    \ i = 0\n        local j = (#text - 1) + 1\n        while i <= j do\n        \
    \    if text[i] ~= text[j] then\n                return false\n            end\n\
    \            i = i + 1\n            j = j - 1\n        end\n        return true\n\
    \    end\n    return is_palindrome_helper(text)\nend", "  -- O(N)\n  -- O(N)\n\
    \  -- O(N)\n  local len = #text\n  local half = len / 2\n  local start = 1\n \
    \ while start <= half do\n    -- O(1)\n    -- O(1)\n    -- O(1)\n    local char\
    \ = text[start]\n    -- O(1)\n    -- O(N)\n    if char ~= text[end - 1] then\n\
    \      return false\n    end\n    -- O(1)\n    -- O(1)\n    -- O(1)\n    start\
    \ = start + 1\n    -- O(1)\n    -- O(1)\n  end\n  return true\nend", "    local\
    \ new_text = text:gsub('([a-z])', function(a) return a:lower() end)\n    local\
    \ reversed_new_text = new_text:gsub('([^a-z])', function(a) return a:upper() end)\n\
    \    return new_text == reversed_new_text\nend", "  local reversed_text = string.reverse(text)\n\
    \  return text == reversed_text\nend", "   return text:gsub('%w+'):reverse() ==\
    \ text\nend", "  return text:gsub('.', function(c) \n    local reverse = string:reverse(c)\n\
    \    return reverse == c\n  end)\nend", "  text = text:lower()\n  local s, l =\
    \ text:len(), 1\n  while (s ~= l) and s do\n    -- if text is shorter than 2 characters\
    \ skip it (will be tested later)\n    if s < 2 then return false end\n    -- if\
    \ next symbol is the same then skip (will be tested later)\n    if text[s] ~=\
    \ text[s+1] then return false end\n    -- increment index\n    s = s + 1\n   \
    \ -- we test if text was longer than 1 char (we test it later)\n    l = l+1\n\
    \  end\n  return s == l\nend", "  if text == nil then return false end\n  local\
    \ function reverse(text)\n    local s = text:gsub(\"%w+\", function(c)\n     \
    \ c = string.char(tonumber(c))\n      return c:reverse()\n    end)\n    return\
    \ s\n  end\n  local text = text:gsub(\"%w+\", reverse)\n  -- The last character\
    \ can be either punctuation or whitespace\n  local last = text:len()\n  if last\
    \ % 2 == 1 and text:sub((last - 1), (last - 1)) == \"\\n\" then\n    text = text:sub((last\
    \ - 1), last - 1)\n  end\n  -- Remove spaces\n  text = text:gsub(\"( +)\", \"\
    \ \"):gsub(\"( +)\", \"\\n\")\n  -- Remove any extra characters\n  text = text:gsub(\"\
    [^\"..string.char(127..129, 111, 119, 105, 110)..\"]\", \"\")\n  -- Check for\
    \ trailing newlines\n  if text:sub(#text, #text) == \"\\n\" then\n    text = text:sub(1,\
    \ #text)\n  end\n  return text == text:reverse()\nend", "  if text == nil then\
    \ return false end\n  text = text:lower()\n  return text:sub(1,#text) == text:sub((#text)/2,#text)\n\
    end", "   for i = #text, 1, -1 do\n      if text:sub(i, i) ~= text:sub(i+1, i+1)\
    \ then\n         return false\n      end\n   end\n   return true\nend", "\ttext\
    \ = text:lower() -- convert to lower case\n\tlocal n = text:len() -- get its length\n\
    \tlocal count = 0 -- counts how many characters are the same as the start character",
  "    local i, j = 1, text:len()-1\n    while i <= j do\n        local first_char\
    \ = text:sub(i, i)\n        local second_char = text:sub(j, j)\n        if first_char\
    \ == second_char then\n            i = i+1\n            j = j-1\n        elseif\
    \ first_char < second_char then\n            j = j-1\n        else\n         \
    \   i = i+1\n        end\n    end\n    return i == j\nend", "    local reverse\
    \ = string.gsub(text, \"[\" .. string.len(text) .. \"]\", \"\")\n    if reverse\
    \ == text then return true end\n    for i = 1, string.len(text) do\n        if\
    \ text:sub(i, i) ~= reverse:sub(i, i) then return false end\n    end\n    return\
    \ true\nend", "\ttext = text or ''\n\tlocal start, length = #text, 0\n\twhile\
    \ length > 0 and start > 0 do\n\t\tlocal mid = math.floor(length / 2)\n\t\tif\
    \ text[mid] == text[start - mid] then\n\t\t\tlength = length - mid\n\t\t\tstart\
    \ = start - mid\n\t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\n\
    end", "  return text:reverse():sub(1, text) == text\nend", "    -- remove leading\
    \ and trailing whitespace\n    text = text:gsub('\\n', ''):gsub('\\r', ''):gsub('\
    \  ', ' ')", "   local function reverse(text)\n      local result, temp = \"\"\
    , \"\"\n      for i = 1, #text do \n         temp = text[i] \n         result\
    \ = result .. temp \n      end\n      return result \n   end\n   local text =\
    \ text:lower()\n   for i = 1, #text do\n      if text:sub(i, i) == text:sub((i\
    \ - 1), ((i - 1))) then\n         return true\n      else\n         return false\n\
    \      end\n   end\n   return false\nend", "   local i, j = 1, #text\n   if j\
    \ ~= i then\n      while j ~= i and text[i] ~= text[j] do\n         i = i + 1\n\
    \         j = j - 1\n      end\n      return text[i] == text[j]\n   else\n   \
    \   return true\n   end\nend", "  -- reverse text\n  local function reverse(text)\n\
    \    return text:gsub('(...)([^a-z])', function(match)\n      return match..match:reverse()\n\
    \    end)\n  end\n  return text:gsub('([^a-z])', function(match)\n    return match:reverse()\n\
    \  end):reverse() == text\nend", "  local s, l, r = text:gsub('%a{}', ''):find('(.-)\\\
    \\1')\n  if s then\n    return l == r and text:sub(1, l) == text:sub(r + 1, #text)\n\
    \  else\n    return false\n  end\nend", "  local function reverse(text)\n    return\
    \ text:gsub(\"([^\" .. table.concat(string.lower(string.gsub(text, \"[\" .. string.char(32)\
    \ .. \",\" .. string.char(32) .. string.char(32)), \"%1\")..\"]+)\", function\
    \ (x)\n      return string.sub(x, 1, #x - 1)\n    end)\n  end", "  local function\
    \ reverse(text)\n    local buf = {}\n    local i = #text\n    while i > 0 do\n\
    \      table.insert(buf, string.sub(text, i, i - 1))\n      i = i - 1\n    end\n\
    \    return table.concat(buf)\n  end\n  return reverse(text) == text\nend\n</cell>\n\
    <cell>", "    if text ~= string.lower(text) then return false end\n    local start\
    \ = 1\n    local end = #text\n    while start <= end do\n        if text[start]\
    \ ~= text[end - 1] then return false end\n        start = start + 1\n        end\
    \ = end - 1\n    end\n    return true\nend", "  local function reverse(text, i)\n\
    \    local reversed = text\n    for j = 1, i do\n      reversed = reversed:sub(1,1)\
    \ .. reversed:sub(n-i+1,n-i+1)\n    end\n    return reversed\n  end\n  local n\
    \ = #text\n  if n == 0 then\n    return true\n  end\n  local first = text:sub(1,1)\n\
    \  if first ~= text:sub(n-1,n) then\n    return false\n  end\n  return reverse(text,n-1)\
    \ == reverse(text:sub(1,n),n)\nend", "\treturn (string.gsub(text, \"[^\"..string.char(0xFFFF)..\"\
    ^]\", \"\") == text)\nend", "  text = string.gsub(text, '[%z\\1-\\2\\3]', '')\n\
    \  return text:reverse() == text\nend", "    local s, e, i = 0, text:len(), 0\n\
    \    while s do\n        e = s - 1\n        while i < e and text:sub(s, e):sub(e,\
    \ s) ~= \"\" do\n            s, e = s + 1, e - 1\n        end\n        if s <=\
    \ e and text:sub(s, e) == text:sub(e, s) then\n            i = e + 1\n       \
    \ end\n        s = s + 1\n    end\n    return s == 0\nend", "    if text ~= text:reverse()\
    \ then\n        return false\n    end\n    return true\nend", "    return text\
    \ == text:reverse()\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
