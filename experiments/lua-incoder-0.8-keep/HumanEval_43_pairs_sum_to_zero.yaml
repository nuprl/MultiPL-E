name: HumanEval_43_pairs_sum_to_zero
language: lua
prompt: "-- pairs_sum_to_zero takes a list of integers as an input.\n-- it returns\
  \ True if there are two distinct elements in the list that\n-- sum to zero, and\
  \ False otherwise.\n-- >>> pairs_sum_to_zero([1, 3, 5, 0])\n-- False\n-- >>> pairs_sum_to_zero([1,\
  \ 3, -2, 1])\n-- False\n-- >>> pairs_sum_to_zero([1, 2, 3, 7])\n-- False\n-- >>>\
  \ pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n-- True\n-- >>> pairs_sum_to_zero([1])\n\
  -- False\nlocal function pairs_sum_to_zero(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pairs_sum_to_zero\n\
  \    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1,\
  \ 3, -2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({2,\
  \ 4, -5, 3, 5, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({-3,\
  \ 9, -1, 3, 2, 30}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}),\
  \ true)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)\n    lu.assertEquals(candidate({-3,\
  \ 9, -1, 4, 2, 31}), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Check for an empty list.\n  -- If we have an empty list, return\
    \ False.\n  if #l == 0 then return false end\n  -- Initialize a boolean variable\
    \ that will be True only if two integers\n  -- are added to zero.\n  local all_zero\
    \ = false\n  -- Check each pair of numbers in the list.\n  for i = 1, #l do\n\
    \    -- Check if the current number is the first number in the pair.\n    if i\
    \ == 1 then\n      -- If the current number is the first, return True if any of\
    \ the\n      -- numbers in the pair are also equal to zero.\n      if l[i] ~=\
    \ 0 then return false end\n      -- If the current number is the first number,\
    \ then we know that the\n      -- rest of the pair is equal to zero.\n      all_zero\
    \ = true\n    else\n      -- If the current number is not the first, check whether\
    \ the sum of\n      -- numbers in the pair is equal to zero.\n      if l[i] +\
    \ l[i-1] ~= 0 then return false end\n      -- If the current number is the second\
    \ number, then we know that the\n      -- rest of the pair is equal to zero.\n\
    \      all_zero = true\n    end\n  end\n  -- If the variable all_zero is true,\
    \ then we have found a pair with two\n  -- distinct elements that sum to zero,\
    \ and we return true only if the\n  -- variable all_zero is false because the\
    \ list contained two distinct\n  -- elements.\n  return all_zero\nend", "  if\
    \ #l == 0 then\n    return false\n  end\n  local current = l[1]\n  for i=2,#l\
    \ do\n    local next_ = l[i]\n    if current > 0 and current + next_ > 0 then\n\
    \      current = current + next_\n    else\n      return current == 0\n    end\n\
    \  end\n  return true\nend", "    local total = 0\n    for i = 1, #l do total\
    \ = total + l[i] end\n    for i = 1, #l do if total - l[i] ~= 0 then return false\
    \ end; end\n    return true\nend", "  local v = {} -- this will be the resulting\
    \ dictionary\n  for i = 1, #l do\n    local found = False\n    for k in pairs(v)\
    \ do\n      if l[i] + l[k] == 0 then\n        table.remove(v)\n        found =\
    \ true\n        break\n      end\n    end\n    if not found then\n      v[#v +\
    \ 1] = l[i]\n    end\n  end\n  return #v > 1\nend", "  local a = {}\n  for k,v\
    \ in pairs(l) do a[k] = v end\n  for k,v in pairs(a) do a[k] = 0 end\n  return\
    \ true\nend", "  local s = #l\n  local n = {}\n  for i = 1, s do\n    local v\
    \ = l[i]\n    if v then\n      n[v] = (n[v] or 0) + i - 1\n    end\n  end\n  return\
    \ #n == 0\nend", "  local pairs = {}\n  for i, e in ipairs(l) do\n    pairs[i]\
    \ = pairs[i] or {}\n    pairs[i][e] = true\n  end\n  local i = 0\n  local j =\
    \ 1\n  while i <= j do\n    local k = j\n    while k <= i do\n      if pairs[i][k]\
    \ == true then\n        pairs[i][k] = false\n        break\n      else\n     \
    \   k = k + 1\n      end\n    end\n    i = i + j\n    j = j + 1\n  end\n  local\
    \ ok = true\n  for k, v in pairs(pairs) do\n    ok = ok and v\n  end\n  return\
    \ ok\nend", "  for i = 2, #l do\n    local sum = 0\n    for j = 1, #l do\n   \
    \   sum = sum + l[j]\n    end\n    if sum == 0 then\n      return true\n    end\n\
    \  end\n  return false\nend", "  local total = 0\n  local i = 0\n  -- We want\
    \ to compare the first item to the sum of the remaining\n  -- items. If we do\
    \ l[i+1] + l[i+2], we may overflow and get an invalid\n  -- value.\n  local llen\
    \ = #l\n  while i < llen and total + l[i+1] > 0 do\n    total = total + l[i]\n\
    \    i = i + 1\n  end\n  return i == llen and total == 0\nend", "    local pairs\
    \ = {}\n    for _, val in pairs(l) do\n        pairs[val] = pairs[val] + 1 or\
    \ 1\n    end\n    return not (pairs[#l] > 1 or (pairs[#l] == 1 and l[1] == 0))\n\
    end", "    local nums = {} -- map each number to a list of pairs with indices\
    \ of same\n    -- length as nums\n    for i, x in ipairs(l) do\n        if nums[x]\
    \ == nil then\n            nums[x] = {i = i, nums = {}}\n        end\n       \
    \ nums[x].nums[#nums[x].nums + 1] = i\n    end\n    for _, x in pairs(nums) do\n\
    \        local i = 0\n        for j = 1, #x.nums do\n            if x.nums[j]\
    \ + 1 > i then\n                i = x.nums[j]\n            end\n        end\n\
    \        if i ~= 0 then\n            -- if all indices have 0 sum then return\
    \ false\n            for _, y in pairs(nums) do\n                local z = 0\n\
    \                for _, u in pairs(y.nums) do\n                    z = z + u\n\
    \                end\n                if z == i then\n                    -- print\
    \ ('returning false')\n                    --return false\n                  \
    \  return true\n                end\n            end\n        end\n    end\n \
    \   return false\nend", "  for i = 1, #l do\n    local first_element = l[i]\n\
    \    for j = i+1, #l do\n      local second_element = l[j]\n      if not second_element\
    \ then\n        return false\n      elseif first_element + second_element == 0\
    \ then\n        return false\n      end\n    end\n  end\n  return true\nend",
  "  local first_pair\n  for _, v in pairs(l) do\n    local second_pair\n    for _,\
    \ v2 in pairs(l) do\n      if v + v2 == 0 then\n        return true\n      elseif\
    \ not first_pair then\n        first_pair = v\n        second_pair = v\n     \
    \ elseif v + v2 < 0 then\n        return false\n      end\n    end\n  end\n  return\
    \ first_pair == nil\nend\n</cell>\n<text>\nTests\nOur code works with the following\
    \ tests:", "  local s = #l\n  for i = 1, s do\n    if l[i] + l[i - 1] > 0 then\n\
    \      return true\n    end\n  end\n  return false\nend", "  return not (l and\
    \ #l > 0 and sum((unpack(l))) == 0)\nend", "    if #l == 0 then\n        return\
    \ false\n    end\n    if #l == 1 then\n        return true\n    end", "  local\
    \ is_pair, i, k, pairs = pcall(require, \"table\")\n  return is_pair and #l ==\
    \ 2 and l[1] and pairs(l) == pairs and #pairs > 0\nend", "\tlocal zero = l.zero\n\
    \tfor i = 2, #l do\n\t\tif not (zero(l[i])) then return false end\n\tend\n\treturn\
    \ true\nend", "  local num_non_zero = 0\n  for _, v in pairs(l) do\n    if not\
    \ v then return false end\n    num_non_zero = num_non_zero + 1\n  end\n  local\
    \ total = 0\n  for _, v in pairs(l) do\n    total = total + v\n  end\n  return\
    \ total < 0 and num_non_zero > 1\nend", "  for i, v in ipairs(l) do\n    for j\
    \ = i + 1, #l do\n      if v + l[j] == 0 then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "   local s = #l\n   for i = 1, s-1 do\n\
    \      local v\n      if #l == s then\n         v = l[i]\n      elseif i == 1\
    \ then\n         v = l[i-1]\n      else\n         v = l[i] + l[i-1]\n      end\n\
    \      if v == 0 then\n         return true\n      end\n   end\n   if s % 2 ==\
    \ 1 then\n      return false\n   end\n   local t = l[s/2]\n   for i = s/2+1, s\
    \ do\n      local k = l[i]\n      if k > t then\n         return false\n     \
    \ end\n      t = k\n   end\n   return true\nend", "    local count = 0\n    local\
    \ max_count = 0\n    for i = 1, #l do\n        if l[i] > max_count then\n    \
    \        count = count\n            max_count = l[i]\n        elseif l[i] < max_count\
    \ then\n            count = count + 1\n        end\n    end\n    return max_count\
    \ > 0 and count > 1\nend", "  -- this algorithm is O(n**2)\n  -- but it only needs\
    \ to be done once in the entire program\n  -- so it doesn't matter\n  for idx\
    \ = 1, #l do\n    if idx > 1 then\n      if l[idx] + l[idx - 1] > 0 then\n   \
    \     return false\n      end\n    end\n  end\n  return true\nend", "  local result\
    \ = {}\n  for i = 2, #l do\n    if result[sum:new(unpack(l, 1, i))] then\n   \
    \   return false\n    end\n    result[sum:new(unpack(l, 1, i))] = true\n  end\n\
    \  return #result == 0\nend", "  local function f(i1,i2)\n    return i1 + i2\n\
    \  end\n  local a = {}\n  local b = {}\n  for i,v in pairs(l) do\n    if a[f(i,v)]\
    \ then\n      return false\n    end\n    table.insert(a, f(i,v))\n  end\n  table.sort(a)\n\
    \  for i,v in pairs(a) do\n    if i ~= f(b[i]) then\n      return false\n    end\n\
    \  end\n  return true\nend", "   local s = sum(l)\n   if s == 0 then return false\
    \ end\n   for i=1,#l do\n      if l[i] + i > s then\n         return false\n \
    \     end\n   end\n   return true\nend\n</cell>\n<text>\nAwesome! Now, let's do\
    \ some math with the pairs of numbers in our dataset. Let's get the mean of the\
    \ pairs.", "    local i = 0\n    local j = 1\n    local k = 0\n    local sum =\
    \ 0\n    local pairs = {}\n    -- if l is empty it returns True\n    if #l ==\
    \ 0 then return True end\n    -- while k not equal to last element of list l\n\
    \    while i < #l do\n        local element = l[i]\n        -- while j not equal\
    \ to last element of list l\n        while j < #l do\n            if pairs[element]\
    \ == 0 then\n                pairs[element] = 1\n                k = k + 1\n \
    \               sum = sum + element\n                if k == j then\n        \
    \            pairs[element] = 0\n                    return (sum == 0)\n     \
    \           end\n            end\n            j = j + 1\n        end\n       \
    \ i = i + 1\n    end\nend", "  local sum, count = 0, 1\n  for index, value in\
    \ pairs(l) do\n    if index == 0 or value ~= l[index - 1] then\n      count =\
    \ count + 1\n      sum = sum + value\n    end\n  end\n  return count == 2 and\
    \ sum == 0\nend", "  local num_same = 0\n  local num_different = 0\n  for i, e\
    \ in ipairs(l) do\n    if e ~= 0 then\n      if num_same == 0 then\n        num_same\
    \ = 1\n      else\n        num_different = num_different + 1\n        if num_different\
    \ == 2 then return false end\n      end\n    end\n  end\n  if num_different ==\
    \ 2 then return true end\n  return false\nend", "  return #l == 0 or (#l == 1\
    \ and l[1] > 0)\nend", "  for i = 1, #l do\n    local cur_pair = { l[i] }\n  \
    \  for j = i + 1, #l do\n      local pair = { l[j] }\n      if math.abs(pair:sum()\
    \ - cur_pair:sum()) < 1e-12 then\n        return true\n      end\n      table.insert(cur_pair,\
    \ pair)\n    end\n  end\n  return false\nend", "  local seen = {}\n  local pairs\
    \ = l:gmatch(\"([^,]+),?([^,]+),?([^,]+),?([^,]+),?([^,]+),?([^,]+)\")\n  for\
    \ _, p in pairs do\n    if seen[tostring(p)] then return false end\n    seen[tostring(p)]\
    \ = true\n  end\n  return true\nend", "  local pairs = pairs(l)\n  local sum =\
    \ 0\n  for _,v in pairs do\n    sum = sum + v\n  end\n  for _,v in pairs do\n\
    \    if sum == 0 then\n      return false\n    end\n  end\n  return true\nend",
  "    local seen = {}\n    local t = {[1] = true}\n    local res = true\n    for\
    \ i = 2, #l do\n        if l[i] + l[i-1] == 0 then\n            if seen[#seen\
    \ + 1] == l[i-1] then\n                res = false\n                break\n  \
    \          else\n                seen[#seen + 1] = l[i-1]\n            end\n \
    \       else\n            t[#t + 1] = false\n        end\n    end\n    if #t ==\
    \ 1 then\n        res = t[1]\n    end\n    return res\nend", "  -- Find two distinct\
    \ elements that sum to zero.\n  for i = 1, #l do\n    for j = 1, #l do\n     \
    \ local sum = 0\n      local elem = l[i]\n      for k = 1, j do\n        sum =\
    \ sum + elem\n        if sum < 0 then\n          break\n        elseif sum ==\
    \ 0 then\n          return true\n        end\n        elem = elem * 10\n     \
    \ end\n    end\n  end\n  return false\nend", "  local pairs = setmetatable({},\
    \ { __eq = table.eq })\n  for _, v in ipairs(l) do\n    pairs[v] = true\n  end\n\
    \  for _, v in pairs do\n    pairs[v] = false\n  end\n  for _, v in pairs do\n\
    \    local v_sum = pairs[v] and v or 0\n    if v_sum > 0 then return false end\n\
    \  end\n  return true\nend", "  local seen = {}\n  local total = 0\n  for i =\
    \ 1, #l do\n    total = total + l[i]\n    if total then\n      seen[total] = true\n\
    \    end\n  end\n  return #seen == 1 and seen[1]\nend", "  local i, j, k = 0,\
    \ #l - 1, 0\n  while (i < j) do\n    k = l[i] + k\n    i = i + 1\n    j = j -\
    \ 1\n  end\n  return k == 0\nend", "    local i = 0\n    local pairs = {}\n  \
    \  local s = 0\n    for w in l do\n        if pairs[w] == nil then\n         \
    \   pairs[w] = 1\n        else\n            pairs[w] = pairs[w] + 1\n        end\n\
    \        total = total + w\n        if pairs[w] == 2 then\n            pairs[s]\
    \ = true\n            i = i + 1\n            s = s - w\n        end\n    end\n\
    \    \n    return pairs[total] == 2\nend", "  return true -- FIXME\nend", "  \
    \  local t = 0\n    for k, v in ipairs(l) do\n        t = t + v\n        if t\
    \ > 0 then\n            return false\n        end\n    end\n    return true\n\
    end", "  local sum = 0\n  local result\n  for _, v in pairs(l) do sum = sum +\
    \ v end\n  if sum == 0 then return true end\n  result = _viper_load_file_string('file(\"\
    /usr/share/dict/words\")')\n  for _, v in ipairs(result) do\n    if sum + v ==\
    \ 0 then return true end\n  end\n  return false\nend", "   local i, j, k, ret\
    \ = 0, 1, {}, {}\n   for _, v in ipairs(l) do\n      j[k] = v\n      k, ret =\
    \ k+1, k+v\n      if k > ret then\n         return false\n      end\n   end\n\
    \   for _, v in ipairs(j) do\n      if v > 0 then\n         return false\n   \
    \   end\n   end\n   return true\nend", "\tassert(#l == 1)\n\tlocal a = l[1]\n\t\
    for i = 2, #l do\n\t\tlocal b = l[i]\n\t\tif a + b == 0 then\n\t\t\treturn false\n\
    \t\telseif a + b < 0 then\n\t\t\treturn true\n\t\tend\n\t\ta = b\n\tend\n\treturn\
    \ true\nend", "  local sum = 0\n  for i, v in ipairs(l) do\n    if v then\n  \
    \    sum = sum + v\n      if sum < 0 then\n        return false\n      elseif\
    \ sum == 0 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "    for i = 1, #l do\n        if l[i - 1] == 0 and l[i] ~= 0 then\n   \
    \         return false\n        end\n    end\n    return true\nend", "    local\
    \ t = {}\n    for _, v in pairs(l) do t[v] = true end\n    local pairs = {}\n\
    \    for k, v in pairs(t) do pairs[v] = pairs[v] + 1 or true end\n    return #pairs\
    \ == 0\nend", "    local pairs = {}\n    for idx, i in pairs(l) do\n        pairs[i\
    \ - 1] = idx\n    end\n    if #pairs == 0 then\n        return false\n    else\n\
    \        local pairs = {}\n        for idx = #pairs do\n            if pairs[idx]\
    \ > #pairs then\n                pairs[idx] = nil\n            else\n        \
    \        pairs[idx] = pairs[pairs[idx]]\n            end\n        end\n      \
    \  local count = 0\n        for _, idx in pairs do\n            count = count\
    \ + 1\n            if count == 2 then\n                return true\n         \
    \   end\n        end\n        return false\n    end\nend", "  if #l == 0 then\n\
    \    return false\n  end\n  local first = table.unpack(l, 1, #l) -- get first\
    \ element\n  local rest = table.slice(l, 2, #l) -- get rest of list\n  local sum\
    \ = 0\n  for _, v in pairs(rest) do -- sum the rest of the elements\n    sum =\
    \ sum + v\n  end\n  if first == 0 then\n    return rest == [] or sum == 0\n  else\n\
    \    return sum == 0\n  end\nend", "    local pairs = {}\n    for idx, value in\
    \ pairs(l) do\n        pairs[value] = idx\n    end\n    for idx = 2, #l do\n \
    \       local val = l[idx]\n        if val then\n            if pairs[val] then\n\
    \                pairs[val] = nil\n            else\n                return false\n\
    \            end\n        end\n    end\n    return true\nend", "  local pairs\
    \ = {}\n  for i = 1, #l do\n    for j = i + 1, #l do\n      table.insert(pairs,\
    \ {l[i], l[j]})\n    end\n  end\n  local num_pairs = #pairs\n  for i = 1, num_pairs\
    \ do\n    if pairs[i].s[1] == 0 then\n      return true\n    end\n  end\n  return\
    \ false\nend", "    local num_zeros = 0\n    for _, v in pairs(l) do num_zeros\
    \ = num_zeros + v end\n    if num_zeros == 0 then return false end\n    for _,\
    \ v in pairs(l) do if v == 0 then num_zeros = num_zeros - 1 end\n            \
    \            if num_zeros == 0 then return true end\n                    end\n\
    \    return false\nend", "  local l2 = nil\n  for i = 1, #l do\n    l2 = l2 or\
    \ {}\n    local sum, count = 0, i + 1\n    for j = (i + 1):#l do\n      sum =\
    \ sum + l[j]\n      if sum == 0 then\n        return false\n      end\n      count\
    \ = (count - 1)\n      if count ~= 0 then\n        l2[j] = true\n      end\n \
    \   end\n    if count > 0 then\n      return false\n    end\n  end\n  return true\n\
    end", "    local zero = nil\n    for _, v in pairs(l) do\n        if v > zero\
    \ then\n            return false\n        end\n        zero = v\n    end\n   \
    \ return true\nend", "  if #l == 0 then return true end\n  for i = 1, #l do\n\
    \    if l[i] > 0 and l[i] ~= 0 then\n      if not pairs_sum_to_zero(l[i - 1],\
    \ l[i]) then return false end\n    end\n  end\n  return true\nend", "   -- check\
    \ for valid list before we begin\n   if #l ~= 2 then\n      return\n   end", " \
    \ local ret\n  local i = 1\n  while i < #l do\n    local v1 = l[i]\n    local\
    \ v2 = l[i + 1]\n    ret = v1 + v2 + ret\n    if ret ~= 0 then\n      i = i +\
    \ 1\n    else\n      if i == #l then\n        return ret\n      else\n       \
    \ i = i + 1\n      end\n    end\n  end\n  return false\nend", "  return #l ==\
    \ 0 or not table.remove(l, l[0]) or pairs_sum_to_zero(l) end\nend\n</cell>\n<cell>",
  "   if #l == 0 then return false end\n   local i\n   for i = 1,#l do\n      if l[i\
    \ - 1] > l[i] then\n         return false\n      end\n   end\n   return true\n\
    end", "    local i = 1\n    local n = 0\n    for i=1, #l do\n        n = n + 1\n\
    \        if l[i] == 0 then\n            return false\n        elseif n >= 2 then\n\
    \            return true\n        end\n    end\n    return false\nend", "    local\
    \ zeros = 0\n    local pairs = {}\n    for i = 1, #l do\n        local current_pair\
    \ = (l[i], 0)\n        if pairs[current_pair] then\n            pairs[current_pair]\
    \ = false\n        else\n            pairs[current_pair] = true\n            zeros\
    \ = zeros + 1\n        end\n    end\n    if zeros == #l then\n        return true\n\
    \    else\n        return false\n    end\nend", "    for i = 1, #l do -- loop\
    \ through the elements of l\n        local k = i\n        while k > 1 do\n   \
    \         k = k - 1\n            if l[k] + l[k] ~= 0 then -- check if the sum\
    \ of two elements\n                return false -- exist, i.e. there is no pair\
    \ in l that sum to 0\n            end\n        end\n    end\n    return true\n\
    end", "  return #l == 0 or (#l == 1 and l[1] == 0) or (#l > 1 and\n    ((l[1]\
    \ < 0 and l[2] == 0) or (l[1] >= 0 and l[2] < 0)) and\n    pairs_sum_to_zero(l:sub(2))\
    \ and\n    pairs_sum_to_zero(l:sub(1, 2))\n  )\nend", "    -- Scan through the\
    \ list\n    for i, v in ipairs(l) do\n        -- If the current element and the\
    \ one after it sum up to zero,\n        -- return true\n        if v == 0 and\
    \ l[i + 1] then\n            return true\n        end\n    end\n    return false\n\
    end", "    local sum = 0\n    for i = 1, #l do\n        sum = sum + l[i]\n   \
    \     if sum < 0 then\n            return false\n        end\n    end\n    return\
    \ true\nend", "   for i,v in pairs(l) do\n      if i == 1 or v == 0 then\n   \
    \      return false\n      elseif v == 1 then\n         if l[i - 1] + l[i + 1]\
    \ == 0 then\n            return false\n         end\n      else\n         return\
    \ false\n      end\n   end\n   return true\nend", "    local n = #l\n    if n\
    \ == 0 then\n        return true\n    end\n    local first = l[1]\n    for i =\
    \ 2, n do\n        local last = l[i - 1]\n        if last < first then\n     \
    \       return false\n        end\n        first = last + first\n    end\n   \
    \ return true\nend", "  local function helper(res, val, i)\n    if i ~= #l then\n\
    \      res[#res + 1] = val\n      helper(res, val, i + 1)\n    end\n  end", " \
    \ return #l == 0 and l[1] == 0 or #l == 0 and l[1] < 0\nend", "  local i = 0\n\
    \  local imax = #l\n  while i < imax do\n    local j = i + 1\n    while j < imax\
    \ and l[i] + l[j] == 0 do\n      j = j + 1\n    end\n    if j - i == 1 then\n\
    \      return true\n    end\n    i = j\n  end\n  return false\nend", "  for i\
    \ = 1, #l do\n    local found = false\n    for j = 1, #l do\n      if i > j then\n\
    \        found = (l[i] + l[j]) == 0 and\n          found or false\n      end\n\
    \    end\n    if not found then\n      return false\n    end\n  end\n  return\
    \ true\nend", "    -- write your code here.\n    for i = 1, #l do\n        if\
    \ i ~= 1 then\n            if l[i-1] + l[i] > 0 then\n                return false\n\
    \            else\n                return true\n            end\n        end\n\
    \    end\n    return false\nend", "   if #l == 1 then\n      return true\n   elseif\
    \ #l == 2 then\n      if l[1] == l[1] then\n         return true\n      else\n\
    \         return false\n      end\n   else\n      local s = 0\n      for _, x\
    \ in ipairs(l) do s = s + x end\n      if s == 0 then\n         return true\n\
    \      else\n         return false\n      end\n   end\nend", "   -- this code\
    \ is based on code by Chas Emerickson\n   if #l == 0 then\n      return true\n\
    \   end\n   local i = 1\n   local j = 1\n   while i <= #l and j <= #l do\n   \
    \   if l[i] + l[j] == 0 then\n         return true\n      end\n      j = j + 1\n\
    \      if j > #l then\n         j = 1\n         i = i + 1\n      end\n   end\n\
    \   return false\nend", "   if #l == 0 then\n      return false\n   elseif #l\
    \ == 1 then\n      return true\n   else\n      local prev_elem = l[1]\n      local\
    \ i = 0\n      while true do\n         if i > #l then\n            return false\n\
    \         end\n         if l[i] == prev_elem then\n            i = i + 1\n   \
    \      else\n            if i - 1 == #l then\n               return true\n   \
    \         else\n               prev_elem = l[i]\n            end\n         end\n\
    \      end\n   end\nend", "    local s, d, seen = 0, 0, {}\n    for i, v in ipairs(l)\
    \ do\n        seen[v] = true\n        if v > 0 then\n            s = s + v\n \
    \           d = d + 1\n        end\n    end\n    if d == 0 then\n        return\
    \ true\n    elseif d == 1 then\n        return seen[l[1]]\n    end\n    if d >\
    \ 1 then\n        return seen[l[1]] and pairs_sum_to_zero(l[(s+1):end])\n    else\n\
    \        return false\n    end\nend", "  -- The list should contain integers.\n\
    \  assert(type(tonumber(l[1])) and type(tonumber(l[2])) and type(tonumber(l[3]))\
    \ and type(tonumber(l[4])) and type(tonumber(l[5])) and type(tonumber(l[6])) and\
    \ type(tonumber(l[7])), \"The list should contain integers.\")\n  -- The empty\
    \ list sums to zero.\n  if #l == 0 then return true end\n  -- Find the first non-zero\
    \ number.\n  for i = 1, #l do\n    if tonumber(l[i]) == 0 then return false end\n\
    \  end\n  -- Iterate through the list comparing each number to the previous number.\n\
    \  local i = 1\n  while i < #l do\n    local current = tonumber(l[i])\n    local\
    \ prev = tonumber(l[i-1])\n    if current == prev then\n      i = i + 1\n    else\n\
    \      return true\n    end\n  end\n  return false\nend", "  local s = 0\n  local\
    \ l2 = {}\n  for k, v in pairs(l) do \n    local t = s + v\n    if t > 0 then\
    \ \n      l2[t] = k\n    end\n    s = t\n  end\n  return #l2 > 0\nend", "  local\
    \ i = 1\n  while i < l do\n    if l[i] == 0 then\n      i = i + 1\n    else\n\
    \      if l[i] == l[i - 1] + 1 then\n        -- We need to increment i to skip\
    \ over the current pair\n        i = i + 1\n      else\n        -- Found a pair\n\
    \        return false\n      end\n    end\n  end\n  return true\nend", "  local\
    \ last_pair = nil\n  for i, v in ipairs(l) do\n    if not last_pair or v ~= last_pair[1]\
    \ then\n      last_pair = {v, 1}\n    else\n      last_pair[1] = last_pair[1]\
    \ + 1 -- pairs consist of (value, frequency)\n    end\n  end\n  return last_pair[1]\
    \ == 0\nend", "  if #l == 0 then\n    return true\n  end\n  if #l == 1 then\n\
    \    return false\n  end\n  local first = l[1]\n  local next = l[1] + 1\n  for\
    \ i = 2, #l do\n    if l[i] < first then\n      return false\n    end\n    local\
    \ this_sum = first + l[i]\n    if this_sum == next then\n      return true\n \
    \   elseif this_sum > next then\n      next = this_sum\n    end\n  end\nend",
  "\tlocal result = {}\n\tfor i,v in ipairs(l) do\n\t\tresult[v] = true\n\tend\n\t\
    for i,v in ipairs(l) do\n\t\tif result[v] then\n\t\t\tresult[v] = false\n\t\t\
    end\n\tend\n\treturn #result == 0\nend", "  local i\n  for i = 1, #l do\n    local\
    \ k\n    k = i - 1\n    local sum = 0\n    while k >= 0 do\n      sum = sum +\
    \ l[k]\n      k = k - 1\n    end\n    if sum == 0 then\n      return true\n  \
    \  end\n  end\n  return false\nend", "  if l == nil then\n    return false\n \
    \ end\n  for i = #l, 1, -1 do\n    for j = 1, #l do\n      if l[i] == l[j] and\
    \ j - i < 2 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  local zero = {}\n  for i = 1, #l do\n    zero[i] = 0\n  end\n  for i\
    \ = 1, #l do\n    if l[i] ~= 0 then\n      local prev = i-1\n      local found\
    \ = false\n      for j = prev+1, #l do\n        if l[j] == l[i] + l[prev] then\n\
    \          found = true\n          break\n        end\n      end\n      if found\
    \ then\n        return true\n      end\n    end\n    zero[i] = l[i]\n  end\n \
    \ return false\nend", "    local zero, pairs = 0, {}\n    for i = 1, #l do\n \
    \       pairs[i] = l[i]\n    end\n    for i = 1, #l do\n        local a = pairs[i]\n\
    \        if a then\n            for j = i + 1, #l do\n                if pairs[j]\
    \ then\n                    local b = pairs[j]\n                    local s =\
    \ a + b\n                    if s then\n                        pairs[j] = s\n\
    \                        pairs[i] = b\n                        zero = s or zero\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\n    return zero\nend", "  local n = 0\n  for i=1,#l do\n    local e\
    \ = tonumber(l[i])\n    if e == 0 then\n      n = n + 1\n      if n == 2 then\n\
    \        return true\n      else\n        return false\n      end\n    end\n \
    \ end\n  return false\nend", "  local function f(x, sum)\n    if x == nil then\n\
    \      return false\n    end\n    if sum > 0 then\n      sum = sum - x\n    elseif\
    \ sum < 0 then\n      sum = sum + x\n    end\n    return sum == 0 and f(x[1],\
    \ sum) or not f(x[2], sum)\n  end\n  local result = f(1, l[1]) or f(1, -l[1])\n\
    \  return result\nend", "  local result = true\n  local first = {}\n  for i =\
    \ 1,#l do\n    local x = l[i]\n    if x == 0 then\n      if not result[#first+1]\
    \ then\n        result = false\n        break\n      end\n    elseif result[#first+1]\
    \ then\n      result = false\n      break\n    else\n      result[#first+1] =\
    \ x\n      first[#first+1] = i\n    end\n  end\n  return result\nend", "    local\
    \ pairs = {}\n    for i, v in pairs(l) do pairs[v] = i end\n    return #pairs\
    \ == 0\nend", "    local t = {}\n    for i, v in ipairs(l) do\n        if t[v]\
    \ == nil then\n            t[v] = i\n        else\n            return false\n\
    \        end\n    end\n    return true\nend", "   if #l == 0 then return false\
    \ end\n   local prev_sum = l[1]\n   for _, elem in pairs(l) do\n      if prev_sum\
    \ == 0 then\n         return false\n      else\n         prev_sum = prev_sum +\
    \ elem\n      end\n   end\n   return true\nend", "    local num_ones = 0\n   \
    \ local num_zeroes = 0\n    for i,v in ipairs(l) do\n        if v == 1 then\n\
    \            num_ones = num_ones + 1\n        else\n            num_zeroes = num_zeroes\
    \ + 1\n        end\n    end\n    return (num_ones > 1 and num_zeroes == 0)\nend",
  "    local s = 0\n    for i = 1,#l do\n        s = s + l[i]\n        if s == 0 then\
    \ return false end\n    end\n    return true\nend", "  local pairs = {}\n  local\
    \ total = 0", "  local pairs = {}\n  for i, v in ipairs(l) do\n    pairs[v] =\
    \ pairs[v] or {}\n    pairs[v][l[i]] = true\n  end\n  local sum = 0\n  local found\
    \ = false\n  for v, d in pairs do\n    local total = #d\n    if total > 1 then\n\
    \      return false\n    end\n    sum = sum + v\n    if sum == 0 then\n      found\
    \ = true\n    end\n  end\n  return found\nend", "    if #l == 0 then return false\
    \ end\n    if #l == 1 then return true end", "    local pairs = {}\n    for i,\
    \ x in pairs(l) do\n        table.insert(pairs, x)\n        table.insert(pairs,\
    \ 0)\n    end\n    local total = 0\n    for i, x in pairs(pairs) do\n        total\
    \ = total + x\n    end\n    for i, x in pairs(pairs) do\n        local difference\
    \ = total - x\n        if difference ~= 0 then\n            return false\n   \
    \     end\n    end\n    return true\nend", "   if #l == 0 then\n      return false\n\
    \   end\n   if #l == 1 then\n      return l == 0\n   end\n   for i=1, #l do\n\
    \      local first = l[i]\n      for j=1, #l do\n         local second = l[j]\n\
    \         if second < first then\n            local tmp\n            if second\
    \ > 0 then\n               tmp = first - second\n               if tmp >= 0 then\n\
    \                  return true\n               end\n               if tmp > 0\
    \ then\n                  return false\n               end\n            end\n\
    \            if first > 0 then\n               return true\n            end\n\
    \         end\n      end\n   end\n   return false\nend", "  local i, j, sum\n\
    \  local function inner_pairs_sum_to_zero(l)\n    i = l[1]\n    j = l[2]\n   \
    \ sum = i + j\n    if i == 0 or j == 0 then\n      return true\n    end\n    if\
    \ pairs and sum == 0 then\n      return true\n    end\n    return inner_pairs_sum_to_zero(l)\
    \ and inner_pairs_sum_to_zero(pairs(l)) and\n      inner_pairs_sum_to_zero(pairs(pairs(l)))\n\
    \  end\n  if pairs then\n    if type(l) == 'table' then\n      if l[1] == {} and\
    \ l[2] == {} and #l == 0 then\n        return true\n      end\n      local r1\
    \ = pairs(l)\n      local r2 = pairs(pairs(l))\n      local r3 = pairs(pairs(pairs(l)))\n\
    \      for i = 1, #r1 do\n        local pairs1 = r1[i]\n        local pairs2 =\
    \ r2[i]\n        local pairs3 = r3[i]\n        local r1n = table.remove(r1, i)\n\
    \        local r2n = table.remove(r2, i)\n        local r3n = table.remove(r3,\
    \ i)\n        local r1nn = table.remove(r1, i)\n        local r2nn = table.remove(r2,\
    \ i)\n        local r3nn = table.remove(r3, i)\n        if not inner_pairs_sum_to_zero(pairs1)\
    \ and !inner_pairs_sum_to_zero(pairs2) and\n          !inner_pairs_sum_to_zero(pairs3)\
    \ then\n          return false\n        end\n        if inner_pairs_sum_to_zero(pairs1)\
    \ and inner_pairs_sum_to_zero(pairs2) and\n          inner_pairs_sum_to_zero(pairs3)\
    \ then\n          if r1n ~= r1nn then\n            return false\n          end\n\
    \          if r1n ~= r3nn then\n            return false\n          end\n    \
    \      if r1n ~= r3n then\n            return false\n          end\n         \
    \ if r1n ~= r2n then\n            return false\n          end\n        end\n \
    \     end\n      if #r1 < #r2 then\n        if r1 == r2 then\n          return\
    \ false\n        end\n        return true\n      end\n      if #r1 < #r3 then\n\
    \        if r1 == r3 then\n          return false\n        end\n        return\
    \ true\n      end\n      if #r2 < #r3 then\n        if r2 == r3 then\n       \
    \   return false\n        end\n        return true\n      end\n      return false\n\
    \    end\n  end\n  return false\nend", "    if #l == 0 then return false end\n\
    \    local i, j = 1, 1\n    while i <= #l do\n        local k = i + j\n      \
    \  if k > #l then break end\n        local ok = false\n        local t\n     \
    \   for t = i, k do\n            if l[t] + l[k] == 0 then\n                ok\
    \ = true\n                break\n            end\n        end\n        if not\
    \ ok then break end\n        i = k + 1\n        j = i\n    end\n    if i == #l\
    \ then return true end\n    return false\nend", "  local result = {}\n  local\
    \ max = 0\n  for _, v in pairs(l) do\n    if v > 0 then\n      if max == 0 then\n\
    \        max = v\n      elseif max ~= v then\n        return false\n      end\n\
    \    end\n  end\n  return true -- There were two elements with equal value.\n\
    end", "    if #l == 0 then return False end\n    local i, j = 1, 1\n    while\
    \ i <= #l do\n        if l[i] == 0 and l[j] == 0 then return false end\n     \
    \   i = i + 2\n        j = j + 1\n    end\n    return true\nend", "  assert(#l\
    \ == 2)\n  return ((l[1] > 0) == (l[2] > 0)) and (not ((l[1] == 0) and (l[2] ==\
    \ 0)))\nend", "  local num_equal = 0\n  local num_not_equal = 0\n  for i = 1,\
    \ #l do\n    if l[i] + l[i+1] == 0 then\n      num_equal = num_equal + 1\n   \
    \ elseif l[i] - l[i+1] > 0 then\n      num_not_equal = num_not_equal + 1\n   \
    \ end\n  end\n  return num_not_equal == 0 and num_equal == #l - 1\nend", "  for\
    \ i,v in pairs(l) do\n    v = -v\n    if v==0 then\n      return i\n    end\n\
    \  end\n  return false\nend", "   local pairs = {}\n   for i=1,#l do\n      pairs[i]\
    \ = l[i]\n      if pairs[i] ~= pairs[i]+i then return false end\n   end\n   return\
    \ true\nend", "   if #l == 1 then\n      return false\n   end", "    local zero\
    \ = {}\n    for i,v in pairs(l) do\n        zero[v] = true\n    end\n    for i,v\
    \ in pairs(l) do\n        if zero[v] then\n            return false\n        end\n\
    \    end\n    return true\nend", "  if #l == 0 then\n    return false\n  end\n\
    \  local s, d, i = 0, {}, {}\n  for k, v in pairs(l) do\n    i = i + 1\n    local\
    \ nv = v\n    if nv == 0 then\n      return true\n    end\n    if nv ~= nil then\n\
    \      if not d[v] then\n        d[v] = false\n      end\n      if d[v] then\n\
    \        if s ~= 0 then\n          if nv == s then\n            return true\n\
    \          end\n        else\n          s = nv\n        end\n      end\n    end\n\
    \  end\n  return false\nend", "   local s = 0\n   for _, elem in ipairs(l) do\n\
    \      if elem > 0 then\n         s = s + elem\n      end\n   end\n   return s\
    \ == 0 and lua.math.huge\nend", "\tlocal l1 = table.remove(l, 1)\n\tfor _, v in\
    \ pairs(l) do\n\t\tif v + l1 == 0 then\n\t\t\treturn false\n\t\tend\n\tend\n\t\
    return true\nend", "  for i,v in ipairs(l) do\n    for j = i + 1,#l do\n     \
    \ if v + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "    local pairs = {}\n    local n = 1\n    for i=1,#l do\n   \
    \     table.insert(pairs, {n, l[i]})\n        n = n*(-1)+l[i]\n    end\n    local\
    \ sum = 0\n    for i,v in pairs do\n        sum = sum + v\n    end\n    return\
    \ sum == 0\nend", "  local num_unique = #l\n  if num_unique == 0 then\n    return\
    \ false\n  end\n  local zeros = {}\n  local total_pairs = 0\n  for i = 1, num_unique\
    \ do\n    local element = l[i]\n    if element == 0 then\n      zeros[element]\
    \ = true\n    else\n      total_pairs = total_pairs + 1\n      if total_pairs\
    \ == 2 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  local sum_zero = 0\n  local i = 0\n  local j = 1\n  for k,v in pairs(l)\
    \ do\n    sum_zero = sum_zero + v\n    if sum_zero == 0 then\n      return false\n\
    \    end\n  end\n  return true\nend", "   local pairs = {}\n   for i = 1,#l do\n\
    \      local v1 = l[i]\n      local v2 = l[i+1]\n      if v1 ~= 0 and v2 ~= 0\
    \ then pairs[v1 + v2] = true end\n   end\n   if #pairs > 1 then return false end\n\
    \   for i = 1,#pairs do\n      if pairs[i] != false then return false end\n  \
    \ end\n   return true\nend", "   -- We require that l be a list or tuple, since\
    \ lists are mutable.\n   assert(type(l) == 'table' or type(l) == 'tuple')\n  \
    \ assert(#l > 0)\n   -- Return true if the input list has 2 distinct integers\
    \ that\n   -- sum to zero.\n   return false\nend", "  local pairs = {}\n  for\
    \ i = 1, #l do\n    pairs[l[i]] = l[i]\n  end\n  local keys = {}\n  local values\
    \ = {}\n  for k, v in pairs do\n    if pairs[keys[k]] and pairs[keys[k]] ~= v\
    \ then\n      return false\n    end\n    keys[k] = v\n    values[v] = true\n \
    \ end\n  return #keys == 1\nend", "  assert(type(l) == \"table\")\n  local result\
    \ = {}\n  for _, v in ipairs(l) do\n    if v == 1 then\n      result[#result +\
    \ 1] = v\n    else\n      local found = {}\n      for i = 1, #result do\n    \
    \    if v + result[i] == 0 then\n          table.insert(found, 1)\n        elseif\
    \ v + result[i] ~= 0 and result[i] ~= 0 then\n          return true\n        end\n\
    \      end\n      if #found > 1 then\n        return true\n      end\n      result\
    \ = found\n    end\n  end\n  return #result == 1\nend", "   for i = #l + 1, 1\
    \ do\n      for j = 1, #l do\n         if l[i] == l[j] then return false end\n\
    \      end\n   end\n   return true\nend", "  assert(#l == 2)\n  local n1, n2 =\
    \ l[1], l[2]\n  local sum\n  if n1 == nil then\n    sum = 0\n  elseif n2 == nil\
    \ then\n    sum = n1\n  else\n    sum = n1 + n2\n  end\n  return sum == 0 and\
    \ pairs(l).sum == 0 or sum == 0\nend", "  if l == nil then return false end\n\
    \  local pairs = {}\n  for i = 1, #l do pairs[#pairs + 1] = l[i] + l[i - 1]; end\n\
    \  local i, ret = 1, false\n  while i <= #pairs do\n    if pairs[i] > 0 and pairs[i\
    \ + 1] > 0 and pairs[i] + pairs[i + 1] == 0 then\n      ret = true\n      break\n\
    \    end\n    i = i + 1\n  end\n  return ret\nend", "\tassert(#l == 2, 'Pairs\
    \ list must have exactly two elements')\n\tlocal l1, l2 = unpack(l)\n\tlocal i1,\
    \ i2 = l1, l2\n\twhile i1 < #l and i2 < #l do\n\t\ti1 = l1 -- this line is equivalent\
    \ to:\n\t\t-- i1 = l1:next()\n\t\t-- (i1 == nil) -- nil will be returned when\
    \ end of list is reached\n\t\t-- l2 = l2:next()\n\t\t-- (l2 == nil) -- nil will\
    \ be returned when end of list is reached\n\t\tif i1 ~= nil then l1, l2 = l2,\
    \ l1:next() end\n\t\tif i2 ~= nil then l1, l2 = l2, l2:next() end\n\tend\n\treturn\
    \ i1 ~= nil and i2 ~= nil\nend", "  local sum = 0\n  local i = 0\n  for _ in pairs(l)\
    \ do\n    sum = sum + l[i]\n    i = i + 1\n  end\n  return sum == 0\nend", " \
    \ for _, i in pairs(l) do\n    if sum(i) ~= 0 then return false end\n  end\n \
    \ return true\nend", "  local s = #l\n  local i = s\n  while i > 0 do\n    local\
    \ k = s - 1\n    while k > 0 do\n      if l[i] - l[k] == 0 then\n        return\
    \ false\n      end\n      k = k - 1\n    end\n    i = i - 1\n  end\n  return true\n\
    end", "    local ok, last_pair = false, false\n    for _, value in ipairs(l) do\n\
    \        ok = ok and last_pair and not last_pair[2]\n        last_pair = last_pair\
    \ or {value, value, value, value}\n    end\n    return not ok\nend", "\tlocal\
    \ first_half = { }\n\tlocal second_half = { }\n\tlocal pairs = {}\n\tlocal k =\
    \ 0\n\tlocal i\n\tfor i = 1, #l do\n\t\tlocal value = l[i]\n\t\tk = k + value\n\
    \t\tif k < 2 then\n\t\t\tpairs[k] = value\n\t\telse\n\t\t\ttable.insert(first_half,\
    \ pairs[k])\n\t\t\ttable.insert(second_half, value)\n\t\tend\n\tend\n\t-- Make\
    \ sure that all the pairs are the same size.\n\t-- In other words, check that\
    \ there are two distinct elements.\n\t-- There are two distinct elements if and\
    \ only if the sum of the two\n\t-- first elements is zero.\n\tassert(#first_half\
    \ == #second_half)\n\tlocal z\n\tfor i = 1, #first_half do\n\t\tz = z + first_half[i]\n\
    \tend\n\tif z == 0 then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend",
  "  local pairs = {}\n  local i = 1\n  for _, elem in ipairs(l) do\n    pairs[i]\
    \ = elem\n    i = i + 1\n  end\n  for i = 2, #l do\n    local j = i - 1\n    while\
    \ j >= 0 do\n      local k = j + 1\n      while k <= #pairs do\n        pairs[k]\
    \ = (pairs[k] + pairs[j]) -- This is the line that causes the error\n        k\
    \ = k + 1\n      end\n      j = j - 1\n    end\n  end\n  -- if l is a number,\
    \ then it must be equal to a sum of the list elements.\n  return #pairs == 0\n\
    end", "   if l[1] == nil then\n      return false\n   end", "   if #l == 0 then\n\
    \      return false\n   end\n   local i = 1\n   local j = #l\n   while i < j do\n\
    \      if l[i] + l[j] ~= 0 then\n         return false\n      end\n      i = i\
    \ + 1\n      j = j - 1\n   end\n   return true\nend", "    -- Check if l is non-empty.\n\
    \    if not l then return false end", "  local function helper(l, index, sum)\n\
    \    if index == 1 then\n      return true\n    elseif index > l then\n      return\
    \ false\n    elseif index == 1 then\n      return sum == 0\n    else\n      return\
    \ helper(l, index-1, sum-pairs[index])\n    end\n  end", "  local s = 0\n  local\
    \ t = {}\n  for k, v in pairs(l) do\n    local k = k or 1\n    local v = v or\
    \ 1\n    s = s + v\n    t[s] = t[s] and 1 or nil\n  end\n  local keys = {}\n \
    \ -- Only one nil value exists. We won't worry about returning nil since\n  --\
    \ that is done in the other function.\n  for k, v in pairs(t) do\n    keys[k]\
    \ = nil\n  end\n  for i = 1, #l do\n    local k = l[i]\n    local v = t[k]\n \
    \   -- Avoid comparing pairs with nil values. Since the nil value is\n    -- not\
    \ present in the key hash, the function will ignore that key.\n    local key =\
    \ (k and k) or 1\n    if not v or v == 0 then\n      return false\n    end\n \
    \ end\n  for k, v in pairs(keys) do\n    -- If we've reached this point, then\
    \ we have the same number\n    -- of pairs as in the list. Since we added in the\
    \ nil check,\n    -- we can safely ignore this pair.\n    if v == nil then\n \
    \     return true\n    end\n  end\n  return false\nend", "  local n = #l\n  for\
    \ i = 1, n do\n    local t = l[i]\n    if t ~= 0 and t ~= l[i+1] then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  local pairs = {}\n  for i,v in\
    \ ipairs(l) do\n    pairs[i] = v\n  end\n  local sum = 0\n  for i,v in pairs do\n\
    \    sum = sum + v\n  end\n  return sum == 0\nend", "  if #l == 0 then\n    return\
    \ true\n  end\n  local zeros, last = 0, {}\n  for i, x in ipairs(l) do\n    if\
    \ x == 0 then\n      zeros = zeros + 1\n    else\n      table.insert(last, x)\n\
    \    end\n  end\n  if #last == 0 then\n    return false\n  end\n  if zeros ==\
    \ #last then\n    return true\n  end\n  return pairs_sum_to_zero(last)\nend",
  "  local num_zeros = 0\n  for i = 1, #l do\n    local diff = l[i] - l[i - 1]\n \
    \   if diff == 0 then num_zeros = num_zeros + 1 end\n    if num_zeros > 1 then\
    \ return false end\n  end\n  return true\nend", "\tlocal pairs = {}\n\tlocal total\
    \ = 0\n\tfor _, elt in pairs(l) do\n\t\ttotal = total + elt\n\t\tif total < 0\
    \ then\n\t\t\treturn false -- negative total\n\t\tend\n\tend\n\tfor _, elt in\
    \ pairs(l) do\n\t\tif total > 0 then\n\t\t\treturn false -- non-distinct elements\n\
    \t\tend\n\t\ttotal = total + elt\n\tend\n\treturn true\nend", "  local t = {}\n\
    \  local i = 1\n  for _ in pairs(l) do\n    t[i] = t[i] or 0\n    t[i] = t[i]\
    \ + l[i]\n    if t[i] ~= 0 then\n      return false\n    end\n    i = i + 1\n\
    \  end\n  if i == 1 then\n    return true\n  end\nend", "  local n = #l\n  local\
    \ zeros = 0\n  local pairs = {}\n  local i = 1\n  while i < n do\n    local j\
    \ = i + 1\n    while j < n do\n      if l[i] + l[j] == 0 then\n        zeros =\
    \ zeros + 1\n      else\n        pairs[i] = pairs[i] or l[i]\n        pairs[j]\
    \ = pairs[j] or l[j]\n        pairs[i]:add(pairs[j])\n        pairs[j]:clear()\n\
    \        pairs[i] = pairs[i]:sort()\n        pairs[j]:sort() -- sort the pairs\
    \ again\n        break\n      end\n      j = j + 1\n    end\n    i = i + 1\n \
    \ end\n  return zeros == n\nend", "  return #l == 0 or\n    pairs(l):reduce(\n\
    \      function(s, t)\n        local result = s + t\n        if result > 0 then\
    \ return t end\n        if result < 0 then return s end\n        return s\n  \
    \    end,\n      0) == 0 and true\nend", "  local zero = {}\n  local zeros = zero\n\
    \  for i = 1, #l do\n    local value = l[i]\n    if value == 0 then\n      if\
    \ #zeros == 0 then\n        return true\n      elseif #zeros + 1 == i then\n \
    \       zeros[#zeros + 1] = 0\n      else\n        zeros = zeros[#zeros]\n   \
    \   end\n    elseif value == -1 then\n      zeros[#zeros + 1] = value\n    end\n\
    \  end\n  return false\nend", "  local n_pairs = 0\n  local zeros = 0\n  for i,\
    \ x in pairs(l) do\n    if x == 0 then\n      zeros = zeros + 1\n    elseif n_pairs\
    \ == 0 then\n      n_pairs = i\n    else\n      if x >= 0 then\n        local\
    \ pair = n_pairs - i - 1\n        if pair > 0 and l[pair] == x then\n        \
    \  return false\n        elseif pair ~= 0 and l[pair] == x + l[pair - 1] then\n\
    \          return false\n        else\n          n_pairs = i\n        end\n  \
    \    end\n    end\n  end\n  return n_pairs == zeros\nend", "  local seen = {}\n\
    \  local i = 1\n  while i <= #l do\n    local elem = l[i]\n    if seen[elem] ~=\
    \ nil then\n      return false\n    else\n      seen[elem] = i\n    end\n    i\
    \ = i + 1\n  end\n  return true\nend", "  local l1 = l[1]\n  for _, v2 in ipairs(l)\
    \ do\n    if v1 + v2 ~= 0 then\n      return false\n    end\n  end\n  return true\n\
    end", "    local result = true\n    for i = 1, #l do\n        if result\n    \
    \    then\n            if l[i] ~= 0\n            then\n                result\
    \ = false\n                break\n            end\n        end\n    end\n    return\
    \ result\nend\n</code>\n<|/ a tags=lua,lua-table |>\n<| a |>\n<code>", "\tassert(type(l)\
    \ == \"table\" and #l > 0)\n\tlocal s, result = {}, {}\n\tfor i = 1, #l do\n\t\
    \tlocal value = l[i]\n\t\ts[value] = true\n\t\tif value == 0 then break end\n\t\
    end\n\tfor key, value in pairs(s) do\n\t\tif result[value] == nil then\n\t\t\t\
    result[value] = key\n\t\tend\n\tend\n\treturn #result == 0\nend", "  for i = 2,\
    \ #l do\n    local twos = l[i - 2]\n    if twos == 0 and pairs(l[i - 1]) == pairs(l[i])\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  local s =\
    \ l -- initialize a variable to store the sum\n  local n = #l -- initialize a\
    \ variable to count the elements\n  local t = false -- initialize a variable to\
    \ store the result\n  local count = 0 -- initialize a variable to count the elements",
  "    local i\n    for i = 1, #l do\n        if l[i] == 0 then\n            return\
    \ false\n        end\n    end\n    return true\nend", "\t-- find all pairs of\
    \ elements in the list that sum to zero.\n\tlocal function is_two(n)\n\t\treturn\
    \ n >= 0 and n and n and n % 2 ~= 0\n\tend", "    local i\n    local j = #l\n\
    \    local k = 1\n    repeat do\n        i = j - k\n        if i > 0 then\n  \
    \          if l[i+k] == 0 then\n                return false\n            else\n\
    \                k = k+1\n            end\n        end\n        j = j-1\n    \
    \    if j > 0 then\n            if l[j] == 0 then\n                return false\n\
    \            else\n                k = k+1\n            end\n        end\n   \
    \ until j == 0\n    return true\nend", "\tlocal s = #l\n\tlocal count = 0\n\t\
    local i = 0\n\twhile i < s do\n\t\tlocal cur = l[i]\n\t\tcount = count + cur\n\
    \t\ti = i + 1\n\t\tif count == 0 then\n\t\t\treturn true\n\t\telseif count ==\
    \ 1 then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn false\nend", "   assert(#l\
    \ > 0)\n   local num_distinct_pairs = 0\n   for i = 2, #l do\n      local element\
    \ = l[i]\n      for j = i, #l do\n         if element == l[j] then\n         \
    \   num_distinct_pairs = num_distinct_pairs + 1\n         end\n      end\n   end\n\
    \   return (num_distinct_pairs == 0)\nend", "  local s = 0\n  for _, v in pairs(l)\
    \ do\n    s = s + v\n  end\n  if s == 0 then\n    return false\n  else\n    local\
    \ t = {}\n    local i = 1\n    for k, v in pairs(l) do\n      if i == 1 then\n\
    \        t[s] = v\n      else\n        if t[s] ~= v then\n          return false\n\
    \        end\n      end\n      i = i + 1\n    end\n    return true\n  end\nend",
  "  for i = 1,#l do\n    for j = i+1,#l do\n      if l[i] + l[j] == 0 then\n    \
    \    return true\n      end\n    end\n  end\n  return false\nend", "  local res\
    \ = {}\n  local i = 1\n  while i <= #l do\n    local key = l[i]\n    local val\
    \ = i - 1\n    while val ~= 0 do\n      if key == l[val] then\n        val = val\
    \ - 1\n      else\n        res[#res + 1] = key .. ','\n        res[#res + 1] =\
    \ val\n        return res\n      end\n    end\n    res[#res + 1] = key .. ','\n\
    \    res[#res + 1] = '-1'\n    i = i + 1\n  end\n  return res\nend", "  local\
    \ result = {}\n  for k,v in pairs(l) do\n    if v == 0 then\n      table.insert(result,\
    \ k)\n    end\n  end\n  if #result == 1 then\n    return true\n  else\n    return\
    \ false\n  end\nend", "  local seen = {}\n  for i, v in ipairs(l) do\n    seen[v]\
    \ = true\n  end\n  return #seen == 2 or #seen == 0\nend", "   local result\n \
    \  for i = 1, #l do\n      result = result or (l[i - 1] + l[i] == 0)\n   end\n\
    \   return result\nend", "  local res = {pairs(l)}\n  local sum = 0\n  for _,\
    \ v in pairs(l) do\n    sum = sum + v\n    res[sum] = v\n  end\n  for i = 1, #l\
    \ do\n    local j = i\n    while j and res[j - 1] > res[j] do\n      j = j - 1\n\
    \    end\n    if j == 1 then\n      return false\n    end\n    res[j] = res[j]\
    \ - l[i]\n  end\n  return true\nend", "  local ok, count = pcall(function() table.sort(l)\
    \ end)\n  if count == 1 then return false end\n  local i = 1\n  repeat\n    ok,\
    \ count = pcall(function() return (i - 1) * (i - 1) end) -- i * i\n  until not\
    \ ok\n  local j = 1\n  repeat\n    ok, count = pcall(function() return (l[j] +\
    \ l[j + 1]) end) -- l[j] + l[j + 1]\n  until not ok\n  return true\nend", "  \
    \  local r = {} -- r is a hashtable\n    for i = 1, #l do -- iterate over list\
    \ l, 1 at a time\n        if r[l[i]] == nil then -- if hash table does not contain\
    \ an element\n            r[l[i]] = i -- add it to the hash table\n        elseif\
    \ r[l[i]] > i then -- if hash table already contains this key\n            r[l[i]]\
    \ = r[l[i]] -- update the hash table\n        else\n            return false --\
    \ break out of loop\n        end\n    end\n    return true -- return true if all\
    \ elements in the hash table have value 0\nend", "  for i = 1, #l do\n    for\
    \ j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n    \
    \  end\n    end\n  end\n  return false\nend", "  local result\n  local i1\n  for\
    \ i1, elem in ipairs(l) do\n    local i2 = i2\n    while i2 > 0 do\n      i2 =\
    \ i2 - 1\n      if elem > l[i2] then break end\n    end\n    local i3 = i1\n \
    \   while i3 > i1 do\n      i3 = i3 - 1\n      if not result then\n        result\
    \ = {i1, i2, i3}\n      elseif elem > l[i3] and elem > result[#result] then\n\
    \        result[#result] = elem\n        break\n      end\n    end\n  end\n  return\
    \ #result == 2\nend", "    local pairs = {}\n    for i, x in ipairs(l) do\n  \
    \      pairs[i] = x\n    end\n    local sum = 0\n    for key, value in pairs do\n\
    \        sum = sum + value\n    end\n    return sum == 0\nend", "  local count\
    \ = 0\n  local l_size = #l\n  while l_size > 0 do\n    count = count + 1\n   \
    \ local i = 1\n    while i <= l_size do\n      if l[i] == 0 and l[i-1] == 0 then\n\
    \        return true\n      elseif l[i] > 0 and l[i-1] > 0 then\n        count\
    \ = count + 1\n      else\n        count = count - 1\n        break\n      end\n\
    \      i = i + 1\n    end\n    l_size = l_size - 1\n  end\n  return count == 0\n\
    end", "    for i = 1, #l do\n        if l[i] == l[i - 1] + 1 then\n          \
    \  return false\n        end\n    end\n    return true\nend", "  local s = 0\n\
    \  for _, v in pairs(l) do s = s + v end\n  return s == 0\nend", "\tlocal n =\
    \ #l\n\tif n < 2 then\n\t\treturn false\n\tend\n\tlocal m = {}\n\tfor i = 1, n\
    \ do\n\t\tlocal w = l[i]\n\t\tif m[w] ~= nil then\n\t\t\treturn false\n\t\tend\n\
    \t\tm[w] = true\n\tend\n\tlocal count = 0\n\tfor i = 2, n do\n\t\tlocal w = l[i]\n\
    \t\tif not m[w] then\n\t\t\treturn false\n\t\tend\n\t\tcount = count + 1\n\tend\n\
    \treturn count == 2\nend", "    -- We use a table to keep track of how many times\
    \ an element appears in the list\n    local counts = table.new()\n    -- We loop\
    \ through the list and count how many times an element appears\n    for _, x in\
    \ ipairs(l) do\n        counts[x] = counts[x] + 1 or 1\n    end\n    -- We check\
    \ whether there are two distinct elements that sum to zero.\n    -- Since we have\
    \ at most 10 elements, if there are more than 10 distinct elements,\n    -- we\
    \ return False\n    local count = 0\n    for _, x in ipairs(l) do\n        count\
    \ = count + counts[x]\n    end\n    -- If there are more than 10 distinct elements,\
    \ return False.\n    return count > 10\nend", "  -- Scan the list from left to\
    \ right and check if the sum is 0.\n  -- If it is, return true, otherwise return\
    \ false.\n  local pairs = {}\n  for i = 1, #l do\n    pairs[i] = l[i]\n  end\n\
    \  for i = #l, 1, -1 do\n    local p = pairs[i]\n    if p + pairs[i - 1] == 0\
    \ then\n      return true\n    end\n    pairs[i] = nil\n  end\n  return false\n\
    end", "  local sum = 0\n  for _, v in pairs(l) do\n    sum = sum + v\n    if sum\
    \ < 0 then return false end\n  end\n  return true\nend", "   -- return if there\
    \ are no elements in the list\n   if #l == 0 then\n      return true\n   end",
  "  return l.size == 1 and (l == [1 .. 1] or l[l.size - 1] == 0)\nend", "  local\
    \ function aux(l)\n    local i = 1\n    local n = #l\n    while i < n do\n   \
    \   local s = l[i] + l[i+1]\n      if s == 0 then\n        return false\n    \
    \  elseif s == 0 then -- we found two equal numbers, no need to keep checking\n\
    \        return true\n      elseif s > 0 then -- we need to keep checking\n  \
    \      local ok = aux(l, i, i+2)\n        if not ok then\n          return false\n\
    \        end\n        i = i + 2\n      else\n        i = i + 1\n      end\n  \
    \  end\n    return true\n  end\n  return aux(l)\nend", "  if l == nil then\n \
    \   return false\n  end\n  local sum = 0\n  for i,v in ipairs(l) do\n    sum =\
    \ sum + v\n    if sum > 0 then\n      break\n    end\n  end\n  if sum == 0 then\n\
    \    return true\n  else\n    return false\n  end\nend", "  local pairs = {}\n\
    \  for i = 1, #l do\n    local sum = 0\n    for _, v in pairs(l) do\n      sum\
    \ = sum + v\n    end\n    pairs[i] = sum\n  end\n  local sum = 0\n  for i, v in\
    \ pairs(l) do\n    sum = sum + v\n    if sum == 0 then return false end\n  end\n\
    \  return true\nend", "\tlocal l1 = {}\n\tlocal l2 = {}\n\tfor index, value in\
    \ ipairs(l) do\n\t\tif l1[value] ~= nil then\n\t\t\treturn false\n\t\tend\n\t\t\
    l1[value] = true\n\tend\n\tfor index, value in ipairs(l) do\n\t\tl2[value] = true\n\
    \tend\n\t\n\tlocal pairs = {}\n\tfor key, value in pairs(l1) do\n\t\tif value\
    \ == l2[value] then\n\t\t\tpairs[pairs.new({key = key, value = value})] = true\n\
    \t\tend\n\tend\n\t\n\treturn #pairs == 0\nend", "  local function is_zero(a)\n\
    \    return not (a or a:sub(1,-1))\n  end\n  local function sum_if_zero(i, j)\n\
    \    return j and is_zero(i-j) or 0\n  end\n  local function is_two(i)\n    return\
    \ i and is_zero(i) and i-1 and is_zero(i-1)\n  end\n  local function is_three_or_more(i)\n\
    \    return i and is_zero(i) and i > 2 and is_zero(i-2)\n  end\n  local function\
    \ is_three_or_less(j)\n    return j and is_zero(j) and j > 2 and is_zero(j-2)\n\
    \  end\n  local function is_one(i)\n    return i and is_zero(i) and i-1 and is_one(i-1)\n\
    \  end\n  local function is_twos(i)\n    return i and is_zero(i) and i-1 and is_twos(i-1)\n\
    \  end\n  local function is_threes(i)\n    return i and is_zero(i) and i-1 and\
    \ is_threes(i-1)\n  end\n  local function is_fours(i)\n    return i and is_zero(i)\
    \ and i-1 and is_fours(i-1)\n  end\n  local function is_fives(i)\n    return i\
    \ and is_zero(i) and i-1 and is_fives(i-1)\n  end\n  return l and #l > 1 and is_zero(l[1])\
    \ and #l >= 2 and is_zero(l[1]-2) and #l >= 3 and is_zero(l[1]-2) and #l >= 4\
    \ and is_zero(l[1]-2) and #l >= 5 and is_zero(l[1]-2) and #l >= 6 and is_zero(l[1]-2)\
    \ and #l >= 7 and is_zero(l[1]-2) and #l >= 8 and is_zero(l[1]-2) and #l >= 9\
    \ and is_zero(l[1]-2) and #l >= 10 and is_zero(l[1]-2) and #l >= 11 and is_zero(l[1]-2)\
    \ and #l >= 12 and is_zero(l[1]-2) and #l >= 13 and is_zero(l[1]-2) and #l >=\
    \ 14 and is_zero(l[1]-2) and #l >= 15 and is_zero(l[1]-2) and #l >= 16 and is_zero(l[1]-2)\
    \ and #l >= 17 and is_zero(l[1]-2) and #l >= 18 and is_zero(l[1]-2) and #l >=\
    \ 19 and is_zero(l[1]-2) and #l >= 20 and is_zero(l[1]-2) and #l >= 21 and is_zero(l[1]-2)\
    \ and #l >= 22 and is_zero(l[1]-2) and #l >= 23 and is_zero(l[1]-2) and #l >=\
    \ 24 and is_zero(l[1]-2) and #l >= 25 and is_zero", "   assert(#l >= 2, 'pairs_sum_to_zero:\
    \ l has length less than 2')\n   local s = l[1]\n   for i = 2, #l do\n      s\
    \ = s + l[i]\n      if s == 0 then return true end\n   end\n   return false\n\
    end", "   local result\n   for _, v in ipairs(l) do\n      if v > 0 then\n   \
    \      if result then return false end\n         result = true\n      end\n  \
    \ end\n   return result\nend", "  -- We use a hash table to find pairs with the\
    \ same sum.\n  -- This algorithm is O(n) (where n is the length of the input list).\n\
    \  local tbl = {}\n  for _, x in ipairs(l) do\n    local new_tbl = {}\n    for\
    \ i = 1, #tbl do\n      local s, p = tbl[i]\n      if s == x then\n        new_tbl[i]\
    \ = p + 1, true\n      else\n        new_tbl[i] = s, false\n      end\n    end\n\
    \    tbl = new_tbl\n  end\n  return #tbl[1] == 0\nend", "  local sz = #l\n  if\
    \ sz == 0 then return false end\n  local first = l[1]\n  for i = 2, sz do\n  \
    \  local tmp = l[i]\n    if tmp == first then return false end\n    first = first\
    \ - tmp\n  end\n  return true\nend", "  if #l == 0 then return true end\n  local\
    \ zeros, non_zeros = 1, 1\n  for i = 1, #l do\n    if l[i] ~= 0 then\n      if\
    \ l[i] + non_zeros > zeros then\n        zeros = l[i] + non_zeros\n      else\n\
    \        non_zeros = l[i] + non_zeros\n      end\n    end\n  end\n  return zeros\
    \ == 0 and non_zeros == 0\nend", "    local sum = 0\n    for pair in l do\n  \
    \      sum = sum + pair[1]\n    end\n    return (sum == 0)\nend", "  local new_l\
    \ = {}\n  for i, v in ipairs(l) do\n    new_l[i] = v\n  end\n  for i = 1, #l do\n\
    \    local s = new_l[i] + new_l[i + 1]\n    if s == 0 then\n      return true\n\
    \    end\n    if new_l[i + 1] > 0 and s == 0 then\n      return true\n    end\n\
    \    new_l[i + 1] = new_l[i]\n  end\n  return false\nend", "  local i = 1\n  while\
    \ i <= #l do\n    if l[i - 1] + l[i] > 0 then return false end\n    i = i + 1\n\
    \  end\n  return true\nend", "  local result = true\n  for i = 1, #l do\n    local\
    \ pair = unpack(l, i, true)\n    if pair[1] == pair[2] then result = false break\
    \ end\n  end\n  return result\nend", "   if #l == 0 then return false end\n  \
    \ local zero = false\n   local one = false\n   local two = false\n   local i =\
    \ 1\n   while i <= #l do\n      if l[i] > 0 and l[i] < l[i - 1] then\n       \
    \  one = not one\n      elseif l[i] > 0 and l[i] > l[i - 1] then\n         zero\
    \ = not zero\n      elseif l[i] < 0 and l[i] < l[i - 1] then\n         two = not\
    \ two\n      else\n         return false\n      end\n      i = i + 1\n   end\n\
    \   return not zero\nend", "  local s = 0\n  local t = nil\n  local seen = nil\n\
    \  for i=1,#l do\n    if s == 0 then\n      s = l[i]\n      t = i\n      seen\
    \ = 1\n    else\n      if s == l[i] then\n        seen = seen + 1\n      else\n\
    \        if seen > 1 then\n          return false\n        end\n        s = l[i]\n\
    \        t = i\n        seen = 1\n      end\n    end\n  end\n  if seen > 1 then\n\
    \    return false\n  end\n  return true\nend", "    local new_l = {}\n    for\
    \ index, item in ipairs(l) do\n        if index == 1 then\n            new_l[1]\
    \ = 1\n        else\n            new_l[index] = item\n        end\n    end\n \
    \   local count = 0\n    local pair = {}\n    local max_item = 0\n    for index,\
    \ item in ipairs(new_l) do\n        if item > 0 then\n            count = count\
    \ + 1\n            if item > max_item then\n                max_item = item\n\
    \                pair[1] = index - 1\n            elseif item == max_item then\n\
    \                pair[1] = index - 1\n                pair[2] = index\n      \
    \      end\n        end\n    end\n    if max_item == 0 then\n        pair[1] =\
    \ #new_l\n        pair[2] = #new_l\n    end\n    return #pair == 2 and (pair[1]\
    \ == pair[2])\nend", "  local i = 0\n  local j = 1\n  while i < #l do\n    if\
    \ l[i] == 0 then\n      if i == j then\n        return true\n      else\n    \
    \    j = i + 1\n      end\n    else\n      if j > #l then\n        return false\n\
    \      end\n      i = i + 1\n      j = j + 1\n    end\n  end\n  return false\n\
    end", "    local pairs = {}\n    for i = 1, #l do\n        table.insert(pairs,\
    \ i)\n        table.insert(pairs, -i)\n    end\n    return #pairs == #l and pairs[#pairs\
    \ == #l - 1]\nend", "  local sum_ = 0\n  for _, v in pairs(l) do\n    sum_ = sum_\
    \ + v\n  end\n  for _, v in pairs(l) do\n    if sum_ == 0 then return false end\n\
    \    sum_ = sum_ - v\n  end\n  return true\nend", "  local pairs = {}\n  local\
    \ i = 0\n  for _, v in pairs(l) do\n    i = i + 1\n    pairs[i] = v\n  end", " \
    \ local pairs = {}\n  for i = 1, #l do\n    local value = l[i]\n    for j = 1,\
    \ i do\n      pairs[l[i]] = l[j]\n    end\n    if value > 0 then\n      pairs[value]\
    \ = true\n    end\n  end\n  for _, v in pairs do\n    if v then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  local seen = {}\n  local i =\
    \ 1\n  local s = l[1]\n  while i < #l do\n    if seen[s] then\n      return true\n\
    \    end\n    seen[s] = true\n    s = s + l[i]\n    i = i + 1\n  end\n  return\
    \ false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
