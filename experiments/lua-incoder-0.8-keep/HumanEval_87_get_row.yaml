name: HumanEval_87_get_row
language: lua
prompt: "-- You are given a 2 dimensional data, as a nested lists,\n-- which is similar\
  \ to matrix, however, unlike matrices,\n-- each row may contain a different number\
  \ of columns.\n-- Given lst, and integer x, find integers x in the list,\n-- and\
  \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n-- each tuple is a\
  \ coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by\
  \ rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending\
  \ order.\n-- Examples:\n-- get_row([\n-- [1,2,3,4,5,6],\n-- [1,2,3,4,1,6],\n-- [1,2,3,4,5,1]\n\
  -- ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- get_row([], 1) == []\n\
  -- get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlocal function get_row(lst, x)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n\
  \    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3,\
  \ 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1,\
  \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1,\
  \ 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4,\
  \ 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4,\
  \ 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4,\
  \ 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0},\
  \ {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({},\
  \ 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{},\
  \ {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if lst == nil or x == nil then\n        return nil\n    end", " \
    \ if lst[x] == nil then\n    error(\"element not found\")\n  end\n  local row\
    \ = { }\n  row[x] = lst[x]\n  for i = x, 1, -1 do\n    table.insert(row, lst[i])\n\
    \  end\n  table.sort(row, function(a, b) return a[2] < b[2] end)\n  table.sort(row,\
    \ function(a, b) return a[2] > b[2] end)\n  return row\nend", "    if lst[x] ==\
    \ nil then\n        return nil\n    end\n    local i = 1\n    local n = #lst\n\
    \    local tuples = {}\n    for i = 1,n do\n        local row = lst[x]\n     \
    \   local tuple = {}\n        for j = 1,#row do\n            tuple[j] = (i-1,\
    \ j-1)\n        end\n        tuples[i] = tuple\n        i = i + 1\n    end\n \
    \   return tuples\nend", "    local rows = {}\n    for index, row in ipairs(lst)\
    \ do\n        rows[#rows + 1] = { x = index, y = row }\n    end\n    table.sort(rows)\
    \ -- sort in ascending order\n    local row, row_length = 0, 1\n    local row_dict\
    \ = {}\n    for _, row2 in ipairs(rows) do\n        local row_dict = {}\n    \
    \    for i = row_length, row_length + row2.y do\n            row_dict[row2.x]\
    \ = true\n        end\n        row_length = row_length + row2.y\n        for _,\
    \ row3 in ipairs(rows) do\n            if row3.x == row and row3.y > row then\n\
    \                row3.y = row3.y - 1\n                break\n            elseif\
    \ row3.x == row and row3.y == row then\n                row3.x = row3.x + 1\n\
    \                row3.y = row2.y\n            else\n                row3.x = row3.x\
    \ + 1\n            end\n        end\n        table.insert(rows, { x = row, y =\
    \ row_length })\n    end\n    return rows\nend", "    local rows = {}\n    for\
    \ _, row in ipairs(lst) do\n        if x == 0 then\n            return rows\n\
    \        end", "\tlocal rows = {}\n\tfor i, row in ipairs(lst) do\n\t\tlocal row_sorted\
    \ = {}\n\t\tfor j, value in ipairs(row) do\n\t\t\tif value == x then\n\t\t\t\t\
    table.insert(row_sorted, {i, j})\n\t\t\tend\n\t\tend\n\t\ttable.sort(row_sorted,\
    \ function(a, b) return a[2] > b[2] end)\n\t\tfor _, val in ipairs(row_sorted)\
    \ do\n\t\t\ttable.insert(rows, {val = val, i = val[1], j = val[2]})\n\t\tend\n\
    \tend\n\ttable.sort(rows, function(a, b) return a.i > b.i end)\n\ttable.sort(rows,\
    \ function(a, b) return a.j > b.j end)\n\t\n\treturn rows\nend", "  if x == 0\
    \ or lst[x] == nil then\n    return nil\n  end\n  local ys = {}\n  for y, row\
    \ in pairs(lst) do\n    if y == x then\n      ys[1] = ys[1] or -1\n      ys[2]\
    \ = ys[2] or -1\n      local i = 1\n      for _, v in pairs(row) do\n        if\
    \ v == x then\n          ys[i] = ys[i] or -1\n        end\n        i = i + 1\n\
    \      end\n    end\n  end\n  table.sort(ys, function(a, b) return b - a end)\n\
    \  return ys\nend", "  local row = { }\n  local row_idx = 1\n  local row_num =\
    \ 0\n  local col_num = 0\n  local col_num_last_val = false\n  for i, v in ipairs(lst)\
    \ do\n    if col_num_last_val then\n      if v == col_num then\n        table.insert(row,\
    \ row_idx, row_num)\n      end\n    else\n      col_num = col_num + 1\n      col_num_last_val\
    \ = col_num\n    end\n    row_num = row_num + 1\n    row_idx = row_idx + 1\n \
    \ end\n  table.sort(row, function(a, b)\n    return b[1] - a[1]\n  end)\n  table.sort(row,\
    \ function(a, b)\n    return a[2] - b[2]\n  end)\n  local result = { (0, 0) }\n\
    \  local row_num = 1\n  for _, v in ipairs(row) do\n    table.insert(result, v[1],\
    \ row_num)\n    row_num = row_num + 1\n  end\n  return result\nend", "  local\
    \ num_columns = #lst[1]\n  local pairs = setmetatable({}, {__mode = 'k'})\n  local\
    \ i = 1\n  for _, row in ipairs(lst) do\n    local j = 1\n    for _, col in ipairs(row)\
    \ do\n      if j >= x then\n        break\n      end\n      local _pair\n    \
    \  if i > 1 then\n        local row_id = i - 1\n        local row_pairs = get_row(row_id,\
    \ num_columns)\n        if row_pairs then\n          for _pair, _ in pairs(row_pairs)\
    \ do\n            table.insert(pairs, {i, _pair})\n          end\n        end\n\
    \      end\n      table.insert(pairs, {i, j})\n      j = j + 1\n    end\n    i\
    \ = i + 1\n  end\n  table.sort(pairs, function(a, b)\n    return a[2] > b[2]\n\
    \  end)\n  table.sort(pairs, function(a, b)\n    return a[1] < b[1]\n  end)\n\
    \  return pairs\nend", "  local results = {}\n  local n = #lst\n  if x > n then\
    \ return end", "    local lst_y = {}\n    local lst_x = {}\n    for i, v in ipairs(lst)\
    \ do\n        for _, val in ipairs(v) do\n            lst_x[#lst_x+1] = val\n\
    \        end\n        lst_y[#lst_y+1] = i\n    end\n    table.sort(lst_x, function(a,\
    \ b) return a < b end)\n    table.sort(lst_y, function(a, b) return b < a end)\n\
    \    local row = lst_y[#lst_y]\n    local columns = {}\n    for i, v in ipairs(lst_x)\
    \ do\n        if v == x then columns[#columns+1] = i end\n    end\n    local x\
    \ = x - row\n    local lst = {}\n    for i, v in ipairs(lst_y) do\n        lst[#lst+#columns+2]\
    \ = {x=v+x, y=i+row}\n    end\n    table.sort(lst, function(a, b) return a.x <\
    \ b.x end)\n    for i, v in ipairs(lst) do table.insert(lst_y, v.y) end\n    return\
    \ lst_y\nend", "  -- sort coordinates in ascending order by the number of columns\
    \ in each row\n  table.sort(lst, function(a, b) return #a == #b end)\n  -- sort\
    \ coordinates of each row by columns in descending order\n  for i = #lst, 1, -1\
    \ do\n    local tmp = lst[i]\n    table.sort(tmp, function(a, b) return #a ==\
    \ #b end)\n    lst[i] = tmp\n  end", "  local row = {}\n  local index = 1\n  for\
    \ item in lst do\n    for _, v in pairs(item) do\n      if v == x then\n     \
    \   row[index] = index\n      end\n      index = index + 1\n    end\n  end\n \
    \ if #row == 0 then\n    return {}\n  end\n  table.sort(row, function(a, b) return\
    \ a[1] > b[1] end)\n  table.sort(row, function(a, b) return a[2] < b[2] end)\n\
    \  local results = {}\n  local index = 1\n  for _, value in ipairs(row) do\n \
    \   results[index] = (row[index], value)\n    index = index + 1\n  end\n  return\
    \ results\nend", "  -- Based on https://stackoverflow.com/questions/53830177/search-through-a-list-of-lists-for-multiple-values\n\
    \  -- Solution is similar to what \"get_column\" does.\n  -- Recall that lst =\
    \ [[1,2], [3,4], [5,6]].\n  -- The rows of lst are sorted in ascending order.\n\
    \  local coords = {}\n  for _, row in ipairs(lst) do\n    for _, coord in ipairs(row)\
    \ do\n      if coord == x then\n        table.insert(coords, {1, coord})\n   \
    \   end\n    end\n  end\n  table.sort(coords, function(a, b) return a[1] < b[1]\
    \ end)\n  table.sort(coords, function(a, b) return a[2] > b[2] end)\n  return\
    \ coords\nend", "    if not lst then\n        return nil\n    end", "  if #lst\
    \ == 0 then return {} end\n  local row = {}\n  for i = #lst, 1, -1 do\n    table.insert(row,\
    \ i)\n  end\n  table.sort(row, function(a, b)\n    return a < b\n  end)\n  table.sort(row,\
    \ function(a, b)\n    return a > b\n  end)\n  local ans = {}\n  for _, i in ipairs(row)\
    \ do\n    table.insert(ans, (i, lst[i]))\n  end\n  table.sort(ans, function(a,\
    \ b)\n    return a[1] < b[1]\n  end)\n  return ans\nend", "    local result =\
    \ {}\n    if lst[x] then\n        for i = 1, #lst[x] do\n            result[#result\
    \ + 1] = { i = i, x = lst[x][i] }\n        end\n    end\n    return table.sort(result,\
    \ function(a, b) return b.x > a.x end)\nend", "  if #lst == 0 then return {} end\n\
    \  if #lst == 1 then return { {0, 0} } end\n  local row = {}\n  for i = 1, #lst,\
    \ 1 do\n    local row = row\n    local j = i - 1\n    for k, v in pairs(lst) do\n\
    \      if j >= x and v > lst[j] then\n        row[j] = v\n        break\n    \
    \  else\n        j = j - 1\n      end\n    end\n  end\n  table.sort(row,\n   \
    \ function (k1, k2)\n      if k1 == k2 then return 0 end\n      if k1 > k2 then\
    \ return 1 end\n      return -1\n    end)\n  table.sort(row,\n    function (k1,\
    \ k2)\n      if k1 >= k2 then return 1 end\n      if k1 < k2 then return -1 end\n\
    \      return 0\n    end)\n  return row\nend", "  if #lst<=1\n  then return {}\n\
    \  end\n  local row_size = math.max(#lst[1], #lst[2])\n  local row = {}\n  local\
    \ row_coords = {}\n  for i=1,row_size do\n    local row = { row={} } -- to preserve\
    \ row ordering\n    row_coords[i] = {}\n    for j=1, #lst[i] do\n      row_coords[i][j]\
    \ = j\n      table.insert(row, lst[i][j])\n    end\n  end\n  table.sort(row_coords)\n\
    \  table.sort(row_coords, function(c1, c2) return c1[1] > c2[1] or c1[2] > c2[2]\
    \ end)\n  local row_coords_list = {}\n  for i=1,row_size do\n    row_coords_list[i]\
    \ = {}\n    for j=1, #row_coords[i] do\n      table.insert(row_coords_list[i],\
    \ {row_coords[i][j], i})\n    end\n  end\n  table.sort(row_coords_list, function(c1,\
    \ c2) return c1[1] < c2[1] or c1[2] < c2[2] end)\n  local result = {0, row_size}\n\
    \  for i=1,row_size do\n    local row_coords = row_coords_list[i]\n    local row_len\
    \ = #row_coords\n    local y = row_coords[1][1]\n    if y == row_len then\n  \
    \    table.insert(result, row_coords[1])\n      continue\n    end\n    for j=row_len-1,1,-1\
    \ do\n      local z = row_coords[j][1]\n      local a = result[y]\n      local\
    \ b = result[y+1]\n      local c = row_coords[j][1]\n      local d = result[c]\n\
    \      if a < z\n      and b > z\n      and c > z\n      and d < z then\n    \
    \    result[c] = d\n      else\n        table.insert(result, row_coords[j])\n\
    \      end\n    end\n  end\n  if #result < x then x = #result end\n  return result\n\
    end", "    local output = {}\n    for i, v in ipairs(lst) do\n        output[i]\
    \ = {}\n        for j = 1, x do\n            output[i][#output[i] + 1] = v\n \
    \       end\n    end\n    table.sort(output, function(a, b)\n        if a[1] <\
    \ b[1] then\n            return -1\n        else\n            return 1\n     \
    \   end\n    end)\n    table.sort(output, function(a, b)\n        if b[1] < a[1]\
    \ then\n            return -1\n        else\n            return 1\n        end\n\
    \    end)\n    return output\nend", "\tlocal rows = {}\n\tfor _, item in pairs(lst)\
    \ do\n\t\ttable.insert(rows, item)\n\tend\n\ttable.sort(rows, function(row1, row2)\n\
    \t\tlocal i1, j1 = unpack(row1)\n\t\tlocal i2, j2 = unpack(row2)\n\t\treturn j2\
    \ > j1\n\tend)\n\ttable.sort(rows, function(row1, row2)\n\t\tlocal i1, j1 = unpack(row1)\n\
    \t\tlocal i2, j2 = unpack(row2)\n\t\treturn i2 > i1\n\tend)\n\ttable.sort(rows,\
    \ function(row1, row2)\n\t\tlocal i1, j1 = unpack(row1)\n\t\tlocal i2, j2 = unpack(row2)\n\
    \t\treturn j1 < j2\n\tend)\n\tlocal result = {0, {0, 0}} -- Coordinates initially\
    \ by rows in ascending order.\n\tlocal row, i, col, j = unpack(rows[1])\n\tlocal\
    \ row1, row2 = unpack(rows[1])\n\tlocal row3, row4 = unpack(rows[3])\n\tlocal\
    \ col1, col2 = unpack(rows[1])\n\tlocal col3, col4 = unpack(rows[3])\n\tlocal\
    \ count1 = 0\n\tlocal count2 = 0\n\tfor i = 1, #rows do\n\t\tlocal count3 = 0\n\
    \t\tfor j = 1, #rows[i] do\n\t\t\tif rows[i][j] == x then\n\t\t\t\ttable.insert(result,\
    \ { i, j })\n\t\t\t\tcount3 = count3 + 1\n\t\t\tend\n\t\tend\n\t\tif count3 >\
    \ count1 then\n\t\t\tcount1 = count3\n\t\t\trow = i\n\t\tend\n\t\tlocal count4\
    \ = 0\n\t\tfor j = 1, #row2 do\n\t\t\tif row2[j] == x then\n\t\t\t\ttable.insert(result,\
    \ { row, j })\n\t\t\t\tcount4 = count4 + 1\n\t\t\tend\n\t\tend\n\t\tif count4\
    \ > count2 then\n\t\t\tcount2 = count4\n\t\t\tcol = j\n\t\tend\n\tend\n\ttable.sort(result,\
    \ function(row1, row2)\n\t\tlocal i1, j1 = unpack(row1)\n\t\tlocal i2, j2 = unpack(row2)\n\
    \t\treturn j2 < j1\n\tend)\n\ttable.sort(result, function(row1, row2)\n\t\tlocal\
    \ i1, j1 = unpack(row1)\n\t\tlocal i2, j2 = unpack(row2)\n\t\treturn i2 < i1\n\
    \tend)\n\ttable.sort(result, function(row1, row2)\n\t\tlocal i1, j1 = unpack(row1)\n\
    \t\tlocal i2, j2 = unpack(row2)\n\t\treturn j1 < j2\n\tend)\n\ttable.sort(result,\
    \ function(row1, row2)\n\t\t", "  local _len = #lst\n  local _i = 0\n  local row\
    \ = {}\n  local _max = 0\n  while _i < _len do\n    local _min = x + _i + 1\n\
    \    local _max = x + _len - 1\n    local _x = x + _i - 1\n    local _y = x +\
    \ _i\n    local _found = 0\n    for _ = _i, _len do\n      if lst[_] < x then\n\
    \        break\n      end\n      if lst[_] == x then\n        table.insert(row,\
    \ (_x, _y))\n        _found = 1\n        break\n      end\n      _x = _x + 1\n\
    \      _y = _y + 1\n    end\n    if not _found then\n      table.insert(row, (_x,\
    \ _y))\n    end\n    _i = x + _len + 1\n  end\n  table.sort(row, nil, nil, function(_,\
    \ _, a) return a > b end, false)\n  return row\nend", "  local row = {}\n  local\
    \ coord = {}\n  for i, v in ipairs(lst) do\n    table.insert(row, v)\n    table.insert(coord,\
    \ i, v)\n  end\n  table.sort(coord)\n  table.sort(row, function(a, b)\n    return\
    \ b > a\n  end)\n  local result = {{x = x + 1, y = coord[x]}} -- x+1\n  for i\
    \ = 1, table.getn(row) do\n    table.insert(result, coord[i])\n  end\n  return\
    \ result\nend", "\t-- Sorting coordinates in ascending order initially by rows\n\
    \t-- (this part is unrelated to the question, but is needed to be\n\t-- able to\
    \ compare coordinates in descending order)\n\ttable.sort(lst, function(a, b) \n\
    \t\treturn a.rows[a] < b.rows[a] \n\tend)", "  if type(lst) == 'table' then\n\
    \    lst = table.sort(lst, 'asc')\n  end\n  local rows, i, j, r, rc = {}, {},\
    \ {}, {}\n  for i = 1, #lst do\n    j = nil\n    for k = 1, #lst[i] do\n     \
    \ if j == nil then\n        j = k\n      else\n        j = math.max(j, k)\n  \
    \    end\n    end\n    if j == x then\n      for r = 1, #rows do\n        table.insert(rc,\
    \ i)\n        table.insert(r, i)\n      end\n      rows[i] = i\n    else\n   \
    \   table.insert(rc, i)\n      table.insert(rows, j)\n    end\n  end\n  table.sort(rc,\
    \ 'desc')\n  for i = 1, #rc do\n    for j = 1, #rows[i] do\n      table.insert(rc,\
    \ rows[i][j])\n    end\n  end\n  return rc\nend", "    local res = {}\n    local\
    \ n = #lst\n    for i = 1, n do\n        local row = lst[i]\n        if i == x\
    \ then\n            table.insert(res, i, row[1], reverse(row[2:]))\n        else\n\
    \            local row = lst[i]\n            table.insert(res, i, row[1], row[2])\n\
    \        end\n    end\n    table.sort(res, function(a, b)\n        return a[2]\
    \ < b[2]\n    end)\n    table.sort(res, function(a, b)\n        return b[2] >\
    \ a[2]\n    end)\n    return res\nend", "    local i = 1\n    local r = {}\n \
    \   while true do\n        table.insert(r, i, lst[i])\n        i += 1\n      \
    \  if i == x then\n            return r\n        end\n    end\nend", "  if x ==\
    \ nil then return [] end\n  local i, rows = 1, #lst\n  local coordinates = {}\n\
    \  for i = 1, rows do\n    local row = {}\n    for j = 1, #lst[i] do\n      if\
    \ lst[i][j] == x then\n        table.insert(row, i, j)\n      end\n    end\n \
    \   table.insert(coordinates, row)\n  end\n  table.sort(coordinates, function(a,\
    \ b) return a[2] > b[2] end)\n  table.sort(coordinates, function(a, b) return\
    \ a[1] < b[1] end)\n  return coordinates\nend", "  -- Sort the coordinates initially\
    \ by rows in ascending order.\n  -- (row, column), starting with 0\n  -- We first\
    \ sort by columns in descending order.\n  -- If the coordinates are not sorted\
    \ by columns, sort by rows instead.\n  return lst:gmap(function (row) -- For each\
    \ row in the given data.\n      return row:gmap(function (column) -- For each\
    \ column in the row.\n          return {x = column, y = row} -- Return the coordinates.\n\
    \      end):sort(function (first, second) -- We sort the coordinates.\n      \
    \    return second.y - first.y -- Sorting in descending order.\n      end):reverse()\
    \ -- We sort the coordinates in descending order.\n  end):sort(function (first,\
    \ second) -- We sort the rows initially by columns in descending order.\n    \
    \  return second.x - first.x -- Sorting in descending order.\n  end):reverse()\
    \ -- We sort the rows in descending order.\nend", "    if #lst == 0 then\n   \
    \     return nil\n    end", "  local row_idx = 1\n  local row = {}\n  for row_idx\
    \ = 1, #lst do\n    local row_elmt = lst[row_idx]\n    local row_elmt_len = #row_elmt\n\
    \    for column_idx = 1, row_elmt_len do\n      if row_elmt[column_idx] == x then\n\
    \        table.insert(row, row_idx, column_idx)\n        break\n      end\n  \
    \  end\n  end\n  table.sort(row, function(a, b)\n    return a[2] > b[2]\n  end)\n\
    \  table.sort(row, function(a, b)\n    return a[1] > b[1]\n  end)\n  return row\n\
    end", "  local rs = {}\n  for i = 1, #lst do\n    if x == lst[i][1] then\n   \
    \   rs[#rs+1] = { i, lst[i][#lst] }\n    end\n  end\n  table.sort(rs, function(a,\
    \ b) return a[2] > b[2] end)\n  return rs -- Returns a sorted list of coordinates\
    \ of row in ascending order\nend", "\t-- Return list of tuples, [(yx, xx)] where\
    \ yx is (x, y) coordinates\n\t-- and xx is (row, columns) coordinates.\n\t-- Sort\
    \ coordinates initially by rows in ascending order.\n\t-- Also, sort coordinates\
    \ of the row by columns in descending order.\n\t-- Args:\n\t--   lst (list of\
    \ lists of numbers): 2-dimensional data\n\t--   x (int): an integer to find in\
    \ the list\n\t--   y (optional): an integer to find in the row\n\t--   x (optional):\
    \ an integer to find in the row (used for sorting)\n\t--   y (optional): an integer\
    \ to find in the column (used for sorting)\n\t-- Returns:\n\t--   list of tuples\
    \ [(yx, xx)] where yx is (x, y) coordinates\n\t--   and xx is (row, columns) coordinates.\n\
    \tlocal row = {}\n\tlocal y = x\n\tif x ~= nil then\n\t\tfor yx = 0, #lst do\n\
    \t\t\tlocal y = lst[yx][y]\n\t\t\tif not row or y > row[1] then\n\t\t\t\trow[1]\
    \ = y\n\t\t\t\trow[2] = yx\n\t\t\tend\n\t\tend\n\tend", "  -- Check that the provided\
    \ list is valid and that x is valid.\n  assert(type(lst) == \"table\" and \"table\"\
    \ in lst and #lst > 0 and type(x) == \"number\" and x > 0 and x <= #lst)\n  --\
    \ Create a dictionary to map from each row index to the sorted coordinates.\n\
    \  local row_indices = {}\n  -- Create a dictionary to map from each column index\
    \ to the sorted coordinates.\n  local col_indices = {}\n  -- Create a dictionary\
    \ to map from each coordinate to its index.\n  local coord_index = {}\n  -- Iterate\
    \ over the number of rows and columns in the list.\n  for row_index = 0, #lst\
    \ do\n    -- Iterate over the number of columns in that row.\n    for col_index\
    \ = 0, lst[row_index]:size() do\n      -- Add the coordinate (x, y) to the dictionary.\
    \ Note: We need coordinates in descending order, so we sort in descending order.\n\
    \      table.insert(coord_index, {x = x, y = row_index})\n      -- Add the coordinates\
    \ (x, y) to the dictionary.\n      table.insert(row_indices, {x = row_index, y\
    \ = col_index})\n      -- Add the coordinates (x, y) to the dictionary.\n    \
    \  table.insert(col_indices, {x = col_index, y = row_index})\n    end\n  end\n\
    \  -- Sort the coordinates in descending order.\n  table.sort(coord_index, function(x,\
    \ y)\n    return x.y < y.y\n  end)\n  -- Sort the coordinates in ascending order.\n\
    \  table.sort(row_indices, function(x, y)\n    return x.y < y.y\n  end)\n  --\
    \ Sort the coordinates in ascending order.\n  table.sort(col_indices, function(x,\
    \ y)\n    return x.y < y.y\n  end)\n  -- Return the coordinates of the row.\n\
    \  local function get_row_index(index)\n    local coord = coord_index[index]\n\
    \    return coord.x, coord.y\n  end\n  return table.map(get_row_index, row_indices)\n\
    end", "  local rows = {}\n  local last_row\n  for i = 1, #lst do\n    if rows[i]\
    \ == nil then\n      rows[i] = {i = i, y = {}}\n    end\n    local y = rows[i].y\n\
    \    for j = 1, #lst[i] do\n      y[j] = y[j] or {row_index = i, col_index = j,\
    \ value = lst[i][j]}\n    end\n    last_row = i\n  end\n  table.sort(rows, function(a,\
    \ b) return a.i > b.i end)\n  table.sort(rows, function(a, b) return b.i > a.i\
    \ end)\n  local results = {}\n  for i, row in ipairs(rows) do\n    for j, value\
    \ in ipairs(row.y) do\n      if value.value == x then\n        results = {i, j,\
    \ x}\n      end\n    end\n  end\n  table.sort(results, function(a, b) return b.col_index\
    \ > a.col_index end)\n  return results\nend", "  local row = {x = -1}\n  for i\
    \ = 1, #lst do\n    if lst[i][1] == row then\n      if row[x] == nil then\n  \
    \      row[x] = i\n      else\n        local row = row\n        row[x]\n     \
    \   break\n      end\n    end\n  end\n  return row\nend", "   if #lst == 0 then\n\
    \      return {}\n   else\n      local row = {}\n      local n = #lst\n      for\
    \ i = 1, n do\n         if lst[i] ~= x then\n            table.insert(row, i)\n\
    \         end\n      end\n      return row\n   end\nend", "    local ans = {}\n\
    \    for i = 1, #lst do\n        table.insert(ans, (i, #lst))\n    end\n    table.sort(ans,\
    \ function(a, b)\n        if a[1] == x then\n            return b[2] > a[2] \n\
    \        end\n        return a[1] == x \n    end)\n    table.sort(ans, function(x,\
    \ y)\n        if x[1] < y[1] then\n            return false \n        end\n  \
    \      if x[1] > y[1] then\n            return true \n        end\n        return\
    \ x[2] > y[2] \n    end)\n    table.sort(ans, function(a, b)\n        if a[1]\
    \ < x then\n            return true \n        end\n        if a[1] > x then\n\
    \            return false \n        end\n        return b[2] < a[2] \n    end)\n\
    \    local tt = {}\n    for _, v in pairs(ans) do\n        table.insert(tt, v[1],\
    \ v[2])\n    end\n    return tt\nend", "  -- write your code here\nend", "   \
    \ local sorted_by_row = {}\n    local sorted_by_column = {}\n    local index =\
    \ 1\n    for _, row in ipairs(lst) do\n        local sorted_by_row[#sorted_by_row\
    \ + 1] = index\n        for _, cell in ipairs(row) do\n            sorted_by_column[#sorted_by_column\
    \ + 1] = index\n            index = index + 1\n        end\n    end", "    if\
    \ not lst or x ~= 0 then\n        return {}\n    end\n    local rows = {}\n  \
    \  local count = 0\n    local row = {}\n    for _, v in ipairs(lst) do\n     \
    \   for _, c in ipairs(v) do\n            if c == x then\n                table.insert(row,\
    \ count, v)\n                count = count + 1\n            end\n        end\n\
    \    end\n    table.sort(row, function(a, b) return b[2] < a[2] end)\n    table.sort(row,\
    \ function(a, b) return a[1] > b[1] end)\n    for i = #row, 1, -1 do\n       \
    \ table.insert(rows, {count = row[i][1], coord = row[i][2]})\n    end\n    return\
    \ rows\nend", "  if x == 1 then return lst[#lst] else return nil end\n  if x ~=\
    \ 1 then\n    local n = #lst\n    local res, i = nil, n\n    for i = 1, x do\n\
    \      res, i = res, {#lst[i + n]}\n    end\n    return res\n  end\n  return lst\n\
    end", "    local n = 0\n    local res = {}\n    local tmp = {}\n    for _, v in\
    \ ipairs(lst) do\n        table.insert(tmp, v)\n        table.insert(res, x)\n\
    \    end\n    for i = #tmp, 0, -1 do\n        if tmp[i] ~= nil then\n        \
    \    n = i + 1\n            break\n        end\n    end\n    for i = 1, n do\n\
    \        if res[i] ~= nil then\n            for j = #res, i, -1 do\n         \
    \       if res[j] ~= nil then\n                    res[j] = nil\n            \
    \        break\n                end\n            end\n        end\n    end\n \
    \   for i = 1, n do\n        if res[i] ~= nil then\n            for j = i, #res,\
    \ -1 do\n                if res[j] ~= nil then\n                    res[j] = nil\n\
    \                    break\n                end\n            end\n        end\n\
    \    end\n    return res\nend", "  assert(type(lst) == \"table\")\n  assert(lst:nrows()\
    \ > 0)\n  assert(type(lst:nfields() == number))\n  assert(type(x) == \"number\"\
    )", "  if #lst == 0 then\n    return nil\n  else\n    local rows = nil\n    local\
    \ i = 1\n    while i < #lst do\n      local rows = lst[i]\n      i = i + 1\n \
    \     if #rows == x then\n        break\n      end\n    end\n    if rows == nil\
    \ then\n      return nil\n    end\n    return rows\n  end\nend", "   if not lst[x]\
    \ then return {} end\n   local res = {}\n   for i = 1, #lst[x] do\n      table.insert(res,\
    \ ((#res) + 1, i))\n   end\n   table.sort(res)\n   table.sort(res, {function(x,\
    \ y) return y[#y] or #y < y[#x] end, function(x, y) return y[#y] or #y > y[#x]\
    \ end})\n   return res\nend", "   -- Write your code here\n   assert(lst, \"lst\"\
    )\n   assert(type(x) == \"number\", \"x\")\n   local ans = {}\n   local rv = setmetatable({},\
    \ { __index = function(_, k)\n      if k == x then\n         return ans\n    \
    \  else\n         local rv = { k = k }\n         if type(lst[k]) == \"table\"\
    \ then\n            local cols = unpack(lst[k])\n            for i = 1, #cols\
    \ do\n               local cx = i + 1\n               local rv = setmetatable(rv,\
    \ { __index = function(_, k2)\n                  if k2 == cx then\n          \
    \           return unpack(lst[k][cx])\n                  else\n              \
    \       return rv[k2]\n                  end\n               end})\n         \
    \   end\n         end\n         return rv\n      end\n   end})\n   return rv\n\
    end", "  local row = {}\n  for _, row in ipairs(lst) do\n    if row[#row] < x\
    \ then\n      table.insert(row, #row)\n    end\n  end\n  table.sort(row, function(a,\
    \ b)\n    return a[b]\n  end)\n  table.sort(row, function(a, b)\n    return b[#row]\n\
    \  end)\n  return row\nend", "  local rows = {}\n  local n = #lst", "  local rows\
    \ = {}\n  local xs = {}\n  for i, row in ipairs(lst) do\n    for j, cell in ipairs(row)\
    \ do\n      if cell == x then\n        table.insert(xs, i, j)\n      end\n   \
    \ end\n    table.insert(rows, #row + 1, xs)\n    xs = {}\n  end\n  return rows\n\
    end", "  local coords = {}\n  local tmp = {}\n  local rows = #lst\n  for i = 0,\
    \ rows do\n    if i == x then\n      tmp[i] = (i, i)\n    else\n      local tmp\
    \ = lst[i]\n      for j = 1, #tmp do\n        table.insert(coords, tmp[j])\n \
    \     end\n      table.sort(coords, function(a,b) return a[1] < b[1] end)\n  \
    \    table.sort(coords, function(a,b) return a[1] > b[1] end)\n    end\n  end\n\
    \  local coord\n  for _,coord in ipairs(coords) do\n    table.insert(coords[#coords][2],\
    \ coord[1])\n  end\n  return coords\nend", "  -- Find coordinate of element x\
    \ in lst\n  local row, col\n  for _,v in ipairs(lst) do\n    if v == x then\n\
    \      row = #lst\n      break\n    end\n  end\n  -- Find coordinate of last element\
    \ in row\n  local last_row\n  for _,v in ipairs(lst[row]) do\n    if v == x then\n\
    \      last_row = row\n      break\n    end\n  end\n  -- Sort coordinates of row\n\
    \  table.sort(lst[last_row], function(a, b) return b - a; end)\n  table.sort(lst[row],\
    \ function(a, b) return b - a; end)\n  return lst\nend", "   assert(#lst>=1)\n\
    \   assert(type(x)=='number')", "    local lst = lst or {}\n    local lst = lst\
    \ and lst:toList() or {}\n    local lst = lst and lst:sort()\n    local ret =\
    \ {}\n    for i = 1, #lst, 1 do\n        local x = lst[i]\n        local y = x\
    \ - 1\n        local row = { x, y }\n        for j = 2, #lst[i], 1 do\n      \
    \      local x_ = lst[i]\n            local y_ = x_ - 1\n            row = row\
    \ + ({ x_, y_ })\n        end\n        if #row > 1 then\n            table.insert(ret,\
    \ row)\n        end\n    end\n    table.sort(ret, function(a, b) return a[2] <\
    \ b[2] end)\n    return ret\nend", "  local row = {}\n  for i = 1, #lst do\n \
    \   table.insert(row, i)\n  end\n  table.sort(row, function(a, b)\n    return\
    \ table.getn(lst[a]) < table.getn(lst[b]) or (table.getn(lst[a]) == table.getn(lst[b])\
    \ and a < b)\n  end)\n  local col_sum = {}\n  local row_sum = {}\n  for i = 1,\
    \ #row do\n    table.insert(col_sum, 0)\n    table.insert(row_sum, 0)\n  end\n\
    \  for i = 1, #row do\n    local r = row[i]\n    for j = 1, #lst do\n      local\
    \ c = j\n      local val = table.getn(lst[c])\n      for k = 1, table.getn(r)\
    \ do\n        if val == table.getn(lst[c][k]) then\n          c = k\n        \
    \  val = table.getn(lst[c][k])\n        end\n      end\n      table.insert(col_sum,\
    \ col_sum[#col_sum] + val)\n      table.insert(row_sum, row_sum[#row_sum] + c)\n\
    \    end\n  end\n  local row2 = {}\n  for i = #row - 1, 1, -1 do\n    table.insert(row2,\
    \ i)\n  end\n  table.sort(row2, function(a, b)\n    return table.getn(col_sum[a])\
    \ < table.getn(col_sum[b]) or (table.getn(col_sum[a]) == table.getn(col_sum[b])\
    \ and a < b)\n  end)\n  local col_sum_2 = {}\n  local row_sum_2 = {}\n  for i\
    \ = #row2 - 1, 1, -1 do\n    table.insert(col_sum_2, 0)\n    table.insert(row_sum_2,\
    \ 0)\n  end\n  for i = #row2 - 1, 1, -1 do\n    local r = row2[i]\n    for j =\
    \ 1, #lst do\n      local c = j\n      local val = table.getn(lst[c])\n      for\
    \ k = 1, table.getn(r) do\n        if val == table.getn(lst[c][k]) then\n    \
    \      c = k\n          val = table.getn(lst[c][k])\n        end\n      end\n\
    \      table.insert(col_sum_2, col_sum_2[#col_sum_2] + val)\n      table.insert(row_sum_2,\
    \ row_sum_2[#row_sum_2] + c)\n    end\n  end\n  local ret = {}\n  for i = 1, #col_sum,\
    \ 2 do\n    ret[i] = {}\n    for j = 1, #row_sum do\n      table.insert(ret[i],\
    \ {row_sum[j] + i, col_sum[j] + col_sum_2[j] + row_sum_2[j] + 1})\n    end\n \
    \ end\n  return ret\nend", "    local new_lst = lst:clone()\n    local y = 0\n\
    \    local row = {}\n    for i = 1, #lst, 1 do\n        local new_row\n      \
    \  for j = 1, #lst[i], 1 do\n            if x == lst[i][j] then\n            \
    \    new_row = table.insert(row, (0, y))\n                break\n            end\n\
    \        end\n        y = y + 1\n        if y > #new_row then y = 1 end\n    \
    \    if y > #new_lst then y = 1 end\n        if y == 1 then\n            new_lst\
    \ = table.concat(new_lst, \"\\n\")\n        end\n        new_lst = table.concat(new_lst,\
    \ table.concat(new_row, \",\"))\n    end\n    return new_lst\nend", "    local\
    \ row = {}\n    for i = 1, #lst do\n        local element = lst[i]\n        for\
    \ j = 1, #element do\n            local num = element[j]\n            if num ==\
    \ x then\n                table.insert(row, i - 1)\n                table.insert(row,\
    \ j - 1)\n                break\n            end\n        end\n    end\n    table.sort(row,\
    \ 1, #row + 1, 1, function(x, y) return row[x] > row[y] end)\n    table.sort(row,\
    \ #row + 1, #row, 1, function(x, y) return row[x] > row[y] end)\n    return row\n\
    end", "  local rows = {}\n  for i = 1, #lst, 2 do\n    local row_x = lst[i]\n\
    \    local row_y = lst[i + 1]\n    if row_x == x then\n      table.insert(rows,\
    \ {i, row_y})\n    end\n  end\n  table.sort(rows, function(a, b)\n    return b[1].y\
    \ - a[1].y\n  end)\n  table.sort(rows, function(a, b)\n    return a[1].x - b[1].x\n\
    \  end)\n  table.sort(rows, function(a, b)\n    return a[1].x - b[1].x\n  end)\n\
    \  return rows\nend", "  local row = {}\n  for i = 0, #lst do\n    if lst[i][1]\
    \ >= x then\n      if i == #row then row = {} end\n      table.insert(row, i)\n\
    \    end\n  end\n  table.sort(row, function(a, b) return a[2] > b[2] end)\n  table.sort(row,\
    \ function(a, b) return a[2] < b[2] end)\n  return row\nend", "  local row = {}\n\
    \  for _, v in ipairs(lst) do\n    table.insert(row, v)\n  end\n  table.sort(row)",
  "\tlocal result = {}\n\tlocal row, col = 0, 0\n\twhile row < #lst do\n\t\tif row\
    \ = 0 then row = 1\n\t\t\twhile col < x do\n\t\t\t\tcol = 0\n\t\t\t\tresult =\
    \ {(row, col)}\n\t\t\t\trow = row + 1\n\t\t\tend\n\t\telseif row = #lst - 1 then\n\
    \t\t\twhile col < x do\n\t\t\t\tresult = {(row, col)}\n\t\t\t\tcol = col + 1\n\
    \t\t\tend\n\t\telse\n\t\t\twhile col < x do\n\t\t\t\tcol = col + 1\n\t\t\t\tresult\
    \ = {(row, col)}\n\t\t\tend\n\t\t\trow = row + 1\n\t\tend\n\tend\n\ttable.sort(result,\
    \ function(x, y) return x[1] <= y[1] end)\n\ttable.sort(result, function(x, y)\
    \ return y[2] > x[2] end)\n\ttable.sort(result, function(x, y) return x[1] > y[1]\
    \ end)\n\treturn result\nend", "  -- Your code here\n  -- Make sure the list has\
    \ x number of elements\n  assert(#lst[x] == 1, \"list must contain one row\")\n\
    \  -- Make a list of tuples [[(x, y), (x, y)], ...]\n  local row = {}\n  for i=1,\
    \ #lst do\n    -- Add each element in the row to lst, adding it to the list\n\
    \    -- while iterating across the row\n    table.insert(row, { x = i, y = lst[i]})\n\
    \  end\n  -- Now sort the row by its y values and descending order\n  table.sort(row,\
    \ function(a, b) return b.y - a.y end)\n  -- Then sort the column by its x values\
    \ and ascending order\n  table.sort(row, function(a, b) return a.x - b.x end)\n\
    \  -- Return the coordinate pairs\n  return row\nend", "  local ret = {}\n  for\
    \ _, row in ipairs(lst) do\n    local found = false\n    for _, value in ipairs(row)\
    \ do\n      if value == x then\n        table.insert(ret, table.unpack(row, 1,\
    \ table.maxn(row)))\n        found = true\n        break\n      end\n    end\n\
    \    if not found then\n      table.insert(ret, table.unpack(row, 1, table.maxn(row)))\n\
    \    end\n  end\n  table.sort(ret)\n  table.sort(ret, function(row, row2)\n  \
    \  local reverse = false\n    if #row > 1 then\n      if #row2 == 1 then\n   \
    \     reverse = row2[1] > row[1]\n      elseif #row2 == 2 then\n        if row2[1]\
    \ == row[1] then\n          reverse = row2[2] > row[2]\n        else\n       \
    \   reverse = row2[1] > row[1]\n        end\n      elseif #row2 == 3 then\n  \
    \      if row2[1] == row[1] then\n          if row2[2] == row[2] then\n      \
    \      reverse = row2[3] > row[3]\n          else\n            reverse = row2[2]\
    \ > row[2]\n          end\n        else\n          reverse = row2[1] > row[1]\n\
    \        end\n      end\n    end\n    return reverse\n  end)\n  return ret\nend",
  "  local row = {}\n  local row_start = 0\n  for index, item in pairs(lst) do\n \
    \   if item == x then\n      table.insert(row, row_start, index)\n      row_start\
    \ = index + 1\n    end\n  end\n  table.sort(row, function(a, b) return a < b end)\n\
    \  table.sort(row, function(a, b) return b < a end)\n  return row\nend", "  if\
    \ x == 0 then\n    return {}\n  elseif x > #lst or x < 0 then\n    return nil\n\
    \  end", "  local result = {}\n  for i = 1, #lst do\n    if i == x then\n    \
    \  local row = { i = x, j = #lst[i]-1 }\n      for j = 1, #lst[i] do\n       \
    \ table.insert(result, row)\n        table.insert(row, { i = i, j = j })\n   \
    \   end\n      table.sort(result, \"<>\")\n      break\n    end\n  end\n  if #result\
    \ == 0 then\n    local row = { i = x, j = #lst[x] }\n    table.insert(result,\
    \ row)\n  end\n  return result\nend", "    local rows = {}\n    for i, el in ipairs(lst)\
    \ do\n        table.insert(rows, (i + 1, el))\n    end\n    table.sort(rows, function(a,\
    \ b) return a[1] < b[1] end)\n    table.sort(rows, function(a, b) return a[2]\
    \ > b[2] end)\n    local result = {}\n    for i, row in ipairs(rows) do\n    \
    \    if i == x then\n            table.insert(result, (i + 1, row))\n        end\n\
    \    end\n    return result\nend", "  local result\n  for _, row in ipairs(lst)\
    \ do\n    for i = 1, #row do\n      if row[i] == x then\n        result = result\
    \ or {}\n        table.insert(result, { i, i - 1 })\n      end\n    end\n  end\n\
    \  return result or {}\nend", "  local result = {}\n  local row_sorted = sort_by_row(lst)\n\
    \  for i, row in ipairs(row_sorted) do\n    for j = 1, #row do\n      if row[j]\
    \ == x then\n        table.insert(result, { i, j })\n        break\n      end\n\
    \    end\n  end\n  return result\nend", "   assert(#lst > 0)\n   assert(x > 0)\n\
    \   local rows = { }\n   for i = 1, #lst do\n      local row_y = lst[i - 1]\n\
    \      local row_x = lst[i]\n      table.insert(rows, { i, (row_x + ((row_y -\
    \ row_x) / 2)) / 2 })\n   end\n   table.sort(rows, function(a, b) return b[1]\
    \ - a[1] end)\n   table.sort(rows, function(a, b) return b[2] - a[2] end)\n  \
    \ return rows[-1 - x]\nend", "  if lst[x] == nil then return {} end\n  local row\
    \ = {}\n  for i = 1, #lst[x] do\n    row.pairs = row.pairs or {}\n    table.insert(row.pairs,\
    \ {i, #lst[x] - 1})\n  end\n  table.sort(row.pairs, function(a, b)\n    return\
    \ a.second > b.second\n  end)\n  table.sort(row.pairs, function(a, b)\n    return\
    \ a.first > b.first\n  end)\n  return row\nend", "    local nrows = #lst\n   \
    \ local ncols = #lst[1]", "  local ret = {}\n  for i = 1, #lst, 1 do\n    local\
    \ tmp = {}\n    for j = 0, #lst[i - 1], 1 do\n      tmp[#tmp + 1] = (lst[i][j],\
    \ j)\n    end\n    table.sort(tmp, function(a, b)\n      return a[1] < b[1]\n\
    \    end)\n    if x == 1 then\n      ret[#ret + 1] = tmp\n    end\n  end\n  return\
    \ ret\nend", "  if x == 0 then\n    return {}\n  end\n  local row = {}\n  for\
    \ i = 1, #lst do\n    if i == x then\n      table.insert(row, i)\n    else\n \
    \     table.insert(row, get_row(lst, i - 1))\n    end\n  end\n  table.sort(row,\
    \ function(x, y)\n    if x > y then\n      return 1\n    else\n      return -1\n\
    \    end\n  end)\n  table.sort(row, function(x, y)\n    if x > y then\n      return\
    \ -1\n    else\n      return 1\n    end\n  end)\n  return row\nend", "  local\
    \ results = {}\n  for i = 0, #lst - 1 do\n    local x = lst[i]\n    if x[i] ==\
    \ x then\n      results[i] = x\n    elseif i > 1 then\n      results[i] = (i -\
    \ 1, i)\n    end\n  end\n  table.sort(results, function(a, b) return b[1] - a[1]\
    \ end)\n  return table.sort(results, function(a, b) return b[2] - a[2] end)\n\
    end", "\tlocal function comp(a, b)\n\t\treturn b - a\n\tend", "  local coords\
    \ = {}\n  for i, row in pairs(lst) do\n    local count = 0\n    for j, col in\
    \ pairs(row) do\n      if col == x then\n        count = count + 1\n      end\n\
    \    end\n    if count > 1 then\n      table.insert(coords, {i, count})\n    end\n\
    \  end\n  table.sort(coords, function(a, b) return a[2] > b[2] end)\n  table.sort(coords,\
    \ function(a, b) return a[1] > b[1] end)\n  return coords\nend", "  local rows\
    \ = { [0] = {} }\n  local cols = { [0] = {} }\n  for i, row in pairs(lst) do\n\
    \    table.insert(rows, i)\n    table.insert(cols, #row)\n  end\n  table.sort(rows)\n\
    \  table.sort(cols)\n  local coords = { [0] = {} }\n  for i, col in pairs(cols)\
    \ do\n    for j, row in pairs(rows) do\n      if row[j] == x then\n        table.insert(coords,\
    \ { row = i, col = j })\n      end\n    end\n  end\n  return coords\nend", " \
    \   if lst == nil then return nil end\n    if x == 0 then return 0 end", "   --\
    \ If no coordinates were found, or if coordinates of row are out of bounds,\n\
    \   -- return an empty list.\n   if x == nil or #lst[x] ~= 2 then\n      return\
    \ []\n   end", "   local row = {}\n   local n = 0\n   for _, row in ipairs(lst)\
    \ do\n      n = n + #row\n   end\n   if n == 0 then\n      return nil\n   end\n\
    \   local i = 0\n   local j = 0\n   local k = 0\n   while i < n do\n      if i\
    \ == x then\n         for j = k, n+k do\n            table.insert(row, j)\n  \
    \       end\n         return row\n      else\n         j = j + 1\n      end\n\
    \      k = j\n      i = i + 1\n   end\n   return nil\nend", "  -- If there are\
    \ less than two rows, return empty list.\n  assert(#lst >= 2, 'Invalid input,\
    \ lst must be at least 2 rows.')", "  -- Initialize rows and columns\n  local\
    \ rows, columns = {}, {}\n  for i = 1, #lst do\n    table.insert(rows, i)\n  \
    \  table.insert(columns, #lst[i])\n  end\n  table.sort(rows)\n  table.sort(columns)",
  "  local row = {}\n  for _, elem in ipairs(lst) do\n    table.insert(row, elem[x])\n\
    \  end\n  table.sort(row)\n  table.sort(row, function(a, b) return b > a end)\n\
    \  return row\nend", "   if lst == nil then return nil end\n   local res = {}\n\
    \   for i=1,#lst do\n      if i == x then\n         table.insert(res, {i,x})\n\
    \      else\n         local r = get_row(lst[i-1], x)\n         if r~=nil then\n\
    \            table.insert(res, r)\n         end\n      end\n   end\n   table.sort(res,\
    \ function(a, b) return a[1] > b[1] end)\n   table.sort(res, function(a, b) return\
    \ b[2] > a[2] end)\n   return res\nend", "  -- if there are no rows or columns\
    \ in the matrix, return empty list\n  if not lst[1] then\n    return nil\n  end",
  "    if x == nil then\n        error(\"get_row: x is nil\")\n    end\n    local\
    \ results = {}\n    local row = {}\n    local row_len = #lst\n    if row_len >\
    \ 0 then\n        table.insert(row, row_len - 1, nil)\n        table.insert(results,\
    \ 0, row)\n    end\n    local prev_row = row\n    for i = 2, row_len do\n    \
    \    if lst[i] == nil then\n            table.insert(results, i, nil)\n      \
    \      continue\n        end\n        if prev_row ~= nil then\n            local\
    \ prev_row_len = #prev_row\n            local row = nil\n            local rows\
    \ = {}\n            table.insert(rows, 0, prev_row)\n            for j = 1, prev_row_len\
    \ do\n                table.insert(rows, j, prev_row[j])\n            end\n  \
    \          table.insert(row, prev_row_len, rows)\n        end\n        prev_row\
    \ = lst[i]\n        if prev_row ~= nil then\n            local prev_row_len =\
    \ #prev_row\n            local row = nil\n            local rows = {}\n      \
    \      table.insert(rows, 0, prev_row)\n            for j = 1, prev_row_len do\n\
    \                table.insert(rows, j, prev_row[j])\n            end\n       \
    \     table.insert(row, prev_row_len, rows)\n        end\n    end\n    if row\
    \ ~= nil then\n        local row_len = #row\n        table.insert(results, row_len,\
    \ row)\n    end\n    table.sort(results, function(x, y) return y[1] < x[1] and\
    \ 1 or -1 end)\n    table.sort(results, function(x, y) return y[1] > x[1] and\
    \ 1 or -1 end)\n    table.sort(results, function(x, y) return y[2] < x[2] and\
    \ 1 or -1 end)\n    table.sort(results, function(x, y) return y[2] > x[2] and\
    \ 1 or -1 end)\n    return results\nend", "   if #lst == 0 then\n      return\
    \ nil\n   end", "    if not lst[x] then\n        error(\"index not found.\")\n\
    \    end", "  if x == 0 then\n    return {}\n  elseif #lst < x then\n    error(\"\
    Index out of range\")\n  else\n    local rows, columns, row_list, column_list\
    \ = {}, {}, {}, {}\n    for i = 1, #lst, x do\n      rows[#rows+1] = i\n    end\n\
    \    for i = 1, #lst, x do\n      local tmp_row, tmp_columns = {}, {}\n      for\
    \ j = 0, #lst[i] do\n        tmp_columns[#tmp_columns+1] = j\n      end\n    \
    \  row_list[#row_list+1] = (rows, tmp_row, tmp_columns)\n      columns[#columns+1]\
    \ = i\n    end\n    local row_index = {}\n    for i = 1, #rows do\n      row_index[#row_index+1]\
    \ = i\n    end\n    return table.sort(\n      table.sort(\n        table.sort(\n\
    \          table.sort(\n            row_list,\n            function(row_index,\
    \ row)\n              return row_index[row.row]\n            end),\n         \
    \ function(row_index, row)\n            return row_index[row.column]\n       \
    \   end),\n        function(row_index, row)\n          return row_index[row.row]\n\
    \        end),\n      function(row_index, row)\n        return row_index[row.column]\n\
    \      end)\n  end\nend", "  local row = {}\n  local row_sorted = {}\n  for i=1,\
    \ #lst do\n    for j=1, #lst[i] do\n      table.insert(row, { i, j })\n      table.insert(row_sorted,\
    \ { i, j })\n    end\n  end\n  table.sort(row_sorted)\n  local results = {}\n\
    \  for i=1, #row_sorted do\n    local c = row_sorted[i]\n    for j=1, #row do\n\
    \      if row[j].i == c then\n        table.insert(results, { row[j].j, x })\n\
    \        break\n      end\n    end\n  end\n  return results\nend", "  local row\
    \ = {}\n  for i=1, #lst, 1 do\n    table.insert(row, i)\n  end\n  table.sort(row,\
    \ function(a, b) return table.getn(lst[a]) <  table.getn(lst[b]) end)\n  table.sort(row,\
    \ function(a, b) return table.getn(lst[a]) >  table.getn(lst[b]) end)\n  table.sort(row,\
    \ function(a, b) return table.getn(lst[a][x]) < table.getn(lst[b][x]) end)\n \
    \ table.sort(row, function(a, b) return table.getn(lst[a][x]) > table.getn(lst[b][x])\
    \ end)\n  return row\nend", "    local row = {}\n    for i, x in ipairs(lst) do\n\
    \        row[i] = x[i]\n    end\n    table.sort(row, function(a, b) return a <\
    \ b end)\n    table.sort(row, function(a, b) return a > b end)\n    table.sort(row,\
    \ function(a, b) return a < b end)\n    return row\nend", "  local results = {}\n\
    \  local row_idx = 1\n  local column_idx = 1\n  local row, column = #lst, 1\n\
    \  local row_coords, column_coords = setmetatable({}, {__mode='k'})\n  while row\
    \ ~= 0 do\n    row_coords[row] = column_coords\n    column_coords = column_coords\
    \ + 1\n    row_idx = row_idx + 1\n    if row > x then\n      break\n    end\n\
    \    row = row - 1\n    column = column + 1\n  end\n  for i = row_idx do row_coords[i]\
    \ = column_coords end\n  table.sort(row_coords, function(lhs, rhs)\n    return\
    \ rhs - lhs\n  end)\n  for i = 1, row_idx do results[i] = row_coords[i] end\n\
    \  table.sort(column_coords, function(a, b) return a<b end)\n  for i = 1, column_idx\
    \ do results[row_idx+i] = column_coords[i] end\n  return results\nend", "  --\
    \ Sort the coordinates by rows in ascending order\n  local function sort(x, y)\n\
    \    if x > y then\n      return 1\n    elseif x < y then\n      return -1\n \
    \   end\n  end\n  table.sort(lst, sort)\n  -- Sort the coordinates of each row\
    \ by columns in descending order\n  for i = 0, #lst do\n    local row = lst[i]\n\
    \    table.sort(row, sort)\n  end\n  -- Find coordinates\n  local coordinates\
    \ = {}\n  for i = 0, #lst do\n    local row = lst[i]\n    local row_coordinates\
    \ = {}\n    -- Find coordinates\n    for j = 0, #row do\n      if row[j] == x\
    \ then\n        table.insert(row_coordinates, j)\n      end\n    end\n    -- Add\
    \ coordinates to coordinates\n    if #row_coordinates > 0 then\n      table.insert(coordinates,\
    \ row_coordinates)\n    end\n  end\n  return coordinates\nend", "    local rows,\
    \ cols = {}, {}\n    for _, row in ipairs(lst) do\n        cols[#cols + 1] = #row\n\
    \        for _, v in ipairs(row) do\n            if v == x then\n            \
    \    table.insert(rows, v)\n            end\n        end\n    end\n    table.sort(rows,\
    \ function(a, b) return a < b end)\n    table.sort(cols, function(a, b) return\
    \ b < a end)\n    local res = {}\n    for _, row in ipairs(rows) do\n        table.insert(res,\
    \ table.unpack(col, 2, table.unpack(row, 2, {})))\n    end\n    return res\nend",
  "  if #lst == 0 then return nil end\n  local rows = {}\n  for _, row in ipairs(lst)\
    \ do\n    local row_x = row[x]\n    local row_y = {}\n    for _, val in ipairs(row)\
    \ do\n      row_y[val] = row_y[val] or 0\n      row_y[val] = row_y[val] + 1\n\
    \    end\n    table.insert(rows, {x = row_x, y = row_y})\n  end\n  table.sort(rows,\
    \ function(a, b) return a.x < b.x end)\n  table.sort(rows, function(a, b) return\
    \ b.y < a.y end)\n  for _, _ in ipairs(rows) do\n    table.sort(rows[_].y, function(a,\
    \ b) return b.x < a.x end)\n  end\n  return rows\nend", "   local rows = { }\n\
    \   local i = 1\n   for k in pairs(lst) do\n      if k[x] ~= nil then\n      \
    \   table.insert(rows, (i, k[x]))\n      end\n      i = i + 1\n   end\n   table.sort(rows,\
    \ function(a, b)\n      return a[1] < b[1]\n   end)\n   table.sort(rows, function(a,\
    \ b)\n      return a[2] > b[2]\n   end)\n   return rows\nend", "  -- The data\
    \ you have been given is represented as a nested list of lists.\n  -- The first\
    \ element of the outer list is always the row number.\n  -- The rest of the elements\
    \ represent the row data, in order.\n  -- Your task is to return the coordinates\
    \ (x, y) of a given row\n  -- number, which matches the conditions of get_column().\n\
    \  -- You do not need to print anything, just return the coordinate list.\n  --\
    \ You can assume each row has the same number of columns.", "    local row = {}\n\
    \    for _, list in ipairs(lst) do\n        for i = 1, #list do\n            local\
    \ v = list[i]\n            if v == x then\n                table.insert(row, i)\n\
    \            end\n        end\n    end\n    table.sort(row, function(a, b)\n \
    \       if a > b then\n            return 1\n        elseif b > a then\n     \
    \       return -1\n        else\n            return 0\n        end\n    end)\n\
    \    table.sort(row, function(a, b)\n        if b > a then\n            return\
    \ 1\n        elseif a > b then\n            return -1\n        else\n        \
    \    return 0\n        end\n    end)\n    return row\nend", "   -- initialize\
    \ result\n   local res = {}\n   -- go over each row\n   for i, row in pairs(lst)\
    \ do\n      -- if current row has x number of elements\n      -- and the last\
    \ element of this row is x,\n      -- then add the result to the result\n    \
    \  if #row == x and row[x] == x then\n         table.insert(res, table.concat({i,\
    \ x}))\n      -- if current row has x number of elements\n      -- and the last\
    \ element of this row is not x,\n      -- then add the result to the result\n\
    \      elseif #row == x then\n         table.insert(res, table.concat({i, #row}))\n\
    \      -- if current row has x number of elements\n      -- and the last element\
    \ of this row is x,\n      -- but the previous element of this row is y \n   \
    \   -- and previous row does not contain y, \n      -- then add the result to\
    \ the result\n      elseif row[x] == x and row[i-1] ~= x then\n         table.insert(res,\
    \ table.concat({i, x}))\n      -- if current row has x number of elements\n  \
    \    -- and the last element of this row is not x,\n      -- but the previous\
    \ element of this row is y,\n      -- but the previous row does not contain y,\
    \ \n      -- then add the result to the result\n      elseif row[x] == x and row[i-1]\
    \ == y then\n         table.insert(res, table.concat({i, #row}))\n      elseif\
    \ row[x] == x then\n         table.insert(res, table.concat({i, #row}))\n    \
    \  end\n   end\n   table.sort(res)\n   table.sort(res, function(a, b)\n      return\
    \ a > b\n   end)\n   return res\nend", "  local num_cols_lst = table.remove(lst,\
    \ 1)\n  num_cols_lst = num_cols_lst and num_cols_lst[1] or 0\n  local coord_lst\
    \ = {}\n  for i = 1, #lst do\n    local row = lst[i]\n    local num_cols = len(row)\n\
    \    if num_cols > num_cols_lst then\n      local lst = row\n      row = row[1]\n\
    \      num_cols = len(lst)\n    end\n    for j = 1, num_cols do\n      local coord_row\
    \ = coord_lst\n      for c = 1, num_cols_lst do\n        coord_row = coord_row[c]\n\
    \      end\n      coord_row[num_cols_lst] = (x == num_cols) and j or (j, row)\n\
    \    end\n  end\n  return coord_lst\nend", '  if x == 0 then return nil end',
  "  local row = {}\n  for i = 0, #lst do\n    row[i] = lst[i]\n  end\n  table.sort(row,\
    \ function(a, b) return a[2] < b[2] end)\n  table.sort(row, function(a, b) return\
    \ b[2] < a[2] end)", "  local row = {}\n  for _, row in ipairs(lst) do\n    if\
    \ x == row[1] then\n      return row\n    end\n  end\nend", "  local row = {}\n\
    \  for i = 1, #lst do\n    table.insert(row, i)\n  end\n  table.sort(row, function(a,\
    \ b) return a[a] < b[b] end)\n  table.sort(row, function(a, b) return a[b] < b[a]\
    \ end)\n  return row[#row]:map(x, function(r) return (r, 0) end)\nend", "\tlocal\
    \ ret = {}\n\tfor i = 1, #lst, 1 do\n\t\tif i >= x then\n\t\t\ttable.insert(ret,\
    \ table.unpack(lst[i]))\n\t\tend\n\tend\n\treturn ret\nend", "  local rows = {\
    \ }\n  for _, row in ipairs(lst) do\n    local col = { }\n    for _, val in ipairs(row)\
    \ do\n      table.insert(col, val)\n    end\n    table.insert(rows, {\n      row\
    \ = row,\n      col = col,\n      val = x,\n      order = #row - 1,\n    })\n\
    \  end\n  table.sort(rows, function(a, b) return a.order < b.order end)\n  table.sort(rows,\
    \ function(a, b) return a.order > b.order end)\n  return rows\nend", "  -- Base\
    \ cases\n  if not (type(lst) == 'table') and #lst ~= x then return end\n  if not\
    \ (lst == []) then return lst, {0, 0}", "  -- There should be two elements, each\
    \ of which should be a list.\n  -- We assume that lst[0] is a list of rows, and\
    \ lst[1] is a list of columns.\n  local rows, cols = {}, {}\n  \n  for i, row\
    \ in ipairs(lst) do\n    local row_len = 0\n    local col_len = 0\n    \n    for\
    \ _, elem in ipairs(row) do\n      if elem == x then\n        table.insert(cols,\
    \ col_len)\n        table.insert(row_len, i)\n      end\n    end\n    \n    table.insert(rows,\
    \ row_len)\n  end\n  \n  return table.sort(table.concat(rows))\nend", "  assert(type(lst)\
    \ == \"table\" and type(x) == \"number\")\n  local row = { }\n  for _, row in\
    \ ipairs(lst) do\n    table.insert(row, { })\n    for _, val in ipairs(row) do\
    \ table.insert(val, x) end\n  end\n  table.sort(row, function(a, b) return a[1]\
    \ > b[1] end)\n  table.sort(row, function(a, b) return a[2] > b[2] end)\n  return\
    \ row\nend", "  local row = {}\n  for i = 1, #lst do \n    if i == x then break\
    \ end\n    table.insert(row, i)\n  end\n  table.sort(row)\n  table.sort(row, function(a,\
    \ b) return a > b end)\n  return row\nend", "    local tmp = {}\n    for i = 1,\
    \ #lst do\n        table.insert(tmp, i, lst[i][x])\n    end\n    table.sort(tmp,\
    \ function(a, b) return a[1] > b[1] end)\n    table.sort(tmp, function(a, b) return\
    \ a[2] > b[2] end)\n    return tmp\nend", "    local row = {}\n    for i, v in\
    \ ipairs(lst) do\n        if v == x then\n            table.insert(row, i)\n \
    \       end\n    end\n    return table.sort(row, 1, true)\nend", "  -- Base case\n\
    \  if lst[#lst]==nil then\n    return {}\n  end", "  -- base case\n  if x ~= 0\
    \ then\n    return nil\n  end", "  local rows = {}\n  local new_lst = lst\n  for\
    \ i = 0, #lst - 1 do\n    local row = i / x\n    local col = i % x\n    table.insert(rows,\
    \ {row = row, col = col, value = new_lst[i + 1]})\n  end\n  return rows\nend",
  "  local row = {}\n  local row_lengths = {}\n  local column_lengths = {}\n  for\
    \ i = 1, #lst do\n    local row_length = row_lengths[#row+1]\n    local column_length\
    \ = column_lengths[#column_lengths]\n    if i == x then\n      table.insert(row,\
    \ i)\n      table.insert(row, row_length)\n      table.insert(row, column_length)\n\
    \    end\n    table.insert(row_lengths, row_length)\n    table.insert(column_lengths,\
    \ column_length)\n  end\n  table.sort(row_lengths)\n  table.sort(column_lengths)\n\
    \  return row\nend", "  -- write your code here\n  if x == 0 then\n    return\
    \ nil\n  end\n  \n  local pairs = {}\n  for _, row in ipairs(lst) do\n    for\
    \ _, col in ipairs(row) do\n      if col == x then\n        table.insert(pairs,\
    \ {\n          row = row,\n          col = col\n        })\n      end\n    end\n\
    \  end\n  \n  table.sort(pairs, function(a, b)\n    local a_row = a.row\n    local\
    \ b_row = b.row\n    if a_row < b_row then\n      return true\n    elseif a_row\
    \ > b_row then\n      return false\n    else\n      return a.col < b.col\n   \
    \ end\n  end)\n  \n  table.sort(pairs, function(a, b)\n    local a_col = a.col\n\
    \    local b_col = b.col\n    if a_col < b_col then\n      return true\n    elseif\
    \ a_col > b_col then\n      return false\n    else\n      return a.row < b.row\n\
    \    end\n  end)\n  \n  return pairs\nend", "  if #lst < 1 then\n    return {}\n\
    \  end\n  local res = {}\n  for i = 1, #lst do\n    local row_elem = lst[i]\n\
    \    for j = 1, #row_elem do\n      if row_elem[j] == x then\n        table.insert(res,\
    \ i - 1, j)\n      end\n    end\n  end\n  table.sort(res, function(a, b) return\
    \ a[2] > b[2] end)\n  table.sort(res, function(a, b) return a[2] < b[2] end)\n\
    \  return res\nend", "  if x == 0 then return [] end\n  local row = {}\n  for\
    \ i = 1, #lst, 1 do\n    table.insert(row, i)\n  end\n  table.sort(row)\n  table.sort(row,\
    \ reverse)\n  local idx = 1\n  local coord_lst = {}\n  for _, row in ipairs(row)\
    \ do\n    local coord = table.insert{row = row, idx = idx}\n    table.insert(coord_lst,\
    \ coord)\n    idx = idx + 1\n  end\n  return coord_lst\nend", "  assert(x > 0)\n\
    \  local ret = {}\n  for i = 1, #lst do\n    local cur = lst[i]\n    if x == cur[#cur]\
    \ then\n      table.insert(ret, i, cur)\n    end\n  end\n  table.sort(ret, function(a,\
    \ b) return a[2] > b[2] end)\n  table.sort(ret, function(a, b) return a[2] > b[2]\
    \ and a[1] > b[1] end)\n  return ret\nend", "  -- assert(type(lst) == 'table'\
    \ and lst.nrows == 1)\n  -- assert(type(x) == 'number' and x >= 0 and x < lst.ncols)\n\
    \  -- assert(type(lst[x,1]) == 'table')", "  local n = 1\n  local m = 0\n  for\
    \ row in lst do\n    if n ~= 1 then\n      if n == x then return nil, n end\n\
    \      if m < n then m = n end\n    end\n    for _,v in pairs(row) do n = n +\
    \ 1 end\n  end\n  if n == x then return nil, n end\n  if m < n then m = n end\n\
    \  -- sort coordinates by rows\n  for i = 1, n do\n    local tmp = i - 1\n   \
    \ for row = lst, j = 1, m do\n      if i == j then\n        table.insert(row,\
    \ {i,i})\n      else\n        if tmp < j then\n          table.insert(row, {i,j})\n\
    \        else\n          table.insert(row, {j,i})\n        end\n      end\n  \
    \  end\n  end\n  -- sort coordinates by columns\n  for _,row in pairs(lst) do\n\
    \    local tmp = 1\n    for _,v in pairs(row) do tmp = tmp + v end\n    for _,v\
    \ in pairs(row) do row[v] = row[v] / tmp end\n  end\n  -- return coordinates sorted\
    \ (ascending, first by rows, then by columns)\n  local tmp = {}\n  for _,v in\
    \ pairs(lst) do tmp[v] = 1 end\n  for _,row in pairs(lst) do table.insert(tmp,\
    \ row) end\n  local res = {}\n  for i = 1, #tmp do table.insert(res, tmp[i]) end\n\
    \  return res\nend\n</cell>\n<code language=julia-0.5>\n@time x, y = get_row([\n\
    \  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1)\n</cell>\n<code language=julia-0.5>\n\
    @time x, y = get_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n\
    ], 3)\n</cell>\n<code language=julia-0.5>\n@time x, y = get_row([\n  [1,2,3,4,5,6],\n\
    \  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 10)\n</cell>\n<text>\nExercise 3\nCreate\
    \ a function which finds the number of integers in each row of a given 2D matrix.\
    \ \nFor example, the output should look like the following:", "  local function\
    \ compare(x, y) \n    return y <= x and x == y\n  end\n  \n  local function sort(x,\
    \ is_asc) \n    local function aux(x, is_asc) \n      local r = {}\n      local\
    \ t = x\n      repeat\n        table.insert(r, t)\n        local m = #t / 2\n\
    \        t[m], t[#t] = t[#t], t[m]\n      until #r > 0\n      for i = #r - 1,\
    \ 1, -1 do\n        local _, c = x[i]\n        x[i] = c\n      end\n      return\
    \ x, is_asc\n    end\n    return aux(x, is_asc)\n  end\n  \n  local function sort_by_row(lst,\
    \ is_asc) \n    local row = {}\n    local rows = []\n    local i = 1\n    for\
    \ _, lv in ipairs(lst) do \n      if #lv > i then \n        for j = 1, #lv do\
    \ \n          local v = lv[j]\n          table.insert(row, v)\n        end\n \
    \     else \n        table.insert(row, lv)\n      end\n      i = i + 1\n    end\n\
    \    table.sort(row, function(a, b) return is_asc and a<b end) \n    table.sort(row,\
    \ function(a, b) return not is_asc and a<b end) \n    for _, lv in ipairs(row)\
    \ do \n      table.insert(rows, {i, lv})\n    end\n    return rows\n  end\n  \n\
    \  return sort(sort_by_row(lst, false), true)\nend", "  -- base case\n  if x ==\
    \ 0 then\n    return nil\n  end", "   -- x is not necessarily a positive integer\
    \ as we are looking for\n   -- exact matches and sorting with negative values\
    \ is not allowed.\n   assert(x > 0 and x % 2 == 0)\n   local row = {}\n   for\
    \ i = 1, #lst do\n      local row = row\n      local cols = {}\n      for j =\
    \ 1, #lst[i] do\n         local v = lst[i][j]\n         if v == x then\n     \
    \       table.insert(row, i - 1)\n            table.insert(cols, j - 1)\n    \
    \        break\n         end\n         local v = v + 1\n         if v > x then\n\
    \            table.insert(row, i - 1)\n            table.insert(cols, j - 1)\n\
    \         else\n            table.insert(cols, j - 1)\n         end\n      end\n\
    \      if #cols > 0 then\n         table.sort(cols)\n         table.insert(row,\
    \ i - 1)\n      end\n   end\n   return row\nend", "  if lst[x] == nil then\n \
    \   return nil\n  end", "  local row = { }\n  for i, x in ipairs(lst) do\n   \
    \ row[i] = x[x:len() + 1]\n  end\n  table.sort(row, function(a, b) return a[1]\
    \ > b[1] end)\n  table.sort(row, function(a, b) return a[2] > b[2] end)\n  local\
    \ coords = { }\n  for i, x in ipairs(row) do\n    table.insert(coords, i - 1,\
    \ i)\n  end\n  table.sort(coords, function(a, b) return coords[b] < coords[a]\
    \ end)\n  table.sort(coords, function(a, b) return coords[b] < coords[a] end)\n\
    \  return coords\nend", "  if lst[x] then\n    local first = lst[x][1]\n    local\
    \ second = lst[x][2]\n    return { x = x, y = first > second and first or second\
    \ }\n  else\n    return {}\n  end\nend", "  local num_columns = #lst[1]\n  local\
    \ row = {}\n  for i = 1, num_columns do\n    table.insert(row, i)\n  end", " \
    \ local row = {}\n  for i = 0, #lst do\n    local c = lst[i]\n    local _, _,\
    \ r = unpack(c)\n    if r == x then\n      for j = 1, #c do\n        table.insert(row,\
    \ i - j)\n      end\n    end\n  end\n  return row\nend", "  if lst == nil or x\
    \ == nil then\n    return nil\n  end\n  -- Sort the coordinates in ascending order\n\
    \  local coord_lst = lst:clone()\n  coord_lst:sort(function(a, b)\n    return\
    \ a[1] > b[1]\n  end)\n  -- Sort the coordinates in descending order\n  coord_lst:sort(function(a,\
    \ b)\n    return a[1] < b[1]\n  end)\n  -- Find x coordinate in row with coordinates\
    \ in ascending order\n  for i = 1, #coord_lst do\n    if coord_lst[i][1] == x\
    \ then\n      return coord_lst[i]\n    end\n  end\n  return nil\nend", "  -- Base\
    \ case\n  if lst==nil or x==nil then return nil\n  elseif x == 1 then\n    return\
    \ lst\n  end", "    local row = {}\n    for i = 1, #lst do\n        local pos\
    \ = #row\n        for j = 1, #lst[i] do\n            table.insert(row, {pos, j})\n\
    \        end\n    end\n    table.sort(row, function(x, y) return x[1] < y[1] end)\n\
    \    table.sort(row, function(x, y) return x[1] > y[1] end)\n    local out = {}\n\
    \    for i, row in pairs(row) do\n        local col = {}\n        for j, value\
    \ in pairs(lst[row.r]) do\n            table.insert(col, value)\n        end\n\
    \        table.sort(col, function(x, y) return x[1] < y[1] end)\n        table.sort(col,\
    \ function(x, y) return x[1] > y[1] end)\n        table.insert(out, {row.r, col.r})\n\
    \    end\n    return out\nend", "  local row = {}\n  for i = 1, #lst, 2 do\n \
    \   if lst[i] < x then\n      table.insert(row, i - 1)\n    end\n  end\n  table.sort(row,\
    \ function(a,b) return math.sign(a) end)\n  table.sort(row, function(a,b) return\
    \ math.sign(b) end)\n  table.sort(row, function(a,b) return a < b end)\n  return\
    \ row\nend", "  local result = {}\n  for i = 0, #lst do -- iterate over rows\n\
    \    if #lst[i] > x then break end\n    table.insert(result, i)\n  end\n  for\
    \ i = #lst, 1, -1 do -- iterate over columns\n    if #lst[i-1] > x then break\
    \ end\n    table.insert(result, i)\n  end\n  table.sort(result)\n  return result\n\
    end", "    local rw = {}\n    for i = 0, #lst - 1 do\n        local row = lst[i]\n\
    \        local rc = {}\n        local is_in = false\n        for j = 0, #row -\
    \ 1 do\n            if row[j] == x then\n                table.insert(rc, {i,\
    \ j})\n                is_in = true\n                break\n            end\n\
    \        end\n        if not is_in then\n            table.insert(rw, {i, table.unpack(rc)})\n\
    \        end\n    end\n    table.sort(rw, function(a, b) return a[2] > b[2] end)\n\
    \    table.sort(rw, function(a, b) return a[1] > b[1] end)\n    return rw\nend",
  "    local rows, cols = {}, {}\n    local rows, cols = unpack(lst)\n    table.sort(rows,\
    \ function(a, b) return a < b end)\n    table.sort(cols, function(a, b) return\
    \ b > a end)", "   if not lst or x == nil or not x > 1 then\n      return nil\n\
    \   end\n   local row = {}\n   for i, row in ipairs(lst) do\n      local coords\
    \ = {}\n      local cur_row = row\n      for _, _ in ipairs(cur_row) do\n    \
    \     table.insert(coords, i)\n      end\n      table.sort(coords)\n      for\
    \ _, _ in ipairs(cur_row) do\n         table.insert(coords, -cur_row[_])\n   \
    \   end\n      table.sort(coords, function(a, b)\n         return b < a end\n\
    \      )\n      table.insert(row, coords)\n   end\n   table.sort(row)\n   return\
    \ row\nend", "    if x == nil then\n        return x\n    end\n    local row =\
    \ {}\n    for i = 1, #lst do\n        local elem = lst[i]\n        local ii =\
    \ i\n        while ii < #elem and elem[ii] == x do\n            ii = ii + 1\n\
    \        end\n        if ii < #elem then\n            table.insert(row, ii, elem[ii])\n\
    \        end\n    end\n    table.sort(row)\n    table.sort(row, function(a, b)\
    \ return b - a end)\n    return row\nend", "  if lst == nil then\n    lst = {\
    \ }\n  end\n  local row = { }\n  for i = 0, #lst do -- Populate row with coordinates\
    \ of each element in lst\n    if i == x then\n      table.insert(row, i)\n   \
    \ end\n  end\n  table.sort(row, function(a, b) return a[1] < b[1] end)\n  table.sort(row,\
    \ function(a, b) return b[2] < a[2] end)\n  return row\nend", "  if #lst == 0\
    \ then return nil, end\n  if x < 0 then return nil end\n  if lst[x] == nil then\
    \ return nil end\n  if #lst[x] == 0 then\n    return {}\n  end\n  local lst2 =\
    \ lst[x][#lst[x]][#lst[x][#lst[x]]-1]\n  -- Find smallest number of rows in other\
    \ rows\n  for i, row in pairs(lst) do\n    local r = 0\n    for k, v in pairs(row)\
    \ do\n      r = r + v\n    end\n    if r > lst2 and i > x then\n      lst2 = r\n\
    \    end\n  end\n  -- Sort rows by number of columns\n  for i, row in pairs(lst)\
    \ do\n    local c = 0\n    for k, v in pairs(row) do\n      c = c + (v / lst2)\n\
    \    end\n    lst[x][#lst[x]] = c\n    lst[x][#lst[x]][#lst[x][#lst[x]]] = i\n\
    \  end\n  -- Sort columns by decreasing number\n  local res = {}\n  for i, row\
    \ in pairs(lst) do\n    res[i] = {}\n    local j = 0\n    while j <= #row do\n\
    \      res[i][j] = row[j]\n      j = j + 1\n    end\n  end\n  table.sort(res)\n\
    \  return res\nend", "  local out = {}\n  for i, row in ipairs(lst) do\n    local\
    \ out1 = {}\n    for j, elem in ipairs(row) do\n      local out2 = {}\n      for\
    \ k, e in ipairs(elem) do\n        if e == x then\n          table.insert(out1,\
    \ {i, k})\n          table.insert(out2, {j, k})\n        end\n      end\n    end\n\
    \    table.sort(out2, function(a, b) return a[2] > b[2] end)\n    table.sort(out1,\
    \ function(a, b) return a[1] > b[1] end)\n    if #out1 == 0 then break end\n \
    \   table.insert(out, out1)\n  end\n  return out\nend", "  assert(#lst==0)\n \
    \ if #lst==0 then\n    return {}\n  end\n  if x==0 then\n    return {{x = 0, y\
    \ = #lst-1}}\n  end\n  local row = { x = 0, y = #lst-1 }\n  for i=1,#lst do\n\
    \    if lst[i]<=x then\n      row.y = i\n      break\n    end\n  end\n  table.insert(row,{\
    \ x = row.x, y = row.y - 1 })\n  table.insert(row,{ x = row.x - 1, y = row.y })\n\
    \  return row\nend", "  assert(#lst >= 1, 'Empty list given')\n  assert(type(x)\
    \ == 'number', 'Wrong parameter')\n  if x == 1 then\n    return lst\n  end\n \
    \ local lst2 = lst\n  local n = #lst\n  for i = 1, n do\n    local row = lst2[i]\n\
    \    if row[x] > 1 then\n      table.insert(lst2, table.copy(row))\n      table.insert(lst2[i][x],\
    \ 0)\n    end\n  end\n  local rows = {}\n  for i = 1, n do\n    local row = lst2[i]\n\
    \    for j = 1, #row do\n      table.insert(rows, {row = i, column = j})\n   \
    \ end\n  end\n  table.sort(rows, 'function(a, b) return a.row > b.row end')\n\
    \  table.sort(rows, 'function(a, b) return a.column > b.column end')\n  local\
    \ out = {}\n  for i = 1, n do\n    local row = lst2[i]\n    local outrow = {}\n\
    \    for j = 1, #row do\n      local index = rows[j].row\n      local k = rows[j].column\n\
    \      table.insert(outrow, lst[index][k])\n    end\n    table.insert(out, outrow)\n\
    \  end\n  return out\nend", "   local r = {}\n   local cnt = 1\n   for _, v in\
    \ ipairs(lst) do\n      if v == x then\n         r.push(cnt, v)\n         cnt\
    \ = cnt + 1\n      end\n   end\n   return r\nend", "   if #lst == 0 then\n   \
    \   return {}\n   end\n   local coord_table = {}\n   for i, row in ipairs(lst)\
    \ do\n      table.insert(coord_table, i)\n      table.insert(coord_table, #row\
    \ + 1 .. #row)\n   end\n   table.sort(coord_table, function(a, b) return coord_table[a]\
    \ < coord_table[b] end)\n   local coord_table2 = {}\n   for i, row in ipairs(coord_table)\
    \ do\n      table.insert(coord_table2, row)\n   end\n   table.sort(coord_table2,\
    \ function(a, b) return coord_table2[a][x] > coord_table2[b][x] end)\n   for i\
    \ = 1, #coord_table2 do\n      table.insert(coord_table2, coord_table2[i])\n \
    \  end\n   local new_coords = {}\n   for i, row in ipairs(coord_table2) do\n \
    \     table.insert(new_coords, (i + 1, 1))\n      table.insert(new_coords, (i\
    \ + 1, #row))\n   end\n   return new_coords\nend", "    local out = {}\n    for\
    \ i = #lst, 1, -1 do\n        local row = lst[i]\n        table.sort(row, function(a,\
    \ b) return a < b end)\n        table.sort(row, function(a, b) return b < a end)\n\
    \        for j = #row, 1, -1 do\n            table.insert(out, {i = i, j = (#row)\
    \ - j - 1, x = row[j]})\n        end\n    end\n    table.sort(out, function(a,\
    \ b) return a.i > b.i end)\n    table.sort(out, function(a, b) return a.j > b.j\
    \ end)\n    return out\nend", "  local row = nil\n  local new_coords = lst[1]\n\
    \  for i = 2, #lst do\n    local coords = lst[i]\n    if x == coords[#coords]\
    \ then\n      row = coords[#coords]:map(function(i) return i - 1 end)\n      break\n\
    \    end\n    new_coords = coords\n  end\n  if row == nil then\n    row = new_coords\n\
    \  end\n  return row\nend", "  -- Return empty list when list has no rows\n  if\
    \ not lst[#lst] then\n    return {}\n  end", "  if x==0 then return {} end\n \
    \ local row = {}\n  for i=1,#lst,1 do row[i] = lst[i] end\n  table.sort(row, function(a,b)\
    \ return a[1] < b[1] end)\n  table.sort(row, function(a,b) return a[2] > b[2]\
    \ end)\n  for i=1,#row do row[i] = row[i][1] end\n  table.sort(row, function(a,b)\
    \ return a[1] < b[1] end)\n  return row\nend", "  local row = {}\n  for i = 1,\
    \ #lst, 1 do\n    table.insert(row, i)\n  end\n  table.sort(row)\n  table.sort(row,\
    \ function(a, b) return #lst[a] > #lst[b] or #lst[a] < #lst[b] end)\n  table.sort(row,\
    \ function(a, b) return #lst[a][x] > #lst[b][x] or #lst[a][x] < #lst[b][x] end)\n\
    \  return row\nend", "  local results = {}\n  for i = 0, #lst - 1 do\n    local\
    \ row = lst[i]\n    local rowx = x + 1\n    local rc = {}\n    for j = 0, #row\
    \ - 1 do\n      local col = row[j]\n      table.insert(rc, (rowx - j + 1, col))\n\
    \    end\n    table.sort(rc)\n    table.sort(rc, function(a, b)\n      return\
    \ b[1] - a[1]\n    end)\n    table.insert(results, rc)\n  end\n  table.sort(results)\n\
    \  table.sort(results, function(a, b)\n    return b[1] - a[1]\n  end)\n  return\
    \ results\nend", "  if x==0 then return [] end\n  if lst[x] == nil then return\
    \ nil end\n  local r={}\n  for i=0,#lst[x] do\n    local r={}\n    for j=0,#r\
    \ do\n      r[j]={}\n      r[j][1]=i\n      r[j][2]=j\n    end\n    for j=0,#lst[x]\
    \ do\n      if lst[x][j] == i then\n        for k=0,#r do\n          r[k]={}\n\
    \          r[k][1]=k\n          r[k][2]=j\n        end\n      end\n    end\n \
    \   if #r > 0 then table.insert(r,{}) end\n  end\n  return r\nend", "   -- Initialize\
    \ row and col number\n   local r = 0\n   local c = 0", "    local row_x = {}\n\
    \    for _, row in ipairs(lst) do\n        local row_y = {}\n        for _, v\
    \ in ipairs(row) do\n            if v == x then\n                table.insert(row_x,\
    \ v)\n                table.insert(row_y, 0)\n            else\n             \
    \   table.insert(row_y, v)\n            end\n        end\n        table.sort(row_y)\n\
    \        table.sort(row_x, function(a, b) return a[2] < b[2] end)\n    end\n \
    \   table.sort(row_x)\n    return row_x\nend", "    local function sortby(lst,\
    \ f)\n        if #lst == 0 then\n            return\n        end\n        table.sort(lst,\
    \ function(a, b) return f(a) < f(b) end)\n        return lst\n    end\n    local\
    \ function descsort(lst, f)\n        if #lst == 0 then\n            return\n \
    \       end\n        table.sort(lst, function(a, b) return f(b) < f(a) end)\n\
    \        return lst\n    end\n    local function sort(lst, f)\n        if #lst\
    \ == 0 then\n            return\n        end\n        table.sort(lst, function(a,\
    \ b) return f(a) < f(b) end)\n        table.sort(lst, function(a, b) return f(a)\
    \ > f(b) end)\n        return lst\n    end\n    local function sort_rows(lst,\
    \ f)\n        local ret = {}\n        for i = 1, #lst, 1 do\n            table.insert(ret,\
    \ f(i, lst[i]))\n        end\n        return ret\n    end\n    local function\
    \ sort_cols(lst, f)\n        local ret = {}\n        for i = 1, #lst, 1 do\n \
    \           table.insert(ret, f(lst[i], i))\n        end\n        return ret\n\
    \    end\n    local function filter_b(lst, f)\n        local ret = {}\n      \
    \  for i = 1, #lst, 1 do\n            if f(i, lst[i]) then\n                table.insert(ret,\
    \ f(i, lst[i]))\n            end\n        end\n        return ret\n    end\n \
    \   local function filter_c(lst, f)\n        local ret = {}\n        for i = 1,\
    \ #lst, 1 do\n            if lst[i] == f(i, i) then\n                table.insert(ret,\
    \ f(i, i))\n            end\n        end\n        return ret\n    end\n    if\
    \ x == nil then\n        return nil\n    end\n    if #lst == 0 then\n        return\
    \ nil\n    end\n    if #lst[1] == 0 then\n        return nil\n    end\n    local\
    \ i = 1\n    local tmp = {}\n    while i < #lst do\n        local c = 0\n    \
    \    while c < #lst[1] do\n            if lst[i][c] == x then\n              \
    \  table.insert(tmp, i, c)\n            end\n            c = c + 1\n        end\n\
    \        i = i + 1\n    end\n    local ret = {}\n    local f\n    if #tmp > 0\
    \ then\n        f = sort\n    else\n        f = descsort\n    end\n    local tmp\
    \ = filter_b(tmp, f)\n    if #tmp > 0 then\n        f = sort_cols\n    else\n\
    \        f = sort_rows\n    end\n    tmp = filter_c(tmp, f)\n    for i = 1, #tmp\
    \ do\n        table.insert(ret, f(tmp[i]))\n    end\n    return ret\nend", " \
    \ -- Initialize empty list\n  local row = {}", "  local res = {}\n  for i = 1,\
    \ #lst do\n    local row = lst[i]\n    for j = 1, #row do\n      if row[j] ==\
    \ x then\n        table.insert(res, j)\n        break\n      end\n    end\n  end\n\
    \  table.sort(res, function(a, b) return a[1] > b[1] end)\n  table.sort(res, function(a,\
    \ b) return a[2] > b[2] end)\n  return res\nend", "  local rows = terralib.newlist()\n\
    \  local cols = terralib.newlist()\n  for i = 1, #lst do\n    local row = terralib.newlist()\n\
    \    local cnt = 0\n    for j = 1, #lst[i] do\n      if cnt == x then\n      \
    \  row:insert(i - 1)\n        cols:insert(j)\n      elseif cnt < x then\n    \
    \    row:insert(cnt)\n        cols:insert(j)\n      end\n      cnt = cnt + 1\n\
    \    end\n    if cnt < x then\n      row:insert(cnt)\n      cols:insert(#lst[i])\n\
    \    end\n    table.insert(rows, row)\n  end\n  return rows, cols\nend", "   \
    \ if x ~= math.abs(x) then\n        error(\"x must be a positive integer\")\n\
    \    end\n    local row_lst = table.remove(lst, 1)\n    local row_tuple = {}\n\
    \    for i, row in ipairs(row_lst) do\n        row_tuple[i] = {}\n        for\
    \ j, col in ipairs(row) do\n            row_tuple[i][j] = col\n        end\n \
    \   end\n    table.sort(row_tuple)\n    table.sort(row_tuple, function(a, b)\n\
    \        return b - a\n    end)\n    local res = {}\n    for i, row in ipairs(row_tuple)\
    \ do\n        table.insert(res, i, get_column(lst, row, x))\n    end\n    return\
    \ res\nend", "    if x==0 then\n        return nil\n    end\n    local res = {}\n\
    \    for i = 1, #lst, 1 do\n        local n = lst[i]\n        for j = 1, #n, 1\
    \ do\n            local m = n[j]\n            if m == x then\n               \
    \ table.insert(res, i, j)\n            end\n        end\n    end\n    table.sort(res,\
    \ function(i,j) return j>i end)\n    table.sort(res, function(i,j) return j[1]<i[1]\
    \ end)\n    return res\nend", "    local rows = {}\n    local i = 1\n    local\
    \ n = #lst\n    while i < n do\n        local j = i\n        while j < n and lst[i][j]\
    \ == x then\n            j = j + 1\n        end\n        if j > i then\n     \
    \       table.insert(rows, (i, j))\n        end\n        i = j\n    end\n    if\
    \ #rows == 0 then\n        return nil\n    end\n    table.sort(rows, function(a,\
    \ b) return a[1] <= b[1] end)\n    table.sort(rows, function(a, b) return a[2]\
    \ > b[2] end)\n    return rows\nend", "   -- write your code here\n   if lst[x]\
    \ == nil then\n      return nil\n   end\n   local rows = #lst\n   local result\
    \ = {}\n   local row_xs = {}\n   for i = 1, rows do\n      if i <= x then\n  \
    \       local row_x = i\n         for j = 1, #lst[i - 1] - 1 do\n            table.insert(row_xs,\
    \ {row_x, j})\n         end\n      else\n         local row_x = i - 1\n      \
    \   for j = 1, #lst[i - 1] - 1 do\n            table.insert(row_xs, {row_x, j})\n\
    \         end\n      end\n   end\n   table.sort(row_xs)\n   for _, row_x in pairs(row_xs)\
    \ do\n      table.insert(result, row_x:reverse())\n   end\n   return result\n\
    end", "  if x ~= 0 then\n    assert(x > 0, 'x must be positive')\n  end", "  if\
    \ lst[x] == nil then\n    return nil\n  end\n  local y = 0\n  local row = {}\n\
    \  while x ~= nil do\n    local n = #lst[x]\n    row[y+1] = y\n    for i = 1,\
    \ n do\n      if lst[x][x] == i then\n        x = nil\n      else\n        x =\
    \ lst[x][x]\n      end\n    end\n    y = y + 1\n  end\n  return row\nend", " \
    \ if x > #lst then return nil end\n  local res = {}\n  local i, j = 0, 1\n  while\
    \ j < x:\n    res[i] = {}\n    for _, v in ipairs(lst[i]) do\n      res[i][j]\
    \ = v\n      j = j + 1\n    end\n    i = i + 1\n  end\n  return res\nend", " \
    \   local row = {}\n    for i = 1, #lst do\n        local y = lst[i - 1][x]\n\
    \        local row = setmetatable({ _=y }, row) or row\n    end\n    return row\n\
    end", "  if lst[x] == nil then\n    return nil\n  else\n    return lst[x]:reverse()\n\
    \  end\nend", "\t-- initialize rows\n\tlocal rows = {}\n\t-- iterate rows\n\t\
    for i, row in ipairs(lst) do\n\t\t-- initialize columns\n\t\tlocal columns = {}\n\
    \t\t-- iterate columns\n\t\tfor j, col in ipairs(row) do\n\t\t\t-- initialize\
    \ coordinates\n\t\t\tlocal coordinate = (i, j)\n\t\t\t-- check coordinate\n\t\t\
    \tif coordinate[1] == x then\n\t\t\t\t-- append coordinate to columns\n\t\t\t\t\
    table.insert(columns, coordinate)\n\t\t\t\t-- append coordinate to rows\n\t\t\t\
    \tif #rows > 0 then\n\t\t\t\t\ttable.insert(rows, coordinate)\n\t\t\t\telse\n\t\
    \t\t\t\ttable.insert(rows, {coordinate})\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\
    -- sort columns\n\t\ttable.sort(columns, function(pair1, pair2)\n\t\t\treturn\
    \ pair2[1] - pair1[1]\n\t\tend)\n\t\t-- sort rows\n\t\ttable.sort(rows, function(pair1,\
    \ pair2)\n\t\t\treturn pair2[2] - pair1[2]\n\t\tend)\n\tend\n\t-- sort coordinates\n\
    \ttable.sort(rows, function(pair1, pair2)\n\t\treturn pair2[1] - pair1[1]\n\t\
    end)\n\t-- return coordinates\n\treturn rows\nend", "    local results = {}\n\
    \    local index = 0\n    local n = #lst\n    while index < n do\n        local\
    \ row = get_row(lst[index], x) - 1\n        table.insert(results, row)\n     \
    \   index = index + 1\n    end\n    table.sort(results)\n    return results\n\
    end", "    if not lst or x == 0 then\n        return {}\n    end\n    if x < 0\
    \ or x >= #lst then\n        error()\n    end\n    local res = {}\n    for i =\
    \ 1, #lst, 1 do\n        local row = lst[i]\n        if row[x] == x then\n   \
    \         table.insert(res, i)\n        end\n    end\n    table.sort(res, function(a,\
    \ b) return a[1] - b[1] end)\n    table.sort(res, function(a, b) return b[2] -\
    \ a[2] end)\n    return res\nend", "  if not lst or #lst == 0 then\n    return\
    \ []\n  end\n  local row_sizes = {}\n  for _, row in ipairs(lst) do\n    row_sizes[#row_sizes\
    \ + 1] = #row\n  end\n  row_sizes[#row_sizes + 1] = 1\n  for _, row in ipairs(lst)\
    \ do\n    table.sort(row, function(a, b) return a < b end)\n    table.sort(row,\
    \ function(a, b) return b < a end)\n  end\n  local coords = {}\n  for row = 1,\
    \ #lst do\n    local row_coords = {}\n    for _, rw in ipairs(row_sizes) do\n\
    \      local col_coords = {}\n      for _, cw in ipairs(row) do\n        local\
    \ coord = { row, rw }\n        if cw == x then\n          table.insert(col_coords,\
    \ coord)\n        end\n      end\n      table.sort(col_coords, function(a, b)\
    \ return a.row < b.row end)\n      table.sort(col_coords, function(a, b) return\
    \ b.row < a.row end)\n      table.insert(row_coords, col_coords)\n    end\n  \
    \  table.sort(row_coords, function(a, b) return a.rw < b.rw end)\n    table.sort(row_coords,\
    \ function(a, b) return b.rw < a.rw end)\n    table.insert(coords, row_coords)\n\
    \  end\n  return coords\nend", "  if x == 0 then\n    return lst\n  end", "  \
    \ if x > #lst or x < 1 then\n      return {x = nil, y = nil}\n   end\n   local\
    \ lst = lst[1]\n   local res = {}\n   local i = 1\n   for _, v in ipairs(lst)\
    \ do\n      if i == x then\n         return {x = i, y = #v}\n      else\n    \
    \     i = i + 1\n         res[#res+1] = {x = i, y = v}\n      end\n   end\n  \
    \ return res\nend", "  local out = {}\n  for i = 1, #lst do\n    if i == x then\n\
    \      table.insert(out, {i, x})\n    end\n  end\n  table.sort(out, function(a,\
    \ b) return a.i < b.i end)\n  table.sort(out, function(a, b) return a.c > b.c\
    \ end)\n  return out\nend", "   local rows = { }\n   local cols\n   for row in\
    \ lst, cols = row, 1, #row do\n      local columns =\n         { [col - 1] for\
    \ col = 1, #row }\n      table.sort(columns)\n      table.sort(rows, function(a,\
    \ b) return a[2] < b[2] end)\n      if x >= rows[1][2] and x <= rows[2][2] then\n\
    \         return { row = rows[1], columns = columns }\n      elseif x == rows[2][2]\
    \ then\n         return { row = rows[2], columns = columns }\n      end\n   end\n\
    end\n</cell>\n<text>\nNext, define a function that will calculate the distance\
    \ between two points.\nNote that we will only use the following formulas to calculate\
    \ the distance:", "  local row = {}\n  local row, sorted_row_by_columns = sort_row(row,\
    \ 0, lst, x)\n  local result = {()}\n  for i = 1, #row do\n    local columns =\
    \ {}\n    local columns, sorted_column_by_columns = sort_column(columns, i, lst,\
    \ x, row[i])\n    table.insert(result, { row[i], columns })\n  end\n  return result\n\
    end", "    local rows = #lst\n    local cols = 1\n    local result = {}\n    for\
    \ i = 1, rows do\n        table.insert(result, { x = i, y = cols })\n        cols\
    \ = cols + lst[i][x] or 1\n    end\n    table.sort(result)\n    return unpack(result)\n\
    end", "    local row = {}\n    local last_index = #lst\n    for i = 1, #lst do\n\
    \        if i == x then\n            row[i] = i\n        end\n        if i ~=\
    \ x then\n            local index = i - 1\n            while index > 0 do\n  \
    \              local row_id = last_index - (index - 1)\n                local\
    \ row_value = lst[row_id]\n                row[#row + 1] = row_value .. '-' ..\
    \ row_id\n                if row_value == x then\n                    return row\n\
    \                end\n                index = index - 1\n            end\n   \
    \     end\n    end\nend", "  local rows = {}\n  for _, row in ipairs(lst) do\n\
    \    table.insert(rows, {row = row, columns = {}})\n  end\n  table.sort(rows,\
    \ function(a, b)\n    local are_same = true\n    for i = 1, #a.row do\n      if\
    \ a.row[i] ~= b.row[i] then\n        are_same = false\n        break\n      end\n\
    \    end\n    return are_same\n  end)\n  table.sort(rows, function(a, b)\n   \
    \ local are_same = true\n    for i = #a.columns, 1, -1 do\n      if a.columns[i]\
    \ ~= b.columns[i] then\n        are_same = false\n        break\n      end\n \
    \   end\n    return are_same\n  end)\n  local res = {}\n  for _, row in ipairs(rows)\
    \ do\n    if row.row[x] then\n      table.insert(res, row.row)\n      table.insert(res,\
    \ row.row)\n    end\n  end\n  return res\nend", "  local function cmp(x, y)\n\
    \    if x > y then return 1 end\n    if x < y then return -1 end\n    return 0\n\
    \  end", "   if not lst then\n      return nil\n   elseif lst[x] then\n      local\
    \ r = [(0,0)]\n      for i=#lst+1, x, -1 do\n         table.insert(r, (i-1, lst[i]))\n\
    \      end\n      return r\n   else\n      return nil\n   end\nend", "  local\
    \ row = {}\n  local index = 0\n  for _, vlist in pairs(lst) do\n    if index ==\
    \ x then\n      table.insert(row, vlist)\n    else\n      index = 0\n    end\n\
    \    index = index + 1\n  end\n  return row\nend", "    local row = {}\n    for\
    \ _, v in ipairs(lst) do\n        table.insert(row, v)\n    end\n    table.sort(row,\
    \ function(a,b) return a<b end)\n    table.sort(row, function(a,b) return a>b\
    \ end)\n    return table.remove(row, x)\nend", "  local row = {}\n  for _, val\
    \ in ipairs(lst) do\n    if #val == x then\n      for i, v in ipairs(val) do\n\
    \        row[i] = v\n      end\n    end\n  end\n  return row\nend", "  if #lst==0\
    \ then\n    return {}\n  end\n  \n  local ret = {}\n  for i=0,#lst-1 do\n    for\
    \ j=0,#lst[i] do\n      if x == lst[i][j] then\n        for k=0,#ret do\n    \
    \      if ret[k] and ret[k][1] <= j then\n            table.insert(ret, ret[k])\n\
    \          end\n        end\n        table.insert(ret, (i,j))\n        break\n\
    \      end\n    end\n  end\n  \n  table.sort(ret)\n  for i=1,#ret do\n    table.insert(ret,\
    \ ret[i])\n  end\n  \n  table.sort(ret, function(a,b) return a[1] > b[1] end)\n\
    \  \n  return ret\nend", "   if not lst then return nil end\n   local sorted_coords\
    \ = { }\n   for _, v in ipairs(lst) do\n      table.insert(sorted_coords, #sorted_coords\
    \ + 1)\n      for _, w in ipairs(v) do\n         if w == x then\n            table.insert(sorted_coords,\
    \ {x = x, y = #sorted_coords + 1})\n         end\n      end\n   end\n   table.sort(sorted_coords,\
    \ function(a, b)\n      local is_col = (b.x < a.x)\n      local is_row = (a.y\
    \ < b.y)\n      if is_row ~= is_col then\n         return is_row\n      else\n\
    \         return a.x < b.x\n      end\n   end)\n   return sorted_coords\nend",
  "  if x == 1 then\n    return lst.sort()\n  else\n    -- We need to generate new\
    \ list each time we call get_row\n    local row_lst = {}\n    for _, r in pairs(lst)\
    \ do\n      row_lst[#row_lst + 1] = r\n    end\n    -- Sort rows by columns\n\
    \    local row_lst_sorted = row_lst.sort()\n    -- Sort rows by columns, in descending\
    \ order\n    local row_lst_sorted = row_lst_sorted:reverse()\n    -- Get rows\
    \ by columns\n    return row_lst_sorted:map(function(c)\n      return unpack(c,\
    \ 1)\n    end)\n  end\nend\n</cell>\n<cell>", "   local ans = {}\n   for i = 1,\
    \ #lst do\n      local row = lst[i]\n      local row_x = row[x]\n      \n    \
    \  for j = #row, 1, -1 do\n         local row_y = row[j]\n         \n        \
    \ if row_x == row_y then\n            table.insert(ans, {i, j })\n         else\n\
    \            break\n         end\n      end\n   end\n   table.sort(ans, function(a,\
    \ b) return a[1] < b[1] end)\n   return ans\nend", "  if not lst or x == nil then\n\
    \    return nil\n  end\n  local nrow = #lst\n  local ncol = lst[1]\n  local res\
    \ = {}\n  for i = 1, nrow do\n    local row = get_row(lst[i], x)\n    if row ~=\
    \ nil then\n      for j = 1, ncol do\n        res[(i-1) * ncol + j] = (row[j],\
    \ i)\n      end\n    end\n  end\n  if #res == 0 then\n    return nil\n  end\n\
    \  table.sort(res, function(a, b)\n    if b[1] == a[1] then\n      return b[2]\
    \ > a[2]\n    else\n      return a[1] > b[1]\n    end\n  end)\n  return res\n\
    end", "    local row = {}\n    for i, v in pairs(lst) do\n        if v == x then\n\
    \            table.insert(row, i)\n        end\n    end\n    table.sort(row, function(a,\
    \ b) return b < a end)\n    table.sort(row, function(a, b) return b > a end)\n\
    \    return row\nend", "  -- Base Case\n  if type(x) == 'number' and x == 1 then\n\
    \    return lst\n  end\n  -- Recursive Case\n  if x ~= 1 then\n    lst = lst[#lst]\n\
    \    return get_row(lst, (x - 1))\n  end\n  -- Sorting\n  local sorted_row = {}\n\
    \  for i = 1, #lst do\n    table.insert(sorted_row, table.unpack(lst[i]))\n  end\n\
    \  table.sort(sorted_row, function(a, b) return a[1] > b[1] end)\n  -- Column\
    \ sorting is done in descending order\n  table.sort(sorted_row, function(a, b)\
    \ return b[2] > a[2] end)\n  -- Row sorting is done in ascending order\n  table.sort(sorted_row,\
    \ function(a, b) return a[3] < b[3] end)\n  return sorted_row\nend", "  local\
    \ rows = {}\n  for i = 1, #lst do\n    for j = 1, #lst[i] do\n      rows[i] =\
    \ rows[i] or (0, lst[i][j])\n    end\n  end\n  table.sort(rows, function(a, b)\
    \ return a[1] < b[1] end)\n  table.sort(rows, function(a, b) return a[2] > b[2]\
    \ end)\n  local results = {}\n  for i = 1, #rows do\n    local r = rows[i]\n \
    \   if r[1] == x then\n      results[i] = r\n    end\n  end\n  return results\n\
    end", "  if lst == nil then return nil end\n  local i, j = #lst, x\n  if j > 0\
    \ then\n    local row_lst = {}\n    for row = i, 1, -1 do\n      local row_lst\
    \ = lst.sub(1, row).sub(i, j)\n      row_lst = sort_row_by_columns(row_lst)\n\
    \      row_lst = sort_by_rows(row_lst, j)\n      for col = 1, j do\n        local\
    \ value = row_lst[col][1]\n        row_lst[col] = (value[1], col)\n      end\n\
    \    end\n    return row_lst\n  end\n  return nil\nend", "  local rows = {}\n\
    \  for _, lst in ipairs(lst) do\n    table.insert(rows, {x = x, y = x})\n  end\n\
    \  table.sort(rows, function(a, b)\n    if a.x < b.x then\n      return true\n\
    \    else\n      return false\n    end\n  end)\n  table.sort(rows, function(a,\
    \ b)\n    if a.y < b.y then\n      return true\n    else\n      return false\n\
    \    end\n  end)\n  for _,i in ipairs(rows) do\n    local j = i - 1\n    local\
    \ k = i + 1\n    while j <= k do\n      if rows[j].x > rows[k].x then\n      \
    \  break\n      end\n      table.insert(rows, {x = rows[j].x, y = rows[k].y})\n\
    \      j = j + 1\n      k = k + 1\n    end\n  end\n  return rows\nend", "   --\
    \ base case\n   if #lst == 0 then\n      return {}\n   end", "    local row =\
    \ { x = x }\n    local sorted = {}\n    for _, v in pairs(lst) do\n        for\
    \ j = 1, #v do\n            if v[j] == x then\n                table.insert(sorted,\
    \ { j = j, i = #v-1 })\n                break\n            end\n        end\n\
    \    end\n    for _, v in pairs(sorted) do\n        row = {\n            row.i\
    \ = v.i,\n            row.x = row[row.x] + 1,\n        }\n    end\n    return\
    \ row\nend", "  if #lst == 0 then return nil end\n  if x > lst[#lst] then\n  \
    \  return nil\n  end\n  local m = math.ceil((#lst) / (x / lst[#lst]) + 1)\n  local\
    \ r = {}\n  r[#r + 1] = {}\n  local i = 1\n  for i = 1, m do\n    r[#r + 1][1]\
    \ = (i - 1) * lst[#lst] + 1\n    r[#r + 1][2] = i\n  end\n  for i = 1, #lst -\
    \ 1 do\n    r[#r + 1][1] = (#r + 1) * lst[#lst] + i - 1\n    r[#r + 1][2] = (i\
    \ + 1) * lst[#lst] + 1\n  end\n  table.sort(r)\n  return r\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
