name: HumanEval_134_check_if_last_char_is_a_letter
language: lua
prompt: "-- Create a function that returns True if the last character\n-- of a given\
  \ string is an alphabetical character and is not\n-- a part of a word, and False\
  \ otherwise.\n-- Note: \"word\" is a group of characters separated by space.\n--\
  \ Examples:\n-- check_if_last_char_is_a_letter(\"apple pie\") \u279E False\n-- check_if_last_char_is_a_letter(\"\
  apple pi e\") \u279E True\n-- check_if_last_char_is_a_letter(\"apple pi e \") \u279E\
  \ False\n-- check_if_last_char_is_a_letter(\"\") \u279E False\nlocal function check_if_last_char_is_a_letter(txt)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_if_last_char_is_a_letter\n\
  \    lu.assertEquals(candidate('apple'), false)\n    lu.assertEquals(candidate('apple\
  \ pi e'), true)\n    lu.assertEquals(candidate('eeeee'), false)\n    lu.assertEquals(candidate('A'),\
  \ true)\n    lu.assertEquals(candidate('Pumpkin pie '), false)\n    lu.assertEquals(candidate('Pumpkin\
  \ pie 1'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('eeeee\
  \ e '), false)\n    lu.assertEquals(candidate('apple pie'), false)\n    lu.assertEquals(candidate('apple\
  \ pi e '), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local last_char_index = 1\n    while true do\n        local result\
    \ = string.sub(txt, last_char_index, last_char_index+1)\n        if result ==\
    \ \"-\" and last_char_index > 1 then\n            local previous_result = string.sub(txt,\
    \ last_char_index-1, last_char_index)\n            if string.match(previous_result,\
    \ \"[[:alpha:]]\") then\n                return false\n            end\n     \
    \   end\n        last_char_index = last_char_index + 1\n    end\nend", "    local\
    \ word_chars = string.gsub(txt, \"[\\\\s]\", \"\")\n    if word_chars and word_chars:match(\"\
    %a\") then return true end\n    return false\nend", "    if txt ~= \"\" then\n\
    \        if string.sub(txt, string.len(txt)-1, string.len(txt)) ~= \" \" then\n\
    \            -- This line checks if the last character in the string is a letter\n\
    \            -- Note: The check will fail if the last character is a space,\n\
    \            --       but this can be fixed by adding a space to the end of\n\
    \            --       the string\n            return true ~= string.match(tostring(string.sub(txt,\
    \ 1, string.len(txt)-1)),\n            \"^[%aA-zZ]+$\")\n        else\n      \
    \      return false -- The last character is a space\n        end\n    else\n\
    \        return false -- The input is null\n    end\nend", "  local word\n  for\
    \ word in txt:gmatch('([^ ]+)')do return false end\n  return true\nend", "   \
    \ local last_char\n    for _, last_char in string.gsub(txt, \"[^a-zA-Z ]+$\",\
    \ \"%1\") do\n        return true\n    end\n    return false\nend", "    if not\
    \ txt then return false end\n    if txt:len() == 1 then\n        return true\n\
    \    end\n    local word = txt:sub(1,txt:len()-1)\n    local last_char = word:sub(-1)\n\
    \    return last_char:alpha()\nend", "    return (type(txt) == 'string') and\n\
    \           (string.sub(txt, string.len(txt)-1, string.len(txt))) ~= ' ' and\n\
    \           (string.sub(txt, string.len(txt)-1, string.len(txt))) ~= '.'\nend",
  "  local lastchar = txt:sub(1, #txt)\n  return lastchar ~= '' and\n         lastchar\
    \ ~= '?' and\n         lastchar ~= '!' and\n         lastchar ~= '-' and\n   \
    \      lastchar ~= '#' and\n         lastchar ~= '%' and\n         lastchar ~=\
    \ '&' and\n         lastchar ~= '(' and lastchar ~= ')' and\n         lastchar\
    \ ~= '-' and lastchar ~= '='\nend", "  return txt:sub(1, #txt)..'' ~= \" .-,\"\
    \ .. txt:sub(-1)\nend", "  return txt:sub(1, #txt) == txt and #txt:sub(1, #txt)\
    \ == 1 and\n         (check_if_last_char_is_a_word(txt:sub(1, #txt-1)) or #txt:sub(1,\
    \ #txt)) == 1 and\n         not is_letter(txt:sub(1, #txt-1)) -- first char must\
    \ be a letter if not a word separator\nend", "  return string.match(txt, \"([A-Za-z])$\"\
    )\nend", "    return txt:sub(-1, 1, 1) == \"a\" and #txt > 0 and txt:sub(-1, 1)\
    \ ~= \" \" and\n    not (check_if_last_char_is_a_word(txt) and txt:sub(-1, 1,\
    \ 1) ~= \"a\")\nend", "    if not txt then\n        return false\n    end\n  \
    \  txt = txt:gsub(\"%w+$\", \"\")\n    if #txt > 0 and txt:sub(#txt - 1, 1) ~=\
    \ \" \" then\n        return true\n    end\n    return false\nend", "    if not\
    \ txt then return false end\n    local last = string.sub(txt, -1)\n    return\
    \ (last:gsub(\"[a-z]\", \"\") ~= \"\") and last:gsub(\"[a-z]\", \"\") ~= \"a\"\
    \nend", "   local _alphabet = string.char(string.letters() + \" \")\n   return\
    \ (_alphabet:sub(string.len(txt)-1, string.len(txt))) == txt\nend", "  -- If the\
    \ string is empty, return False\n  if txt:len() == 0 then return false end", "\t\
    -- Check if the input string is not empty\n\tif not txt or #txt == 0 then\n\t\t\
    return false\n\tend\n\t\n\t-- Check if the last character is alphanumeric\n\t\
    -- or punctuation mark\n\treturn (string.sub(txt,-1,1) and string.sub(txt,-1,1)\
    \ ~= \" \")\nend", "\t-- Remove spaces if there is any\n\ttxt = string.gsub(txt,\
    \ \" \", \"\")\n\t-- Check if the last char is not a letter\n\t-- if so, return\
    \ false\n\tif string.sub(txt, -1, 1) ~= 'a' and string.sub(txt, -1, 1) ~= 'e'\
    \ and string.sub(txt, -1, 1) ~= 'i' and string.sub(txt, -1, 1) ~= 'o' and string.sub(txt,\
    \ -1, 1) ~= 'u' then\n\t\treturn false\n\telse\n\t\treturn true\n\tend\nend",
  "   local last = string.sub(txt, -1)\n   if last ~= \"\" and last ~= \"-\" and last\
    \ ~= \".\" and last ~= \"\\n\" and last ~= \" \" and last ~= \"!\" and last ~=\
    \ \"?\" and last ~= \"!\" and last ~= \"?\" and last ~= \",\" and last ~= \";\"\
    \ and last ~= \":\" and last ~= \".\" and last ~= \",\" and last ~= \":\" then\n\
    \      return true\n   else\n      return false\n   end\nend", "    local last_char\
    \ = txt:sub( 0, txt:len()-1 )\n    return last_char ~= \"\" and last_char ~= \"\
    \ \" and last_char ~= \",\" and\n          last_char ~= \";\" and last_char ~=\
    \ \".\" and last_char ~= \"-\"\nend", "  -- Check for emptiness\n  if txt == nil\
    \ or txt == '' then return False end\n  -- Check for non-alphabetical characters\n\
    \  if string.sub(txt,string.len(txt)-1,string.len(txt)) ~= string.sub(txt,string.len(txt),1)\
    \ then return False end\n  -- Check for word\n  -- Look for the beginning of the\
    \ last word\n  local i = string.find(txt,\" \",1,true)\n  -- If no word, then\
    \ return False\n  if i == nil then return False end\n  -- Loop over each character\
    \ in the word\n  for j = string.len(txt)-1,1,-1 do\n    if string.sub(txt,j,j)\
    \ == string.sub(txt,string.len(txt)-1,string.len(txt)) then return False end\n\
    \  end\n  return True\nend", "    local last_char = txt:sub(1, #txt)\n    return\
    \ (last_char == last_char:lower() and last_char:sub(2, #last_char) == \"\")\n\
    end", "   if txt == nil then return false end\n   local last_char = txt:sub((txt:len()-1),\
    \ txt:len())\n   return last_char:lower() == \"a\" or last_char:lower() == \"\
    e\" or last_char:lower() == \"i\" or last_char:lower() == \"o\" or last_char:lower()\
    \ == \"u\"\nend", "    -- return False if not provided\n    if txt == nil then\
    \ return end", "   if txt == \"\" then return false end\n   local last_char =\
    \ string.sub(txt, string.len(txt), 1)\n   return ((last_char ~= '\\ ') and #last_char\
    \ == 1) or\n      ((last_char ~= '\\ ') and (last_char ~= 'i' and last_char ~=\
    \ 'j'))\nend", "   return txt:sub(1,#txt)==txt:sub(1,#txt:len()-1) and\n     \
    \    not (word:sub(#word:len()-1,#word)) and\n         not word:sub(1,#word:len())\n\
    end", "    if txt == nil then\n        return false\n    end", "  local is_last,\
    \ last_char = string.match(txt, \"(.*[%w_]+)$\")\n  if is_last and last_char ~=\
    \ '' then\n    return true\n  else\n    return false\n  end\nend", "    local\
    \ last_char = string.sub(txt, -1)\n    local last_char_is_a_letter = string.sub(last_char,\
    \ -1) ~= '-'\n    local last_char_is_not_a_word = last_char == ''\n    return\
    \ last_char_is_a_letter and not last_char_is_not_a_word\nend", "    if txt ~=\
    \ \"\" then\n        local last_char = string.sub(txt, string.len(txt) - 1, string.len(txt))\n\
    \        return last_char == '.' or last_char == ' ' or last_char == ',' or\n\
    \            (last_char == '-' and string.sub(txt, string.len(txt) - 1, string.len(txt))\
    \ ~= '-')\n    end\nend", "  if txt == nil then\n    return False\n  end\n  return\
    \ string.sub(txt, -1) == \" \" and string.sub(txt, -1):match(\"[%W]\")\nend",
  "    local lastChar = string.sub(txt,-1,1)\n    return lastChar == string.sub(txt,-1,1)\
    \ and lastChar ~= '_'\nend", "  -- Initialize variables\n  local characters =\
    \ {}\n  local word = \"\"", "    local last_char = txt:sub(-2,-1)\n    if last_char\
    \ ~= \"\" then\n        local chars = string.gmatch(last_char, \"[%w]\")\n   \
    \     if chars ~= nil and #chars == 1 then\n            -- return True if last\
    \ character is alphabetical\n            return true\n        end\n    end\n \
    \   return false\nend", "  return txt:match(\"[^ ]%w$\")\nend", "  if txt and\
    \ #txt > 0 and txt:sub(1,1) ~= '\\0' and str:len(txt) == 1 then\n    return true\n\
    \  else\n    return false\n  end\nend", "  return string.sub(txt, 1, string.len(txt)\
    \ - 1) == string.sub(txt, 1, string.len(txt)-1) and string.sub(txt, 1, string.len(txt)-1)\
    \ ~= ' ' and string.sub(txt, 1, string.len(txt)-1) ~= '_' and string.sub(txt,\
    \ 1, string.len(txt)-1) ~= '-' and string.sub(txt, 1, string.len(txt)-1) ~= ':'\
    \ and string.sub(txt, 1, string.len(txt)-1) ~= '?' and string.sub(txt, 1, string.len(txt)-1)\
    \ ~= '%' and string.sub(txt, 1, string.len(txt)-1) ~= '!' and string.sub(txt,\
    \ 1, string.len(txt)-1) ~= '~' and string.sub(txt, 1, string.len(txt)-1) ~= '-'\
    \ and string.sub(txt, 1, string.len(txt)-1) ~= '[' and string.sub(txt, 1, string.len(txt)-1)\
    \ ~= ']' and string.sub(txt, 1, string.len(txt)-1) ~= '^' and string.sub(txt,\
    \ 1, string.len(txt)-1) ~= '_' and string.sub(txt, 1, string.len(txt)-1) ~= '{'\n\
    end", "  txt = tostring(txt)\n  local has_letter = true\n  for i = #txt, 2, -1\
    \ do\n    if not txt:sub(i, i):match(\"[%w]\") then\n      has_letter = false\n\
    \      break\n    end\n  end\n  return not has_letter\nend", "    local last_letter\
    \ = string.sub(txt, -1, 1)\n    if last_letter ~= '' then\n        return last_letter\
    \ ~= ' ' or string.sub(txt, 1, -1)\n    end\nend", "  local last_char = txt:sub((#txt),\
    \ 1)\n  return last_char ~= nil and not (last_char == \" \" and txt:sub((#txt\
    \ - 1), 1) == \"a\")\nend", "  return txt:sub(1,#txt) and ((txt:sub(-1)) == \"\
    \ \" or txt:sub(-1)==\" \") \nend", "    local last_char\n    local word_index\n\
    \    -- If the last character of the string is not a space, and\n    -- its not\
    \ part of a word:\n    if txt ~= \"\" then\n        last_char = txt:sub(-2, -1)\n\
    \        -- If the last char is not a letter:\n        if last_char ~= \"a\" and\
    \ last_char ~= \"A\" and last_char ~= \"e\" and last_char ~= \"i\" and last_char\
    \ ~= \"o\" and last_char ~= \"u\" then\n            -- If the last character is\
    \ not part of a word:\n            if word_index ~= nil then\n               \
    \ return false\n            end\n            word_index = #txt - 1\n        end\n\
    \    end\n    return true\nend", "  local last_char = string.sub(txt, string.len(txt))\n\
    \  local is_a_letter = last_char in alpha\n  local is_last_char_a_word = last_char\
    \ in word\n  return is_a_letter ~= is_last_char_a_word\nend", "  return string.sub(\
    \ txt, -1, 1 ) and string.sub( txt, -1, 1 ) ~= ' ' and string.sub( txt, -1, 1\
    \ ) ~= '-' and string.sub( txt, -1, 1 ) ~= '#'\nend", "    -- If the given string\
    \ is empty, return False.\n    if string.len(txt) == 0 then\n        return False\n\
    \    end", "  return (not string.match(txt, \"^[^ ]+$\") and\n    string.find(string.sub(txt,\
    \ string.len(txt)-1), #\" \", 1, true) ~= -1)\nend", "  local last = txt:match('^([^\\\
    s]+)$')\n  if last == nil then\n    return false\n  end\n  local last_char = last:sub(1,\
    \ #last)\n  local last_word = txt:sub(1, #txt:match('^([^\\s]+)$'))\n  return\
    \ last_char:match('^[a-zA-Z]+$') == nil and last_word:match('^[a-zA-Z]+$') ==\
    \ nil\nend", "  return string.sub((txt or \"\"), -1, string.len(txt)) == \" \"\
    \ and string.sub((txt or \"\"), -1, 1, \"a\") ~= \"e\" and\n    string.sub((txt\
    \ or \"\"), -1, 1, \"i\") ~= \"e\" and\n    string.sub((txt or \"\"), -1, 1, \"\
    o\") ~= \"e\" and\n    string.sub((txt or \"\"), -1, 1, \"u\") ~= \"e\" and\n\
    \    string.sub((txt or \"\"), -1, 1, \"A\") ~= \"E\" and\n    string.sub((txt\
    \ or \"\"), -1, 1, \"I\") ~= \"E\" and\n    string.sub((txt or \"\"), -1, 1, \"\
    O\") ~= \"E\" and\n    string.sub((txt or \"\"), -1, 1, \"U\") ~= \"E\"\nend",
  "   -- If txt is empty, then return False so that it can be handled\n   -- appropriately\
    \ by the calling function\n   if txt == \"\" then\n      return false\n   end",
  "  if txt == '' then return False end\n  local txt = txt:upper()\n  local word\n\
    \  local last_char = txt:sub(-1)\n  if last_char == ' ' then last_char = '' end\n\
    \  for word in txt:gmatch('([A-Z]+)') do\n    if word:len() < 2 then break end\n\
    \  end\n  if last_char == '.' then\n    -- Special case where \"...\" is a valid\
    \ letter.\n    word = word:gsub('.$', '')\n  end\n  if word ~= '' and word:sub(-1,\
    \ -1) == ' ' then\n    word = word:sub(1, word:len()-1)\n  end\n  return word\
    \ ~= nil and not (word == \".\" or word == \"\")\nend", "  local words = txt:match('(%S+)')\
    \ -- Split string by space into words\n  local letters = txt:gsub('([^A-Za-z ]+)$',\
    \ '') -- Remove everything after the last letter\n  return words[#words] and words[#words]\
    \ == letters -- Return True only if last word is equal to letters\nend", "   if\
    \ txt == nil then\n      return false\n   elseif type(txt) ~= 'string' then\n\
    \      return false\n   else\n      return (txt:len() >= 1) and ((txt:len() -\
    \ 1) >= 1) and (txt:sub(1, 1) == \" \" or txt:sub(1, 1) == \"\")\n   end\nend",
  "  if txt ~= \"\" then\n    return not (string.match(\"^[^ ]+\", txt))\n  else\n\
    \    return false\n  end\nend", "  local last_letter = string.sub(txt, -1, 1)\n\
    \  local is_letter = false\n  local words = string.gsub(txt, \"%s+\", \" \")\n\
    \  for _, word in pairs(words) do\n    local letter = string.sub(word, -1, 1)\n\
    \    if letter ~= last_letter then\n      is_letter = true\n      break\n    end\n\
    \  end\n  return not is_letter\nend", "  for i = 1,#txt do\n    if txt:sub(i,i)\
    \ == \" \" then\n      -- If last character is space, check for letter part\n\
    \      if check_if_last_char_is_a_letter(txt:sub(i-1, 1, i-1)) then\n        return\
    \ false\n      end\n    end\n  end\n  return true\nend", "  if txt == nil then\n\
    \    return false\n  end\n  txt = txt:gsub(\"%w+\", \" \")\n  return #txt > 0\
    \ and txt[#txt] == txt:sub(1,#txt)\nend", "  return txt:sub(1, #txt) ~= \" \"\
    \ and txt:sub(-1, #txt) ~= \" \"\nend", "    local last_char = string.sub(txt,\
    \ -1)\n    return not ((last_char == \" \") or (last_char == \"-\"))\nend", " \
    \ -- If the last character is an alphabetical character:\n  if (txt:sub(1,1) ==\
    \ \"a\" or txt:sub(1,1) == \"e\" or txt:sub(1,1) == \"i\" or txt:sub(1,1) == \"\
    o\" or txt:sub(1,1) == \"u\") and not(string.sub(txt, -1) == \"\\n\")\n  -- If\
    \ the last character is a letter:\n  or txt:sub(1,1) == \"a\"\n  or txt:sub(1,1)\
    \ == \"e\"\n  or txt:sub(1,1) == \"i\"\n  or txt:sub(1,1) == \"o\"\n  or txt:sub(1,1)\
    \ == \"u\"\n  -- If the last character is a space:\n  or string.sub(txt, -1) ==\
    \ \" \"\n  -- If the last character is a number:\n  or string.sub(txt, -1) ==\
    \ \"\\n\"\n  -- If the last character is a \".\":\n  or string.sub(txt, -1) ==\
    \ \".\"\n  -- Otherwise:\n  then return true\n  else return false\n  end\nend",
  "    if txt == \"\" then\n        return false\n    end\n    -- Check for space\n\
    \    if string.sub(txt, string.len(txt) - 1, string.len(txt)) == \" \" then\n\
    \        return false\n    end\n    -- Check for alphabetic characters\n    for\
    \ _, c in ipairs(string.gsub(txt, \"[^a-zA-Z]\", \"\")) do\n        return false\n\
    \    end\n    -- Return true if all characters are alphabetic\n    return true\n\
    end", "  return txt:len() >= 1 and txt:sub(1, txt:len() - 1):find(\"[a-zA-Z]\"\
    )\nend", "  return txt:match(\"[%a%a]+$\") or txt:match(\"[%a%a]+$\")\nend", " \
    \   if txt == nil then\n        return false\n    end", "  if txt ~= nil then\n\
    \    local txt = txt:sub(1, #txt)\n    local letter = string.match(txt, \"([A-Za-z])\"\
    )\n    if letter ~= nil and letter ~= \"\" then\n      return false\n    else\n\
    \      return true\n    end\n  else\n    return false\n  end\nend", "    local\
    \ words = txt:gsub(\" \", \"\")\n    for _, word in ipairs(words) do\n       \
    \ if not word:match(alpha) then\n            return false\n        end\n    end\n\
    \    return true\nend", "  return string.sub(txt, -1, 1) ~= \" \" and string.sub(txt,\
    \ -1, 1) ~= \"\\n\"\nend", "\tlocal words = string.gmatch(txt, \"([^ ]*)\")\n\t\
    local lastword = string.sub(words, #words - 1, 1)\n\treturn lastword ~= nil and\
    \ lastword ~= \"\" and #lastword > 0 and lastword:match(\"^[a-z]+$\")\nend", "\t\
    -- Find last character in txt\n\tlocal last_char = txt:sub(1, #txt - 1)\n\t--\
    \ If last char is alphabet but not an aplhabet in txt return false\n\tif last_char\
    \ == 'A' or (last_char == 'a' and txt:sub((#txt-1), #txt) == 'e') or (last_char\
    \ == 'a' and txt:sub((#txt-1), #txt) == 'i') or (last_char == 'a' and txt:sub((#txt-1),\
    \ #txt) == 'o') or (last_char == 'a' and txt:sub((#txt-1), #txt) == 'u') then\
    \ return false end\n\t-- If last char is space or tab or newline return true\n\
    \tif last_char == '\\t' or last_char == ' ' or last_char == '\\n' then return\
    \ true end\n\treturn false\nend", "  local words = txt:gsub('( +)', ' ', 'g')\n\
    \  local last_char = words[#words]\n  return last_char ~= '' and\n         last_char\
    \ == string.sub(last_char, 1, #last_char) and\n         not string.sub(last_char,\
    \ #last_char)\nend", "    if not txt then return False end\n    local words =\
    \ string.split(txt)\n    if #words == 0 then return False end\n    local last_word\
    \ = words[#words]\n    local last_chars = string.gsub(last_word, \"(%S+)$\", \"\
    \")\n    return #last_chars == 0 and last_chars == last_word\nend", "  local last_char\
    \ = txt:sub(-1)\n  local is_letter = last_char ~= \" \" and last_char ~= nil\n\
    \  if txt ~= last_char then return False end\n  local is_word = false\n  for w\
    \ in txt:gmatch(\"[%w_-]+\") do\n    is_word = true\n    break\n  end\n  return\
    \ not is_word and is_letter\nend", "  return ((string.len(txt) > 1) and (string.sub(txt,\
    \ string.len(txt) - 1, string.len(txt)) ~= '\\b')\n          and not (string.match(txt,\
    \ \"[[:alpha:]]\"))\n          and string.sub(txt, string.len(txt), string.len(txt))\
    \ ~= \" \")\nend", "    if txt == nil then\n        return false\n    end\n  \
    \  if txt:len() < 3 then\n        return false\n    end\n    for i = 1, txt:len()\
    \ do\n        if string.char(string.byte(txt, i)) == string.char(string.byte('a'))\
    \ then\n            return false\n        end\n    end\n    return true\nend",
  "   if txt == nil then\n      return false\n   end\n   local last_char = txt:sub(1,#txt-1)\n\
    \   if last_char:sub(1,1) == '_' then\n      return false\n   elseif last_char\
    \ == '.' then\n      return false\n   elseif last_char:sub(1,1) == ' ' then\n\
    \      return false\n   elseif last_char:sub(1,1) == '-' then\n      return false\n\
    \   elseif last_char:sub(1,1) == '_' then\n      return false\n   else\n     \
    \ return true\n   end\nend", "  return txt:match(\"[^ ]+$\")\nend", "   local\
    \ words = txt:gmatch(\"%w+( )\") -- \"word\" is a group of characters separated\
    \ by space.\n   if not words then return False end\n   for _, word in pairs(words)\
    \ do\n      if not word:sub(1,1) and word:sub(-1)~=\".\" then return False end\n\
    \   end\n   return True\nend", "  -- Make sure that txt has at least 1 character.\n\
    \  if txt == nil then\n    return false\n  else\n    -- Get the length of the\
    \ txt string.\n    local txt_len = #txt\n    -- If the length of the txt string\
    \ is not greater than 0, return false.\n    if txt_len == 0 then\n      return\
    \ false\n    else\n      -- Create a variable that will hold the alphabet characters.\n\
    \      local alphabet = {}\n      -- Iterate through every character in the txt\
    \ string.\n      for i = 0, txt_len - 1 do\n        -- If the character is not\
    \ an alphabetical character,\n        -- add it to the alphabet array.\n     \
    \   if not (txt:sub(i, i + 1):sub(1, 2)) then\n          alphabet[i] = true\n\
    \        end\n      end\n      -- If the alphabet array is empty, return false.\n\
    \      if #alphabet == 0 then\n        return false\n      else\n        return\
    \ true\n      end\n    end\n  end\nend", "  if txt == \"word\" then return false\
    \ end\n  local i = #txt - 1\n  while i ~= 0 do\n    local c = string.sub(txt,\
    \ i, i)\n    if not (string.byte(c) < 128 and string.byte(c) > 0 and c ~= \" \"\
    \ and\n      c ~= \"-\" and c ~= \"_\") then\n      return false\n    end\n  \
    \  i = i - 1\n  end\n  return true\nend", "   if txt == nil then\n      return\
    \ false\n   end\n   local last_char = string.sub(txt,-1)\n   local is_last_char_blank\
    \ = string.sub(txt,-1,-1) == \"\"\n   return last_char == \" \" and is_last_char_blank\n\
    end\n</cell>\n<cell>", "    -- Your code here\n    if #txt == 0 then return false\
    \ end\n    if txt[#txt] == \" \" then return false end\n    if string.sub( txt,\
    \ 1, #txt ) == \" \" then return false end\n    if string.sub( txt, #txt + 1,\
    \ -1 ) == \" \" then return false end\n    if string.sub( txt, #txt + 1, -1 )\
    \ == \" \" then return false end\n    for w in string.gmatch( txt, \" \" ) do\n\
    \        if string.sub( w, -1, 1 ) ~= \" \" then\n            return true\n  \
    \      end\n    end\n    return false\nend", "  local words = txt:match(\"(%S+)\"\
    )\n  if words then\n    for w in words:gmatch(\"%w+\") do\n      local c = w:sub(1,\
    \ 1)\n      if c:byte() == #w and c ~= \" \" then\n        return false\n    \
    \  end\n    end\n  else\n    return false\n  end\n  return true\nend", "    local\
    \ last_char = string.sub(txt, #txt - 1, 1)\n    return last_char ~= \" \" and\
    \ string.sub(txt, #txt, 1) ~= \"\"\nend", "    local last_char = string.sub(txt,-1)\n\
    \    if last_char == ' ' then\n        return false\n    else\n        return\
    \ string.match(txt, \"^[A-Za-z]+$\")\n    end\nend", "   -- Your code here\n \
    \  return true\nend", "  local ok, err = true, \"success\"\n  local alpha_re =\
    \ \"[A-Za-z]-\"\n  local alpha_word = alpha_re .. \"(\" .. alpha_re .. \")*\"\n\
    \  local alpha_no_word = alpha_re .. \"(\" .. alpha_re .. \")+\" .. alpha_word\n\
    \  local alpha_end_of_word = alpha_re .. \"(\" .. alpha_re .. \")+$\"\n  local\
    \ alpha_word_end = alpha_no_word .. alpha_end_of_word\n  local alpha_word_has_chars\
    \ = alpha_word_end .. \"(\" .. alpha_no_word .. \")+\"", "  for i = 1, #txt -\
    \ 1 do\n    if string.sub(txt, i, i+1) ~= \" \" then\n      return true\n    end\n\
    \  end\n  return false\nend", "  for i = #txt - 1, 1, -1 do\n    if string.sub(txt,\
    \ i, i) ~= '\\000' and string.sub(txt, i, i) ~= '\\200' and string.sub(txt, i,\
    \ i) ~= '\\257' then\n      return true\n    end\n  end\n  return false\nend",
  "  for _, letter in ipairs(txt:gsub('[%s]+$','')):gmatch('%w+') do\n    return letter\
    \ ~= ''\n  end\n  return false\nend", "  if txt == nil then\n    return false\n\
    \  end\n  -- Check last char in the txt\n  if txt:len() > 0 then\n    local last_char\
    \ = txt:len() -1\n    if txt:len() >= 2 then\n      local last_char = txt:len()\
    \ -1\n      -- Check if it's an alphabetical char\n      if txt:sub(last_char,\
    \ last_char) == alphaChar:upper() then\n        return false\n      end\n    end\n\
    \  end\n  return true\nend", "  -- Create a counter variable that holds the number\
    \ of characters\n  -- that have been checked so far.\n  local counter = 0", " \
    \   local word\n    if txt and string.sub(txt,#txt,1) ~= \"\" then\n        word\
    \ = string.gsub(txt,\" \",\"\")\n        if word[#word] == \" \" then\n      \
    \      word = string.gsub(word,\" \",\"\")\n        end\n    end\n    local alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n    for\
    \ i=1,#alphabet do\n        local ch = alphabet:sub(i,i)\n        if word and\
    \ word == ch then\n            return false\n        end\n    end\n    return\
    \ true\nend", "    local last_char = txt:match(\"(.-)$\")\n    if last_char ==\
    \ nil then\n        return false\n    end\n    if last_char:gsub(\"%a+\", \"\"\
    ) ~= \"\" then\n        return false\n    end\n    return true\nend", "  local\
    \ last_char = txt:sub((txt:len()-1))\n  local words = tbl_by_chars(txt)\n  local\
    \ word = ''\n  for word in pairs(words) do\n    if word == last_char then\n  \
    \    return false\n    end\n  end\n  return true\nend", "    local txt = txt:lower()\n\
    \    local word_list = txt:gsub('%s+', \" \")\n    local last_char = word_list:sub(1,word_list:len()-1)\n\
    \    return last_char:match('^[%w]$') ~= nil\nend", "   if txt == \"\" then return\
    \ false end\n   local last_char = txt:sub(-1)\n   return last_char == ' ' or last_char\
    \ == '.' or last_char == '-'\nend", "    local words = string.gmatch(txt, \"([^\
    \ ]+)\") -- Split string into words\n    return words[#words][#words[#words]]\
    \ = '' -- Check to see if last word is blank\nend", "   local last_char = string.sub(txt,\
    \ -1, 1)\n   return string.match(last_char, \"%w\") == nil\nend", "    if txt\
    \ == nil then\n        return nil\n    end\n    if #txt <= 0 then\n        return\
    \ false\n    end\n    -- Remove trailing spaces\n    txt = txt:gsub(\"( +)$\"\
    , '')\n    local last_char = txt:sub(-1)\n    -- If last character is a letter,\
    \ return true\n    return last_char:isalpha()\nend", "    local last_char = string.sub(txt,\
    \ -1)\n    return (last_char ~= \" \" and last_char ~= \".\")\nend", "   -- check\
    \ for empty string\n   if txt == \"\" then\n      return false\n   end\n   --\
    \ initialize variable\n   local result = true\n   -- get last character\n   local\
    \ last_char = txt:sub((#txt), 1)\n   -- check for letters\n   if last_char ==\
    \ \"a\" or last_char == \"e\" or last_char == \"i\" or last_char == \"o\" or last_char\
    \ == \"u\" then\n      result = false\n   end\n   -- return result\n   return\
    \ result\nend", "  return (string.len(txt) > 0)\n  and string.sub(txt, string.len(txt)-1,\
    \ string.len(txt)) ~= '\\\\w'\nend", "  if txt == nil then\n    return false\n\
    \  end\n  txt = txt:lower()\n  local words = txt:gsub(\"([^ ]+) \", \"%1\")\n\
    \  return words:sub(1, 1):match(\"^([a-z]$)\")\nend", "  for _, letter in ipairs(txt)\
    \ do\n    if not letter or letter:find(\" \") then\n      return false\n    end\n\
    \  end\n  return true\nend", "  return txt:sub(1, #txt) ~= \"\" and #txt - txt:sub(1,\
    \ #txt):match(\"%a\") ~= 0\nend", "   local last_char = string.sub(txt, -1, 1)\n\
    \   if last_char == \"\" then\n      return false\n   elseif string.find(string.gsub(last_char,\
    \ \"[^A-Za-z]\", \"\"), \" \") == nil then\n      return true\n   else\n     \
    \ return false\n   end\nend", "  local last_char = string.sub(txt,-1)\n  local\
    \ last_char = string.lower(last_char)\n  return last_char == string.sub(txt,-1,1)\
    \ and not find_words_in_this_string(txt)\nend", "    return (string.sub(txt, -1,\
    \ 1) ~= \" \") and\n        (string.find(string.gsub(txt, \"[^ ]+\", \" \"), \"\
    \ \") ~= -1)\nend", "    local last_char = txt:sub((#txt), 1)\n    return ((last_char\
    \ == \" \") or last_char == \"\\n\") or last_char == \"\\t\"\nend", "    local\
    \ last_char = string.sub(txt, #txt)\n    return last_char and last_char:match(\"\
    ^[A-Za-z]$\")\nend", "    -- Checks the last character of each string passed to\
    \ function\n    for i,word in ipairs(txt) do\n        if string.sub(word,-1,1)\
    \ ~= '\\\\' then\n            return false\n        else\n            -- Checks\
    \ if last character is a letter\n            if string.sub(word,-1,1) ~= string.sub(word,-1,1)\
    \ then\n                return false\n            else\n                -- Checks\
    \ if first character is \"a\"\n                if string.sub(word,1,1) ~= \"a\"\
    \ then\n                    return false\n                end\n            end\n\
    \        end\n    end\n    return true\nend", "  local last_char = string.sub(txt,\
    \ -1)\n  local words = string.gsub(txt, \" \", \"\")\n  -- return false if there\
    \ are no words in the string\n  -- or if the last character is a letter or number\
    \ not part of a word\n  if words == \"\" then\n    return false\n  end\n  -- return\
    \ false if the last character is a letter or number\n  -- that is part of a word\n\
    \  if last_char:match(\"^[a-zA-Z0-9]+$\") then\n    return true\n  end\n  return\
    \ false\nend", "    local txt = txt:gsub(\"%s+$\", \"\")\n    if txt ~= \"\" then\n\
    \        local letter = string.byte(txt)\n        return letter == 97 or letter\
    \ == 65\n    end\n    return false\nend", "  return not string.sub(txt, -1, 1)\
    \ and string.sub(txt, -1, 1) ~= \" \" and\n         string.sub(txt, -1, 1) ~=\
    \ \" \" and\n         string.sub(txt, -1, 1) ~= \"-\"\nend", "    return string.sub(txt,\
    \ 1, string.len(txt)-1) == string.sub(txt, 1, string.len(txt)-1) and string.sub(txt,\
    \ 1, string.len(txt)-1) ~= \" \" \nend", "    local last_char = string.sub(txt,\
    \ -1)\n    return last_char ~= \" \" and last_char ~= \"\" and\n      (last_char:lower()\
    \ == \"a\" or last_char:lower() == \"e\" or last_char:lower() == \"i\" or last_char:lower()\
    \ == \"o\" or\n       last_char:lower() == \"u\" or last_char:lower() == \"\xE1\
    \" or last_char:lower() == \"\xE9\" or last_char:lower() == \"\xED\" or\n    \
    \   last_char:lower() == \"\xF3\" or last_char:lower() == \"\xFA\" or last_char:lower()\
    \ == \"\xE4\" or last_char:lower() == \"\xEB\" or\n       last_char:lower() ==\
    \ \"\xFC\" or last_char:lower() == \"\xF6\")\nend", "    return string.sub(txt,\
    \ -1) == string.sub(txt, -1, 1) and string.sub(txt, -2) ~= \" \" and string.sub(txt,\
    \ -2) ~= \" \"\nend", "  return txt:sub(1, #txt) ~= '' and\n    not string.match(txt,\
    \ \"%S+$\")\nend", "    if txt == nil then\n        return false\n    end\n  \
    \  -- Remove all trailing spaces:\n    txt = txt:gsub(\"( +)$\", \"\")", "   \
    \ return txt:sub(1, #txt) == \" \" and #txt > 0 and check_if_last_char_is_a_letter(txt:sub(2))\
    \ or false\nend", "    local last_char = txt:sub(1, #txt)\n    return last_char\
    \ == string.letters(last_char)\nend", "    local last = txt:match(\"(.-)$\")\n\
    \    if last ~= \"\" then\n        return last:match(\"^%a\") ~= nil\n    end\n\
    \    return false\nend", "  local words = txt:gsub('[^ ]+', ' '):gsub(' ', '').toLowerCase()\n\
    \  return words[#words] ~= ''\nend", "    -- Check if the given string has length\
    \ greater than zero.\n    if string.len(txt) > 0 then\n        -- Return True\
    \ if we have a non-empty string, and the last character\n        -- of the given\
    \ string is an alphabetical character and is not a\n        -- part of a word.\n\
    \        return string.sub(txt, string.len(txt)-1, string.len(txt)) == string.sub(txt,\
    \ 1, string.len(txt)) and not (string.sub(txt, 1, string.len(txt)) ~= \" \")\n\
    \    end\n    -- Return True if the given string has no length or is empty.\n\
    \    return string.len(txt) == 0 or string.len(txt) == \"\"\nend", "  local s\
    \ = txt:sub(1, 2)\n  if s ~= \"\" then\n    for _,c in pairs(s:gsub(\"%w+\", \"\
    \")) do\n      return c ~= \" \" and c ~= \"\"\n    end\n  end\n  return false\n\
    end", "    return (txt:sub(-1) == \" \" and not is_word(txt))\nend", "  return\
    \ (txt:sub(1, #txt) == txt:sub(#txt, #txt))\nend", "   if not txt then return\
    \ False end\n   -- Check if string ends with space.\n   if string.sub(txt, 1,\
    \ string.len(txt)) == txt then return false end\n   -- Check if last character\
    \ is a letter.\n   if string.sub(txt, -1, 1) == string.sub(txt, string.len(txt)-1,\
    \ string.len(txt)) == string.sub(txt, 1, string.len(txt)-1) then return false\
    \ end\n   return true\nend", "  local last_char = string.sub(txt, -1)\n  return\
    \ last_char ~= ' ' and\n         last_char ~= '-' and\n         last_char ~= '('\
    \ and \n         last_char ~= ':' and\n         last_char ~= '?' and \n      \
    \   last_char ~= '-' and\n         last_char ~= '\"'\nend", "    local last =\
    \ txt:sub((#txt), 1, #txt)\n    local first_char = last:sub(1, 1)\n    -- Check\
    \ if the first char is a letter\n    if first_char == 'a' or first_char == 'e'\
    \ or first_char == 'i' or first_char == 'o' or first_char == 'u' then\n      \
    \  -- If so then check if the last char is a letter\n        return last:sub((#last),\
    \ 1)\n    else\n        -- If no first char then return false\n        return\
    \ false\n    end\nend", "   -- If the string is empty, return False\n   if txt\
    \ ~= \"\" then\n      -- Use Lua pattern matching (~=) to find if the string ends\
    \ in an\n      -- alphabetical character\n      if txt ~= string.sub(txt, -1,\
    \ 1) then\n         return true\n      else\n         -- If the last char is not\
    \ an alphabetical char, return False\n         return false\n      end\n   end",
  "  return string.sub(txt, 1, string.len(txt)) ~= \" \" and string.sub(txt, 1, string.len(txt))\
    \ == string.sub(txt, string.len(txt), string.len(txt)-1)\nend", "  -- Check for\
    \ validity\n  if txt == nil then\n    return false\n  end\n  -- Check txt is a\
    \ string\n  if type(txt) ~= 'string' then\n    return false\n  end\n  -- If txt\
    \ is empty, return true\n  if #txt == 0 then\n    return true\n  end\n  -- Check\
    \ txt is at least 1 character\n  if #txt < 1 then\n    return false\n  end\n \
    \ -- Check for letter\n  for i = #txt - 1, 1, -1 do\n    if string.sub(i, 1, 1)\
    \ ~= string.sub(txt, i, 1) then\n      return false\n    end\n  end\n  -- No letter\
    \ in txt, return true\n  return true\nend", "  return (txt:len() >= 1 and\n  \
    \  txt:sub(1,1) ~= \" \" and\n    string.sub(txt,-1,1) ~= \"-\" and\n    string.sub(txt,-1,1)\
    \ ~= \"!\" and\n    string.sub(txt,-1,1) ~= \"?\" and\n    string.sub(txt,-1,1)\
    \ ~= \"$\" and\n    string.sub(txt,-1,1) ~= \"%\" and\n    string.sub(txt,-1,1)\
    \ ~= \"%\" and\n    string.sub(txt,-1,1) ~= \"&\" and\n    string.sub(txt,-1,1)\
    \ ~= \"*\" and\n    string.sub(txt,-1,1) ~= \"+\" and\n    string.sub(txt,-1,1)\
    \ ~= \"(\" and\n    string.sub(txt,-1,1) ~= \")\" and\n    string.sub(txt,-1,1)\
    \ ~= \";\" and\n    string.sub(txt,-1,1) ~= \":\" and\n    string.sub(txt,-1,1)\
    \ ~= \"/\" and\n    string.sub(txt,-1,1) ~= \"<\" and\n    string.sub(txt,-1,1)\
    \ ~= \"=\" and\n    string.sub(txt,-1,1) ~= \">\" and\n    string.sub(txt,-1,1)\
    \ ~= \"?\" and\n    string.sub(txt,-1,1) ~= \"^\" and\n    string.sub(txt,-1,1)\
    \ ~= \"{\" and\n    string.sub(txt,-1,1) ~= \"}\" and\n    string.sub(txt,-1,1)\
    \ ~= \"|\" and\n    string.sub(txt,-1,1) ~= \"\xBB\" and\n    string.sub(txt,-1,1)\
    \ ~= \"\xAB\" and\n    string.sub(txt,-1,1) ~= \";\" and\n    string.sub(txt,-1,1)\
    \ ~= \":\" and\n    string.sub(txt,-1,1) ~= \"/\" and\n    string.sub(txt,-1,1)\
    \ ~= \"<\" and\n    string.sub(txt,-1,1) ~= \"=\" and\n    string.sub(txt,-1,1)\
    \ ~= \">\" and\n    string.sub(txt,-1,1) ~= \"?\" and\n    string.sub(txt,-1,1)\
    \ ~= \"^\" and\n    string.sub(txt,-1,1) ~= \"{\" and\n    string.sub(txt,-1,1)\
    \ ~= \"}\" and\n    string.sub(txt,-1,1) ~= \"|\" and\n    string.sub(txt,-1,1)\
    \ ~= \"\xBB\" and\n    string.sub(txt,-1,1) ~= \"\xAB\" and\n    string.sub(txt,-1,1)\
    \ ~= \"", "  local last\n  for i = 1, #txt do\n    local c = string.sub(txt, i,\
    \ i)\n    last = c:upper()\n    if last == \"A\" or last == \"B\" or last == \"\
    C\" or last == \"D\" or last == \"E\" or last == \"F\" then\n      return false\n\
    \    end\n  end\n  return true\nend", "  -- Remove trailing blanks.\n  txt = txt:gsub(\"\
    %s+$\",\"\");\n  -- If txt is empty, return False\n  if not txt then return false\
    \ end\n  -- If the last character in txt is a letter, return true\n  return txt:sub(\
    \ #txt - 1, 1)  == 'a'\nend", "   return (txt:sub( -1, 1 ):lower() == \"a\"\n\
    \      or txt:sub( -1, 1 ):lower() == \"e\"\n      or txt:sub( -1, 1 ):lower()\
    \ == \"i\"\n      or txt:sub( -1, 1 ):lower() == \"o\"\n      or txt:sub( -1,\
    \ 1 ):lower() == \"u\"\n      or txt:sub( -1, 1 ):lower() == \"y\")\nend", " \
    \  local last_char = txt:sub(#txt-1)\n   if last_char ~= \"\" then\n      if last_char:match(\"\
    [a-zA-Z]\") then\n         return false\n      end\n   end\n   return true\nend",
  "   return txt:sub(1,#txt)~=tostring(\" \")\nend", "  -- Check if string is empty\
    \ or only contains one character\n  if txt:len() == 0 or txt:sub(1, 1) ~= 'e'\
    \ or txt:sub(1, 1) ~= 'w' or txt:sub(1, 1) ~= 'p' then\n    return false\n  end\n\
    \  -- Return true if the last character is not an alphabet\n  return true\nend",
  "  return txt:sub((#txt - 1)):match(\n    \"[%a][%A][%w-]\", -- Letters\n    \"\
    [%a][%A][%w-]*\", -- Letters, numbers\n    \"[%a][%A][%w-]*[%a][%A][%w-]*\", --\
    \ Letters, numbers, spaces, letters\n    \"[%a][%A][%w-]*[%a][%A][%w-]*[%a][%A][%w-]*\"\
    , -- Letters, numbers, spaces, letters, numbers\n    \"[%a][%A][%w-]*[%a][%A][%w-]*[%a][%A][%w-]*[%a][%A][%w-]*\"\
    \ -- Letters, numbers, spaces, letters, numbers, spaces\n  )\nend", "  if txt:len()\
    \ ~= 0 then\n    local last_char = txt:sub(1, txt:len())\n    if last_char:find(\"\
    \ \") ~= nil then\n      last_char = last_char:sub(1, last_char:len() - 1)\n \
    \   end\n    if last_char:gsub(\"%W\", \"\") == \"\" then\n      return false\n\
    \    end\n    return true\n  end\n  return false\nend", "  local txt = txt or\
    \ \"\"\n  local last_char = txt:sub(1, #txt)\n  return last_char and last_char:match\
    \ \"[%w-]\"\nend", "  return txt:sub((#txt) - 1) ~= ' ' and\n    txt:sub((#txt)\
    \ - 1) ~= '' and\n    txt:sub((#txt) - 1):match('[a-zA-Z]')\nend", "  return string.len(txt)\
    \ == string.len(txt:sub(string.len(txt) - 1, 1)) and txt:sub(1, string.len(txt))\
    \ == string.gsub(txt, ' ', '') and false or true\nend", "\t-- If empty string,\
    \ return False\n\tif txt == \"\" then\n\t\treturn false\n\tend", "  -- Write your\
    \ code here:\n  -- Your code here\n  local _, word_ending = string.find(txt, \"\
    \ \")\n  -- If there is no word in the string, return False\n  -- If there is\
    \ no character after a space, return False\n  if word_ending == nil then\n   \
    \ return false\n  end\n  local char_after_word_ending = txt:sub(1, word_ending\
    \ - 1)\n  -- If the character after the word ending is not a letter, return False\n\
    \  -- If there is the character after the word ending that is also a letter,\n\
    \  -- the last char is not a letter.\n  if char_after_word_ending:sub(1, 1) ~=\
    \ string.char(string.ascii_letter) then\n    return false\n  end\n  return true\n\
    end", "  if txt == \"\" then\n    return false\n  end", "  local last_char = string.sub(txt,\
    \ #txt, -1)\n  local result = false\n  for word in string.gmatch(txt, \"([^ ]*)$\"\
    ) do\n    if last_char ~= word[#word] then\n      result = true\n      break\n\
    \    end\n  end\n  return result\nend", "    local lastchar = string.sub(txt,\
    \ 1, #txt - 1)\n    return (lastchar == 'a' or lastchar == 'e' or lastchar ==\
    \ 'i' or lastchar == 'o' or lastchar == 'u')\nend", "  if txt == nil then return\
    \ false end\n  -- check if string is not empty\n  if #txt < 1 then return false\
    \ end\n  -- check if last character is a letter\n  local is_last_char = txt:sub(\
    \ #txt -1, 1 ):upper()\n  return is_last_char == \"A\" or\n         is_last_char\
    \ == \"B\" or\n         is_last_char == \"C\" or\n         is_last_char == \"\
    D\" or\n         is_last_char == \"E\" or\n         is_last_char == \"F\" or\n\
    \         is_last_char == \"G\" or\n         is_last_char == \"H\" or\n      \
    \   is_last_char == \"I\" or\n         is_last_char == \"J\" or\n         is_last_char\
    \ == \"K\" or\n         is_last_char == \"L\" or\n         is_last_char == \"\
    M\" or\n         is_last_char == \"N\" or\n         is_last_char == \"O\" or\n\
    \         is_last_char == \"P\" or\n         is_last_char == \"Q\" or\n      \
    \   is_last_char == \"R\" or\n         is_last_char == \"S\" or\n         is_last_char\
    \ == \"T\" or\n         is_last_char == \"U\" or\n         is_last_char == \"\
    V\" or\n         is_last_char == \"W\" or\n         is_last_char == \"X\" or\n\
    \         is_last_char == \"Y\" or\n         is_last_char == \"Z\"\nend", "  \
    \  -- Your code here\n    local alpha = string.match(string.gsub(txt,\" \",\"\
    ?\"),\"[a-z]\")\n    if alpha then\n        local word_end_pos = string.find(string.gsub(txt,\"\
    \ \",\"?\"),\"[[:alpha:]]\")\n        if word_end_pos then\n            return\
    \ true\n        else\n            return false\n        end\n    else\n      \
    \  return false\n    end\nend", "  txt = txt:sub(1,#txt-1)\n  for i,c in pairs(txt:gmatch(\"\
    %S+\")) do\n    if string.match(\"([A-Za-z])\",c) then\n      return false\n \
    \   end\n  end\n  return true\nend", "  if txt ~= nil then\n    if txt:sub(1,\
    \ 1) ~= ' ' then\n      if txt:sub(#txt, 1) ~= '-' and txt:sub(#txt, 1) ~= '/'\
    \ and txt:sub(#txt, 1) ~= '.' and txt:sub(#txt, 1) ~= '-' and txt:sub(#txt, 1)\
    \ ~= '/'\n      then\n        return false\n      else\n        return true\n\
    \      end\n    else\n      return true\n    end\n  else\n    return false\n \
    \ end\nend", "  -- Initialize return value\n  local last_char_is_a_letter = false\n\
    \  -- Initialize return value\n  local is_last_char_in_word = false\n  -- Initialize\
    \ return value\n  local last_char_not_in_word = \"\"\n  -- Iterate over each character\
    \ in txt string\n  for i,v in ipairs(txt) do\n    -- Check if current char is\
    \ alphabetical and not in a word\n    if v:alpha() and v ~= \" \" then\n     \
    \ -- If current char is not a letter\n      if not v:alpha() then\n        --\
    \ Set last char not in a word to current char\n        last_char_not_in_word =\
    \ v\n      -- If current char is not a letter\n      else\n        -- Set last\
    \ char not in a word to current char\n        last_char_not_in_word = v\n    \
    \  -- If current char is last char in word\n      elseif v:sub(1,1) == v then\n\
    \        -- Set last char not in a word to current char\n        last_char_not_in_word\
    \ = v\n      -- If current char is not last char in word\n      elseif not v:sub(1,1)\
    \ ~= v then\n        -- Set last char not in a word to current char\n        last_char_not_in_word\
    \ = v\n      -- If current char is last char in word AND current char is not a\
    \ letter\n      elseif v:sub(1,1) == v and not v:alpha() then\n        -- Set\
    \ last char not in a word to current char\n        last_char_not_in_word = v\n\
    \      -- If current char is last char in word AND current char is not a letter\n\
    \      elseif v:sub(1,1) == v and not v:alpha() then\n        -- Set last char\
    \ not in a word to current char\n        last_char_not_in_word = v\n      -- If\
    \ current char is last char in word AND current char is in word\n      elseif\
    \ v:sub(1,1) == v and v:sub(1,2) == v then\n        -- Set last char not in a\
    \ word to current char\n        last_char_not_in_word = v\n      -- If current\
    \ char is not last char in word\n      elseif not v:sub(1,1) ~= v then\n     \
    \   -- Set last char not in a word to current char\n        last_char_not_in_word\
    \ = v\n      -- If current char is not last char in word\n      elseif not v:sub(1,1)\
    \ ~= v then\n        -- Set last char not in a word to current char\n        last_char_not_in_word\
    \ = v\n      -- If current char is not last char in word\n      elseif not v:sub(1,1)\
    \ ~= v then\n        -- Set last char not in a word to current char\n        last_char_not_in_word\
    \ = v\n      -- If ", "  local last_char = txt:sub((txt:len() - 1))\n  if last_char:gsub('^%S+$')\
    \ ~= '' and last_char:gsub('^%S+$') ~= '' then\n    return true\n  end\n  return\
    \ false\nend", "  local last_char = string.sub(txt,-1)\n  return last_char:isalpha()\
    \ and last_char:sub(1,1) ~= '_'\nend", "  -- Check if txt is an empty string.\n\
    \  if not txt then return False end", "   -- your code here\nend\n</cell>\n<text>\n\
    Exercise: Write a function that returns True if the last character\nof a given\
    \ string is a vowel character (a, e, i, o, u) and False otherwise.\nExamples:",
  "    if not txt or #txt <= 0 then\n        return False\n    end\n    if txt:sub(1,\
    \ #txt) == \"\" then\n        return false\n    end\n    return string.match(string.sub(txt,\
    \ #txt, #txt, true, true), \".\") == nil\nend", "  -- Base Case\n  if txt:len()\
    \ < 2 then\n    return false\n  end\n  -- Find last character of a string\n  local\
    \ last_char = txt:sub(1,txt:len()-1)\n  -- Check if last character is alphabetical\
    \ and is not a part of a word\n  for w in string.gmatch(last_char, \"([a-z]+)\
    \ \") do\n    return false\n  end\n  -- Return True if last character is a letter,\
    \ False otherwise\n  return true\nend", "    if string.len(txt) <= 1 then\n  \
    \      return false\n    end\n    return string.sub(txt, string.len(txt)-1, string.len(txt))\
    \ == \" \" and\n           not string.match(txt, \"[%a_-z]\")\nend", "    local\
    \ result = true\n    if txt ~= nil then\n        local idx = #txt-1\n        if\
    \ idx > 0 then\n            if string.sub(txt, idx, idx) == \" \" then\n     \
    \           -- If the last character is a space, then\n                -- txt\
    \ doesn't end with a letter.\n                result = false\n            elseif\
    \ string.sub(txt, idx, idx) == \"_\" then\n                -- If the last character\
    \ is \"_\", then\n                -- txt doesn't end with a letter.\n        \
    \        result = false\n            elseif string.sub(txt, idx, idx) ~= string.sub(txt,\
    \ 1, idx) then\n                result = false\n            end\n        end\n\
    \    end\n    return result\nend", "    if txt ~= nil and txt ~= \"\" then\n \
    \       if txt:len() > 0 then\n            if txt:len() > 1 then\n           \
    \     if txt:sub(1, 1) == \"a\" or txt:sub(1, 1) == \"e\" or txt:sub(1, 1) ==\
    \ \"i\" or txt:sub(1, 1) == \"o\" or txt:sub(1, 1) == \"u\" or txt:sub(1, 1) ==\
    \ \"y\" then\n                    if txt:sub(txt:len() - 1, txt:len() - 1) ~=\
    \ \" \" then\n                        return true\n                    else\n\
    \                        return false\n                    end\n             \
    \   else\n                    if txt:sub(txt:len() - 1, txt:len() - 1) ~= \" \"\
    \ then\n                        return true\n                    else\n      \
    \                  return false\n                    end\n                end\n\
    \            else\n                return false\n            end\n        end\n\
    \    end\n    return false\nend", "    local last_letter = txt:sub( -1, 1 )\n\
    \    local is_last_letter = last_letter:ialpha()\n    -- check if last letter\
    \ isn't part of a word\n    -- checking is done because in some cases, the first\
    \ letter of a word is not\n    -- an alphabetical letter (e.g. in \"Apple pie\"\
    \ -> \"a\" and not \"A\")\n    if last_letter == \" \" then\n        return true\n\
    \    end\n    -- check if last letter isn't a part of a word\n    -- checking\
    \ is done because in some cases, the first letter of a word is not\n    -- an\
    \ alphabetical letter (e.g. in \"Apple pie\" -> \"a\" and not \"A\")\n    local\
    \ last_letter_is_word = false\n    local last_word_index = txt:find(\" \", 1,\
    \ true)\n    if last_word_index then\n        last_word_index = last_word_index\
    \ - 1\n        last_letter = txt:sub( last_word_index, 1 )\n        if last_letter:ialpha()\
    \ then\n            last_letter_is_word = true\n        else\n            -- to\
    \ handle last letter not being part of a word\n            -- the rest of the\
    \ text is put into a variable\n            -- (by \"txt:sub()\") and the function\
    \ is called\n            -- with that variable\n            local rest = txt:sub(\
    \ last_word_index )\n            check_if_last_char_is_a_letter(rest)\n      \
    \  end\n    end\n    return not last_letter_is_word\nend", "  return ((txt:sub(1,\
    \ #txt)) ~= \" \" and txt:sub(1, #txt) ~= \"\") and #(txt:sub(1, #txt):byte()\
    \ == #(txt:sub(1, #txt):sub(1, #txt):byte())) and (txt:sub(1, #txt):byte() ==\
    \ 65) and (txt:sub(1, #txt):byte() != 97) and (txt:sub(1, #txt):byte() != 122)\n\
    end", "    local lastChar = txt:sub(1, #txt)\n    local letter  = string.sub(lastChar,\
    \ 1, 1)\n    return lastChar ~= ' ' and letter ~= '!'\nend", "   for word in txt:gmatch(\"\
    %w+\") do\n      if not word:sub(1,1):upper() then\n         return false\n  \
    \    end\n   end\n   return true\nend", "  if txt == \"\" then\n    return false\n\
    \  end\n  local last_char = txt:sub(1, #txt)\n  local is_a_letter = false\n  if\
    \ last_char ~= 'a' and last_char ~= 'e' and last_char ~= 'i' and last_char ~=\
    \ 'o' and last_char ~= 'u' then\n    return false\n  end\n  local words = txt:gsub('(%S+)',\
    \ ' ')\n  if words == \"\" then\n    return false\n  end\n  for _, word in pairs(words)\
    \ do\n    if word ~= '' and word ~= \" \" then\n      if word:sub(#word - 1, #word)\
    \ ~= '^[a-zA-Z]' then\n        return false\n      end\n    end\n  end\n  return\
    \ is_a_letter\nend", "    local word = string.gsub(txt, \" \", \"\") -- Remove\
    \ spaces\n    return word[#word] == txt[#txt]\nend", "    local words = split(txt,\"\
    \ \")\n    for _, word in pairs(words) do\n        if last(word) ~= \"\" then\n\
    \            return false\n        end\n    end\n    return true\nend", "   if\
    \ txt ~= nil then\n      local word = string.gsub(txt, \" \", \"\")\n      if\
    \ word:sub(1, 1) ~= \"\" then\n         return true\n      end\n   end\n   return\
    \ false\nend", "    --  local result = true\n    --  for char in txt:gmatch(\"\
    [%z\\1-\\127]\") do result = false\n    --  return result\n    --end\n    -- return\
    \ true\n    --  local result = true\n    -- local is_last_char  = true\n    --\
    \ local is_last_char_word = true\n    --  local i = 0\n    -- local len = #txt\n\
    \    --  for i=1, len-1 do\n    --  local char = txt:sub(i,i)\n    --  if char\
    \ == \"A\" or char == \"a\" then\n    --  is_last_char  = false\n    --  is_last_char_word\
    \ = false\n    --  break -- don't continue to check if next char is a space\n\
    \    --  elseif char == \"Z\" or char == \"z\" then\n    --  is_last_char  = false\n\
    \    --  is_last_char_word = false\n    --  break -- don't continue to check if\
    \ next char is a space\n    --  elseif char == \"W\" or char == \"w\" then\n \
    \   --  is_last_char_word = true\n    --  break -- don't continue to check if\
    \ next char is a space\n    --  elseif char == \" \" then\n    --  is_last_char_word\
    \ = true\n    --  break -- don't continue to check if next char is a space\n \
    \   --  else\n    --  is_last_char_word = false\n    --  break -- don't continue\
    \ to check if next char is a space\n    --  end\n    --  end\n    --  if is_last_char_word\
    \ then\n    --  result = true\n    --else\n    --  result = false\n    --end\n\
    \    -- return result\n    --  return true\n    --  local result = true\n    --\
    \ local is_last_char  = true\n    -- local is_last_char_word = true\n    --  local\
    \ i = 0\n    -- local len = #txt\n    --  for i=1, len-1 do\n    --  local char\
    \ = txt:sub(i,i)\n    --  if char == \"A\" or char == \"a\" then\n    --  is_last_char\
    \  = false\n    --  is_last_char_word = false\n    --  break -- don't continue\
    \ to check if next char is a space\n    --  elseif char == \"Z\" or char == \"\
    z\" then\n    --  is_last_char  = false\n    --  is_last_char_word = false\n \
    \   --  break -- don't continue to check if next char is a space\n    --  elseif\
    \ char == \"W\" or char == \"w\" then\n    --  is_last_char_word = true\n    --\
    \  break -- don't continue to check if next char is a space\n    --  elseif char\
    \ == \" \" then\n    --  is_last_char_word = true\n    --  break -- don't continue\
    \ to check if next char is a space\n    --  else\n    --  is_last_char_", "  \
    \ -- If the string is empty, return False\n   if txt == \"\" then return false\
    \ end", "\tlocal txt = txt .. ' '\n\tlocal last_char = txt:sub(1,1)\n\tlocal txt\
    \ = txt:sub(2)\n\treturn (last_char ~= ' ' and txt ~= '') and #txt < 1\nend",
  "   if txt == nil then return false end\n   local word = string.sub(txt, -1, string.len(txt))\n\
    \   if not word then return false end\n   local first = string.sub(word, -1, 1)\n\
    \   return first:sub(1, 1) == \"a\" and first:sub(2, 1) == \"p\" and first:sub(3,\
    \ 1) == \"i\"\nend", "    local last_char = txt:sub(1, #txt)\n    return last_char\
    \ ~= \"\" and\n        (last_char ~= \" \" or\n         (last_char and not(last_char:sub(1,\
    \ #last_char)\n         == \"\\a\" or last_char:sub(1, #last_char)\n         ==\
    \ \"\\b\" or last_char:sub(1, #last_char)\n         == \"\\v\" or last_char:sub(1,\
    \ #last_char)\n         == \"\\f\")))\nend", "\t-- Initialize the flag\n\tlocal\
    \ flag = false\n\t-- If the input string is not empty\n\tif txt ~= '' then\n\t\
    \t-- If the last character is a letter\n\t\tif txt:sub(#txt, #txt) == string.sub(txt,\
    \ 1, #txt) then\n\t\t\t-- If the last character is not an alphabetical character\n\
    \t\t\t-- or is a part of a word\n\t\t\tif string.sub(txt, 1, #txt) ~= 'A' and\
    \ string.sub(txt, 1, #txt) ~= 'a' then\n\t\t\t\t-- Set the flag to True\n\t\t\t\
    \tflag = true\n\t\t\tend\n\t\tend\n\tend\n\treturn flag\nend", "    return txt:sub(1,\
    \ #txt - 1) ~= \" \" and txt:sub(1, #txt) ~= \" \" and txt:sub(1, #txt-1) ~= \"\
    \ \" and txt:sub(1, #txt+1) ~= \" \"\nend", "  local last_char = txt:sub((#txt),\
    \ 1)\n  local result = false\n  for i = #word, 1, -1 do\n    local first_letter\
    \ = word[i]\n    if first_letter == last_char then\n      result = true\n    \
    \  break\n    end\n  end\n  return result\nend", "  -- Check that the string is\
    \ not empty\n  if string.len(txt) == 0 then\n    return false\n  end\n  -- Get\
    \ the last character of the string\n  local last_char = string.sub(txt, -1)\n\
    \  -- Get the letters a-z\n  local letters = string.gsub(\"[a-z]\", \" \", \"\"\
    )\n  -- Check that the last character of the string is either an alphabetical\
    \ character,\n  --  or is not a part of a word\n  return string.find(letters,\
    \ last_char) or string.find(words[tonumber(last_char)], txt)\nend", "   -- If\
    \ there's nothing to check, then return the empty string.\n   -- If txt is an\
    \ empty string, then return True.\n   if txt == \"\" then\n      return true\n\
    \   end", "  return string.sub(txt, -1) == ' ' and \n         not string.find(string.gsub(txt,\
    \ ' $', ''), '[^A-Za-z]')\nend", "  local last_char = string.sub(txt, 1, string.len(txt)-1)\n\
    \  return string.byte(last_char) > 47 and string.byte(last_char) < 58 \nend",
  "    local char = txt:sub((#txt), 1)\n    if char == \" \" then\n        return\
    \ false\n    elseif char:lower() ~= 'a' and char:lower() ~= 'i' and char:lower()\
    \ ~= 'e' and char:lower() ~= 'o' and char:lower() ~= 'u' then\n        return\
    \ true\n    else\n        return false\n    end\nend", "    --print(\"checking\
    \ if last char in string is a letter\")\n    local txt = txt -- Convert it to\
    \ a string if necessary\n    if #txt == 0 then\n        return false -- String\
    \ is empty -- False if it is a word\n    end\n    if txt[#txt] ~= \"\" then\n\
    \        return true\n    end\n    local words = string.gmatch(txt, \"([^ ]+)\"\
    ) -- Split it on spaces -- Return array of words with non-space characters in\
    \ them -- Split each word on non space characters -- Return array of words with\
    \ non-space characters in them\n    if words[1] ~= \"\" then\n        return true\n\
    \    end\n    return false\nend", "   local word = txt:match(\"^([%a%p]+[%a%p]+[%a%p]+)$\"\
    )\n   return word ~= nil and word:sub(1, 1):match(\"[%a%p]+$\") ~= nil\nend",
  "  return txt and string.sub(txt, string.len(txt) - 1)  ~= \" \" and string.sub(txt,\
    \ string.len(txt) - 1) ~= \" \" and string.sub(txt, string.len(txt) - 1) ~= \"\
    \ \"\nend", "  -- Your code here\n  return true\nend", "  if txt == nil then\n\
    \    return false\n  end\n  local last_char = string.sub(txt, #txt - 1, 1)\n \
    \ return not string.find(string.gsub(txt, \" \", \"\"), \"[\" .. last_char ..\
    \ \"]\", 0)\nend", "    local last_char_idx = #txt - 1\n    local last_char =\
    \ txt:sub(last_char_idx, 1)\n    local last_char_words = nil\n    if last_char:sub(1,\
    \ 1) == \" \" then\n        last_char_words = txt:sub(last_char_idx + 1)\n   \
    \     last_char = last_char_words:sub(1, 1)\n    end\n    if last_char:sub(#last_char\
    \ + 1, 1) == \" \" then\n        last_char_words = txt:sub(last_char_idx + 1,\
    \ #last_char_idx + 1)\n        last_char = last_char_words:sub(1, 1)\n    end\n\
    \    local alpha = string.match(last_char, \"[%a%A]\")\n    if alpha ~= nil then\n\
    \        alpha = alpha ~= \".\"\n    end\n    return alpha\nend", "  -- Remove\
    \ leading and trailing spaces.\n  txt = txt:gsub(\"^%s*(.-)%s*$\", \"%1\")\n \
    \ -- Remove all non-alphabetic chars.\n  txt = txt:gsub(\"[^A-Za-z]\", \"\")\n\
    \  -- Check if the string is empty.\n  return txt ~= \"\"\nend", "    local words\
    \ = string.gmatch(txt, \"([^ ]+)\")\n    if words then\n        local word = words[1]\n\
    \        if word:sub(1, 1) ~= ' ' and word:sub(-1, -1) ~= ' ' then\n         \
    \   return true\n        else\n            return false\n        end\n    else\n\
    \        return false\n    end\nend", "    return string.sub(txt, string.len(txt)-1,\
    \ 1, string.len(txt)) == string.sub(txt, string.len(txt)-1, 1) and\n         \
    \  not string.find(txt, \" \") and\n           not string.find(txt, \".\")\nend",
  "   local last_char = txt:sub(1,-1)\n   return last_char == txt:sub(1,1) and ((last_char:gsub(\"\
    %w+\", \"\") == '') or last_char:sub(1,1) ~= ' ') end\nend", "  -- if input is\
    \ empty, return false\n  if(txt == \"\") then return False end\n  -- if last character\
    \ is not a letter, return false\n  if(txt[#txt] ~= letter) then return False end\n\
    \  -- if no space in word, return false\n  if(string.sub(txt, #txt, #txt) == \"\
    \ \") then return False end\n  -- return true\n  return True\nend", "    local\
    \ last_char_index = txt:len()\n    local last_char_tok = txt:sub(1, last_char_index)\n\
    \    local last_char_ascii = tonumber(last_char_tok)\n    if last_char_ascii <=\
    \ 64 then\n        return false\n    end\n    local is_last_char_was_a_word\n\
    \    is_last_char_was_a_word = true\n    local w\n    for w in words:gmatch(\"\
    [^ ]+\") do\n        is_last_char_was_a_word = false\n    end\n    return is_last_char_was_a_word\n\
    end", "    local last_char = string.sub( txt, -1, 1 )\n    return string.match(string.gsub(string.lower(last_char),\
    \ \"[aeiou]\", \"\"), \"%W\") == 0\nend", "   -- Initialize to the last character\
    \ in the string\n   local last_char_index = #txt", "   -- Initialize a variable\
    \ to store last char\n   local last_char = \"x\"\n   -- If the variable txt is\
    \ empty\n   if txt == nil then\n      return False\n   end\n   -- If the variable\
    \ txt is empty or only contains space\n   if txt == \"\" or #txt == 1 then\n \
    \     return False\n   end\n   -- Find the last character of the variable txt\n\
    \   last_char = txt:sub((#txt), #txt)\n   -- If the variable last_char is alphabetic\n\
    \   if #last_char == 1 and last_char >= 65 and last_char <= 90 then\n      return\
    \ False\n   end\n   -- If the variable last_char is numeric\n   if #last_char\
    \ == 2 and not (last_char >= 48 and last_char <= 57) then\n      return False\n\
    \   end\n   -- If the variable last_char is part of a word\n   if #last_char >\
    \ 1 then\n      -- Create a variable to store last char\n      local last_char_2\
    \ = last_char\n      -- If the variable txt is empty or only contains space\n\
    \      if txt == \"\" or #txt == 1 then\n         return False\n      end\n  \
    \    -- Find the last character of the variable txt\n      last_char_2 = txt:sub((#txt),\
    \ #txt)\n      -- If the variable last_char is alphabetic\n      if #last_char_2\
    \ == 1 and last_char_2 >= 65 and last_char_2 <= 90 then\n         return False\n\
    \      end\n      -- If the variable last_char is numeric\n      if #last_char_2\
    \ == 2 and not (last_char_2 >= 48 and last_char_2 <= 57) then\n         return\
    \ False\n      end\n      -- If the variable last_char is part of a word\n   \
    \   if #last_char_2 > 1 then\n         return False\n      end\n   end\n   return\
    \ True\nend\n</cell>\n<text>\nCreate a function named is_a_word_or_number that\
    \ returns True if the given string is a word or number. Otherwise, returns False.\
    \ This function should take a string as its only parameter.", "  -- First we check\
    \ that the input is a string\n  if type(txt) ~= 'string' then return end\n  --\
    \ Then we check if the last char of the input is a letter\n  return not (txt:sub(#txt)\
    \ == \" \" or txt:sub(#txt, #txt, -1) == \" \" or txt:sub(#txt, #txt, -1) == \"\
    \\n\")\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
