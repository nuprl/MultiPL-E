name: HumanEval_29_filter_by_prefix
language: lua
prompt: "-- Filter an input list of strings only for ones that start with a given\
  \ prefix.\n-- >>> filter_by_prefix([], 'a')\n-- []\n-- >>> filter_by_prefix(['abc',\
  \ 'bcd', 'cde', 'array'], 'a')\n-- ['abc', 'array']\nlocal function filter_by_prefix(strings,\
  \ prefix)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_prefix\n\
  \    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx',\
  \ 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return table.filter(function(value) return string.sub(value, 1, #prefix)\
    \ == prefix end, strings)\nend", "  return filter_by_func(strings, function(string)\n\
    \    return string.start == prefix\n  end)\nend", "  return strings:map(function(string)\n\
    \    return string == prefix and string or nil\n  end)\nend", "    local filtered_strings\
    \ = {}\n    for string in strings do\n        if string.startswith(prefix) then\n\
    \            table.insert(filtered_strings, string)\n        end\n    end\n  \
    \  return filtered_strings\nend", "  local new_strings = {}\n  for i, value in\
    \ ipairs(strings) do\n    if value:sub(1, #prefix) == prefix then\n      table.insert(new_strings,\
    \ value)\n    end\n  end\n  return new_strings\nend", "    if prefix and #prefix\
    \ > 0 then\n        local new = {}\n        for _, s in ipairs(strings) do\n \
    \           if s:sub(1, #prefix) == prefix then\n                new[#new + 1]\
    \ = s\n            end\n        end\n        return new\n    else\n        return\
    \ strings\n    end\nend", "    local filter_strings = {}\n    for _, str in pairs(strings)\
    \ do\n        if string.sub(str,1,prefix:len()) == prefix then\n            table.insert(filter_strings,\
    \ str)\n        end\n    end\n    return filter_strings\nend", "  local filter\
    \ = {}\n  for _, string in ipairs(strings) do\n    if string.sub(1, prefix) ==\
    \ prefix then\n      table.insert(filter, string)\n    end\n  end\n  return filter\n\
    end", "    local output = {}\n    for _, string in ipairs(strings) do\n      \
    \  if string.starts(prefix) then\n            table.insert(output, string)\n \
    \       end\n    end\n    return output\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis won't work as expected if any of the strings contains `prefix`.\n<|/\
    \ c |>\n<| a tags=lua,string,lua-table |>\nHere's another solution:\n<code>",
  "  return table.filter(\n      function(str)\n        return str:sub(1, #prefix)\
    \ == prefix\n      end,\n      strings\n  )\nend", "  for i, v in ipairs(strings)\
    \ do\n    if v:sub(1, #prefix) == prefix then\n      return strings[i]\n    end\n\
    \  end\n  return nil\nend", "  assert(type(prefix) == 'string')\n  local result\
    \ = {}\n  for _, str in pairs(strings) do\n    if str:sub(1, #prefix) == prefix\
    \ then\n      table.insert(result, str)\n    end\n  end\n  return result\nend",
  "  local results = {}\n  for _, string in ipairs(strings) do\n    if string.starts\
    \ with prefix then\n      table.insert(results, string)\n    end\n  end\n  return\
    \ results\nend", "   local result = {}\n   for _, item in ipairs(strings) do\n\
    \      if string.sub(item, 1, #prefix) == prefix then\n         table.insert(result,\
    \ item)\n      end\n   end\n   return result\nend\n</cell>\n<text>\nExercise 3:\
    \ Filtering Lists\nWrite a function that takes a list of strings and returns a\
    \ list of strings where the strings are all words longer than 5 characters.\n\
    >>> filter_by_length([], 5)\n[]\n>>> filter_by_length(['abc', 'bcd', 'cde', 'array'],\
    \ 5)\n['abc', 'bcd', 'cde', 'array']\n>>> filter_by_length(['abc', 'bcd', 'cde',\
    \ 'array'], 4)\n['abc', 'bcd', 'array']\n>>> filter_by_length(['abc', 'bcd', 'cde',\
    \ 'array'], 8)\n['abc', 'bcd', 'cde', 'array']\n>>> filter_by_length(['abc', 'bcd',\
    \ 'cde', 'array'], 1)\n['array']\nExercise 4: Filter by Length Function\nWrite\
    \ a function that takes a list or vector of strings and filters those strings\
    \ by length, returning the results as a list or vector.\n>>> filter_by_length_helper(['a',\
    \ 'b', 'c', 'd'], 2)\n['a', 'b', 'c']\n>>> filter_by_length_helper(['a', 'b',\
    \ 'c', 'd'], 5)\n['a', 'b', 'c', 'd']\nExercise 5: Filter By Length Function\n\
    Write a function that filters strings in a vector by a user-provided function.\n\
    >>> filter_by_length_helper(['a', 'b', 'c', 'd'], function (str) string.len(str)\
    \ == 5 end)\n['a', 'b', 'c', 'd']\nExercise 6: Filter By Length Function\nWrite\
    \ a function that filters strings in a list by a user-provided function.\n>>>\
    \ filter_by_length_helper(list, function (str) string.len(str) == 5 end)\n['a',\
    \ 'b', 'c', 'd']\nExercise 7: Filter By Length Function\nWrite a function that\
    \ filters strings in a list by a user-provided function and returns a new list\
    \ containing the results.\n>>> filter_by_length_helper(list, function (str) string.len(str)\
    \ == 5 end)\n['a', 'b', 'c', 'd']\nExercise 8: Filter By Length Function\nWrite\
    \ a function that filters strings in a list by a user-provided function and returns\
    \ a new list containing the results and the number of matches.\n>>> filter_by_length_helper(list,\
    \ function (str) string.len(str) == 5 end)\n['a', 'b', 'c', 'd', 6]\nExercise\
    \ 9: Filter By Length Function\nWrite a function that filters strings in a list\
    \ by a user-provided function and returns a new list containing the results and\
    \ the number of matches.\n>>> filter_by_length_helper(list, function (str) string.len(str)\
    \ == 5 end)\n['a', 'b', 'c', 'd', 6]\nExercise 10: Filter By Length Function\n\
    Write a ", "    return function(v)\n        if type(v) == \"string\" then\n  \
    \          return v:sub(prefix) ~= \"\"\n        end\n        return false\n \
    \   end\nend", "  local out = {}\n  for _, str in ipairs(strings) do\n    if str:sub(1,\
    \ #prefix) == prefix then\n      table.insert(out, str)\n    end\n  end\n  return\
    \ out\nend", "  if prefix and prefix ~= '' then\n    strings = strings:gmatch(prefix\
    \ .. '%w') -- Convert a list of strings to a list of words\n  end\n  local result\
    \ = {}\n  for _, str in ipairs(strings) do\n    if not str == '' then\n      result[#result\
    \ + 1] = str\n    end\n  end\n  return result\nend", "  assert(type(strings) ==\
    \ \"table\")\n  assert(type(prefix) == \"string\")\n  local ret = {}\n  for _,\
    \ str in ipairs(strings) do\n    if str:sub(1, #prefix) == prefix then\n     \
    \ table.insert(ret, str)\n    end\n  end\n  return ret\nend", "  -- This works\
    \ because the strings are already lowercased.\n  local result = {}\n  for _, s\
    \ in ipairs(strings) do\n    if s:sub(1, #prefix) == prefix then\n      table.insert(result,\
    \ s)\n    end\n  end\n  return result\nend", "  for _, s in ipairs(strings) do\n\
    \    if string.sub(s, 1, string.len(prefix)) ~= prefix then\n      table.remove(strings,\
    \ s)\n    end\n  end\n  return strings\nend", "  local result = {}\n  for _, str\
    \ in ipairs(strings) do\n    if str:sub(1, #prefix) == prefix then\n      table.insert(result,\
    \ str)\n    end\n  end\n  return result\nend", "  local output = {}\n  for _,\
    \ s in ipairs(strings) do\n    if string.sub(s, 1, string.len(prefix)) = prefix\
    \ then\n      table.insert(output, s)\n    end\n  end\n  return output\nend",
  "  if not prefix then\n    prefix = \"\"\n  elseif prefix ~= \"\" then\n    prefix\
    \ = prefix .. \"*\"\n  else\n    return nil\n  end", "  local results = {}\n \
    \ for _, str in ipairs(strings) do\n    if str:sub(1, #prefix) == prefix then\n\
    \      table.insert(results, str)\n    end\n  end\n  return results\nend", " \
    \   local out = {}\n    for _, v in ipairs(strings) do\n        if v == prefix\
    \ then table.insert(out, v) end\n    end\n    return out\nend", "  return filter(function(str)\
    \ str:sub(1, #prefix) == prefix end, strings)\nend", "  local result = {}\n  for\
    \ _, value in ipairs(strings) do\n    if value:sub(1, #prefix) == prefix then\n\
    \      result[#result + 1] = value\n    end\n  end\n  return result\nend", " \
    \ if prefix then\n    local filtered_strings = {}\n    for str in strings do\n\
    \      if str:sub(1, #prefix) == prefix then\n        table.insert(filtered_strings,\
    \ str)\n      end\n    end\n    return filtered_strings\n  else\n    return strings\n\
    \  end\nend", "    if prefix ~= '' then\n        local filtered = {}\n       \
    \ for s in strings do\n            if s:sub(1, #prefix) == prefix then\n     \
    \           table.insert(filtered, s)\n            end\n        end\n        return\
    \ filtered\n    else\n        return strings\n    end\nend", "    if not prefix\
    \ then return strings end\n    prefix = prefix .. '$'\n    local filtered = {}\n\
    \    for _, s in ipairs(strings) do\n        if s:sub(1, #prefix) == prefix then\n\
    \            table.insert(filtered, s)\n        end\n    end\n    return filtered\n\
    end", "  if #strings <= 0 then\n    return strings\n  end\n  if prefix ~= string.sub(prefix)\
    \ then\n    return strings\n  end\n  local i = 1\n  local results = {}\n  while\
    \ i <= #strings do\n    local substring = strings[i]\n    if substring == prefix\
    \ then\n      table.insert(results, strings[i])\n    else\n      i = i + 1\n \
    \   end\n  end\n  return results\nend", "    local result = {}\n    for _, str\
    \ in ipairs(strings) do\n        if str:sub(1, #prefix) == prefix then\n     \
    \       result[#result + 1] = str\n        end\n    end\n    return result\nend",
  "  local filtered_strings = {}\n  for i, v in ipairs(strings) do\n    if string.sub(v,\
    \ 1, len(prefix)) ~= prefix then\n      table.insert(filtered_strings, v)\n  \
    \  end\n  end\n  return filtered_strings\nend", "  assert(type(strings) == \"\
    table\")\n  assert(type(prefix) == \"string\")", "  local result = {}\n  for _,\
    \ item in ipairs(strings) do\n    if string.sub(item, 1, #prefix) == prefix then\n\
    \      table.insert(result, item)\n    end\n  end\n  return result\nend", "  \
    \  return filter_by_predicate(\n        function(x)\n            return x:sub(1,\
    \ prefix:len()) == prefix\n        end,\n        strings,\n    )\nend", "  assert(prefix\
    \ ~= '')\n  assert(type(strings) == 'table')\n  for _, string in ipairs(strings)\
    \ do\n    if string.starts(prefix) then\n      return string\n    end\n  end\n\
    \  return nil\nend", "  assert(type(strings) ~= 'table')\n  assert(type(prefix)\
    \ ~= 'string')\n  local result = {}\n  for _, string in ipairs(strings) do\n \
    \   if string.starts(prefix) then\n      table.insert(result, string)\n    end\n\
    \  end\n  return result\nend", "  local result = {}\n  for _, s in ipairs(strings)\
    \ do\n    if string.sub(s, 1, prefix:len()) == prefix then\n      table.insert(result,\
    \ s)\n    end\n  end\n  return result\nend", "    if type(strings) ~= 'table'\
    \ then\n        return nil\n    end\n    \n    local prefix_pos = #prefix\n  \
    \  \n    if prefix then\n        if prefix_pos <= 0 then\n            return nil\n\
    \        end\n        \n        -- Check if given prefix is at the first position\
    \ of the given strings\n        local is_prefix_at_first\n        for _, string\
    \ in ipairs(strings) do\n            is_prefix_at_first = (prefix_pos == 1)\n\
    \            if is_prefix_at_first then\n                -- If given prefix is\
    \ not at the first position of the given strings, skip it (it can be at different\
    \ position)\n                is_prefix_at_first = prefix_pos == #string\n    \
    \        end\n            \n            if is_prefix_at_first then\n         \
    \       if prefix == string then\n                    -- If given prefix matches\
    \ the current string, return current string (we don't have to return all strings\
    \ that don't start with the given prefix)\n                    return string\n\
    \                else\n                    -- If given prefix doesn't match the\
    \ current string, skip current string\n                    continue\n        \
    \        end\n            end\n            \n            -- If given prefix is\
    \ not at the first position of the given strings, return current string (the one\
    \ that starts with the given prefix)\n            return string\n        end\n\
    \    else\n        -- If no prefix was given, return all strings\n        return\
    \ strings\n    end\n    \n    return nil\nend", "    local output = {}\n    for\
    \ _, str in ipairs(strings) do\n        if str:sub(1, #prefix) == prefix then\n\
    \            table.insert(output, str)\n        end\n    end\n    return output\n\
    end", "  for i, value in ipairs(strings) do\n    if string.sub(value, 1, #prefix)\
    \ == prefix then\n      table.remove(strings, i)\n    end\n  end\n  return strings\n\
    end", "  local result = {}\n  for _, s in ipairs(strings) do\n    if s:sub(1,\
    \ #prefix) == prefix then\n      table.insert(result, s)\n    end\n  end\n  return\
    \ result\nend", "    local function match(s, p)\n        if string.sub(s, 1, #p)\
    \ == p then\n            return true\n        end\n        return false\n    end\n\
    \    return filter(strings, match, \"%s\")\nend", "   if #strings < 1 then\n \
    \     return nil\n   end", "  if prefix then\n    local results = {}\n    for\
    \ i, str in ipairs(strings) do\n      if str:sub(1, #prefix) == prefix then\n\
    \        results[#results + 1] = str\n      end\n    end\n    return results\n\
    \  else\n    return strings\n  end\nend", "  local new_strings = {}\n  for _,\
    \ string in ipairs(strings) do\n    if string.startswith(prefix) then\n      table.insert(new_strings,\
    \ string)\n    end\n  end\n  return new_strings\nend", "    local result = {}\n\
    \    for _, string in ipairs(strings) do\n        if string.startswith(prefix)\
    \ then\n            result[#result + 1] = \"'\" .. string .. \"'\"\n        end\n\
    \    end\n    return result\nend", "  assert(type(prefix) == \"string\")\n  return\
    \ filter_by_predicate(\n    function(s) return s:sub(1, #prefix) == prefix end,\n\
    \    strings)\nend", "    if type(strings) ~= 'table' then\n        return nil\n\
    \    end", "  local result = {}\n  for _, str in ipairs(strings) do\n    if not\
    \ str:sub(#prefix) ~= prefix then break end\n    result[#result + 1] = str\n \
    \ end\n  return result\nend", "  local result = {}\n  for _, str in ipairs(strings)\
    \ do\n    if string.sub(str, 1, #prefix) == prefix then\n      table.insert(result,\
    \ str)\n    end\n  end\n  return result\nend", "  return filter(\n    function(string)\n\
    \      return string.starts_with(prefix)\n    end,\n    strings)\nend", "    return\
    \ filter(\n        function(string) return string.startswith prefix,\n       \
    \ strings\n    )\nend", "   if not prefix then return strings end\n   return table.filter(\n\
    \      function(a) return string.sub(prefix, 1, #a) == a end,\n      strings)\n\
    end", "    local ret = {}\n    for str in strings do\n        if str:sub(1, #prefix)\
    \ == prefix then\n            table.insert(ret, str)\n        end\n    end\n \
    \   return ret\nend\n</cell>\n<text>\nFiltering strings in a table", "  local\
    \ result = {}\n  for _, string in ipairs(strings) do\n    if string.startswith(prefix)\
    \ then\n      table.insert(result, string)\n    end\n  end\n  return result\n\
    end", "  local result = {}\n  for _, str in pairs(strings) do\n    if str:sub(1,\
    \ #prefix) == prefix then\n      table.insert(result, str)\n    end\n  end\n \
    \ return result\nend", "  local ret = {}\n  for _, string in ipairs(strings) do\n\
    \    local _, index = string.find(string, \"^\" .. prefix)\n    if index == 0\
    \ then\n      table.insert(ret, string)\n    end\n  end\n  return ret\nend", " \
    \ for _, string in ipairs(strings) do\n    if string.startswith(prefix) then\n\
    \      return string\n    end\n  end\n  return nil\nend", "  local filtered_strings\
    \ = {}\n  for _, string in ipairs(strings) do\n    if string.startswith(prefix)\
    \ then\n      table.insert(filtered_strings, string)\n    end\n  end\n  return\
    \ filtered_strings\nend", "  local _table, _n = select('#', _, nil)\n  if strings\
    \ and prefix and _n > 0 then\n    local filtered_strings = {}\n    for _, string\
    \ in ipairs(strings) do\n      if string.start == prefix then\n        filtered_strings\
    \ = filtered_strings or {}\n        table.insert(filtered_strings, string)\n \
    \     end\n    end\n    return filtered_strings\n  else\n    return strings\n\
    \  end\nend", "  if prefix then\n    return function(str)\n      str = str:gsub('%%%s*'\
    \ % prefix, '')\n      return str and str:match('^%s*$') ~= nil\n    end\n  else\n\
    \    return function(str)\n      return str:match('^%s*$') ~= nil\n    end\n \
    \ end\nend", "  local result = {}\n  for _, str in ipairs(strings) do\n    if\
    \ str:sub(1, #prefix) == prefix then\n      table.insert(result, str)\n    end\n\
    \  end\n  return result\nend", "    if prefix then prefix = prefix .. '^' end\n\
    \    local filtered_strings = strings:gmatch(prefix)\n    if not filtered_strings\
    \ then\n        return strings\n    end", "  if prefix then\n    prefix = prefix\
    \ .. ''\n    local filtered = {}\n    for _, v in ipairs(strings) do\n      if\
    \ v:find(prefix) == 1 then\n        table.insert(filtered, v)\n      end\n   \
    \ end\n    return filtered\n  else\n    return strings\n  end\nend", "    local\
    \ result = {}\n    for _, s in ipairs(strings) do\n        if s:sub(1, #prefix)\
    \ == prefix then\n            result[#result + 1] = s\n        end\n    end\n\
    \    return result\nend", "  if prefix ~= prefix then\n    return {}\n  end\n\
    \  local result = {}\n  for _, s in ipairs(strings) do\n    if string.sub(s, 1,\
    \ prefix) == prefix then\n      table.insert(result, s)\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for _, str in ipairs(strings) do\n   \
    \ if string.sub(str, 1, prefix:len()) == prefix then\n      table.insert(result,\
    \ str)\n    end\n  end\n  return result\nend", "  -- If the prefix is missing,\
    \ return the original list.\n  prefix = prefix or ''", "  return map(\n    function(string)\n\
    \      -- Skip strings starting with our prefix.\n      if not string.starts with\
    \ prefix then\n        return nil\n      end", "   local results = {}\n   for\
    \ _, str in ipairs(strings) do\n      if str:sub(1, #prefix) == prefix then\n\
    \         table.insert(results, str)\n      end\n   end\n   return results\nend",
  '    if not strings or not prefix then return strings end', "  if prefix and prefix\
    \ ~= '' then\n    local prefix = prefix .. ''\n    local filter = function(s)\n\
    \      return s:sub(1, #prefix) == prefix\n    end\n    return filter(strings)\
    \ or filter(table.sort(strings))\n  end\n  return strings\nend", "  assert(type(strings)\
    \ == 'table', 'Invalid input type. Expected table.')\n  assert(type(prefix) ==\
    \ 'string', 'Invalid input type. Expected string.')\n  return filter_by_prefix_aux(strings,\
    \ prefix, false, true)\nend", "    local function matcher(s)\n        return s:sub(1,\
    \ #prefix) == prefix end\n    return filter2(matcher, strings)\nend", "  local\
    \ results = {}\n  for _, string in ipairs(strings) do\n    local index = string.find(prefix,\
    \ 1, true)\n    if index == 0 then\n      results[#results + 1] = string\n   \
    \ end\n  end\n  return results\nend", "  local filtered = {}\n  for _, string\
    \ in ipairs(strings) do\n    if string.prefix(prefix) then\n      table.insert(filtered,\
    \ string)\n    end\n  end\n  return filtered\nend", "  if prefix and #prefix >\
    \ 0 then\n    local index = 1\n    local results = {}\n    for string in strings\
    \ do\n      if index:sub(1,#prefix) == prefix then\n        results[#results+1]\
    \ = string\n        index = index + #prefix + 1\n      end\n    end\n    return\
    \ results\n  else\n    return strings\n  end\nend", "  assert(type(strings) ==\
    \ \"table\")\n  assert(type(prefix) == \"string\")\n  local filtered = {}\n  for\
    \ _, string in ipairs(strings) do\n    if string.starts(prefix) then\n      table.insert(filtered,\
    \ string)\n    end\n  end\n  return filtered\nend", "    local prefix_len = #prefix\n\
    \    local strings_with_prefix = {}\n    for _, str in ipairs(strings) do\n  \
    \      local str_len = #str\n        if str_len >= prefix_len then\n         \
    \   strings_with_prefix[str_len > prefix_len and str:sub(1, prefix_len) or str]\
    \ = true\n        end\n    end\n    return table.concat(strings_with_prefix, \"\
    ^\")\nend", "  local res = {}\n  for _, string in ipairs(strings) do\n    if string.startswith(prefix)\
    \ then\n      table.insert(res, string)\n    end\n  end\n  return res\nend", " \
    \ assert(type(strings) ~= 'table', 'Argument strings must be a table')\n  assert(type(prefix)\
    \ ~= 'string', 'Argument prefix must be a string')\n  assert(prefix ~= '', 'Argument\
    \ prefix must be a non-empty string')\n  -- If the list is empty, return an empty\
    \ list.\n  -- If the list is non-empty, return a list of all strings that start\n\
    \  -- with prefix, and in order, except for the prefix itself.\n  return strings:gmatch('^'\
    \ .. prefix .. '([^' .. prefix .. '*]+)') or { }\nend", "  local result = {}\n\
    \  for _, s in ipairs(strings) do\n    if s:sub(1, #prefix) == prefix then\n \
    \     table.insert(result, s)\n    end\n  end\n  return result\nend", "   if not\
    \ strings then return nil end\n   local new_strings = {}\n   for i = 1, #strings\
    \ do\n      if string.sub(strings, i, i+#prefix) == prefix then\n         table.insert(new_strings,\
    \ strings[i])\n      end\n   end\n   return new_strings\nend", "    if prefix\
    \ then\n        local filtered_strings = terralib.newlist()\n        for _, string\
    \ in ipairs(strings) do\n            if string.startswith(prefix) then\n     \
    \           filtered_strings:insert(string)\n            end\n        end\n  \
    \      return filtered_strings\n    else\n        return strings\n    end\nend",
  "  for _, v in ipairs(strings) do\n    if string.sub(v, 1, string.len(prefix)) ==\
    \ prefix then\n      table.insert(strings, v)\n    end\n  end\n  return strings\n\
    end", "  local result = {}\n  for i, value in ipairs(strings) do\n    if string.sub(value,\
    \ 1, #prefix) == prefix then\n      table.insert(result, value)\n    end\n  end\n\
    \  return result\nend", "    local new_strings = {}\n    for _, s in ipairs(strings)\
    \ do\n        if s:sub(1, #prefix) == prefix then\n            new_strings[#new_strings\
    \ + 1] = s\n        end\n    end\n    return new_strings\nend", "  return select(2,\
    \ map(function(str) return str:sub(1, len(prefix)) end,\n                    \
    \ strings))\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n  \
    \  if string.sub(s, 1, string.len(prefix)) == prefix then\n      table.insert(result,\
    \ s)\n    end\n  end\n  return result\nend", "  local result = {}\n  for i, str\
    \ in ipairs(strings) do\n    if str:sub(1, #prefix) == prefix then\n      table.insert(result,\
    \ str)\n    end\n  end\n  return result\nend", "    local result = {}\n    for\
    \ _, string in pairs(strings) do\n        if string.startswith(prefix) then\n\
    \            result[#result + 1] = string\n        end\n    end\n    return result\n\
    end", "    local prefix_len = #prefix\n    local output = { }\n    for _, s in\
    \ ipairs(strings) do\n        if s:sub(1, prefix_len) == prefix then\n       \
    \     table.insert(output, s)\n        end\n    end\n    return output\nend\n\
    _G.filter_by_prefix = filter_by_prefix", "  local result = {}\n  for i = 1, #strings\
    \ do\n    if string.sub(strings[i], 1, #prefix) == prefix then\n      table.insert(result,\
    \ strings[i])\n    end\n  end\n  return result\nend", "  local results = {}\n\
    \  for _,s in ipairs(strings) do\n    if s:sub(1,#prefix) == prefix then\n   \
    \   table.insert(results, s)\n    end\n  end\n  return results\nend", "    local\
    \ results = {}\n    for _, string in pairs(strings) do\n        if string.starts(prefix)\
    \ then\n            table.insert(results, string)\n        end\n    end\n    return\
    \ results\nend\nfilter_by_prefix = Curry._1(filter_by_prefix, 2)", '  local list
    = { }', "  return list.filter_by_function(function(string)\n    string.startswith(prefix)\n\
    \  end, strings)\nend", "  if prefix and prefix ~= '' then\n    local pattern\
    \ = \"^\" .. prefix\n    return map(\n      function(x) return x:match(pattern)\
    \ .. '\\2' },\n      strings\n    )\n  else\n    return strings\n  end\nend",
  "  local result = {}\n  for _, string in ipairs(strings) do\n    if string.sub(1,\
    \ #prefix) == prefix then\n      table.insert(result, string)\n    end\n  end\n\
    \  return result\nend", "  assert(type(strings) == \"table\", \"strings should\
    \ be a table\")\n  assert(type(prefix) == \"string\", \"prefix should be a string\"\
    )\n  local results = {}\n  for _, str in ipairs(strings) do\n    if str:sub(1,\
    \ #prefix) == prefix then\n      table.insert(results, str)\n    end\n  end\n\
    \  return results\nend", "  local new_strings = {}\n  for _, str in ipairs(strings)\
    \ do\n    if str:sub(1, #prefix) == prefix then\n      table.insert(new_strings,\
    \ str)\n    end\n  end\n  return new_strings\nend\nfilter_by_prefix = terralib.memoize(filter_by_prefix)",
  "  if prefix == nil then\n    return nil\n  end", "    local result = {}\n    for\
    \ index, value in ipairs(strings) do\n        if value:sub(1, #prefix) == prefix\
    \ then\n            result[#result + 1] = value\n        end\n    end\n    return\
    \ result\nend", "  local r = {}\n  for _, string in ipairs(strings) do\n    if\
    \ string.starts_with(prefix) then\n      table.insert(r, string)\n    end\n  end\n\
    \  return r\nend", "  if #strings <= 0 then\n    return strings\n  end\n  local\
    \ prefix_len = #prefix\n  assert(prefix_len <= #strings, \"Prefix length must\
    \ be <= #strings\")\n  local filtered_strings = terralib.newlist()\n  for i =\
    \ 1, #strings do\n    if string.sub(tostring(strings[i]), prefix_len, #strings[i])\
    \ == prefix then\n      filtered_strings:insert(strings[i])\n    end\n  end\n\
    \  return filtered_strings\nend", "    if prefix and #prefix > 0 then\n      \
    \  local result = {}\n        for _, string in ipairs(strings) do\n          \
    \  if string.startswith(prefix) then\n                result[#result + 1] = string\n\
    \            end\n        end\n        return result\n    else\n        return\
    \ strings\n    end\nend", "  -- Create a dictionary to hold all of the unique\
    \ prefixes and whether or not they have been used.\n  local prefix_set = {}\n\
    \  for _, str in ipairs(strings) do\n    prefix_set[str:sub(1, #prefix+1)] = true\n\
    \  end\n  -- Build a filtered list of unique prefixes from the original list.\n\
    \  local filtered = {}\n  for _, str in ipairs(strings) do\n    if prefix_set[str:sub(1,\
    \ #prefix+1)] then\n      table.insert(filtered, str)\n    end\n  end\n  return\
    \ filtered\nend", "  local result = {}\n  for _, str in ipairs(strings) do\n \
    \   if str:sub(1, #prefix) == prefix then\n      table.insert(result, str)\n \
    \   end\n  end\n  return result\nend", "  return function()\n    if prefix then\n\
    \      local result = {}\n      for _, s in ipairs(strings) do\n        if s:sub(1,\
    \ #prefix) == prefix then\n          table.insert(result, s)\n        end\n  \
    \    end\n      return result\n    end\n    return strings\n  end\nend", "   \
    \ local prefix_len = #prefix\n    local out_strings = {}\n    for i, str in ipairs(strings)\
    \ do\n        local str_len = #str\n        if str_len > prefix_len then\n   \
    \         out_strings[#out_strings + 1] = str\n        end\n    end\n    return\
    \ out_strings\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n\
    \    if s:sub(1, #prefix) == prefix then\n      table.insert(result, s)\n    end\n\
    \  end\n  return result\nend", "    local function doIt(t)\n        local ok,\
    \ s = pcall(function () return string.sub(t, 1, prefix) end)\n        return ok\
    \ and s or nil\n    end\n    return strings:map(doIt)\nend", "    local results\
    \ = {}\n    for _, str in ipairs(strings) do\n        if str:sub(1, #prefix) ==\
    \ prefix then\n            table.insert(results, str)\n        end\n    end\n\
    \    return results\nend", "  return filter(\n    function(str)\n      return\
    \ str:sub(1, #prefix) == prefix end,\n    strings\n  )\nend", "  local result\
    \ = {}\n  local i = 1\n  for string in strings do\n    if string.startswith(prefix)\
    \ then\n      result[i] = string\n      i = i + 1\n    end\n  end\n  return result\n\
    end", "    local filtered = {}\n    for _, s in ipairs(strings) do\n        if\
    \ s:sub(1, #prefix) == prefix then\n            table.insert(filtered, s)\n  \
    \      end\n    end\n    return filtered\nend", "    if not prefix then prefix\
    \ = '' end\n    local new_strings = {}\n    for _, s in ipairs(strings) do\n \
    \       if s:sub(1, #prefix) == prefix then\n            new_strings[#new_strings\
    \ + 1] = s\n        end\n    end\n    return new_strings\nend", "    local output\
    \ = {}\n    local pattern = '^' .. prefix\n    for i,v in ipairs(strings) do\n\
    \        if v:match(pattern) then\n            output[#output + 1] = v\n     \
    \   end\n    end\n    return output\nend", "  assert(type(prefix) == 'string')\n\
    \  return assert(filter_list(strings, function(str)\n    return string.sub(str,\
    \ 1, string.len(prefix)) ~= prefix\n  end))\nend", "  local result = {}\n  for\
    \ _, str in ipairs(strings) do\n    if str:sub(1, #prefix) == prefix then\n  \
    \    table.insert(result, str)\n    end\n  end\n  return result\nend", "    local\
    \ results = {}\n    for _, str in ipairs(strings) do\n        if str:sub(1, #prefix)\
    \ == prefix then\n            table.insert(results, str)\n        end\n    end\n\
    \    return results\nend", "    return map(\n        function(string) return string.sub(1,\
    \ #prefix + 1) end,\n        filter(\n            function(string) return string.sub(#prefix\
    \ + 1, 1, #string) == prefix end,\n            strings))\nend", "   for _, string\
    \ in ipairs(strings) do\n      if string.starts with prefix then\n         return\
    \ true\n      end\n   end\n   return false\nend", "  local function match(s, prefix)\n\
    \    return (s:match('^' .. prefix) == prefix)\n  end", "  local filtered_strings\
    \ = {}\n  for _, v in ipairs(strings) do\n    if v:sub(1, #prefix) == prefix then\n\
    \      table.insert(filtered_strings, v)\n    end\n  end\n  return filtered_strings\n\
    end", "  local function is_prefix(str)\n    return (str:len() > #prefix) and str:sub(1,\
    \ #prefix):lower() == prefix\n  end\n  return filter(strings, function(str)\n\
    \    return is_prefix(str)\n  end)\nend", "    if strings == nil then\n      \
    \  return nil\n    end", "    local result = {}\n    for _, string in ipairs(strings)\
    \ do\n        if string.starts(prefix) then\n            table.insert(result,\
    \ string)\n        end\n    end\n    return result\nend", "    local res = {}\n\
    \    for _,s in ipairs(strings) do\n        if string.sub(s, 1, string.len(prefix))\
    \ ~= prefix then\n            table.insert(res, s)\n        end\n    end\n   \
    \ return res\nend", "    local filtered_strings = {}\n    for i, string in ipairs(strings)\
    \ do\n        if string.sub(s, 1, #prefix) == prefix then\n            table.insert(filtered_strings,\
    \ string)\n        end\n    end\n    return filtered_strings\nend", "    local\
    \ result = {}\n    for _, s in ipairs(strings) do\n        if s:sub(1, #prefix)\
    \ == prefix then\n            table.insert(result, s)\n        end\n    end\n\
    \    return result\nend", "  local function is_prefix(x, y)\n    return string.sub(y,\
    \ 1, #x) == prefix\n  end", "  local result = {}\n  for _, string in ipairs(strings)\
    \ do\n    if string.sub(1, #prefix) == prefix then\n      table.insert(result,\
    \ string)\n    end\n  end\n  return result\nend", "  local prefix = prefix or\
    \ ''\n  local result = {}\n  for _, s in ipairs(strings) do\n    if s:sub(1, #prefix)\
    \ == prefix then\n      table.insert(result, s)\n    end\n  end\n  return result\n\
    end", "  local newStrings = {}\n  for _, str in ipairs(strings) do\n    if string.sub(str,\
    \ 1, string.len(prefix)) = prefix then\n      table.insert(newStrings, str)\n\
    \    end\n  end\n  return newStrings\nend", "    if prefix then\n        local\
    \ i = 0\n        local out = {}\n        for s in strings do\n            if s:sub(1,#prefix)\
    \ == prefix then\n                table.insert(out, s)\n            end\n    \
    \        i = i + 1\n        end\n        return filter_by_prefix(out, prefix)\
    \ -- Repeatedly call filter_by_prefix with the tail of the list to continue matching\
    \ after the end of the prefix.\n    end\n    return strings\nend", "  return filter(\n\
    \    function(str)\n      return str:sub(1, #prefix) == prefix and str ~= nil\n\
    \    end,\n    strings\n  )\nend", "  local result = {}\n  for _, v in ipairs(strings)\
    \ do\n    if v:sub(1, #prefix) == prefix then\n      table.insert(result, v)\n\
    \    end\n  end\n  return result\nend", "  assert(type(prefix) == \"string\")\n\
    \  local filtered_strings = {}\n  for _, s in ipairs(strings) do\n    if type(s)\
    \ ~= \"string\" then\n      filtered_strings[#filtered_strings + 1] = s\n    elseif\
    \ string.sub(s, 1, #prefix) == prefix then\n      filtered_strings[#filtered_strings\
    \ + 1] = s\n    end\n  end\n  return filtered_strings\nend", "    local function\
    \ prefixed_string(s)\n        return s:sub(1, #prefix) == prefix\n    end\n  \
    \  local function prefixed_strings(strings)\n        return filter(prefixed_string,\
    \ strings)\n    end\n    return prefixed_strings(strings)\nend", "    if not prefix\
    \ then\n        return strings\n    end\n    local prefix_len = len(prefix)\n\
    \    local new_strings = terralib.newlist()\n    for i, s in ipairs(strings) do\n\
    \        if s:sub(1, prefix_len) == prefix then\n            new_strings[i] =\
    \ s\n        end\n    end\n    return new_strings\nend", "    local rv = {}\n\
    \    for _, s in ipairs(strings) do\n        if s:sub(1, prefix:len()) == prefix\
    \ then\n            table.insert(rv, s)\n        end\n    end\n    return rv\n\
    end", "    local function match(pattern)\n        return string.match(pattern,\
    \ prefix) ~= nil\n    end\n    local function filter(string)\n        return match(string)\
    \ and string.sub(string, 1, #prefix) == prefix\n    end\n    return filter or\
    \ {}\nend", "  local prefix = prefix:lower()\n  local ret = {}\n  for _, str in\
    \ ipairs(strings) do\n    if str:sub(1, #prefix) == prefix then\n      table.insert(ret,\
    \ str)\n    end\n  end\n  return ret\nend", "    return strings:filter(function(x)\n\
    \        return x == prefix or x:sub(1, #prefix) == prefix\n    end)\nend", " \
    \ if not prefix then\n    return strings\n  else\n    local new_strings = terralib.newlist()\n\
    \    for i = 1, #strings do\n      if strings[i] and strings[i] >= prefix then\n\
    \        new_strings:insert(strings[i])\n      end\n    end\n    return new_strings\n\
    \  end\nend", "    if prefix then\n        local filtered = {}\n        for _,\
    \ str in ipairs(strings) do\n            if string.sub(str, 1, string.len(prefix))\
    \ == prefix then\n                table.insert(filtered, str)\n            end\n\
    \        end\n        return filtered\n    end\n    return strings\nend", "  local\
    \ result = {}\n  for i = 1, #strings do\n    if string.sub(strings[i], 1, #prefix)\
    \ == prefix then\n      table.insert(result, strings[i])\n    end\n  end\n  return\
    \ result\nend", "  local function is_start(str)\n    return str:sub(1, #prefix)\
    \ == prefix\n  end\n  local filtered_strings = terralib.newlist()\n  for _, str\
    \ in ipairs(strings) do\n    if is_start(str) then\n      filtered_strings:insert(str)\n\
    \    end\n  end\n  return filtered_strings\nend", "  local filtered_strings =\
    \ {}\n  for _, str in pairs(strings) do\n    if str:sub(#prefix) == prefix then\n\
    \      table.insert(filtered_strings, str)\n    end\n  end\n  return filtered_strings\n\
    end\n</cell>\n<cell>", "  if prefix then\n    prefix = prefix:lower() -- Avoid\
    \ case issues\n    local result = {}\n    for _, item in ipairs(strings) do\n\
    \      if item:sub(1, #prefix):lower() == prefix then\n        result[#result\
    \ + 1] = '' -- Preserve empty prefix\n      else\n        result[#result + 1]\
    \ = item\n      end\n    end\n    return result\n  else\n    return strings\n\
    \  end\nend", "    local function match(string, prefix)\n        return string.sub(string,\
    \ 1, prefix:len()) == prefix\n    end\n    return filter2(strings, function(string,\
    \ i)\n        return match(string, prefix)\n    end)\nend", "    local function\
    \ filter_func(string)\n        return string.starts_with(prefix)\n    end\n  \
    \  return filter(strings, filter_func)\nend", "    local result = {}\n    for\
    \ i, value in ipairs(strings) do\n        if string.sub(value, 1, string.len(prefix))\
    \ == prefix then\n            result[#result + 1] = value\n        end\n    end\n\
    \    return result\nend", "  -- Fast path if no prefix provided\n  if not prefix\
    \ then\n    return strings\n  else\n    local prefix_strings = { prefix }\n  \
    \  prefix_strings:insertall(strings)\n    return prefix_strings\n  end\nend",
  "    local result = {}\n    for i, v in ipairs(strings) do\n        if v:sub(1,\
    \ #prefix) == prefix then\n            result[#result + 1] = v\n        end\n\
    \    end\n    return result\nend", "    return filter(\n        function (s)\n\
    \            return string.sub(s, '^' .. prefix) == prefix\n        end,\n   \
    \     strings)\nend", "  local function match(str)\n    str = str:lower()\n  \
    \  return str:sub(1, #prefix) == prefix\n  end\n  return filter_list(\n      strings,\n\
    \      function(str)\n        return match(str)\n      end)\nend", "    local\
    \ result = {}\n    for _, string in ipairs(strings) do\n        if string.startswith(prefix)\
    \ then\n            table.insert(result, string)\n        end\n    end\n    return\
    \ result\nend", "  if prefix then\n    return filter_by_prefix(\n        function\
    \ (s) return s:sub(1, #prefix) == prefix end,\n        prefix)\n  end\n  return\
    \ strings or nil\nend", "  assert(type(prefix) == 'string', 'Prefix should be\
    \ a string')\n  local prefix_len = #prefix\n  return filter(function(str)\n  \
    \  return str:sub(1, prefix_len) == prefix\n  end, strings)\nend", "  assert(type(strings)\
    \ == 'table', 'Input list is not a table')\n  assert(type(prefix) == 'string',\
    \ 'Prefix is not a string')\n  local filtered = {}\n  for _, str in pairs(strings)\
    \ do\n    if str:sub(1, #prefix) == prefix then\n      table.insert(filtered,\
    \ str)\n    end\n  end\n  return filtered\nend\nfilter_by_prefix = setmetatable(filter_by_prefix,\
    \ {__index = function(t,k) error(\"filter_by_prefix:missing\",2) end})", "   \
    \ if prefix and #prefix > 0 then\n        local first_prefix = prefix\n      \
    \  for i = 1, #strings do\n            if strings[i]:sub(1, #prefix) == prefix\
    \ then\n                return strings[i]\n            end\n        end\n    end\n\
    \    return \"\"\nend", "    if not prefix then return strings end\n    local\
    \ prefix_len = (prefix or \"\"):len()\n    local new_strings = {}\n    for _,\
    \ str in ipairs(strings) do\n        local str_len = (str or \"\"):len()\n   \
    \     if str_len == prefix_len then\n            new_strings[#new_strings + 1]\
    \ = (str)\n        end\n    end\n    return new_strings\nend", "   for _, string\
    \ in ipairs(strings) do\n      if string.find(prefix, 1, true) then\n        \
    \ return string\n      end\n   end\n   return {}\nend", "  assert(type(strings)\
    \ == 'table', 'First argument must be an array')\n  assert(type(prefix) == 'string',\
    \ 'Second argument must be a string')", "  local _iterator, _i, _len\n  local\
    \ result = {}\n  for _i, _len = #strings, 1, -1 do\n    local str = strings[_i]\n\
    \    if not str:sub(#prefix, #str) == prefix then\n      result[#result + 1] =\
    \ str\n    end\n  end\n  return result\nend", '    if not prefix then return strings
    end', "  return map(function(s) return s:sub(1, #prefix) ~= prefix and s or ''\
    \ end, strings)\nend", "    local result = {}\n    for _, str in ipairs(strings)\
    \ do\n        if str:sub(1, #prefix) == prefix then\n            result[#result\
    \ + 1] = tostring(str)\n        end\n    end\n    return result\nend", "  local\
    \ result = {}\n  for _, str in pairs(strings) do\n    if str:sub(1, #prefix) ==\
    \ prefix then\n      table.insert(result, str)\n    end\n  end\n  return result\n\
    end", "   local results = {}\n   for _, s in ipairs(strings) do\n      assert(type(s)\
    \ == 'string')\n      assert(p:len(s) > 0)\n      assert(p:len(prefix) <= p:len(s))\n\
    \      if not p:startswith(prefix, s) then\n         results[#results + 1] = p:sub(p:len(prefix),\
    \ p:len(s))\n      end\n   end\n   return results\nend", "  if #strings == 0 then\n\
    \    return strings or nil\n  end", "  if type(strings) ~= 'table' then return\
    \ strings end\n  local prefix = prefix or ''\n  local list = { }\n  for _, string\
    \ in ipairs(strings) do\n    if string.startswith(prefix) then\n      list[#list\
    \ + 1] = string\n    end\n  end\n  return list\nend", "    local function filter(prefix,\
    \ strings)\n        local result = {}\n        for _, string in ipairs(strings)\
    \ do\n            if string.prefix == prefix then\n                table.insert(result,\
    \ string)\n            end\n        end\n        return result\n    end\n    return\
    \ filter(prefix, strings)\nend", "  for _, value in pairs(strings) do\n    if\
    \ string.sub(value, 1, string.len(prefix)) == prefix then\n      table.remove(strings,\
    \ value)\n    end\n  end\n  return strings\nend", "    local filtered_strings\
    \ = {}\n    for index, str in ipairs(strings) do\n        if str:sub(1, #prefix)\
    \ == prefix then\n            table.insert(filtered_strings, str)\n        end\n\
    \    end\n    return filtered_strings\nend", "    local function is_prefix_match(s)\n\
    \        return (string.sub(s,1,#prefix) == prefix)\n    end", "    local function\
    \ match(str)\n        return str:sub(1, #prefix) == prefix\n    end", "  local\
    \ out = { }\n  for _, string in ipairs(strings) do\n    if string.startswith(prefix)\
    \ then\n      table.insert(out, string)\n    end\n  end\n  return out\nend", " \
    \ local result = {}\n  for i = 1, #strings do\n    local value = strings[i]\n\
    \    if string.sub(prefix, 1, #value) == value then\n      table.insert(result,\
    \ value)\n    end\n  end\n  return result\nend", "\tassert(type(strings) == 'table')\n\
    \tassert(type(prefix) == 'string')\n\t\n\tlocal newstrings = {}\n\tfor _, str\
    \ in ipairs(strings) do\n\t\tif str:sub(1, #prefix) == prefix then\n\t\t\ttable.insert(newstrings,\
    \ str)\n\t\tend\n\tend\n\treturn newstrings\nend", "    local result = {}\n  \
    \  local last_idx\n    for idx = 1, #strings do\n        if strings[idx]:sub(1,\
    \ #prefix) == prefix then\n            table.insert(result, strings[idx])\n  \
    \          last_idx = idx\n        end\n    end\n    return result, last_idx\n\
    end", "    local filtered_strings = {}\n    for _, string in ipairs(strings) do\n\
    \        if string.starts_with(prefix) then\n            table.insert(filtered_strings,\
    \ string)\n        end\n    end\n    return filtered_strings\nend", "  local result\
    \ = {}\n  for _, string in ipairs(strings) do\n    if string.starts(prefix) then\n\
    \      table.insert(result, string)\n    end\n  end\n  return result\nend", " \
    \ local results = {}\n  for _, value in ipairs(strings) do\n    if string.sub(value,\
    \ 1, string.len(prefix)) = prefix then\n      table.insert(results, value)\n \
    \   end\n  end\n  return results\nend", "    local result = {}\n    for _, s in\
    \ ipairs(strings) do\n        if s:sub(1, #prefix) == prefix then\n          \
    \  result[#result + 1] = s\n        end\n    end\n    return result\nend", " \
    \ assert(type(strings) == 'table', 'Input is not a table')\n  assert(type(prefix)\
    \ == 'string', 'Prefix is not a string')\n  local function prefixed_string(s)\n\
    \    return s:sub(1, #prefix) == prefix\n  end\n  return strings:filter(prefixed_string)\n\
    end", "  local result = {}\n  for _, s in ipairs(strings) do\n    if s:sub(1,\
    \ #prefix) == prefix then result[#result + 1] = s end\n  end\n  return result\n\
    end", "    local filtered = {}\n    for i, v in ipairs(strings) do\n        if\
    \ v:sub(1, #prefix) == prefix then\n            table.insert(filtered, v)\n  \
    \      end\n    end\n    return filtered\nend", "  local out = terralib.newlist()\n\
    \  for _, s in ipairs(strings) do\n    if s:sub(1, #prefix) == prefix then\n \
    \     out:insert(s)\n    end\n  end\n  return out\nend", "  local filtered_strings\
    \ = {}\n  for _, str in ipairs(strings) do\n    if str:sub(1, #prefix) == prefix\
    \ then\n      table.insert(filtered_strings, str)\n    end\n  end\n  return filtered_strings\n\
    end", "  local result = {}\n  for _, string in ipairs(strings) do\n    if string.startswith(prefix)\
    \ then\n      table.insert(result, string)\n    end\n  end\n  return result\n\
    end", "  if prefix then\n    prefix = prefix .. '$'\n  end", "  assert(type(prefix)\
    \ == 'string')\n  for _, string in ipairs(strings) do\n    if string.starts(prefix)\
    \ then\n      table.insert(results, string)\n    end\n  end\n  return results\n\
    end", "  local function is_prefixed(x)\n    return x:sub(1, #prefix) == prefix\n\
    \  end\n  local function filter_fn(value)\n    if is_prefixed(value) then\n  \
    \    return value\n    else\n      return nil\n    end\n  end\n  local new_strings\
    \ = terralib.newlist()\n  for _, value in ipairs(strings) do\n    if value ~=\
    \ nil then\n      new_strings:insert(filter_fn(value))\n    end\n  end\n  return\
    \ new_strings\nend", "    if not prefix then\n        return strings\n    end\n\
    \    local prefix_length = prefix:len()\n    if prefix_length == 1 then\n    \
    \    return filter_by_prefix(strings, prefix:sub(1, prefix_length))\n    end\n\
    \    local filtered_list = {}\n    for _, str in pairs(strings) do\n        if\
    \ str:sub(prefix_length) == prefix then\n            table.insert(filtered_list,\
    \ str)\n        end\n    end\n    return filtered_list\nend", "  assert(type(strings)\
    \ == \"table\", \"input must be table type\")\n  assert(type(prefix) == \"string\"\
    , \"prefix must be string\")\n  return strings:filter(function(s)\n    return\
    \ s:sub(1, #prefix) == prefix end\n  )\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
