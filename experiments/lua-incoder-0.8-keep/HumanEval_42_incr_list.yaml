name: HumanEval_42_incr_list
language: lua
prompt: "-- Return list with elements incremented by 1.\n-- >>> incr_list([1, 2, 3])\n\
  -- [2, 3, 4]\n-- >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n-- [6, 4, 6, 3, 4,\
  \ 4, 10, 1, 124]\nlocal function incr_list(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = incr_list\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({3, 2, 1}),\
  \ {4, 3, 2})\n    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6,\
  \ 3, 6, 3, 4, 4, 10, 1, 124})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local index = 1\n  local size = #l\n  for i=1, size do\n    index\
    \ = index + 1\n    table.insert(l, index)\n  end\n  return l\nend", "    local\
    \ new_list = nil\n    local n = #l\n    if n == 0 then\n        return new_list\n\
    \    end\n    new_list = l[1]\n    for i = 2, n do\n        new_list = new_list\
    \ .. \", \" .. l[i]\n    end\n    return new_list\nend", "   for i = 1, #l do\n\
    \      l[i] = l[i] + 1\n   end\n   return l\nend", "  local l2 = {}\n  for i =\
    \ #l, 1, -1 do\n    l2[i] = l[i] + 1\n  end\n  return l2\nend", "  for i = #l,\
    \ 1, -1 do\n    l[i] = l[i] + 1\n  end\n  return l\nend", "  for i = #l, 1, -1\
    \ do\n    table.insert(l, table.getn(l))\n  end\n  return l\nend", "  local n\
    \ = #l\n  if n == 0 then\n    return l\n  else\n    local i = n - 1\n    while\
    \ i do\n      l[i + 1] = l[i] + 1\n      i = i - 1\n    end\n    return l\n  end\n\
    end", "  local result = {}\n  for i = 1, #l do\n    result[i - 1] = (result[i]\
    \ or 0) + l[i]\n  end\n  return result\nend", "  local result = {}\n  for i =\
    \ 1, #l do\n    result[#result + 1] = l[i]\n  end\n  return result\nend", "  local\
    \ acc = {}\n  local i = 1\n  for _, e in ipairs(l) do\n    acc[i] = e\n    i =\
    \ i + 1\n  end\n  return acc\nend", "    -- Return list with elements incremented\
    \ by 1.\n    local newL = {}\n    local i = 1\n    for _, v in ipairs(l) do\n\
    \        table.insert(newL, v)\n        table.insert(newL, v)\n        i = i +\
    \ 1\n    end\n    return newL\nend\n</cell>\n<text>\nExercise\nCan you write a\
    \ function (or script) which can generate a random number between $0$ and $1$?\
    \ Hint: there are many ways to do this, including:", "    local i, count = 1,\
    \ 1\n    for _, v in ipairs(l) do\n        i = i + 1\n        if i == count then\n\
    \            count = count + 1\n        end\n    end\n    return l\nend", "  local\
    \ n = 1\n  local i = 1\n  while i <= #l do n = n * l[i]; i = i + 1; end\n  return\
    \ l\nend", "  local new_l = {}\n  for i = #l, 1, -1 do\n    new_l[i] = new_l[i-1]+1\n\
    \  end\n  return new_l\nend", "  local lt = {}\n  for i = 1, #l do\n    table.insert(lt,\
    \ l[i] + 1)\n  end\n  return lt\nend", "    local t = {}\n    for i, v in ipairs(l)\
    \ do\n        t[#t + 1] = v\n    end\n    return t\nend", "  return list.reduce(f,\
    \ l):reverse()\nend", "   local tmp = {}\n   for i=1, #l do\n      tmp[i] = l[i]\
    \ + 1\n   end\n   return tmp\nend", "  local acc = 1\n  for i = 1, #l do\n   \
    \ acc = acc + l[i]\n  end\n  return l\nend", "  if #l == 0 then return nil end\n\
    \  local n = l[1] + 1\n  l[1] = n\n  return l\nend", "    local i = 1\n    for\
    \ _,v in ipairs(l) do i = i+1 end\n    return table.concat(l, i)\nend", "  --\
    \ We do not know whether we will be passed an empty list or not,\n  -- so we always\
    \ return a list. If we were passed an array, we could return\n  -- an empty list\
    \ instead, but then the caller would need to know to handle\n  -- the empty case\
    \ properly.\n  return list.reduce(capi.list(l), function(acc, x) return x + 1\
    \ end, 1)\nend", "  local n = #l\n  if n > 0 then\n    local result = {}\n   \
    \ local i = 1\n    while i <= n do\n      result[i] = l[i] + 1\n      i = i +\
    \ 1\n    end\n    result[#result]\n  end\nend", "    local t = {}\n    for i,\
    \ v in ipairs(l) do\n        t[i + 1] = v\n    end\n    return t\nend", "  return\
    \ setmetatable(l:map(function(n) return n + 1 end), {__index = function(self,\
    \ idx)\n    return self[idx] + 1\n  end})\nend", "    local i = 0\n    local new_l\
    \ = {}\n    for elem in l do\n        new_l[i + 1] = elem\n        i = i + 1\n\
    \    end\n    return new_l\nend", "   local newL = {}\n   for i = 1, #l do\n \
    \     newL[i] = l[i] + 1\n   end\n   return newL\nend", "  if #l == 0 then\n \
    \   return l\n  end\n  local last = l[#l]\n  l[#l] = last + 1\n  return l\nend",
  "  local t = {}\n  for i, v in ipairs(l) do\n    table.insert(t, v+1)\n  end\n \
    \ return t\nend\n</code>\n<|/ a |>\n<| c |>\nThis does work and I appreciate the\
    \ effort but as I said in the question, I specifically need the answer to be a\
    \ table function.\n<|/ c |>\n<| c |>\nI guess the downvote was unwarranted. My\
    \ answer was very detailed and helpful. I would like to see an alternative answer.\n\
    <|/ c |>\n<| c |>\nWhy do you think you need an alternative answer? What are you\
    \ actually trying to do? Why do you need the function in the first place?\n<|/\
    \ c |>\n<| c |>\nI apologize, your answer is very helpful and I understand that\
    \ it doesn't directly answer my question. However, I have no other means of communicating\
    \ my question.\n<|/ c |>\n<| c |>\n: I see what you mean now... You were asking\
    \ for an alternative to `incr_list`, which has already been provided by other\
    \ people. Perhaps you can give a better description of what you are trying to\
    \ do now that we have more information.\n<|/ c |>\n<| a tags=lua |>\nOne more\
    \ solution: \n<code>", "    local i = 1\n    local ret = {}\n    for i = 1, #l\
    \ do\n        ret[i] = l[i] + 1\n    end\n    return ret\nend", "  local i = #l\n\
    \  if i == 0 then return l else return l[1:(i + 1)] + l[(i + 1):end] end\nend",
  "  local ret = {}\n  for i = 1, #l do\n    ret[i] = ret[i] + 1\n    if ret[i] >\
    \ #l then\n      break\n    end\n  end\n  return ret\nend", "  if l == nil then\n\
    \    error('nil list')\n  elseif #l == 0 then\n    error('empty list')\n  end",
  "  return table.concat(l):gsub(\"(%d+)\", function(n)\n    return tonumber(n) +\
    \ 1 -- luacheck: ignore next line for this linter\n  end)\nend", "  local res\
    \ = {}\n  for i = 1, #l do\n    res[#res + 1] = l[i] + 1\n  end\n  return res\n\
    end", "    local new_l = {}\n    for i, v in ipairs(l) do\n        new_l[i] =\
    \ v + 1\n    end\n    return new_l\nend", "  local r = {}\n  for i = 1, #l do\n\
    \    r[#r+1] = l[i] + 1 -- [#r+1] := ... := l[i] + 1\n  end\n  return r\nend",
  "    if #l == 1 then\n        -- Don't do anything.\n    elseif #l == 2 then\n \
    \       l[1] = l[1] + 1\n    else\n        l[#l+1] = l[#l+1] + 1\n    end\n  \
    \  return l\nend", "   for i = #l, 1, -1 do\n      l[i] = l[i] + 1\n   end\n \
    \  return l\nend", "  return setmetatable(l, { __index = function(self, idx)\n\
    \      return idx + 1\n    end})\nend", "  local n = 1\n  local ret = l\n  for\
    \ i = 1, #l do n = n * i + ret[i] end\n  ret = n / i\n  return ret\nend", "  local\
    \ accum = 0\n  local length = #l\n  for i = 1, length do\n    accum = accum +\
    \ 1\n    l[i] = accum\n  end\n  return l\nend", "  local n = 1\n  for i = 1, #l\
    \ do\n    n = (n + l[i]) + 1\n    l[i] = n\n  end\n  return l\nend", "  local\
    \ result = {}\n  for i = #l, 1, -1 do\n    result[#result + 1] = l[i]\n  end\n\
    \  return result\nend", "  local new_l = {}\n  for i = 1, #l do\n    new_l[i]\
    \ = l[i] + 1\n  end\n  return new_l\nend", "  local rv = { }\n  local n = 1\n\
    \  for i = #l, 1, -1 do\n    rv[i] = n\n    n = n + 1\n  end\n  return rv\nend",
  "   if #l == 0 then\n      return l\n   end\n   local r = {l[1]}\n   for i = 2,\
    \ #l do\n      r[#r + 1] = r[#r + 1] + l[i]\n   end\n   return r\nend", "  local\
    \ count = 1\n  local last = l[1]", "  local results = {}\n  local pos = 1\n  for\
    \ i = 1, #l do\n    table.insert(results, pos, l[i])\n    pos = pos + 1\n  end\n\
    \  return results\nend", "  local n = 1\n  for i = #l - 1, 1, -1 do\n    local\
    \ v = l[i]\n    l[i] = v + n\n    n = n / 2\n  end\n  return l\nend", "  -- We\
    \ want to know if the list is nil or not so we need to do a\n  -- type check first\
    \ and handle it gracefully\n  if not l then\n    return nil\n  elseif type(l)\
    \ == 'table' then\n    local result\n    for index, v in ipairs(l) do\n      --\
    \ This might not be the best way to do this, just doing\n      -- what we were\
    \ taught in the class so we don't run into errors\n      -- on assignments\n \
    \     if not result then\n        result = {}\n      else\n        table.insert(result,\
    \ index)\n      end\n    end\n    return result\n  else\n    table.insert(l, 1)\n\
    \    return l\n  end\nend", "   for i = #l, 1, -1 do\n      l[i] = l[i-1] + 1\n\
    \   end\n   return l\nend", "  for idx = 2, #l do\n    idx = idx + 1\n    l.insert(idx,\
    \ l[idx])\n  end\n  return l\nend", "    local new_list = {}\n    for i = 1, #l\
    \ do\n        new_list[#new_list + 1] = l[i] + 1\n    end\n    return new_list\n\
    end", "  for i = #l, 1, -1 do\n    l[i] = l[i] + 1\n  end\n  return l\nend", " \
    \   local i = 1\n    local last = nil\n    for _ = 1, #l do\n        if last ==\
    \ nil or last > l[i] then\n            last = l[i]\n        end\n        i = i\
    \ + 1\n    end\n    if last == nil then\n        last = l[1]\n    end\n    return\
    \ lists.copy(l)\nend", "  local n = 1\n  local i = 1\n  for _, v in ipairs(l)\
    \ do\n    n = n * 10 + v\n    i = i + 1\n  end\n  -- Append 1 at the end to avoid\
    \ empty list issues.\n  i = i + 1\n  n = n * 10 + 1\n  return table.concat(table.unpack(rep(n,\
    \ i)))\nend", "  local n = 0\n  for _, v in ipairs(l) do\n    n = n + 1\n    l[n]\
    \ = v\n  end\n  return l\nend", "  local res = {}\n  for i=1,#l do res[i] = res[i]\
    \ + 1 end\n  return res\nend", "  return setmetatable({n = 1}, l) -- Create a\
    \ new table with n set to 1.\nend", "  -- Base case: empty list or one element\
    \ is a number.\n  if #l <= 1 then return [1] else return l end", "    local new_list\
    \ = {}\n    for i, x in ipairs(l) do\n        new_list[i] = x + 1\n    end\n \
    \   return new_list\nend", "  for i = 1, #l do l[i] = l[i] + 1 end\n  return l\n\
    end", "    local i = 1\n    for i=1,#l do\n        l[i] = l[i] + i\n    end\n\
    \    return l\nend", "    local c = 0\n    local n = #l\n    for i = 1, n do\n\
    \        c = c + l[i]\n        l[i] = c\n    end\n    return l\nend", "  if #l\
    \ == 0 then\n    return l\n  else\n    return l[#l] + 1\n  end\nend", "    local\
    \ t = {}\n    for i, v in ipairs(l) do\n        if t then\n            t[#t +\
    \ 1] = v\n        else\n            t[i] = v\n        end\n    end\n    return\
    \ t\nend", "  local index = 1\n  local t = l\n  local result\n  repeat\n    if\
    \ t[index] == nil then\n      result = result or 0\n    else\n      result = result\
    \ or t[index] + 1\n    end\n    index = index + 1\n  until not t\n  return result\n\
    end", "    local n = #l\n    if n == 0 then\n        return l\n    end\n    table.insert(l,\
    \ l[n])\n    return table.concat(l)\nend", "  local n = #l\n  local v = l[1]\n\
    \  for i = 2, n do\n    v = v + 1\n    l[i] = v\n  end\n  return l\nend", "  for\
    \ i = #l, 1, -1 do\n    l[i] = l[i] + 1\n  end\n  return l\nend", "  local t =\
    \ {}\n  for i=1,#l do\n    t[i] = l[i] + 1\n  end\n  return t\nend", "  local\
    \ llen = #l\n  local newlist = {}\n  for i = 1, llen do\n    table.insert(newlist,\
    \ l[i]+1)\n  end\n  return newlist\nend", "  local accum = { }\n  for i = 1, #l\
    \ do\n    accum[#accum + 1] = l[i]\n  end\n  return accum\nend", "  for i = #l,\
    \ 1, -1 do\n    l.[i] = l.[i] + 1\n  end\n  return l\nend", "  if #l == 0 then\
    \ return nil end\n  local n = l[1]\n  if n then\n    local v = l[2]\n    l[2]\
    \ = n + 1\n    table.insert(l, v)\n  end\n  return l\nend", "  local newL = {}\n\
    \  local i = 1\n  for _, v in ipairs(l) do\n    table.insert(newL, v)\n    table.insert(newL,\
    \ v)\n    i = i + 2\n  end\n  return newL\nend", "  local tmp = {}\n  for i =\
    \ 1, #l do\n    table.insert(tmp, i)\n  end\n  for i = #l + 1, 1 do\n    table.insert(tmp,\
    \ i)\n  end\n  return tmp\nend", "  local new_list = []\n  local index = 1", " \
    \ local incr = 1\n  for i = #l, 1, -1 do\n    table.insert(l, incr)\n    incr\
    \ = incr + 1\n  end\n  return l\nend", "  local t = {}\n  for i = 1, #l do\n \
    \   table.insert(t, l[i])\n  end\n  return t\nend", "  local n = 1\n  local l2\
    \ = {}\n  for i = 1, #l do\n    table.insert(l2, l[i])\n    i = i + 1\n  end\n\
    \  for i = 1, #l2 do\n    n = n + 1\n    l2[i] = n\n  end\n  return l2\nend",
  "  local l2 = {}\n  for _, v in ipairs(l) do\n    l2[#l2 + 1] = v + 1\n  end\n \
    \ return l2\nend", "  local ret = {1}\n  for i = 2, #l do ret[i] = ret[i - 1]\
    \ + 1 end\n  return ret\nend", "  return #l + #l + 1\nend", "  local r\n  if #l\
    \ > 0 then\n    r = l[1] + 1\n    for i = 2, #l do\n      r = self.add(l, r, i)\n\
    \    end\n  end\n  return r\nend", "  local res = {}\n  for i = #l, 1, -1 do\n\
    \    res[i] = l[i] + 1\n  end\n  return res\nend", "\tlocal new_l = {}\n\tlocal\
    \ index = 1\n\tfor i=1, #l do\n\t\tnew_l[i] = l[index] + 1\n\t\tindex = index\
    \ + 1\n\tend\n\treturn new_l\nend", "  local newlist = { }\n  for i=1,#l do\n\
    \    newlist[#newlist+1] = l[i]+1\n  end\n  return newlist\nend", "    local count\
    \ = 1\n    for i = #l, 1, -1 do\n        count = count + 1\n        l[i] = count\
    \ -- Counting backwards\n    end\n    return l\nend", "   -- For speed\n   local\
    \ i = #l\n   for i, v in pairs(l) do\n      l[i] = v + 1\n   end\n   return l\n\
    end", "  local result = {}\n  local i = 1\n  for i = 1, #l do\n    result[i] =\
    \ l[i] + 1\n  end\n  return result\nend", "  local res = {}\n  local last = l[1]\n\
    \  for i = 1, #l do\n    local element = l[i]\n    res[#res + 1] = element + last\n\
    \    last = element\n  end\n  return res\nend", "   for i = #l, 1, -1 do\n   \
    \   l[i] = l[i] + 1\n   end\n   return l\nend", "  local result = {l[1]}\n  for\
    \ i = 2, #l do\n    result = {l[1], l[i]}\n  end\n  return result\nend", "  local\
    \ result = {}\n  for i = 1, #l do\n    result[i - 1] = l[i]\n  end\n  return result\n\
    end", "\tlocal n = #l\n\tif n > 0 then\n\t\tfor i = 1, n do\n\t\t\tl[i] = l[i]\
    \ + 1\n\t\tend\n\tend\n\treturn l\nend", "  local count = 1\n  local newL = nil\n\
    \  for i, v in ipairs(l) do\n    newL = (count <= #l) and l[count] or v\n    count\
    \ = count + 1\n    l[count] = newL\n  end\n  return newL\nend", "  -- Return list\
    \ with elements incremented by 1.\n  -- >>> incr_list([4, 3, 6, 4, 6, 3, 4, 3,\
    \ 6, 4, 6, 3, 4, 9, 0, 123, 34])\n  -- [5, 5, 6, 5, 6, 6, 5, 5, 6, 6, 6, 6, 6,\
    \ 6, 5, 5, 6, 5, 6, 5, 6, 5, 6, 6, 6, 5, 6, 5, 6, 6, 5, 6, 6, 5, 6, 6, 5, 5, 5,\
    \ 5, 5, 5, 5, 5]\n  local len = 1\n  for _, v in pairs(l) do\n    len = len +\
    \ v\n  end\n  local t = {}\n  for _, v in pairs(l) do\n    table.insert(t, len\
    \ + v)\n  end\n  return t\nend", "  for i = 1, #l do\n    l[i] = l[i] + 1\n  end\n\
    \  return l\nend", "  if #l == 0 then\n    return l\n  else\n    return l[#l+1]\
    \ + 1, incr_list(l[#l])\n  end\nend", '  return { value = l[1], value = l[2],
    value = l[3], value = l[4], value = l[5], value = l[6], value = l[7], value =
    l[8], value = l[9], value = l[10], value = l[11], value = l[12], value = l[13],
    value = l[14], value = l[15], value = l[16], value = l[17], value = l[18], value
    = l[19], value = l[20], value = l[21], value = l[22], value = l[23], value = l[24],
    value = l[25], value = l[26], value = l[27], value = l[28], value = l[29], value
    = l[30], value = l[31], value = l[32], value = l[33], value = l[34], value = l[35],
    value = l[36], value = l[37], value = l[38], value = l[39], value = l[40], value
    = l[41], value = l[42], value = l[43], value = l[44], value = l[45], value = l[46],
    value = l[47], value = l[48], value = l[49], value = l[50], value = l[51], value
    = l[52], value = l[53], value = l[54], value = l[55], value = l[56], value = l[57],
    value = l[58], value = l[59], value = l[60], value = l[61], value = l[62], value
    = l[63], value = l[64], value = l[65], value = l[66], value = l[67], value = l[68],
    value = l[69], value = l[70], value = l[71], value = l[72], value = l[73], value
    = l[74], value = l[75], value = l[76], value = l[77], value = l[78], value = l[79],
    value = l[80], value = l[81], value = l[82], value = l[83], value = l[84], value
    = l[85], value = l[86], value = l[87], value = l[88], value = l[89], value = l[90],
    value = l[91], value = l[92], value = l[93], value = l[94], value = l[95], value
    = l[96], value = l[97], value = l[98], value = l[99], value = l[100], value =
    l[101], value = l[102], value = l[103], value = l[104], value = l[105], value
    = l[106], value = l[107], value = l[108], value = l', "  local ret = {}\n  local\
    \ i = 1 -- Start at index 1 because of empty list return value.\n  for i = 1,\
    \ #l do\n    ret[i] = i + l[i]\n  end\n  return ret\nend", "  return table.concat(l,\
    \ 1, math.max(#l, 1))\nend", "  local new_l = {}\n  local i = 0\n  for i=1, #l\
    \ do\n    new_l[i] = l[i] + 1\n  end\n  return new_l\nend", "   local i = #l\n\
    \   if i == 0 then return 1 end\n   l[i] = l[i] + 1\n   return incr_list(l) -\
    \ 1\nend", "    local newL = {}\n    for i, v in pairs(l) do\n        newL[i]\
    \ = v + 1\n    end\n    return newL\nend", "  local result\n  for i = 1, #l do\n\
    \    result = result or {}\n    table.insert(result, l[i] + 1)\n  end\n  return\
    \ result\nend", "\tlocal new_l = {}\n\tfor i = 1, #l do\n\t\ttable.insert(new_l,\
    \ l[i])\n\tend\n\treturn new_l\nend", "  local result = {}\n  for i = 2, #l do\n\
    \    result[i - 1] = l[i] + 1\n  end\n  return result\nend", "  if #l == 0 then\n\
    \    return l\n  elseif #l == 1 then\n    return l\n  else\n    return l[#l+1]\n\
    \  end\nend", "  local i, n = 1, #l\n  if n == 0 then\n    return l\n  else\n\
    \    for i = 1, n do\n      l[i] = l[i] + 1\n    end\n    return l\n  end\nend",
  "    local result = {}\n    for i = 1, #l do\n        table.insert(result, i + 1)\n\
    \    end\n    return result\nend", "    local i = 1\n    local c = 0\n    local\
    \ n = {}\n    for _, _ in ipairs(l) do\n        n[c] = l[i]\n        i = i + 1\n\
    \        c = c + 1\n    end\n    return n\nend", "    local i = 1 -- Index of\
    \ first element to increment\n    local y = 1 -- Index of first element to increment\n\
    \    local z = 0", "  local n = 1\n  for i = 1, #l do\n    n = (n + l[i]) + 1\n\
    \  end\n  return n\nend", "    local i = 0\n    local ret = {}\n    for i, v in\
    \ ipairs(l) do\n        ret[i] = v + 1\n    end\n    return ret\nend", "  local\
    \ r = {l[1]}\n  for i = 2, #l do\n    table.insert(r, l[i])\n  end\n  return r\n\
    end", "   for i = #l + 1, 2, -1 do\n      l[i] = l[i - 1] + 1\n   end\n   return\
    \ l\nend", "  local n = 1\n  local v\n  for _, v in ipairs(l) do n = n * v end\n\
    \  return n + 1\nend", "  local i = 1\n  local n = 1\n  for i = 1, #l do\n   \
    \ n = n * 10 + l[i]\n    l[i] = n / 10\n  end\n  return l\nend", "  local size\
    \ = #l\n  if size == 0 then\n    return l\n  else\n    local result = {}\n   \
    \ local i = size - 1\n    while i > 0 do\n      result[i] = result[i] + 1\n  \
    \    i = i - 1\n    end\n    return setmetatable(result, list)\n  end\nend", " \
    \ return terralib.newlist(\n    function(idx)\n      return l[idx+1]\n    end)\n\
    end", "  local ret = {}\n  for i = 1, #l do\n    ret[i] = ret[i] + 1\n  end\n\
    \  return ret\nend", "  local result = {}\n  for i = #l, 1, -1 do\n    table.insert(result,\
    \ l[i])\n  end\n  return result\nend", "  local newL = {}\n  for _, el in ipairs(l)\
    \ do\n    newL[#newL + 1] = el + 1\n  end\n  return newL\nend", "  local incr\
    \ = 0\n  for i = 2, #l do\n    incr = incr + l[i-1]\n    l[i] = incr\n  end\n\
    \  return l\nend", "    for idx = #l + 1, 1 do\n        l[#l + 1] = idx - 1\n\
    \    end\nend", "    if type(l) ~= 'table' then return l end\n    local n = 1\n\
    \    for i = #l, 1, -1 do\n        n = (n + l[i]) + 1\n        l[i] = n\n    end\n\
    \    return l\nend", "  for i = #l, 1, -1 do\n    l[i] = l[i] + 1\n  end\n  return\
    \ l\nend", "  local n = 1\n  for i = 1, #l do\n    local e = l[i]\n    local f\
    \ = e + 1\n    if f < n then\n      table.remove(l, i)\n      table.insert(l,\
    \ f)\n    end\n    n = f\n  end\n  return l\nend", "    for idx, val in pairs(l)\
    \ do\n        l[idx] = val + 1\n    end\n    return l\nend", "  if #l == 0 then\n\
    \    return l\n  end\n  local n = 1\n  local new_list = nil\n  for i, v in ipairs(l)\
    \ do\n    new_list = v + n\n    n = new_list\n    if i == #l then\n      break\n\
    \    end\n  end\n  return new_list or n\nend", "  for i, v in ipairs(l) do\n \
    \   if type(v) ~= 'number' then\n      error('list items must be numbers')\n \
    \   end\n    v = v + 1\n    l[i] = v\n  end\n  return l\nend", "    if #l == 0\
    \ then\n        return l\n    end\n    local result = {}\n    local i = 1\n  \
    \  for i = 1, #l do\n        result[i] = l[i] + 1\n    end\n    return result\n\
    end", "   for i = 1, #l do\n      l[i] = l[i] + 1\n   end\n   return l\nend",
  "    local i = 1\n    for i = #l + 1, 1 do\n        l[#l] = i\n    end\n    return\
    \ l\nend", "  local i = #l\n  if i <= 1 then\n    return l\n  end\n  repeat\n\
    \    i = i + 1\n    l[i] = l[i] + 1\n  until i > #l\n  return l\nend", "  local\
    \ n = 1\n  local tmp\n  tmp = l[1]\n  l[1] = nil\n  for i = 2, #l do\n    if l[i]\
    \ == tmp then\n      n = n + 1\n    else\n      l[n + 1] = l[i]\n      n = 1\n\
    \    end\n  end\n  l[n + 1] = tmp\n  return l\nend", "    local n = 1\n    local\
    \ out = {}\n    for i, v in ipairs(l) do\n        out[#out + 1] = v\n        n\
    \ = n + 1\n    end\n    return out\nend", "  local n = 1\n  local s = ''\n  for\
    \ i=1,#l do\n    s = g..tostring(l[i])\n    n = n*10 + tonumber(s)\n    i = i\
    \ + 1\n  end\n  table.insert(l, n)\n  return l\nend", "   if l[1] == nil then\
    \ return l end\n   return table.insert(l, 1, l[1] + 1)\nend", "  local n = #l\n\
    \  if n == 1 then\n    local n = l[1]\n    l[1] = n + 1\n    return n\n  end\n\
    \  for i = 2, n do\n    local m = l[i]\n    l[i] = m + 1\n  end\n  return n\n\
    end", "  local index = 1\n  local result\n  for i, v in ipairs(l) do\n    result[i]\
    \ = v + index\n    index = index + 1\n  end\n  return result\nend", "  local result\n\
    \  for i = #l, 1, -1 do\n    table.insert(result, i)\n  end\n  return result\n\
    end\n</cell>\n<text>\nExercise 6\nWrite a function that takes a number and a list,\
    \ then returns a new list with every element of the original list except the number\
    \ that you are passing.", "  local res = {}\n  for i = 1, #l do\n    res[#res+1]\
    \ = l[i] + 1\n  end\n  return res\nend", "  local n = #l\n  if n > 0 then\n  \
    \  for i = 1, n do\n      l[i] = l[i] + 1\n    end\n  end\n  return l\nend", " \
    \   local idx = 1\n    for i, x in ipairs(l) do\n        l[i] = x + idx\n    \
    \    idx = idx + 1\n    end\n    return l\nend", "  local i, count = 1, 1\n  local\
    \ new_l = {}\n  for i=1, #l do\n    new_l[i] = l[i] + count\n    count = count\
    \ + 1\n  end\n  return new_l\nend", "  return l.__index .. l\nend", "  local r\n\
    \  if #l > 0 then\n    r = {}\n    for i = 1, #l do\n      r[i] = l[i] + 1\n \
    \   end\n  else\n    r = l\n  end\n  return r\nend", "  return table.concat(l,\
    \ 1, function(x)\n    return x + 1\n  end)\nend", "  local new_list = {}\n  for\
    \ _, v in ipairs(l) do\n    new_list[#new_list + 1] = v\n  end\n  return new_list\n\
    end\n</cell>\n<cell>", "  if l==nil then return nil end\n  local index = 1\n \
    \ local result = {}\n  for i, v in ipairs(l) do\n    result[i] = v + index\n \
    \   index = index + 1\n  end\n  return result\nend", "  local n = #l\n  if n <=\
    \ 1 then return l else return l[1] .. incr_list(l[#l]) end\nend", "  local i =\
    \ 0\n  for i = #l, 2, -1 do\n    l[i + 1] = l[i] + 1\n  end\n  return l\nend",
  "  local new_l = {}\n  for _, v in pairs(l) do\n    new_l[v + 1]\n  end\n  return\
    \ new_l\nend\n</cell>\n<text>\n\u041C\u043E\u0436\u043D\u043E \u0441\u0434\u0435\
    \u043B\u0430\u0442\u044C \u0438\u0437 \u043D\u0438\u0445 \u0442\u0430\u043A:",
  "  for i = #l + 1, 2, -1 do\n    l[i] = l[i - 1] + 1\n  end\n  return l\nend", " \
    \ local new_l = {}\n  for i = 1, #l do\n    new_l[i + 1] = l[i]\n  end\n  return\
    \ new_l\nend", "  local size = #l\n  local i = 0\n  local out = {}\n  for i =\
    \ 1, size do\n    table.insert(out, i + 1)\n  end\n  return out\nend", "  local\
    \ new_list = { }\n  for i = 1, #l do\n    new_list[#new_list + 1] = l[i] + 1\n\
    \  end\n  return new_list\nend", "  local n = #l\n  if n == 0 then\n    return\
    \ nil\n  else\n    local new_l = {}\n    for i = 1, n do\n      new_l[i] = l[i]\
    \ + 1\n    end\n    return new_l\n  end\nend", "  local incr = 1 + #l\n  if incr\
    \ > 0 then\n    local i = 0\n    while i < incr do\n      l[i] = l[i] + 1\n  \
    \    i = i + 1\n    end\n  end\n  return l\nend", "   local i = #l\n   for i=1,\
    \ #l do\n      l[i] = l[i] + 1\n      if l[i] <= i then\n         break\n    \
    \  end\n   end\n   return l\nend", "  local newL = {}\n  for _, v in ipairs(l)\
    \ do\n    newL[#newL + 1] = v + 1\n  end\n  return newL\nend", "  local n = 1\n\
    \  for i = #l, 1, -1 do\n    n, _ = n + l[i], 1\n    l[i] = n\n  end\n  return\
    \ l\nend", "  local n = 1\n  for i = #l, 1, -1 do\n    table.insert(l, n)\n  \
    \  n = n + 1\n  end\n  return l\nend", "  local newL = {}\n  for i = 1, #l do\n\
    \    newL[i] = l[i] + 1\n  end\n  return newL\nend", "  local n = 1\n  local i\
    \ = #l + 1\n  while i <= #l do\n    table.insert(l, n)\n    i = i + 1\n    n =\
    \ n + 1\n  end\n  return l\nend", "  local n = 1\n  local t = {}\n  for i = 1,\
    \ #l do t[#t + 1] = l[i] + n end\n  return t\nend", "  local i = 1;\n  local j\
    \ = #l + 1;\n  while i <= j do\n    local k = i + 1;\n    l[k] = l[k] + 1;\n \
    \   i = i + 1;\n  end\n  return l;\nend", "    local i = 1 -- Current index.\n\
    \    local n = 0 -- Current element.\n    for idx, v in ipairs(l) do\n       \
    \ n = v + i\n        i = i + 1\n        l[idx] = n\n    end\n    return l\nend",
  "    local i = 1\n    for i, v in ipairs(l) do\n        l[i] = v + 1\n    end\n\
    \    return l\nend", "   local n = 1\n   for _, v in pairs(l) do n = n + 1, v\
    \ end\n   return l, n\nend", "  local n = #l\n  if n == 0 then\n    return l\n\
    \  elseif n > 0 then\n    local new_list = table._new(0)\n    local i = n - 1\n\
    \    while i do\n      new_list[i] = l[i] + 1\n      i = i - 1\n    end\n    return\
    \ new_list\n  end\nend", "  local new_list = {}\n  for _, item in ipairs(l) do\n\
    \    new_list[#new_list + 1] = item\n  end\n  return new_list\nend", "  if #l\
    \ == 0 then\n    return l\n  end\n  local i = l[1]\n  l[1] = i + 1\n  l[#l + 1]\
    \ = i\n  return l\nend", "  local ret = {}\n  for i = 1, #l do\n    ret[i] = l[i]\
    \ + 1\n  end\n  return ret\nend", "  if #l == 0 then\n    return l\n  end\n  local\
    \ first = l[1]\n  local rest = incr_list(l)\n  rest[#rest + 1] = first + 1\n \
    \ return rest\nend", "  if l[1] == nil then\n    return l\n  elseif l[1] > 1 then\n\
    \    local first = l[1] - 1\n    local i = l[2]\n    local newlist = { first,\
    \ nil, i }\n    if i == nil then\n      return newlist\n    end\n    while true\
    \ do\n      newlist[2] = i\n      i = i + 1\n      if i == nil then\n        return\
    \ newlist\n      end\n    end\n  end\nend", "  local new_list = {}\n  for i =\
    \ 1, #l do\n    new_list[i - 1] = ccall( 'i', 'int', l[i] + 1 )\n  end\n  return\
    \ new_list\nend", "  local i = 1\n  local new_l = {}\n  for _, x in ipairs(l)\
    \ do\n    new_l[i] = x\n    i = i + 1\n  end\n  return new_l\nend", "  local out\
    \ = {}\n  for i=1,#l do\n    table.insert(out, l[i]+1)\n  end\n  return out\n\
    end", "  local n = 1\n  for i = 1, #l do\n    table.insert(l, n)\n    n = n +\
    \ 1\n  end\n  return l\nend", "  local new_l = {}\n  for i = #l, 1, -1 do\n  \
    \  new_l[i - 1] = l[i] + 1\n  end\n  return new_l\nend", "  local n = #l\n  if\
    \ n == 0 then\n    return l\n  end\n  local head = l[1]\n  if n == 1 then\n  \
    \  l[1] = head\n  else\n    local head = head + 1\n    table.insert(l, head)\n\
    \  end\n  return l\nend", "  local n = #l\n  local m = math.floor(n / 2)\n  for\
    \ i = 1, m do\n    l[i] = l[i + 1]\n  end\n  l[m] = n + 1\n  return l\nend", " \
    \ local n = 1\n  for _, x in ipairs(l) do n = n * x end\n  return n\nend", " \
    \ local idx = #l + 1\n  for _, v in pairs(l) do idx = idx + 1 end\n  l.idx = idx\n\
    \  return l\nend", "  if l == nil then return nil end\n  local i = 1\n  local\
    \ n = #l\n  repeat\n    l[#l + 1] = l[#l + 1] + 1\n    i = i + 1\n  until i >\
    \ n\n  return l\nend", "  local l2 = {}\n  for i = 1, #l do\n    l2[i] = l[i]\
    \ + 1\n  end\n  return l2\nend", "    local n = 1\n    for i, v in ipairs(l) do\n\
    \        n = n * v\n    end\n    return n + 1\nend", "  local new_l = {}\n  for\
    \ i = 1, #l do\n    new_l[i] = l[i] + 1\n  end\n  return new_l\nend", "  local\
    \ i = 1\n  while i <= #l do\n    i = i + 1\n    table.insert(l, i)\n  end\n  return\
    \ l\nend", "    local newL = {}\n    for i = 1, #l do \n        newL[i] = l[i]\
    \ + 1\n    end\n    return newL\nend", "    local t = {}\n    for i = 1, #l do\n\
    \        table.insert(t, l[i])\n    end\n    return t\nend", "    local out =\
    \ {}\n    local i = l[1]\n    while i do\n        out[#out + 1] = i + 1\n    \
    \    i = l[i .. 1]\n    end\n    return out\nend", "    local index = 1\n    local\
    \ new_l = {}\n    for i = 1, #l do\n        new_l[i] = l[i] + 1\n        index\
    \ = index + 1\n        if index > #l then\n            return new_l\n        end\n\
    \    end\n    return new_l\nend", "  local r = 0\n  local l2 = {}\n  for i = 1,\
    \ #l do\n    table.insert(l2, l[i])\n    l = l2\n    i = i + 1\n    if i == #l\
    \ then\n      table.insert(l2, 0)\n    end\n  end\n  return l2\nend", "  local\
    \ ret = {l[1]}\n  l[1] = l[1] + 1\n  for i = 2, #l do\n    ret[#ret + 1] = l[i]\n\
    \  end\n  return ret\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
