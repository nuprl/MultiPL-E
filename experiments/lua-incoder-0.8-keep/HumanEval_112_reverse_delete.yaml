name: HumanEval_112_reverse_delete
language: lua
prompt: "-- Task\n-- We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n-- then check if the result\
  \ string is palindrome.\n-- A string is called palindrome if it reads the same backward\
  \ as forward.\n-- You should return a tuple containing the result string and True/False\
  \ for the check.\n-- Example\n-- For s = \"abcde\", c = \"ae\", the result should\
  \ be ('bcd',False)\n-- For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n\
  -- For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\nlocal\
  \ function reverse_delete(s, c)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n\
  \    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef',\
  \ 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc',\
  \ true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a',\
  \ 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba',\
  \ true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n\
  \    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma',\
  \ 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Check if s is empty or null\n  if s == nil or s == \"\" then\n\
    \    return nil, nil\n  end\n  -- Check if c is empty or null\n  if c == nil or\
    \ c == \"\" then\n    return s, true\n  end\n  -- Create two pointers and initialize\
    \ them\n  local p1, p2 = 0 , 1\n  -- While the second pointer is less than the\
    \ length of s\n  while p2 < #s do\n    -- Check if s is equal to the character\
    \ at the second pointer and if not add the first pointer to the result\n    if\
    \ s ~= c[p1] then\n      p2 = p2 + 1\n    else\n      -- If s is equal to the\
    \ character at the second pointer, decrement the second pointer\n      p2 = p2\
    \ + 1\n      -- If the second pointer is equal to the length of s, append the\
    \ first pointer to result\n      if p2 == #s then\n        -- Add first pointer\
    \ to result\n        return c[p1], false\n      end\n    end\n    -- Increment\
    \ the first pointer\n    p1 = p1 + 1\n  end\n  return nil, true\nend", "   for\
    \ i = 1, #s do\n      if s[i] == c\n      then\n         s = s:sub(2):sub(1)\n\
    \      else\n         s = s .. s[i]\n      end\n   end\n   local rev = s:reverse()\n\
    \   return (rev == \"\" and \"true\" or \"false\")\nend", "  s = s:lower()\n \
    \ c = c:lower()\n  local new_s = \"\"\n  local new_c = \"\"\n  local last_c =\
    \ \"\"\n  for i=1,#s do\n    if s[i] == c  then\n      new_c = last_c\n      last_c\
    \ = s[i]\n    elseif s[i] == last_c then\n      new_c = new_c..last_c\n    else\n\
    \      new_s = new_s..new_c\n      new_c = s[i]\n    end\n  end\n  if new_s ==\
    \ s then -- string is a palindrome\n    return (new_s,true)\n  else\n    return\
    \ (new_s,false)\n  end\nend", "\t-- Base case\n\tif not s then\n\t\treturn\n\t\
    end", "\tlocal str_len = len(s)\n\tlocal c_len = #c\n\tlocal result = {}\n\tlocal\
    \ i,j = 0,0\n\twhile i < str_len do\n\t\tif s[i]:sub(1,c_len) == c then\n\t\t\t\
    result[j] = s[i]\n\t\t\tj = j + 1\n\t\tend\n\t\ti = i + 1\n\tend\n\tif j > 0 then\n\
    \t\tresult[j] = nil\n\t\tj = j + 1\n\tend\n\treturn result, j == 0 or j == c_len\n\
    end", "   local reverse = \"\"\n   for i=1,#s do\n       reverse = reverse ..\
    \ c\n       if s[i] == c then reverse = reverse .. s[i] end\n   end\n   return\
    \ (reverse,true)\nend", "   -- We will use two indexes, i and j to go through\
    \ the string and find where are equal\n   local i, j = 0, #s\n   -- We will save\
    \ the result in s\n   local s = ''\n   -- While i is smaller than j\n   while\
    \ i <= j do\n      -- If s[i] == c[i], we replace s[i] with ''\n      if s[i]:sub(1,\
    \ 1) == c[i] then\n         s = s .. s[i]:sub(2)\n      -- If s[i] isn't equal\
    \ to c[i], we increment j\n      else\n         j = j + 1\n      end\n      i\
    \ = i + 1\n   end\n   -- If s[i]:sub(1, 1) isn't equal to c[i], we return '' and\
    \ False\n   if s[i]:sub(1, 1) ~= c[i] then\n      return s, 'False'\n   else\n\
    \      return s, 'True'\n   end\nend", "  local r = \"\"\n  local i = 0\n  for\
    \ i=1, #s do\n    if s[i] = c then\n      r = r..s[i]\n    else\n      r = r..s[i]\n\
    \    end\n  end\n  return r,#r > 0 and true\nend", "\t-- The base case: either\
    \ s is empty or c is empty.\n\tif s == \"\" then\n\t\treturn s,true\n\tend\n\t\
    if c == \"\" then\n\t\treturn reverse_delete(s,\"\")\n\tend\n\t\n\t-- We should\
    \ use two pointers to search through the string s\n\t-- If the pointer s is at\
    \ any point at which c is a substring of s then it is definitely a palindrome.\n\
    \tlocal i, j = 0, 0\n\twhile i < #s and j < #c do\n\t\tif s[i] == c[j] then\n\t\
    \t\ti = i + 1\n\t\t\tj = j + 1\n\t\telse\n\t\t\ti = i-1\n\t\t\tj = j-1\n\t\tend\n\
    \tend\n\t\n\tif i >= #s then\n\t\treturn s,true\n\telseif i == 0 then\n\t\treturn\
    \ reverse_delete(s[i+1:end],c),false\n\telse\n\t\treturn reverse_delete(s[i-1:i+1],c),false\n\
    \tend\nend", "  local i = 1\n  local reverse = \"\"\n  for i = #s - 1 , -1 , -1\
    \ do\n    reverse = reverse .. s[i .. c]\n  end\n  return reverse, #reverse==0\
    \ and true or false\nend", "    local i = 1\n    local j = 1\n    local reverse\
    \ = \"\"\n    while i < #s and j < #c do\n        local char = s[i % #s]\n   \
    \     if char == c[j % #c] then\n            reverse = reverse .. char\n     \
    \       i = i + 1\n            j = j + 1\n        else\n            j = j + 1\n\
    \        end\n    end\n    return (reverse, j == #c)\nend", "    local i, j, k\
    \ = 1, #s, 1\n    local result", "\tif c == \"\" then return s end\n\tlocal i,\
    \ j = 1, #s - 1\n\twhile i <= j do\n\t\tlocal char = s[i + 1]\n\t\tif char ==\
    \ c then\n\t\t\tj = i - 1\n\t\t\ts[i] = char\n\t\telse\n\t\t\tj = i + 1\n\t\t\t\
    i = i - 1\n\t\tend\n\tend\n\treturn (s, i == #s)\nend", "    local i, j = 0, #s-1\n\
    \    local str = \"\"\n    while i <= j do\n        if s[i,j] ~= c then\n    \
    \        str = str .. s[i]\n        else\n            j = j - 1\n        end\n\
    \        i = i + 1\n    end\n    return (str,true)\nend", "    -- Find the number\
    \ of characters in s whose values are equal to c in s.\n    local num = 0\n  \
    \  for i=1,#s do\n        if s[i]==c then\n            num = num + 1\n       \
    \ end\n    end\n    -- Check if num is even.\n    if num%2==0 then\n        --\
    \ Find the number of characters in s whose values are equal to c in reverse.\n\
    \        local num2 = 0\n        for i=1,#s do\n            if s[i]==c and #s==(num-1)*2\
    \ then\n                num2 = num2 + 1\n            end\n        end\n      \
    \  -- Check if the number of characters in s is equal to the number of characters\
    \ in reverse.\n        if num2 == num then\n            return (s,false)\n   \
    \     else\n            return (s,true)\n        end\n    else\n        -- Find\
    \ all characters in s whose values are equal to c in reverse.\n        local res\
    \ = {}\n        for i=1,#s do\n            if s[i]==c and #s==(num-1)*2 then\n\
    \                table.insert(res,i)\n            end\n        end\n        --\
    \ Find the number of characters in s whose values are equal to c in reverse.\n\
    \        local num2 = 0\n        for i=#res,1,-1 do\n            if s[i]==c then\n\
    \                num2 = num2 + 1\n            end\n        end\n        -- Check\
    \ if the number of characters in s is equal to the number of characters in reverse.\n\
    \        if num2 == num then\n            return (s,false)\n        else\n   \
    \         return (s,true)\n        end\n    end\nend", "    local t = {}\n   \
    \ local index = 1\n    for _, v in ipairs(s) do\n        if v == c then\n    \
    \        index = index - 1\n        else\n            t[index] = v\n        end\n\
    \    end\n    if index == 1 then\n        return t\n    end\n    local reversed\
    \ = {}\n    for _, v in ipairs(t) do\n        reversed = v..reversed\n    end\n\
    \    return reversed, true\nend", "    if #s > #c then return nil end\n    local\
    \ res\n    local pos\n    for pos = #s, 1, -1 do\n        if s[pos] == c then\n\
    \            res, pos, s[pos] = reverse(s[pos], c)\n        else\n           \
    \ break\n        end\n    end\n    return res, pos\nend", "  local i,j,k = 0,1,0\n\
    \  while i < #s do\n    if s[k] == c  then\n      if k > 0 then\n        s[k]\
    \ = s[k-1]\n        k = 1\n      else\n        k = 1\n      end\n    end\n   \
    \ if k < #s then\n      k = k + 1\n    end\n    if j == #c then\n      break \n\
    \    end\n    i = i + 1\n  end\n  return s\nend", "  -- Base case\n  if c == \"\
    \" then\n    return s\n  end\n  -- Check all characters of s\n  for i = #s, 1,\
    \ -1 do\n    local tmp = c\n    -- Check each character in c\n    for j = 1, #c\
    \ do\n      if s[i] != c[j] then\n        tmp = s[i]\n        break\n      end\n\
    \    end\n    -- If tmp has changed\n    if tmp ~= s[i] then\n      -- Remove\
    \ this character\n      s[i] = tmp\n      -- Return the result string\n      return\
    \ reverse_delete(s, c..\"\")\n    end\n  end\n  -- Return ('',False)\n  return\
    \ ('',false)\nend", "    local n = 0\n    local i = 0\n    local result = ''\n\
    \    repeat\n        i = i + 1\n        n = n - 1\n        if n==0 then\n    \
    \        n = #s\n        else\n            n = #s\n        end\n        result\
    \ = result .. s[n-i]\n    until i == #c\n    if result == s then\n        return\
    \ result, true\n    else\n        return result, false\n    end\nend", "\t-- initialize\
    \ return value\n\tlocal result\n\t-- get current index\n\tlocal index = 1\n\t\
    -- check every element of s\n\tfor index = 1, #s do\n\t\t-- check if this index\
    \ is in the c string\n\t\tif string.find(c, tostring(s[index])) ~= nil then\n\t\
    \t\t-- set the value to -1\n\t\t\tresult[1] = -1\n\t\t\t-- break the loop\n\t\t\
    \tbreak\n\t\tend\n\tend\n\t-- check if s is empty\n\tif index == 1 then\n\t\t\
    result[1] = s\n\telse\n\t\t-- reverse every element of s\n\t\tlocal reverse =\
    \ \"\"\n\t\tfor index = 1, #s do\n\t\t\treverse = reverse .. tostring(s[index])\n\
    \t\tend\n\t\t-- delete every character in c that is equal to any character in\
    \ s\n\t\tlocal deleted = reverse_delete(reverse, c)\n\t\t-- get the first character\
    \ of the result string\n\t\tresult[1] = deleted.[1]\n\t\t-- check if the result\
    \ string is palindrome\n\t\tif string.sub(tostring(result[1]), 1) == string.sub(tostring(result[1]),\
    \ #result[1]) then\n\t\t\t-- set the second element to False\n\t\t\tresult[2]\
    \ = false\n\t\telse\n\t\t\t-- set the second element to True\n\t\t\tresult[2]\
    \ = true\n\t\tend\n\tend\n\treturn result\nend", "  s = string.gsub(s, \"%c\"\
    , function (char)\n    if string.find(c, char, 1, true) == 0 then\n      return\
    \ \"\"\n    else\n      return char\n    end\n  end)\n  return s:reverse():gsub(\"\
    (^\" .. c .. \"$)|(\" .. c .. \"$)\", \"\")\nend", "\tlocal lenS=#s\n\tlocal lenC=#c\n\
    \tlocal p=\"\"\n\tlocal i=lenS\n\tlocal j=0\n\tlocal flag=0\n\twhile i<lenS do\n\
    \t\tif j==lenC and flag==1 then\n\t\t\treturn (p,flag)\n\t\telseif s[j]==c[j]\
    \ then\n\t\t\tp= p..s[j]\n\t\t\ti=i+1\n\t\telse\n\t\t\tp= p..s[j]\n\t\t\tj=j+1\n\
    \t\tend\n\tend\n\treturn (p,flag)\nend", "    local ans = \"\"\n    for i=1,#s\
    \ do\n        ans = ans .. c:sub(1,1):sub(i-1)\n    end\n    return ans,string.gsub(ans,ans:reverse(),\"\
    \")\nend", "\tlocal str = \"\"\n\tfor i=1,#s do\n\t\tif s[i] == c then\n\t\t\t\
    str = str .. s[#s]\n\t\telse\n\t\t\tstr = str .. s[i]\n\t\tend\n\tend\n\treturn\
    \ (str,#s == #str)\nend", "   -- If both strings are empty return empty string,\
    \ True\n   if #s == 0 and #c == 0 then\n      return '', true\n   end\n   -- If\
    \ the first string is empty return second string, True\n   if #s == 0 then\n \
    \     return c, true\n   end\n   -- If first and second string are equal, return\
    \ empty string, False\n   if s[#s] == c then\n      return '', false\n   end\n\
    \   -- Delete first and second string, check for palindrome\n   -- Since we are\
    \ working with characters, we use characters as the iterator\n   local first_itr\
    \ = #s\n   local last_itr = #s\n   while #s > 0 do\n      -- Delete first character\n\
    \      s = string.sub(s,1,#s-1) -- Reverse string\n      -- Check if string is\
    \ the same backwards and forwards\n      -- If not, return empty string and false\n\
    \      if s[first_itr] == s[last_itr] then\n         return '', false\n      end\n\
    \      -- Update last iterator\n      last_itr = first_itr\n      first_itr =\
    \ first_itr - 1\n   end\n   -- If we get to here, then either first and last were\
    \ equal, or the last was at the end\n   -- so just return the original string\
    \ and true\n   return s, true\nend", "  -- Keep the count of how many times the\
    \ character repeats\n  local cnt = 0\n  -- For each characters in s, if the charcter\
    \ is in c, increment the counter\n  for i=1,#s do\n    if s[i] == c then\n   \
    \   cnt = cnt + 1\n    end\n  end\n  -- If all the characters are the same in\
    \ c, the result will be the string that has no duplicates\n  if cnt == #c then\n\
    \    return s\n  end\n  -- If there are some characters in c that are not in the\
    \ string, return false\n  if cnt < #c then\n    return false\n  end\n  -- If the\
    \ result string is empty, return an empty string\n  if #s == 0 then\n    return\
    \ \"\"\n  end\n  -- For each characters in s, if the charcter is in c, remove\
    \ it from s\n  local newString = \"\"\n  for i=1,#s do\n    if s[i] == c then\n\
    \      s = s:sub(1,i)\n    else\n      newString = newString .. s[i]\n    end\n\
    \  end\n  -- For each characters in s, add them to the result\n  while #s > 0\
    \ do\n    if s[#s] == c then\n      newString = newString .. s[#s]\n      s =\
    \ s:sub(1)\n    else\n      newString = newString .. s[#s]\n    end\n  end\n \
    \ -- If there are still characters in s to remove, return false because there\
    \ is no palindrome\n  if #s > 0 then\n    return false\n  end\n  -- If there are\
    \ still characters in s to keep, return result string and true\n  return newString\n\
    end", "  -- To check whether character in s is equal to any character in c ,\n\
    \  -- we do a sliding window.\n  local index = 0\n  -- Check if any character\
    \ in c are deleted\n  while index do\n    if string.sub(s, index, index + 1) ~=\
    \ c then\n      -- If not , delete the character in s and continue.\n      index\
    \ = string.len(s) - index\n      -- Continue to delete character in s\n      --\
    \ if still not any character, break the loop\n      if not index then break end\n\
    \    end\n    index = index + 1\n  end", "    local rs, rc = \"\", \"\"\n    for\
    \ i = 1, #s do\n        local c = s[i]\n        if c == c then\n            rs\
    \ = rs .. c\n        elseif c == c * 2 then\n            rs = rs .. c\n      \
    \      rc = rc .. c\n        elseif c ~= c then\n            rs = rs .. c\n  \
    \      end\n    end\n    return (rs, rc == c)\nend\n</code>\n<|/ a tags=algorithm,lua,string\
    \ |>\n<| c |>\nThis is really nice work and I did some benchmarking with both\
    \ methods in Lua 5.1.4. One more question, why do you think `reverse_delete` is\
    \ faster than `reverse`? Do you think my solution is wrong?\n<|/ c |>\n<| c |>\n\
    : I suspect reverse is faster in this case because it doesn't need to do any allocations.\
    \ In reverse_delete it allocates one string for every character, but in this case\
    \ only one string is ever allocated at a time.\n<|/ c |>\n<| a |>\nTo expand on\
    \ david's answer, the following is a recursive algorithm to determine whether\
    \ a string is a palindrome or not:\n<code>", "  local i, j = 1, #s - 1\n  while\
    \ (j > 0 or i < j) do\n    local a = s[i + j]\n    s[j] = s[i]\n    s[i] = a\n\
    \    if (a == c) then\n      i = i + 1\n      j = j - 1\n    else\n      j = j\
    \ - 1\n    end\n  end\n  return (i == #s) and (s==s..s[#s])\nend", "  -- check\
    \ if the string c is palindrome\n  if c == \"\\000\" then\n    return (\"\\000\"\
    ,false)\n  end\n  -- reverse string and delete the characters equal to the character\
    \ in c\n  local reverse = s:reverse():gsub(c,\"\")\n  -- check if string is a\
    \ palindrome\n  if reverse == s then\n    return (s,true)\n  end\n  -- if the\
    \ string is not a palindrome\n  return (reverse,false)\nend", "    local l={}\n\
    \    for i=1,#s do table.insert(l, string.sub(s,i,i)) end\n    if #c>0 then\n\
    \        local t={}\n        for i=1,#c do table.insert(t,string.sub(c,i,i)) end\n\
    \        for i=1,#l do table.insert(t, l[i]) end\n        l=t\n    end\n    local\
    \ str=\"\"\n    local found=false\n    for i=1,#l do str=str..l[i] end\n    for\
    \ i=1,#str-1 do\n        local index=string.find(str, str[i])\n        if index\
    \ > 1 then\n            table.insert(str, str[index-1])\n            table.insert(str,\
    \ str[index+1])\n            found=true\n        end\n    end\n    return (str,\
    \ found)\nend", "    local i = 0\n    local result = ''\n    while i < #s do\n\
    \        if s[i] == c then\n            i = i + 1\n        else\n            table.insert(result,\
    \ s[i])\n        end\n    end\n    table.insert(result, s[i])\n    return result,\
    \ #result == #s\nend", "  -- Get the list of characters that are equal to c\n\
    \  local c_list = {}\n  for i = 1, #c do\n    c_list[#c_list + 1] = c[i]\n  end\n\
    \  -- Get the list of characters that are not equal to c\n  local c_list2 = {}\n\
    \  for i = 1, #c do\n    c_list2[#c_list2 + 1] = c[i]\n  end\n  -- Get the list\
    \ of characters that are equal to c\n  local c_list3 = {}\n  for i = 1, #s do\n\
    \    c_list3[#c_list3 + 1] = s[i]\n  end\n  -- Get the list of characters that\
    \ are not equal to c\n  local c_list4 = {}\n  for i = 1, #s do\n    c_list4[#c_list4\
    \ + 1] = s[i]\n  end\n  -- Reverse the list by deleting element one by one\n \
    \ -- This way we only need to loop over each half of the string\n  -- Once we\
    \ delete one character, we can just loop over the string again\n  -- until we\
    \ have done all characters\n  for i = #c_list3, 1, -1 do\n    -- We have reached\
    \ the front of the list\n    -- Need to delete an element from either c_list or\
    \ c_list2\n    -- Choose which one to delete based on which half we are\n    --\
    \ Deleting from c_list\n    if i > #c_list2 then\n      c_list3[i] = c_list3[i\
    \ - 1]\n    else\n      c_list3[i] = c_list2[i - 1]\n    end\n    -- Delete from\
    \ c_list2 so that we don't delete any duplicates\n    -- that may have already\
    \ been deleted from c_list\n    if i ~= #c_list2 then\n      c_list2[#c_list2\
    \ + 1] = c_list2[i - 1]\n    end\n    -- Delete from c_list so that we don't delete\
    \ any duplicates\n    -- that may have already been deleted from c_list\n    if\
    \ i ~= #c_list then\n      c_list[#c_list + 1] = c_list[i - 1]\n    end\n  end\n\
    \  -- Get all the characters that are equal to the final character\n  local c_list5\
    \ = {}\n  for i = 1, #c_list3 do\n    c_list5[#c_list5 + 1] = c_list3[i]\n  end\n\
    \  -- Return tuple of final string and boolean indicating if this is a palindrome\n\
    \  return string.rep((#c_list5 > #c_list) and c_list5[#c_list5 + 1] or c_list,\
    \ 1, #c_list), c_list5[#c_list5 + 1] == c_list5[#c_list5]\nend", "  -- base case\n\
    \  if s == nil or c == nil then\n    return nil, true\n  end", "    -- Base Case\n\
    \    if c == '' or s == c then\n        return s,true\n    end", "    if #s <=\
    \ 0 then\n        return s, false\n    end\n    local reversed = \"\"\n    for\
    \ i = #s-1, 1, -1 do\n        reversed = reversed + s[i]\n    end\n    if s ==\
    \ reversed then\n        return reversed, true\n    else\n        return reverse_delete(reversed,\
    \ c)\n    end\nend", "\t-- base case\n\tif c > #s or #s == 0 then return ('',False)\
    \ end", "\tlocal i, j = 1, #s\n\tlocal result = ''\n\twhile i > 0 and j > 0 do\n\
    \t\tif s[i] ~= c[j] then\n\t\t\tresult = result .. s[i]\n\t\telse\n\t\t\tresult\
    \ = result .. c[j]\n\t\t\ti = i - 1\n\t\t\tj = j - 1\n\t\tend\n\tend\n\t-- check\
    \ if result is empty string because slicing doesn't return empty string\n\tif\
    \ result ~= '' then\n\t\treturn result, true\n\telse\n\t\treturn result, false\n\
    \tend\nend", "   local result = \"\"\n   for _,x in ipairs(s) do\n      if x==c\
    \ then\n         if s==result then\n            return\n         end\n       \
    \  result = result .. x\n      else\n         result = result .. x\n      end\n\
    \   end\n   if s==result then\n      return (result,true)\n   end\n   return (result,false)\n\
    end", "\tlocal result = \"\"\n\tlocal is_palindrome = true\n\tlocal is_in = false\n\
    \tlocal i = 1\n\twhile i <= #s and i <= #c do\n\t\tif s[i] == c[i] then\n\t\t\t\
    i = i + 1\n\t\telse\n\t\t\tresult = result .. s[i]\n\t\t\tis_palindrome = false\n\
    \t\t\tbreak\n\t\tend\n\tend\n\tif i == #s then\n\t\treturn (result,is_palindrome)\n\
    \telse\n\t\treturn (result,not is_palindrome)\n\tend\nend", "    local rev_s =\
    \ reverse(s)\n    local rev_c = reverse(c)\n    if rev_s == rev_c then\n     \
    \   return (rev_s, false)\n    else\n        return (rev_s, true)\n    end\nend",
  "    local reverse = ''\n    for i = #s, 1, -1 do\n        reverse = reverse ..\
    \ c\n    end\n    return (reverse == s and true or false, s)\nend", "  local len_c\
    \ = #c\n  local len_s\n  if #s > #c then len_s= #s else len_s= #c end\n  local\
    \ i, j, result= 0, 0, ''\n  for i=1,len_s do\n    j = len_s-i-1\n    result= result\
    \ .. c[j] .. s[i]\n    if len_c == len_s  and result == s then return result,true\
    \ end\n  end\n  return result,false\nend", "  for i=1,#s do\n    if s[i]==c then\n\
    \      table.remove(s,i)\n      break\n    end\n  end\n  local is_palindrome =\
    \ #s==0 or #s==#s-1\n  if is_palindrome then\n    return s, is_palindrome\n  else\n\
    \    return nil, is_palindrome\n  end\nend", "\tlocal result = ''\n\tlocal i =\
    \ 0\n\tlocal j = 0\n\twhile i < #s and j < #c do\n\t\tif s[i] ~= c[j] then\n\t\
    \t\tresult = result .. s[i]\n\t\t\ti = i + 1\n\t\telse\n\t\t\tresult = result\
    \ .. c[j]\n\t\t\ti = i + 1\n\t\t\tj = j + 1\n\t\tend\n\tend\n\tresult = result\
    \ .. s[i+1 .. #s]\n\t\n\tif result ~= s then\n\t\treturn result,true\n\telse\n\
    \t\treturn result,false\n\tend\nend", "    local i = 0\n    local j = 0\n    local\
    \ result = ''\n    while i <= #s do\n        local char = s[i]\n        if char\
    \ == c[i] then\n            i = i + 1\n        elseif char == c[j]  then\n   \
    \         j = j + 1\n        else\n            result = result .. char\n     \
    \   end\n    end\n    if i == #s and j > 0 then\n        result = result .. s[j]\n\
    \    end\n    return result, i == #s\nend", "  -- This will be the result of the\
    \ operation\n  local result = {}\n  -- For each character in c\n  for _, c in\
    \ ipairs(c) do\n    local index = {}\n    local s = s\n    local isDeleted = false\n\
    \    -- For each character in s\n    for _, s in ipairs(s) do\n      -- If the\
    \ current character is the one we delete\n      -- Add the index where the current\
    \ character is located\n      if c == s then\n        index = table.insert(index,\
    \ #index + 1)\n      else\n        -- Otherwise, delete the character\n      \
    \  index = table.insert(index, #index)\n      end\n    end\n    -- If the result\
    \ string is not palindrome\n    -- Add the current index to the result string\n\
    \    if not isDeleted then\n      result = table.concat(result, index, \"\")\n\
    \    end\n  end\n  return result, #result == #c\nend", "\tlocal result = {}\n\t\
    local len = #s\n\tlocal pos = 0\n\twhile pos<len do\n\t\tif s[pos] == c then\n\
    \t\t\ttable.insert(result, string.sub(s,pos+1,pos))\n\t\t\tpos = pos + 1\n\t\t\
    elseif s[pos] ~= c then\n\t\t\tpos = pos + 1\n\t\telse\n\t\t\tpos = pos + 1\n\t\
    \t\tbreak\n\t\tend\n\tend\n\treturn (table.concat(result,\"\"),(pos==len))\nend",
  "  -- base case: empty string\n  if s == nil or c == nil then\n    return s, false\n\
    \  -- recursive case: not empty\n  elseif #s < 1 then\n    return s, false\n \
    \ else\n    -- split into characters\n    local s1, s2 = s:sub(1,#s-1), s:sub(1,#s)\n\
    \    -- split into characters\n    local s1, s2 = reverse_delete(s1, c), reverse_delete(s2,\
    \ c)\n    -- join characters\n    return s1 .. s2, true\n  end\nend", "    local\
    \ newS = string.gsub(s, '[' .. c .. ']', '')\n    if newS ~= s then return newS,true\
    \ else return newS,false end\nend", "    local t = {}\n    local l = #c\n    for\
    \ i = 1,l do\n        t[#t+1] = c[i]\n    end\n    local j = 1\n    for i = 1,l\
    \ do\n        t[#t+1] = s[i][j]:reverse()\n        j = j+1\n    end\n    local\
    \ result = t[1]\n    local isPalindrome = true\n    for i = 2,#t do\n        if\
    \ t[i] ~= t[i-1] then\n            isPalindrome = false\n            break\n \
    \       end\n    end\n    return (result,isPalindrome)\nend", "  -- check whether\
    \ s and c are valid string\n  if not s or not c or #s > #c or #c > 0 then\n  \
    \  return nil,nil\n  end\n  -- reverse s and c\n  local reverse = string.gsub(s,\"\
    %s\",function(x)\n    return string.sub(s,#x+1,#x)\n  end)\n  reverse = string.gsub(reverse,\"\
    %s\",function(x)\n    return string.sub(c,#x+1,#x)\n  end)\n  -- check whether\
    \ reverse is palindrome\n  if reverse ~= s then\n    return nil,nil\n  end\n \
    \ -- reverse s and c\n  local reverse = string.gsub(s,\"%s\",function(x)\n   \
    \ return string.sub(s,#x+1,#x)\n  end)\n  reverse = string.gsub(reverse,\"%s\"\
    ,function(x)\n    return string.sub(c,#x+1,#x)\n  end)\n  -- check whether reverse\
    \ is palindrome\n  if reverse ~= s then\n    return nil,nil\n  end\n  return s,true\n\
    end", "  if c == '' then return s, true end\n  local start = 1\n  local end  =\
    \  #s-1 \n  local res  = {}\n  while start <= end do\n    if s[start] == c then\n\
    \      res[#res+1] = s[start]\n      start = start + 1\n    else\n      start\
    \ = start + 1\n    end\n  end\n  if #res < 1 then return res, false end\n  res[#res]\
    \ = ''\n  return res, s[#res]\nend", "    -- We are using s instead of s because\
    \ it is mutable and we want to change the original string.\n    local result =\
    \ s\n    -- We loop through the given string and check if it is equal to the given\
    \ character\n    for i = 1, #s do\n        if s[i] != c then\n            result\
    \ = result .. s[i]\n        end\n    end\n    return (result, #s == #result)\n\
    end", "  -- check if there are any chars\n  assert(#s > 0)\n  assert(#c > 0)\n\
    \  -- reverse\n  local s = s:reverse()\n  -- iterate over s, remove all chars\
    \ equal to c\n  for i = 1, #s do\n    if s[i] == c then\n      s = s:sub(1, i\
    \ - 1)\n      break\n    end\n  end\n  -- check if there are any chars left\n\
    \  assert(#s > 0)\n  -- reverse the string\n  s = s:reverse()\n  -- check if string\
    \ is the same forward/backward\n  if s == s then\n    return ('',True)\n  else\n\
    \    -- reverse the string\n    s = s:reverse()\n    -- check if string is the\
    \ same forward/backward\n    if s == s then\n      return ('',False)\n    else\n\
    \      return ('('..s','..(s == s))\n    end\n  end\nend", "  local new_s = \"\
    \"\n  local okay = true\n  for i = 0, #s do\n    if s[i] == c then\n      new_s\
    \ = new_s .. s[i]\n    elseif s[i] ~= c then\n      okay = false\n    end\n  end",
  "\t-- We are given two strings s and c, you have to deleted all the characters in\
    \ s that are equal to any character in c\n\t-- then check if the result string\
    \ is palindrome.\n\t-- A string is called palindrome if it reads the same backward\
    \ as forward.\n\t-- You should return a tuple containing the result string and\
    \ True/False for the check.\n\t-- Example\n\t-- For s = \"abcde\", c = \"ae\"\
    , the result should be ('bcd',False)\n\t-- For s = \"abcdef\", c = \"b\"  the\
    \ result should be ('acdef',False)\n\t-- For s = \"abcdedcba\", c = \"ab\", the\
    \ result should be ('cdedc',True)\n\tif #s ~= #c then return ('',False) end\n\t\
    local result = ''\n\tlocal is_palindrome = True\n\t\n\tfor i in ipairs(s) do\n\
    \t\tfor j in ipairs(c) do\n\t\t\tif s[i] == c[j] then\n\t\t\t\tresult = result\
    \ .. s[i]\n\t\t\t\ts = s:gsub(i,\"\")\n\t\t\t\tc = c:gsub(j,\"\")\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\tend\n\tif result ~= '' then is_palindrome = false end\n\t\
    return (result, is_palindrome)\nend", "  local s = s or \"\"\n  local c = c or\
    \ \"\"\n  local result = \"\"\n  for i=#s, 1, -1 do\n    local pos = string.find(s,\
    \ c, i)\n    if pos ~= nil then\n      result = result .. s[pos]\n      s = string.sub(s,1,pos-1)\
    \ .. string.sub(s,pos+1)\n    else\n      result = result .. s[i]\n    end\n \
    \ end\n  return result, s == result\nend", "\tlocal res = ''\n\tfor i = 1,#s do\n\
    \t\tif s[i] == c then\n\t\t\tres = string.sub(s,i-1,i-1) == res then\n\t\telse\n\
    \t\t\tres = res .. s[i]\n\t\tend\n\tend\n\treturn res, string.sub(s,#s)==res\n\
    end", "   local result = \"\";\n   for c in s:gmatch(\"(.)\"):gmatch(\"(.)\")\
    \ and \"(.)\" or \"\" do \n      if c:sub(1, 1) == c:sub(2, 2) then\n        \
    \ result = result .. c:sub(1, 1);\n      else\n         result = result .. c:sub(1,\
    \ 2) .. c:sub(2, 1);\n      end;\n   end; \n   return (result, c == result and\
    \ true or false);\nend; ", "  s = s or \"c\"\n  c = c or \"ab\"\n  local s = string.gsub(s,\
    \ \"%a\", function()\n    return string.sub(s, 1, string.len(s) - 1)\n  end)\n\
    \  local c = string.gsub(c, \"%a\", function()\n    return string.sub(c, 1, string.len(c)\
    \ - 1)\n  end)\n  local i = #s\n  local j = 0\n  local x = \"\"\n  while i <=\
    \ 0 do\n    local c = string.sub(s, i, i)\n    if c ~= string.sub(c, j) then\n\
    \      x = x .. c\n    end\n    i = i + 1\n    j = j + 1\n  end\n  if x ~= s then\n\
    \    return (x:reverse():gsub(\"%a\", \"a\"), false)\n  end\n  return (s, true)\n\
    end", "   -- base case\n   if (#s > 1) then\n      -- delete all equal character\
    \ and return the new string\n      -- then check if its palindrome or not\n  \
    \    local s = reverse_delete(s[1:#s], c)\n      if (s == c) then\n         return\
    \ s\n      else\n         return reverse_delete(s, c)\n      end\n   else\n  \
    \    return s\n   end\nend", "  -- TODO: complete this function!\nend", "\tlocal\
    \ reverse, result = string.gsub( s, '^', '') -- get rid of leading ^\n\treverse\
    \ = reverse:gsub('^', c) -- get rid of leading c\n\tif reverse == s then return\
    \ (result, false) end\n\tlocal revReverse, result = reverse_delete(reverse, c)\n\
    \tif revReverse == s then return (result, false) end\n\trevReverse = revReverse:gsub('^',\
    \ c)\n\trevReverse = revReverse:gsub('$', c) -- get rid of trailing c\n\tif revReverse\
    \ == s then return (result, false) end\n\trevReverse = revReverse:gsub('$', c)\n\
    \treturn (reverse, false)\nend", "  local pal = s:reverse()\n  return pal:sub(1,\
    \ pal:find(c)) ~= nil or (s:sub(1, #s)) == s -- no palindrome or one character\n\
    end", "\tlocal s = s:gsub(\"(.)\", string.rep(\"%1$2\", c:len()) .. \"%1$1\")\n\
    \tlocal result = s:gsub(\"%1%1\", c)\n\treturn result, s:sub(#result) ~= nil\n\
    end", "    local result = \"\"\n    local done = false\n    for i=1, #s do\n \
    \       if done then\n            break\n        end\n        local found = false\n\
    \        for j=1, #c do\n            if c[j] == s[i] then\n                found\
    \ = found or j\n            end\n        end\n        if not found then\n    \
    \        result=result..s[i]\n            done = true\n        end\n    end\n\
    \    local reverse = result\n    local done = true\n    local count\n    local\
    \ index\n    local last\n    while done do\n        done = false\n        for\
    \ index=1, #c do\n            count = string.len(reverse)\n            reverse\
    \ = reverse..c[index]\n            done = done or count-1 > #reverse\n       \
    \ end\n        if last and #last > 0 then\n            count = string.len(reverse)\n\
    \            reverse = reverse..c[index]\n            done = done or count-1 >\
    \ #reverse\n        end\n        last=reverse\n    end\n    return reverse, done\n\
    end", "    local result = \"\";\n    local flag;\n    local i;\n    local j;\n\
    \    for i = 1, #s do\n        flag = true;\n        for j = 1, #c do\n      \
    \      if s[i:len(i)] == c[j:len(j)] then\n                flag = false;\n   \
    \         end\n        end\n        if flag == true then\n            result =\
    \ result .. s[i];\n        end\n    end\n    return result, flag;\nend", "  if\
    \ #s < 1 then return nil, false end\n  if #c < 1 then return s, false end", " \
    \  local r = ''\n   for i = 1, #s do\n      if s[i] ~= c then\n         r = r\
    \ .. s[i]\n      else\n         return (r,true)\n      end\n   end\n   return\
    \ (r,false)\nend", "    local result = {}\n    for i=1, #s do \n        table.insert(result,string.sub(s,i,i))\n\
    \    end", "  for i,v in string.gmatch(s,\"(..)\") do\n    if v == c then\n  \
    \    string.gsub(s,\"(..)\"..i,\"\")\n    end\n  end\n  return s,string.gmatch(s,\"\
    (..)\"..c)\nend", "\t-- base case\n\tif #s == 0 then\n\t\treturn s, false\n\t\
    end", "    if #s == 0 then return false, s end\n    if #c == 0 then return false,\
    \ c end\n    if #s == 1 then return true, s:sub(#s-1, 1) end\n    local ss, se\
    \ = s:sub(1,1), s:sub(#s-1,1)\n    local cs, ce = c:sub(1,1), c:sub(#c-1,1)\n\
    \    local reverse = reverse_delete(ss, cs)\n    if reverse then\n        return\
    \ reverse, string.rep(cs, #s) .. string.rep(ss, #s) .. reverse_delete(se, cs)\n\
    \    else\n        return false, s\n    end\nend", "   -- TODO: implement this\
    \ function\n   \n   -- Base Case\n   if #s < 1 then\n      return s\n   end\n\
    \   \n   -- Recursive Case\n   local sub, start, middle, done = s, 1, 0, false\n\
    \   while done ~= true do\n      if sub:sub(1,1) ~= c then\n         done = true\n\
    \      else\n         middle = start + (middle / 2)\n         sub = sub:sub(middle+1)\n\
    \         start = middle + 1\n      end\n   end\n   return sub, done\nend", " \
    \ local new_s = \"\"\n  for _, c in ipairs(s) do\n    if c ~= cs[c] then new_s\
    \ = new_s .. c end\n  end\n  if new_s == s then\n    return (\"palindrome\", true)\n\
    \  else\n    return (\"palindrome\", false)\n  end\nend", "  local result = ''\n\
    \  for i = 1, #s do\n    local found = false\n    for j = 1, #c do\n      if s[i]\
    \ == c[j] then\n        found = true\n        break\n      end\n    end\n    if\
    \ found then result = result .. s[i] end\n  end\n  return (result,string.find(result,c)~=0)\n\
    end", "  local reversed_str = string.gsub(s, c, '') -- Reverse all strings that\
    \ have c in them\n  local str_in_result = reversed_str .. s -- Pad the original\
    \ string to account for the reversed string\n  local result = string.gsub(str_in_result,\
    \ '^%..', '') -- Remove any leading spaces from the result\n  local bool = string.gsub(result,\
    \ '.', '') -- Remove the final .\n  -- Check to make sure there are not two '.'\
    \ in result\n  -- If the string is not equal to the last character in reversed_str,\
    \ then the string is not palindrome\n  -- Otherwise, if the string is not equal\
    \ to the first character in reversed_str, then the string is not palindrome\n\
    \  return result, bool\nend", "   local s_reverse = \"\"\n   for i,v in ipairs(s)\
    \ do\n     s_reverse = s_reverse .. v\n   end\n   if s_reverse == s then\n   \
    \  return (s,true)\n   else\n     s_reverse = s_reverse .. c\n     return (s_reverse,false)\n\
    \   end\nend", "   -- The first string is empty (s is empty) and the second string\
    \ is empty (c).\n   -- The check will be true only when there is at least one\
    \ character in c.\n   -- The first string s is empty and there is no character\
    \ in c, so we have to reverse the second string c\n   -- The reverse of c is also\
    \ empty, c is empty, so the result is also empty.\n   -- The check will be true\
    \ only when c is empty, so it is also valid.\n   -- The first string s is empty\
    \ and there are no characters in s, so the result is also empty.\n   if s == c\
    \ and s == \"\" and c == \"\" then\n      return (s, false)\n   end\n   local\
    \ i, j = 0, 1\n   while j < #s do\n      if s[i] == c[j] then\n         if j ==\
    \ #s - 1 then\n            i, j = i, j + 1\n         else\n            i, j =\
    \ i + 1, j + 1\n         end\n      else\n         if j == #s - 1 then\n     \
    \       return (s, false)\n         end\n      end\n   end\n   return (s, true)\n\
    end", "  local i, j = #s, 1\n  while i < j do\n    if s[i] != c then return false,\
    \ i end\n    i = i + 1;\n    j = j - 1\n  end\n  return true, j\nend", "    --\
    \ The base case: either s is empty or c is empty\n    if #s == 0 then\n      \
    \  if c == \"\" then\n            return \"\"\n        else\n            return\
    \ (c, true)\n        end\n    end\n    if c == \"\" then\n        return (reverse_delete(s[1:end],\
    \ \"\"), false)\n    end\n    -- recursive case\n    local result = reverse_delete(s[1:end],\
    \ c)\n    if not result[1] then\n        return result\n    end\n    return (reverse_delete(s,\
    \ result[1]..c), false)\nend", "  local results = {}\n  for i = 1, #s do\n   \
    \ local current = s[i]\n    local found = false\n    for j = 1, #c do\n      if\
    \ current == c[j] then\n        results[i] = c[j]\n        found = true\n    \
    \    break\n      end\n    end\n    if not found then\n      results[i] = current\n\
    \    end\n  end\n  return unpack(results)\nend", "    if c == '' then\n      \
    \  return s, true\n    end\n    local s = reverse_delete(s, c[1:len(c)])\n   \
    \ return s, not c:sub(1, len[c]) and s:sub(1, len[c]) or not s:sub(1, len[c])\
    \ or s:sub(1, len[c]) and reverse_delete(s, c[end]) -- True/False\nend", "\tlocal\
    \ result = ''\n\tfor i = 1,#s do\n\t\tresult = result .. c\n\t\tif s[i] == s[#s]\
    \ then -- If character at end of s is equal to character at start of s\n\t\t\t\
    break\n\t\tend\n\tend\n\t\n\tlocal resultReverse = result\n\tlocal isPalindrome\n\
    \t\n\tfor i in 1,#resultReverse do\n\t\tif resultReverse[i] ~= result[i]\n\t\t\
    then\n\t\t\tisPalindrome = false\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\treturn (result,isPalindrome)\n\
    end", "  -- If there is no character in c then return s (no change)\n  if not\
    \ c then return s end\n  -- If there is only one character in c return s it (no\
    \ change)\n  if #c <= 1 then return s end\n  -- If there are no characters in\
    \ c then return '' and False\n  if #c == 1 then return s, false end\n  -- We will\
    \ loop through each character in s, deleting character in c\n  local rev = s\n\
    \  for i in 1 .. #s do\n    -- Reverse the character\n    rev = rev:sub(1,#rev)\
    \ + c:sub(i-1,i)\n    -- If the characters are equal then break and return the\
    \ string\n    if rev == s then break end\n  end\n  return rev,true\nend\nprint(reverse_delete('abcde','e'))",
  "  local new_s = \"\"\n  for i=1,#s,1 do\n    local char = s[i]\n    local new_char\
    \ = char\n    for j=1,#c,1 do\n      if char == c[j] then\n        new_char =\
    \ new_char..char\n        break\n      end\n    end\n    new_s = new_s..new_char\n\
    \  end\n  return new_s, (new_s == new_s)\nend", "  -- reverse the string and delete\
    \ the characters\n  local new_s = \"\"\n  local new_c = \"\"\n  for i = #s-1,\
    \ 1, -1 do\n    new_s = new_s .. tostring(s[i])\n    new_c = new_c .. tostring(c[i])\n\
    \  end", "  if #s < #c then\n    return (reverse_delete(s .. c .. '', c), true)\n\
    \  else\n    return (reverse_delete(s, c:sub(1,#c-1)), false)\n  end\nend", "\t\
    local r = ''\n\tfor j = 0, #s do\n\t\tif tostring(s[j]) ~= c then\n\t\t\tr = r\
    \ .. tostring(s[j])\n\t\telse\n\t\t\t-- Remove the character that needs to be\
    \ deleted.\n\t\t\ts = r:sub(r:len() - j - 1)\n\t\t\t-- If we have only 1 character\
    \ left then it is a palindrome.\n\t\t\tif s == '' then\n\t\t\t\treturn (r,true)\n\
    \t\t\telse\n\t\t\t\treturn (r,false)\n\t\t\tend\n\t\tend\n\tend\n\t-- If we reach\
    \ here then we have checked all characters in string.\n\treturn (r,false)\nend",
  "  local function helper(s, c, r, n)\n    if r == n then\n      return (s, r ==\
    \ n)\n    end\n    r, n = n + 1 , n\n    return helper(s,c,r, n)\n  end\n  local\
    \ r, n = 0, #s\n  return helper(s, c, r, n)\nend", "  -- Check if s and c are\
    \ both palindromes\n  if s == c and s == s then\n    return (s,true)\n  end\n\
    \  -- reverse the string\n  local r = s:reverse()\n  -- find the last occurence\
    \ of c in r\n  local i = #r\n  while i >= 1 do\n    if r[i] == c then\n      i\
    \ = i - 1\n    else\n      break\n    end\n  end\n  -- delete the chars\n  r =\
    \ r:sub(1,i)\n  -- reverse the string again\n  r = r:reverse()\n  -- check if\
    \ r is equal to the original string\n  -- return r\n  if r == s then\n    return\
    \ (r,false)\n  end\n  -- reverse the string and check if it matches the original\
    \ string\n  return (reverse_delete(r,c),false)\nend", "   local res = {}\n   for\
    \ i = 1,#s do\n      if s[i] == c then\n         for j = i,#s do\n           \
    \ table.insert(res, s[j])\n         end\n      end\n   end\n   return (table.concat(res),\
    \ true)\nend", "  for i, j in pairs(s) do\n    if j == c[i] then\n      s = s:gsub(i,\
    \ \"\")\n    end\n  end\n  return s, s:reverse():reverse() == s\nend", "  local\
    \ result=\"\"\n  local result1 = \"\"\n  for i=1,#s do\n    local s=string.sub(s,i,i+1)\n\
    \    if s == c then\n      table.insert(result1,s)\n    end\n  end\n  if #result1\
    \ == 0 then\n    return result,false\n  end\n  for i=#result1,1,-1 do\n    if\
    \ string.sub(result1,i,i) == string.sub(result1,i-1,i) then\n      result=result..string.sub(result1,i,i)\n\
    \    else\n      break\n    end\n  end\n  return result,true\nend", "   for i\
    \ = #s,1,-1 do\n      s = s.sub(i,i)\n      if s == c then\n         return s,false\n\
    \      end\n   end\n   if #s > 0 then\n      return s,true\n   else\n      return\
    \ s,false\n   end\nend", "\tlocal n = {}\n\tfor k, v in pairs(s) do\n\t\tn[v]\
    \ = nil\n\tend\n\tn[c] = c\n\tlocal rev = { [c] = nil }\n\t\n\tfor k, v in pairs(n)\
    \ do\n\t\tif not rev[v] then\n\t\t\trev[v] = v\n\t\t\ttable.insert(rev, v)\n\t\
    \tend\n\tend\n\t\n\tif #rev > 0 and #rev == #s then return (rev[#rev],true) end\n\
    \tif #rev > 0 and #rev > #s then return (s,false) end\n\tif #rev > 0 and #rev\
    \ < #s then return (s,false) end\n\treturn (s,false)\nend", "    local results\
    \ = {}\n    for c in s:gmatch(\"([\" .. c .. \"]+)\") do\n        table.insert(results,\
    \ string.rep(c, 1)) -- prepend\n    end\n    table.insert(results, s)\n    table.sort(results)\n\
    \    if table.concat(results) == s or table.concat(results) == s then\n      \
    \  return table.concat(results), true\n    else\n        return table.concat(results),\
    \ false\n    end\nend", "  local result = ''\n  local is_palindrome = true", " \
    \ local res = {}\n  for i = 1, #s do\n    if s[i] = c then\n      table.insert(res,\
    \ s[i])\n    end\n  end\n  return res, #res == #s or #res == 0\nend", "\t-- Base\
    \ Case\n\tif(s == \"\") return \"\"\n\t\n\t-- We start by deleting the first character\
    \ in s\n\t-- If it is the same as c, then we return s and True\n\t-- Otherwise,\
    \ we start at the second character in s\n\tlocal i = 2\n\t\n\t-- While i is less\
    \ than the length of s\n\twhile i < #s do\n\t\tif(s[i] == c) then\n\t\t\t-- Delete\
    \ the character at i\n\t\t\ts[i] = nil\n\t\t\t-- Remove it from the string\n\t\
    \t\ts = string.sub(s,1,i)\n\t\t\t-- Return the string and false\n\t\t\treturn\
    \ (s,false)\n\t\telse\n\t\t\ti = i + 1\n\t\tend\n\tend\n\t-- Return the string\
    \ and true\n\treturn (s,true)\nend", "    local result\n    if s == c then \n\
    \        result = s\n        return result, true\n    else\n        result = string.rep(s,\
    \ c:len())\n        result = result..c\n        -- Remove each character in s\
    \ whose value is equal to any character in c\n        local i = 1\n        local\
    \ j = 1\n        while i <= #s and j <= #c do\n            if s[i] == c[j] then\
    \ \n                result:sub(i, 1)\n                -- remove all character\
    \ with value == j\n                i = i + 1\n                j = j + 1\n    \
    \        else\n                j = j + 1\n            end\n        end\n     \
    \   -- Check if result is palindrome\n        if result == string.reverse(result)\
    \ then\n            return result, false\n        else\n            return reverse_delete(result,\
    \ c)\n        end\n    end\nend", "    if not s:match(\"^(.-)$\") then return\
    \ {\"\", false} end\n    local reverse = \"\"\n    for i = #s, 1, -1 do\n    \
    \    reverse = reverse .. c\n        local found = false\n        for j = #c,\
    \ 1, -1 do\n            if c[j] == s[i] then\n                found = true\n \
    \           end\n        end\n        if not found then\n            reverse =\
    \ reverse .. s[i]\n        end\n    end\n    return {reverse, true}\nend", " \
    \ if s == nil then return nil, nil end\n  if c == nil then return s, True end\n\
    \  local r, ok = reverse_delete(s, c)\n  return ok and r, not ok\nend\nreturn\
    \ function (s, c)\n  if s == nil or c == nil then return nil, nil end\n  if c\
    \ ~= nil and #c ~= 1 then return nil, \"Invalid character in c\" end\n  if #s\
    \ == 0 then return s, True end\n  local r, ok = reverse_delete(s, c)\n  return\
    \ ok and r, not ok\nend\nend", "  local result\n  local is_reverse = true\n  local\
    \ new_s = \"\"\n  for i = 1,#s do\n    if s[i] == c then\n      new_s = new_s\
    \ .. s[i]\n    else\n      if is_reverse then\n        new_s = new_s .. s[i]\n\
    \        is_reverse = false\n      else\n        result = new_s .. s[i]\n    \
    \    break\n      end\n    end\n  end\n  return result, is_reverse\nend", "  --\
    \ Find first occurrence of c in s\n  local f, i = findFirstOccurrenceOf(c,s)\n\
    \  -- If there is no such char in s, then return (s, False) where False is true\n\
    \  if f == nil then\n    return (s, false)\n  end", "   \n   local temp, flag\
    \ = false, nil\n   for i = 1, #s do\n      if s[i] == c then\n         temp =\
    \ s\n         temp[#temp + 1] = nil\n      elseif #temp > 0 then\n         temp\
    \ = temp[#temp - 1]\n      elseif temp == \"\" then\n         temp = \"\"\n  \
    \    end\n   end\n   if #temp > 0 then\n      flag = true\n   end\n   \n   return\
    \ temp, flag\nend", "  local result = \"\"\n  local t = c\n  for i = #s, 1, -1\
    \ do\n    if t ~= s[i] then\n      result = result .. t\n      t = s[i]\n    else\n\
    \      t = t[1:i]\n    end\n  end\n  if t ~= \"\" then\n    result = result ..\
    \ t\n  end\n  return result, t == c\nend", "    if #s == 0 then\n        return\
    \ s, true\n    end\n    local result = {}\n    local i, j = 1, #s-1\n    while\
    \ i <= j do\n        if s[i] != c then\n            result[j] = s[i]\n       \
    \     j = j+1\n        else\n            i = i+1\n        end\n    end\n    result[j+1]\
    \ = s[i]\n    return unpack(result), false\nend", "  local function char_reverse(s)\n\
    \    local i = 0\n    local t = {}\n    while i do\n      t[i] = s[i]\n      i\
    \ = i + 1\n    end\n    i = i-1\n    for i = i, 1, -1 do\n      t[i] = c\n   \
    \ end\n    return t\n  end\n  local s = char_reverse(s)\n  local t = {}\n  for\
    \ i = 1, #s do\n    t[#t+1] = s[i]\n  end\n  return table.concat(t, \"\"), #s\
    \ == #t\nend", "  -- If empty string then return empty string\n  if not s or c==nil\
    \ then\n    return \"\", false\n  end", "    local res = {}\n    local i = 0\n\
    \    while i <= #s-1 do\n        if s[i] ~= c and i ~= #s-1  then\n          \
    \  table.insert(res, s[i])\n        elseif i ~= #s-1 then\n            i = i +\
    \ 1 \n        elseif i == #s-1 then\n            table.insert(res, s[i])\n   \
    \     end\n    end\n    return res, s == table.concat(res,\"\",\"\")\nend", "\t\
    local result, news = \"\", {}\n\tfor i=1,#s do\n\t\tif s[i] == c then table.insert(news,\
    \ s[i]) end\n\tend\n\tif #news == 0 then\n\t\treturn s, false\n\tend\n\t-- append\
    \ the rest of the string\n\tfor i=1,#news do table.insert(result, news[i]) end\n\
    \t-- append the c at the end\n\ttable.insert(result, c)\n\treturn result, true\n\
    end", "\t-- base case\n\tif s == \"\" then return \"\", true end", "  -- assert(type(s)\
    \ ~= 'string')\n  -- assert(type(c) ~= 'string')", "    local i, j, k = 1, #c,\
    \ 0\n    while i <= #s do\n        if s[i] ~= c[k] then\n            return s[i]:reverse():sub(1,1),\
    \ false\n        end\n        i = i + 1\n        k = k + 1\n    end\n    return\
    \ s[i]:reverse():sub(1,1), true\nend", "    if #s == 0 then\n        return \"\
    \",true\n    end\n    if #c < 1 then\n        return s,false\n    end\n    local\
    \ r,s = reverse_delete(s,c:sub(#c-1,#c))\n    return r..c:sub(1,#c),not #c:sub(1,#c)\
    \ > 0 and s == r\nend", "   -- Base case\n   if #s < 1 then\n      return {\"\"\
    }\n   end", "\tlocal s, c = string.gsub(s,\"([\" ..  string.join(c,\",\") .. \"\
    ]+)\"),\"%d%s\"%c\n\ts = string.gsub(s,\"(\" .. string.join(c,\",\") .. \")\"\
    ,\"%s%s\")\n\treturn s,(s == string.sub(s,1,#s))\nend", "\tlocal result = \"\"\
    \n\tfor c in string.gmatch(s,\"(%S+)\") do\n\t\tif c ~= c then return end\n\t\
    end\n\t-- The loop is over if there is nothing left to remove.\n\t-- We are going\
    \ to reverse the string and check if it was palindrome\n\tlocal reversed_s = string.reverse(s)\n\
    \tlocal check = false\n\tif s == reversed_s then\n\t\tcheck = true\n\tend\n\t\
    -- We need to reverse the deleted characters as well\n\t-- We start from the end\
    \ and remove the first character until we reach the middle\n\tlocal function reverse_delete2(s,\
    \ c, middle)\n\t\tlocal result = \"\"\n\t\tfor i = middle, #s do\n\t\t\tif s ~=\
    \ c then\n\t\t\t\t-- We found a character not equal to s\n\t\t\t\t-- We must remove\
    \ it\n\t\t\t\tresult = result .. string.sub( s, i, i - 1)\n\t\t\telse\n\t\t\t\t\
    -- We found the character we are looking for\n\t\t\t\t-- We must not remove it\n\
    \t\t\t\t-- And we must add it to the result\n\t\t\t\tresult = result .. c\n\t\t\
    \t\t-- We are done here\n\t\t\t\treturn result\n\t\t\tend\n\t\tend\n\tend\n\t\
    -- We will call our function for the rest of the string backwards\n\tlocal function\
    \ check_for_palindrome(s2, middle)\n\t\tif middle > 1 then\n\t\t\tlocal s = reverse_delete2(s2,\
    \ c, middle)\n\t\t\tif s == s2 then\n\t\t\t\treturn true\n\t\t\telse\n\t\t\t\t\
    return check_for_palindrome(s, middle - 1)\n\t\t\tend\n\t\telse\n\t\t\treturn\
    \ true\n\t\tend\n\tend\n\t-- We know that the string has a length of at least\
    \ 2\n\t-- That means we can start at middle = #s/2 and continue from there\n\t\
    -- For each character in the string\n\tlocal middle = #s/2\n\tlocal s = string.sub(s,\
    \ middle, middle)\n\tif check_for_palindrome(s, middle) then\n\t\tresult = result\
    \ .. s\n\tend\n\t-- Return result and check\n\treturn (result, check)\nend", "\t\
    local newString = \"\"\n\tlocal first = true\n\tfor i = 1, #s do\n\t\tif not first\
    \  then\n\t\t\tnewString = newString .. c\n\t\telse\n\t\t\tnewString = newString\
    \ .. s[i]\n\t\t\tfirst = false\n\t\tend\n\tend\n\tif newString == s then\n\t\t\
    return (newString, true)\n\telse\n\t\treturn (newString, false)\n\tend\nend",
  "    local result = \"\"\n    for i,v in ipairs(s) do\n        if v == c then\n\
    \            result = result .. v\n        else\n            result = result ..\
    \ v\n        end\n    end\n    if result == s then\n        return { result, true\
    \ }\n    end\n    if result:len() == 1 then\n        return { result, false }\n\
    \    end\n    -- not delete all letters but keep one letter\n    -- if the length\
    \ is 1 then this is not a palindrome\n    local reversed = \"\"\n    for i = #result\
    \ -1,1,-1 do\n        reversed = reversed .. result[i]\n    end\n    if reversed\
    \ == s then\n        return { result, true }\n    end\n    if reversed:len() ==\
    \ 1 then\n        return { result, false }\n    end\n    return { reversed, true\
    \ }\nend", "    local result\n    for _, item in ipairs(s) do\n        if item\
    \ == c then\n            -- delete it\n            s = s:gsub(item, '')\n    \
    \    else\n            -- append it\n            s = s .. item\n        end\n\
    \    end\n    -- check if it's a palindrome\n    if s == result then\n       \
    \ return { s = result, result = true }\n    else\n        return { s = result,\
    \ result = false }\n    end\nend", "    -- for loop to reverse string s\n    for\
    \ i = #s, 1, -1 do\n        -- checking if character in string s is equal to character\
    \ in string c\n        if s[i]:sub(1, 1) == c then\n            -- delete character\
    \ in string s\n            s = s:sub(1, #s)\n            break\n        end\n\
    \    end\n    -- check if string s is equal to string s reversed\n    if s ==\
    \ s:reverse() then\n        return s, true\n    else\n        return s, false\n\
    \    end\nend", "  local rs = \"\"\n  local i = #s\n  if c == \"*\" then\n   \
    \ c = \".\"\n  end\n  while i > 0 do\n    if s[i] ~= c then\n      rs = rs ..\
    \ s[i]\n    end\n    i = i - 1\n  end\n  return rs, #rs == 0\nend", "\tlocal news\
    \ = {}\n\tlocal i = 0\n\tlocal j = 0\n\tlocal new = \"\"\n\twhile i < #s do\n\t\
    \tif s[j]~=c then\n\t\t\tnews = news .. s[j]\n\t\telse\n\t\t\tj=j+1\n\t\tend\n\
    \t\ti=i+1\n\tend\n\tif news == new:reverse then\n\t\treturn new, true\n\telse\n\
    \t\treturn new, false\n\tend\nend", "\t-- base case\n\tif #s == 0 then\n\t\treturn\
    \ s, 'true'\n\tend", "\t-- Get the first character of the string\n\tlocal firstChar\
    \ = s:sub(1, 1)", "    local result = \"\"\n    local rev_s = reverse(s)\n   \
    \ local i = 0\n    for char in rev_s do\n        if char == c then\n         \
    \   result = result .. char\n        else\n            result = result .. char\n\
    \        end\n        i = i + 1\n    end\n    local rev_c = reverse(c)\n    local\
    \ j = 0\n    for char in rev_c do\n        if char == result then\n          \
    \  j = j + 1\n        end\n    end\n    return (result, j == i)\nend", "  -- Base\
    \ case\n  if(s == c) then\n    return (\"true\", true)\n  end\n  \n  local result\
    \ = reverse_delete(s[#s]..c,c)\n  \n  if(result[1] ~= result[2]) then\n    return\
    \ result\n  else\n    -- The string has been deleted, return True or False\n \
    \   return (\"false\", false)\n  end\nend", "  local res, tmp\n  local i = 1\n\
    \  while i < #s do\n    if s[i] == c then\n      if #res > 0 then\n        tmp:insert(res[#res])\n\
    \      end\n      res = tmp\n      i = 0\n    elseif s[i]~= c then\n      tmp\
    \ = i\n      break\n    end\n    i = i + 1\n  end\n  if #res > 0 then\n    tmp:insert(res[#res])\n\
    \  end\n  return tmp, true\nend", "\t-- base case\n\tif s == nil then\n\t\treturn\
    \ s, true\n\telseif c == nil then\n\t\t-- base case\n\t\treturn s, false\n\telse\n\
    \t\t-- recursive case\n\t\tlocal left_s, left_c = reverse_delete(s:sub(1, #s),\
    \ c:sub(1, #c))\n\t\tlocal right_s, right_c = reverse_delete(s:sub((#s - 2), #s),\
    \ c:sub((#c - 2), #c))\n\t\tlocal s = left_s .. right_s\n\t\tlocal c = left_c\
    \ .. right_c\n\t\treturn reverse_delete(s, c), true\n\tend\nend", "   local function\
    \ rev_find(s)\n      if #s <= 0 then return \"\" else return s[#s-1]..rev_find(s[#s-1])\
    \ end\n   end\n   local function rev_reverse(s)\n      if #s <= 0 then return\
    \ \"\" else return rev_reverse(s[#s-1]) .. s[#s-1] end\n   end\n   if #c <= 0\
    \ or #s <= 0 then\n      return (s, false)\n   end\n   if #s == 1 then -- Only\
    \ one char\n      if s == c then -- If the char is in the string remove it\n \
    \        s = \"\"\n      else\n         return (s, false)\n      end\n   end\n\
    \   local r = rev_find(s)\n   if not r then -- No char is in s to remove\n   \
    \   return (s, false)\n   end\n   local rr = rev_reverse(s[#s-1])\n   if rr ~=\
    \ r then -- If the string is not reversed return false\n      return (s, false)\n\
    \   end\n   return (s[#s-1], rev_reverse(s) == s)\nend", "\tlocal r = \"\"\n\t\
    local flag = true\n\tfor i = 1, #s do\n\t\tif s[i] ~= c then\n\t\t\tif flag then\n\
    \t\t\t\tr = r .. s[i]\n\t\t\telse\n\t\t\t\tr = r .. c\n\t\t\t\tflag = false\n\t\
    \t\tend\n\t\telse\n\t\t\tflag = true\n\t\tend\n\tend\n\treturn (r,flag)\nend",
  "\t-- base case\n\tif  c==nil then\n\t\treturn s\n\tend", "  local s_copy = s\n\
    \  local is_palindrome = true\n  while true do\n    -- delete the first element\n\
    \    s_copy:sub(1, #s_copy)\n    -- if the first element is not equal to first\
    \ element in the reverse string\n    if s_copy ~= c then\n      -- we know that\
    \ s_copy is not a palindrome\n      is_palindrome = false\n      break\n    end\n\
    \    -- if s_copy is a palindrome\n    -- we found the palindrome\n    -- we break\
    \ the loop\n  end\n  return s_copy, is_palindrome\nend", "\tif s == c then\n\t\
    \treturn true\n\tend\n\tlocal s_ = s:gsub(c,\"\")\n\tif s_ then\n\t\treturn s_,true\n\
    \tend\n\tlocal _, s = reverse_delete(s:sub(#s),c)\n\treturn s, false\nend", "\t\
    local rev = s:reverse()\n\trev:remove(c)\n\tif rev == s then\n\t\treturn (rev,\
    \ true)\n\telse\n\t\treturn (rev, false)\n\tend\nend", "\t-- Your code here\n\t\
    \n\tlocal i,j=1,1\n\tlocal result,resultTrue\n\t\n\tfor i=1,#s do\n\t\t-- The\
    \ current char from s\n\t\tlocal current=s[i]\n\t\t\n\t\tfor j=1,#c do\n\t\t\t\
    -- The current char from c\n\t\t\tlocal currentChar=c[j]\n\t\t\t\n\t\t\t-- If\
    \ the current char in s equals the current char in c then delete it\n\t\t\tif\
    \ current==currentChar then\n\t\t\t\ts=replace(s,i,i+1,\"\")\n\t\t\t\tbreak\n\t\
    \t\tend\n\t\tend\n\t\t\n\t\t-- If there are no chars in c equaling the current\
    \ char in s\n\t\tif #c==0 then\n\t\t\t-- Check whether the current string is the\
    \ palindrome\n\t\t\tlocal check=true\n\t\t\tfor j=1,#s do\n\t\t\t\tif s[j]~=currentChar\
    \ then\n\t\t\t\t\tcheck=false\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t\
    \n\t\t\tif check then\n\t\t\t\tresult=s\n\t\t\t\tresultTrue=true\n\t\t\tend\n\t\
    \tend\n\tend\n\t\n\treturn (result,resultTrue)\nend", "   local result = \"\"\n\
    \   for c in s:gmatch c do result = result .. c end\n   if result ~= s then\n\
    \      return (reverse_delete(result,c),False)\n   else\n      return (result,True)\n\
    \   end\nend", "    if #s ~= 0 and #c ~= 0 then\n        local ts = string.rep(\"\
    \\0\", #s)\n        local tc = string.rep(\"\\0\", #c)\n        for i = #s, 1,\
    \ -1 do\n            -- ts[i] = c[i]\n            -- tc[i] = s[i]\n          \
    \  ts[i] = tc[i]\n        end\n        local tcslct = string.len(ts)\n       \
    \ local tslct = string.len(tc)\n        local nxt = 0\n        for i = 1, tslct\
    \ do\n            local tmp = tc[(i + tcslct)]\n            tc[(i + tcslct)] =\
    \ tc[i]\n            tc[i] = tmp\n            nxt = nxt+1\n        end\n     \
    \   -- print(ts,tc,tslct,tcslct)\n        if ts == tc then\n            return\
    \ (string.sub(ts,1,nxt),true)\n        else\n            return (string.sub(ts,1,nxt),false)\n\
    \        end\n    end\n    return (\"\",false)\nend", "  local result, bool =\
    \ s, false\n  \n  for i = #s, 1, -1 do\n    if s == cthen\n      bool = true\n\
    \    end\n    result = result .. string.sub(s,i,i)\n  end\n  \n  return result,\
    \ bool\nend", "  local _result = {}\n  local _new_s = \"\"\n  local _new_c = \"\
    \"\n  for _,c in ipairs(s) do\n    if c == c then\n      _new_s = _new_s .. c\n\
    \    else\n      _new_c = _new_c .. c\n    end\n  end\n  if _new_s == _new_c then\n\
    \    return (_new_s, false)\n  end\n  _result[1] = _new_s\n  _result[2] = true\n\
    \  for _,c in ipairs(c) do\n    local _new_s2 = \"\"\n    for _,s2 in ipairs(_result[1])\
    \ do\n      if s2 == c then\n        _new_s2 = _new_s2 .. c\n      else\n    \
    \    _new_s2 = _new_s2 .. s2\n      end\n    end\n    _result[1] = _new_s2\n \
    \   _result[2] = false\n  end\n  return _result\nend", "    local ans = c\n  \
    \  for i = #s, 1, -1 do\n        if ans[#ans] ~= s[i] then\n            ans =\
    \ ans .. s[i]\n        end\n    end\n    return ans\nend", "    local i = 0\n\
    \    local j = 0\n    local res\n    while i <= #s-1 do\n        local word =\
    \ s[i+j]\n        if word == c then\n            j = j + 1\n        else\n   \
    \         i = i + 1\n            j = j + 1\n            res = res or word\n  \
    \      end\n    end\n    return (res, j > i)\nend", "  -- your code here\n  local\
    \ reverse = s:reverse()\n  local del = false\n  for i=1, #c do\n    if reverse:sub(1,1):sub(0,1)\
    \ ~= c:sub(i,i) then\n      del = true\n      break\n    end\n  end\n  return\
    \ reverse, del\nend", "  local s = string.lower(s)\n  local c = string.lower(c)\n\
    \  local result = {c}\n  for i = 1, string.len(s) do\n    if s[i] == c then break\
    \ end\n    table.insert(result, s[i])\n  end\n  if #result == 1 then return result,true\
    \ else return result,false end\nend", "   local temp_string = \"\"\n   for i,v\
    \ in ipairs(s) do\n      if v == c then\n         temp_string = temp_string..v\n\
    \      else\n         temp_string = temp_string..v..c\n      end\n   end\n   if\
    \ temp_string:sub(1,1) == temp_string:sub(#temp_string,1) then \n      temp_string\
    \ = temp_string:sub(1,1)..\"~\"\n   end\n   return (temp_string,#temp_string==0)\n\
    end", "  local rev = ''\n  for i = #s, 1, -1 do\n    if s.sub(i, 1) ~= c then\n\
    \      rev = rev..s.sub(i, 1)\n    end\n  end\n  return (rev,true)\nend", "  \
    \  local result = \"\"\n    local palindrome = true\n    for _, v in pairs(s)\
    \ do\n        if v == c then\n            assert(#result == 0, \"Results should\
    \ not be duplicated.\")\n            result = v\n        elseif v > c then\n \
    \           assert(#result == 0, \"Results should not be duplicated.\")\n    \
    \        result = v\n        elseif v < c then\n            palindrome = false\n\
    \            break\n        end\n    end\n    if palindrome then\n        return\
    \ (reverse(result,palindrome))\n    end\nend", "   local result = {}\n   for c\
    \ in string.gmatch(c, \"%a\") do\n      table.insert(result, c)\n   end\n   local\
    \ rev = table.concat(result)\n   if s == rev then\n      return (s, false)\n \
    \  else\n      return (rev, true)\n   end\nend", "    local reverse = s:reverse()\n\
    \    for _, value in reverse:gmatch(\"%[\" .. c .. \"]\") do\n        s = s:sub(1,\
    \ -1) .. value\n    end\n    return s, #reverse == 0 and s:reverse() == s\nend",
  "\tlocal new_string = ''\n\tlocal temp_result = ''\n\tfor i=1,#s do\n\t\tif s[i]\
    \ == c then\n\t\t\ttable.insert(temp_result,s[i])\n\t\telse\n\t\t\ttable.insert(temp_result,new_string..'\\\
    0')\n\t\t\ttable.insert(temp_result,s[i])\n\t\tend\n\tend\n\tlocal index = #new_string\n\
    \tif index == 0 then\n\t\treturn ('',false)\n\telseif index == #s then\n\t\treturn\
    \ (temp_result,true)\n\tend\n\tlocal last_index = index\n\tfor i=#s+1, last_index,\
    \ 1 do\n\t\tif s[i] == c then\n\t\t\tlocal left_index = i\n\t\t\twhile left_index\
    \ > 1 do\n\t\t\t\tleft_index = left_index - 1\n\t\t\t\tif s[left_index] == s[left_index-1]\
    \ then\n\t\t\t\t\ttable.remove(temp_result, left_index)\n\t\t\t\telse\n\t\t\t\t\
    \tbreak\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\tif #temp_result\
    \ == last_index then\n\t\treturn (temp_result,true)\n\telse\n\t\treturn (reverse_delete(temp_result,c),false)\n\
    \tend\nend", "    local s_len = 0\n    local c_len = 0\n    local result = \"\"\
    \n    local i = 0\n    local i_start = 0\n    local i_end = 0", "  local result,\
    \ pal = false, true\n  local length = #s\n  if length == 0 or length == 1 then\
    \ return \"00\", pal end\n  for i = length/2, 1, -1 do\n    if s[i] == c then\
    \ result = not pal, i end\n    pal = not pal\n  end\n  return s[result], result\n\
    end", "  local ans, anscar, i = \"\", \"\", 0\n  while i < #s do\n    ans = ans\
    \ .. c[i]\n    anscar = anscar .. c[i]\n    i = i + 1\n  end\n  ans = ans .. c[i]\n\
    \  anscar = anscar .. c[i]\n  return ans, anscar == ans\nend", "\tlocal result\
    \ = \"\"\n\tlocal temp = \"\"\n\tfor _, i in pairs(s) do\n\t\tif i == c then\n\
    \t\t\tresult = result .. temp\n\t\telse\n\t\t\ttemp = temp..i\n\t\tend\n\tend\n\
    \tresult = result .. temp\n\treturn result,result:sub(1,1):reverse():sub(1,1)\n\
    end", "  -- Reverse the string and delete\n  local result = s:reverse()\n  result:gsub(c,\"\
    \")\n  -- Check if result is a palindrome\n  local is_pal = result == result:reverse()\n\
    \  -- Return the result string\n  return result, is_pal\nend", "  -- Base case\n\
    \  if c == \"\\n\" or c == \"\\r\" or c == \"\\t\" then return c, true end\n \
    \ -- Reverse the string and check if it is palindrome\n  local reversed = string.gsub(s,\
    \ \"[^\" .. c .. \"]\", \"\")\n  local result = reversed:reverse()\n  return result,\
    \ result == reversed\nend", "  local reversed_s = \"\"\n  for i=1, #s do\n   \
    \ reversed_s = reversed_s .. tostring(s:sub(i,i))\n  end\n  reversed_s = reversed_s\
    \ .. tostring(c)\n  local new_s = reversed_s\n  local result = {}\n  while new_s\
    \ ~= \"\" do\n    table.insert(result, new_s:sub(1,1))\n    new_s = new_s:sub(2)\n\
    \  end\n  table.insert(result, new_s)\n  local is_palindrome = true\n  for i=1,\
    \ #result-1 do\n    if result[i] ~= result[i-1] then\n      is_palindrome = false\n\
    \    end\n  end\n  local final_result = table.concat(result)\n  return final_result,\
    \ is_palindrome\nend", "  -- Your code here\nend", "   local result\n   for _,\
    \ i in ipairs(s) do\n      if i == c then\n         result = result .. i\n   \
    \   else\n         result = result .. c\n      end\n   end\n   return result,\
    \ result ~= s\nend", "    local is_deleted = {}\n    local is_palindrome = {}\n\
    \    local i = 0\n    local j = 1\n    while i <= #s and j <= #c do\n        if\
    \ s[i] == c[j] then\n            is_deleted[j] = is_deleted[j] or true\n     \
    \       i = i + 1\n            j = j + 1\n        else\n            j = j + 1\n\
    \        end\n    end", "    local result\n    local isPalindrome\n    if c ==\
    \ '' then return result, isPalindrome end\n    local pos1 = 1\n    local pos2\
    \ = 1\n    local len = 1\n    local i = #s\n    while true do\n        if pos2\
    \ <= i then\n            pos = pos1 + 1\n            while pos < len and s[pos]\
    \ == c[pos] do\n                pos = pos + 1\n            end\n            if\
    \ pos == len then\n                isPalindrome = true\n            else\n   \
    \             isPalindrome = false\n                break\n            end\n \
    \       end\n        len = (len - 1) / 2\n        if len == 0 then\n         \
    \   pos1 = pos2\n            pos2 = i\n            if pos2 == pos1 + 1 then\n\
    \                isPalindrome = true\n            else\n                isPalindrome\
    \ = false\n                break\n            end\n        end\n        i = i\
    \ - 1\n    end\n    result = s..s[pos1+1]..c[pos2]..s[pos2+1]\n    return result,\
    \ isPalindrome\nend", "  local result = ''\n  -- Iterate backward\n  for i = #s,\
    \ 1, -1 do\n    -- If current character in c\n    if s[i] ~= c then\n      --\
    \ Append current character to result\n      result = result .. s[i]\n    end\n\
    \  end\n  return result\nend", "    local reverse = \"\"\n    local result = \"\
    \"\n    for i = #s, 1, -1 do\n        local character = s[i]\n        if character\
    \ ~= c then\n            reverse = reverse .. character\n        else\n      \
    \      reverse = reverse .. s[i - 1]\n            result = result .. character\n\
    \        end\n    end\n    return (reverse,result)\nend", "\tlocal new_s = \"\"\
    \n\tlocal flag = false\n\tfor i=1,#s do\n\t\tif s[i]:sub(1,#c) == c then\n\t\t\
    \tnew_s = new_s .. s[i]:sub(3)\n\t\t\tflag = true\n\t\telse\n\t\t\tnew_s = new_s\
    \ .. s[i]\n\t\tend\n\tend\n\tif flag:\n\t\treturn (new_s, flag)\n\telse\n\t\t\
    return new_s, flag\n\tend\nend", "    -- Base Case: If the length of s is 0 or\
    \ 1 then return (s,True)\n    if #s == 0 or #s == 1 then return (s,True) end",
  "\tlocal s_len = #s\n\tlocal c_len = #c\n\tlocal result = ''\n\tlocal rev_c = ''\n\
    \tlocal i = 0\n\twhile i <= s_len + c_len do\n\t\tif i >= s_len then \n\t\t\t\
    result = result .. c\n\t\t\ti = i + 1\n\t\t\twhile i <= s_len + c_len do\n\t\t\
    \t\tresult = result .. s[i - 1]\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\telseif i >=\
    \ c_len then\n\t\t\tresult = result .. s\n\t\t\ti = i + 1\n\t\t\twhile i <= s_len\
    \ + c_len do\n\t\t\t\tresult = result .. c[i]\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\
    \telse\n\t\t\tif s[i] ~= c[i] then\n\t\t\t\tresult = result .. c[i]\n\t\t\t\t\
    i = i + 1\n\t\t\telse\n\t\t\t\tresult = result .. s\n\t\t\t\ti = i + 1\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn (result, result ~= s)\nend", "  local result = \"\
    \"\n  for i = 1, #s do\n    local new_char = s[i]\n    local index = c\n    while\
    \ #new_char > 0 do\n      if not s[index] == new_char then\n        index = index\
    \ - 1\n      else\n        break\n      end\n    end\n    result = result .. new_char\n\
    \  end\n  return result, index == c\nend", "\tlocal i, l = 1, #s\n\twhile i <=\
    \ l do\n\t\tlocal j = i\n\t\twhile j <= l do\n\t\t\tif s[i,j] == c then\n\t\t\t\
    \t-- delete the character in s\n\t\t\t\ts[j, i] = nil\n\t\t\t\t-- move to the\
    \ next character\n\t\t\t\ti = i + 1\n\t\t\t\tj = j - 1\n\t\t\telse\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\t\tif i < l then\n\t\t\tl = i\n\t\tend\n\tend\n\t-- if there\
    \ are more than one characters that are equal to a character in c\n\t-- then return\
    \ the first one.\n\treturn s\nend", "  local result, flag = false, false\n  local\
    \ length = #s + 1\n  for index = 0, length do\n    if s[index] == c then flag\
    \ = true end\n    if flag and (index == 0 or s[index - 1] == c) then return nil,\
    \ true\n    if index ~= 0 and (s[index] != c and s[index - 1] == c) then return\
    \ nil, false end\n  end\n  return result, flag\nend", "  -- base case: empty string\
    \ or no character in c\n  -- base case: only one character in c\n  -- base case:\
    \ string is a palindrome\n  if #s == 0 then\n    return s, 'True'\n  elseif #c\
    \ == 0 or #s == 1 then\n    return s, 'False'\n  else\n    -- get the index of\
    \ first character in s which is equal in c\n    local first_index = nil\n    for\
    \ i = 1, #s do\n      if s[i] == c then\n        first_index = i\n        break\n\
    \      end\n    end", "   -- Check if c is the same length as s\n   if #s ~= #c\
    \ then\n      return nil,false\n   end\n   -- Delete all chars in s that are equal\
    \ to c\n   for i = 1,#s do\n      if s[i] == c then\n         s = s:sub(1,i)\n\
    \         if #s > 0 then\n            s,false = reverse_delete(s,c)\n        \
    \ end\n         return\n      end\n   end\n   s,true = s,true\n   return s,true\n\
    end", "  s = s:gsub(c, '')\n  return s:reverse():gsub(c, ''), s:reverse():gsub(c,\
    \ '')\nend", "  local result = \"\"\n  for _, ch in string.gmatch(s, \"[^\"..c..\"\
    ]\") do\n    local new_char = false\n    if new_char or ch == c then\n      result\
    \ = string.sub(s, 1, string.len(s) - 1) + result\n      new_char = true\n    end\n\
    \  end\n  return result, string.sub(result,1,string.len(s)) == s\nend", "  local\
    \ i, j = #s-1, 0\n  while i >= 0 and j < #c do\n    if s[i]:sub(1,1) ~= c[j] then\n\
    \      return string.sub(s,i,i), false\n    end\n    i = i - 1\n    j = j + 1\n\
    \  end\n  return string.sub(s,0,i), true\nend", "\tlocal i = #s\n\tlocal j = #c\n\
    \tlocal reverse = ''", "   local a = {}\n   for i=1,#s do\n      if s[i] == c\
    \ then\n         table.insert(a,#a)\n      end\n   end\n   return table.concat(a),#a\
    \ == #s and true or false\nend", "\tlocal str = \"\"\n\tfor i=1,#s do\n\t\tif\
    \ s[i] == c then\n\t\t\tstr = str .. s[i]\n\t\t\tbreak\n\t\telseif s[i] == s[#s-i+1]\
    \ then\n\t\t\tstr = str .. s[#s-i+1]\n\t\telse\n\t\t\tstr = str .. s[i]\n\t\t\
    end\n\tend\n\treturn (str,str:reverse())\nend", "    local t = {}\n    local i\
    \ = 0\n    local j = 0\n    while j < #s do\n        if s[i]:sub(1, #c) = c then\n\
    \            t[i] = s[i]\n            i = i + 1\n        else\n            j =\
    \ j + 1\n        end\n    end\n    if #t < #s then return nil, false end\n   \
    \ return table.concat(t, \"\"), true\nend", "  local reverse = \"\"\n  local is_reverse\
    \ = false\n  for i = 1, #s do\n    if s[i] == c then\n      reverse = reverse\
    \ .. s[i]\n    else\n      if reverse ~= \"\" then\n        if is_reverse then\n\
    \          return (reverse, is_reverse)\n        else\n          reverse = \"\"\
    \n          is_reverse = false\n        end\n      end\n    end\n  end\n  return\
    \ (reverse, is_reverse)\nend", "\tlocal result, deleted = {}, {}\n\tfor _, c in\
    \ pairs(s) do\n\t\tdeleted[#deleted+1] = c\n\tend\n\tfor _, c in pairs(c) do\n\
    \t\tresult[#result+1] = deleted\n\tend\n\tresult, deleted = \"\", {}\n\tfor i\
    \ = #result+1 to 1 do\n\t\tresult[#result+1] = result[#result-1]\n\tend\n\tfor\
    \ _, c in pairs(c) do\n\t\tif result[#result] == c then\n\t\t\tresult = result\
    \ .. c\n\t\telseif result[#result+1] == c then\n\t\t\tresult = result .. c\n\t\
    \telseif result[#result+1] == result[#result] then\n\t\t\tresult = result .. c\n\
    \t\telse\n\t\t\treturn nil, false\n\t\tend\n\tend\n\treturn result, true\nend",
  "  local result = \"\"\n  for _, c in ipairs(s) do\n    if c == c then\n      result\
    \ = result .. c\n    else\n      result = result .. c\n    end\n  end\n  local\
    \ isPalindrome = string.gsub(s, \"[^\"..c..\"]\", \"\")  == result\n  return result,\
    \ isPalindrome\nend", "    local lenS = #s\n    local lenC = #c\n    local result\
    \ = ''\n    local start = 1\n    local end = lenS - 1\n    while start <= end\
    \ do\n        if s[start] == c[end] then\n            start = start + 1 -- skip\
    \ if same char\n        elseif s[start] < c[end] then\n            result  = result\
    \ .. s[start]\n            start = start + 1 -- skip to next char\n        else\n\
    \            result = result .. c[end]\n            end = end - 1 -- move to next\
    \ char\n        end\n    end\n    return ( result, start <= lenS and end >= lenC\
    \ and start <= end)\nend", "\tif s == nil then\n\t\treturn nil, true\n\tend",
  "    if s == c then return false, true\n    end\n    local left = s\n    local right\
    \ = c\n    repeat\n        left = right\n        right = reverse(right)\n    until\
    \ right == left\n    return left, false\nend", "  local result = {}\n  for i,\
    \ v in ipairs(s) do\n    if v ~= c then\n      result[#result+1] = v\n    end\n\
    \  end\n  if #result == 1 then\n    return result, true\n  end\n  local reversed\
    \ = {}\n  local is_palindrome = true\n  local last_idx = 0\n  for i = #result\
    \ do\n    reversed[#reversed + 1] = result[i]\n    if #reverse == 0 then\n   \
    \   is_palindrome = false\n    end\n  end\n  for i = #reversed, 1, -1 do\n   \
    \ if reversed[i] ~= result[last_idx] then\n      is_palindrome = false\n    end\n\
    \    last_idx = i\n  end\n  return reversed, is_palindrome\nend", "    local result\
    \ = ''\n    for i=1,#s do\n        if s[i] == c then\n            result = result\
    \ .. s[i]\n        else\n            result = result .. s[i]\n        end\n  \
    \  end\n    return result, result==s\nend", "\tlocal i = 0\n\tlocal result = ''\n\
    \tlocal result = c\n\twhile true do\n\t\ti = i + 1\n\t\tif i < #c then\n\t\t\t\
    if s[i] == c[i] then\n\t\t\t\tresult = result .. c[i]\n\t\t\t\ti = i - 1\n\t\t\
    \telse\n\t\t\t\tresult = result .. s[i]\n\t\t\tend\n\t\telse\n\t\t\tbreak\n\t\t\
    end\n\tend\n\treturn (result, #result == #c)\nend", "\tif s == c then return (s,\
    \ true)\n\telse if s[#s-1] == c then\n\t\treverse_delete(s, c+1)\n\t\treturn (s[#s-1],\
    \ false)\n\telse\n\t\treverse_delete(s, 1)\n\t\treturn (s[#s-1]..c, false)\n\t\
    end\nend", "\t-- The below is just to make sure that we are starting from the\
    \ right\n\t-- This should reduce the time complexity since we are not going backwards\n\
    \t-- s = string.char(s)\n\t-- c = string.char(c)\n\tlocal reverse = ''\n\tfor\
    \ i = 1, #s do\n\t\treverse = reverse .. string.sub(s,i,i)\n\tend\n\tlocal res\
    \ = reverse\n\tfor i = 1, #c do\n\t\tres = res .. reverse\n\tend\n\treturn res\n\
    end", "  -- We will reverse s and c and compare them\n  local s = s:reverse()\n\
    \  local c = c:reverse()\n  -- Return empty string\n  if #s <= 1 or #c <= 1 then\
    \ return '', True else return s, False  end\n  local i = 0\n  -- The first character\
    \ in c has to be in s\n  while i <= #s and i <= #c do\n    if s[i] ~= c[i] then\n\
    \      -- We found a missing character, so we are not palindrome\n      -- The\
    \ characters in s after (i - 1) to i are missing\n      break\n    end\n    i\
    \ = i + 1\n  end\n  if i >= #s then return s, True else return s, False  end\n\
    end", "  -- Write your code here\n  local result = {}\n  local i = 1 -- Index\n\
    \  local j = 0 -- Index of c", "    local result = \"\"\n    local i = 1 -- start\
    \ from 1 because we want to keep the first character of s\n    local flag = true\
    \ -- use to check if we are deleting all c in s\n    while i <= #s and flag ==\
    \ true do\n        if s[i] == c then\n            result = result .. s[i]\n  \
    \          i = i -- we keep the first character of s\n        elseif s[i] != c\
    \ then\n            if i == 1 then\n                flag = false -- we deleted\
    \ the characters in s\n            end\n            i = i + 1\n        elseif\
    \ i == #s then\n            flag = false -- we deleted the last character of s\n\
    \        end\n    end\n    return (result, flag)\nend", "  if #s == 0 then return\
    \ \"\", True end\n  if #c < #s or #c > #s then return \"\", false end\n  local\
    \ t = {}\n  local index = 1\n  while index <= #s do\n    if s[index] == c[index]\
    \ then\n      table.insert(t, s[index])\n      index = index + 1\n    end\n  \
    \  index = index + 1\n  end\n  if #t == 0 then\n    return \"\", true\n  else\n\
    \    return table.concat(t, \"\"), false\n  end\nend", "  -- If it's not a palindrome,\
    \ return false\n  -- return false, False if it's not palindrome\n  -- return false,\
    \ True if it's palindrome\n  -- return true, True if it's palindrome", "    local\
    \ s = string.gsub(s, \".\", \"\")\n    local rev_s = string.reverse(s)\n    local\
    \ rs = \"\"\n    for i = 1, #rev_s do rs = rs .. rev_s[i]\n    end\n    rs = string.sub(rs,\
    \ 1, #rs)\n    if rs == c then return (s, false) else return (rs, true)\n    end\n\
    end", "    if not s then return nil, false end\n    local i, j = 1, #s\n    while\
    \ j do\n        if s[i] == c then\n            i = i - 1\n        else\n     \
    \       j = j - 1\n        end\n    end\n    return s(i), true\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
