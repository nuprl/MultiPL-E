name: HumanEval_49_modp
language: lua
prompt: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n\
  -- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n--\
  \ 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
  \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
  \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
  \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
  \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tif n == 0 then return 1 end\n\tn = n-1\n\tif n == 0 then\n\t\treturn\
    \ p\n\tend\n\tpn = p*(n+1)\n\tnn = n*(n+1)\n\tif n >= 0 then\n\t\treturn modp(nn,\
    \ pn)\n\tend\n\treturn modp(pn, pn)\nend", "  if n and p\n    then return math.mod(n,\
    \ p) -- numeric operators are faster\n    else return n\n  end\nend", "  if p\
    \ == 0 then return 1 end\n  if p == 1 then return n end\n  local q, r = pdiv(n,\
    \ p)\n  return modp(q, p) * p + r\nend", "\tif n < 0 then\n\t\tn = -n\n\tend\n\
    \tlocal result = 1\n\t-- Start with small primes.\n\t-- TODO: Could do sieving\
    \ until you find a prime that doesn't fit in an int.\n\twhile n > 1 do\n\t\t--\
    \ If n is evenly divisible by p, then a smaller prime must exist.\n\t\tif n %\
    \ p == 0 then\n\t\t\t-- If n is evenly divisible by (p + 1), then a smaller prime\
    \ must exist.\n\t\t\tif p + 1 <= n then\n\t\t\t\t-- n is evenly divisible by (p\
    \ + 1), so p divides n.\n\t\t\t\tresult = result + (p - 1)\n\t\t\t\t-- n is evenly\
    \ divisible by (p + 1), so p + 1 divides n.\n\t\t\t\tn = n / p\n\t\t\telse\n\t\
    \t\t\t-- n is not evenly divisible by (p + 1), so n is not prime (mod p).\n\t\t\
    \t\tbreak\n\t\t\tend\n\t\telse\n\t\t\t-- n is not evenly divisible by p, so n\
    \ is not prime (mod p).\n\t\t\tbreak\n\t\tend\n\tend\n\treturn result\nend", " \
    \ local b = n % p\n  return b == 0 and n or p * b % p\nend", "\tlocal nMod = n\
    \ % p\n\tif nMod ~= 0 then\n\t\tn = p - nMod\n\tend\n\treturn n\nend", "  if p\
    \ == 0 then return 1 end\n  if p == 1 or p == 1 then return n end\n  return n\
    \ % p\nend", "  if p == 0 then return 0 end\n  if p > n then return 1 end\n  if\
    \ p < 0 then return modp(-n, -p) end\n  local result = 1\n  local i = 1\n  while\
    \ i <= p do\n    result = result % p + n - (p + i) % p\n    i = i + 1\n  end\n\
    \  return result\nend", "\t-- Note: n is unsigned.\n\t-- Returns 2^n modulo p.\n\
    \t-- If n is negative, returns 2^n modulo 2*p.\n\t-- If n is 0 or 1, returns n.\n\
    \tn = math.abs(n)\n\tif n == 0 then return 1\n\tif n == 1 or n == 2 then return\
    \ n\n\tif n <= p then return n % p\n\t-- If n is too big, return 2^n modulo 2*p.\n\
    \tend\n\treturn ((1 << (n - 1)) - 1) % (2 * p)\nend", "  if p == 0 then\n    return\
    \ 1\n  elseif p == 1 then\n    return n\n  elseif p == n then\n    return p\n\
    \  else\n    -- The remainder must come before we divide:\n    return n % p +\
    \ modp(n / p, p)\n  end\nend", "    if n == p then\n        return n\n    elseif\
    \ n < p then\n        return modp(n + p - 1, p)\n    else\n        return modp(n\
    \ - p + 1, p)\n    end\nend", "  if n == 0 then\n    return 1\n  elseif n == p\
    \ then\n    return 0\n  else\n    local m = n % p\n    return modp(n - m, p) +\
    \ m\n  end\nend", "    local sign = n < 0 and -1 or 1\n    n = tonumber(n)\n \
    \   p = tonumber(p)\n    local x, y = 0, n % p\n    while y > 0 and x >= p do\n\
    \        x = x % p\n        x, y = y, x % p\n    end\n    return sign * x\nend",
  "  local x\n  if n == 0 then return 1 end\n  if n <= p then return n % p end\n \
    \ x = modp(n - p, p)\n  x = x % p\n  x = x + (p / 2)\n  return x % p\nend", "\t\
    n = n - 1\n\tlocal t = p + p + p + (p > 0)\n\treturn math.floor(n * t % p)\nend",
  "    return ((n % p) + p) % p\nend", "\t-- Check against 0\n\tif n == 0 then\n\t\
    \treturn 1\n\tend", "\tif p > n-1 then return 1 end\n\tlocal c = math.ceil(n)\n\
    \tlocal r = n % p\n\treturn r % p + (r and (modp(c - 1, r - 1)) or 0)\nend", "\t\
    assert(n > 0 and n > p, \"n must be > 0 and > p\")\n\tassert(p == 0 or p == 1,\
    \ \"p must be == 0 or == 1\")\n\tlocal f = 0\n\trepeat\n\t\tf = f * 2\n\t\tn =\
    \ n - 1\n\tuntil n > 0 or p < f\n\treturn f % p\nend", "\tlocal m, r = 0, 1\n\t\
    for i = 1, n do\n\t\tm = m + (r * p) % p\n\t\tr = r * 2\n\tend\n\tif m > p then\n\
    \t\tm = m % p\n\tend\n\treturn m\nend", "    local a = math.pow(n, 1 / p)\n  \
    \  return math.floor(a % p)\nend\n</cell>\n<code language=xeus-cling-cpp14>\n\
    %%file modp_test.cpp\n// This file is for testing modp.cpp", "    local r\n  \
    \  if p == 0 then\n        r = n % p\n    else\n        local v\n        local\
    \ t = p\n        v = (n % p) * p\n        r = v + t\n    end\n    if r < 1 then\n\
    \        return modp(n - 1, r - 1)\n    else\n        return r\n    end\nend\n\
    return {\n    add = add,\n    sub = sub,\n    mul = mul,\n    div = div,\n   \
    \ modp = modp\n}\nend", "\t-- The algorithm relies on a few details in luajit\
    \ which could have\n\t-- changed since the Lua 5.2 version. I'm assuming these\
    \ details are\n\t-- unlikely to change.\n\tassert(p, \"p must be number\")\n\t\
    assert(n, \"n must be number\")\n\t-- The algorithm does not allow negative numbers.\
    \ Negative numbers might\n\t-- be used as unsigned values (e.g. modp(2, -2) returns\
    \ 1).\n\t-- LuaJIT has implemented the algorithm with unsigned integers, which\
    \ is\n\t-- fine as long as we do no math with negative numbers.\n\tassert(n >\
    \ 0, \"n must be positive\")\n\t-- The algorithm allows zero-division, but there\
    \ is no point in\n\t-- doing that in this algorithm.\n\tassert(p == p or p ==\
    \ 1, \"p must be 1 or bigger\")\n\t-- LuaJIT implements the algorithm with unsigned\
    \ integers. We convert to\n\t-- signed integers by masking off the bottom bit.\n\
    \t--\n\t-- >>> bin(modp(2, -2))\n\t-- 0b100\n\t-- >>> bin(modp(2, -1))\n\t-- 0b111\n\
    \t-- >>> bit32.band(bin(modp(2, -2)), 32)\n\t-- -1\n\t--\n\tlocal t = 1\n\tlocal\
    \ r = n - ((n & t) - t)\n\twhile (r ~= 0 do\n\t\tt = ((n << 1) + t) - 1\n\t\t\
    r = (n - ((n & t) - t)) - (r & ~t)\n\tend)\n\treturn r\nend", "  if n <= p then\n\
    \    return 1\n  end\n  local m = n - p\n  if m <= 0 then\n    return 0\n  end\n\
    \  if n <= p then\n    return 1\n  end\n  while m % 2 == 0 do\n    m = m / 2\n\
    \  end\n  while m % 3 == 0 do\n    m = m / 3\n  end\n  while m % 5 == 0 do\n \
    \   m = m / 5\n  end\n  return m % p\nend", "\tif n == 0 then return 1 end\n\t\
    if n < 0 then return n % p end\n\tlocal s = math.floor(n)\n\tn = math.mod(n, p)\n\
    \twhile n >= p do\n\t\tn = ((n % p) + p) % p\n\tend\n\treturn s\nend", "  if n\
    \ == 0 then return p end\n  local t = 1\n  while n > p do\n    n = n % p\n   \
    \ t = t*p\n    p = p*p\n  end\n  return t % p\nend", "  return math.floor(math.abs(n)\
    \ * math.pow(math.abs(n), p)) % p\nend", "  if n == 0 then\n    return 0\n  end\n\
    \  local a = n % p\n  local b = math.modf(n) / p\n  if b == 0 then\n    return\
    \ a\n  else\n    return modp(b, p) * p + a\n  end\nend", "   local mod = 0\n \
    \  while n ~= 0 do\n      mod = mod * 2 + n % p\n      n = math.floor(n / p)\n\
    \   end\n   return mod % p\nend", "  n = math.abs(n)\n  if n <= p then\n    return\
    \ 1\n  elseif n > p then\n    return modp(n - (p * math.ceil(n/p)), p)\n  else\n\
    \    return math.ceil(n)\n  end\nend", "\tlocal r\n\t-- Avoid round-off errors\
    \ by checking against a larger field.\n\tif n >= p and n <= p then return n end\n\
    \t-- The smallest power of two greater than or equal to the number.\n\t-- If n\
    \ is greater than or equal to p, then the largest power of two\n\t-- is at least\
    \ as large as n, and the largest power of two is at least as large\n\t-- as (p-n).\
    \ Because p^2-p+1 is the smallest such value, this will result\n\t-- in the largest\
    \ power of two that is at least as large as n.\n\t-- The only exception is when\
    \ n = p^2-p+1, where this doesn't matter.\n\tif p == 0 or p == 1 then return n\
    \ end\n\t-- Return p^2 modulo p, which can be done efficiently using the binary\
    \ inversion\n\t-- of the exponentiation algorithm.\n\tr = p^2 - p + 1\n\twhile\
    \ r > 0 do\n\t\tr = r >> 1\n\t\tn = ((n-r) ^ p) mod p\n\tend\n\treturn n\nend",
  "  if p == 0 then return 0 end\n  local q = 1\n  while p >= q do\n    if p == q\
    \ then return n end\n    q = q * 2\n  end\n  return n % p\nend", "  local ni,\
    \ p, result = 1, p, 1\n  if n <= 0 then\n    return 1\n  end\n  repeat\n    local\
    \ q, r = divmod(n, p)\n    if q <= 0 then\n      break\n    end\n    result, p\
    \ = result, p\n    ni = ni * p + q\n  until ni == 0\n  return result\nend", "\t\
    if p == 0 then\n\t\treturn 1\n\tend\n\tif p == 1 then\n\t\treturn n\n\tend\n\t\
    if p == 0 then\n\t\treturn 0\n\tend\n\tif p == 1 then\n\t\treturn n % p\n\tend\n\
    \tlocal t = n % p\n\tif t == 0 then\n\t\treturn modp(n, p - 1)\n\telse\n\t\treturn\
    \ modp(t + 1, p) * (p - t)\n\tend\nend", "    local x = math.abs(n)\n    local\
    \ z = math.ceil(p/x)\n    -- If p isn't a power of 2 then round up\n    if p ==\
    \ x then\n        return z\n    end\n    -- Use math.mod to calculate remainder\
    \ as math.mod/x returns a double and so does math.modf(math.mod/x)\n    -- The\
    \ remainder will be the quotient when divided by p, so round up if this remainder\
    \ isn't an integer.\n    return math.ceil(z - math.modf(z))\nend", "\tif n < 0\
    \ then return 1\n\tend\n\tif n > p then return 0 end\n\tlocal x = 0\n\twhile n\
    \ >= p do\n\t\tx = x + 1\n\t\tn = n - p\n\tend\n\treturn x + 1\nend", "    local\
    \ modulus = math.floor(n/p)*p\n    return n % p + modulus\nend", "  local x =\
    \ mod((n - 1) % p, p)\n  local r = mod((n - x) % p, p)\n  if n == 0 then return\
    \ 1 else return r end\nend", "    -- Modulo is only supported for integers\n \
    \   if p == nil then return n end\n    if n ~= tonumber(n) then return nil end\n\
    \    if p == 0 then return 1 end\n    -- Handle negative numbers\n    if n < 0\
    \ then n = -n; p = -p; return modp(n, p) end\n    -- Check for special cases\n\
    \    if p == 1 then return 1\n    elseif p == 0 then return 0\n    elseif n ==\
    \ p then return 1\n    elseif n < p then return modp(n + 1, p)\n    elseif n >\
    \ p then return modp(n + p - 1, p)\n    end\nend", "    -- This algorithm isn't\
    \ strictly necessary because Lua integers don't\n    -- overflow.  We could just\
    \ do\n    --\n    --    --   return n - (n % p) % p\n    --\n    -- but this would\
    \ lead to catastrophic failure on input like 1101\n    -- (which Lua would have\
    \ interpreted as \"101\" * 3 in base 10).  Instead,\n    -- we return n-1 and\
    \ let the caller handle overflow.\n    local q, r = p + p-1, 0\n    while q >\
    \ 0 and n >= q do\n        q, r = q-1, r + q\n    end\n    return n - (r%p)\n\
    end", "\t-- assert(type(n) == 'number', 'Input must be a number')\n\t-- assert(type(m)\
    \ == 'number', 'Input must be a number')\n\t-- assert(p > 0, 'Input must be positive')\n\
    \t-- assert(p <= m, 'Input must be smaller or equal than input modulus')\n\t--\
    \ assert(p == n or p == m, 'Input must not be equal to modulus or modulus')\n\t\
    -- assert(p < m or (p == 0 and n <= 0), 'Input must not be negative')\n\t-- assert(not\
    \ p == 0 or not p == m, 'Input must not be equal to modulus 0 and modulus')",
  "  if n < 0 then n = -n; p = -p; end\n  local m = p % n\n  if m == 0 then\n    return\
    \ p\n  elseif m > n then return m end\n  return modp(m, n)\nend", "  if n == 0\
    \ then return 1 end\n  if p == 0 then return 0 end\n  if n < 0 then\n    if n\
    \ % p > 0 then\n      return modp(n + (p - 1), p)\n    else\n      return modp(n,\
    \ p)\n    end\n  else\n    if n % p > 0 then\n      return modp(n, p)\n    else\n\
    \      return modp(n - p, p)\n    end\n  end\nend", "  n = n - 1\n  return ((p\
    \ * n) + 1) % (p + 1)\nend", "  if n == 0 then\n    return 0\n  end\n  if p ==\
    \ 1 or p == -1 then\n    return 1\n  end\n  if p == 1 then\n    return n % p\n\
    \  end\n  local p = p % n\n  if p == 1 then\n    return p\n  end\n  while n >=\
    \ p do\n    n = n / p\n    local k = 1\n    while n < p do\n      k = k * p +\
    \ n % p\n      n = n / p\n    end\n    return k\n  end\n  return n % p\nend",
  "  assert(n >= 0 and p > 0)\n  if n == 0 then\n    return 1\n  else\n    local nn\
    \ = n % p\n    if nn == 0 then\n      return modp(n, p)\n    else\n      return\
    \ (n % p) + modp(nn, p)\n    end\n  end\nend", "  if p == 0 then return n end\n\
    \  return n % p\nend", "\tif p == 0 then return 1 end\n\tlocal p = p or 1\n\t\
    local f = math.modf(n) / p\n\tif math.abs(f) < p then return f end\n\twhile f\
    \ > p do\n\t\tf = math.modf(f) / p\n\tend\n\twhile f < p do\n\t\tf = math.modf(f)\
    \ * p\n\tend\n\treturn f\nend", "  if p == 0 or p == 1 then\n    return n\n  else\n\
    \    return modp(n % p, p)\n  end\nend", "    return ((n % p) + p) % p\nend",
  "\t-- Return 2^n modulo p, preserving sign.\n\tn = n or 0\n\tlocal power = 1\n\t\
    while n ~= 0 do\n\t\tif n >= p then\n\t\t\t-- n >= p, so n is power of two.\n\t\
    \t\tpower = power * 2\n\t\t\t-- n -= p\n\t\t\tn = n - p\n\t\telse\n\t\t\t-- n\
    \ < p, so n is either p or power of two.\n\t\t\t-- Use whichever was the smaller\
    \ multiple of power of two.\n\t\t\t-- power = power < n ? power : power * 2\n\t\
    \t\tpower = power < n ? power : power + n\n\t\t\t-- n = 0\n\t\t\tn = 1\n\t\tend\n\
    \tend\n\treturn power\nend", "  if n == 0 then\n    return 1\n  elseif n == 1\
    \ or n == p then\n    return n\n  elseif p < 0 then\n    error(\"modp(\" .. tostring(n)\
    \ .. \", \" .. tostring(p) .. \"): p < 0\")\n  else\n    -- Find q = floor(n /\
    \ p) and r is n % p\n    local q = math.floor(n/p)\n    local r = n % p\n    --\
    \ Return q times the result of modp(p - r, p).\n    -- We could use math.floor\
    \ instead of math.mod for integers,\n    -- but this is not needed for our purpose.\n\
    \    return q * modp(p - r, p)\n  end\nend", "  if p == 0 then\n    return 1\n\
    \  end\n  if n == 0 then\n    return 0\n  end\n  if p < 1 then\n    return nil\n\
    \  end\n  if p == 1 then\n    return p\n  end\n  local p = p - 1\n  local q =\
    \ n % p\n  if q == 0 then\n    return p\n  end\n  return modp(n - q, p) + 1\n\
    end", "  local function mul2(n)\n    return (n * n - 1) ^ p\n  end\n  if n < p\
    \ then\n    return 1\n  else\n    return mul2(n) / p\n  end\nend", "  -- This\
    \ is pretty horrible, but it works! It's also the fastest way to\n  -- implement\
    \ modular exponentiation. Since mod^k = a mod p, we can\n  -- calculate how many\
    \ times k goes into a, and then calculate a mod\n  -- p by raising a to the power\
    \ of k modulo p.\n  local function powmod(a, k, p)\n    local r = 1\n    for i\
    \ = 1, k do\n      r = r * a % p\n      a = a * a % p\n    end\n    return r\n\
    \  end\n  \n  -- The only way I can find to calculate mod^k, where k is a natural\
    \ number\n  -- without using recursion is by using exponentiation by squaring.\n\
    \  -- Unfortunately, this doesn't work for very large numbers (it overflows).\n\
    \  local function expmod(a, k, p)\n    local a1 = powermod(a, k, p)\n    local\
    \ r = 1\n    local k = k - 1\n    while k > 0 do\n      r = r * a1 % p\n     \
    \ a1 = a1 * a % p\n      k = k - 1\n    end\n    return r\n  end", "\tif n ==\
    \ 0 then\n\t\treturn 1\n\tend\n\t-- n is positive.\n\tif n < 0 then\n\t\tn = -p\n\
    \tend\n\t-- p is positive.\n\tif p == 0 then\n\t\treturn n\n\tend\n\t-- p is negative.\n\
    \tif p < 0 then\n\t\tp = -p\n\t\tn = -n\n\tend\n\t-- n is finite and p is infinite.\n\
    \tif n ~= 0 then\n\t\tif p > n then\n\t\t\tn = p\n\t\tend\n\t\treturn n % p\n\t\
    end\n\t-- n is infinite and p is finite.\n\tif p ~= 0 then\n\t\tif n > p then\n\
    \t\t\tn = p\n\t\tend\n\t\treturn n % p\n\tend\n\t-- n is negative and p is negative\
    \ (p < 0).\n\treturn -p\nend", "\tp = p - 2\n\tif p == 0 then return 1 end\n\t\
    if p == 1 then return 0 end\n\tlocal a = modp(n / p, p)\n\treturn a * p % p\n\
    end\nreturn modp", "  if n == 0 then return 1 end\n  if n < 0 then return modp(0\
    \ - n, p) end\n  local c = 1\n  local t = n\n  while t > 1 do\n    local r = t\
    \ % p\n    t = t\n    c = c * r\n  end\n  return c\nend", "  assert(n >= 0 and\
    \ n <= p)\n  -- If p == 0, n == 0 always return 1 (i.e. even).\n  if p == 0 then\
    \ return 1\n    -- If p == 1 and n < 0, return n (i.e. negated).\n  elseif p ==\
    \ 1 then return n end\n  -- Otherwise, we'll use Mod or R to compute a modular\
    \ reduction.\n  return n % p + modp(n / p, p)\nend", "  -- From Fermat's little\
    \ theorem:\n  -- >>> pow(2, 16) % 25 == 2\n  -- >>> pow(2, 17) % 25 == 3\n  --\
    \ >>> pow(2, 31) % 25 == 0\n  -- >>> modp(25, 25) == 25\n  if p == 0 then\n  \
    \  return 1\n  else\n    if n == 0 then\n      return 0\n    else\n      if n\
    \ >= p then\n        return modp(n - p, p)\n      else\n        return modp(n\
    \ + p - 1, p)\n      end\n    end\n  end\nend", "\tlocal t = n % p\n\tif t ==\
    \ 0 then\n\t\treturn p\n\telseif n < p then\n\t\treturn modp(t, p)\n\telse\n\t\
    \treturn modp(t - p, p)\n\tend\nend", "  local ret = 1\n  local power = 1\n  while\
    \ n > 0 and power < p do\n    ret = ret * power % p\n    power = power * 2\n \
    \   n = n / 2\n  end\n  return ret\nend", "    if p == 0 then\n        return\
    \ n\n    else\n        return n % p\n    end\nend", "  if p == 0 then\n    return\
    \ 0\n  elseif p == 1 then\n    return n\n  else\n    return modp(n % p, p)\n \
    \ end\nend", "  -- The result equals to floor(a / b) * b + mod(a, b).\n  if n==0\
    \ then return 0 end\n  -- Modulo operation can overflow for very large numbers.\n\
    \  -- Use integers instead.\n  n = tonumber(n)\n  p = tonumber(p)\n  local a,\
    \ b, overflow\n  if n then\n    a, b = p, b\n  else\n    a, b = 1, p\n    overflow\
    \ = 1\n  end\n  -- The result equals to floor(a / b) * b + mod(a, b).\n  local\
    \ result = math.floor(a/b) * b + modinv(a, b)\n  if overflow then\n    -- Overflow\
    \ occurred, the result is infinity.\n    -- Return infinity modulo p.\n    error(\"\
    modp overflow\")\n  else\n    -- Return result modulo p.\n    return result\n\
    \  end\nend", "   if n < 0 then\n      return modp(abs(n), p)\n   end\n   if p\
    \ == 1 or n == 1 then\n      return n\n   end\n   if p % 2 == 0 and n % p == 0\
    \ then\n      return modp(n / p, p)\n   else\n      return modp(n - n * math.floor(p/2),\
    \ p)\n   end\nend", "  local res = 0\n  while n >= p do\n    res = (n % p + p)\
    \ % p\n    n /= p\n  end\n  return res\nend", "  if p == 0 then return 1 end\n\
    \  if n == 0 then return 0 end\n  if n == 1 then return 1 end\n  if p < 0 then\
    \ return nil end\n  local t = modp(n >> 1, p)\n  return ((n & 1) ~= 0) and t or\
    \ t - p\nend", "  if n < 0 then\n    return 0\n  elseif n < p then\n    return\
    \ n - p + 1\n  else\n    return p\n  end\nend", "    return math.floor((n - math.floor(n\
    \ / p) * p) % p)\nend", "  local q = math.floor(math.log(n) / math.log(p))\n \
    \ if p == 0 then\n    return 0\n  else\n    return q * p + (n - math.pow(p, q))\n\
    \  end\nend", "  local nn = p * math.pow(2, n)\n  return math.floor(nn / p)\n\
    end", "  n = n % p\n  if n == 0 then return p end\n  if p == 1 or p == 2 then\
    \ return n end\n  if p == 0 or p % 2 == 0 then return n % p end\n  if p == 1 then\
    \ return n end\n  return n % p\nend", "    if n == 0 then\n        return 1\n\
    \    end\n    return mod(n, p) + modp(n/p, p)\nend", "  local m = math.floor(n)\n\
    \  n = n - m * p -- n is now the difference between m and p.\n  -- Note that m\
    \ might not be an integer, because of the mod p.\n  if n == 0 then return m end\n\
    \  if p == 0 or p == 1 then return m end\n  return modp(m, p) + p\nend", "  if\
    \ n < 0 then\n    error('modp(n, p)', 'n must be non-negative')\n  end", "  if\
    \ n == 0 then return 1 end\n  local m = n % p\n  local r = modp(m - 1, p) * (p\
    \ - m)\n  if r ~= 0 then\n    local t = modp(r, p + 2)\n    if t < r then t =\
    \ t + p end\n    r = t\n  end\n  return r\nend", "  if p == 0 then\n    return\
    \ 1\n  elseif n < 0 then\n    return modp(n + (-p), p)\n  else\n    if n % p ==\
    \ 0 then\n      return modp(n / p, p)\n    else\n      return modp(n % p, p)\n\
    \    end\n  end\nend", "    if p == 0 then\n        return n\n    elseif p < 0\
    \ or p > p then error(\"modulus p must be >= 0 and < p\") end\n    local factor\
    \ = 1\n    repeat\n        if factor == 1 then\n            if n ~= 0 then\n \
    \               return 1\n            else\n                return 1\n       \
    \     end\n        else\n            factor = factor * 2\n        end\n    until\
    \ n >= factor\n    return factor\nend", "  local n2 = math.floor(n/p)\n  local\
    \ r = 0\n  while n2 ~= 0 do\n    r = r * p + (n2 % p)\n    n2 = n2//p\n  end\n\
    \  return r\nend", "  local c = 1\n  for i = 1, n do\n    c = c * p % p\n  end\n\
    \  return c\nend", "\tif p == 0 then return 1 end\n\tlocal q\n\tif n == 0 then\
    \ q = 1 elseif n == 1 then q = 2 else\n\t\tlocal z = n % p\n\t\tif z ~= 0 then\
    \ q = (p - z) / p else q = p - z end\n\tend\n\treturn q\nend", "  n = n or 0\n\
    \  p = p or 1\n  if n < 0 then\n    n = -n -- negative number\n  elseif n == 0\
    \ then\n    return 0\n  elseif p == 0 then\n    return n\n  elseif n % p == 0\
    \ then\n    return 0\n  elseif n / p == p then -- n / p == p for all even and\
    \ odd n\n    return n / p\n  else -- n = p/p\n    return modp(n / p, p)\n  end\n\
    end", "  if n < 0 then\n    return p-1\n  end\n  if n == 0 then\n    return 0\n\
    \  end\n  local d, m\n  if p == 1 or p == 1 then\n    d, m = n, 1\n  else\n  \
    \  d, m = modp(n / p, p), n % p\n  end\n  if d == 1 or d == 0 then\n    return\
    \ m\n  end\n  if d == -1 then\n    return m + 1\n  end\n  return d\nend", "  \
    \  local mod = math.fmod(n, p)\n    if mod == 0 then return 1 end\n    if mod\
    \ == p then return 0 end\n    return mod\nend", "  if p == 0 then\n    return\
    \ 1\n  end\n  if p == 1 or p == 2 or p == 3 or p == 4 then\n    return n\n  end\n\
    \  local m = n % p\n  if m == 0 then\n    return p\n  else\n    return modp(n\
    \ - m % p, p)\n  end\nend", "  local _, k = math.modf(n + p)\n  return k + p +\
    \ ((n >= 0) == (k < 0) == (k < 0))\nend", "    if p == 0 then\n        return\
    \ 0\n    end\n    local q = tonumber(p)\n    if q == 0 and n ~= 0 then\n     \
    \   return p\n    elseif q == 0 then\n        return n\n    elseif q == p then\n\
    \        return modp(n, n - 1)\n    end\n    local r = n - (q % n)\n    return\
    \ r + modp(r, q)\nend", "\tif n == 0 then return 1 end\n\tif n == 1 or n == -1\
    \ or p == 1 or p == -1 then return n end\n\tif p > p then return modp(n-1, p)\
    \ end\n\tif p < 1 then return modp(n+1, p) end\n\treturn modp(modp(n-1, p), p)\n\
    end", "\tlocal factor = p\n\trepeat\n\t\tfactor = math.floor(factor / 2)\n\tuntil\
    \ factor == 0\n\treturn (n - (n % factor)) % factor\nend", "  local t = modn(n\
    \ - p, p)\n  if t < 0 then\n    return p + t\n  else\n    return t\n  end\nend",
  "  if p == 0 then\n    return n\n  end", "  return math.floor(n / p) * p + math.modf(n\
    \ / p) * p\nend", "\tif p == 0 then\n\t\treturn n\n\telseif p ~= p or p == math.floor(p)\
    \ then\n\t\terror(\"p must be an integer, got \" .. tostring(p))\n\tend\n\tif\
    \ n < 0 then\n\t\terror(\"n must be >= 0, got \" .. tostring(n))\n\tend\n\tif\
    \ p == 1 or p == 2 then\n\t\treturn n\n\tend\n\tlocal modp\n\tif modp == nil then\n\
    \t\tmodp = math.floor(math.log(p) / math.log(2))\n\tend\n\tlocal res = 1\n\tfor\
    \ i = 3, p * 2 + 1\n\t\tdo\n\t\tres = (res * n) % p\n\t\tn = math.floor(n)\n\t\
    end\n\treturn res\nend", "  if p == 0 then return 1 end\n  if n == 0 then return\
    \ 0 end\n  if n >= p and n <= p - 1 then return 1 end\n  return n % p\nend", " \
    \   return ((n % p) + p) % p\nend", "    if n == 0 then\n        return 1 or 0\n\
    \    end\n    if p == 1 or p == 1 then\n        return n\n    end\n    if p ==\
    \ 0 then\n        return 0 if n >= 0 else -1\n    end\n    if n > p and n >= 0\
    \ then\n        return modp(n % (p - 1), p)\n    end\n    return 0 if n < 0 and\
    \ n < -p\n               and mod(n, -p) == -p\n               and mod(-n, p) ==\
    \ p\n               and mod((-1) + n, -p) == p\n               and mod((-1) +\
    \ n, p) == -p\n               and mod((-1) + n, (-1) + p) == -p\n            \
    \   and mod((-1) + n, (-1) + p) == p\n               and mod((-1) + n, p) == (-1)\
    \ + p\n               and mod(n, -1) == (-1) + p\n               and mod(-n, 1)\
    \ == (-1) + p\n               and mod((-1) + n, 1) == (-1) + p\n             \
    \  and mod((-1) + n, -1) == (-1) + p\n               and mod(n, (-1) + p) == (-1)\
    \ + p\n               and mod(-n, (-1) + p) == (-1) + p\n               and mod(n,\
    \ p) == (-1) + p\n               and mod(-n, p) == (-1) + p\n               and\
    \ mod(-n, (-1) + p) == (-1) + p\n               and mod(-n, (-1) + p) == (-1)\
    \ + p\n               and mod(n, (-1) + p) == (-1) + p\n               and mod(-n,\
    \ (-1) + p) == (-1) + p\n               and mod((-1) + n, (-1) + p) == (-1) +\
    \ p\n               and mod(n, (-1) + p) == (-1) + p\n               and mod(-n,\
    \ (-1) + p) == (-1) + p\n    end\n    if n < 0 and n < -p then\n        return\
    \ modp(-n, p)\n    end\n    return 0 if n < 0 and n < -p\n               and mod(-n,\
    \ p) == -p\n               and mod((-1) + n, p) == p\n               and mod((-1)\
    \ + n, -p) == -p\n               and mod(-n, (-1) + p) == p\n               and\
    \ mod(-n, p) == (-1) + p\n               and mod((-1) + n, (-1) + p) == -p\n \
    \              and mod(n, (-1) + p) == (-1) + p\n               and mod(-n, (-1)\
    \ + p) == (-1) + p\n               and mod(-n, p) == (-1) + p\n              \
    \ and mod((-1) + n, p) == (-1) + p\n               and mod(n, (-1) + p) == (-1",
  "\tlocal m = 0\n\tfor i = 1, n do\n\t\tm = m + (p^(n-1))\n\tend\n\treturn m\nend",
  "  local a\n  if p == 0 then\n    return 1\n  elseif p == 1 then\n    return n\n\
    \  else\n    a = n % p\n    return modp(a, p) * p + n\n  end\nend", "  if n <\
    \ 0 then\n    return modp(-n, p)\n  elseif n == 0 then\n    return 1\n  elseif\
    \ p == 1 then\n    return 0\n  else\n    local factor = p\n    for i = 2, n do\n\
    \      factor = factor * p % i\n    end\n    return factor\n  end\nend", "  if\
    \ p == 0 then\n    -- Special case.\n    return 0\n  end", "\tif n == 0 then\n\
    \t\treturn 1\n\tend\n\tif p == 0 then\n\t\treturn 0\n\tend\n\tif p == 1 or p ==\
    \ -1 then\n\t\treturn n % p\n\tend\n\tlocal function bitcount(x, p)\n\t\tlocal\
    \ count = 0\n\t\twhile x do\n\t\t\tcount = count + 1\n\t\t\tx = x >> p\n\t\tend\n\
    \t\treturn count\n\tend\n\tif n <= p then\n\t\treturn bitcount(n, p) + modp((n\
    \ - bitcount(n, p)), p)\n\telse\n\t\treturn bitcount(n, p) + modp((p + 1), p)\n\
    \tend\nend", "  if n == 0 then\n    return 1\n  elseif p == 1 then\n    return\
    \ 0\n  elseif n < 0 or p <= 0 then\n    return \"not possible\"\n  end", "   \
    \ local r = 0\n    local m = math.abs(p)\n    while n > 0 do\n        r = r *\
    \ m\n        n = n - 1\n    end\n    return r\nend", "  if p == 0 then return\
    \ n end\n  if n == 0 then return 0 end\n  if p == 1 then return n end\n  local\
    \ r = n % p\n  return r and modp(n / p, p) or r\nend", "\t-- Special cases\n\t\
    -- n < 0\n\tif n < 0 then\n\t\treturn nil\n\tend\n\t-- n < p\n\tif n == 0 then\n\
    \t\treturn 1\n\tend\n\t-- n > p\n\tif p == 0 then\n\t\treturn 0\n\tend\n\t-- If\
    \ n is even, return 2^n mod p\n\tif n ~= math.floor(n) then\n\t\treturn modp(math.pow(2,\
    \ n), p)\n\tend\n\t-- If p is even, return n-1 (mod p) then return 2^(n-1) mod\
    \ p\n\tif p ~= math.floor(p) then\n\t\tlocal s = modp(n - 1, p)\n\t\treturn modp(s,\
    \ p) * modp(math.pow(2, s), p)\n\tend\n\t-- If p is odd, return 2^n mod p\n\t\
    local r = 1\n\twhile p % 2 == 1 do\n\t\tr, p = r * 2, p / 2\n\tend\n\treturn r\
    \ * modp(math.pow(2, n), p)\nend", "    local m = 0\n    while n > p do\n    \
    \    n = n / p\n        m = m + 1\n    end\n    return m\nend", "    -- If the\
    \ number is 0 or less, return 1 exactly.\n    if n < 1 then return 1 else return\
    \ modp((n*(p-1) + 1)%p, p) end\n    -- If the number is negative, return 1 exactly.\n\
    \    if n < 0 then return 1 end\n    -- Return 2 ^ n modulo p.\n    return (2^n)%p\n\
    end", "\tif n == 0 then return 1 end\n\tif n > p then return modp(n, p) end\n\t\
    return n - 1 - (n % p)\nend", "  if p < 2 then return n end\n  local q, r = n\
    \ % p\n  return r >= p and n - q or modp(q, p)\nend", "\tlocal d = n - 1\n\tlocal\
    \ u = 1\n\tlocal v = 0\n\twhile d > 0 do\n\t\tv = (v * p + d) % p\n\t\td = d >>\
    \ 1\n\t\tu = u + 1\n\tend\n\treturn u % p\nend", "    if n < p then\n        return\
    \ modp(n - p, p) + 1\n    else\n        return n\n    end\nend", "  -- http://math.stackexchange.com/questions/7929/modular-exponentiation-algorithm-explanation\n\
    \  local t = 1\n  local r = 1\n  repeat\n    if n >= p then\n      r = ((n % p)\
    \ + r) % p\n      t = ((n / p) + t) % p\n    end\n    n, p = p, n\n  until n ==\
    \ 0 or n == 1 or r == 0\n  return r\nend", "  if p == 0 then\n    if n == 0 then\n\
    \      return 1\n    else\n      return 0\n    end\n  end\n  if p == 1 or p ==\
    \ -1 then\n    return math.ceil(n)\n  end\n  if n == 0 then\n    return 0\n  end\n\
    \  if p == 0 then\n    return 0\n  end\n  if n % p == 0 then\n    return modp(n\
    \ / p, p)\n  end\n  return modp(n / p, p)\nend", "  if p < 2 then\n    return\
    \ nil\n  elseif p > n then\n    return 1\n  else\n    return n % p\n  end\nend",
  "  if n < 0 then\n    error('modulus is negative', 2)\n  end\n  return p + p - (p\
    \ * (p + p) - p * math.floor((p - 1) / p))\nend", "  assert(n >= 0 and p >= 0\
    \ and n <= p)\n  local r = n % p\n  -- r = r + (p % r) if r < p else r\n  return\
    \ r\nend", "    local q, r = p + 1, 0\n    while q > 0 do\n        if n % q ==\
    \ 0 then\n            n = n / q\n        else\n            q, r = q - 1, r\n \
    \       end\n    end\n    return n % p\nend", "  n = n % p\n  if n == 0 then\n\
    \    return 1\n  else\n    return modp(n-1, p)\n  end\nend", "    if p == 0 then\
    \ return 1 end\n    local q, r = 0, n\n    while r > 0 do\n        local t = r\
    \ % p\n        q, r = p * q + t, r\n    end\n    return q % p\nend", "  -- Handle\
    \ negative numbers\n  n = math.abs(n)", "  if n == 0 then return p end\n  if n\
    \ == p then return n end\n  if p > n then return 0 end\n  if n % p == 0 then return\
    \ modp(n / p, p) end\n  local r = 1\n  while n % p == 0 do\n    r = r * p % p\n\
    \    n = n / p\n  end\n  return r\nend", "    local x = n or 1\n    local y =\
    \ p or 1\n    while y > 1 do\n        if x % y == 0 then\n            return y\n\
    \        end\n        y, x = y, x % y\n    end\n    return 1 -- x % n should be\
    \ 0 if n < p\nend", "    local t = pow(2, n)\n    return t % p\nend\n</cell>\n\
    <text>\n\u0414\u043B\u044F \u0440\u0430\u0431\u043E\u0442\u044B \u0441 \u0434\u0438\
    \u0430\u0433\u043E\u043D\u0430\u043B\u044C\u043D\u044B\u043C\u0438 \u043F\u043E\
    \u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0435\u043C \u0442\u0430\
    \u043A\u0436\u0435 \u043F\u0440\u0438\u043C\u0435\u043D\u044F\u0435\u0442\u0441\
    \u044F \u043C\u0435\u0442\u043E\u0434 __new__ \u0438 __init__.", "  if p == 0\
    \ then return 1 end\n  if p == 1 then return n end\n  if p < 0 then p = -p; n\
    \ = n / p end\n  return modp(n % p, p)\nend", "  if n ~= math.floor(n) or p ~=\
    \ p then\n    return nil\n  elseif n < 0 then\n    local sign = n ~= math.floor(n)\n\
    \    if sign then\n      n = -n\n      p2 = 1\n    else\n      p2 = -p\n    end\n\
    \    local e = 0\n    while n >= p2 do\n      e = p2 << 1 + e\n      n = n - p2\n\
    \      p2 = p2 * p\n    end\n    return e\n  elseif n == 0 then\n    return 1\n\
    \  else\n    local e = 0\n    while n >= p do\n      e = p * e + 1\n      n =\
    \ n - p\n      p = p * p\n    end\n    return e\n  end\nend", "  -- If n < 0 then\
    \ return 1\n  -- If n is less than 0 then return 0\n  -- If n < p then return\
    \ n\n  -- If n < 2*p then return n - p\n  -- Otherwise return n%p\n  if n < 0\
    \ then\n    return 1\n  elseif n < p then\n    return n\n  elseif n < 2*p then\n\
    \    return n - p\n  else\n    return n % p\n  end\nend", "\tif p == 0 then\n\t\
    \treturn 1\n\tend\n\tlocal q = math.floor((p - 1) / (2 * n)) + 1\n\tlocal r, s\
    \ = 1, q\n\trepeat\n\t\tr = r * n + 1\n\t\ts = s * n - q\n\tuntil s < 0\n\treturn\
    \ r\nend", "  if n%p == 0 then\n    return n%p\n  else\n    -- If n is negative,\
    \ we need to subtract 1 from the result of\n    -- shifting, because we don't\
    \ want the sign bit to be set.\n    return modp(n - ((n%p)-1), p)\n  end\nend",
  "  local res = n\n  local count = 0\n  repeat\n    if res <= p then\n      return\
    \ 1\n    end\n    res, count = res*res % p, count+1\n  until count >= 2\n  return\
    \ res\nend", "  local m = n % p\n  if m < 0 then\n    m += p\n  end\n  return\
    \ m\nend", "\t-- Return 2^n modulo p (be aware of numerics).\n\t-- >>> modp(3,\
    \ 5)\n\t-- 3\n\t-- >>> modp(1101, 101)\n\t-- 2\n\t-- >>> modp(0, 101)\n\t-- 1\n\
    \t-- >>> modp(3, 11)\n\t-- 8\n\t-- >>> modp(100, 101)\n\t-- 1\n\tlocal pow = 2\n\
    \tlocal ret = 1\n\twhile n < p do\n\t\tn = n * pow\n\t\tret = ret + 1\n\tend\n\
    \treturn ret % p\nend", "  if n < 0 then\n    if p < 0 then\n      return nil\n\
    \    end\n    return nil\n  end\n  if p == 0 then\n    if n == 0 then\n      return\
    \ 1\n    end\n    return nil\n  end\n  if p == 1 then\n    return n / p\n  end\n\
    \  -- Return p mod 2^n.\n  --\n  -- >>> modp(3, 5)\n  -- 3\n  -- >>> modp(1101,\
    \ 101)\n  -- 2\n  -- >>> modp(0, 101)\n  -- 1\n  -- >>> modp(3, 11)\n  -- 8\n\
    \  -- >>> modp(100, 101)\n  -- 1\n  local q, r = divmod((n - 1) ^ p, p)\n  --\
    \ Return q mod p.\n  --\n  -- >>> modp(3, 5)\n  -- 3\n  -- >>> modp(1101, 101)\n\
    \  -- 2\n  -- >>> modp(0, 101)\n  -- 1\n  -- >>> modp(3, 11)\n  -- 8\n  -- >>>\
    \ modp(100, 101)\n  -- 1\n  if r * q > n then\n    q, r = divmod((n - r) * p,\
    \ p)\n  end\n  if r > 0 then\n    return q + (p - q)\n  end\n  return q\nend",
  "  if n == 0 then return 1\n  else if n-1 < p then return modp(n-1, p) + 1\n  else\
    \ return modp(n-1, p) + modp(n, p) end\nend", "\tif n == 0 then return 0 end\n\
    \tif n == 1 then\n\t\treturn p\n\tend\n\treturn modp(n - 1, p) * (p + 1) -- fast\
    \ exponentiation algorithm\nend", "  local a\n  if n < 0 then\n    a = 0\n  else\n\
    \    a = p + n\n  end\n  return math.floor(a) / p\nend", "  n = n or 1\n  p =\
    \ p or 1\n  -- Negative number?\n  if n <= 0 then return 1 end\n  -- If p is 0,\
    \ there is no remainder.\n  if p == 0 then return 0 end\n  -- Is n divisible by\
    \ p?\n  if n % p == 0 then return n end\n  -- Is p even power of two?\n  if p\
    \ == 2 then return n end\n  -- Get quotient, remainder\n  local q, rem = math.modf(n)\n\
    \  if rem > 0 then return q end\n  return modp(q, p >> 1)\nend", "  local _, r\
    \ = divrem(n, p)\n  return r\nend", "  assert(n > 0)\n  assert(p > 0)\n  if n>1\
    \ then\n    local p = p\n    if p<1 then\n      p = 1\n    end\n    return n %\
    \ p\n  else\n    return n\n  end\nend", "  if n == 0 then\n    return 1\n  end",
  "  if p == 0 then return n end\n  local r = n % p\n  return r and modp(n / p, p)\
    \ or r\nend", "  if n <= 0 then\n    return 0\n  end\n  if n >= p then\n    return\
    \ p\n  end\n  local d = div(p - 2, n)\n  n = n - 2 * d\n  local r = modp(n - d,\
    \ p)\n  return r + 2 ^ d\nend", "  local mult = n % p\n  if mult ~= 0 and mult\
    \ ~= p then\n    return p\n  else\n    return p * p % p\n  end\nend", "\t-- Special\
    \ case if n < 0\n\tif n < 0 then\n\t\treturn n % p\n\tend\n\t-- Special case if\
    \ p == 0.\n\tif p == 0 then\n\t\treturn 0\n\tend\n\t-- Special case if n is NaN.\n\
    \tif n == NaN then\n\t\treturn NaN\n\tend\n\t-- Special case if n < p.\n\tif n\
    \ < p then\n\t\treturn n % p\n\tend\n\t-- Special case if p == 1 and n == 0.\n\
    \tif p == 1 and n == 0 then\n\t\treturn 0\n\tend\n\t-- Otherwise, just take the\
    \ remainder.\n\treturn n % p\nend", "\tlocal x, y = math.abs(n), p\n\tif x < y\
    \ then\n\t\treturn modp(y, p)\n\telseif x == y then\n\t\treturn 0\n\telse\n\t\t\
    return math.ceil(math.log(x) / math.log(y))\n\tend\nend", "  if n ~= p * 2 and\
    \ n ~= n * p then\n    return 0\n  elseif n ~= math.floor(n) then\n    return\
    \ modp(n, p)\n  end\n  if n % p == 0 then\n    return p\n  else\n    return modp(n,\
    \ p) + 1\n  end\nend", "  -- https://stackoverflow.com/questions/4283121/whats-the-fastest-way-to-modular-a-number-in-c\n\
    \  local mod_n = n % p\n  if mod_n ~= 0 then\n    return modp(mod_n, p)\n  else\n\
    \    return n\n  end\nend", "    local r\n    if n == 0 then return 1 end\n  \
    \  -- Bail if p > n.\n    if n > p and p > 0 then return nil end\n    -- Bail\
    \ if n < 0 or p < 0.\n    if n < 0 or p < 0 then return nil end\n    -- Bail if\
    \ p == 0.\n    if p == 0 then return 1 end\n    -- Get closest int to n, rounding\
    \ up.\n    r = math.ceil(n / p)\n    -- Return 2^r modulo p.\n    return r * p\
    \ - r\nend", "  n = n % p\n  if n == 0 then\n    return 1\n  elseif n == p then\n\
    \    return 0\n  else\n    return modp(n / p, p)\n  end\nend", "  if n < 0 then\
    \ return 0 end\n  if p < 1 then return 0 end\n  if p == 1 then return 1 end\n\
    \  if p == 0 then return 0 end\n  if p == -1 then return -1 end\n  if p == -1\
    \ then return 0 end\n  if p == -2 then return 2 end\n  n = n - 1\n  return modp(n\
    \ / p, p) * p + n % p\nend", "  if p == 0 then\n    return 0\n  elseif p == 1\
    \ then\n    return n\n  else\n    return n % p\n  end\nend", "\t-- Special cases.\n\
    \tif p == 0 or p == 1 then\n\t\treturn 1\n\tend\n\tif n < 0 then\n\t\treturn modp(-n,\
    \ p)\n\tend\n\t-- If n is a multiple of p, return n.\n\treturn n - (n * math.floor(p))\n\
    end", "  -- Modulo\n  return math.floor(n / p) * p\nend", "  -- Avoid numeric\
    \ issues while doing modular arithmetic.\n  local q = 1\n  local r = n % p\n \
    \ while r == 0 do\n    q = q * 2\n    r = n % p\n  end\n  return q % p\nend",
  "  if n == 0 then return 1\n  elseif n == 1 then return p\n  elseif n >= p then\
    \ return n % p\n  else return modp(n / p, p) * p + n % p end\nend", "  if n <\
    \ p then\n    return 0\n  end\n  if n == p then\n    return 1\n  end\n  if p ==\
    \ 0 then\n    return 0\n  end\n  local q = n / p\n  if q == 0 then\n    return\
    \ 0\n  end\n  local r = n % p\n  return r + modp(q, p)\nend", "  local m = n %\
    \ p\n  if m < 0 then\n    m += p\n  end\n  return m\nend", "\tlocal d = p % n\n\
    \tif d ~= 0 then\n\t\treturn (p - d) / n\n\tend\n\treturn 1\nend", "  -- Use \"\
    ==\" operator instead of \"~=\" because \"~\" sometimes fails.\n  if n == 0 then\
    \ return 1 end\n  if p == 0 then return 0 end\n  if n == p then return 1 end\n\
    \  if n < p then return modp(n - p, p) end\n  return n % p + modp((n % p) + p\
    \ - 1, p)\nend", "\tp = p or 1\n\tlocal m = n % p\n\tif m == 0 then\n\t\tm = p\n\
    \telse\n\t\tm = p - m\n\tend\n\treturn m\nend", "  local q = modinv(p, n)\n  if\
    \ q > p then\n    q = p - q\n  else\n    q = q + p\n  end\n  return q % p\nend",
  "\tif n < 0 or p < 0 then\n\t\terror(\"modp: n and p must be non-negative\")\n\t\
    end\n\tif p == 1 then\n\t\treturn 1\n\tend\n\tlocal x = p\n\tlocal y = 0\n\twhile\
    \ x ~= 0 do\n\t\ty = y*2 + x%p\n\t\tx = floor(x/p)\n\tend\n\treturn y - 1\nend",
  "    return ((n % p) + p) % p\nend", "  if n == 0 then return 1 end\n  local c\n\
    \  for c = 1, n do\n    if p == c then return 1 end\n    local m = n % p\n   \
    \ n = m\n  end\n  return n % p\nend", "\tn = n % p\n\tif n > p and n >= 0 then\n\
    \t\treturn modp(n + 1, p)\n\tend\n\treturn p\nend", "\t-- Modulo operator:\n\t\
    return ((n % p) + p) % p\nend", "    -- We assume that n < p and n is positive.\
    \ Otherwise n and p are unsigned\n    -- numbers.\n    if n == 0 then return 1\n\
    \    else if p == 0 then return 0\n    else return n % p\n    end\nend", "  local\
    \ m, r = divmod(n, p)\n  return m and modp(m, p) or r\nend", "    if p == 0 then\n\
    \        return 1\n    end\n    local m = (n % (p or 1)) ~= 0 and (n / p) or 0\n\
    \    if p < 0 and m == 0 then\n        m = -1\n    elseif p < 0 and m ~= 1 then\n\
    \        m = -m\n    end\n    return m\nend", "  local nBits, pBits = p^n, p^(p-1)\n\
    \  if pBits == 0 then\n    return 1\n  end\n  local q = p\n  for i = 1, pBits\
    \ do\n    q = q + p\n    if q > nBits then\n      break\n    end\n  end\n  return\
    \ q % p\nend", "  local t = n % p\n  if t == 0 then\n    return 1\n  elseif t\
    \ == p then\n    return n\n  else\n    return modp(t, p) + p\n  end\nend", " \
    \   local d = n - 1\n    while d % p == 0 do\n        d = (d - 1) % p\n    end\n\
    \    return (d + p) % p\nend", "  local p = p or 1\n  local x = ((n % p) + p)\
    \ % p\n  if x < 0 then\n    local t = x\n    x = (n + 1)\n    while(x == t % p)\
    \ x = (n + 1)\n  end\n  return x\nend", "\tif n ~= p and n % p == 0 then\n\t\t\
    return (n / p + p / 2)\n\telse\n\t\treturn n\n\tend\nend", "  if n < 0 then\n\
    \    return 0\n  elseif n >= p then\n    return n\n  else\n    return n % p +\
    \ modp(n / p, p)\n  end\nend", "\t-- Find power of two greater than or equal to\
    \ n (n may be negative).\n\t-- >>> modp(11, 5)\n\t-- 8\n\t-- >>> modp(10, 5)\n\
    \t-- 2\n\t-- >>> modp(6, 10)\n\t-- 4\n\t-- >>> modp(3, 3)\n\t-- 1\n\t-- >>> modp(127,\
    \ 101)\n\t-- 6", "  if n == 0 then\n    return 0\n  elseif n == p then\n    return\
    \ 1\n  elseif n % p == 0 then\n    return modp(n / p, p)\n  else\n    return modp(n\
    \ / p, p) * p\n  end\nend", "  -- See http://primes.utm.edu/lists/small/1031.txt\n\
    \  -- See http://primes.utm.edu/lists/small/1031_1.txt", "    -- If the number\
    \ is small, return it straightaway.\n    if n < p then\n        return n", "\t\
    assert(n > 0)\n\tassert(type(p) == 'number')\n\tassert(p >= 1)\n\tassert(p <=\
    \ p / 2)\n\treturn math.floor(n / p) * p + n % p\nend", "    -- Avoid numeric\
    \ issues by using binary operations.\n    -- https://stackoverflow.com/a/1027865/139414\n\
    \    local t = ((2^n) - 1) / (p - 1) -- T = (2^n - 1) / (p - 1)\n    return math.modf(t)\
    \ -- Return fractional and integral parts.\nend", "  if n < 0 then return 0 end\n\
    \  if n < p then return modp(n, p - 1) end\n  if n == p then return 1 end\n  if\
    \ n % p == 0 then\n    return modp(n - p, p)\n  else\n    return modp(n + (p -\
    \ n % p), 0)\n  end\nend", "    local x, y = p * n, n\n    while x > 1 do\n  \
    \      x, y = x % p, y\n    end\n    return n % p\nend", "\tif n and p then\n\t\
    \tn = math.floor(math.log(n, p) / math.log(p))\n\t\tn = n % p\n\tend\n\treturn\
    \ n\nend", "    -- Avoid numeric underflow.\n    if p == 0 or n == 0 then\n  \
    \      return 0\n    end", "\t-- If n < 0, we shall have returned the smallest\
    \ n possible.\n\t-- This may or may not be desirable, as n can be negative and\
    \ we may have\n\t-- returned the smallest n possible.\n\t-- If n == 0, then p\
    \ can not be 0.\n\tif n < 0 then\n\t\tif n == 0 then\n\t\t\treturn p\n\t\telse\n\
    \t\t\treturn 0\n\t\tend\n\tend\n\t-- If n == 0, we shall have returned the smallest\
    \ n possible.\n\tif n == 0 then\n\t\treturn p\n\tend\n\t-- If n < p, then n =\
    \ p, and p = 0.\n\t-- If n >= p, then n-p is an integer and is the same as the\
    \ next smaller integer,\n\t-- which means we may have returned the smallest n\
    \ possible.\n\t-- This may be desirable, as n may be negative.\n\t-- This test\
    \ may fail, if p is not an integer.\n\tif n < p then\n\t\treturn 0\n\tend\n\t\
    -- If n >= p, then n-p is a positive integer and is the same as the next smaller\
    \ integer,\n\t-- which means we may have returned the smallest n possible.\n\t\
    -- This may be desirable, as n may be positive.\n\t-- This test may fail, if p\
    \ is not an integer.\n\tif n >= p then\n\t\treturn modp(n - p, p)\n\tend\n\t--\
    \ If the quotient is odd, then n-p is odd, or is a positive integer,\n\t-- and\
    \ is the same as the next smaller integer.\n\t-- This may be desirable, as n may\
    \ be negative.\n\t-- This test may fail, if p is not an integer.\n\tif n >= p\
    \ and n % 2 == 1 then\n\t\treturn modp(n - p, p)\n\tend\n\t-- If the quotient\
    \ is even, then n-p is even, or is a positive integer,\n\t-- and is the same as\
    \ the next smaller integer.\n\t-- This may be desirable, as n may be negative.\n\
    \t-- This test may fail, if p is not an integer.\n\tif n >= p and n % 2 == 0 then\n\
    \t\treturn modp(n - p, p)\n\tend\n\t-- Otherwise, return modp of n / p, and subtract\
    \ one from p.\n\tlocal newp = p - 1\n\t-- The result must be smaller than p as\
    \ n / p may not be an integer.\n\t-- (This test may fail if p is not an integer;\
    \ but note that p may actually be integer.)\n\tif newp > math.floor(n/p) then\n\
    \t\treturn modp(n - (n / p), 1)\n\tend\n\t-- Otherwise, return the result.\n\t\
    return newp\nend", "  if p == 0 then\n    return 1\n  end\n  if p == 1 or p ==\
    \ 2 or p == 3 then\n    return n\n  end\n  if p == 4 then\n    return n / p\n\
    \  end\n  if n % p == 0 then\n    return n\n  else\n    return modp(n / p, p)\n\
    \  end\nend", "  if p == 0 then\n    return 1\n  else\n    return (n % p + modp(n\
    \ / p, p)) % p\n  end\nend", "  return ((n % p) + p) % p\nend", "  local x = math.floor(n/p)\n\
    \  n = n % p\n  return x * p + n \nend", "  if n ~= nil and p ~= nil then\n  \
    \  -- Avoid overflow due to limited precision.\n    if n < p then\n      local\
    \ mod = ((p - 1) * (p + 1))\n      if mod < n then return mod end\n    elseif\
    \ n > p then\n      local mod = ((p - 1) * (p - 1))\n      if mod < n then return\
    \ mod end\n    end\n  end\n  return nil\nend", "  return math.floor(n) % (p or\
    \ 0) -- Lua 5.2\nend", "\tlocal nBits, m = n % p, n = math.floor(n/p)\n\tif n\
    \ == 0 or n == p then\n\t\treturn 1\n\telse\n\t\treturn modp(n - m*p, p)\n\tend\n\
    end", "  local e = 2\n  while e <= p do\n    if n & (1 << (e - 1)) == 0 then\n\
    \      return e\n    end\n    e = e * 2\n  end\n  return p\nend", "   if n ==\
    \ 0 then\n      return 1\n   else\n      return modn(math.abs(n)*p, p)\n   end\n\
    end", "  assert(n >= 0)\n  assert(p >= 0)\n  if n == 0 then\n    return 1\n  end\n\
    \  if n == 1 then\n    return p\n  end\n  return modp(n / 2, p) * p + modp((n\
    \ + 1) / 2, p)\nend", "  n = n - 1\n  if n < 0 then return 0 end\n  if n == 0\
    \ then return 1 end\n  if p < 2 then return n % p end\n  local i\n  for i = 1,\
    \ p do\n    n = ((n % p) + p) % p\n  end\n  return n\nend", "\t-- Optimization:\
    \ if n is small, return n-1.\n\tif n < 0 or n < p then\n\t\treturn n - 1\n\tend",
  "\tif n <= 0 then return 0 end\n\tif n == 1 then return 1 end\n\tif p == 1 then\
    \ return 1 end\n\treturn modp(n >> 1, p >> 1) + (n & 1 and 1 or 0) - modp((n >>\
    \ 1) + (n & 1 and -1 or 0), p >> 1)\nend", "    local r = 0\n    while n > 1 do\n\
    \        -- n is odd, divide by 2\n        if n % 2 == 1 then\n            n =\
    \ n / 2\n        else\n            -- n is even => return result of last division\n\
    \            r = r * 10 + n % p\n            n = n / p\n        end\n    end\n\
    \    return r\nend\nreturn modp"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
