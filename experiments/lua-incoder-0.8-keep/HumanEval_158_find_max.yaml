name: HumanEval_158_find_max
language: lua
prompt: "-- Write a function that accepts a list of strings.\n-- The list contains\
  \ different words. Return the word with maximum number\n-- of unique characters.\
  \ If multiple strings have maximum number of unique\n-- characters, return the one\
  \ which comes first in lexicographical order.\n-- find_max([\"name\", \"of\", \"\
  string\"]) == \"string\"\n-- find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\
  \n-- find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlocal function find_max(words)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_max\n\
  \    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')\n    lu.assertEquals(candidate({'name',\
  \ 'enam', 'game'}), 'enam')\n    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}),\
  \ 'aaaaaaa')\n    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')\n    lu.assertEquals(candidate({'play',\
  \ 'this', 'game', 'of', 'footbott'}), 'footbott')\n    lu.assertEquals(candidate({'we',\
  \ 'are', 'gonna', 'rock'}), 'gonna')\n    lu.assertEquals(candidate({'we', 'are',\
  \ 'a', 'mad', 'nation'}), 'nation')\n    lu.assertEquals(candidate({'this', 'is',\
  \ 'a', 'prrk'}), 'this')\n    lu.assertEquals(candidate({'b'}), 'b')\n    lu.assertEquals(candidate({'play',\
  \ 'play', 'play'}), 'play')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local max_unique = #words\n  local max_word = \"\"\n  for i = 1,\
    \ #words do\n    local unique = 0\n    for j = 1, #words do\n      if words[j]\
    \ == words[i] then\n        unique = unique + 1\n      end\n    end\n    if unique\
    \ > max_unique then\n      max_unique = unique\n      max_word = words[i]\n  \
    \  end\n  end\n  return max_word\nend", "  local max = \"\"\n  local word = \"\
    \"\n  for _, word in ipairs(words) do\n    local count = 0\n    for c in word\
    \ do\n      count = count + 1\n    end\n    if count > #max then\n      max =\
    \ word\n    end\n  end\n  if max ~= \"\" then\n    return max\n  else\n    return\
    \ nil\n  end\nend", "  local max_count = -1\n  local max_string = nil", "   local\
    \ counts = {}\n   for _, word in ipairs(words) do\n      counts[word] = counts[word]\
    \ or 0\n      counts[word] = counts[word] + 1\n   end\n   local max_word = nil\n\
    \   local max_count = -1\n   for key, value in pairs(counts) do\n      if value\
    \ > max_count then\n         max_count = value\n         max_word = key\n    \
    \  end\n   end\n   \n   return max_word\nend\n</cell>\n<cell>", "    -- Your code\
    \ here\n    local table = {}\n    for i,v in pairs(words) do\n       if table.count(v)\
    \ > 0 then\n           table[v] = table[v]+1\n       else\n           table.insert(v,0)\n\
    \       end\n    end\n    local max,maxi = -1,-1\n    for k,v in pairs(table)\
    \ do\n        if v>max then\n            max = v\n            maxi = k\n     \
    \   end\n    end\n    return words[maxi]\nend", "  -- Write your code here\n \
    \ local unique = {}\n  for i = 1, #words do\n    unique[words[i]] = 0\n  end\n\
    \  local max_val = -1\n  local max_word = \"\"\n  for i = 1, #words do\n    if\
    \ unique[words[i]] > max_val then\n      max_val = unique[words[i]]\n      max_word\
    \ = words[i]\n    end\n    unique[words[i]] = unique[words[i]] + 1\n  end\n  return\
    \ max_word\nend", "  local alphabet = {}\n  local max_count = 0\n  local max_word\
    \ = \"\"\n  for i = 1, #words do\n    alphabet[i] = 0\n  end -- for", "    local\
    \ max = nil\n    for _, word in ipairs(words) do\n        if not max or #word\
    \ > #max then\n            max = word\n        else\n            max = max ..\
    \ ' ' .. word\n        end\n    end\n    return max\nend", "   if words == nil\
    \ then\n      return nil\n   end\n   local max = words[1]\n   for i = 2, #words\
    \ do\n      local cur = words[i]\n      if #(cur) == 1 then\n         local len\
    \ = #cur\n         if len > #max then\n            max = cur\n         end\n \
    \     end\n   end\n   return max\nend\nassert(find_max([\"name\", \"enam\", \"\
    game\"]) == \"enam\")\nassert(find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\")",
  "  local max = {}\n  local word = words[1]\n  for _, v in pairs(words) do\n    local\
    \ count = {}\n    for _, c in pairs(v) do\n      count[c] = (count[c] or 0) +\
    \ 1;\n    end\n    for _, c in pairs(count) do\n      if count[c] > max[c] then\n\
    \        max[c] = count[c];\n        word = c\n      end\n    end\n  end\n  return\
    \ word\nend", "  return words[#words] -- Returns the string with the maximum number\
    \ of unique characters.\nend", "  local max = 0 \n  local word = 0 ", "  local\
    \ max_count = 0\n  local max_string = \"\"\n  local word_counts = {}\n  for _,\
    \ w in ipairs(words) do\n    local count = word_counts[w]\n    word_counts[w]\
    \ = count + 1\n    if count > max_count then\n      max_count = count\n      max_string\
    \ = w\n    end\n  end\n  if #word_counts > 1 then\n    local i = 0\n    for w\
    \ in word_counts do\n      if word_counts[w] > i then\n        i = word_counts[w]\n\
    \      end\n    end\n    return max_string\n  else\n    return max_string\n  end\n\
    end", "  local max\n  local i = 1\n  local word = words[i]\n  for j = 1, #words\
    \ do\n    local c = string.count(words[i], words[j])\n    if c > max then\n  \
    \    max = c\n      word = words[j]\n    end\n  end\n  if i == #words then return\
    \ word end\n  return find_max(words) .. word\nend", "\tlocal max_count = -1\n\t\
    local max_word = nil\n\tfor _, w in ipairs(words) do\n\t\tif #w > max_count then\n\
    \t\t\tmax_count = #w\n\t\t\tmax_word = w\n\t\telse\n\t\t\tif #w == max_count then\n\
    \t\t\t\tif w < max_word then\n\t\t\t\t\tmax_word = w\n\t\t\t\tend\n\t\t\telse\n\
    \t\t\t\tif w > max_word then\n\t\t\t\t\tmax_word = w\n\t\t\t\tend\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn max_word\nend", "\tlocal max = 0\n\tlocal min = 1\n\t\
    for i,word in ipairs(words) do\n\t\t-- find the number of unique characters\n\t\
    \tlocal count = 0\n\t\tfor j,c in ipairs(word) do\n\t\t\tcount = count + 1\n\t\
    \tend\n\t\t-- find the max number of unique characters\n\t\tif count > max then\n\
    \t\t\tmax = count\n\t\tend\n\t\t-- find the min number of unique characters\n\t\
    \tif count < min then\n\t\t\tmin = count\n\t\tend\n\tend\n\tif min == 0 then\n\
    \t\treturn \"\"\n\tend\n\t-- find the word with minimum number of unique characters\n\
    \tfor i,word in ipairs(words) do\n\t\tlocal count = 0\n\t\tfor j,c in ipairs(word)\
    \ do\n\t\t\tcount = count + 1\n\t\tend\n\t\tif count == min then\n\t\t\treturn\
    \ word\n\t\tend\n\tend\nend", "  local num_unique = {}\n  for _, word in ipairs(words)\
    \ do\n    local num_count = 0\n    for _, c in pairs(word) do\n      num_count\
    \ = num_count + 1\n    end\n    num_unique[word] = num_count\n  end", "  local\
    \ max_unique = {}\n  local max_unique_length = {}\n  local max_word = nil\n  for\
    \ i = 1, #words do\n    local word_length = 0\n    for _, character in words[i]:gmatch(\"\
    .\") do\n      word_length = word_length + 1\n    end\n    if max_unique_length[word_length]\
    \ then\n      max_unique_length[word_length] = max_unique_length[word_length]\
    \ + 1\n    else\n      max_unique_length[word_length] = 1\n    end\n    if max_unique[word_length]\
    \ then\n      max_unique[word_length] = max_unique[word_length] + 1\n    else\n\
    \      max_unique[word_length] = 1\n    end\n    local word_letters = {}\n   \
    \ for _, character in words[i]:gmatch(\".\") do\n      word_letters[character]\
    \ = word_letters[character] + 1\n    end\n    local word_letters_sorted = {}\n\
    \    for key, value in pairs(word_letters) do\n      word_letters_sorted[value]\
    \ = key\n    end\n    local max_word_characters = #word_letters\n    if max_word_characters\
    \ > max_unique_length[word_length] then\n      max_word = words[i]\n    end\n\
    \  end\n  return max_word\nend", "  local max\n  local count\n  for _, word in\
    \ ipairs(words) do\n    count = nil\n    for _, char in pairs(word) do\n     \
    \ count = count or 1\n      if count > max then\n        max = count\n      end\n\
    \      count = count + 1\n    end\n  end\n  return max\nend", "    if not words\
    \ then return '' end\n    local count = {}\n    for _, word in ipairs(words) do\n\
    \        count[#count + 1] = word .. 1\n    end\n    local max = {}\n    for _,\
    \ word in ipairs(words) do\n        local maxWord = word\n        for i = 1, #word\
    \ do\n            if count[#count + 1] > count[i] then\n                count[#count\
    \ + 1] = count[i]\n                maxWord = word\n            end\n        end\n\
    \        max[#max + 1] = maxWord\n    end\n    return max[#max][1]\nend\nprint(find_max([\"\
    name\", \"of\", \"string\"]) == \"string\")\nprint(find_max([\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nprint(find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\
    \")", "  local max, i, j, l = 0, {}, {}, 0\n  for _, v in ipairs(words) do\n \
    \   for j = 1, #v do\n      l = (j - 1) * 100 + #v + #v + 1\n      i = i + 1 if\
    \ v[j] == nil or l>i or l<max then l=i else max=l end\n      j[l] = v[j]\n   \
    \ end\n  end\n  return max\nend", "  return words[1] -- return first item\nend",
  "   local maxValues = {}\n   local maxValue = 0\n   for _, word in ipairs(words)\
    \ do\n      local value = #word\n      for i = 1, #word do\n         if maxValues[i]\
    \ < value then\n            maxValue = value\n            maxValues[i] = value\n\
    \         end\n      end\n   end\n   return maxValues[#maxValues]\nend", "  local\
    \ max_char = words[1][1]\n  local max_count = 0\n  local max_idx\n  for idx =\
    \ 2, #words do\n    if words[idx][1] == max_char then\n      count = words[idx]\n\
    \      if count > max_count then\n        max_count = count\n        max_idx =\
    \ idx\n      end\n    end\n  end\n  if max_count > 0 then\n    return words[max_idx]\n\
    \  else\n    return \"\"\n  end\nend", "    local max_count = -1\n    local max_word\
    \ = \"\"\n    for i,v in ipairs(words) do\n        local count = #v\n        if\
    \ count > max_count then\n            max_count = count\n            max_word\
    \ = v\n        end\n    end\n    return max_word\nend", "   local wordHashes =\
    \ {}\n   for _, word in ipairs(words) do\n      local wordHash = #word\n     \
    \ wordHashes[word] = wordHash", "  local max = {}\n  for i, word in pairs(words)\
    \ do\n    local n = #word\n    if string.len(word) > 0 then\n      if not max[word]\
    \ then\n        max[word] = n\n      elseif max[word] < n then\n        max[word]\
    \ = n\n      end\n    end\n  end\n  if max[\"\"] then\n    return \"\"\n  end\n\
    \  local maxNum = 0\n  local wordWithMaxNum = {}\n  for word, num in pairs(max)\
    \ do\n    if maxNum < num then\n      wordWithMaxNum = word\n      maxNum = num\n\
    \    end\n  end\n  return wordWithMaxNum\nend", "  local max = -1\n  local wordWithMax\
    \ = \"\"\n  local wordWithMaxCount = 0", "   local max_val = words.reduce([[\n\
    \      function(x, y)\n         return x ~= y and x or y\n      end\n   ]], 0)\
    \ or 0\n   for _, word in ipairs(words) do\n      max_val = math.max(max_val,\
    \ #word)\n   end\n   for _, word in ipairs(words) do\n      local count = #word\n\
    \      for i = 1, #word do\n         count = count - #word[i]\n         if count\
    \ > 0 then\n            return word\n         end\n      end\n   end\n   return\
    \ nil\nend", "   local max = \"\"\n   local n = #words\n   for i=1,n do\n    \
    \  if max ~= \"\" then\n         local k = #max\n         if max ~= words[i] then\n\
    \            max = words[i]\n         end\n         if k > n then\n          \
    \  return max\n         end\n      else\n         max = words[i]\n      end\n\
    \   end\nend", "    -- your code\n    local max_count = words[1]\n    local index\
    \ = 2\n    for _, word in pairs(words) do\n        if word ~= words[index] then\n\
    \            max_count = max_count + 1\n        else\n            if max_count\
    \ > words[index] then\n                max_count = words[index]\n            end\n\
    \        end\n        index =index + 1\n    end\n    return max_count == words[#words]\
    \ and  words[#words]  or  \"\"\nend", "  local results = {}\n  for _, word in\
    \ ipairs(words) do\n    local counts = {}\n    for c in word:gmatch\"(.)\"\n \
    \   do\n      counts[c] = counts[c] or 1\n    end\n    for c, _ in pairs(counts)\n\
    \    do\n      table.insert(results, word)\n    end\n  end\n  table.sort(results,\
    \ function(a, b) return #a > #b end)\n  return results[1]\nend", "    local num_unique\
    \ = 0\n    local last_word = \"\"\n    for i,v in pairs(words) do\n        local\
    \ num_char = #v\n        if num_unique == 0 or num_char > num_unique then\n  \
    \          last_word = v\n            num_unique = num_char\n        end\n   \
    \ end\n    return last_word\nend", "  local maxCount = 0\n  local maxWord = nil\n\
    \  for _, word in ipairs(words) do\n    local count\n    count, maxWord = 1, word\n\
    \    for _, char in pairs(word) do\n      count = count + 1\n      if count >\
    \ maxCount then maxCount = count, maxWord = word end\n    end\n  end\n  return\
    \ maxWord\nend", "  if words == nil then\n    return nil\n  elseif #words == 0\
    \ then\n    return \"\"\n  elseif #words == 1 then\n    local word = words[1]\n\
    \    local count = #word\n    if count == 0 then\n      return word\n    elseif\
    \ count == 1 then\n      return \"\"\n    end\n  end", "  if words == nil then\n\
    \    return nil\n  end\n  local max_value = words[1]\n  local words = words[2..]\n\
    \  for i = 2, #words do\n    local cur_val = words[i]\n    local index = i + 1\n\
    \    local length = #cur_val\n    local char_count = {}\n    for j = 1, length\
    \ do\n      local char = string.sub(cur_val, j, j)\n      char_count[char] = char_count\
    \ and char_count[char] + 1 or 1\n      if char_count > max_value then\n      \
    \  max_value = char_count\n        index = i\n      end\n    end\n    words =\
    \ words[index..]\n  end\n  return words[index] or \"\"\nend", "  local results\
    \ = {}\n  for _, word in pairs(words) do\n    table.insert(results, word)\n  end\n\
    \  table.sort(results, function(a, b) return #a == #b end)\n  return table.find(results,\
    \ function(word) return #word == 1 end)\nend", "\tlocal maxCount = 0\n\tlocal\
    \ maxWord = \"\"\n\tfor _, word in ipairs(words) do\n\t\tlocal count = 0\n\t\t\
    for _, char in ipairs(word) do\n\t\t\tcount = count + 1\n\t\tend\n\t\tif count\
    \ > maxCount then\n\t\t\tmaxCount = count\n\t\t\tmaxWord = word\n\t\tend\n\tend\n\
    \treturn maxWord\nend", "  assert(type(words) == \"table\")\n  local words_dict\
    \ = {}\n  local max_string = \"\"\n  local max_cnt = 0", "  local max_count =\
    \ nil\n  local max_word\n  for _, word in ipairs(words) do\n    local count =\
    \ #word\n    if max_count == nil or max_count > count then\n      max_count =\
    \ count\n      max_word = word\n    end\n  end\n  if max_count ~= nil then\n \
    \   for _, word in ipairs(words) do\n      if word ~= max_word and #word == max_count\
    \ then\n        return word\n      end\n    end\n  end\n  return \"\"\nend", "\t\
    local max_idx = nil\n\tlocal max_val = nil\n\tfor idx, val in ipairs(words) do\n\
    \t\tif val == max_val then\n\t\t\tmax_idx = idx\n\t\t\tbreak\n\t\tend\n\tend",
  "  local max_char = { }\n  local max_count = 1\n  local words = setmetatable({ },\
    \ { __index = nil })\n  for _, word in pairs(words) do\n    words[word] = true\n\
    \    for _, char in ipairs(word) do\n      table.insert(max_char, char)\n    \
    \  if not words[char] then\n        max_count = max_count + 1\n      end\n   \
    \ end\n  end\n  if max_count == 1 then\n    return \"\"\n  else\n    return table.concat(max_char,\
    \ 1)\n  end\nend", "\tlocal max = 0\n\tlocal word = words[#words]\n\tfor _, v\
    \ in ipairs(words) do\n\t\tlocal count = 0\n\t\tfor c in string.gmatch(v, \"%a\"\
    ) do\n\t\t\tcount = count + 1\n\t\tend\n\t\tif count > max then\n\t\t\tmax = count\n\
    \t\t\tword = v\n\t\tend\n\tend\n\treturn word\nend", "  assert(words, \"words\"\
    )\n  if #words == 0 then\n    return \"\"\n  end", "    local max_num_unique =\
    \ 0\n    local max_unique_index = nil\n    local max_unique_chars = nil\n    for\
    \ i = 1, #words,1 do\n        local num_unique = count_unique_chars(words[i])\n\
    \        if num_unique > max_num_unique then\n            max_num_unique = num_unique\n\
    \            max_unique_index = i\n            max_unique_chars = num_unique\n\
    \        end\n    end\n    if max_num_unique == 0 then\n        return \"\"\n\
    \    end\n    local index = max_unique_index\n    return words[index]\nend", " \
    \ local unique_characters = {}\n  local max_characters = \"\"\n  for i = 1, #words\
    \ do\n    local characters = string.rep((words[i]):gsub(\"%W\", \"\"), #unique_characters)\n\
    \    if not unique_characters[characters] then\n      unique_characters[characters]\
    \ = 1\n    else\n      unique_characters[characters] = unique_characters[characters]\
    \ + 1\n    end\n    if unique_characters[characters] > #max_characters then\n\
    \      max_characters = words\n    end\n  end\n  return max_characters\nend\n\
    print(find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]))\n</cell>\n<text>\nExercise:\nWrite\
    \ a function that accepts a list of integers greater than 1 and less than 100000.\n\
    The function should return an integer which represents the sum of the squares\
    \ of the numbers in the list.\nFor example,\nsum_square([7, 11, 52]) should return\
    \ 225.", "  local count = 0\n  local largest = \"\"\n  local index = nil\n  for\
    \ i=1, #words do\n    count = count + 1\n    if count > 1 then\n      index =\
    \ i\n    end\n    if count == 1 then\n      largest = words[i]\n    end\n  end\n\
    \  if count == 1 then\n    return largest\n  end\n  largest = words[index]\n \
    \ for i=index+1, #words do\n    if words[i] > largest then\n      largest = words[i]\n\
    \    end\n  end\n  return largest\nend", "  -- Write your code here.\n  local\
    \ m = {}\n  for i = 1,#words do\n    local n = #m\n    m[words[i]] = n\n  end\n\
    \  local k = 1\n  local max_k = -1\n  local i = 0\n  while i <= #words and k <=\
    \ max_k do\n    local n = m[i]\n    k = k + n\n    i = i + 1\n  end\n  local j\
    \ = 1\n  while j <= i do\n    local k = m[j]\n    if k > max_k then\n      max_k\
    \ = k\n    end\n    j = j + 1\n  end\n  if max_k > 0 then\n    local max_word\
    \ = \"\"\n    local max_count = 0\n    for i = 1,#words do\n      if words[i]\
    \ == words[max_count] then\n        local n = #words[i]\n        if n == max_count\
    \ then\n          max_word = words[i]\n        else\n          max_count = max_count\
    \ + 1\n        end\n      end\n    end\n    return max_word\n  end\n  -- Note:\
    \ Returning an empty string \"\" is allowed.\n  return \"\"\nend", "  if #words\
    \ == 0 then return nil end\n  if #words == 1 then return words[1] end\n  local\
    \ counters = {}\n  for _, word in ipairs(words) do\n    local counter = counters[word]\
    \ or 0\n    counters[word] = counter + 1\n  end\n  local sorted_pairs = pairs(counters)\n\
    \  table.sort(sorted_pairs, function(a, b)\n    if counters[a] > counters[b] then\n\
    \      return 1\n    elseif counters[a] < counters[b] then\n      return -1\n\
    \    else\n      return 0\n    end\n  end)\n  return sorted_pairs[1]\nend", " \
    \  local max_len = 0\n   local word = {}\n   local count = 0\n   for _, x in pairs(words)\
    \ do\n      if x > max_len then\n         word = x\n         count = count+1\n\
    \      elseif x == max_len then\n         count = count+1\n      elseif count\
    \ == max_len then\n         word = x\n      end\n      max_len = max_len + 1\n\
    \   end\n   return word\nend", "    local max_len = 1\n    local max_word = \"\
    \"\n    local max_word_index = 1\n    local max_len_index = 1", "    if #words\
    \ <= 0 then\n        return \"\"\n    end\n    local wordCount = {}\n    local\
    \ maxCount = 0\n    local maxWord = \"\"\n    for word in words do\n        if\
    \ wordCount[word] == nil then\n            wordCount[word] = 1\n        else\n\
    \            wordCount[word] = wordCount[word] + 1\n            if wordCount[word]\
    \ > maxCount then\n                maxCount = wordCount[word]\n              \
    \  maxWord = word\n            end\n        end\n    end\n    return maxWord\n\
    end", "  if #words == 0 then\n    return \"\"\n  end", "  return words[#words]:gsub(\"\
    %z\", \"\"):gsub(\"%A\", \"a\")\nend\nprint(find_max([\"name\", \"enam\", \"game\"\
    ]))", "    local count = {}\n    for w in words do\n        count[#count+1] =\
    \ count[#count] + 1\n    end\n    return words[math.min(#count, #words)]\nend",
  "  local max_count = -1\n  local max_word = words[1]\n  for i = 2, #words do\n \
    \   local count = count_characters(words[i], max_word)\n    if count > max_count\
    \ then\n      max_count = count\n      max_word = words[i]\n    end\n  end\n \
    \ return max_word\nend", "  local max = 0\n  local first = nil\n  for _, word\
    \ in ipairs(words) do\n    if word:match(\"^%s*%%.-\") then\n      max = max +\
    \ 1\n      if max == 0 then\n        first = word\n      elseif max > first then\n\
    \        first = word\n      end\n    end\n  end\n  return first\nend", "  local\
    \ max_count = nil\n  local max_value = nil\n  for _, word in pairs(words) do\n\
    \    local count = 0\n    for c in word do\n      if c == \"a\" then count = count\
    \ + 1 end\n      if c == \"z\" then count = count + 26 end\n    end\n    if max_count\
    \ == nil then\n      max_count = count\n      max_value = word\n    elseif max_count\
    \ > count then\n      max_count = count\n      max_value = word\n    end\n  end\n\
    \  return max_value\nend", "    -- Write your function here\n    local max = {}\n\
    \    for i,v in pairs(words) do\n        local count = 0\n        for k,w in pairs(max)\
    \ do\n            if v < w then\n                max = {\"a\"}\n            elseif\
    \ v > w then\n                count = count+1\n                max = {v}\n   \
    \         end\n        end\n        if count == #max then\n            table.insert(max,\
    \ v)\n        end\n    end\n    return table.remove(max, 1)\nend\nprint(find_max([\"\
    name\", \"of\", \"string\"]))\nprint(find_max([\"name\", \"enam\", \"game\"]))\n\
    print(find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]))", "  local max = \"\"\n  local\
    \ count = 0\n  for _,word in ipairs(words) do\n    count = count + 1\n    max\
    \ = word .. count\n  end\n  return max\nend", "    -- base case\n    if #words\
    \ == 0 then\n        return \"\"\n    end", "    local max = 0\n    local currentWord\
    \ = \"\"\n    for _, _ in pairs(words) do\n        local count = 0\n        for\
    \ char in words do\n            count = count + 1\n            if char == currentWord\
    \ then\n                count = count + 1\n            end\n        end\n    \
    \    if count > max then\n            max = count\n            currentWord = words[math.min(1,#words)\
    \ - 1]\n        end\n    end\n    return currentWord\nend", "   local max = words[1]\n\
    \   for _, word in ipairs(words) do\n      max = max and (#word) == #max and word\
    \ or \"\"\n   end\n   return max\nend", "   local max = 0\n   local word\n   for\
    \ _, word in ipairs(words) do\n      if string.len(word) > max then\n        \
    \ max = string.len(word)\n      end\n   end\n   return word\nend", "    local\
    \ maxcount = nil\n    local maxword = \"\"\n    for w in words:gmatch(\"(%S+)\"\
    ) do\n        local count = 1\n        for char in w:gmatch(\"%W\") do\n     \
    \       if #char == 0 then break end\n            count = count + 1\n        end\n\
    \        if count == maxcount then\n            maxword = w\n        elseif count\
    \ > maxcount then\n            maxcount = count\n            maxword = w\n   \
    \     end\n    end\n    return maxword\nend", "    local max = 0\n    local word\
    \ = \"\"\n    for _, word in ipairs(words) do\n        -- Count the number of\
    \ unique characters\n        local count = 0\n        for _, c in ipairs(word)\
    \ do\n            count = count + 1\n        end\n        -- If the count of unique\
    \ characters is the bigger than the maximum\n        -- so far, then update the\
    \ maximum and the word that has that maximum\n        if count > max then\n  \
    \          max = count\n        end\n    end", "  local max = \"\"\n  local index\
    \ = 1\n  for word in words: -- loop all words and set max and index to 0\n   \
    \ if #word > #max then -- if length of word greater than max\n      max = word\
    \ -- set max to word\n      index = 1 -- set index to 1\n    else -- if length\
    \ of word equals max then increase index\n      index = index + 1\n    end\n \
    \ end\n  return max -- return max word\nend", "  -- Write your code in here!\n\
    \  local maxCount = 0\n  local word = \"\"\n  local count = 1\n  for i,v in ipairs(words)\
    \ do\n    count = count + 1\n    if count == maxCount then\n      word = v\n \
    \   end\n    if count > maxCount then\n      maxCount = count\n      word = v\n\
    \    end\n  end\n  return word\nend", "  -- Count the number of unique characters\
    \ and find the word with highest count.\n  -- If the count is equal, return the\
    \ word with first unique character in lexicographical order.\n  -- If there are\
    \ multiple words having the same count, return the word with first in lexicographical\
    \ order.\n  local function count(word)\n    local counts = {}\n    for i = 1,\
    \ #word do\n      local c = string.sub(word, i, i)\n      if counts[c] == nil\
    \ then\n        counts[c] = 1\n      else\n        counts[c] = counts[c] + 1\n\
    \      end\n    end\n    return counts\n  end\n  local max, word = nil, \"\"\n\
    \  for _, word in pairs(words) do\n    local c = count(word)\n    if c[1] > max\
    \ then\n      max = c[1]\n      word = word\n    end\n  end\n  return word\nend",
  "   local max = 0\n   local result = nil\n   for word in words do\n      if #word\
    \ > max then\n         max = #word\n         result = word\n      end\n   end\n\
    \   return result\nend", "\tlocal max = { count=0, str=nil }\n\tfor i = 1, #words\
    \ do\n\t\tlocal word, count = words[i], words[i]\n\t\tfor j = 1, #word do\n\t\t\
    \tlocal char = word[j]\n\t\t\tif max:count+=1, char\n\t\t\t\telseif max:count\
    \ < count then max = { count = count, str = word }\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn max.str\nend", "\tlocal counts = {}\n\tfor _, word in ipairs(words) do\n\
    \t\ttable.insert(counts, #word, 1)\n\tend\n\ttable.sort(counts)\n\tlocal maximum\
    \ = counts[#counts]\n\tfor _, word in ipairs(words) do\n\t\tlocal count = #word\n\
    \t\tcounts[#counts] = nil\n\t\tif count > maximum then\n\t\t\tmaximum = count\n\
    \t\tend\n\tend\n\treturn words[maximum]\nend", "   if not words or #words == 0\
    \ then\n      return \"\"\n   end", "    local max, i, currentMax = 0, 0, \"\"\
    \n    for _, word in ipairs(words) do\n        local count = {}\n        for char\
    \ in word:gmatch(\".\") do\n            table.insert(count, char)\n        end\n\
    \        count = table.sort(count, 0)\n        if #count == #word then\n     \
    \       if #currentMax == 0 then\n                currentMax = word\n        \
    \    elseif currentMax == word then\n                currentMax = currentMax ..\
    \ word\n            else\n                max = #count\n                currentMax\
    \ = word\n            end\n        end\n    end\n    if max == #words or currentMax\
    \ == \"\" then return \"\" end\n    return currentMax\nend", "   local max = nil\n\
    \   local i = 0\n   for word in words do\n      if max and #word > #max then\n\
    \         max = word\n      else\n         max = word if #word > #max and #word\
    \ > i then\n         i = #word\n      end\n   end\n   return max\nend", "    local\
    \ sorted_words = table.sort(words)\n    local max_index = 1\n    local max_count\
    \ = 1\n    for i = 1, #sorted_words do\n        local count = table.count(sorted_words,\
    \ sorted_words[i])\n        if count > max_count then\n            max_count =\
    \ count\n            max_index = i\n        end\n    end\n    return sorted_words[max_index]\n\
    end", "  local max_char = count(\"$\", words)\n  local max_count = words[max_char]\n\
    \  local index = 1 -- Index starts from 1.\n  for i = 1, #words do\n    if words[i][max_char]\
    \ > max_count then\n      max_count = words[i][max_char]\n      index = i\n  \
    \  end\n  end\n  return words[index]\nend", "  local max = words[1]\n  for i =\
    \ 2, #words do\n    if #words[i] ~= #max then\n      max = words[i]\n    end\n\
    \  end\n  -- If the word doesn't have unique characters, return nil.\n  if #max\
    \ ~= #words[1] then\n    return nil\n  end\n  -- Otherwise, we need to find the\
    \ first word in the lexicographical\n  -- order with the maximum number of unique\
    \ characters.\n  for i = 2, #words do\n    if #words[i] ~= #max then\n      return\
    \ words[#words]\n    end\n  end\nend", "    -- write your code in LUA\n    return\
    \ \"\"\nend", "    -- Your code here\nend", "   local result = {}\n   for _,w\
    \ in ipairs(words) do\n      result[#result + 1] = w\n   end\n   local max = 1\n\
    \   for i = 1, #result do\n      local count = #result\n      for j = 1, #result\
    \ do\n         if i == j then\n            continue\n         end\n         count\
    \ = count-1\n         local v = result[j]\n         if v == result[i] then\n \
    \           count = count+1\n         end\n         if count > max then\n    \
    \        max = count\n            result[i] = v\n         end\n      end\n   end\n\
    \   return result[1]\nend", "    local max_count = 0\n    local max_word = \"\"\
    \n    for _, word in pairs(words) do\n        local count = 0\n        for _,\
    \ _ in pairs(word) do\n            count = count + 1\n        end\n        if\
    \ count > max_count then\n            max_count = count\n            max_word\
    \ = word\n        end\n    end\n    return max_word\nend", "    -- write your\
    \ code in Lua 5.2 here\n    -- your code is here\n    local unique_char_count\
    \ = {}\n    for i=1,#words,1 do\n        unique_char_count = unique_char_count\
    \ or {}\n        for j,word in pairs(words) do\n            unique_char_count[word]\
    \ = unique_char_count[word] or 0\n            unique_char_count[word] = unique_char_count[word]\
    \ + #words[i]\n        end\n    end\n    return table.max( pairs(unique_char_count),\
    \ \n                      function (a,b) return a:n>b:n and 1 or -1 end)\nend",
  "  -- Write your solution here\n  return \"\"\nend", "   local max = \"\"\n   local\
    \ max_count = 0", "  if words == nil then return \"\" end\n  local maxNums = {}\n\
    \  for i, word in ipairs(words) do\n    if maxNums[word] == nil then\n      maxNums[word]\
    \ = { counter = 1 }\n    elseif maxNums[word].counter == 1 then\n      maxNums[word].counter\
    \ = maxNums[word].counter + 1\n    else\n      maxNums[word].counter = maxNums[word].counter\
    \ + 1\n      if maxNums[word].counter > 1 then\n        maxNums[word].word = word\n\
    \      end\n    end\n  end\n  local maxWord = \"\"\n  for word in pairs(maxNums)\
    \ do\n    if maxNums[word].counter == 1 then\n      maxWord = word\n    end\n\
    \  end\n  return maxWord\nend", "  -- Your code here\n  -- ==============================================================\n\
    \  -- return \"\"\n  -- ==============================================================\n\
    end", "    local max_words = nil\n    local max_unique = 0\n    local i = 1\n\
    \    local word_length = #words[1]\n    -- Iterate over every word in the list\n\
    \    while i <= word_length do\n        local unique = 0\n        -- Iterate over\
    \ every word\n        for w in words do\n            -- If word has same number\
    \ of unique characters\n            if w[i] == words[i] then\n               \
    \ -- Increase the unique character counter\n                unique = unique +\
    \ 1\n            end\n        end\n        -- If the unique character counter\
    \ has reached the maximum unique\n        -- character number, save the current\
    \ word\n        if unique > max_unique then\n            max_unique = unique\n\
    \            max_words = words[i]\n        end\n        i = i + 1\n    end\n \
    \   return max_words\nend\nprint(find_max([\"name\", \"of\", \"string\"]))\nprint(find_max([\"\
    name\", \"enam\", \"game\"]))\nprint(find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]))\n\
    print(find_max([]))\nprint(find_max({\"aaa\", \"bbb\"}))\nprint(find_max({\"aaaaaaa\"\
    , \"bbb\", \"cc\", \"d\"}))\n</cell>\n<text>\nWrite a function that accepts a\
    \ list. The list contains integers. If a list contains the same integer more than\
    \ once, return an error message.\nIf the list contains no duplicates, return an\
    \ error message.\nfind_max([\"a\", 2, 3, 1, 4, 7, 4]) ==> \"You have repeated\
    \ an element\"\nfind_max([\"a\", 2, 3, 1, 4, 7, 5, \"b\"]) ==> \"You haven't repeated\
    \ an element\"\nfind_max([\"a\", 2, 3, 1, 4, 7, 5]) ==> \"No repeated elements\"\
    \nfind_max([\"a\", 2, 3, 1, 4, 7, 5, \"b\", 6]) ==> \"No repeated elements\"",
  "  if words == nil then return nil end\n  local max_count = words[1][1]\n  local\
    \ max_word = words[1][2]\n  local i = 1\n  while i <= #words do\n    local count\
    \ = words[i][2]\n    if count > max_count then\n      max_count = count\n    \
    \  max_word = words[i][3]\n    end\n    i = i + 1\n  end\n  return max_word\n\
    end", "   local max_count = -1\n   local max_word = \"\"\n   for _, word in ipairs(words)\
    \ do\n      if #word > max_count then\n         max_count = #word\n         max_word\
    \ = word\n      end\n   end\n   return max_word\nend", "  -- Your code goes here\n\
    \  -- print(words);\n  local max_len = words[1];\n  local max_word = \"\";\n \
    \ for i = 2, #words do\n    local tmp_len = words[i]:len();\n    if tmp_len >\
    \ max_len then\n      max_len = tmp_len;\n      max_word = words[i];\n    end\n\
    \  end\n  return max_word;\nend", "    local max_key = nil\n    local max_count\
    \ = 0\n    for _, v in pairs(words) do\n        local count = 0\n        for k,\
    \ v in pairs(words) do\n            count = count + #v\n        end\n        if\
    \ count > max_count then\n            max_count = count\n            max_key =\
    \ v\n        end\n    end\n    return max_key\nend", "  local max_string = \"\"\
    \n  local max_chars = 0 -- number of unique characters\n  local max_count = 0\
    \ -- number of strings\n  local max_idx = 0 -- the index of the string with maximum\
    \ number of unique characters\n  for idx, word in ipairs(words) do\n    local\
    \ num_chars = #word\n    if num_chars > max_chars then\n      max_chars = num_chars\n\
    \      max_string = word\n      max_count = idx\n      max_idx = idx\n    end\n\
    \  end\n  if max_count == 1 then\n    return max_string\n  end\n  local next_idx\
    \ = max_idx\n  local next_chars = max_chars\n  local max_string = \"\"\n  while\
    \ next_idx <= #words and next_chars == max_chars do\n    local idx = next_idx\n\
    \    local chars = next_chars\n    local word = words[idx]\n    local num_chars\
    \ = #word\n    if num_chars > max_chars then\n      max_chars = num_chars\n  \
    \    max_string = word\n      max_count = idx\n    end\n    next_idx = idx + 1\n\
    \    next_chars = chars\n  end\n  return max_string\nend", "  assert(words and\
    \ #words > 0)\n  local max_char = nil\n  local max_len = nil\n  for _, v in ipairs(words)\
    \ do\n    if v ~= nil then\n      local c, l = #v, v:len()\n      if max_char\
    \ == nil or\n\t c > max_char or\n\t l > max_len\n      then\n        max_char\
    \ = c\n        max_len = l\n      end\n    end\n  end\n  return max_char .. string.rep(\"\
    *\", max_len)\nend", "  local result = {}\n  local max_count = 0\n  local max_key\n\
    \  for _, key in ipairs(words) do\n    local count = 0\n    for _, v in pairs(result)\
    \ do\n      if v == key then\n        count = count + 1\n      end\n    end\n\
    \    if count > max_count then\n      max_count = count\n      max_key = key\n\
    \    end\n  end\n  if max_count == 0 then\n    return nil\n  end\n  return max_key\n\
    end", "  local max = \"\"\n  local max_count = 0\n  local max_word\n  for i, word\
    \ in ipairs(words) do\n    local tmp_count = 0\n    for _, char in ipairs(word)\
    \ do\n      if tmp_count == max_count then\n        max_word = word\n        break\n\
    \      end\n      tmp_count = tmp_count + 1\n    end\n    max_count = max_count\
    \ + 1\n    if tmp_count > max_count then\n      max = word\n      max_count =\
    \ tmp_count\n    end\n  end\n  return max_word\nend", "  local word = {}\n  --\
    \ Scan the words\n  for _, word in pairs(words) do\n    -- Count the number of\
    \ unique characters\n    local count = {}\n    for _, _ in pairs(word) do\n  \
    \    count[#count+1] = 1\n    end\n    -- Determine the maximum\n    local max\
    \ = 1\n    for key, value in pairs(count) do\n      if count > max then\n    \
    \    max = value\n      end\n    end\n    -- Return the word if there are multiple\
    \ max words\n    if count > 1 then\n      return word\n    end\n  end\n  return\
    \ nil\nend", "    local max = 0 -- Maximum number of unique characters for a word\n\
    \    local result = nil -- The word with maximum number of unique characters\n\
    \    for _, word in ipairs(words) do\n        if word:len() > max then\n     \
    \       max = word:len()\n            result = word\n        end\n    end\n  \
    \  return result\nend", "  local result = words[1]\n  for i = 2, #words do\n \
    \   local count = #result\n    for j = 1, #result do\n      if string.sub(result,\
    \ j, 1) == string.sub(words[i], 1, #words[i]) then\n        count = count + 1\n\
    \      end\n    end\n    if count > #result then\n      result = words[i]\n  \
    \  end\n  end\n  return result\nend", "  assert(words and #words > 0, \"invalid\
    \ word list\")\n  local max_count = -1\n  local max_word = nil\n  for _, word\
    \ in ipairs(words) do\n    local count, word = count_unique_letters(word)\n  \
    \  if count > max_count then\n      max_count, max_word = count, word\n    end\n\
    \  end\n  return max_word\nend", "    local count = 0\n    local max_char = nil\n\
    \    local max_str = nil\n    local max_count = nil\n    local max_index = nil\n\
    \    local str_index = 1\n    for _, word in ipairs(words) do\n        count =\
    \ #word\n        if count > max_count or #word > #max_char then\n            max_count\
    \ = count\n            max_char = word\n            max_str = max_char\n     \
    \       max_index = str_index\n        end\n        str_index = str_index + count\n\
    \    end\n    if #max_char == #max_count then\n        return max_str\n    end\n\
    \    local count = #max_char\n    if max_count == count then\n        return max_char\n\
    \    end\n    local index = max_index\n    while index > 1 do\n        local count_left\
    \ = max_count - count\n        local char = max_char:sub(1, max_index-1)\n   \
    \     if count_left > index then\n            count = count + 1\n            return\
    \ char\n        end\n        index = index - 1\n    end\n    return max_char\n\
    end", "  local max = {}\n  for _,v in pairs(words) do\n    local count = #v\n\
    \    if count > max[count] then\n      max[count] = v\n    end\n  end\n  if #max\
    \ > 0 then\n    return max[#max]\n  end\n  return \"\"\nend", "  local max = 0\n\
    \  local max_word = \"\"\n  for _, word in pairs(words) do\n    local count =\
    \ {}\n    for c in word:gmatch(\"[%w%p]+\") do\n      count[c] = count[c] + 1\
    \ or 1\n      if count[c] > max then\n        max = count[c]\n        max_word\
    \ = word\n      end\n    end\n  end\n  return max_word\nend", "   local maxCounts\
    \ = {}\n   local maxString = \"\"\n   for _, word in ipairs(words) do\n      local\
    \ count = #word\n      if maxCounts[count] == nil then\n         maxCounts[count]\
    \ = word\n      elseif count > #maxCounts[count] then\n         maxCounts[count]\
    \ = word\n      end\n   end\n   if #maxCounts == 0 then\n      return \"\"\n \
    \  end\n   for _, maxCount in ipairs(maxCounts) do\n      if maxString == \"\"\
    \ and #maxCount > 0 then\n         maxString = maxCount\n      elseif maxString\
    \ ~= \"\" then\n         if #maxCount > #maxString then\n            maxString\
    \ = maxCount\n         elseif #maxCount == #maxString then\n            if maxCounts[#maxString]\
    \ > maxCount then\n               maxString = maxCount\n            end\n    \
    \     end\n      end\n   end\n   return maxString\nend", "  local max_count =\
    \ 0\n  local max_word = \"\"", "    local max = { count = 0, val = nil }\n   \
    \ for _, w in pairs(words) do\n        for i = 1, #w do\n            local c =\
    \ w[i]\n            local cnt = 1\n            for j = 1, #w do\n            \
    \    if w[j] == c then\n                    cnt = cnt * 10 + #w\n            \
    \    end\n            end\n            if cnt > max.count then\n             \
    \   max.val = w\n                max.count = cnt\n            end\n        end\n\
    \    end\n    if max.count == 1 then\n        return max.val\n    elseif max.count\
    \ == 2 then\n        return max.val[1] .. max.val[2]\n    elseif max.count ==\
    \ 3 then\n        return max.val[1] .. max.val[2] .. max.val[3]\n    else\n  \
    \      return \"\"\n    end\nend", "    if not words then return nil end\n   \
    \ local maxChars = {}\n    for i = 1, #words do\n        local count = 0\n   \
    \     for j = 1, #words[i] do\n            count = count + #words[i][j]\n    \
    \    end\n        if count > maxChars[#maxChars] then\n            maxChars[#maxChars]\
    \ = count\n        end\n    end\n    local maxCount = #maxChars\n    local maxChar\
    \ = maxChars[#maxChars]\n    for i = 1, #words do\n        local count = 0\n \
    \       for j = 1, #words[i] do\n            if #words[i][j] == maxChar then\n\
    \                count = count + 1\n            end\n        end\n        if count\
    \ > maxCount then\n            maxChar = words[i][#words[i]]\n            maxCount\
    \ = count\n        end\n    end\n    return maxChar\nend", "    local hash = {}\n\
    \    local max = 0\n    local word = \"\"", "  -- Find the length of the longest\
    \ word\n  local max_len = -1\n  for _, word in pairs(words) do\n    if max_len\
    \ == -1 or #word > max_len then\n      max_len = #word\n    end\n  end\n  -- Initialize\
    \ a table to store the number of unique characters in words\n  local unique =\
    \ {}\n  -- Initialize a table to store all the words\n  local words = {}\n  for\
    \ _, word in pairs(words) do\n    table.insert(words, word)\n    -- Insert an\
    \ empty element to represent each character in each word\n    table.insert(unique,\
    \ {})\n    for _, c in pairs(word) do\n      table.insert(unique[c], 0)\n    end\n\
    \  end\n  -- Iterate through the words and update the counts\n  for _, word in\
    \ pairs(words) do\n    for _, c in pairs(word) do\n      unique[c] = unique[c]\
    \ + 1\n    end\n  end\n  -- Find the word with maximum number of unique characters\n\
    \  local max_c = -1\n  local max_word = \"\"\n  for c, count in pairs(unique)\
    \ do\n    if count > max_c then\n      max_c = count\n      max_word = words[c]\n\
    \    end\n  end\n  -- Return the string with the maximum number of unique characters\n\
    \  return max_word\nend", "  local num_unique = 0\n  local words_with_unique =\
    \ {}\n  for _, word in pairs(words) do\n    words_with_unique[word] = words_with_unique[word]\
    \ or 1\n    num_unique = num_unique + #word\n  end\n  for key, val in pairs(words_with_unique)\
    \ do\n    if val > num_unique then\n      return key\n    end\n  end\nend", " \
    \ local max = {}\n  local count = {}", "   local max_len = 0\n   local best_word\
    \ = \"\"\n   for _, word in ipairs(words) do\n      if #word > max_len then\n\
    \         max_len = #word\n         best_word = word\n      end\n   end\n   return\
    \ best_word\nend", "    local max_count = nil\n    local max_word = nil\n    for\
    \ _, word in ipairs(words) do\n        local count = 0\n        for _, char in\
    \ pairs(word) do\n            count = count + 1\n        end\n        if max_count\
    \ == nil or count > max_count then\n            max_count = count\n          \
    \  max_word = word\n        end\n    end\n    return max_word\nend", "  local\
    \ count = 0\n  local max = nil\n  local index = 1\n  for _, word in pairs(words)\
    \ do\n    count = #word\n    if count > 0 then\n      if max and count > max then\n\
    \        index = count - 1\n      end\n      max = count \n    end\n  end\n  return\
    \ words[index]\nend", "   local result = {}\n   local max_count = 0\n   local\
    \ max_string = nil\n   for i = 1, #words do\n      local count = table.remove_by_ref(result,\
    \ words[i])\n      if count > max_count then\n         max_count = count\n   \
    \      max_string = words[i]\n      end\n      table.insert(result, words[i])\n\
    \   end\n   return max_string\nend", "  -- Write your code here.\n  local unique_characters\
    \ = {}\n  for i = 1, #words do\n    unique_characters[i] = 0\n  end", "\t-- write\
    \ your code here\n\tlocal max = nil\n\tlocal max_count = 1\n\tlocal max_word_length\
    \ = nil\n\tfor _, w in ipairs(words) do\n\t\tlocal unique_chars = {}\n\t\tfor\
    \ c in w do\n\t\t\tif c in unique_chars then\n\t\t\t\tunique_chars[c] = unique_chars[c]\
    \ + 1\n\t\t\t\tif unique_chars[c] > max_count then\n\t\t\t\t\tmax_count = unique_chars[c]\n\
    \t\t\t\t\tmax = w\n\t\t\t\t\tmax_word_length = #w\n\t\t\t\tend\n\t\t\telse\n\t\
    \t\t\tunique_chars[c] = 1\n\t\t\tend\n\t\tend\n\tend\n\treturn max or \"\"\nend",
  "  local maxword = \"\";\n  local maxcount = -2;\n  for _,v in pairs(words) do\n\
    \    local counts = countStrings(v);\n    local word = \"\";\n    for k,v in pairs(counts)\
    \ do\n      if v > maxcount then\n        maxcount = v;\n        word = k;\n \
    \     end\n    end\n    if maxcount > 0 then\n      maxword=word;\n    end\n \
    \ end\n  if maxcount > 0 then\n    return maxword;\n  else\n    return \"\";\n\
    \  end\nend", "  local max_char = words[1][1]\n  for _, word in pairs(words) do\n\
    \    for _, c in ipairs(word) do\n      if c > max_char then\n        max_char\
    \ = c\n      end\n    end\n  end\n  if max_char == \"\" then\n    return \"\"\n\
    \  end\n  -- If we have multiple words, return the word with smallest length\n\
    \  local min_len = nil\n  for _, word in pairs(words) do\n    if min_len == nil\
    \ or #word < min_len then\n      min_len = #word\n    end\n  end\n  if min_len\
    \ == nil then\n    return \"\"\n  end\n  for _, word in pairs(words) do\n    local\
    \ count = #word\n    if count == min_len then\n      return word\n    end\n  end\n\
    \  -- If all words have same number of unique characters, return the first one\n\
    \  -- with lexicographical order\n  for _, word in pairs(words) do\n    local\
    \ count = 0\n    for _, c in ipairs(word) do\n      count = count + c\n    end\n\
    \    if count == min_len then\n      return word\n    end\n  end\n  return \"\"\
    \nend", "  local charmap = {}\n  for _, w in ipairs(words) do\n    charmap[#charmap+1]\
    \ = w\n  end\n  local maxw\n  for i=1,#charmap do\n    if charmap[i] then\n  \
    \    if maxw and charmap[maxw] >= charmap[i] then\n        maxw = i\n      else\n\
    \        maxw = i\n      end\n    end\n  end\n  if maxw then\n    return charmap[maxw]\n\
    \  end\nend", "    if not words or #words == 0 then\n        return \"\"\n   \
    \ end\n    local max = {}\n    for _, word in pairs(words) do\n        local count\
    \ = table.count(max)\n        if count == 0 or count > #word then\n          \
    \  max[#max+1] = word\n        else\n            local pos = 1\n            for\
    \ i = 1, #word do\n                if max[pos] ~= word[i] then\n             \
    \       max[#max+1] = word\n                    pos = 1\n                    break\n\
    \                else\n                    pos = pos + 1\n                end\n\
    \            end\n        end\n    end\n    return max[1]\nend", "  local max_length\
    \ = 0\n  local max_word = words[1]\n  for i = 2, #words do\n    local len = #words[i]\n\
    \    if len > max_length then\n      max_length = len\n      max_word = words[i]\n\
    \    end\n  end\n  if max_length == 0 then\n    return \"\"\n  end\n  local max_len\
    \ = 1\n  for i = 2, #words do\n    if #words[i] > max_len then\n      max_len\
    \ = #words[i]\n    end\n  end\n  if max_len == 1 then\n    return max_word\n \
    \ end\n  local result = {}\n  for i = 1, max_len do\n    for j = 1, #words do\n\
    \      local len = 1\n      for k = 1, #words[j] do\n        if words[j][k] ==\
    \ words[i][k] then\n          len = len + 1\n        end\n      end\n      if\
    \ len > max_len then\n        result.insert(words[j])\n      end\n    end\n  end\n\
    \  if #result == 0 then\n    return \"\"\n  end\n  table.sort(result)\n  return\
    \ result[1]\nend", "  if words[1] then\n    local max = 0\n    for _, word in\
    \ pairs(words) do\n      local count = word:gsub(\"[^\" .. table.concat(\n   \
    \     string.gmatch(string.gsub(\"[^\" .. table.concat(words, \"\", 1), \"[%w]\"\
    ), \"(%..%)\")) .. \"]\", \"\")\n      if count > max then\n        max = count\n\
    \        word = nil\n      end\n    end\n    if max then\n      local pos = 1\n\
    \      for pos, word in pairs(words) do\n        if word == nil then\n       \
    \   words[pos] = \"\"\n        end\n      end\n      words[1] = words[1] .. max\
    \ .. words[1]:sub(1, #words[1])\n    end\n  end\n  -- if #words == 0 then return\
    \ nil end\n  return words[1]\nend", "\tlocal max = {count = 1, index = -1}\n\t\
    for i = 1, #words do\n\t\tif max.count > #words[i] then\n\t\t\tmax = { count =\
    \ #words[i], index = i }\n\t\tend\n\tend\n\tif max.count == 0 then\n\t\treturn\
    \ \"\"\n\tend\n\tfor i = max.index, 1, -1 do\n\t\twords[#words + i] = \"\"\n\t\
    end\n\treturn words[max.index]\nend", "    local maxChars = {}\n    local maxWord\
    \ = {}", "   local count = {}\n   for i, word in ipairs(words) do\n      if not\
    \ count[word] then\n         count[word] = true\n         table.insert(words,\
    \ word);\n      else\n         count[word] = count[word] + 1\n      end\n   end\n\
    \   table.sort(words);\n   return words[#words];\nend", "\tlocal max = nil\n\t\
    local max_count = nil\n\tlocal max_value = nil\n\tlocal max_index = nil\n\tfor\
    \ idx, word in ipairs(words) do\n\t\tlocal count = 0\n\t\tfor c in word do count\
    \ = count + 1 end\n\t\tif max and max ~= word and count > max_count then\n\t\t\
    \tmax_count = count\n\t\t\tmax_value = word\n\t\t\tmax_index = idx\n\t\telseif\
    \ count > max_count then\n\t\t\tmax_count = count\n\t\t\tmax_value = word\n\t\t\
    \tmax_index = idx\n\t\tend\n\tend\n\treturn max_value\nend", "  local max = 0\
    \ -- The word with the maximum number of unique characters.\n  for _, word in\
    \ ipairs(words) do\n    for _, character in ipairs(word) do\n      -- Increment\
    \ `max` if we encounter the same character in a word.\n      if max == 0 and character\
    \ == words[#words][1] then\n        max = 1 + #words[#words][2]\n      end\n \
    \   end\n  end\n  return max > 0 and words[#words][1] or \"\"\nend", "   local\
    \ maxcount = 0\n   local maxword = \"\"\n   for _, word in ipairs(words) do\n\
    \      if #word > maxcount then\n         maxcount = #word\n         maxword =\
    \ word\n      end\n   end\n   return maxword\nend", "  if #words == 0 then\n \
    \   return nil\n  end\n  local word = words[math.random(1, #words)]\n  local result\
    \ = {}\n  local counts = {}\n  for _, word in pairs(words) do\n    counts[word]\
    \ = counts[word] or 0\n    counts[word] = counts[word] + 1\n    if counts[word]\
    \ == #words then\n      table.insert(result, word)\n    end\n  end\n  if #result>1\
    \ then\n    return find_max(result)\n  end\n  return result[1]\nend", "  local\
    \ max = {}\n  local count = 0\n  for i=1, #words do\n    count = count + 1\n \
    \   if max and count > max[1] then\n      max[1] = count\n      max[2] = words[i]\n\
    \    end\n  end\n  return max[2] or \"\"\nend", "  if #words <= 1 then\n    return\
    \ \"\"\n  else\n    local max_len = 1\n    local max_word = words[1]\n    for\
    \ i = 2, #words do\n      local num_unique = #max_word\n      for j = 1, #max_word\
    \ do\n        if string.sub(max_word,j,j) ~= string.sub(words[i],1,1) then\n \
    \         num_unique = num_unique - 1\n        end\n      end\n      if num_unique\
    \ > max_len then\n        max_len = num_unique\n        max_word = words[i]\n\
    \      end\n    end\n    return max_word\n  end\nend", "    if #words == 0 then\
    \ return \"\" end\n    local letters = {}\n    local max_count = 0\n    local\
    \ max_index = nil\n    for index, word in ipairs(words) do\n        local count\
    \ = 0\n        for c in string.gsub(word, '%W') do\n            count = count\
    \ + #letters[c]\n            table.insert(letters[c], word);\n        end\n  \
    \      if count > max_count then\n            max_count = count\n            max_index\
    \ = index\n        end\n    end\n    if max_count == 0 then\n        return \"\
    \"\n    end\n    return letters[max_index][max_count]\nend", "  local max_num\
    \ = 0\n  local max_char = \"\"\n  for _, word in ipairs(words) do\n    local char_num\
    \ = word:gsub(\"[^\" .. string.char(#string.ascii_lowercase) .. \"]\", \"\")\n\
    \    if char_num > max_num then\n      max_num = char_num\n      max_char = word\n\
    \    end\n  end\n  return max_char\nend", "  local count = {}\n  \n  for _, word\
    \ in pairs(words) do\n    count[#count + 1] = nil\n  end\n  \n  for _, word in\
    \ pairs(words) do\n    local letters = {}\n    for letter in word:gmatch(\"[%z]+\"\
    ) do\n      table.insert(letters, letter)\n    end\n    \n    for _, letter in\
    \ pairs(letters) do\n      count[letter] = count[letter] + 1 \n    end\n  end",
  "  local max_counts = {}\n  local max_word = nil\n  for _, word in ipairs(words)\
    \ do\n    if not max_counts[#max_counts] then max_counts[#max_counts] = 0\n  \
    \    max_counts[#max_counts] = 1 -- We will increment the count of characters\n\
    \    else max_counts[#max_counts]=max_counts[#max_counts]+1\n    end\n    if max_counts[#max_counts]\
    \ >= #word then -- We will increment the count of words\n      max_word = word\n\
    \    end\n  end\n  return max_word\nend", "  if words == nil then\n    return\
    \ nil\n  end", "  local max_count = 0\n  local max_word = \"\"\n  local word =\
    \ words[1]\n  for _, word in ipairs(words) do\n    count = #word\n    if max_count\
    \ < count then\n      max_count = count\n      max_word = word\n    end\n  end\n\
    \  return max_word\nend", "  local max = {words[1]}\n  for _, word in pairs(words)\
    \ do\n    local chars = #word\n    if #max < chars then\n      max = word\n  \
    \  end\n  end\n  return max\nend", "    local maxlen = 0\n    local max_word =\
    \ \"\"\n    local num_words = #words\n    for idx = 1, num_words do\n        local\
    \ maxcount = 0\n        local maxchar = words[idx]\n        for i = 1, #words\
    \ do\n            if words[i]:sub(1, #maxchar) == maxchar then\n             \
    \   if maxcount < #words[i] then maxcount = #words[i] end\n            end\n \
    \       end\n        if maxcount > maxlen then\n            maxlen = maxcount\n\
    \            max_word = words[idx]\n        end\n    end\n    return max_word\n\
    end", "  if #words ~= 1 then\n    return \"\"\n  end", "   local result = \"\"\
    \n   local maxNumber = 0\n   for _, word in pairs(words) do\n      if #word >\
    \ maxNumber then\n         maxNumber = #word\n         result = word\n      end\n\
    \   end\n   return result\nend", "  local max_num = 0\n  local max_word = \"\"\
    \n  for _, word in ipairs(words) do\n    local unique_num = 0\n    for _, c in\
    \ pairs(word) do\n      if word:sub(c, 1, c) ~= word then\n        unique_num\
    \ = unique_num + 1\n      end\n    end\n    if unique_num > max_num then\n   \
    \   max_num = unique_num\n      max_word = word\n    end\n  end\n  return max_word\n\
    end", "  local max = {}\n  for i = 1, #words do\n    if not max[#max + 1] then\n\
    \      max[#max] = {}\n    end\n    local uniques = {}\n    local maxlen = 0\n\
    \    for j = 1, #words[i] do\n      if uniques[words[i][j]] then\n        uniques[words[i][j]]\
    \ = uniques[words[i][j]] + 1\n      else\n        uniques[words[i][j]] = 1\n \
    \     end\n      if uniques[words[i][j]] > maxlen then\n        maxlen = uniques[words[i][j]]\n\
    \        max[#max + 1] = words[i]\n      end\n    end\n  end\n  if #max == 1 then\n\
    \    return max[1]\n  else\n    return max[1]\n  end\nend", "  local result =\
    \ {}\n  local counts = {}\n  for _, word in ipairs(words) do\n    table.insert(result,\
    \ word)\n    local count = counts[word]\n    if not count then\n      count =\
    \ 1\n    else\n      count = count + 1\n    end\n    counts[word] = count\n  end\n\
    \  table.sort(result, function(word1, word2)\n    local count1 = counts[word1]\n\
    \    local count2 = counts[word2]\n    if count1 > count2 then\n      return 1\n\
    \    elseif count1 < count2 then\n      return -1\n    else\n      return 0\n\
    \    end\n  end)\n  return result[1]\nend", "  return words[1]\nend", "    local\
    \ unique_chars = {}\n    local num_unique_chars = 0\n    for _, word in pairs(words)\
    \ do\n        unique_chars = unique_chars + word:gsub(\"[^\" .. string.char(#string.whitespace)\
    \ .. \"]\", \"\")\n        num_unique_chars = num_unique_chars + #word\n    end\n\
    \    local unique_chars_count = #unique_chars\n    local max_num_unique_chars\
    \ = unique_chars_count\n    local max_word = \"\"\n    for _, word in pairs(words)\
    \ do\n        local unique_chars_count_word = #word\n        if max_num_unique_chars\
    \ < unique_chars_count_word then\n            max_num_unique_chars = unique_chars_count_word\n\
    \            max_word = word\n        end\n    end\n    return max_word\nend",
  "  local alphabet = {}\n  for i = 1, #words do\n    table.insert(alphabet, words[i])\n\
    \  end\n  table.sort(alphabet)\n  local max_count = 0\n  local max_word = \"\"\
    \n  for i = 1, #words do\n    if alphabet[i] == words[i] then\n      table.insert(alphabet,\
    \ words[i])\n      count = count + 1\n      if count > max_count then\n      \
    \  max_count = count\n        max_word = words[i]\n      end\n    end\n  end\n\
    \  return max_word\nend", "    -- write your code in Rust, using only standard\
    \ library\n    -- imports and standard library functions. \n    -- You do not\
    \ need to define a new function in Python, \n    -- you may use Python lists and\
    \ dictionary instead.\n    -- Python code (with only standard library)\n    --\
    \ max_word = max(set(words), key = words.count) \n    -- Rust code (with standard\
    \ library)\n    max_word = words[#words] \n    for i=2, #words do\n        if\
    \ words[i-1] == words[i] then\n            max_word = words[i]\n        end\n\
    \    end\n    return max_word\nend\nassert(find_max([\"name\", \"enam\", \"game\"\
    ]) == \"enam\")\nassert(find_max([\"name\", \"enam\", \"game\"]) == \"name\")\n\
    assert(find_max([\"name\", \"enam\", \"game\"]) == \"game\")\nassert(find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\")\nassert(find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\", \"a\"]) == \"a\")\nassert(find_max([\"aaaaaaa\", \"bb\" ,\"cc\", \"a\"])\
    \ == \"\")\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is definitely a good solution\
    \ (which was probably not an option for OP, though). The only thing I'm wondering\
    \ is whether a solution using only standard library could be considered pythonic\
    \ enough to warrant reposting it.\n<|/ c |>\n<| a dscore=2 |>\nTo expand on Alex's\
    \ answer, the standard library has a set of functions that operate on sequences.\
    \ Those are:", "  local maxChar = \"\"\n  local maxNum = 0\n  \n  for i = 1, #words\
    \ do\n    local char = words[i][1]\n    local num = 1\n    for j = i + 1, #words\
    \ do\n      local char1 = words[j][1]\n      if char == char1 then\n        num\
    \ = num + 1\n      end\n    end\n    \n    if num > maxNum then\n      maxNum\
    \ = num\n      maxChar = char\n    end\n  end\n  return maxChar\nend", "  -- Write\
    \ your code here.\n  local map = {}\n  for _, w in pairs(words) do\n    local\
    \ key = string.join(string.gsub(w, \"[^\"..string.char(97, 122, 123, 124, 125,\
    \ 127, 129, 130, 131)..\"]\", \"\"))\n    if map[key] then\n      map[key] = map[key]\
    \ + 1\n    else\n      map[key] = 1\n    end\n  end\n  local i, max = 1, map[1]\n\
    \  local j\n  for _, v in pairs(map) do\n    if v > max then\n      max = v\n\
    \      i = j\n    end\n    j = i\n  end\n  return words[i]\nend", "    local max\
    \ = 0\n    local first = \"\"\n    for word in words do\n        local count =\
    \ 0\n        for char in word do count = count + 1 end\n        if count > max\
    \ then\n            max = count\n            first = word\n        end\n    end\n\
    \    if max ~= 0 then\n        first = first .. string.sub( word, string.len(first)\
    \ - max, string.len(first) )\n    end\n    return first\nend", "\tlocal max =\
    \ {}\n\tfor i, word in ipairs(words) do\n\t\tlocal count = #word\n\t\tif count\
    \ > max[i] then max[i] = count end\n\tend\n\treturn words[math.min(#words, #max)+1]\n\
    end", "    local max = 1\n    local value = nil\n    for i = 1, #words - 1 do\n\
    \        local current_value = string.len(words[i])\n        if #words[i][current_value]\
    \ >= max then\n            value = words[i]\n            max = current_value\n\
    \        end\n    end\n    return value\nend", "  local max_num_unique = 0\n \
    \ local index = {}\n  for _, word in ipairs(words) do\n    local num_unique =\
    \ #word\n    if num_unique > max_num_unique then\n      max_num_unique = num_unique\n\
    \      index = { word }\n    end\n  end\n  if #index == 1 then\n    return index[1]\n\
    \  end\n  -- Now sort the words in index based on lexicographical order\n  local\
    \ sorted_index = sort(index)\n  -- Now compare the words in index which are not\
    \ sorted with each other\n  -- If two words have same number of unique characters,\
    \ return the first one\n  -- which comes first in lexicographical order\n  for\
    \ _, index_word in ipairs(sorted_index) do\n    for _, word in ipairs(sorted_index)\
    \ do\n      if word ~= index_word then\n        local num_unique = #index_word\n\
    \        if num_unique == max_num_unique then\n          -- If the number of unique\
    \ characters of index_word is equal\n          -- to max_num_unique, return index_word\n\
    \          return index_word\n        else\n          -- If the number of unique\
    \ characters of index_word is not equal\n          -- to max_num_unique, return\
    \ word\n          return word\n        end\n      end\n    end\n  end\n  return\
    \ \"\"\nend", "   local unique_chars = {}\n   local max_count = 1\n   local max_word\
    \ = nil\n   for _, v in pairs(words) do\n      if type(unique_chars[v]) == 'number'\
    \ then\n         unique_chars[v] = unique_chars[v] + 1\n      else\n         unique_chars[v]\
    \ = 1\n      end\n      if unique_chars[v] > max_count then\n         max_count\
    \ = unique_chars[v]\n         max_word = v\n      end\n   end\n   if max_count\
    \ > 1 then\n      return max_word\n   else\n      return \"\"\n   end\nend", " \
    \ local num_chars = 0\n  local result = nil\n  for i = 1, #words do\n    local\
    \ num_unique = 0\n    for j = 1, #words[i] do\n      num_unique = num_unique +\
    \ words[i][j]\n    end\n    if num_unique > num_chars then\n      num_chars =\
    \ num_unique\n      result = words[i]\n    end\n  end\n  return result\nend",
  "  return words[#words]\nend", "  local word = words[1]\n  local max = 0\n  \n \
    \ for i = 2, #words do\n    if word:len() > max then\n      word = words[i]\n\
    \      max = word:len()\n    end\n  end\n  \n  return word\nend", "  local max_len\
    \ = 0\n  local min_len = #words\n  local min_idx", "  -- write your code in Lua\
    \ here\nend", "  local max = 0\n  local word = \"\"\n  for _, word in ipairs(words)\
    \ do\n    local unique, count = unique_characters(word)\n    if count > max then\n\
    \      max = count\n      word = word\n    end\n  end\n  return word\nend\n</cell>\n\
    <cell>", "  local unique = {}\n  local max_index = #words - 1\n  \n  for i, word\
    \ in ipairs(words) do\n    table.insert(unique, #word + 1)\n  end", "  assert(words)\n\
    \  local max = {}\n  local maxlen = 0\n  for _, word in ipairs(words) do\n   \
    \ if max[word] == nil then\n      max[word] = nil\n      maxlen = 1\n    else\n\
    \      local len = #word\n      if len > maxlen then\n        max[word] = nil\n\
    \        maxlen = len\n      else\n        local num = 1\n        for i = 1, len\
    \ do\n          if words[i] ~= words[len-i] then\n            num = num + 1\n\
    \          end\n        end\n        if num > maxlen then\n          max[word]\
    \ = words[#words]\n          maxlen = num\n        end\n      end\n    end\n \
    \ end\n  if maxlen > 0 then\n    return unpack(max, 1, maxlen)\n  end\n  return\
    \ \"\"\nend", "  local result={}\n  for _, word in ipairs(words) do\n    local\
    \ max=#word\n    for _, c in ipairs(word) do\n      max=max-1\n      if max==0\
    \ then break end\n      if word[max] ~= c then break end\n    end\n    if max\
    \ ~= #word then result=words[#word] end\n  end\n  if #result>1 then return result[#result+1]\
    \ end\n  return result\nend", "\tlocal word = {}\n\tfor _,v in pairs(words) do\n\
    \t\tfor _,c in pairs(v) do\n\t\t\tif word[c] == nil then\n\t\t\t\tword[c] = 0\n\
    \t\t\tend\n\t\t\tword[c] = word[c] + 1\n\t\tend\n\tend\n\ttable.sort(words, function(a,\
    \ b) return word[b] > word[a] end)\n\tlocal max_char = words[#words][1]\n\tlocal\
    \ max_count = 0\n\tfor _,v in pairs(words) do\n\t\tfor _,c in pairs(v) do\n\t\t\
    \tif c == max_char then\n\t\t\t\tmax_count = max_count + 1\n\t\t\tend\n\t\tend\n\
    \tend\n\tif max_count == 1 then\n\t\treturn words[#words][1]\n\telse\n\t\treturn\
    \ \"\"\n\tend\nend", "\tlocal maxCount = 1; local maxWord = \"\"; local wordCount\
    \ = 0;\n\tfor i, word in ipairs(words) do\n\t\twordCount = 1;\n\t\tfor j=1, #word\
    \ do\n\t\t\tif word[j] == word[j] then wordCount = wordCount + 1 end\n\t\tend\n\
    \t\tif wordCount > maxCount then\n\t\t\tmaxCount = wordCount;\n\t\t\tmaxWord =\
    \ word;\n\t\tend\n\tend\n\tif maxCount > 1 then\n\t\treturn maxWord;\n\telse\n\
    \t\treturn \"\";\n\tend\nend", "\tlocal n = #words\n\tlocal max = 0\n\tlocal max_word\
    \ = \"\"\n\t\n\tfor i = 1, n do\n\t\tif words[i] ~= \"\" then\n\t\t\tlocal count\
    \ = count_unique(words[i])\n\t\t\tif count > max then\n\t\t\t\tmax = count\n\t\
    \t\t\tmax_word = words[i]\n\t\t\tend\n\t\tend\n\tend\n\t\n\tif max == 0 then\n\
    \t\treturn \"\"\n\telseif max == 1 then\n\t\treturn max_word\n\telse\n\t\treturn\
    \ find_max(words[1..n])\n\tend\nend", "  local word = {}\n  local max = {}\n \
    \ for i = 1, #words do\n    local temp = {}\n    for j = 1, #words[i] do\n   \
    \   temp[j] = words[i][j] or 0\n    end\n    table.insert(max, unpack(temp))\n\
    \  end", "    -- Write your function here\n    local max_count = 1\n    local\
    \ max_word = \"\"\n    for i = 1, #words do\n        local count = 0\n       \
    \ for j = 1, #words[i] do\n            count = count + 1\n        end\n      \
    \  if count > max_count then\n            max_count = count\n            max_word\
    \ = words[i]\n        end\n    end\n    return max_word\nend", "  local max =\
    \ {}\n  for _, word in ipairs(words) do\n    local counts = {}\n    for _, c in\
    \ ipairs(word) do\n      counts[c] = counts[c] or 0\n      counts[c] = counts[c]\
    \ + 1\n    end\n    for k, v in pairs(counts) do\n      if v > max[#max] and v\
    \ ~= 0 then\n        max[#max] = v\n        local word = words[k]\n      end\n\
    \    end\n  end\n  for i=1,#max do\n    if max[i] == 0 then\n      return \"\"\
    \n    end\n  end\n  return words[1]\nend", "  local counts = {}\n  for _, word\
    \ in ipairs(words) do\n    counts[#counts + 1] = 1\n    for _, c in pairs(word)\
    \ do\n      counts[#counts + 1] = (counts[#counts + 1] or 0) + 1\n    end\n  end\n\
    \  local result = \"\"\n  for _, count in pairs(counts) do\n    if count > 1 then\n\
    \      if #result > 0 then\n        if counts[result] > counts[#result] then\n\
    \          result = #result\n        end\n      else\n        result = #result\n\
    \      end\n    end\n  end\n  if result ~= 0 then\n    return words[result]\n\
    \  end\nend", "   if #words == 0 then\n      return \"\"\n   end\n   local count\
    \ = {}\n   local maxValue = 0\n   local key\n   for _, key in pairs(words) do\n\
    \      count[key] = count[key] or 1\n      if count[key] > maxValue then\n   \
    \      maxValue = count[key]\n      end\n      count[key] = count[key] + 1\n \
    \  end\n   if maxValue > 1 then\n      for _, key in pairs(words) do\n       \
    \  if count[key] == maxValue then\n            return key\n         end\n    \
    \  end\n   end\n   return \"\"\nend", "  local max_word = \"\"\n  local max_count\
    \ = 0\n  for _, w in pairs(words) do\n    local count = 0\n    for _, c in pairs(w)\
    \ do\n      count = count + 1 -- Count number of unique characters in the word\n\
    \    end\n    if count > max_count then\n      max_count = count\n      max_word\
    \ = w\n    end\n  end\n  return max_word\nend", "  if #words < 2 then\n    return\
    \ \"\"\n  end\n  local word = {}\n  for i, v in pairs(words) do\n    if #word[v]\
    \ == 0 then\n      word[v] = 1\n    else\n      word[v] = word[v] + 1\n    end\n\
    \  end\n  local max_word = false\n  local max_count = 0\n  local max_count = 0\n\
    \  for k, v in pairs(word) do\n    if max_count < v then\n      max_count = v\n\
    \      max_word = k\n    end\n  end\n  if max_count == 0 then\n    max_word =\
    \ word[max_word]\n  end\n  return max_word\nend", "    local max_characters =\
    \ words[1].#\n    if #words == 2 then\n        if words[1] < words[2] then\n \
    \           return words[2]\n        else\n            return words[1]\n     \
    \   end\n    else\n        local last_char = words[#words].chars[#words[#words].chars]:byte()\n\
    \        return if last_char > max_characters then\n            find_max(words[1:])\n\
    \        else\n            return words[1]\n        end\n    end\nend", "  assert(type(words)\
    \ == \"table\", \"bad argument type\")\n  local max = 0 -- Maximum number of unique\
    \ characters\n  local min = 1 -- Minimum number of unique characters\n  for _,\
    \ word in ipairs(words) do\n    if #word > max then\n      max = #word\n    end\n\
    \    if #word < min then\n      min = #word\n    end\n  end\n  if max > 0 then\n\
    \    return words[min]\n  end\n  return \"\"\nend", "  local max_val = words[1]\n\
    \  for i = 2, #words do\n    local unique_char = words[i]\n    local count = 0\n\
    \    for j = 1, #max_val do\n      if max_val[j] == unique_char then\n       \
    \ count = count + 1\n      end\n    end\n    if count > #max_val then\n      max_val\
    \ = words[i]\n    end\n  end\n  return max_val\nend", "    local max_count = tonumber(words[1])\
    \ or 0\n    local word\n    local i = 1\n    for word in words[2] do\n       \
    \ if max_count < tonumber(word) then\n            max_count = tonumber(word)\n\
    \            i = 2\n        end\n    end\n    return words[1] .. words[i] or \"\
    \"\nend", "  local max_count = 0\n  local max_word = nil", "   if #words == 0\
    \ then return '' end\n   local maxChars = words[1]\n   for i = 2, #words do\n\
    \      if #words[i] >= #maxChars then\n         maxChars = words[i]\n      end\n\
    \   end\n   return maxChars\nend", "    local max_count = 0\n    local max_string\
    \ = words[1]\n    for i=2,#words,1 do\n        local count = 0\n        for word\
    \ in words do\n            count = count + 1\n            if word == words[i]\
    \ then\n                break\n            end\n        end\n        if count\
    \ > max_count then\n            max_count = count\n            max_string = words[i]\n\
    \        end\n    end\n    return max_string\nend", "  for i, word in pairs(words)\
    \ do\n    if find_max[word] then -- find word in dictionary\n      return word\n\
    \    end\n    find_max[word] = 0 -- create new word if not found\n  end\nend",
  "  local max_count = 0\n  local max_word = nil\n  local max_word_index", "  if #words\
    \ == 0 then\n    return \"\"\n  else\n    local max\n    local count = { }", " \
    \  local max = 0 \n   local word = \"\"\n   for _, w in ipairs(words) do\n   \
    \   if #w > max then\n         max = #w\n         word = w\n      elseif #w ==\
    \ max then\n         if word ~= w then\n            word = w .. words[#words]\n\
    \         end\n      end\n   end\n   return word\nend", "   local max_len = -1\n\
    \   local max_len_idx = nil\n   for idx, word in ipairs(words) do\n      if max_len\
    \ < #word then\n         max_len = #word\n         max_len_idx = idx\n      end\n\
    \   end\n   return words[max_len_idx]\nend", "  local max_characters = -1\n  local\
    \ max_word = words[1]\n  for i, word in pairs(words) do\n    local characters\
    \ = #word\n    if characters > max_characters then\n      max_characters = characters\n\
    \      max_word = word\n    end\n  end\n  return max_word\nend", "    if #words\
    \ == 0 then\n        return \"\"\n    end", "\tlocal max_key\n\tlocal max_val\
    \ = nil\n\tfor k, v in pairs(words) do\n\t\tlocal val = #v\n\t\tif val > 0 then\n\
    \t\t\tif val > max_val then\n\t\t\t\tmax_val = val\n\t\t\t\tmax_key = k\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn max_key\nend", "  local num_unique_chars = #{}\n\
    \  local max_chars = \"\"\n  local max_word = \"\"\n  for i = 1, #words do\n \
    \   local word = words[i]\n    local unique_chars = #{}\n    for j = 1, #word\
    \ do\n      table.insert(unique_chars, word[j])\n    end\n    if #unique_chars\
    \ > num_unique_chars then\n      num_unique_chars = #unique_chars\n      max_chars\
    \ = table.concat(unique_chars)\n      max_word = words[i]\n    end\n  end\n  return\
    \ max_word\nend", "  assert(#words > 0)\n  local index = 1\n  local count = 0\n\
    \  local max = \"\"\n  while index < #words do\n    local char = words[index]\n\
    \    count = count + 1\n    if count > #max then\n      max = char\n    end\n\
    \    index = index + 1\n  end\n  if count > #max then\n    return \"\"\n  end\n\
    \  return max\nend", "    local count = { }\n    for _, word in pairs(words) do\n\
    \        local char = word:byte()\n        if count[char] == nil then\n      \
    \      count[char] = 1\n        else\n            count[char] = count[char] +\
    \ 1\n        end\n    end\n    local max_char = nil\n    for char, count in pairs(count)\
    \ do\n        if count > count[max_char] then\n            max_char = char\n \
    \       end\n    end\n    return words[#words] or max_char\nend", "    -- write\
    \ your code in Lua 5.3\n    local max_dict = {}\n    local max_key = 0\n    local\
    \ max_word = \"\"", "  local maxCharCount = 0\n  local maxChar = \"\"\n  for _,\
    \ word in pairs(words) do\n    local charCount = #word\n    if charCount > maxCharCount\
    \ then\n      maxCharCount = charCount\n      maxChar = word\n    end\n  end\n\
    \  if maxCharCount > 1 then\n    return maxChar\n  else\n    local i = 0\n   \
    \ for _, word in pairs(words) do\n      if #word > i then\n        i = #word\n\
    \      end\n    end\n    return words[i]\n  end\nend", "  -- sort in order of\
    \ length\n  local sorted_words = table.sort(words)\n  -- remove duplicates\n \
    \ local unique_words = table.unique(sorted_words)\n  -- find the longest word\n\
    \  local longest_word = unique_words[1]\n  -- find the number of unique characters\
    \ in the longest word\n  local longest_word_length = string.len(longest_word)\n\
    \  -- initialize a new empty table to store the final result\n  local max_word_lengths\
    \ = {}\n  -- iterate through all the remaining words\n  for i = 2, #sorted_words\
    \ do\n    local word = sorted_words[i]\n    local word_length = string.len(word)\n\
    \    -- if current word length is greater than the longest word length\n    --\
    \ then update the longest word and length\n    if word_length > longest_word_length\
    \ then\n      longest_word = word\n      longest_word_length = word_length\n \
    \   end\n    -- if we have reached a word which has maximum number of unique chars\n\
    \    -- then update the length of that word\n    if word_length == longest_word_length\
    \ then\n      max_word_lengths[longest_word] = max_word_lengths[longest_word]\
    \ + 1\n    end\n  end\n  -- iterate through all the words and find the word with\
    \ maximum number of unique\n  -- chars\n  for word, char_count in pairs(max_word_lengths)\
    \ do\n    if char_count == #unique_words then\n      return word\n    end\n  end\n\
    \  return ''\nend", "  -- Base cases\n  if #words == 0 then\n    return ''\n \
    \ end\n  if #words == 1 then\n    return words[1]\n  end\n  if #words == 2 then\n\
    \    local first = words[1]\n    local second = words[2]\n    if first <= second\
    \ then\n      return words[1]\n    else\n      return words[2]\n    end\n  end\n\
    \  if #words == 3 then\n    local first = words[1]\n    local second = words[2]\n\
    \    local third = words[3]\n    if first <= second and second <= third then\n\
    \      return words[1]\n    elseif first <= second and second > third then\n \
    \     return words[2]\n    elseif first > second and second <= third then\n  \
    \    return words[3]\n    else\n      return ''\n    end\n  end", "    local maxCount\
    \ = 0\n    local maxWord = nil", "  local max_count = 0\n  local max_word = nil\n\
    \  for _, word in ipairs(words) do\n    if #word > max_count then\n      max_count\
    \ = #word\n      max_word = word\n    end\n  end\n  return max_word\nend", " \
    \ local counts = terralib.newlist()\n  for _, w in ipairs(words) do\n    for _\
    \ = 1, #w do\n      counts[#counts + 1] = w\n    end\n  end\n  local max_count\
    \ = -1\n  local max_word = \"\"\n  for _, w in ipairs(words) do\n    if counts[#counts\
    \ + 1] > max_count then\n      max_count = counts[#counts + 1]\n      max_word\
    \ = w\n    end\n  end\n  return max_word\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
