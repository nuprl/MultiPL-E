name: HumanEval_9_rolling_max
language: lua
prompt: "-- From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n-- in the sequence.\n-- >>> rolling_max([1, 2, 3, 2,\
  \ 3, 4, 2])\n-- [1, 2, 3, 3, 3, 4, 4]\nlocal function rolling_max(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rolling_max\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3,\
  \ 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})\n\
  \    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})\nend\n\n\
  os.exit(lu.LuaUnit.run())"
completions: ["  return math.max(numbers)\nend", "  return numbers:map(function(n)\n\
    \    return math.max(numbers:sub(1, n + 1))\n  end)\nend", "  local rolling_max\
    \ = numbers.[1]\n  for i = 2, #numbers do\n    if numbers[i] > rolling_max then\
    \ rolling_max = numbers[i] end\n  end\n  return rolling_max\nend", "    assert(numbers\
    \ and numbers[1], 'rolling_max need at least a number as input')\n    local n\
    \ = numbers[1]\n    local max_value = numbers[2]\n    local rolling_max = max_value\n\
    \    local rolling_max_idx = 1\n    for i = 2, n do\n        if numbers[i] <=\
    \ rolling_max then\n            rolling_max = numbers[i]\n            rolling_max_idx\
    \ = i\n        end\n    end\n    return rolling_max_idx, rolling_max\nend", " \
    \ local rolling_max = numbers[1]\n  for i = 2, #numbers do\n    if rolling_max\
    \ < numbers[i] then rolling_max = numbers[i] end\n  end\n  return rolling_max\n\
    end", "  local rolling_max = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i]\
    \ < rolling_max then\n      rolling_max = numbers[i]\n    end\n  end\n  return\
    \ rolling_max\nend", "    if #numbers == 1 then\n        return {numbers[1]}\n\
    \    end\n    local max_val = numbers[1]\n    local i = 0\n    for i = 1, #numbers\
    \ do\n        if numbers[i] > max_val then\n            max_val = numbers[i]\n\
    \        end\n    end\n    table.insert(numbers, max_val)\n    return numbers\n\
    end", '  if #numbers < 1 then return nil end', "  if #numbers == 0 then\n    return\
    \ numbers\n  end", "  if numbers == nil then return nil end\n  local n = #numbers\n\
    \  if n == 0 then\n    return numbers\n  end\n  local rollingMax = numbers[n]\n\
    \  for i = n - 1, 1, -1 do\n    if numbers[i] > rollingMax then\n      rollingMax\
    \ = numbers[i]\n    end\n  end\n  return rollingMax\nend", "  local max = 0\n\
    \  local last = 0\n  for _, v in ipairs(numbers) do\n    if v > max then\n   \
    \   max = v\n      last = v\n    end\n  end\n  return last, max\nend", "  local\
    \ max_value = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] > max_value\
    \ then\n      max_value = numbers[i]\n    end\n  end\n  return max_value\nend",
  "\tlocal max_value = numbers[1]\n\tlocal max_number = 1", "    assert(#numbers ==\
    \ 0, 'rolling_max requires at least one element')\n    local maximum = numbers[1]\n\
    \    local current_max = numbers[1]\n    for i = 2, #numbers do\n        local\
    \ element = numbers[i]\n        if element > current_max then\n            current_max\
    \ = element\n        end\n        maximum = element\n    end\n    return maximum\n\
    end", "  return sequence.reduce(numbers, nil,\n    function(max_so_far, current_element)\n\
    \      return math.max(max_so_far, current_element)\n    end)\nend", "    local\
    \ index = 1\n    local max_element = numbers[1]\n    local max_index = numbers[1]\n\
    \    for i = 2, #numbers do\n        if numbers[i] > max_element then\n      \
    \      max_element = numbers[i]\n            max_index = index\n        end\n\
    \        index = index + 1\n    end\n    return max_element, max_index\nend",
  "  if #numbers == 1 then\n    return numbers\n  else\n    local first_max = numbers[1]\n\
    \    for _, elem in pairs(numbers) do\n      if elem > first_max then\n      \
    \  first_max = elem\n      end\n    end\n    return first_max\n  end\nend", " \
    \ local max_elements = #numbers\n  local max_element = 0\n  for i = 1, #numbers\
    \ do\n    max_element = max_element > numbers[i] and numbers[i] or max_element\n\
    \    if max_elements ~= 1 then\n      max_elements = max_elements - 1\n    end\n\
    \  end\n  return max_element\nend", "    local rolling_max, rolling_max_idx =\
    \ {}, 1\n    for i = 1, #numbers do\n        rolling_max[rolling_max_idx] = numbers[i]\n\
    \        if numbers[i] > rolling_max[rolling_max_idx] then\n            rolling_max_idx\
    \ = rolling_max_idx + 1\n        end\n    end\n    return rolling_max\nend", " \
    \ local rolling_max = nil\n  -- First element\n  rolling_max[1] = numbers[1]\n\
    \  -- Find the number of element to generate\n  local rolling_max_size = numbers[1]\n\
    \  for i = 2, #numbers do\n    -- Update rolling max size\n    rolling_max_size\
    \ = math.max(rolling_max_size, numbers[i])\n    -- Remove the current element\n\
    \    rolling_max = table.concat(rolling_max):gsub(\"%d\", numbers[i])\n  end\n\
    \  return rolling_max\nend", "  local rolling_max = numbers.[1]\n  local current_max\
    \ = numbers.[2]\n  local max_idx = 1", "    if #numbers == 0 then\n        return\
    \ nil\n    end", "  local results = {}\n  for i = 1, #numbers do\n    local currentMax\
    \ = numbers[i]\n    for j = 1, i do\n      if numbers[j] < currentMax then\n \
    \       currentMax = numbers[j]\n      end\n    end\n    results[i] = currentMax\n\
    \  end\n  return results\nend", "  if #numbers <= 0 then\n    return {}\n  end",
  "  local max_idx = 1\n  local max_elem = numbers[max_idx]\n  for idx = 2, #numbers\
    \ do\n    if numbers[idx] > max_elem then\n      max_idx = idx\n      max_elem\
    \ = numbers[idx]\n    end\n  end\n  return numbers:sub(max_idx + 1)\nend", " \
    \ local rolling_max_number = numbers[1]\n  for i = 2, #numbers do\n    rolling_max_number\
    \ = math.max(rolling_max_number, numbers[i])\n  end\n  return rolling_max_number\n\
    end", "  local ret = {}\n  local index = 1\n  while #ret < numbers[#numbers]\n\
    \    do\n      local element = numbers[index]\n      if element > ret[#ret] then\n\
    \        ret[#ret] = element\n      end\n      index = index + 1\n    end\n  return\
    \ ret\nend", "  return rolling_window(numbers, 1, function(window, element)\n\
    \    return math.max(window, element)\n  end)\nend", "  local max_elements = numbers[1]\n\
    \  local max_index = numbers[2]\n  local i = 2", "  local max = 1\n  local index\
    \ = 1\n  while true do\n    if index < #numbers then\n      max = math.max(max,\
    \ numbers[index])\n    else\n      return max\n    end\n    index = index + 1\n\
    \  end\nend", "  local rolling_max = numbers.[1]\n  for i = 2, #numbers do\n \
    \   rolling_max = max(rolling_max, numbers[i])\n  end\n  return rolling_max\n\
    end", "    local current_max = numbers[1]\n    for _, num in pairs(numbers[2:])\
    \ do\n        if num > current_max then\n            current_max = num\n     \
    \   end\n    end\n    return current_max\nend", "    local function rolling_max_internal(numbers,\
    \ moment)\n        local current_rolling_max = 0\n        local current_value\
    \ = 0", "  local rolling_maxes = {}\n  for i = 1,#numbers do\n    rolling_maxes[#rolling_maxes\
    \ + 1] = numbers[i]\n    if numbers[i] ~= rolling_maxes[#rolling_maxes] then\n\
    \      rolling_maxes[#rolling_maxes + 1] = numbers[i]\n    end\n  end\n  return\
    \ rolling_maxes\nend", "  local max_element = 0\n  local max_pos = 1\n  for idx\
    \ = 1, #numbers do\n    if numbers[idx] > max_element then\n      max_element\
    \ = numbers[idx]\n      max_pos = idx\n    end\n  end\n  local rolling_max_elements\
    \ = {}\n  for idx = 1, #numbers do\n    local element = numbers[idx]\n    if element\
    \ > max_element then\n      rolling_max_elements[max_pos] = element\n      max_element\
    \ = element\n      max_pos = 1\n    else\n      rolling_max_elements[max_pos]\
    \ = element\n      max_pos = max_pos + 1\n    end\n  end\n  return rolling_max_elements\n\
    end", "  local max_idx = -1\n  local max_val = numbers[1]\n  for i = 2, #numbers\
    \ do\n    if numbers[i] ~= max_val then\n      max_idx = i\n      max_val = numbers[i]\n\
    \    end\n  end\n  table.insert(numbers, max_idx)\n  return numbers\nend", " \
    \ local max = 0\n  local i = 0\n  for i = 1,#numbers do\n    if numbers[i] >=\
    \ max then\n      max = numbers[i]\n    end\n  end\n  i = i + 1\n  local result\
    \ = []\n  while i <= #numbers do\n    if numbers[i] >= max then\n      table.insert(result,\
    \ max)\n      max = numbers[i]\n    else\n      max = max + numbers[i]\n     \
    \ table.insert(result, max)\n    end\n    i = i + 1\n  end\n  return result\n\
    end", "  local rolling_max_res = {}\n  local rolling_max_value = numbers[1]\n\
    \  local last_value\n  for _, v in pairs(numbers) do\n    if last_value ~= nil\
    \ then\n      if v > rolling_max_value then\n        rolling_max_value = v\n \
    \     end\n    else\n      rolling_max_value = v\n    end\n    last_value = v\n\
    \  end\n  rolling_max_res[#rolling_max_res+1] = rolling_max_value\n  return rolling_max_res\n\
    end", "  return function()\n    if #numbers == 0 then\n      nil\n    else\n \
    \     local i = #numbers - 1\n      local max_so_far = numbers[i]\n      while\
    \ i ~= 1 do\n        local max_so_far_new = numbers[i]\n        for j = i - 1\
    \ downto 1 do\n          local max_so_far_old = numbers[j]\n          max_so_far_new\
    \ = max_so_far_new > max_so_far_old\n        end\n        numbers[i] = max_so_far_new\n\
    \        i = i - 1\n      end\n      return numbers[1]\n    end\n  end\nend",
  "  local maxNumber\n  local prevMaxNumber\n  local index = -1\n  local lastMaxIndex\
    \ = -1\n  for i, number in ipairs(numbers) do\n    if i > 0 then\n      if prevMaxNumber\
    \ then\n        -- If we're not at the first iteration\n        if prevMaxNumber\
    \ == number then\n          index = i - 1\n        end\n      else\n        index\
    \ = i\n      end\n    end\n    if maxNumber then\n      if maxNumber < number\
    \ then\n        prevMaxNumber = maxNumber\n        maxNumber = number\n      \
    \  lastMaxIndex = index\n      end\n    else\n      maxNumber = number\n     \
    \ lastMaxIndex = index\n    end\n  end\n  return maxNumber, lastMaxIndex\nend",
  "  local rolling_max = {}\n  for i = 1, #numbers do\n    local max_element = numbers[i]\n\
    \    for j = 1, #numbers do\n      if numbers[j] > max_element then\n        max_element\
    \ = numbers[j]\n      end\n    end\n    table.insert(rolling_max, max_element)\n\
    \  end\n  return rolling_max\nend", "  local rolling_max = numbers.[1]\n  for\
    \ i = 2, #numbers do\n    rolling_max = math.max(rolling_max, numbers[i])\n  end\n\
    \  return rolling_max\nend", "  local rolling_max = numbers[1]\n  for i = 2, #numbers\
    \ do\n    rolling_max = math.max(rolling_max, numbers[i])\n  end\n  return rolling_max\n\
    end", "  local result = {}\n  local i = 1\n  while i <= #numbers do\n    result[#result\
    \ + 1], _ = max(numbers, i, result)\n    i = i + 2\n  end\n  return result\nend",
  "    local max_size = nil\n    local max_element = nil\n    for _,elt in ipairs(numbers)\
    \ do\n        if max_size == nil then\n            max_size = elt\n          \
    \  max_element = elt\n        elseif elt > max_element then\n            max_size\
    \ = elt\n            max_element = elt\n        end\n    end\n    return max_element,max_size\n\
    end", "  local rolling = {} -- Rolling window to store rolling max\n  for i =\
    \ 1, #numbers do\n    local current_max = numbers[i]\n    local current_index\
    \ = i", "  if #numbers == 0 then\n    return {}\n  end", "  local max = numbers[1]\n\
    \  for i = 2, #numbers do\n    if max < numbers[i] then\n      max = numbers[i]\n\
    \    end\n  end\n  return max\nend", "    -- Find the minimum number in the sequence\n\
    \    local minimum = numbers[1]\n    -- Find the maximum number in the sequence\n\
    \    local maximum = numbers[1]\n    -- For each element in the sequence\n   \
    \ for i = 2, #numbers do\n        -- If this element > minimum set minimum to\
    \ this element\n        if numbers[i] > minimum then\n            minimum = numbers[i]\n\
    \        end\n        -- If this element < maximum set maximum to this element\n\
    \        if numbers[i] < maximum then\n            maximum = numbers[i]\n    \
    \    end\n    end\n    -- Return the maximum number found\n    return maximum\n\
    end", "  local rolling_max_found = {}\n  local last_rolling_max_found = -1\n \
    \ local rolling_max_index = -1\n  local rolling_max_number\n  for index, number\
    \ in ipairs(numbers) do\n    if last_rolling_max_found < number then\n      rolling_max_index\
    \ = index\n      rolling_max_number = number\n    end\n    last_rolling_max_found\
    \ = number\n  end\n  for index, number in ipairs(numbers) do\n    if number >\
    \ rolling_max_number then\n      rolling_max_index = index\n      rolling_max_number\
    \ = number\n    end\n  end\n  rolling_max_found[rolling_max_index] = rolling_max_number\n\
    \  return rolling_max_found\nend", "  local rolling_max = numbers[1]\n  for i\
    \ = 2, #numbers do\n    if rolling_max < numbers[i] then\n      rolling_max =\
    \ numbers[i]\n    end\n  end\n  return rolling_max\nend", "  assert(type(numbers)\
    \ ~= 'table', 'argument must be an array')", "  local max = {}\n  local index\
    \ = 1\n  for i = 1, #numbers do\n    if numbers[index] > numbers[i] then\n   \
    \   max[index] = numbers[i]\n      index = index + 1\n    end\n  end\n  max[index]\
    \ = numbers[index]\n  return max\nend", "    local maxes = {}\n    for i = 1,\
    \ #numbers do\n        table.insert(maxes, numbers[i])\n    end\n    local index\
    \ = 0\n    local result = {}\n    local n = numbers[#numbers]\n    for i = 1,\
    \ n do\n        index = index + 1\n        local max\n        for j = index, #numbers\
    \ do\n            if numbers[j] > max then\n                max = numbers[j]\n\
    \            end\n        end\n        table.insert(result, max)\n    end\n  \
    \  return result\nend", "  return numbers .. table.copy(numbers)\n    .reverse()\n\
    \    .reduce(function(m, e)\n        -- Check if a rolling maximum is already\
    \ found before adding it to the list\n        if m == nil then\n          m =\
    \ e\n        else\n          if e > m then\n            m = e\n          end\n\
    \        end", "  local function rolling_max(list, idx)\n    if idx == #numbers\
    \ then\n      return list\n    end\n    if list[idx] == nil then\n      list[idx]\
    \ = numbers[idx]\n    else\n      list[idx] = math.max(list[idx], numbers[idx])\n\
    \    end\n    return rolling_max(list, idx + 1)\n  end\n  return rolling_max{list\
    \ = numbers}\nend", "  local result = {}\n  for i = #numbers, 1, -1 do\n    table.insert(result,\
    \ math.max(numbers[i]:ceil()))\n  end\n  return result\nend", "  local size =\
    \ #numbers\n  local output = {}\n  local m = {}\n  local i = 1\n  while i <= size\
    \ do\n    table.insert(output, numbers[i])\n    table.insert(m, numbers[i])\n\
    \    i = i + 1\n  end\n  i = 1\n  while i <= size do\n    for j = i - 1 downto\
    \ 1 do\n      if m[j] > numbers[i] then\n        m[j] = numbers[i]\n        output[j]\
    \ = numbers[i]\n      end\n    end\n    i = i + 1\n  end\n  return output\nend",
  "  local current_max = 0\n  for i = 1, #numbers do\n    current_max = math.max(numbers[i],\
    \ current_max)\n  end\n  return current_max\nend", "    local result = {}\n  \
    \  local i = 1\n    while i <= #numbers do\n        local value = numbers[i]\n\
    \        for j = i+1 to #numbers do\n            if numbers[j] > value then\n\
    \                i = j\n                value = numbers[j]\n            end\n\
    \        end\n        result[#result+1] = value\n        i = i + 1\n    end\n\
    \    return result\nend", "    local window = 1\n    local maximum = numbers[1]\n\
    \    if #numbers == 1 then\n        return numbers\n    end", "  local rolling_max\
    \ = {}\n  for i = 1, #numbers do\n    for j = 1, i do\n      if numbers[j] < numbers[i]\
    \ then\n        rolling_max[j] = numbers[j]\n      else\n        rolling_max[j]\
    \ = rolling_max[j] or numbers[i]\n      end\n    end\n  end\n  return rolling_max\n\
    end", "  local rolling_max = {}\n  for i = 1, #numbers do\n    local j = i - 1\n\
    \    while true do\n      local rolling_max = numbers[i]:max(rolling_max)\n  \
    \    if j ~= i then\n        rolling_max = numbers[j]:max(rolling_max)\n     \
    \ else\n        return rolling_max\n      end\n      if rolling_max ~= nil then\n\
    \        return rolling_max\n      end\n      j = j - 1\n    end\n  end\nend",
  "  local max_element = 0\n  local rolling_max = {}", "  if numbers[1] then\n   \
    \ return numbers[1]\n  end\n  local rollingMax = numbers[1]\n  for i = 2, #numbers\
    \ do\n    if numbers[i] > rollingMax then\n      rollingMax = numbers[i]\n   \
    \ end\n  end\n  return rollingMax\nend", "  local maxima = tablex.new()\n  for\
    \ i = 1,#numbers,1 do\n    local maxima_element = numbers[i]\n    for j = i+1,#numbers\
    \ do\n      local element = numbers[j]\n      if element > maxima_element then\n\
    \        maxima_element = element\n      end\n    end\n    table.insert(maxima,\
    \ maxima_element)\n  end\n  return maxima\nend", "   if #numbers == 0 then return\
    \ nil end\n   local max = 0\n   local maxes = {max}\n   local pos = 0\n   local\
    \ max = numbers[pos]\n   while pos < #numbers and numbers[pos] ~= max do\n   \
    \   local newmax = numbers[pos]\n      pos = pos + 1\n      if pos < #numbers\
    \ then\n         max = numbers[pos]\n         maxes = {max}\n      end\n   end\n\
    \   return maxes\nend", "\tassert(type(numbers) ~= 'table', 'Expecting a table')\n\
    \tlocal rolling_max = numbers[1]\n\tfor i = 2, #numbers do\n\t\trolling_max =\
    \ rolling_max > numbers[i] and rolling_max or numbers[i]\n\tend\n\treturn rolling_max\n\
    end\n_G.rolling_max = rolling_max", "   local rolling_max = table.new()\n   for\
    \ _, elem in ipairs(numbers) do\n      table.insert(rolling_max, elem)\n     \
    \ if rolling_max[#rolling_max] > elem then\n         rolling_max[#rolling_max]\
    \ = elem\n      end\n   end\n   return rolling_max\nend", "  local max_value =\
    \ 0\n  local max_pos = 1\n  for _, value in ipairs(numbers) do\n    if value >\
    \ max_value then\n      max_value, max_pos = value, 1\n    elseif value == max_value\
    \ then\n      max_pos = max_pos + 1\n    end\n  end\n  return max_value .. max_pos\n\
    end", "  if #numbers == 0 then\n    return {}\n  end", "    local rolling_max\
    \ = numbers.[1]\n    for _ = 2, #numbers do\n        local new_max = rolling_max\
    \ or 0\n        if numbers[_] > new_max then\n            rolling_max = numbers[_]\n\
    \        end\n    end\n    return rolling_max\nend", "  return function()\n  \
    \  local maxValue = numbers[1]\n    for i = 2, #numbers, 1 do\n      local curValue\
    \ = numbers[i]\n      if curValue > maxValue then\n        maxValue = curValue\n\
    \      end\n    end\n    return maxValue\n  end\nend", "  if #numbers <= 1 then\n\
    \    return numbers\n  else\n    local m = 1\n    local current_max = numbers[1]\n\
    \    local new_max = numbers[1]\n    for i = 2, #numbers do\n      if current_max\
    \ < numbers[i] then\n        m = m + 1\n        current_max = numbers[i]\n   \
    \   else\n        new_max = current_max\n        current_max = numbers[i]\n  \
    \    end\n    end\n    return rolling_max(new_max,\n      rolling_max(numbers,\
    \ m - 1, m - 1, current_max))\n  end\nend", "  return torch.max(numbers, torch.Tensor(math.max(numbers:size(1)-1,\
    \ 1)))\nend", "    local results = {}\n    for i = 1, #numbers do\n        results[i]\
    \ = numbers[i]\n    end", "  if numbers then\n    local max = 0\n    local rolling\
    \ = 0\n    local maxi = 1\n    for i = 2, #numbers, 1 do\n      local x = numbers[i]\n\
    \      if x > max then\n        max = x\n        maxi = i\n      end\n      rolling\
    \ = rolling + (x - max)\n    end\n    return rolling, maxi\n  else\n    return\
    \ 0, nil\n  end\nend", "  local max = nil\n  for _, value in ipairs(numbers) do\n\
    \    if not max or value > max then\n      max = value\n    end\n  end\n  return\
    \ max\nend", "  return function()\n    local current  = numbers[1]\n    local\
    \ maximum = numbers[1]", "    -- if given number is empty return empty list\n\
    \    if not numbers then\n        return {}\n    end\n    local max_so_far = numbers[1]\n\
    \    for i = 2, #numbers do\n        local current_element = numbers[i]\n    \
    \    if current_element > max_so_far then\n            max_so_far = current_element\n\
    \        end\n    end\n    return max_so_far\nend", "  if numbers then\n    local\
    \ current = numbers[1]\n    for _, v in ipairs(numbers) do\n      if current >\
    \ v then\n        current = v\n      end\n    end\n    return current\n  else\n\
    \    return nil\n  end\nend", "  local max_index = 1\n  local max_value = numbers[1]\n\
    \  local i = 1\n  for i = 1, #numbers do\n    if numbers[i] > max_value then\n\
    \      max_index = i\n      max_value = numbers[i]\n    end\n  end\n  local index_range\
    \ = max_index - max_index + 1\n  while i <= index_range do\n    table.insert(numbers,\
    \ max_value)\n    max_index = max_index + 1\n    i = i + 1\n    if max_index >\
    \ index_range then\n      break\n    end\n    max_value = max_value * max_index\n\
    \  end\n  return numbers\nend", "  local result = {}\n  for i = 1, math.min(#numbers,\
    \ 4) do\n    table.insert(result, max(numbers[i - 1], numbers[i], numbers[i +\
    \ 1], numbers[i + 2]))\n  end\n  return result\nend", "\tlocal rolling_max, last_number\
    \ = {}, numbers[1]\n\tfor i = 2, #numbers do\n\t\tif numbers[i] ~= last_number\
    \ then\n\t\t\trolling_max = last_number\n\t\t\tlast_number = numbers[i]\n\t\t\
    end\n\t\trolling_max[#rolling_max + 1] = numbers[i]\n\tend\n\treturn rolling_max\n\
    end", "   -- Sort numbers to ensure stability\n   table.sort(numbers)\n   local\
    \ max = 0\n   local max_index = -1\n   for i = 1, #numbers do\n      local value\
    \ = numbers[i]\n      if value > max then\n         max = value\n         max_index\
    \ = i\n      end\n   end\n   return numbers[max_index + 1]\nend", "  for i=1,#numbers,1\
    \ do\n    local max_num = numbers[i]\n    for j=i,#numbers,1 do\n      max_num\
    \ = max_num > numbers[j] and max_num or numbers[j]\n    end\n    numbers[i] =\
    \ max_num\n  end\n  return numbers\nend", "  local rolling_max = nil\n  local\
    \ max_value = nil\n  local max_count = nil\n  local i = 1\n  while i <= #numbers\
    \ do\n    -- if the next value is bigger than the previous one\n    if numbers[i]\
    \ < numbers[i - 1]\n    then\n      -- save the new max_value\n      if max_value\
    \ == nil\n      then\n        max_value = numbers[i]\n      else\n        max_count\
    \ = max_count + 1\n      end\n    end\n    -- save the new max_value\n    if max_value\
    \ == nil\n    then\n      max_value = numbers[i]\n      max_count = max_count\
    \ + 1\n    end\n    i = i + 1\n  end\n  return max_value, max_count\nend", " \
    \ local function rolling_max(...)\n    local rolling_max_value\n    local last_max_value\n\
    \    for i, arg in ipairs(arg) do\n      rolling_max_value = rolling_max_value\
    \ or arg\n      last_max_value = arg\n    end", "   local numbers_with_max_element\
    \ = nil\n   local max_element\n   for i = 1, #numbers do\n      max_element =\
    \ numbers[i]\n      if not numbers_with_max_element or max_element > numbers_with_max_element[1]\
    \ then\n         numbers_with_max_element = {i, max_element}\n      end\n   end\n\
    \   return numbers_with_max_element[1]\nend", "  local rolling_max = numbers[1]\n\
    \  for i = 2, #numbers do\n    rolling_max = math.max(rolling_max, numbers[i])\n\
    \  end\n  return rolling_max\nend", "    return map_reduce(numbers, function(accum,\
    \ number)\n        if accum == nil then\n            return number\n        else\n\
    \            return max(accum, number)\n        end\n    end)\nend", "    local\
    \ max_rolling_numbers = {}\n    for _, number in ipairs(numbers) do\n        local\
    \ rolling_number = math.max(number)\n        if max_rolling_numbers[rolling_number]\
    \ == nil then\n            max_rolling_numbers[rolling_number] = number\n    \
    \    else\n            max_rolling_numbers[rolling_number] = rolling_number ..\
    \ \",\" .. max_rolling_numbers[rolling_number]\n        end\n    end\n    return\
    \ max_rolling_numbers\nend", "    local max_value\n    for _, value in ipairs(numbers)\
    \ do\n        if max_value == nil then\n            max_value = value\n      \
    \  else\n            if value > max_value then\n                max_value = value\n\
    \            end\n        end\n    end\n    return max_value\nend", "    local\
    \ rolling_max = 1\n    for i = 1, #numbers do\n        rolling_max = math.max(rolling_max,\
    \ numbers[i])\n    end\n    return rolling_max\nend", "  local max_element = 0\n\
    \  local max_index = 0\n  local i = 0\n  local max = numbers[1]\n  for i = 1,\
    \ #numbers do\n    if max < numbers[i] then\n      max = numbers[i]\n      max_index\
    \ = i\n    end\n  end", "  local rolling_max_elements = { }\n  local rolling_max_element\
    \ = numbers[1]\n  for i = 2, #numbers do\n    local current_element = numbers[i]\n\
    \    if current_element > rolling_max_element then\n      rolling_max_element\
    \ = current_element\n      rolling_max_elements[#rolling_max_elements+1] = rolling_max_element\n\
    \    end\n  end\n  return rolling_max_elements\nend", "  local max_so_far = numbers[1]\n\
    \  local max_so_far_i = 1\n  for i = 2, #numbers do\n    if numbers[i] >= max_so_far\
    \ then\n      max_so_far = numbers[i]\n      max_so_far_i = i\n    end\n  end\n\
    \  return max_so_far_i, max_so_far\nend", "  assert(#numbers > 0)\n  local rolling_max_idx\
    \ = 1\n  local rolling_max_value = numbers[rolling_max_idx]\n  for idx = 2, #numbers\
    \ do\n    if numbers[idx] > rolling_max_value then\n      rolling_max_value =\
    \ numbers[idx]\n      rolling_max_idx = idx\n    end\n  end\n  return numbers[rolling_max_idx]\n\
    end", "  local result = {}\n  for i = 1, #numbers do\n    local n = numbers[i]\n\
    \    local m = #result\n    if m == 0 or n ~= result[m - 1]\n    then\n      result[m\
    \ - 1] = n\n    else\n      result[m - 1] = result[m - 1] or numbers[i]\n    end\n\
    \  end\n  return result\nend", "  local rolling_maxes = {}\n  for i = 1, (#numbers\
    \ + 1) do -- +1 for the last element\n    local new_rolling_max = {}\n    for\
    \ j = 0, (#rolling_maxes + 1) do -- +1 for the last element\n      if rolling_maxes[j]\
    \ < numbers[i] then\n        new_rolling_max[#new_rolling_max + 1] = rolling_maxes[j]\n\
    \      else\n        new_rolling_max[#new_rolling_max] = numbers[i]\n      end\n\
    \    end\n    rolling_maxes = new_rolling_max\n  end\n  \n  return rolling_maxes\n\
    end", "  return function()\n    if #numbers <= 0 then\n      return {}\n    end\n\
    \    local minimum = numbers[1]\n    local maximum = minimum\n    for _, number\
    \ in ipairs(numbers) do\n      maximum = math.max(number, maximum)\n    end\n\
    \    return minimum, maximum\n  end\nend", "  if #numbers == 0 then\n    return\
    \ nil\n  end\n  local max_so_far = numbers[1]\n  for i = 2, #numbers do\n    if\
    \ numbers[i] > max_so_far then\n      max_so_far = numbers[i]\n    end\n  end\n\
    \  return max_so_far\nend", "  local maxes = nil\n  for i = 1, #numbers, 1 do\n\
    \    local max_index = nil\n    for j = 1, #maxes, 1 do\n      if maxes[j] > numbers[i]\
    \ then\n        max_index = j\n      end\n    end\n    if max_index then\n   \
    \   maxes[max_index] = numbers[i]\n    else\n      maxes = numbers[i]\n    end\n\
    \  end\n  return maxes\nend", "    -- Calculate rolling maximum\n    local max\
    \ = {}\n    for i = 1, #numbers do\n        -- Get current number\n        local\
    \ number = numbers[i]", "  local max_index = 0\n  local max_number = nil\n  for\
    \ i = 1, #numbers do\n    if numbers[i] > max_number then\n      max_index = i\n\
    \      max_number = numbers[i]\n    end\n  end\n  return numbers[max_index..max_index+#numbers-1]\n\
    end", "   assert(#numbers > 0)\n   local rollingMax = numbers[1]\n   for i = 2,\
    \ #numbers do\n      if numbers[i] > rollingMax then\n         rollingMax = numbers[i]\n\
    \      end\n   end\n   return rollingMax\nend", "  if #numbers == 0 then\n   \
    \ return {}\n  end\n  local window = {}\n  local max = 0\n  local pos = 1\n  for\
    \ i = 1, #numbers - 1 do\n    if numbers[i] > max then\n      max = numbers[i]\n\
    \      pos = 1\n    end\n    window[pos] = max\n    pos = pos + 1\n  end\n  window[pos]\
    \ = numbers[#numbers]\n  return window\nend", "  local rolling = {}\n  local lastMax\
    \ = nil\n  local count = 1\n  for i = 1, #numbers do\n    if not rolling[i] then\n\
    \      rolling[i] = 1\n    else\n      rolling[i] = rolling[i] + 1\n    end\n\
    \    if rolling[i] == number then\n      last = numbers[i]\n      if last > lastMax\
    \ then\n        rolling[i] = 1\n      else\n        rolling[i] = lastMax + 1\n\
    \      end\n    end\n  end\n  return rolling\nend", "  local max = 0\n  for _,\
    \ x in pairs(numbers) do\n    if x > max then\n      max = x\n    end\n  end\n\
    \  max\nend", "  return function()\n    if #numbers == 0 then\n      return\n\
    \    end\n    local max = numbers[1]\n    for i = 2, #numbers do\n      max =\
    \ numbers[i] and max or numbers[i]\n    end\n    return max\n  end\nend", "  local\
    \ index = 0\n  local maximum = numbers[index]\n  for i = 1, #numbers do\n    maximum\
    \ = numbers[i] > maximum and numbers[i]:max(maximum) or maximum\n    index = i\
    \ + 1\n  end\n  return maximum\nend", "  local i = 1\n  local max_element = 0\n\
    \  while i < #numbers do\n    local element = numbers[i]\n    max_element = element\
    \ if element > max_element else max_element\n    i = i + 1\n  end\n  return max_element\n\
    end", "  local rolling_max = numbers.[1]\n  local i = 2\n  while i < #numbers\
    \ do\n    if numbers[i] < rolling_max then\n      rolling_max = numbers[i]\n \
    \   end\n    i = i + 1\n  end\n  return rolling_max\nend", "  local rolling_max_table\
    \ = {}\n  for i = 1, #numbers do\n    if rolling_max_table[i] then\n      rolling_max_table[i]\
    \ = rolling_max(rolling_max_table[i], numbers[i])\n    else\n      rolling_max_table[i]\
    \ = numbers[i]\n    end\n  end\n  return rolling_max_table\nend", "  local results\
    \ = {}\n  local rolling_index = 0\n  local rolling_max = numbers[rolling_index]\n\
    \  for i = 1, #numbers do\n    local current_value = numbers[i]\n    if current_value\
    \ > rolling_max then\n      rolling_max = current_value\n      rolling_index =\
    \ i\n    end\n    table.insert(results, rolling_max)\n  end\n  return results\n\
    end", "  return table.concat(numbers, nil, function(number)\n    if number <=\
    \ 2 then\n      -- Return empty array as no rolling max is possible.\n      return\
    \ {}\n    end\n    local max_rolling_index = 1\n    local max_rolling_number =\
    \ numbers[max_rolling_index]\n    for i = max_rolling_index + 1, #numbers do\n\
    \      local rolling_number = numbers[i]\n      if rolling_number > max_rolling_number\
    \ then\n        max_rolling_number = rolling_number\n        max_rolling_index\
    \ = i\n      end\n    end\n    -- Insert last number\n    max_rolling_index =\
    \ max_rolling_index + 1\n    max_rolling_number = numbers[max_rolling_index]\n\
    \    table.insert(max_rolling_number, number)\n    return max_rolling_number\n\
    \  end)\nend", "\tlocal maxnum = 0\n\tlocal maxpos = -1\n\tlocal current\n\tfor\
    \ i, x in ipairs(numbers) do\n\t\tif x ~= current then\n\t\t\tif maxpos == -1\
    \ then\n\t\t\t\tmaxpos = i\n\t\t\t\tmaxnum = x\n\t\t\telse\n\t\t\t\tif x > maxnum\
    \ then\n\t\t\t\t\tmaxpos = i\n\t\t\t\t\tmaxnum = x\n\t\t\t\tend\n\t\t\tend\n\t\
    \tend\n\t\tcurrent = x\n\tend\n\treturn numbers[maxpos+1]\nend", "  return function()\
    \ -- Return rolling max\n    local rolling_max = numbers[1]\n    for i = 2, #numbers,\
    \ 1 do\n      rolling_max = math.max(rolling_max, numbers[i])\n    end\n    return\
    \ rolling_max\n  end\nend", "  assert(#numbers > 0)\n  local max_rolling = {}\n\
    \  local max_rolling_num = 0\n  for _, value in ipairs(numbers) do\n    if value\
    \ > max_rolling_num then\n      max_rolling_num = value\n      max_rolling = {}\n\
    \    end", "  local rolling_max_element = nil\n  for i = 1, #numbers do\n    rolling_max_element\
    \ = numbers[i]\n    if rolling_max_element ~= nil and rolling_max_element > rolling_max_element\
    \ then\n      rolling_max_element = rolling_max_element\n    end\n  end\n  if\
    \ rolling_max_element ~= nil then\n    for i = #numbers, 1, -1 do\n      numbers[i]\
    \ = rolling_max_element\n    end\n  end\n  return numbers\nend", "  return math.max(table.unpack(numbers,\
    \ 1, table.getn(numbers) - 1))\nend", "  local rolling_max = nil\n  local count\
    \ = 0\n  local sum = 0\n  for i = 1, #numbers do\n    sum = sum + numbers[i]\n\
    \    if sum > rolling_max then\n      rolling_max = sum\n    end\n    count =\
    \ count + 1\n  end\n  return rolling_max\nend", "  local max = 0 -- We are going\
    \ to take the max between current number and all previously found maximums\n \
    \ local max_found = 0 -- How many numbers were we looking at?\n  local max_found\
    \ = #numbers -- How many numbers are we looking at?\n  for i = #numbers, 1, -1\
    \ do\n    -- If we already found a higher value than the current one, then stop\
    \ looking\n    if numbers[i] and numbers[i] < max then\n      break\n    end\n\
    \    -- If we didn't find any higher value yet, then just go to the next value\n\
    \    if numbers[i] and numbers[i] > max then\n      max = numbers[i]\n      max_found\
    \ = 1\n    end\n    -- If we found a higher value than the current max, then update\
    \ the max accordingly\n    if not numbers[i] and numbers[i] >= max then\n    \
    \  max = numbers[i]\n      max_found = 1\n    end\n  end\n  return max, max_found\n\
    end", "  local max = 0\n  for i=1,#numbers do\n    if numbers[i] > max then\n\
    \      max = numbers[i]\n    end\n  end\n  return max\nend", "  return function()\
    \ return return table.concat(numbers, math.max(#numbers)) end\nend", "  local\
    \ current_max = numbers[1]\n  local current_max = nil\n  for i = 2, #numbers do\n\
    \    local current_max = numbers[i]\n    if current_max ~= nil and current_max\
    \ > current_max then\n      current_max = nil\n    end\n    if current_max ==\
    \ nil then\n      current_max = numbers[i]\n    end\n  end\n  if current_max ~=\
    \ nil and current_max > current_max then\n    return current_max\n  end\nend",
  "  local rm = {}\n  local last_pos = 0\n  local last_value = numbers[1]\n  local\
    \ last_value_roll = 0\n  for i = 2, #numbers do\n    if numbers[i] ~= last_value\
    \ then\n      last_value_roll = i - 1\n      if last_value_roll > 0 then\n   \
    \     rm[last_value_roll] = numbers[i]\n      end\n      last_pos = i\n      last_value\
    \ = numbers[i]\n    else\n      last_value_roll = i - 1\n      if last_value_roll\
    \ > 0 then\n        rm[last_value_roll] = numbers[i]:max(last_value_roll)\n  \
    \    end\n    end\n  end\n  return rm\nend", "  local rolling_max = {}\n  local\
    \ current_max = 0\n  local index = 0\n  -- TODO: fix this naive implementation\
    \ to return an empty list if list was empty.\n  -- This happens when rolling_max([1])\
    \ is called.\n  if #numbers == 0 then\n    return rolling_max\n  end\n  -- Find\
    \ the first element to include in the rolling max\n  local first_max_element\n\
    \  do\n    index = index + 1\n    current_max = numbers[index]\n    if current_max\
    \ == 0 then\n      -- No rolling max found\n      rolling_max[index] = current_max\n\
    \      rolling_max[1] = current_max\n      return\n    end\n    -- Remove the\
    \ first element from the list and add the next one\n    first_max_element = numbers[#numbers]\n\
    \    numbers[#numbers] = nil\n  until index >= #numbers or current_max > first_max_element\n\
    \  -- Remove the first element from the rolling max\n  rolling_max[index] = numbers[#numbers]\n\
    \  -- Add all other elements until the first element is greater than the first\
    \ element of the list\n  for i = index + 1 , #numbers do\n    if numbers[i] <\
    \ first_max_element then\n      rolling_max[i] = numbers[i]\n    end\n  end\n\
    \  return rolling_max\nend", "    if next(numbers) == nil then\n        return\
    \ nil\n    end\n    local last_value = next(numbers)\n    local last_index = next(numbers)\n\
    \    local last_index = last_index - 1\n    local max_index = 0\n    local max_value\
    \ = last_value\n    while true do\n        local value = next(numbers)\n     \
    \   if value == nil then\n            break\n        end\n        if max_value\
    \ < value then\n            max_value = value\n            max_index = last_index\n\
    \        end\n        last_value = value\n        last_index = last_index - 1\n\
    \    end\n    while max_index > 0 do\n        next(numbers)\n        max_index\
    \ = max_index - 1\n    end\n    return max_value\nend", "   local nnumbers = #numbers\n\
    \   local max_rolling = 0\n   local max_rolling_number = numbers[0]\n   local\
    \ max_rolling_element = numbers[1]", "  local max_rolling = numbers[1]\n  for\
    \ _, rolling in pairs(numbers) do\n    max_rolling = max_rolling and rolling or\
    \ max_rolling\n  end\n  return max_rolling\nend", "  return [math.max(numbers)]\
    \ -- {1,2,3,4,5}\nend", "  local sum = 0\n  local max_so_far = nil\n  for i =\
    \ 1, #numbers do\n    sum = sum + numbers[i]\n    if sum > max_so_far then\n \
    \     max_so_far = sum\n    end\n  end\n  return max_so_far\nend", "    if next(numbers)\
    \ == nil then\n        return {}\n    end", "  if #numbers <= 1 then return numbers\
    \ end\n  local max_so_far = numbers[1]\n  local max_in_front = numbers[1]\n  for\
    \ i = 2, #numbers do\n    if max_so_far > numbers[i] then\n      max_so_far =\
    \ numbers[i]\n    end\n    max_in_front = numbers[i] or max_in_front\n  end\n\
    \  return max_in_front\nend", "  local ret = {}\n  local i = 0\n  local n = 0\n\
    \  for _, v in ipairs(numbers) do\n    i = i + 1\n    if v > n then\n      n =\
    \ v\n    end\n    if i == 1 then\n      ret[#ret + 1] = n\n    else\n      ret[#ret\
    \ - 1] = n\n    end\n  end\n  return ret\nend", "  return function()\n    local\
    \ rolling_max\n    local index = 0\n    local element = 0\n    rolling_max = tablex.create(_G.maxn(numbers))\n\
    \    local function add_max(number)\n      element = number\n      rolling_max:insert(element)\n\
    \      index = index + 1\n      if index > numbers[1] then return rolling_max\
    \ end\n    end\n    for i = 1, numbers[2] do\n      element = numbers[i]\n   \
    \   add_max(element)\n    end\n    return rolling_max\n  end\nend", "   local\
    \ max = 1\n   for i = 1, #numbers do\n      if numbers[i] > max then\n       \
    \  max = numbers[i]\n      end\n   end\n   return max\nend", "  local i = 1\n\
    \  local rolling_max = {[i - 1]}\n  local length = 1", "   local rolling_max,\
    \ rolling_max_index\n   for rolling_max_index = 1, #numbers, 1 do\n      local\
    \ num = numbers[rolling_max_index]\n      if rolling_max == nil then\n       \
    \  rolling_max = num\n         rolling_max_index = rolling_max_index + 1\n   \
    \   else\n         if num > rolling_max then\n            rolling_max = num\n\
    \         end\n      end\n   end\n   return rolling_max\nend\nreturn rolling_max",
  "  local max = {}\n  local i = 0", "\tlocal window = math.max(1, #numbers)\n\tlocal\
    \ buffer = {}\n\tlocal position = -1\n\tlocal max = 0\n\tfor i = 1, window do\n\
    \t\tbuffer[#buffer + 1] = numbers[i]\n\tend\n\tlocal i = window - 1\n\twhile i\
    \ >= 0 do\n\t\tif numbers[i] > max then\n\t\t\tmax = numbers[i]\n\t\t\tposition\
    \ = i\n\t\tend\n\t\ti = i - 1\n\tend\n\tif #buffer > 1 then\n\t\treturn rolling_max(buffer,\
    \ position)\n\telse\n\t\treturn max\n\tend\nend", "    local rolling_max = {}\n\
    \    for i = 1, #numbers do\n        for j = 1, #rolling_max do\n            if\
    \ numbers[i] < rolling_max[j] then\n                rolling_max[j] = numbers[i]\n\
    \            end\n        end\n    end\n    return rolling_max\nend", "  local\
    \ rolling_max = nil\n  local n = 0\n  local m = #numbers - 1\n  while n > 0 do\n\
    \    local element = numbers[n]\n    if rolling_max == nil then\n      rolling_max\
    \ = element\n    elseif element > rolling_max then\n      rolling_max = element\n\
    \    end\n    n += 1\n  end\n  return rolling_max\nend", "  local rolling_max\
    \ = numbers.shift()\n  for i = 1, #numbers do\n    rolling_max = max(rolling_max,\
    \ numbers[i])\n  end\n  return rolling_max\nend", "  return torch.max(xlua.unpack(numbers))\n\
    end", "  return lists:foldl(\n    function(max, number)\n      return max < number\
    \ ? max : number\n    end, numbers[1][1], numbers\n  )\nend", "  local rolling_max\
    \ = numbers[1]\n  for i = 2, #numbers do\n    rolling_max = numbers[i] < rolling_max\
    \ and numbers[i] or rolling_max\n  end\n  return rolling_max\nend", "  return\
    \ unpack(\n    map(\n      function(n)\n        return math.max(\n          n,\n\
    \          numbers[#numbers]\n        )\n      end,\n      numbers\n    )\n  )\n\
    end", "  return local rolling_max_result\n  for i=1,#numbers do\n    rolling_max_result\
    \ = rolling_max_result or (numbers[i])\n    for j=i,#numbers do\n      if numbers[j]\
    \ > rolling_max_result then\n        rolling_max_result = numbers[j]\n      end\n\
    \    end\n  end\n  return rolling_max_result\nend", "  local rolling_max = numbers.[1]\n\
    \  for i = 2, #numbers, 1 do\n    if rolling_max < numbers[i] then\n      rolling_max\
    \ = numbers[i]\n    end\n  end\n  return rolling_max\nend", "    if #numbers ==\
    \ 1 then\n        return numbers\n    end\n    local max_so_far = numbers[1]\n\
    \    for i = 2, #numbers do\n        if numbers[i] ~= max_so_far then\n      \
    \      local m\n            if max_so_far == 1 then\n                m = 1\n \
    \           else\n                m = max_so_far\n            end\n          \
    \  local tmp = max_so_far\n            max_so_far = numbers[i]\n            for\
    \ j = 1, m do\n                max_so_far = max_so_far > numbers[i] and max_so_far\
    \ or numbers[i]\n            end\n            return max_so_far\n        end\n\
    \    end\n    return numbers[1]\nend", "  local max = {}\n  for i = 1, #numbers\
    \ do\n    table.insert(max, numbers[i])\n    if i ~= #numbers and numbers[i] ~=\
    \ numbers[i - 1] + 1 then\n      table.insert(max, numbers[i - 1] + 1)\n    end\n\
    \  end\n  return max\nend", "  local rolling_max = numbers.[1]\n  for i = 2, #numbers\
    \ do\n    if rolling_max < numbers[i] then\n      rolling_max = numbers[i]\n \
    \   end\n  end\n  return rolling_max\nend", "  local max = 0\n  local rolling_maxes\
    \ = {}\n  for i = 1, #numbers do\n    max = numbers[i]\n    rolling_maxes[i] =\
    \ max\n  end\n  table.insert(rolling_maxes, max)\n  for i = 1, #numbers do\n \
    \   rolling_maxes[i + 1] = numbers[i]\n  end\n  return rolling_maxes\nend", " \
    \   assert(numbers, \"At least one element should be provided.\")\n    return\
    \ table.insert((numbers[1] or 0), numbers[1], table.copy(numbers))\nend", "  return\
    \ function(moment)\n    local result = {}\n    for i, v in ipairs(numbers) do\n\
    \      result[i] = v\n      if i > moment then\n        break\n      end\n   \
    \ end\n    return result\n  end\nend", "   local max_value = numbers[1]\n   for\
    \ i, v in pairs(numbers) do\n      max_value = v if v > max_value then v else\
    \ max_value end\n   end\n   return max_value\nend", "    return assert(filter(x->\
    \ x <= maximum(numbers), numbers))\nend", "    local rolling_max = {}\n    local\
    \ max_index = 0\n    for i = 1, #numbers do\n        if numbers[i] > rolling_max[max_index]\
    \ then\n            rolling_max[max_index] = numbers[i]\n        end\n       \
    \ if i == #numbers then\n            rolling_max[max_index] = numbers[i]\n   \
    \     end\n        max_index = max_index + 1\n    end\n    return rolling_max\n\
    end", "  local max_element = nil\n  local max_number = nil\n  for i = 1, #numbers\
    \ do\n    if max_number == nil or max_element > numbers[i] then\n      max_element\
    \ = numbers[i]\n      max_number = numbers[i]\n    end\n    local j = i - 1\n\
    \    while j > 0 and numbers[j] > max_number do\n      max_number = numbers[j]\n\
    \      max_element = max_element or numbers[j]\n      j = j - 1\n    end\n  end\n\
    \  return max_element\nend", '  local rolling_max = numbers.shift()', "  if #numbers\
    \ <= 1 then\n    return numbers[1]\n  end", "    return unpack(numbers:map(function(a)\
    \ return a end):reduce(function(max,a) return max == nil and a or max end,nil))\n\
    end", "  local function rolling_max(t, i, max)\n    if i == #t then\n      return\
    \ max\n    end\n    if t[i] == nil then\n      return rolling_max(t, i + 1, max)\n\
    \    end\n    return rolling_max(t, i + 1, max) or t[i]\n  end\n  return rolling_max(numbers,\
    \ 1, 1)\nend", "    local current = nil\n    local maximum = nil\n    for _, num\
    \ in pairs(numbers) do\n        if current == nil then\n            current =\
    \ num\n            maximum = num\n        else\n            maximum = math.max(num,\
    \ maximum)\n        end\n    end\n    return maximum\nend", "  local rolling =\
    \ {}\n  local max = 0\n  for i = 1, #numbers do\n    max = math.max(max, numbers[i])\n\
    \    table.insert(rolling, max)\n  end\n  return rolling\nend", "  local result\n\
    \  local index\n  local maximum\n  local last_index = 0", "  local function rolling_max(k,\
    \ list, result)\n    local index = 1\n    for i = 1, k do\n      local j = index\n\
    \      local candidate = list[j]\n      local index = index + 1\n      for index\
    \ = index + 2, #list do\n        local candidate = list[index]\n        if candidate\
    \ > candidate then\n          result = candidate\n          break\n        end\n\
    \      end\n    end\n    return result\n  end\n  local result\n  if #numbers ==\
    \ 1 then\n    result = rolling_max(numbers[1], numbers, nil)\n  else\n    result\
    \ = {}\n  end\n  local index = 1\n  for i = 2, #numbers do\n    result[index]\
    \ = rolling_max(i - 1, numbers, result[index])\n  end\n  return result\nend",
  "  local rolling_max = numbers[1]\n  for i = 2, #numbers do\n    rolling_max = max\
    \ rolling_max numbers[i]\n  end\n  return rolling_max\nend", "  local rolling_max\
    \ = numbers.max\n  return function(k)\n    if k > 0 then\n      rolling_max =\
    \ rolling_max and rolling_max(rolling_max)\n    end\n    return rolling_max and\
    \ rolling_max(k)\n  end\nend", "  local rolling = {}\n  local last = {}\n  local\
    \ i = 1\n  while i <= #numbers - 1 do\n    local currentMax = last[#last]\n  \
    \  if currentMax > numbers[i] then\n      last[#last + 1] = numbers[i]\n    end\n\
    \    i = i + 1\n  end\n  return rolling\nend", "  local max_so_far = numbers[1]\n\
    \  local max_list = []\n  for i = 2, #numbers do\n    max_so_far = numbers[i]\n\
    \    if max_so_far > max_so_far then\n      table.insert(max_list, max_so_far)\n\
    \    end\n  end\n  return max_list\nend", "  local rolling_max = numbers.max\n\
    \  return function(n)\n    if n <= 0 then return rolling_max(1, n) end\n    return\
    \ rolling_max(rolling_max(numbers(n)), n - 1)\n  end\nend", "  if numbers == nil\
    \ then return nil end\n  local rolling_max = numbers[1]\n  for i = 2, #numbers\
    \ do\n    if numbers[i] > rolling_max then\n      rolling_max = numbers[i]\n \
    \   end\n  end\n  return rolling_max\nend", "   local current_max = nil\n   local\
    \ current_pos = 0\n   local max_pos = nil", "  local function rolling_max(s, i,\
    \ n)\n    if i < n then\n      local m = s[i]\n      for j = i + 1, n do\n   \
    \     if s[j] > m then\n          m = s[j]\n        end\n      end\n      s[i]\
    \ = m\n    end\n  end\n  rolling_max(nil, 0, #numbers)\n  return numbers\nend",
  "  local max = 1\n  for i = 1, #numbers do\n    local num = numbers[i]\n    if num\
    \ <= max then\n      max = num\n    end\n  end\n  return numbers\nend", "   assert(#numbers\
    \ > 0)\n   local max_i = nil\n   local max_element = nil\n   local max_value =\
    \ nil\n   for i = 1, #numbers do\n      local v = numbers[i]\n      if max_value\
    \ == nil or v > max_value then\n         max_value = v\n         max_element =\
    \ v\n      elseif v == max_value then\n         max_element = max_element > v\
    \ ? max_element : v\n      end\n   end\n   return max_element\nend", "    local\
    \ rolling_maxes = {}\n    local last_value = nil\n    for i = 1, #numbers do\n\
    \        local value = numbers[i]\n        if last_value == nil then\n       \
    \     last_value = value\n        elseif value >= last_value then\n          \
    \  last_value = value\n        else\n            table.insert(rolling_maxes, last_value)\n\
    \            last_value = value\n        end\n    end\n    table.insert(rolling_maxes,\
    \ last_value)\n    return rolling_maxes\nend", "  local max_element = numbers[1]\n\
    \  local max_index = 1\n  for i = 2, #numbers do\n    local element = numbers[i]\n\
    \    if element > max_element then\n      max_element = element\n      max_index\
    \ = i\n    end\n  end", "    if #numbers == 0 then\n        return {}\n    end\n\
    \    local maxima = {}\n    for i = #numbers, 1, -1 do\n        maxima[i] = numbers[i]:max(numbers[i-1]:gt(numbers[i-1]))\
    \ or 0\n    end\n    local function rolling(max, idx, size)\n        local maxima\
    \ = {}\n        for i = idx, idx+size, 1 do\n            maxima[i] = numbers[i]:max(max)\
    \ or 0\n        end\n        return maxima\n    end\n    local function rolling_max(max,\
    \ idx, size)\n        if idx == 0 or size == #numbers or idx+size == #numbers\
    \ and #maxima == 0 then\n            maxima = numbers[idx]:max(max) or 0\n   \
    \     else\n            maxima = rolling(maxima, idx, size)\n        end\n   \
    \     return maxima\n    end\n    return rolling_max(maxima, 1, #numbers)\nend",
  "  local result = {}\n  for i = 1, #numbers do\n    local max_element = numbers[i]\n\
    \    for j = i - 1, 1, -1 do\n      if numbers[j] > max_element then\n       \
    \ max_element = numbers[j]\n      end\n    end\n    result[#result + 1] = max_element\n\
    \  end\n  return result\nend", "    return function(start, size)\n        local\
    \ max_number = numbers[start]\n        for i = start, start + size do\n      \
    \      if numbers[i] > max_number then\n                max_number = numbers[i]\n\
    \            end\n        end\n        return max_number\n    end\nend", "  if\
    \ numbers ~= nil then\n    -- We have some elements to consider\n    if #numbers\
    \ == 1 then\n      return numbers[1]\n    end\n    -- If we have more elements\
    \ to consider than there are number elements, we need to\n    -- extend the sequence\
    \ with the remaining elements.\n    local result = {}\n    local index = #numbers\n\
    \    while index ~= 0 do\n      table.insert(result, numbers[index - 1])\n   \
    \   index = index - 1\n    end\n    -- Extend the sequence with the remaining\
    \ elements.\n    while #numbers > 1 do\n      local index = index - 1\n      table.insert(result,\
    \ numbers[index])\n    end\n    -- Return the result (as array)\n    return result\n\
    \  end\nend", "  local max_value = 0\n  local max_index\n  for _, value in ipairs(numbers)\
    \ do\n    if value > max_value then\n      max_value = value\n      max_index\
    \ = value\n    end\n  end\n  assert(max_index, \"[rolling_max] missing max_index\"\
    )\n  local rolling_max = numbers[max_index]\n  for i = max_index, 1, -1 do\n \
    \   rolling_max = max(rolling_max, numbers[i])\n  end\n  return rolling_max\n\
    end", "  local max_index\n  local max_value = numbers[1]\n  for _, value in pairs(numbers)\
    \ do\n    if value > max_value then\n      max_value = value\n      max_index\
    \ = nil\n    elseif value == max_value then\n      max_index = nil\n    else\n\
    \      max_index = max_index or 1\n      if value > max_value then\n        max_value\
    \ = value\n      end\n    end\n  end\n  return max_index or 1\nend", "  local\
    \ i = 0\n  local rolling_maxes = {}\n  while i < #numbers do\n    rolling_maxes[i]\
    \ = numbers[i]\n    i = i + 1\n  end\n  return rolling_maxes\nend", "  local results\
    \ = {}\n  local index = 1\n  for i = 1, math.ceil(#numbers) do\n    local rolling_max\
    \ = 0\n    for j = 1, i do\n      rolling_max = rolling_max or numbers[j]\n  \
    \    if rolling_max > numbers[index] then\n        rolling_max = numbers[index]\n\
    \        index = j\n      end\n    end\n    results[i] = rolling_max\n  end\n\
    \  return results\nend", "  local rolling_max = numbers.shift()\n  local i = 0\n\
    \  repeat\n    rolling_max = numbers[i]\n    i = i + 1\n  until i > #numbers\n\
    \  return rolling_max\nend", "  local rolling_max_so_far = nil\n  local current_rolling_max\
    \ = nil", "  return function() return table(unpack(numbers), unpack(numbers))\
    \ end\nend", "  local max, i = maxi(0)\n  local rolling_max = numbers[i]\n  while\
    \ i + 1 ~= #numbers and numbers[i + 1] <= max do\n    max = numbers[i + 1]\n \
    \   i = i + 1\n    rolling_max = numbers[i]\n  end\n  return rolling_max\nend",
  "  local i, max = 1, numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] < max\
    \ then\n      max = numbers[i]\n    end\n  end\n  return numbers\nend", "  local\
    \ rolling_maxes = {}\n  local index = numbers[1]\n  local rolling_maxes_len =\
    \ 0\n  for i = 2, #numbers do\n    if numbers[i] > rolling_maxes[rolling_maxes_len]\
    \ then\n      rolling_maxes_len = rolling_maxes_len + 1\n      rolling_maxes[rolling_maxes_len]\
    \ = numbers[i]\n    end\n    if rolling_maxes_len > index then\n      rolling_maxes[rolling_maxes_len]\
    \ = numbers[i]\n    end\n  end\n  return rolling_maxes\nend", '  if numbers ==
    nil then return end', "  return rolling_max_helper(numbers, 0, 0, false, true)\n\
    end", "    local result = {}\n    for _, value in ipairs(numbers) do\n       \
    \ table.insert(result, value)\n    end\n    table.sort(result)\n    local current_max\
    \ = 1\n    for i = 2, #result do\n        if result[i] ~= result[i - 1] and result[i]\
    \ > current_max then\n            current_max = result[i]\n        end\n    end\n\
    \    return current_max\nend", "  local max_index = {}\n  for i = 1, #numbers\
    \ do\n    max_index[i] = numbers[i]\n  end\n  local max_value = max_index[1]\n\
    \  local max_size = #max_index\n  local current = 1\n  local output = {}\n  while\
    \ current <= max_size do\n    if numbers[current] > max_value then\n      max_value\
    \ = numbers[current]\n      max_index = i\n    end\n    current = current + 1\n\
    \  end\n  table.insert(output, max_value)\n  table.insert(output, max_index[1])\n\
    \  return output\nend", "  if #numbers < 1 then\n    return nil\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
