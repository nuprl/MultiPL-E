name: HumanEval_18_how_many_times
language: lua
prompt: "-- Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa',\
  \ 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string,\
  \ substring)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = how_many_times\n\
  \    lu.assertEquals(candidate('', 'x'), 0)\n    lu.assertEquals(candidate('xyxyxyx',\
  \ 'x'), 4)\n    lu.assertEquals(candidate('cacacacac', 'cac'), 4)\n    lu.assertEquals(candidate('john\
  \ doe', 'john'), 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if string == '' or substring == '' then return 0 end\n  local matches\
    \ = 0\n  for i, c in ipairs(string) do\n    if c == '' and substring[i] ~= ''\
    \ then matches += 1 end\n    if c == substring[i] then matches += 1 end\n  end\n\
    \  return matches\nend", "  local count = 0\n  local last_index = 0\n  for index\
    \ = 1, #string do\n    if string.sub(string, index, index) == substring then\n\
    \      count = count + 1\n      last_index = index\n    end\n  end\n  return count,\
    \ last_index\nend", "  return string.gsub( substring, string, \"%0\" .. string.len(substring)\
    \ .. \"%\" ):gsub(\"%0*([%d]+)\", nil) end\nend", "  local count = 0\n  local\
    \ pos = 1\n  while pos <= #string do\n    count = count + 1\n    if string.sub(i,\
    \ pos) == substring then\n      count = count + 1\n      pos = string.find(string,\
    \ substring, pos)\n    end\n    pos = pos + 1\n  end\n  return count\nend", " \
    \ local count = 0\n  for i = 1, string.len() do\n    if string.sub(i, i, i + string.len(substring))\
    \ = substring then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "    if not string or not substring then return 0 end\n    local count =\
    \ 0\n    local i, j = string.find(string, substring, 1, true)\n    while j do\n\
    \        i = j - 1\n        count = count + 1\n        j = string.find(string,\
    \ substring, i + 1)\n    end\n    return count\nend", "    local count, start,\
    \ index = 0, 0, 1\n    local substring_index\n    for index = 1, #string do\n\
    \        substring_index = string.find(substring, string, index)\n        if substring_index\
    \ == nil then\n            break\n        end\n        index = substring_index\
    \ + #substring\n        if substring_index == 0 then\n            count = count\
    \ + 1\n        else\n            count = count + 1\n        end\n    end\n   \
    \ return count\nend", "  local i, count = 0, 1\n  for i = 1, #string do\n    if\
    \ string[i] == substring then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "    local count = 0\n    for i, c in ipairs(string) do\n     \
    \   if c == substring then\n            count = count + 1\n        end\n    end\n\
    \    return count\nend", "    if string == nil then\n        return 0\n    end",
  "    local found = {}\n    for _, c in string.gmatch('([^' .. substring .. ']+)')\
    \ do\n        if not found[c] then\n            found[c] = 1\n        else\n \
    \           found[c] = found[c] + 1\n        end\n    end\n    return #found\n\
    end", "  local count = 0\n  for i = 1, string.len() do\n    if string.sub(i, i,\
    \ i + substring.len()) == substring then\n      count = count + 1\n    end\n \
    \ end\n  return count\nend", "   return string.gsub(string, string, \"%#\"..substring..\"\
    a\").gsub(string, string, \"%#\"..substring..\"b\").gsub(string, string, \"%#\"\
    ..substring..\"c\").gsub(string, string, \"%#\"..substring..\"d\").gsub(string,\
    \ string, \"%#\"..substring..\"e\").gsub(string, string, \"%#\"..substring..\"\
    f\").gsub(string, string, \"%#\"..substring..\"g\").gsub(string, string, \"%#\"\
    ..substring..\"h\").gsub(string, string, \"%#\"..substring..\"i\").gsub(string,\
    \ string, \"%#\"..substring..\"j\").gsub(string, string, \"%#\"..substring..\"\
    k\").gsub(string, string, \"%#\"..substring..\"l\").gsub(string, string, \"%#\"\
    ..substring..\"m\").gsub(string, string, \"%#\"..substring..\"n\").gsub(string,\
    \ string, \"%#\"..substring..\"o\").gsub(string, string, \"%#\"..substring..\"\
    p\").gsub(string, string, \"%#\"..substring..\"q\").gsub(string, string, \"%#\"\
    ..substring..\"r\").gsub(string, string, \"%#\"..substring..\"s\").gsub(string,\
    \ string, \"%#\"..substring..\"t\").gsub(string, string, \"%#\"..substring..\"\
    u\").gsub(string, string, \"%#\"..substring..\"v\").gsub(string, string, \"%#\"\
    ..substring..\"w\").gsub(string, string, \"%#\"..substring..\"x\").gsub(string,\
    \ string, \"%#\"..substring..\"y\").gsub(string, string, \"%#\"..substring..\"\
    z\")\nend", "  if string == nil or substring == nil then\n    return 0\n  end\n\
    \  local length = 0\n  local i = 0\n  while i <= #string do\n    length = length\
    \ + 1\n    if string.find(substring, string[i], i) ~= nil then\n      i = string.find(substring,\
    \ string[i], i + 1)\n    end\n    i = i + 1\n  end\n  return length\nend", '    local
    num_times = 0', "  local match = {}\n  for i = 1, string.find(string, substring)\
    \ do\n    table.insert(match, i)\n  end", "\tlocal count = 0\n\twhile string.find(substring,\
    \ string) >= 0 do\n\t\tcount = count + 1\n\t\tstring = string.sub(string, 1, string.len(string)\
    \ - string.len(substring))\n\tend\n\treturn count\nend", "  local counter = 0\n\
    \  for i = 1, #string do\n    if string.sub(i, i) == substring then\n      counter\
    \ = counter + 1\n    end\n  end\n  return counter\nend", "\t-- We have to do some\
    \ extra checking to deal with overlaps.\n\tif string:len() >= substring:len()\
    \ then\n\t\treturn 0\n\telseif string:len() < substring:len() then\n\t\treturn\
    \ string.tolower() - substring:lower()\n\telse\n\t\tlocal count = 0\n\t\tlocal\
    \ i = 1\n\t\twhile i <= (string:len() - substring:len()) do\n\t\t\tcount = count\
    \ + (string:sub(i, i + substring:len()):lower():len())\n\t\t\ti = i + substring:len()\n\
    \t\tend\n\t\treturn count\n\tend\nend", "\tlocal count = 0\n\tstring.gsub(substring,\
    \ function(c)\n\t\tcount = count + 1\n\tend)\n\treturn count\nend", "\tif string\
    \ == nil or substring == nil then\n\t\treturn 0\n\tend", "  -- Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \  if string == '' or string == nil then\n    return 0\n  end\n  local len_string\
    \ = string.len\n  if len_string == nil then\n    len_string = function() return\
    \ #string end\n  end\n  -- Return early if substring can't be found anywhere in\
    \ the string.\n  if string == substring or string.sub(string, 1, len_string(substring)\
    \ - 1) ~= substring then\n    return 0\n  end\n  local len_substring = string.len\n\
    \  if len_substring == nil then\n    len_substring = function() return #substring\
    \ end\n  end\n  local i = 0\n  while i <= len_string(substring) - 1 do\n    --\
    \ Find the beginning and end indexes of substring.\n    local start_index = string.find(string,\
    \ substring, 1, i)\n    if start_index == nil then\n      break\n    end\n   \
    \ local end_index = string.find(string, substring, start_index + 1, len_string(string))\n\
    \    if end_index == nil then\n      break\n    end\n    i = end_index + 1\n \
    \   local start_index = string.find(string, substring, 1, i)\n    if start_index\
    \ == nil then\n      break\n    end\n    local end_index = string.find(string,\
    \ substring, start_index + 1, len_string(string))\n    if end_index == nil then\n\
    \      break\n    end\n    i = end_index + 1\n    local start_index = string.find(string,\
    \ substring, 1, i)\n    if start_index == nil then\n      break\n    end\n   \
    \ local end_index = string.find(string, substring, start_index + 1, len_string(string))\n\
    \    if end_index == nil then\n      break\n    end\n    i = end_index + 1\n \
    \   local start_index = string.find(string, substring, 1, i)\n    if start_index\
    \ == nil then\n      break\n    end\n    local end_index = string.find(string,\
    \ substring, start_index + 1, len_string(string))\n    if end_index == nil then\n\
    \      break\n    end\n    i = end_index + 1\n    local start_index = string.find(string,\
    \ substring, 1, i)\n    if start_index == nil then\n      break\n    end\n   \
    \ local end_index = string.find(string, substring, start_index + 1, len_string(string))\n\
    \    if end_index == nil then\n      break\n    end\n    i = end_index + 1\n \
    \   -- Return how many times the substring was found.\n    return string.len(string)\
    \ - end_index\n  end\n  -- Return 0 if no substring was found.\n  return 0\nend",
  "    local count = string\n    count = string..substring\n    for i = 1, #string\
    \ do\n        count = count:sub(1,#count)\n        if string.find(string, substring)\
    \ >= 0 then\n            count = count + 1\n        end\n    end\n    return count\n\
    end", "    local count = 0\n    for i = 1, #string do\n        if string[i] ==\
    \ substring then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "  return string.gsub(string, substring, \"%1\") == \"\" or\n \
    \   string.gsub(string, substring, \"\") == \"\" or\n    string.gsub(string, substring,\
    \ \"\") == \"1\"\nend", "   for i = 1, string.len(string) do\n      if string.sub(i,\
    \ i) ~= substring then return 0 end\n   end\n   return string.len(string)\nend",
  "  return string.gsub(string, substring, function(c)\n    return string.len(string.sub(c,\
    \ -1, -1))\n  end)\nend", "  local count = 0\n  repeat\n    count = count + 1\n\
    \  until string.find(substring, string) ~= nil\n  return count\nend", "    return\
    \ string:gsub(\"(\" .. substring .. \")\", string.match or function(substring,\
    \ substring)\n        return string.gsub(substring, string, 1)\n    end)\nend",
  "  if substring == \"\" then\n    return 0\n  end\n  if string.find(substring) then\n\
    \    return string.find(substring) - string.sub(string, 1, string.find(substring)\
    \ - 1)\n  end\n  return 0\nend", "    return string:gsub(\"(^|\\\\W)\" .. substring\
    \ .. \"($|\\\\W)\", ''):match(\"^%D\")\nend", "    return string.gsub(string,\
    \ substring)\nend", '    if string.find(string) == nil then return 0 end', "\t\
    return string.match(string, \"%W\") ~= nil and string.match(string, substring)\
    \ or nil\nend", "    local count = 0\n    for substring in string.gmatch(string,\
    \ \"(.-)%S+\") do\n        count = count + 1\n    end\n    return count\nend",
  "  local n = #string - (#substring + 2)\n  local count = 0", "   -- Find the starting\
    \ index where the first occurrence of substring starts in the string.\n   local\
    \ index = string.find(string, \"^\" .. substring)", "   if string == nil then\n\
    \      return 0\n   end", "  return string.gsub(string, substring, \"%d*\"):match(\"\
    %d*\"):gsub(\"%d*\", \"%2\"):gsub(\"%2\", \"\"):gsub(\"%d*\", \"%d\"):gsub(\"\
    %d*\", \"\")\nend", "    if string == nil then return 0 end\n    if string.find(substring,\
    \ '') then\n        local count = 0\n        local pos = 1\n        local max_pos\
    \ = string.find(substring, '^') -- Find where the substring starts in the string\n\
    \        while string.find(substring, '^', pos) do -- Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \         count = count + 1\n            pos = pos + 1\n        end\n        return\
    \ count\n    else\n        return 0\n    end\nend", "  return string.gsub(string,\
    \ substring, ''):gsub('()', ''):gsub(',', ''):gsub(' ', ''):gsub('.', '')\nend",
  "  if string == '' or string == nil then\n    return 0\n  end\n  local index = string.find(substring,\
    \ 1, 1)\n  if index == nil then\n    return 0\n  elseif index ~= 1 then\n    return\
    \ index\n  end\n  index = string.find(substring, 1, 2)\n  if index == nil then\n\
    \    return 1\n  elseif index == 2 then\n    return 2\n  end\n  index = string.find(substring,\
    \ 1, 3)\n  if index == nil then\n    return 3\n  elseif index == 3 then\n    return\
    \ 4\n  end\n  return 4\nend", "    local pattern = \"(^|[\" .. string.gsub(string.gsub(substring,\
    \ string.gsub('^a', '', substring), pattern=''), '$', pattern='') .. \"])\"\n\
    \    return string.gsub(string, '' .. pattern .. '\\1([^' .. pattern .. ']*)',\
    \ function(a, b)\n        -- Count the number of overlapping matches\n       \
    \ local matches = string.match(string, b)\n        if not matches then\n     \
    \       return 0\n        end\n        if matches[1] == '' then\n            --\
    \ The first match will always be '', so subtract one to count only the non-overlapping\
    \ matches\n            return string.len(a) - string.len(b)\n        else\n  \
    \          return string.len(b) - string.len(matches[1])\n        end\n    end)\n\
    end", "  if string == '' or substring == '' then return 0 end\n  local count =\
    \ 1\n  local pos = 0\n  local len = #string\n  while pos < len do\n    local substr_len\
    \ = #substring\n    if string.sub(string, pos, pos + substr_len) == substring\
    \ then\n      count = count + 1\n      pos = pos + substr_len\n    else\n    \
    \  count = count - 1\n    end\n  end\n  return count\nend", "  local count = 0\n\
    \  for str in string.gmatch(string, \"(\" .. substring .. \")+\") do\n    count\
    \ = count + 1\n  end\n  return count\nend", "    local len_string = string.len(string)\n\
    \    local len_substring = string.len(substring)\n    local count, i, j\n    local\
    \ count_all = 0\n    local count_unique = 0", "    return string:gsub('%c'):gsub('%d'):gsub('%w'):gsub('%f'):gsub('%b'):gsub('%i'):gsub('%p'):gsub('%s'):gsub('%x'):gsub('%o'):gsub('%'):gsub('%d%d'):gsub('%+'):gsub('%.'):gsub('%-'):gsub('%.'):gsub('%+.'):gsub('%-.'):gsub('%.'):gsub('%d%d%d'):gsub('%d%d%d%d'):gsub('%d%d%d%d%d'):gsub('%+d'):gsub('%d%d%d'):gsub('%d%d%d%d'):gsub('%d%d%d%d%d'):gsub('%d%d%d%d%d%d'):gsub('%+dd'):gsub('%d%d%d'):gsub('%d%d%d%d'):gsub('%d%d%d%d%d'):gsub('%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d'):gsub('%+dddd'):gsub('%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%+ddddd'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
  "  local count = -1\n  string.gsub(substring, function(substring)\n    if string.find(string,\
    \ substring) then\n      count = count + 1\n    end\n  end)\n  return count\n\
    end", "  if string == substring then return 1 end\n  local index = 1\n  while\
    \ true do\n    index = string.find(substring, index, true)\n    if index == nil\
    \ then return end\n    if index == 0 then return 0 end\n    index = index + 1\n\
    \  end\nend", "  if string == nil or substring == nil then\n    return 0\n  end",
  "    local result = 1\n    for i = 1, #string do\n        if string.sub(i, i) ==\
    \ substring then\n            result = result + 1\n        end\n    end\n    return\
    \ result\nend", "   return string.gsub(string, \".\", {\n      local count = 1\n\
    \      local pos = string.find(string, \".\", 1, true)\n      while pos do\n \
    \        count = count + 1\n         pos = string.find(string, substring, pos\
    \ + 1, true)\n      end\n      return count\n   })\nend", "  local count = 0\n\
    \  for c in string.gmatch('%' .. substring .. '%') do\n    if string.find(string,\
    \ c) then\n      count = count + 1\n    end\n  end\n  return count\nend", "  \
    \  return string.gsub('%[' .. substring .. '%.]', function(c) return string.char(tonumber(c))\
    \ end, 0)\nend", "\t-- if there are no occurrences, it can't be a substring.\n\
    \tif string == '' or substring == '' then\n\t\treturn 0\n\tend", "  local result\
    \ = 0\n  local substring_length = #substring\n  for i = 1, #string do\n    if\
    \ string[i] == substring then\n      result = result + 1\n      if result > substring_length\
    \ then\n        return result\n      end\n    end\n  end\n  return result\nend",
  "  if string == nil then return 0 end\n  if substring == nil then return 0 end",
  "  if string == nil or substring == nil then\n    return 0\n  elseif string == ''\
    \ or substring == '' then\n    return 1\n  elseif string ~= substring then\n \
    \   return 0\n  else\n    -- Find the first position of substring in the string.\n\
    \    local position = 1\n    local position = string.find(string, substring, position)\n\
    \    -- If the substring is not found, count the substring as zero.\n    if position\
    \ == nil then\n      return 0\n    end\n    -- If the substring is found, find\
    \ the first position of last character and count the substring.\n    local start\
    \ = position\n    while start < string.len() do\n      position = string.find(string,\
    \ substring, start + 1)\n      if position == nil then\n        return string.len()\
    \ - start - 1\n      end\n      start = position\n    end\n  end\nend", "\treturn\
    \ string.gsub(string, substring, function(...)\n\t\treturn tonumber(...)\n\tend)\n\
    end", "  if string.find(substring) ~= nil then return 1 + string.find(substring,\
    \ 1, string.len(string)) end\n  local matches = 0\n  while string.find(substring)\
    \ ~= nil do\n    matches = matches + 1\n    string = string.sub(string, string.find(substring)\
    \ + string.len(substring))\n  end\n  return matches\nend", "    local count =\
    \ 0\n    for _, char in string:gmatch(\"%S+\") do\n        if char == substring\
    \ then\n            count = count + 1\n        end\n    end\n    return count\n\
    end", "    return #string + #substring - (string.find(string) or 0)\nend", " \
    \   local substring_index = 1\n    local count = 0\n    for index, chars in ipairs(string)\
    \ do\n        if chars == substring then\n            count = count + 1\n    \
    \        if count > substring_index then\n                substring_index = index\n\
    \            end\n        end\n    end\n    return substring_index\nend", "  local\
    \ count = 0\n  for i = 1, #string do\n    if string.sub(i, i - #substring) ==\
    \ substring then\n      count = count + 1\n    end\n  end\n  return count\nend",
  "    local count = 1\n    for i = 1, #string do\n        if string.sub(i, #i - 1)\
    \ == substring then\n            count = count + 1\n        end\n    end\n   \
    \ return count\nend", "  local matches = 0\n  for _, chars in pairs(string.gmatch(string,\
    \ \"(.-)\"..substring..\"(.-)\", 'o')) do\n    if chars == nil then break end\n\
    \    matches = matches + 1\n  end\n  return matches\nend", "    return string.gsub(string.gsub(string,\
    \ substring, 1), substring, 1)\nend", "    if string == substring then return\
    \ 1 end\n    if substring == '' then return 0 end\n    local num_occurrences =\
    \ 0\n    local current_start = 1\n    local current_end = #string\n    while current_start\
    \ <= current_end do\n        local search_start = string.find(substring, string,\
    \ current_start, 'last')\n        local search_end = string.find(substring, string,\
    \ current_start, 'last')\n        if search_start ~= nil and search_end ~= nil\
    \ then\n            num_occurrences = num_occurrences + 1\n            current_start\
    \ = search_end\n        else\n            return num_occurrences\n        end\n\
    \    end\n    return num_occurrences\nend", "    if string == substring then\n\
    \        return 0\n    end\n    local count = 0\n    for i = 1, #string do\n \
    \       if string.sub(i, #string) == substring then\n            count = count\
    \ + 1\n        end\n    end\n    return count\nend", "  local count = 0\n  for\
    \ _, c in string.gmatch(string, \"[^\" .. substring .. \"]+\") do\n    count =\
    \ count + 1\n  end\n  return count\nend", "    local count = 0\n    for c in string.gmatch(string,\
    \ \"[^\"..substring..\"]\") do\n        if string.sub(c, 1, 1) == substring then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  local start = 0 -- index in the original string\n  local substring_index = string.find(string,\
    \ substring)\n  while substring_index do\n    -- find next character in original\
    \ string\n    local index_in_substring = substring_index + 1\n    if index_in_substring\
    \ > #string then break end\n    local index = string.find(string, substring, index_in_substring)\n\
    \    -- If the substring has been found, get the string between the start and\
    \ end indices\n    if index then\n      start = start + index\n      substring_index\
    \ = substring_index + string.sub(string, index, index_in_substring) - index\n\
    \    end\n    -- move to next character in the original string\n    substring_index\
    \ = string.find(string, substring, index_in_substring)\n  end\n  return start\n\
    end", "  return string.gsub(string, substring, function()\n    return string[#string]\
    \ + 1\n  end)\nend", "\tif string == nil then\n\t\treturn 0\n\tend\n\tif substring\
    \ == nil then\n\t\treturn 1\n\tend\n\tlocal count = 0\n\tfor i, c in ipairs(string)\
    \ do\n\t\tif c == substring then\n\t\t\tcount = count + 1\n\t\tend\n\tend\n\t\
    return count\nend", "    if string == nil or substring == nil then\n        return\
    \ nil\n    end", "\tlocal count=0\n\tfor char=string.sub(string,1,string.len(substring))\
    \ do\n\t\tif char==substring then\n\t\t\tcount=count+1\n\t\telse\n\t\t\tcount=count+1\
    \ -- count overlaping cases\n\t\tend\n\tend\n\treturn count\nend", "  return string.gsub(string,\
    \ \"(\" .. substring .. \")\", function(match)\n    return string.match(match,\
    \ substring) + 1 -- Match case-insensitive, therefore add 1.\n  end)\nend", " \
    \   local matched, offset = 0,0\n    local substring_len = string.len\n    while\
    \ offset < string.len do\n        offset = offset + substring_len\n        if\
    \ string.sub(string, offset, offset) == substring then matched = matched + 1 end\n\
    \    end\n    return matched\nend", "  if string == nil or substring == nil then\n\
    \    return nil\n  end\n  -- Count overlapping cases\n  local count_matches =\
    \ 0\n  local current_start = string.find(string, \"^\"):byte()\n  local end_offset\
    \ = string.find(string, \"$\", start_offset, nil, true):byte()\n  while true do\n\
    \    local found = string.find(string, substring, current_start, true)\n    if\
    \ found == nil then\n      break\n    end\n    count_matches = count_matches +\
    \ 1\n    current_start = found + substring.len()\n  end\n  return count_matches\n\
    end", "  local count = substring == '' or string == nil then 0 else\n    string.gsub('[^'\
    \ .. substring .. ']', '', ''):gsub('[' .. substring .. ']', ''):gsub('%W', ''):gsub('%W',\
    \ '')\n  -- print(\"string: \", string)\n  -- print(\"substring: \", substring)\n\
    \  -- print(\"count: \", count)\n  return count\nend", "    local count = 0\n\
    \    for i = 1, #string do\n        if string.find(substring, string[i]) then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  local n = 0\n  while true do\n    local _n = string.find(string, substring, 1,\
    \ true)\n    if _n == nil then break end\n    if string.sub(string, _n + #substring)\
    \ == substring then n = n + 1 end\n  end\n  return n\nend", "\tlocal count = 0\n\
    \tfor _, sub in ipairs(string) do\n\t\tif sub == substring then\n\t\t\tcount =\
    \ count + 1\n\t\tend\n\tend\n\treturn count\nend", "  local count = 0\n  while\
    \ true do\n    local index = string:find(substring, 1, true) or string\n    if\
    \ index == string then return count end\n    count = count + 1\n    string = index\n\
    \  end\nend", "   local count = 0\n   for i = 1, #string do\n      if string.sub(i,\
    \ i, #substring) == substring then\n         count = count + 1\n      end\n  \
    \ end\n   return count\nend", "    local count = 0\n    for match in string.gsub(string,\
    \ substring, \"([^\" .. substring .. \"]*)\", true) do\n        count = count\
    \ + 1\n    end\n    return count\nend", "  if string == nil or substring == nil\
    \ then return 0 end\n  local index = string.find(string, substring, 1)\n  if index\
    \ == nil then return 0 end\n  return index + 1\nend", "\tlocal num_times = 0\n\
    \tfor i, v in ipairs(string.gmatch(string, \"%\" .. substring .. \"(.-)\")) do\n\
    \t\tif v == substring then\n\t\t\tnum_times = num_times + 1\n\t\tend\n\tend\n\t\
    return num_times\nend", "    local count = 0\n    for match in string.gmatch(string,\
    \ \"[^\" .. substring .. \"]\") do\n        count = count + 1\n    end\n    return\
    \ count\nend", "    if not string or not substring then return 0 end\n    local\
    \ count = 0\n    for s in string.gmatch(string, \"(%S+)\") do\n        if substring\
    \ == s or string.find(string, s, 1, true) then\n            count = count + 1\n\
    \        end\n    end\n    return count\nend", "  local index = 0\n  local index2\
    \ = 0\n  while index <= #string do\n    index2 = string.find(substring, string,\
    \ index + 1) -- Find position of substring\n    if index2 > index then\n     \
    \ return math.max(index2 - index, 1)\n    end\n    index = index2 + 1\n  end\n\
    \  return 0 -- The substring wasn't found\nend", "  if string == '' or substring\
    \ == '' then\n    return 0\n  end\n  local count = 0\n  for i = 1, #string do\n\
    \    if string.sub(i, i) == substring then\n      count = count + 1\n    end\n\
    \  end\n  return count\nend\nhow_many_times = wrap_string(how_many_times)", " \
    \   if not string or not substring then\n        return 0\n    end", "    local\
    \ count = 0\n    for pos, c in ipairs(string) do\n        if string.sub(c, pos,\
    \ pos) == substring then\n            count = count + 1\n        end\n    end\n\
    \    return count\nend", "  local cnt = 0\n  for _, c in string.gmatch(string,\
    \ '[^'..substring..']+') do\n    cnt = cnt + (string.sub(c, 1, string.len(substring))\
    \ == substring)\n  end\n  return cnt\nend", "\tif string == '' or string == '^'\
    \ then return 0 end\n\tlocal i, j = 1, #string\n\twhile i <= j do\n\t\tif string.sub(i,\
    \ j) == substring then return i end\n\t\ti, j = i + 1, j + 1\n\tend\n\treturn\
    \ 1\nend", "  return string.gsub(string, substring, \"\"):gsub(\"%S+\", function\
    \ (x)\n    return (#substring) * (#x + 1)\n  end)\nend", "   return string.gsub(string,\
    \ substring, 1).gsub(substring, string, 1, string.len(substring))\nend", "  if\
    \ string == nil or substring == nil then\n    return 0\n  end\n  local substring\
    \ = string.gsub('.', {\n    ['[%w]'] = function(c) return c end,\n    ['%w'] =\
    \ function(c) return string.lower(c) end,\n  }[substring])\n  local count = 0\n\
    \  local index = 1\n  while index <= #string do\n    if string.sub(string,index,index+#substring)\
    \ == substring then\n      count = count + 1\n      index = index + 1\n    else\n\
    \      index = index + 1\n    end\n  end\n  return count\nend", "  local substring_length\
    \ = #substring\n  if substring_length == 0 then return 0 end\n  local count =\
    \ 0\n  for match in (string.gsub(string, '[^'..substring.']+', function(x) return\
    \ x:len() end)) do\n    count = count + 1\n    if match == substring then return\
    \ count end\n  end\n  return count\nend", "  local count = 1\n  while true do\n\
    \    count = count + 1\n    local _, index = string.find(string, substring, 1)\n\
    \    if index == nil then break end\n    if string.sub(string, index, index +\
    \ 1) ~= substring then break end\n  end\n  return count\nend", "\treturn string:gsub('%a'..substring..'a',\
    \ function(c) -- Find how many times substring occurs in string.\n\t\tif string.find(string,\
    \ substring, 1, true) ~= nil then\n\t\t\t-- Find the start position of the current\
    \ match. Substring has already been counted before.\n\t\t\t-- Substring can be\
    \ found in the original string. Count overlaping cases.\n\t\t\t-- >>> how_many_times('aaaa',\
    \ 'aa')\n\t\t\t-- 3\n\t\t\t-- >>> how_many_times('aaaaa', 'aa')\n\t\t\t-- 3\n\t\
    \t\treturn string.find(string, substring, 1, true) - 1 -- Substring has been counted\
    \ already, so use it's start position to count the overlapping case.\n\t\telse\n\
    \t\t\treturn 0 -- No overlapping case.\n\t\tend\n\tend)\nend", "  if string ==\
    \ '' or substring == '' or string ~= substring then\n    return 0\n  end", " \
    \  local count = 0\n   if string and substring then\n      local index_string\
    \ = 1\n      while index_string <= string.len and string.sub(1, index_string)\
    \ == substring do\n         count = count + 1\n         index_string = index_string\
    \ + 1\n      end\n   end\n   return count\nend\nreturn how_many_times", "  return\
    \ string.gsub(string, substring):gsub('%W', function() return '\\\\1' end):gsub('%d',\
    \ '%d'):gsub('%D', '%d'):gsub('%%', '%'):gsub('%b', '%b'):gsub('%s', '%s'):gsub('%x',\
    \ '%x'):gsub('%u', '%u'):gsub('%x', '%x'):gsub('%X', '%X'):gsub('%d%d%d', '%d%d%d'):gsub('%d%d%d%d%d',\
    \ '%d%d%d%d%d%d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d', '%+d'):gsub('%+d',\
    \ '", "  if string == '' or substring == '' then\n    return 0\n  end\n  local\
    \ count_of_times = 0\n  for substring_start in string.gmatch('<(.*?)>') do\n \
    \   count_of_times = count_of_times + 1\n    local substring = string.sub(substring_start,\
    \ substring_start + 1)\n    if substring == substring then\n      count_of_times\
    \ = count_of_times + 1\n    end\n  end\n  return count_of_times\nend", "\tlocal\
    \ matches = 0\n\tfor i = 1, #string do\n\t\tlocal substring_index = string.find(substring,\
    \ string, i)\n\t\tif substring_index ~= nil then\n\t\t\tmatches = matches + 1\n\
    \t\t\ti = substring_index - 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn\
    \ matches\nend", "  local count = 0\n  for i = 1, #string do\n    if string.find(substring,\
    \ string, 1, i) then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "\tif string == '' then return 0 end\n\tlocal count = 0\n\tfor _, char in\
    \ string.gmatch(string, '%a'..substring) do count = count + 1 end\n\treturn count\n\
    end", "\tlocal i, count = 1, 1\n\tfor i = 1, #string do\n\t\tif string.sub(i,\
    \ i - #substring) == substring then count = count + 1 end\n\tend\n\treturn count\n\
    end", "  return string.gsub(string, '^%s*'):gsub('%s*$', ''):gsub('%s+', function(c)\
    \ return c:lower() end):match(tostring(substring))\nend", "  local count = 0\n\
    \  for _ in string.gfind(string, '^' .. substring .. '$') do\n    count = count\
    \ + 1\n  end\n  return count\nend\n</cell>\n<text>\nString manipulation and pattern\
    \ matching", "  if string == '' then return 0 end\n  if substring == '' then return\
    \ 1 end\n  local i = 0\n  while true do\n    i = string.find(substring, i, #string)\n\
    \    if i == nil then\n      return i + 1\n    end\n    i = i + 1\n  end\nend",
  "    local count = 0\n    local pos = 1\n    while pos <= #string do\n        if\
    \ string.find(substring, string, pos) == pos then\n            count = count +\
    \ 1\n        end\n        pos = pos + 1\n    end\n    return count\nend", '    if
    not string or not substring then return 0 end', "    local count = #string\n \
    \   for i = 1, #substring do\n        if string.find(string, substring) then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "\tif string.find(substring, string, 1, true) then\n\t\treturn string.find(substring,\
    \ string, 1, true) - string.find(substring, string, 1, 1)\n\telse\n\t\treturn\
    \ 0\n\tend\nend", "  if string == '' then\n    return 0\n  end\n  if substring\
    \ == '' then\n    return 1\n  end", "   for j = 1, string.len(substring) do\n\
    \      if string.find(string, substring, 1, j) ~= nil then\n         return string.len(substring)\
    \ - j - 1\n      end\n   end\n   return nil\nend", "\t-- First get all the matches\
    \ of our substring within the original string.\n\t-- If there are no matches,\
    \ return 0.\n\tlocal matches = string:gsub(\"(^\" .. substring .. \"$)|($\" ..\
    \ substring .. \"$)\", ''):gsub(\"(.)(\" .. substring .. \"..)(.)\",'\\2'):gsub(\"\
    (.)(\" .. substring .. \")(.)\",'\\2'):gsub(\"(.)(\" .. substring .. \"..)(.)\"\
    ,'\\2')\n\t-- If there are no matches at all, return 0.\n\tif not matches then\n\
    \t\treturn 0\n\tend\n\t-- Else, return the number of matches.\n\treturn matches:match(\"\
    (.)\"):match(\"(\" .. substring .. \"*):*\")\nend", "    -- Make all characters\
    \ lower case\n    string = string.lower(string)\n    -- Remove spaces from the\
    \ substring if they exist\n    if substring ~= \"\" then substring = substring.lower()\
    \ end\n    -- The count is how many times the substring can be found in the original\
    \ string\n    return string.gsub(substring, \".\", function()\n        local result\
    \ = 1\n        -- If the substring matches at least one time in the original string\n\
    \        for i = 1, #string do\n            -- Check if this character is equal\
    \ to the one at the current index\n            if string.sub(i, i, #substring)\
    \ == substring then\n                -- Increment the result by 1\n          \
    \      result = result + 1\n            end\n        end\n        return result\n\
    \    end)\nend", "   -- Special case where substring is empty string.\n   if string\
    \ == '' and substring == '' then\n      return 0\n   end\n   if string == '' or\
    \ substring == '' then\n      return 1\n   end\n   -- If the substring is longer,\
    \ substring is longer\n   if #substring > #string then\n      return how_many_times(substring,\
    \ string)\n   end\n   -- The substrings cannot be the same, just compare\n   if\
    \ string == substring then\n      return 0\n   end\n   -- Start with 0 times to\
    \ avoid zero substring matches.\n   -- For substring 'abc', the count of 'abc'\
    \ is 0 + 1 + 2 + 3 = 6\n   -- For substring 'ab', the count of 'ab' is 0 + 1 +\
    \ 2 = 4\n   local count = 0\n   -- Start comparing from the end of the string,\
    \ to ensure substrings are compared starting from the end of a string.\n   for\
    \ i = #string, 1, -1 do\n      if string[i] == substring then\n         count\
    \ = count + 1\n      else\n         break\n      end\n   end\n   return count\n\
    end", "    -- If the substring doesn't even exist in the original string, return\
    \ 0.\n    if not string or string == substring or string == '' then return 0 end\n\
    \    -- If the original string is empty, return a 0.\n    if string == '' then\
    \ return 0 end\n    -- Start by finding the start index of the substring.\n  \
    \  local index = 1\n    while string.sub(string, 1, index) == substring do\n \
    \       index = index + 1\n    end\n    -- Now that the start index is found,\
    \ the substring was found for the first time.\n    -- Now find where the substring\
    \ ends.\n    index = string.find(string, substring, index) + 1\n    -- The substring\
    \ was found for the first time, now loop through and subtract any overlaps.\n\
    \    local count = 0\n    while index > 1 do\n        index = string.find(string,\
    \ substring, index)\n        if index == 0 then break end\n        count = count\
    \ + 1\n        index = index - 1\n    end\n    return count\nend", "    if string\
    \ == nil then return 0 end\n    local num_times = 1\n    for i = 1, string.len()\
    \ do\n        if string.sub(i, i) == substring then num_times = num_times + 1\
    \ end\n    end\n    return num_times\nend", "    local count = 0\n    for c in\
    \ string.gsub(substring, \".\") do\n        count = count + 1\n    end\n    return\
    \ count\nend", "    return string.gsub(string, '[^' .. substring .. ']') ~= nil\
    \ and string.gsub(string, '(' .. substring .. ')', '').. string.gsub(string, '('\
    \ .. substring .. ')', '') or 0\nend", "    local count = 0\n    for c in string.gmatch(string,\
    \ '[^' .. substring .. ']') do\n        count = count + 1\n    end\n    return\
    \ count\nend", "  -- Create a hash table to store how many times a substring was\
    \ found in a string.\n  local hash = {}\n  for i = 1, #string do\n    hash[string[i]]\
    \ = hash[string[i]] + 1 -- Start from 1 instead of 0.\n  end\n  -- Find the number\
    \ of times the substring could be found in a string.\n  local count = 0\n  --\
    \ Iterate through all characters in the string.\n  for i = 1, #substring do\n\
    \    -- If the current character is found in the hash table, increment the count.\n\
    \    count = count + hash[substring[i]]\n  end\n  return count\nend", "\tlocal\
    \ count_a = 0\n\tlocal count_b = 0\n\tfor i = 1, #string do\n\t\tif string.sub(string,\
    \ i, i+#substring) == substring then\n\t\t\tcount_a = count_a + 1\n\t\telseif\
    \ string.sub(string, i, i+#substring) < substring then\n\t\t\tcount_b = count_b\
    \ + 1\n\t\tend\n\tend\n\tif count_a + count_b > 0 then\n\t\treturn count_a + count_b\n\
    \telse\n\t\treturn 0\n\tend\nend", "    local num_matches = 0\n    for i = 1,\
    \ string.gsub(substring, string, 1, 1) do\n        -- If the substring is not\
    \ found on the string, then return 0 since it will not match\n        if not string.sub(i,\
    \ string.len(substring), i) then return 0 end\n        num_matches = num_matches\
    \ + 1\n    end\n    return num_matches\nend", "\tlocal count = 0\n\tfor i, v in\
    \ ipairs(string) do\n\t\tif v == substring then\n\t\t\tcount = count + 1\n\t\t\
    end\n\tend\n\treturn count\nend", "  local count = 0\n  local i = 1, #string\n\
    \  while i <= #string do\n    local j = string.find(substring, string[i])\n  \
    \  if j == nil then\n      count = count + 1\n    else\n      if i == j then\n\
    \        count = count + 1\n      else\n        count = count + 1\n        i =\
    \ j\n      end\n    end\n    i = i + 1\n  end\n  return count\nend", "  local\
    \ count = 0\n  local start = substring.start\n  local index = string.find(string,\
    \ start, \"..\")\n  while index == do\n    count = count + 1\n    index = string.find(string,\
    \ index + 1, start)\n  end\n  return count\nend", "  return string:gsub(substring,\
    \ function() return 1 end):match(\"%d+\") - 1 -- Overlapping cases.\nend", "\t\
    return string.gsub(string, substring, \"([^\" .. substring .. \"]+)\") - 1 --\
    \ Remove the first match + count overlapping matches\nend", "  local matches =\
    \ string.gsub(string.gsub(string.gsub(string.gsub(string, '(.-)(.+$)', '%2'),\
    \ '(^[^%]+)', '%1'), '(.-)(.-%2)', '%3'), '(.-)(.-%2)', '%4')\n  return #matches\
    \ + #string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string,\
    \ '(.-)(.+$)', '%2'), '(^[^%]+)', '%1'), '(.-)(.-%2)', '%3'), '(.-)(.-%2)', '%4')\n\
    \  return #matches + #string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string,\
    \ '(.-)(.+$)', '%2'), '(^[^%]+)', '%1'), '(.-)(.-%2)', '%3'), '(.-)(.-%2)', '%4')\n\
    \  return #matches + #string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string,\
    \ '(.-)(.+$)', '%2'), '(^[^%]+)', '%1'), '(.-)(.-%2)', '%3'), '(.-)(.-%2)', '%4')\n\
    \  return #matches + #string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string,\
    \ '(.-)(.+$)', '%2'), '(^[^%]+)', '%1'), '(.-)(.-%2)', '%3'), '(.-)(.-%2)', '%4')\n\
    \  return #matches + #string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string,\
    \ '(.-)(.+$)', '%2'), '(^[^%]+)', '%1'), '(.-)(.-%2)', '%3'), '(.-)(.-%2)', '%4')\n\
    \  return #matches + #string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string,\
    \ '(.-)(.+$)', '%2'), '(^[^%]+)', '%1'), '(.-)(.-%2)', '%3'), '(.-)(.-%2)', '%4')\n\
    \  return #matches + #string.gsub(string.gsub(", "    local count = 0\n    for\
    \ c in string.gmatch(string, \"(.-)\"..substring..\"(.-)\") do\n        count\
    \ = count + 1\n    end -- end for\n    return count\nend -- end how_many_times",
  "  local count = 0\n  for i = 1, #string do\n    if string.find(substring, string,\
    \ 1, i) == i then\n      count = count + 1\n    end\n  end\n  return count\nend",
  "  local start = 0 -- Start index in the original string.\n  while start <= #string\
    \ do\n    local substring_index = string:find(substring, start)\n    if substring_index\
    \ == nil then\n      start = start + 1 -- Found the last occurrence of the substring.\n\
    \    elseif substring_index > start then\n      return substring_index - start\
    \ + 1 -- Found the first occurrence of the substring.\n    end\n    start = substring_index\
    \ + 1 -- Increment the start index in the original string.\n  end\n  return 0\
    \ -- No occurrence of the substring was found.\nend", "\t-- This code does not\
    \ work when substring is empty\n\tif not string then\n\t\treturn 0\n\tend", " \
    \  if string == '' or substring == '' then return 0 end\n   local string_length\
    \ = #string\n   local substring_length = #substring\n   if string_length <= 0\
    \ or substring_length <= 0 then return 0 end\n   local count = string_length -\
    \ substring_length\n   for i = 1, string_length do\n      if string.sub(i, substring_length)\
    \ == substring then count = count + 1 end\n   end\n   return count\nend", "  local\
    \ number_of_substrings = 0\n  local index = string.find(string, substring)\n \
    \ while index do\n    index = string.find(substring, index, string) + 1\n    number_of_substrings\
    \ = number_of_substrings + 1\n  end\n  return number_of_substrings\nend", "  local\
    \ i = 0\n  for _ in string:gmatch(\"(.-)\" .. substring) do\n    i = i + 1\n \
    \ end\n  return i\nend", "    return string.gsub(string, substring, '%s').gsub('(.-)%s'..substring,\
    \ '%1'):gsub('(..)'..substring, '%1'):gsub('(.-)%s*'%substring, '%1'):gsub('(..)%s*'%substring,\
    \ '%1')\nend", "  if string == nil then return 0 end\n  if substring == nil then\
    \ return 1 end", "   if string == nil then\n      string = ''\n   end\n   if substring\
    \ == nil then\n      substring = ''\n   end\n   local count = 0\n   for s in string.gmatch(string,\
    \ '%S+') do\n      if s == substring then\n         count = count + 1\n      elseif\
    \ s:sub(1, #substring) == substring then\n         count = count + 1\n      end\n\
    \   end\n   return count\nend", "\tlocal count = 0\n\twhile true do\n\t\tlocal\
    \ index = string.find(string, substring)\n\t\tif index == nil then\n\t\t\treturn\
    \ count\n\t\tend\n\t\tcount = count + 1\n\t\tif index > 0 then\n\t\t\tstring =\
    \ string.sub(string, index + #substring)\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\
    \treturn count\nend", "    local result = 1\n    if string.find(string, substring)\
    \ ~= nil then\n        while string.find(string, substring, 1, true) ~= nil do\n\
    \            -- Found a matching substring. Increase the counter.\n          \
    \  local start_index = string.find(string, substring, 1, true)\n            if\
    \ start_index > 0 then\n                result = result + 1\n            end\n\
    \            -- Continue with other possible matches.\n            string = string.sub(string,\
    \ start_index + 1, string.len(string))\n        end\n    end\n    return result\n\
    end", "  local count_string\n  local count_substring\n  count_string = 0\n  count_substring\
    \ = 0\n  for i = 1, #string do\n    if string.sub(i, #string + #substring) ==\
    \ substring then\n      count_substring = count_substring + 1\n      count_string\
    \ = count_string + 1\n    end\n  end\n  return count_string + count_substring\n\
    end", "    local substring_index = string.find(string, substring)\n    return\
    \ substring_index and substring_index or 0\nend", "    if string == nil or substring\
    \ == nil then\n        return 0\n    end\n    local count = 0\n    for char in\
    \ string.gmatch(string, \"[^\" .. substring .. \"]+\") do\n        if string.find(string,\
    \ char, substring, 1, true) then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "\tlocal substring_positions = {}\n\tfor i =\
    \ 1, #substring do\n\t\tlocal index = string.find(string, substring, i)\n\t\t\
    if index == nil then\n\t\t\treturn 0\n\t\telseif index > i then\n\t\t\ttable.insert(substring_positions,\
    \ index)\n\t\tend\n\tend\n\tlocal number_of_overlapping_characters = 0\n\tfor\
    \ _, index in pairs(substring_positions) do\n\t\tnumber_of_overlapping_characters\
    \ = number_of_overlapping_characters + 1\n\tend\n\treturn #substring_positions\n\
    end", "  if string == nil or substring == nil then\n    return 0\n  end\n  local\
    \ count = 0\n  while true do\n    local pos = string.find(string, substring, 1,\
    \ true)\n    if pos == nil then\n      break\n    end\n    count = count + 1\n\
    \  end\n  return count\nend", "    local count = string:find(substring)\n    count\
    \ = count and count + 1 or 1\n    return count:gsub('(.-):*$','%1')\nend", " \
    \   local result = 0\n    for i = 1, #string do\n        if string[i] == substring\
    \ then\n            assert(i > 1)\n            result = result + 1\n        end\n\
    \    end\n    return result\nend", "    if string == nil or substring == nil then\
    \ return 0 end\n    local number_of_times = 0\n    local string_length = string:len()\n\
    \    local substring_length = substring:len()\n    for i = 1, string_length do\n\
    \        if string.sub(i, string_length) == substring then number_of_times = number_of_times\
    \ + 1 end\n    end\n    for i = 1, substring_length do\n        local substring_start\
    \ = string.sub(i, substring_length)\n        if substring_start and substring_start:find(substring)\
    \ then\n            number_of_times = number_of_times + 1\n        end\n    end\n\
    \    return number_of_times\nend", "  -- Count how many times substring occurs\
    \ in string\n  local string_length = len(string)\n  local substring_index = string.find(substring,\
    \ 1, true)\n  if substring_index == nil then\n    -- Substring not found\n   \
    \ return 0\n  else\n    -- Found substring\n    return substring_index - 1\n \
    \ end\nend", "  return #string <= 0 or\n    not #substring <= 0 or\n    not string.substring\
    \ or\n    not string.gsub or #string.gsub(string, substring, \"\") > 0 or\n  \
    \  not string.gsub or string.gsub(string, substring, \"\", 1) == 0\nend", "  local\
    \ count = 1\n  for i = 1, string.len(substring) do\n    local start_index = string.find(string,\
    \ substring, 1, i)\n    if start_index == nil then break end\n    count = count\
    \ + 1\n    i = start_index + 1\n  end\n  return count\nend", "    return string.gsub(string,\
    \ substring, \"\"):gsub(\"^%s*(.-)%s*$\", function(match) return string.sub(s,\
    \ string.len(match)) end)\nend", "\tlocal count = 0\n\tfor i, _ in ipairs(string.gsub(string,\
    \ substring)) do\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "\treturn\
    \ string.gsub(string, substring, '%1'..substring..'%1')\nend", "    local matches\
    \ = 0\n    for i = 1, #string do\n        if string.find(substring, string[i])\
    \ ~= nil then\n            matches = matches + 1\n        end\n    end\n    return\
    \ matches\nend", "    if string == nil then\n        return 0\n    end", "\treturn\
    \ (string.gsub(string, substring) or 0) + (string.gsub('%' .. substring .. '$',\
    \ substring) or 0)\nend", "    if string == nil then return 0 end\n    if substring\
    \ == nil then return 0 end\n    local count = 0\n    while true do\n        local\
    \ pos = string.find(substring, string, 1, true)\n        if pos == nil then break\
    \ end\n        count = count + 1\n        string = string.sub(string, pos + 1)\n\
    \    end\n    return count\nend", "    if not string or substring == string then\n\
    \        return 0\n    end\n    if string.find(string) then\n        return string.find(string)\
    \ + 1\n    elseif string.find(substring, 1, string.len(string)) then\n       \
    \ return string.find(substring, 1, string.len(string)) + 1\n    end\n    return\
    \ 0\nend", "   local count = 0\n   while string and substring ~= \"\" do\n   \
    \   -- Find the index that has the current substring and add one to it.\n    \
    \  -- If the substring isn't found then add 1 to the index.\n      local index\
    \ = string.find(substring, 1, true)\n      if not index then\n         index =\
    \ #string\n      end\n      count = count + 1\n      string = string.sub(string,\
    \ index + 1) -- Ignore the substring that is being searched.\n   end\n   return\
    \ count\nend", "\tlocal count = 0\n\tlocal s = string\n\twhile true do\n\t\tlocal\
    \ new_s = s:sub(1, #substring + 1)\n\t\tif new_s == substring then\n\t\t\tcount\
    \ = count + 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\t\ts = s.sub(new_s)\n\tend\n\t\
    return count\nend", "    local count = 0\n    for index, value in ipairs(string)\
    \ do\n        if value == substring then\n            count = count + 1\n    \
    \    elseif value == substring and string.find(value, substring, index - 1, true)\
    \ ~= nil then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "    local substring = string.gsub(substring, function(c) return\
    \ '%c' end, '_')\n    local matches = 0\n    for substring_ in string.gsub(substring,\
    \ {'%_', '%c', '%s'}, '') do\n        local substring = string.gsub(substring_,\
    \ '%c', '')\n        matches = matches + string.find(string, substring, 1, true)\
    \ - string.find(string, substring_, 1, true)\n    end\n    return matches\nend",
  "  return string.gsub(string, substring, ''):gsub('[^'..substring.']]', '')\nend",
  "\tlocal count_ = 0\n\tlocal pattern = '^' .. string.gsub(substring.l, '.', '[%z+%.]')\n\
    \tlocal regex = string.gsub(pattern, '([%z+%.])', '([^%s]+)'):gsub('%%s', '')\n\
    \tlocal i = 1, #string\n\twhile i <= #string do\n\t\tlocal result = string.gsub(string,\
    \ '.', '[%z+%.]'):gsub(regex, '%1'):gsub('%%s', '')\n\t\tif result == string.gsub(string,\
    \ '.', '[%z+%.]'):gsub(regex, '%2') then\n\t\t\tcount_ = count_ + 1\n\t\t\ti =\
    \ i + 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn count_\nend", "  local\
    \ count = 0\n  for char in string do\n    if string.find(substring, char, 1, true)\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "  local\
    \ result = 1\n  for _, b in ipairs(string) do\n    if b:sub(1, #substring) ==\
    \ substring then\n      result = result + 1\n    end\n  end\n  return result\n\
    end", "    local count = 0\n    local last_index = string.find(string, substring,\
    \ 1)\n    while last_index do\n        count = count + 1\n        last_index =\
    \ string.find(string, substring, last_index + 1) -- Skip overlapping cases\n \
    \   end\n    return count\nend", "    return string.match(string, '%a') == nil\
    \ and 0 or string.match(string, '%a'):gsub(substring, function(a, c)\n       \
    \ return string.match(a, '%a') ~= nil and string.match(a, '%a'):gsub(substring,\
    \ function(a, c)\n            return string.match(a, '%a'):gsub(substring, function(a,\
    \ c)\n                return string.match(a, '%a'):gsub(substring, function(a,\
    \ c)\n                    return string.match(a, '%a'):gsub(substring, function(a,\
    \ c)\n                        return string.match(a, '%a'):gsub(substring, function(a,\
    \ c)\n                            return string.match(a, '%a'):gsub(substring,\
    \ function(a, c)\n                                return string.match(a, '%a'):gsub(substring,\
    \ function(a, c)\n                                    return string.match(a, '%a'):gsub(substring,\
    \ function(a, c)\n                                        return string.match(a,\
    \ '%a'):gsub(substring, function(a, c)\n                                     \
    \       return string.match(a, '%a'):gsub(substring, function(a, c)\n        \
    \                                        return string.match(a, '%a'):gsub(substring,\
    \ function(a, c)\n                                                    return string.match(a,\
    \ '%a'):gsub(substring, function(a, c)\n                                     \
    \                   return string.match(a, '%a'):gsub(substring, function(a, c)\n\
    \                                                            return string.match(a,\
    \ '%a'):gsub(substring, function(a, c)\n                                     \
    \                           return string.match(a, '%a'):gsub(substring, function(a,\
    \ c)\n                                                                    return\
    \ string.match(a, '%a'):gsub(substring, function(a, c)\n                     \
    \                                                   return string.match(a, '%a'):gsub(substring,\
    \ function(a, c)\n                                                           \
    \                 return string.match(a, '%a'):gsub(substring, function(a, c)\n\
    \                                                                            \
    \    return string.match(a, '%a'):gsub(substring, function(a, c)\n           \
    \                                                                         return\
    \ string.match(a, '%a'):gsub(substring, function(a, c)\n                     \
    \                                                                   return string.match(a,\
    \ '%a'):gsub(substring, function(a, c)\n                                     \
    \                                                       return string.match(a,\
    \ '%a'):gsub(substring, function(a, c)\n                                     \
    \                                                           return string.match(a,\
    \ '%a'):gsub(substring, function(a, c)\n                                     \
    \                                                               return string.match(a,\
    \ '%a'):gsub(substring, function(a, c)\n                                     \
    \                                                                   return string.match(a,\
    \ '%a'):gsub(substring, function(a, c)\n                                     \
    \                                                                       return\
    \ string.match(a, '%a'):gsub(substring, function(a, c)\n                     \
    \                                                                            \
    \               return string.match(a, '%a'):gsub(substring, function(a, c)\n\
    \                                                                            \
    \                                        return string.match(a, '%a'):gsub(substring,\
    \ function", "    local count = 0\n    for _, s in string.gmatch(\"(.-)\"..substring..\"\
    (.-)\") do\n        count = count + 1\n    end\n    return count\nend", "\t--\
    \ Find position of substring.\n\tlocal position = 0\n\twhile position <= #string\
    \ do\n\t\tposition = string.find(string, substring, position)\n\t\tif position\
    \ ~= nil then return 1 + position - 1 end\n\t\tposition = string.len(string) +\
    \ 1\n\tend\n\treturn 0\nend", "\treturn string.gsub(string, substring, function()\n\
    \t\tlocal start\n\t\tlocal stop\n\t\tlocal startlen\n\t\tlocal stoplen\n\t\tlocal\
    \ last\n\t\tfor start = 1, string.len(substring) do\n\t\t\tif string.sub(string,\
    \ start, start + 1) ~= substring then\n\t\t\t\treturn string\n\t\t\tend\n\t\t\
    end\n\t\tstartlen = 1\n\t\tfor stop = (string.len(substring) + 1) - 1, string.len(string)\
    \ do\n\t\t\tif string.sub(string, (string.len(substring) + 1) - 1, stop) ~= substring\
    \ then\n\t\t\t\treturn string\n\t\t\tend\n\t\tend\n\t\tstoplen = string.len(substring)\
    \ + 1\n\t\tlast = string.sub(string, (string.len(substring) + 1) - 1, string.len(string))\n\
    \t\tif last ~= substring then\n\t\t\treturn string\n\t\tend\n\t\treturn string.len(substring)\
    \ * how_many_times(string.sub(string, 1, stoplen), substring)\n\tend)\nend", " \
    \ if string == nil then return 0 end\n  if string == substring then return 1 end\n\
    \  local count = 1\n  for i = 1, #string do\n    if string.sub(i, i) ~= substring\
    \ then\n      if count > 1 then\n        return count\n      else\n        count\
    \ = count + 1\n      end\n    end\n  end\n  return count\nend", "\treturn (string.gsub(string,\
    \ substring, 1, 'g') or 0) + (string.gsub(string, substring, '', 'g') or 0)\n\
    end", "  local n = #string\n  if n == 0 then return 0 end\n  local result = 0\n\
    \  for i = 1, #substring do -- Binary search\n    local m = math.ceil((n - i)\
    \ / 2) + i\n    if string[i] == substring[i] then\n      result = result + 1\n\
    \      if m ~= n then -- Overlap\n        if m - i < #string and string[m] ==\
    \ substring[m - 1] then\n          result = result + 1\n        end\n      end\n\
    \    end\n  end\n  return result\nend", "  if string == '' or string == nil then\n\
    \    return 0\n  end\n  local count = 0;\n  local pos = 1;\n  while pos < string.len()\
    \ do\n    if string.substring (pos, pos + #substring) == substring then\n    \
    \  count = count + 1\n    end\n    pos = pos + #substring\n  end\n  return count\n\
    end", "  local substring_index = 1\n  local string_length = #string\n  while substring_index\
    \ <= string_length do\n    local position = string.find(string, substring, substring_index)\n\
    \    if position == nil then\n      return 0\n    end\n    substring_index = position\
    \ + 1\n  end\n  return substring_index - 1 -- The last index should be the length\
    \ of the substring\nend", "\tif string == substring or string == '' then\n\t\t\
    return 0\n\tend\n\tlocal count = 0\n\tfor char in string:gmatch('%a') do\n\t\t\
    if string.find(substring, char, 0, true) then\n\t\t\tcount = count + 1\n\t\tend\n\
    \tend\n\treturn count\nend", "  return string.match(string, \"[\"..substring..\"\
    *]+\") or 0\nend", "  local count = 0\n  for sub in string:gmatch(\"(.-)%S+\"\
    ) do\n    if sub == substring then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "    if not string then\n        return 0\n    end\n  \
    \  local count = 0\n    for _, _, c in string.gmatch(\"[\" .. substring .. \"\
    ]\") do\n        count = count + 1\n    end\n    return count\nend", '    if not
    substring or string == substring then return 0 end', "  return string.gsub(string,\
    \ substring, 1, true) - string.gsub(string, substring, 1, 1)\nend", "    return\
    \ string.gsub(string, string, \"[^\"..substring..\"]\"):gsub(\"^[^\"..substring..\"\
    ]\", \"\"):gsub(\"[^\"..substring..\"]$\", \"\"):gsub(\"^[^\"..substring..\"]\"\
    , \"\"):gsub(\"^[^\"..substring..\"]\", \"\"):gsub(\"^[^\"..substring..\"]\",\
    \ \"\"):gsub(\"^[^\"..substring..\"]\", \"\"):gsub(\"^[^\"..substring..\"]\",\
    \ \"\"):gsub(\"^[^\"..substring..\"]\", \"\"):gsub(\"^[^\"..substring..\"]\",\
    \ \"\"):gsub(\"^[^\"..substring..\"]\", \"\"):gsub(\"^[^\"..substring..\"]\",\
    \ \"\")\nend", "   if string == '' or string == nil then\n      return 0\n   end\n\
    \   if string.find(substring) then\n      local count = string.find(substring)\n\
    \      return count\n   else\n      return 1\n   end\nend", "  -- If the input\
    \ string is empty, return 0.\n  if string == nil then return 0 end\n  -- The substring's\
    \ length is the string's length.\n  local substring_size = #substring\n  -- If\
    \ the input string's length is 0, return 0.\n  if string_size == 0 then return\
    \ 0 end\n  -- If the substring is too long, return 0.\n  if substring_size > string_size\
    \ then return 0 end\n  -- The overlapping count is the sum of the substring length.\n\
    \  local overlapping_count = string_size + substring_size\n  -- The total count\
    \ is the sum of the previous overlapping and non-overlapping counts.\n  local\
    \ total_count = overlapping_count + how_many_times(string, substring, overlapping_count\
    \ + 1)\n  return total_count\nend", "  return string.gsub(string.gsub(string,\
    \ substring, 1, 'g'), substring, 1, 'g'):match(\"%S+\") or (string.gsub(string,\
    \ substring, 1, 'g'):match(\"[^\"..string.char(substring):gsub(\"%S\",'')..\"\
    ]+\") or 0):gsub(\"%S+\", \"\")\nend", "    if not string or string.len == 0 or\
    \ substring == nil then\n        return 0\n    end\n    local count = 0\n    for\
    \ i = 1,string.len do\n        if string.sub(i, i, string) == substring then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "    if string == '' then\n        return 0\n    end\n    if substring == '' then\n\
    \        return string.count('a')\n    end", "    return string.gsub(string, \"\
    [\"..substring..\"]\"):gsub(\"(.)\"..substring, \"\\1\"):gsub(\"[\"..substring..\"\
    ](.)\"..substring, \"\"):gsub(\"\\\\1\", \"1\")\nend", "  local count = 0\n  for\
    \ _, char in string.gmatch(string, \"([^\"..tostring(substring)..\"]+)\") do\n\
    \    count = count + 1\n  end\n  return count\nend", "  if string == nil or substring\
    \ == nil then return 0 end\n  local result = 1\n  for i = 1, #string do\n    if\
    \ string.sub(i, i) ~= substring then\n      result = result + 1\n    end\n  end\n\
    \  return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
