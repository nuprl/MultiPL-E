name: HumanEval_108_count_nums
language: lua
prompt: "-- Write a function count_nums which takes an array of integers and returns\n\
  -- the number of elements which has a sum of digits > 0.\n-- If a number is negative,\
  \ then its first signed digit will be negative:\n-- e.g. -123 has signed digits\
  \ -1, 2, and 3.\n-- >>> count_nums([]) == 0\n-- >>> count_nums([-1, 11, -11]) ==\
  \ 1\n-- >>> count_nums([1, 1, 2]) == 3\nlocal function count_nums(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_nums\n\
  \    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({-1, -2, 0}),\
  \ 0)\n    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)\n    lu.assertEquals(candidate({1,\
  \ 6, 9, -6, 0, 1, 5}), 5)\n    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}),\
  \ 4)\n    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)\n    lu.assertEquals(candidate({0,\
  \ 1}), 1)\n    lu.assertEquals(candidate({1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local count = 0\n    for _, i in ipairs(arr) do\n        if i >\
    \ 0 then\n            count = count + i\n        end\n    end\n    return count\n\
    end", "  -- Write your code below!\n  -- arr is a list of numbers\n  -- return\
    \ an integer\n  -- return 0 for an empty array\n  return 0 \nend", "  local n\
    \ = 0\n  for i = 1, #arr do\n    local sum = 0\n    for j = 1, 10 do\n      sum\
    \ = sum + arr[i]\n      if sum > 0 then\n        return n\n      end\n    end\n\
    \    n = n + 1\n  end\n  return n\nend", "   local num_sum = 0\n   for i = 1,\
    \ #arr do\n      num_sum = num_sum + tostring(arr[i])\n      if num_sum > 0 then\n\
    \         return i + 1\n      end\n   end\nend", "\tlocal count\n\tfor i = 1,\
    \ #arr do\n\t\tcount = count + arr[i]\n\tend\n\treturn count\nend", "  local count\
    \ = 0\n  for i = 1, #arr do\n    if isnumber(arr[i]) and arr[i] > 0 then\n   \
    \   count = count + 1\n    end\n  end\n  return count\nend", "  if #arr == 0 then\
    \ return 0 end\n  local cnt = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n\
    \      cnt = cnt + 1\n    end\n  end\n  return cnt\nend\ncount_nums = wrap_lua_function(count_nums)",
  "  -- Return the number of elements which has sum digits > 0.\n  -- Note that this\
    \ assumes there will be at least one number with a sum digit.\n  -- If there are\
    \ no such numbers, then return 0.\n  local num_with_sum_digits = 0\n  -- For every\
    \ number in the array, if the sum of its digits > 0, then\n  -- increment the\
    \ counter.\n  for _, num in pairs(arr) do\n    -- The number starts with the least\
    \ signficant digit.\n    local num_without_sum_digits = num:sub(1,1)\n    -- Iterate\
    \ from the second digit and add each digit to the total number\n    -- of such\
    \ numbers.\n    for _, sum_digit in ipairs(num_without_sum_digits) do\n      num_with_sum_digits\
    \ = num_with_sum_digits + 1\n    end\n  end\n  return num_with_sum_digits\nend",
  "    local count = 0\n    for i = 1, #arr do\n        count = count + arr[i]\n \
    \       if arr[i] < 0 then\n            count = count + (-arr[i]) ^ 1\n      \
    \  end\n    end\n    return count\nend", "    local count = 0\n    for i=1,#arr\
    \ do\n        count = count + count_digits(arr[i])\n    end\n    return count\n\
    end", "    local count = 0\n    for i = 1, #arr do\n        local n = (arr[i]\
    \ + 48) % 96\n        if n > 0 then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend\ncount_nums = count_nums -- make \"count_nums\"\
    \ visible in LuaJIT's REPL", "  local n = 0\n  for i = 1, #arr do\n    local n\
    \ = n - count_digits(tostring(arr[i]))\n  end\n  return n\nend", "  -- Write your\
    \ code here\n  local n = 0\n  local sign = 1\n  for i = 1, #arr do\n    local\
    \ sum = 0\n    for j = 1, i do\n      sum = sum + (arr[j] * sign)\n    end\n \
    \   if sum ~= 0 then\n      n = n + 1\n      if sum > 0 then\n        sign = math.floor(math.abs(sum))\n\
    \      else\n        sign = math.ceil(math.abs(sum))\n      end\n    end\n  end\n\
    \  return n\nend", "  local n = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n\
    \      n = n + #arr + 1 - i\n    end\n  end\n  return n\nend", "    local cnt\
    \ = 0\n    for i = 1, #arr do\n        local n = arr[i]\n        if n > 0 then\n\
    \            cnt = cnt + math.floor((math.log10(n) + 1) / (LOG_BASE_FACTOR + 1))\n\
    \        end\n    end\n    return cnt\nend", "  local count = 0\n  for i, v in\
    \ pairs(arr) do\n    count = count + math.abs(v)\n  end\n  return count\nend",
  "  -- Slightly faster than using table.insert()\n  -- but slower than a loop through\
    \ arr:\n  for i = #arr, 1, -1 do\n    local c = arr[i]\n    if c < 0 then\n  \
    \    c = -c\n    end\n    arr[i] = c\n  end\n  local n = 0\n  for i = #arr, 1,\
    \ -1 do\n    if arr[i] > 0 then\n      n = n + 1\n    end\n  end\n  return n\n\
    end", "  if arr == nil then\n    return 0\n  end\n  local num_sum = 0\n  for _,\
    \ value in pairs(arr) do\n    num_sum = num_sum + digits(value)\n  end\n  return\
    \ num_sum\nend", "  if arr[#arr] < 0 then\n    arr[1] = -(arr[1] + 1) -- Negative\
    \ number has a first signed digit.\n  end\n  local result = 0\n  for i = 1, #arr\
    \ do\n    if arr[i] > 0 then\n      result = result + 1\n    end\n  end\n  return\
    \ result\nend", "  if #arr == 0 then\n    return 0\n  end\n  local result = 0\n\
    \  for i = 1, #arr do\n    local digit = arr[i]\n    if digit < 0 then\n     \
    \ result = (digit - 9) * (-1)\n    elseif digit >= 0 then\n      result = result\
    \ + digit\n    end\n  end\n  return result\nend", "  local n = 0\n  for i = 1,\
    \ #arr do\n    local v = tonumber(arr[i])\n    if v < 0 then\n      if i == 1\
    \ then\n        n = -n\n      end\n      v *= -1\n    end\n    n = v + n\n  end\n\
    \  return n\nend", "    local result = 0\n    for _,v in ipairs(arr) do\n    \
    \    -- If this value has a negative sign, we need to subtract it\n        --\
    \ before we can check whether it's a sum of digits.\n        if v < 0 then\n \
    \           v = -v\n        end\n        result = result + v\n    end\n    return\
    \ result\nend", "  -- Special case for empty array:\n  if not arr then return\
    \ 0 end", "  local n = 0\n  for i = 2, #arr do\n    if arr[i] > 0 then\n     \
    \ n = n + 1\n    end\n  end\n  return n\nend", "    local n = 0\n    for i = 1,\
    \ #arr do\n        local count = 0\n        for j = 1, math.floor(math.log10(arr[i]))+1\
    \ do\n            if arr[i] % 10 == 0 then count = count + 1 end\n           \
    \ i = i // 10\n        end\n        if count > 0 then n = n + count end\n    end\n\
    \    return n\nend", "   local count = 0\n   for _, v in pairs(arr) do\n     \
    \ if not math.abs(v) > math.abs(v + 1) then\n         count = count + 1\n    \
    \  end\n   end\n   return count\nend", "    if arr == nil then\n        return\
    \ 0\n    end\n    local n = 0\n    for i = 1, #arr do\n        local v = tonumber(arr[i])\n\
    \        if v < 0 then\n            n = 0 - n\n        end\n        n = n + (v\
    \ % 10 + 9) % 10\n    end\n    return n\nend", "  local count_num = 0\n  for i\
    \ = 1, #arr do\n    local tmp_count_num = count_num\n    local tmp_sum_of_digits\
    \ = 0\n    for j = 1, #arr do\n      tmp_sum_of_digits = tmp_sum_of_digits + arr[j][i]\n\
    \    end\n    if tmp_sum_of_digits > 0 then\n      count_num = count_num + 1\n\
    \    end\n  end\n  return count_num\nend", "  local count = 0\n  for _, _ in pairs(arr)\
    \ do\n    if arr[_] >= 0 then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "  -- Write your code here.\nend", "    local count = 0\n    for\
    \ i = 1, #arr do\n        if arr[i] > 0 then\n            count = count + 1\n\
    \        end\n    end\n    return count\nend", "  local result = 0\n  local last_signed_digit\
    \ = -1\n  for i = 1, #arr do\n    local element = arr[i]\n    -- If the element\
    \ is not negative,\n    if element < 0 then\n      element = element - last_signed_digit\n\
    \    end\n    -- If the element has a negative sign then add it to the result\n\
    \    -- as if the element had a positive sign\n    if element < 0 then\n     \
    \ result = result + 1\n      element = element + 10\n    end\n    -- If the element\
    \ has a positive sign, then subtract it from the\n    -- last sign of the last\
    \ element in the array\n    if element > last_signed_digit then\n      result\
    \ = result + 1\n    end\n    last_signed_digit = element\n  end\n  return result\n\
    end", "    local n = 0\n    for i = 1, #arr do\n        local x = tonumber(arr[i])\n\
    \        if x then\n            if x < 0 then\n                n = n - 1 + count_nums(arr[#arr\
    \ + 1 .. i])\n            else\n                n = n + 1\n            end\n \
    \       end\n    end\n    return n\nend", "  local count = 0\n  for i in arr do\n\
    \    if i > 0 then\n      count = count + count_nums(math.abs(i) + 1)\n    end\n\
    \  end\n  return count\nend", "    local count = 0\n    for i = 1, #arr do\n \
    \       local sign = arr[i]\n        if sign < 0 then\n            sign = -sign\n\
    \        end\n        if sign ~= 0 and sign % 2 == 1 then\n            count =\
    \ count + 1\n        end\n    end\n    return count\nend", "    local n = 0\n\
    \    for i = 1, #arr do\n        local t = arr[i]\n        if t < 0 then\n   \
    \         t = -arr[i]\n        end\n        if t ~= 0 then\n            n = n\
    \ + 1\n        end\n    end\n    return n\nend", "  local count = 0\n  for i =\
    \ 1, #arr do\n    local digit = arr[i]\n    if digit > 0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  local n = 0\n  for i = 1, #arr\
    \ do\n    n = n + tonumber(arr[i]) * math.pow(10, #arr-i-1)\n  end\n  return n\n\
    end", "  -- Initialize result and count variables.\n  local result, count = 0,\
    \ 0\n  -- Loop through array.\n  for i = 1, #arr do\n    -- Get the current number\
    \ in array.\n    local num = arr[i]\n    -- See if first digit is positive or\
    \ negative.\n    local is_negative = num < 0\n    -- Add 1 to the result for each\
    \ digit that has a sum greater than 0.\n    if is_negative then\n      -- Multiply\
    \ by -1 to give a positive number.\n      num = -num\n    end\n    -- Get the\
    \ sum of digits in number.\n    local sum_digits = sum(digits(num))\n    -- Add\
    \ 1 to result if sum_digits > 0.\n    if sum_digits > 0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  if is_nil(arr) then\n    return\
    \ 0\n  elseif is_number(arr) then\n    return 1\n  else\n    local n = 1\n   \
    \ for _, v in ipairs(arr) do\n      if v > 0 then\n        n = (n * 10) + v\n\
    \      else\n        break\n      end\n    end\n    return n\n  end\nend", " \
    \   local count = 0\n    for _, _ in pairs(arr) do\n        count = count + 1\n\
    \    end\n    return count\nend", "    local n = 0\n    for i = 1, #arr do\n \
    \       n = n + (arr[i] + i - 1)\n    end\n    return n\nend", "  local n = 1\n\
    \  for i = 1, #arr do\n    local d = tostring(arr[i])\n    if d ~= '0' and d ~=\
    \ '1' then\n      n = n + 1\n    end\n  end\n  return n\nend", "  local n = 0\n\
    \  for i = 1, #arr do\n    local digit = tonumber(arr[i])\n    if digit < 0 then\n\
    \      n = n + abs(digit) * 10\n    else\n      n = n + digit\n    end\n  end\n\
    \  return n\nend", "  local n = 0\n  for i = 2, #arr do\n    n = n + 1\n    local\
    \ d = 0\n    for d = -10, 10 do\n      local s = 0\n      local x = arr[i]\n \
    \     for x = x - d, 10 do\n        s = s + 1\n      end\n      if s == 10 then\n\
    \        n = n + 1\n      end\n    end\n  end\n  return n\nend", "   local sum\
    \ = 0\n   for v in arr do\n      sum = sum + v\n   end\n   return sum\nend", " \
    \ local sum = 0\n  for i = 1, #arr do\n    sum = sum + arr[i]\n    if sum > 0\
    \ then return i end\n  end\n  return 0\nend", "    local count = 0\n    for i\
    \ = 2, #arr do\n        if arr[i] > 0 then\n            count = count + 1\n  \
    \      end\n    end\n    return count\nend", "  -- Initialize result to zero.\n\
    \  local result = 0", "  if arr == nil then return 0 end\n  if #arr == 1 then\n\
    \    if tonumber(arr[1]) > 0 then\n      return 1\n    end\n    return 0\n  else\n\
    \    local count = arr[1]\n    for i = 2, #arr do\n      count = count + count_nums(arr[i]\
    \ - tonumber(arr[i-1]))\n    end\n    return count\n  end\nend", "    local count\
    \ = 0\n    for i = 1, #arr do\n        if arr[i] > 0 then\n            count =\
    \ count + 1\n        else\n            count = count - count_digits(arr[i]) +\
    \ 1\n        end\n    end\n    return count\nend\ncount_nums = count_nums", " \
    \ local n = 0\n  for i = 1, #arr do\n    local num = 0\n    while #arr - i >=\
    \ 0 do\n      local k = arr[i + #arr + num + 1] - 1\n      if k > 0 then\n   \
    \     num = k\n        break\n      else\n        num = -1\n      end\n    end\n\
    \    n = n + (num > 0 and num)\n  end\n  return n\nend", "  -- The return value\n\
    \  local c = 0\n  -- Loop over the array\n  for i, v in ipairs(arr) do\n    local\
    \ digit = 0\n    -- If the value is negative\n    if v < 0 then\n      -- Get\
    \ the first digit\n      digit = v / math.pow(10, abs(v))\n      -- Multiply the\
    \ number by its sign and subtract it\n      v = v - (math.pow(10, abs(v)) * digit)\n\
    \    end\n    -- Add the digit\n    c = c + math.floor(v)\n  end\n  -- Return\
    \ the number of elements whose sum is > 0\n  return c\nend\n</cell>\n<text>\n\
    Let's test our count_nums function by counting the number of elements with a sum\
    \ of digits > 0.", "    local n = 0\n    for i = 1,#arr do\n        n = n + (arr[i]\
    \ * math.floor((arr[i]) / math.pow(10, #arr-i)))\n    end\n    return n\nend",
  "  return #arr:reduce(function(n, x)\n    if x > 0 then\n      return n + count_digits(x)\n\
    \    else\n      if x ~= 0 then\n        return -n + count_digits(-x)\n      end\n\
    \    end\n  end)\nend", "    local count = 0\n    for _ in arr do\n        count\
    \ = count + 1\n    end\n    return count\nend", "    if arr then\n        for\
    \ v in arr do\n            if v then\n                return 1\n            end\n\
    \        end\n    end\nend", "    local num_count = 0\n    for i = 1, #arr do\n\
    \        if arr[i] > 0 then\n            num_count = num_count + 1\n        end\n\
    \    end\n    return num_count\nend", "  local nums = 0\n  local total = 0\n \
    \ for i = 1, #arr do\n    local v = array[i]\n    if v then\n      total = total\
    \ + v\n      nums = nums + 1\n    end\n  end\n  return nums\nend", "  local n\
    \ = 0\n  for i = 1, #arr do\n    n = n + (arr[i] > 0 and (arr[i] % 10) or 0)\n\
    \  end\n  return n\nend", "  local count = -- (#arr + 1) * (#arr + 1) -- Multiplication\
    \ by two.\n  for i = 2, #arr do\n    if arr[i] == 0 then break end\n    count\
    \ = count + (#arr + 1) * (#arr + 1) - (2 * i + 1) -- Multiplication by i, minus\
    \ two.\n  end\n  return count\nend", "  -- Write your function here!\n  -- Make\
    \ sure it works with negative numbers.\n  -- Use the first element of the arr\
    \ to test if its positive.\n  -- If positive, return 1, if negative, return -1.\n\
    \  if arr[1] == nil then\n    return 0\n  end\n  if arr[#arr] < 0 then\n    arr[#arr]\
    \ = -arr[#arr]\n    return -count_nums(arr)\n  end\n  local result = 0\n  for\
    \ i = 1, #arr do\n    result = result + arr[i - 1]\n    if result == 0 and i >\
    \ 1 then\n      result = result - 1\n    end\n  end\n  if result == 0 then\n \
    \   return 0\n  end\n  return result\nend", "  local n = 0\n  local total = 0\n\
    \  for i = 1, #arr do\n    total = total + tonumber(arr[i])\n    if total > 0\
    \ then\n      n = n + 1\n      total = total - tonumber(arr[i])\n    end\n  end\n\
    \  return n\nend", "    local sum = 0\n    for i = 1, #arr do\n        sum = sum\
    \ + arr[i]\n    end\n    if sum ~= 0 and sum < 0 then\n        sum = sum + #arr\n\
    \    end\n    return sum\nend", "  local n = 0\n  for i = 1, #arr do\n    local\
    \ n = n + (i > 0 and arr[i] > 0 and arr[i] % 10)\n  end\n  return n\nend", " \
    \ local count = 0\n  for i = 1, #arr do\n    -- If number has digits, the number\
    \ has a sum of digits > 0\n    if arr[i] ~= 0 then\n      count = count + 1\n\
    \    end\n    -- If number is negative, first sign digit will be negative\n  \
    \  if arr[i] < 0 then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  local count = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n     \
    \ count = count + 1\n      if arr[i] < 10 then\n        count = count + math.floor(arr[i]\
    \ / 10)\n      else\n        count = count + math.floor(arr[i] / 10) + math.floor(arr[i]\
    \ % 10)\n      end\n    end\n  end\n  return count\nend", "  if #arr == 0 then\n\
    \    return 0\n  end\n  local first, rest = unpack(arr:gsub('(-?%d*)$', function(w)\
    \ return w end))\n  if first then\n    local sign = first < 0 and '-' or ''\n\
    \    local digits = first and first % 10 or 0\n    return #arr + 1 + count_nums(rest\
    \ + (sign(digits and digits % 10) or ''))\n  end\n  local count = 1\n  local last\
    \ = 0\n  for i = 1, #arr do\n    last = last + arr[i]\n    count = count + count_nums(rest)\n\
    \    if last >= 10 then\n      last = last % 10\n      count = count + 1\n   \
    \ end\n  end\n  return count\nend", "  local n = 0\n  \n  for i = 1, #arr do\n\
    \    if arr[i] > 0 then\n      n = n + (arr[i] > 0 and 1 or -1)\n    end\n  end",
  "  -- Write your implementation here.\nend", "  if arr == nil then\n    return 0\n\
    \  else\n    local count = 0\n    for i = 0, #arr do\n      if arr[i] > 0 then\n\
    \        count = count + 1\n      else\n        if arr[i] > -10 then\n       \
    \   count = count + 1\n        else\n          count = count - 1\n        end\n\
    \      end\n    end\n    return count\n  end\nend", "    return math.max(#arr,\
    \ 1)\nend", "    local nums = 0\n    for i = 1, #arr do\n        local x = arr[i]\n\
    \        if x >= 0 then\n            nums = nums + 1\n        else\n         \
    \   local a = x - 1\n            if math.floor(a) == a then\n                nums\
    \ = nums + 1\n            end\n        end\n    end\n    return nums\nend", " \
    \   local count = 0\n    for i, v in ipairs(arr) do\n        if v >= 0 then\n\
    \            count = count + 1\n        else\n            count = count + count_nums(sign(v)\
    \ * v)\n        end\n    end\n    return count\nend", "  if arr == nil then return\
    \ 0 end\n  local count = 0\n  for i = 1, #arr do\n    count = count + (tonumber(arr[i])\
    \ + i * 10)\n  end\n  return count\nend", "   local i = 0\n   for _ in arr do\n\
    \      i = i + 1\n      if arr[i] > 0 then\n         return i\n      end\n   end\n\
    \   return 0\nend", "  for i = 1, #arr do\n    if arr[i] > 0 then\n      local\
    \ num = 0\n      for j = 1, i do\n        if arr[j] >= 10 then\n          num\
    \ = num * 10 + arr[j]\n        else\n          num = num * 10 + arr[j] - 10 +\
    \ (j == i - 1)\n        end\n      end\n      if num > 0 then\n        return\
    \ num\n      end\n    end\n  end\n  return 0\nend\ncount_nums = Curry.__curry(count_nums)",
  "  local count = 0\n  for i = 2, #arr do\n    count = count + arr[i]\n    if count\
    \ > 0 then\n      return count\n    end\n  end\n  return 0\nend", "  local sum\
    \ = 0\n  local i = 1\n  for _ in pairs(arr) do\n    sum = sum + math.abs(math.floor(i\
    \ / 10)) + math.modf(i / 10):int - 1\n    i = i + 1\n  end\n  return sum\nend",
  "    local count = 0\n    for i = 1, #arr do\n        if arr[i] > 0 then\n     \
    \       count = count + 1\n            end\n        end\n    return count\nend",
  "  -- Count number of digits in first non-negative number.\n  -- If number is negative,\
    \ add 1 to negative value.\n  -- Negative numbers are special as they have their\
    \ first digit as -1.\n  return 1 + count_nums(arr:sub(1))\nend", "  local n =\
    \ 0\n  local s = math.abs(arr[1] or 0)\n  for i = 1, #arr do\n    local d = math.abs(arr[i])\n\
    \    if d > 0 then\n      n = n + d\n    elseif d < 0 then\n      s = s - d\n\
    \    end\n  end\n  if s > 0 then\n    n = n - s\n  end\n  return n\nend", "  local\
    \ ret = 0\n  for i = 1, #arr do\n    local n, d = tointeger(arr[i]), arr[i]\n\
    \    if d < 0 then\n      n = -n -- make n positive\n    end\n    if n < 0 then\n\
    \      -- add extra count of negative numbers\n      ret = ret + math.floor(-n\
    \ / 10)\n      n = n % 10\n    end\n    if n < 10 then\n      ret = ret + 1\n\
    \    end\n    if n > 0 then\n      ret = ret + n\n    end\n  end\n  return ret\n\
    end", "  if arr then\n    local sum = 0\n    local count = 0\n    for i=1,#arr\
    \ do\n      sum = sum + math.abs(arr[i])\n      if sum > 0 then\n        count\
    \ = count + 1\n      end\n    end\n    return count\n  else\n    return 0\n  end\n\
    end", "  -- We need to iterate over the array as its elements are not in order.\n\
    \  -- So we can't use a simple table.\n  for i = 1, #arr do\n    -- First we convert\
    \ the number into an array of its digits.\n    local digit_arr = string.format(\"\
    %g\", arr[i])\n    -- We need to loop over all digits in the number until we find\
    \ the one\n    -- which has a sum of digits > 0. This will take us O(n) time as\
    \ we can\n    -- only loop over all digits once.\n    for j = 1, #digit_arr do\n\
    \      if digit_arr[j] ~= 0 then\n        -- If the first digit is a negative\
    \ sign, it's assumed to be negative.\n        if digit_arr[j] < 0 then\n     \
    \     -- If the digit has a sum greater than zero, increase the count.\n     \
    \     if digit_arr[j] + i > 0 then\n            -- If we reach here, then the\
    \ digit has a sum of digits > 0.\n            -- We set the count and break out\
    \ of the loop.\n            i = digit_arr[j] + i\n            break\n        \
    \  end\n        else\n          -- If the digit has a sum less than zero, decrease\
    \ the count.\n          if digit_arr[j] - i < 0 then\n            -- If we reach\
    \ here, then the digit has a sum of digits < 0.\n            -- We set the count\
    \ and break out of the loop.\n            i = digit_arr[j] - i\n            break\n\
    \          end\n        end\n      end\n    end\n    -- If we have found a digit\
    \ with the sum of digits > 0, then the\n    -- number is valid. Set the result\
    \ and break out of the loop.\n    if i ~= 0 then\n      -- If the number is positive,\
    \ then the count is incremented.\n      if arr[i] > 0 then\n        i = i + arr[i]\n\
    \      end\n      -- If the number is negative, then the count is decremented.\n\
    \      if arr[i] < 0 then\n        i = i - arr[i]\n      end\n      return i\n\
    \    end\n  end\n  -- If we reach here, the number is not valid.\n  return 0\n\
    end", "  local n = 0\n  for i = 1, #arr do\n    local d = tonumber(arr[i])\n \
    \   if d > 0 and (d % 10) == 0 then\n      n = n + 1\n    end\n  end\n  return\
    \ n\nend", "  -- Write your code here\n  local result = 0\n  for i = 1, #arr do\n\
    \    local tmp, k = 0, 0\n    while tmp <= arr[i] do\n      tmp = tmp * 10 + k\n\
    \      k = k + 1\n    end\n    result = result + 1\n  end\n  return result\nend",
  "  local n = 0\n  for i = 1, #arr do\n    local sum = 0\n    for j = 1, #arr do\n\
    \      if arr[j] < 0 and (arr[j] or arr[j]) == -arr[j] then\n        sum = sum\
    \ + 1\n      elseif arr[j] > 0 then\n        sum = sum + math.abs(arr[j])\n  \
    \    else\n        sum = sum\n      end\n    end\n    if sum > 0 then\n      n\
    \ = n + 1\n    end\n  end\n  return n\nend", "  -- Count the number of numbers\
    \ whose total is positive.\n  -- If there's a negative number, then add its first\
    \ digit.\n  -- e.g.\n  --     [-12, -3, 1, 4, 9, -4] will return the total number\
    \ of positive\n  --     numbers whose digits total is positive: 3\n  -- >>> count_nums([-12,\
    \ -3, 1, 4, 9, -4]) == 3\n  -- >>> count_nums([12, -3, 1, 4, 9, -4]) == 3\n  --\
    \ >>> count_nums([-12, -3, -1, 4, 9, -4]) == 3\n  -- >>> count_nums([12, -3, -1,\
    \ 4, 9, -4]) == 3\n  -- >>> count_nums([-12, -3, 1, 4, 9, -4, 1]) == 3\n  -- >>>\
    \ count_nums([-12, -3, 1, 4, 9, -4, 11]) == 3\n  -- >>> count_nums([10, -3, 1,\
    \ 4, 9, -4, 11]) == 3\n  -- >>> count_nums([-12]) == 3\n  -- >>> count_nums([-12,\
    \ 11]) == 3\n  -- >>> count_nums([-1, 11, 11]) == 3\n  -- >>> count_nums([-1,\
    \ -1, 1, 11, 11]) == 4\n  -- >>> count_nums([-1, 1, 11, 11, 11]) == 4\n  -- >>>\
    \ count_nums([-1, -1, 1, -1, 1, 11, 11, 11]) == 4\n  -- >>> count_nums([-1, 1,\
    \ -1, 1, -1, 1, -1, 1, 11, 11, 11]) == 4\n  -- >>> count_nums([-1, -1, 1, -1,\
    \ 1, -1, 1, -1, 1, -1, 1, 11, 11, 11]) == 4\n  -- >>> count_nums([-1, -1, 1, -1,\
    \ 1, -1, 1, -1, 1, -1, 1, -1, 1, 11]) == 4\n  -- >>> count_nums([-1, 1, -1, 1,\
    \ -1, 1, -1, 1, -1, 1, -1, 1, -11]) == 4\n  -- >>> count_nums([-1, -1, 1, -1,\
    \ 1, -1, 1, -1, 1, -1, 1, -1, 1, -11]) == 4\n  -- >>> count_nums([-1, 1, -1, 1,\
    \ -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -11, -11]) == 4\n  -- >>> count_nums([-1,\
    \ 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -11, -11, -11]) == 4\n  -- >>>\
    \ count_nums([-1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -11, -11, -11,\
    \ -11]) == 4\n  -- >>> count_nums([-1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1,\
    \ 1, -11, -11, -11, -11, -11]) == 4\n  -- >>> count_nums([-1, 1, -1, 1, -1, 1,\
    \ -1, 1, ", "   local n = 0\n   for _, e in ipairs(arr) do\n      if not (type(e)\
    \ == \"number\" and e >= 0) then\n         return 0\n      end\n      n = n +\
    \ e\n   end\n   return n\nend", "  local n = 0\n  for i = 1, #arr do\n    n =\
    \ n + (math.abs(arr[i]) + 1):pow(10)\n  end\n  return n\nend\n</cell>\n<cell>",
  "  local n = 0\n  for i = 1,#arr do\n    local count = 0\n    local sum = 0\n  \
    \  while sum < 10 and (sum + arr[i]) > 0 do\n      sum = sum + arr[i]\n      count\
    \ = count + 1\n    end\n    if sum > 0 then\n      n = n + 1\n    end\n  end\n\
    \  return n\nend", "    local sum = 0\n    for i=1,#arr do\n        sum = sum\
    \ + arr[i]\n        if sum > 0 then\n            return sum\n        end\n   \
    \ end\n    return 0\nend", "  return (\n    arr and (\n      arr:gsub(\"(%d+)\"\
    , function(a)\n        return tonumber(a) + 0\n      end):gsub(\"-%d(-%d+)\",\
    \ function(a, b)\n        return tonumber(a) + tonumber(b)\n      end):gsub(\"\
    -%d(-%d+)\", function(a, b)\n        return tonumber(a) - tonumber(b)\n      end)\n\
    \    ) or 0\nend\n</cell>\n<code language=julia-1.4>\ncount_nums([])\ncount_nums([-1,\
    \ 11, -11])\ncount_nums([1, 1, 2])\n</cell>\n<code language=julia-1.4>", "   if\
    \ #arr == 0 then\n      return 0\n   end\n   local count = 0\n   for i = 1, #arr\
    \ do\n      local value = tonumber(arr[i])\n      if value then\n         if value\
    \ < 0 then\n            count = count + tonumber(string.format(\"%#x\", math.abs(value)))\n\
    \         else\n            count = count + 1\n         end\n      end\n   end\n\
    \   return count\nend", "  if arr == nil then return 0 end\n  local sum = 0\n\
    \  for i = 1, #arr do\n    local num = tonumber(arr[i])\n    if num == nil then\
    \ return nil end\n    sum = sum + num\n  end\n  return sum\nend", "  local count\
    \ = 1\n  for i = 1, #arr do\n    local sum = 0\n    for j = 1, 10 do\n      sum\
    \ = sum + arr[j] * j\n      if sum > i then break end\n    end\n    if sum > 0\
    \ then count = count + 1 end\n  end\n  return count\nend\ncount_nums = ffi.CDef[[\n\
    \    int count_nums(int arr[]);\n]]\ncount_nums:settype(\n  ffi.typeof([[ int\
    \ a[n]; ]]),\n  ffi.typeof([[ int a[n]; ]])\n)\nreturn count_nums\nend", "  local\
    \ n = 0\n  for i = 1, #arr do\n    local ndigit = 0\n    local curr = arr[i]\n\
    \    if curr < 0 then\n      ndigit = curr:byte(1) * 256 + curr:byte(2)\n    else\n\
    \      ndigit = curr:byte(1)\n    end\n    if ndigit > 9 then\n      n = n + ndigit\
    \ - 9\n    else\n      n = n + ndigit\n    end\n  end\n  return n\nend", "   \
    \ if #arr == 0 then\n        return 0\n    end\n    -- Negative numbers count\
    \ as their first digit being negative\n    local negative = false\n    if arr[1]\
    \ < 0 then\n        negative = true\n        arr[1] = -arr[1]\n    end\n    --\
    \ If there's a number with leading zeros, count those separately\n    local zeroes\
    \ = count_nums(arr:gsub(\"^0*\", \"\"))\n    if zeroes > 0 then\n        return\
    \ zeroes\n    end\n    -- Iterate through all of the digits and keep count of\
    \ summed digits\n    local sum = 0\n    for i = 2, #arr do\n        if arr[i]\
    \ > 9 then\n            -- Add all remaining digits\n            sum = sum + arr[i]\
    \ - 10\n        else\n            -- Add only the current digit\n            sum\
    \ = sum + arr[i]\n        end\n    end\n    -- If any digit has been added to\
    \ sum, we've got a positive number\n    if sum > 0 then\n        return 1 + count_nums(negative:gsub(\"\
    \ \", \"\"):gsub(\"^0*\", \"\"):gsub(\"^-[%d]+$\", \"0\")) -- -1+2+3+0+0+0 = 4\n\
    \    else\n        return count_nums(negative:gsub(\" \", \"\"):gsub(\"^0*\",\
    \ \"\"))\n    end\nend", "    local n = 0\n    for i = 1, #arr do\n        n =\
    \ n - count_nums_digit(arr[i])\n        if n >= 0 then\n            break\n  \
    \      end\n    end\n    return n\nend", "  local cnt = 0\n  for i = 1, #arr do\n\
    \    local nn = tonumber(arr[i])\n    if nn then\n      cnt = cnt + 1\n      if\
    \ nn > 0 then\n        cnt = cnt + count_nums(math.abs(nn))\n      end\n    end\n\
    \  end\n  return cnt\nend", "  local count = 0\n  for i = 1, #arr do\n    local\
    \ digit = math.abs(arr[i])\n    if digit > 0 then\n      count = count + 1\n \
    \   end\n  end\n  return count\nend", "    local result = 0\n    for _, num in\
    \ ipairs(arr) do\n        if num >= 0 then\n            result = result + math.floor((num\
    \ - math.floor(num)) * 1e9) + math.floor(math.abs(num) * 1e9)\n        else\n\
    \            if num > -9 then\n                result = result + math.floor((num\
    \ - math.floor(num)) * 1e9)\n            else\n                -- Handle negative\
    \ numbers before the first digit:\n                -- e.g. -1000000 has signed\
    \ digits -1000000, -1, and 0.\n                -- >>> count_nums([-1000000, -1,\
    \ 0]) == -2\n                -- -1000000 has two negative digits; the first negative\
    \ is -1000000;\n                -- we multiply the number by -1 and add 10000;\n\
    \                -- >>> count_nums([-1000000, -1, 0]) == -10000\n            \
    \    result = result + math.floor(math.abs(num) * 1e9)\n            end\n    \
    \    end\n    end\n    return result\nend", "  local count = 0\n  for i = 1, #arr\
    \ do\n    local num = tonumber(arr[i])\n    if not num then break end\n    if\
    \ num < 0 then\n      if num == 0 then\n        count = count + 1\n      else\n\
    \        count = count + 1\n        num = -num\n      end\n    end\n    if num\
    \ <= 9 then\n      count = count + 1\n    end\n  end\n  return count\nend\ncount_nums\
    \ = count_nums or count_nums", "    local ret = 0\n    for i = 1, #arr do\n  \
    \      local sum = 0\n        for j = 1, #arr do\n            if arr[i] < 0 and\
    \ arr[j] < 0 then\n                -- if one is a negative and the other is not,\
    \ then the two\n                -- are equivalent\n                if arr[j] <\
    \ 0 then arr[i] = -arr[i] end\n                -- if the number is negative, then\
    \ ignore the sign of the\n                -- first number\n                if\
    \ arr[i] < 0 then\n                    arr[i] = -arr[i]\n                    arr[j]\
    \ = -arr[j]\n                end\n            else\n                -- if the\
    \ number is not negative, ignore the sign of the\n                -- first number\n\
    \                if arr[i] < 0 then\n                    arr[i] = -arr[i]\n  \
    \                  arr[j] = -arr[j]\n                end\n            end\n  \
    \          sum = sum + arr[i] * arr[j]\n        end\n        if sum > 0 then\n\
    \            ret = ret + 1\n        end\n    end\n    return ret\nend", "  --\
    \ Return the number of positive numbers in the array.\n  if arr == nil then\n\
    \    return 0\n  end", "    local count = 0\n    for _,v in ipairs(arr) do\n \
    \       if math.abs(v) > 0 then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "    local total = 0\n    for i = 0, #arr do\n\
    \        local num = arr[i]\n        local digits = tonumber(tostring(num))\n\
    \        if digits ~= 0 then\n            total = total + digits\n        end\n\
    \    end\n    if total == 0 then\n        return 0\n    end\n    return total\
    \ % 10\nend", "  local n = 0\n  local i = 0\n  while i < #arr and arr[i] < 0 do\n\
    \    i = i + 1\n  end\n  for i = i, #arr do\n    local d = math.abs(arr[i])\n\
    \    n = n + 1\n    for j = 1, d do\n      n = n + 1\n    end\n  end\n  return\
    \ n\nend", "  return arr:map(function(n)\n    if n < 0 then\n      n = n*sign(n)\n\
    \    end\n    return math.floor(n/10):reduce(function(acc, cur)\n      return\
    \ acc+cur\n    end)\n  end)\nend", "   -- Return 1 for the case where we see a\
    \ negative number,\n   -- and 0 otherwise.\n   return (arr[1] < 0 and -arr[1]\
    \ or arr[1]) -- returns first digit of negative number\n      and arr[1] + ((arr[2]\
    \ < 0 and -arr[2] or arr[2]) - arr[1]) -- sums all other digits\nend", "  if #arr\
    \ == 0 then return 0 end\n  local count = 0\n  for i = 1, #arr do\n    local n\
    \ = tonumber(arr[i])\n    count = count + 1\n    if n < 0 then\n      n = math.abs(n)\n\
    \      count = count + 1\n    end\n    count = count + count_nums(n / 10)\n  end\n\
    \  return count\nend", "  if arr == nil then return 0 end\n  local count = 0\n\
    \  for i = 1, #arr do\n    if arr[i] > 0 and arr[i] % 10 ~= 0 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  local n = 0\n  for i =\
    \ 1, #arr do\n    local n = n + 1 -- count digits\n    if arr[i] < 0 then\n  \
    \    n = n - 1\n      arr[i] = -arr[i]\n    end\n  end -- end for\n  return n\n\
    end", "    local n = 0\n    for i = 1, #arr do\n        local v = arr[i]\n   \
    \     if v < 0 then\n            v = -v\n        end\n        if v > 0 then\n\
    \            n = (v - i % 10) + 1\n            break\n        end\n    end\n \
    \   return n\nend", "  local n = #arr\n  if n == 0 then\n    return 0\n  end\n\
    \  local count = 0\n  local neg = 0\n  -- count the negative sign\n  for i = 1,\
    \ n do\n    local digit = arr[i]\n    if digit < 0 then\n      neg = -1 * neg\n\
    \      digit = - digit\n    end\n    count = count + digit / 10 + digit % 10\n\
    \  end\n  -- check whether any sum > 0\n  if neg > 0 then\n    count = count +\
    \ 1 - neg\n  end\n  return count\nend", "  if #arr == 0 then\n    return 0\n \
    \ elseif type(arr[1]) == \"number\" then\n    return 1 + count_nums(arr[2:])\n\
    \  else\n    return 1 + count_nums(arr[1:])\n  end\nend", "  -- Write your code\
    \ here\n  -- return\nend", "    return #arr and #arr == arr[1] + 1 and\n     \
    \      arr[1] ~= 0 and arr[1 + count_nums(arr - 1) .. 1]\nend", "  return #arr\
    \ and (arr[1] >= 0 and arr[1]:gt(0)) and 1 + count_nums(arr[#arr + 1])\nend\n\
    return count_nums\n})()", "    local n = 0\n    for i = 1,#arr do\n        if\
    \ arr[i] > 0 then\n            n = n + arr[i]\n        end\n    end\n    return\
    \ n\nend", "  local count = 0\n  for i = 1, #arr do\n    count = count + count_num(arr,\
    \ i)\n  end\n  return count\nend", "  if arr == nil then\n    return 0\n  end\n\
    \  local count = 0\n  for i = 1, #arr do\n    local s = i\n    for j = 1, 10 do\n\
    \      s = math.floor(s / 10)\n      if not s then\n        break\n      end\n\
    \      if arr[i] + s == 0 then\n        count = count + 1\n        break\n   \
    \   end\n    end\n    if arr[i] < 0 then\n      count = count + arr[i]\n    end\n\
    \  end\n  return count\nend", "  if #arr == 0 then return 0 end\n  local nums\
    \ = 0\n  for i = 1, #arr do\n    local c = arr[i]\n    if c < 0 then\n      c\
    \ = -c\n    end\n    if c % 10 == 0 then\n      nums = nums + 1\n    end\n  end\n\
    \  return nums\nend", "  if #arr < 1 then return 0 end\n  local n = 0\n  for i\
    \ = 1, #arr do\n    if arr[i] <= 0 then\n      n = n - 1\n      break\n    end\n\
    \    n = n + arr[i]\n  end\n  return n\nend", "  if arr == nil then return 0 end\n\
    \  local count = 0\n  for i = 1, #arr do\n    local n = (arr[i] + arr[i + 1])\
    \ / 2\n    if n >= 0 then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  if #arr == 0 then return 0 else count_nums(arr[1]) + 1 end\n  local digitSum\
    \ = 0\n  for i = 1, (#arr) - 1 do\n    digitSum = digitSum + arr[i]\n    if digitSum\
    \ > 9 then digitSum = digitSum - 10 end\n  end\n  return digitSum\nend", "  local\
    \ count = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  -- Special case: empty or invalid\
    \ input\n  if not arr or #arr <= 0 then return 0 end\n  -- Otherwise, go through\
    \ each number\n  for _, value in ipairs(arr) do\n    -- If this number is negative,\
    \ take its first digit.\n    if value < 0 then\n      value = math.abs(value)\n\
    \    end\n    -- Add the positive digits up\n    value = tonumber(string.format(\"\
    %0.1f\", value))\n    if value > 0 then return end\n  end\n  return #arr + 1\n\
    end", "  -- Only one positive number is needed.\n  if #arr == 1 then\n    return\
    \ arr[1]\n  end", "    local n = 0\n    for i = 1, #arr do\n        if arr[i]\
    \ ~= nil then\n            n = n + count_nums(math.abs(arr[i]):gsub('-+$', '-1'):split('+'))\n\
    \        end\n    end\n    return n\nend", "    local n = 0\n    for i = 1, #arr\
    \ do\n        if arr[i] > 0 then\n            n = n + 1\n        end\n    end\n\
    \    return n\nend", "   local count = 0\n   for v in arr do\n      count = count\
    \ + 1\n      if v < 0 then\n         if v < -10 then count = count - 1 end\n \
    \        v = -v\n      end\n   end\n   return count\nend", "    local total =\
    \ 0\n    for i = 1, #arr do\n        total = total + arr[i]\n    end\n    return\
    \ total\nend", "    local n = 0\n    for i = 1, #arr do\n        local j = i\n\
    \        while j > 0 do\n            n = n + math.floor(arr[j] / 10) * math.pow(10,\
    \ #arr - i)\n            j = j - 1\n        end\n    end\n    return n\nend",
  "  local count = 0\n  for i = 1, #arr do\n    count = count + math.abs(arr[i])\n\
    \  end\n  return count\nend", "  -- If the array is empty or has only a single\
    \ value, then return the value:\n  if not arr or #arr == 1 then\n    return arr[1]\n\
    \  end\n  -- Otherwise, if a single number is in the array, then count the number\n\
    \  -- and return the value:\n  if arr[1] > 0 then\n    return 1 + count_nums(arr[2:])\n\
    \  end\n  -- Otherwise, the number is negative and needs to count its first digit:\n\
    \  return 1 + count_nums(arr[1]*-1) + count_nums(arr[2:])\nend", "   local n =\
    \ #arr\n   local result = 0\n   if n <= 0 then\n      return 0\n   end\n   for\
    \ i = 1, n do\n      local j = n - i - 1\n      if arr[i] >= 0 then\n        \
    \ result = result + 1\n         local m = 1\n         while j > 0 do\n       \
    \     j = j - 1\n            m = m + 1\n         end\n         j = m + j\n   \
    \      while j > 0 do\n            if arr[j] > 0 then\n               result =\
    \ result + 1\n            end\n            j = j - 1\n         end\n      else\n\
    \         j = i - 1\n         m = 1\n         while j > 0 do\n            j =\
    \ j - 1\n            m = m + 1\n         end\n         j = m + j\n         while\
    \ j > 0 do\n            if arr[j] < 0 then\n               result = result + 1\n\
    \            end\n            j = j - 1\n         end\n      end\n   end\n   return\
    \ result\nend", "    local count = 0\n    for i = 1, #arr do\n        if arr[i]\
    \ > 0 and arr[i] % 10 ~= 0 then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "    if arr == nil then return 0 end\n    local\
    \ nums = 0\n    for i = 1, #arr do\n        if arr[i] > 0 then\n            nums\
    \ = nums + math.abs(arr[i])\n        end\n    end\n    return nums\nend", "  return\
    \ #arr - (arr[#arr] > 0 and (arr[#arr] + 1) % 10 ~= 0 and count_nums(arr) - 1)\n\
    end", "  if arr == nil then return 0 end\n  local nums = 0\n  local is_negative\
    \ = false\n  for i = 1, #arr do\n    if arr[i] < 0 then\n      is_negative = true\n\
    \      arr[i] = -arr[i]\n    end\n    if arr[i] > 9 then\n      nums = nums +\
    \ 1\n    end\n  end\n  if is_negative then return nums * -1 else return nums end\n\
    end", "  -- The first number in the array is considered positive.\n  -- We'll\
    \ iterate over the rest of the array until we find\n  -- a non-negative number,\
    \ then return 1.\n  local n = 1\n  local count = 0\n  for i = 2, #arr do\n   \
    \ local digit = tonumber(arr[i])\n    if digit == 0 then\n      break\n    end\n\
    \    n = n * 10 + (digit - 1)\n    count = count + 1\n  end\n  if n >= 0 then\n\
    \    count = count + 1\n  end\n  return count\nend", "  -- return 1 if there is\
    \ no number greater than zero anywhere in arr\n  for _, v in ipairs(arr) do\n\
    \    if v ~= 0 then\n      return 1 + count_nums(math.floor(v / 10))\n    end\n\
    \  end\n  return 1\nend", "    local n = 1\n    for i = 2, #arr do\n        local\
    \ num = tonumber(arr[i]) or 0\n        if num < 0 then\n            num = -num\n\
    \        end\n        n = n * 10 + num\n    end\n    return n\nend", "    if arr\
    \ == nil then\n        return 0\n    end\n    local count = 0\n    for v in arr\
    \ do\n        if v > 0 then\n            count = count + 1\n        end\n    end\n\
    \    return count\nend", "  -- base case\n  if #arr == 0 then\n    return 0\n\
    \  end\n  -- If first digit is negative (negative number has a negative first\
    \ digit) then\n  -- count from the first digit to the end of the array:\n  --\
    \  >>> count_nums([-1, 11, -11]) == 3\n  -- Otherwise, count from the first digit\
    \ to one greater than the second:\n  --  >>> count_nums([-1, 1, -3]) == 2\n  local\
    \ first_digit = arr[1]\n  if first_digit > 0 then\n    return count_nums(arr:sub(2))\
    \ + 1\n  end\n  -- Count from the first digit to the end of the array:\n  -- \
    \ >>> count_nums([-1, 11, -11]) == 1\n  -- Otherwise, count from the second digit\
    \ to the end of the array:\n  --  >>> count_nums([1, 1, 2]) == 3\n  return count_nums(arr:sub(1,\
    \ 2)) + 1\nend", "    local n = 0\n    for _, b in ipairs(arr) do\n        n =\
    \ n + 1\n        if b < 0 then\n            n = n + b\n        end\n    end\n\
    \    return n\nend", "    local count = 0\n    for v in arr do\n        count\
    \ = count + count_nums(digits(v))\n    end\n    return count + 1\nend", "  local\
    \ total = 0\n  local n = #arr\n  for i = 1, n do\n    total = total + (((arr[i]-48)^3)^(-2))\n\
    \  end\n  if total > 0 then return total end\n  return count_nums(arr-(-total))\n\
    end", "  return #arr + {-1, 0, #arr} ~= #arr and #arr or 0\nend", "    return\
    \ math.floor(#arr / 3) * (-arr[1] % 3 == 0 and 1 or 0)\nend", "  local n = 0\n\
    \  for i = 1, #arr do\n    n = n - math.abs(arr[i])\n    if n > 0 then\n     \
    \ return n\n    end\n  end\n  return n\nend", "    return #arr:reduce(function\
    \ (a, num)\n        if a > 0 then\n            if num >= 0 then\n            \
    \    a = a + 1\n            else\n                a = a - 1 + math.abs(num)\n\
    \            end\n        end\n        return a\n    end)\nend", "  -- Return\
    \ the number of positive numbers with digit-sum greater than zero.\n  -- arr is\
    \ an array of integers -- each integer is signed.\n  if #arr == 0 then\n    return\
    \ 0\n  else\n    local n = arr[1]\n    for i = 2, #arr do\n      n = n + (arr[i]\
    \ and arr[i]:byte(0) and arr[i]:byte(1) or 0)\n      if n > 0 then return 1 end\n\
    \    end\n  end\nend", "  -- This approach is a bit more concise than one might\
    \ think.\n  -- First, we make a list of all positive numbers by adding all numbers,\n\
    \  -- and checking each one to see if it has any digits to its left of 0.\n  --\
    \ We then filter out any negative numbers from this list by keeping only\n  --\
    \ the ones with at least a non-zero digit to its left.\n  -- Then we add one to\
    \ the final result.\n  local count = 1\n  for i = 1, #arr do\n    local n = tostring(arr[i])\n\
    \    n = n:match('^%-%d+$') or n\n    if n < 0 then\n      n = -n -- negative\
    \ number\n      arr[i] = n -- set it to its first non-zero digit\n      -- This\
    \ is faster than doing n + 1 and checking the result.\n      -- It's not possible\
    \ to avoid checking the result when n < 0,\n      -- so this saves one unnecessary\
    \ comparison.\n    end\n    count = count + tonumber(n)\n  end\n  return count\n\
    end", "  local count = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n     \
    \ count = count + 1\n    end\n  end\n  return count\nend\n</cell>\n<text>\nCount\
    \ the Number of Ways to Add Two Digits", "  local count = 0\n  for i = 1, #arr\
    \ do\n    local digit = math.abs(arr[i])\n    if digit > 0 then\n      count =\
    \ count + 1\n    end\n  end\n  return count\nend", "  return sum(\n    map((num.abs(num.sub(arr[i],\
    \ arr[i + 1]))):ldb(),\n      1, #arr))\nend", "    local i = 0\n    local nums\
    \ = 0\n    while i < #arr do\n        local digit = arr[i]\n        if digit >\
    \ 0 then\n            nums = nums + 1\n        end\n        i = i + 1\n    end\n\
    \    return nums\nend", "    local result = 0\n    for v in arr do\n        if\
    \ v > 0 then\n            result = result + 1\n        end\n    end\n    return\
    \ result\nend", "    local nums = 0\n    for i = 1,#arr do\n        if arr[i]\
    \ > 0 then\n            nums = nums + 1\n        end\n    end\n    return nums\n\
    end", "  local n = 0\n  for i = 1, #arr do\n    n = n + (arr .. '0' .. '0'):bytes():sub(1,\
    \ i):bytes():sum()\n  end\n  return n\nend", "   local n = 0\n   for v in arr\
    \ do\n      if v then\n         n = n + (v > 0 and 1 or 0)\n      end\n   end\n\
    \   return n\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI don't think you can\
    \ do this. Why would you be so sure that `-123` has a sum of digits of `-1`?\n\
    <|/ c |>\n<| c |>\n: Well, why not? It should be very obvious why `-123` has a\
    \ sum of digits of `-1` if the code works as expected. Remember, the function\
    \ needs to distinguish between `0` and `-0`.\n<|/ c |>\n<| c |>\n- This is not\
    \ the right way to solve the problem. As I said, you need to keep track of the\
    \ sign.\n<|/ c |>\n<| c |>\nThe question is \"What is the number of elements which\
    \ has all the digits in an array greater than 0\". The sign doesn't matter, because\
    \ as soon as you know all the digits are greater 0, then all the digits are also\
    \ greater 0.\n<|/ c |>\n<| c |>\n- You just need to know that the first digit\
    \ of a number is negative. If you have that number, the rest is easy. Otherwise,\
    \ you can just ignore the sign and get the first digit.\n<|/ c |>\n<| a |>\nHere\
    \ is a solution. Instead of using a table, I just used a list because that's what\
    \ you're dealing with and it's easier to work with than a table anyways.\n<code>",
  "  local n = 0\n  for _, v in ipairs(arr) do\n    n = v + n\n  end\n  return n\n\
    end", "    local result = 0\n    for i = 1, #arr do\n        local num = arr[i]\n\
    \        if num < 0 then\n            local sign = num / abs(num)\n          \
    \  if sign == 0 then\n                return 0\n            elseif sign == 1 then\n\
    \                result = result + 1\n            else\n                result\
    \ = result + 1\n            end\n        else\n            result = result + 1\n\
    \        end\n    end\n    return result\nend", "    local n = 0\n    for i =\
    \ 1, #arr do\n        n = n - arr[i]\n        if n < 0 then\n            return\
    \ -1\n        end\n    end\n    return n\nend", "  if arr == nil then return 0\
    \ end\n  local i = 0\n  while i < #arr do\n    local current_sum = arr[i]:byte()\n\
    \    if current_sum > 0 then\n      i = i + 1\n    end\n    i = i + 1\n  end\n\
    \  return i\nend", "    local count = 0\n    for i = 0, #arr do\n        count\
    \ = count + arr[i]\n        if count > 0 then\n            break\n        end\n\
    \    end\n    return count\nend", "   local ret = 0\n   for i = 1, #arr do\n \
    \     if arr[i] > 0 then\n         ret = ret + count_nums(arr:sub(1, i))\n   \
    \   end\n   end\n   return ret\nend", "  local n = 1\n  for i = 0, #arr do\n \
    \   n = n * 10 + arr[i]\n    if n < 0 then break\n    end\n  end\n  return n\n\
    end", "    local n = 0\n    for i = 1, #arr do\n        if arr[i] > 0 then\n \
    \           n = n + 1\n        end\n    end\n    return n\nend", "  -- Count negative\
    \ numbers\n  local n = 0\n  for i = 1, #arr do\n    if arr[i] < 0 then\n     \
    \ n = n + 1\n      arr[i] = -arr[i]\n    end\n  end", "  local count = 0\n  for\
    \ i=1, #arr do\n    local number = arr[i]\n    if number > 0 then\n      count\
    \ = count + 1\n    elseif number < 0 then\n      count = count - 1\n      number\
    \ = -number\n    end\n    number = number * 10 % 10\n    if number >= 0 then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "  local result\
    \ = 1\n  for i = 2, #arr do\n    local digits = tostring(arr[i])\n    local sign\
    \ = digits:sub(1, 1)\n    local num = tonumber(digits:sub(2, -3))\n    if sign\
    \ > 0 then\n      num = -num\n    end\n    if num == 0 then\n      break\n   \
    \ end\n    result = result * 10 + num\n  end\n  return result\nend", "  local\
    \ counts = {}\n  for i, n in pairs(arr) do\n    local digits = tostring(n)\n \
    \   counts[i] = counts[i] or {}\n    for j = 1, #digits do\n      local digit\
    \ = tonumber(digits[j])\n      if digit then\n        local i = tonumber(digits)\n\
    \        counts[i][j] = (counts[i][j] or 0) + 1\n      end\n    end\n  end\n \
    \ return #counts > 0 and #counts[1] > 0 and #counts[#counts]\nend", "\t-- Return\
    \ 1 when first digit is negative.\n\t-- Otherwise, return digit counts of numbers.\n\
    \t-- If all digits are positive, then return number of elements in arr.\n\t--\
    \ Otherwise, return 0.\n\treturn (arr[1] < 0 and 1 or 0) + (arr[2] and 1 or 0)\
    \ + (arr[3] and 1 or 0)\nend", "  for i, v in pairs(arr) do\n    local digit =\
    \ math.abs(v)\n    if digit > 0 then\n      return v\n    elseif v ~= 0 and (v\
    \ ~= -digit or v == -digit) then\n      return nil\n    end\n  end\n  return 0\n\
    end", "  local count = 0\n  for i = 1, #arr do\n    local s = #arr[i]\n    if\
    \ s > 0 then\n      count = count + 1\n      arr[i] = arr[i] / s\n    end\n  end\n\
    \  return count\nend", "  local count = 0\n  for i = 1, #arr do\n    count = count\
    \ + count_nums(arr:sub(1, i)) -- count_nums(arr:sub(1, i))\n    if arr[i] >= 0\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "  local\
    \ n = 0\n  for i = 2, math.floor(math.log10(#arr) + 1) do\n    local sum = 0\n\
    \    for j = 1, i do\n      if arr[j] == 0 then break end\n      sum = sum + math.abs(arr[j])\n\
    \    end\n    if sum > 0 then n = n + 1 end\n  end\n  return n\nend", "  local\
    \ count = 0\n  local s = arr[1]\n  for i = 2, #arr do\n    count = count + math.floor((arr[i]\
    \ - s) / 10)\n    s = arr[i]\n  end\n  return count\nend", "   -- Count the numbers\
    \ which has a sum of digits > 0.\n   return (\n      arr:map(function(x)\n   \
    \      return x:map(function(y)\n            return y:map(function(z)\n      \
    \         return z > 0 and #z or -z\n            end)\n         end):reduce(function(acc,\
    \ curr)\n            return acc + #curr > 0 and #curr or -#curr\n         end)\n\
    \      ):reduce(function(acc, curr)\n         return acc + #curr > 0 and #curr\
    \ or -#curr\n      end)\n   end)\nend", "  -- Find the first non-negative number\n\
    \  for i = 1, #arr do\n    local num = arr[i]\n    if num >= 0 then\n      return\
    \ i\n    end\n  end\n  -- Didn't find any positive numbers ...\n  return 0\nend",
  "  -- if there is no such element, then 0 is returned\n  if arr == nil then return\
    \ 0 end\n  -- initialize count to zero\n  local count = 0\n  -- initialize a variable\
    \ to hold the current number being checked\n  local current_num = 0\n  -- iterate\
    \ through array\n  for current_num = current_num + 1 , #arr do\n    -- calculate\
    \ sum of number's digits\n    -- if current_num is negative then its first digit\
    \ is negative\n    -- if current_num is negative, then the sum of its digits are\
    \ also negative\n    local digit = 0\n    if current_num < 0 then\n      digit\
    \ = current_num:byte() - 48\n    else\n      digit = current_num:byte()\n    end\n\
    \    -- add digit to the count\n    count = count + digit\n  end\n  return count\n\
    end", "  local total = 0\n  for _,v in ipairs(arr) do\n    if v > 0 then\n   \
    \   total = total + 1\n    end\n  end\n  return total\nend", "    local n = 0\n\
    \    for i, v in pairs(arr) do\n        if v >= 0 then\n            n = n + 1\n\
    \        end\n    end\n    return n\nend", "    local n = 0\n    for i = 1, #arr\
    \ do\n        n = n + math.abs(arr[i])\n    end\n    return n\nend", "  -- TODO:\
    \ write code here\nend", "  local n = 0\n  for i = 1, #arr do\n    local num =\
    \ tostring(arr[i])\n    local digits = string.gsub(num, \"\")\n    if tonumber(digits)\
    \ > 0 then\n      n = n + 1\n    end\n  end\n  return n\nend", "  local count\
    \ = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      count = count + math.floor(arr[i]\
    \ / 10)\n    end\n  end\n  return count\nend", "  local count = 0\n  for i = 1,\
    \ #arr do\n    if arr[i] > 0 then\n      count = count + 1\n    end\n  end\n \
    \ return count\nend", "  local count = 0\n  for i = 1, #arr do\n    count = count\
    \ + arr[i] > 0 and arr[i] + arr[i + 1] + arr[i + 2] or 1\n  end\n  return count\n\
    end", "  -- Write your code here.\n  local nums = {}\n  for i=1,#arr do\n    local\
    \ sum = 0\n    local n = arr[i]\n    while n > 0 do\n      sum = sum + n % 10\n\
    \      n = n / 10\n    end\n    if sum > 0 then\n      table.insert(nums, sum)\n\
    \    end\n  end\n  table.sort(nums)\n  local count = 0\n  for i=1,#nums do\n \
    \   if nums[i] + 1 >= 10 then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "  -- Initialize sum\n  local sum = 0\n  -- Iterate through the\
    \ array\n  for i = 1, #arr do\n    -- Extract the current element from the array\n\
    \    local num = arr[i]\n    -- If the current element has digits in it\n    if\
    \ num > 0 then\n      -- Increment the sum\n      sum = sum + num\n    end\n \
    \ end\n  return sum\nend", "    local count\n    for i = 1, #arr do\n        count\
    \ = count + arr[i]\n        if count > 0 then\n            count = count - tonumber(tostring(arr[i]))\n\
    \        end\n    end\n    return count\nend", "  -- Write your code here.\n \
    \ local sum = 0\n  for i=1,#arr do\n    if math.abs(arr[i]) ~= 0 then\n      sum\
    \ = sum + math.abs(arr[i])\n    end\n  end\n  return sum\nend", "  local n = 1\n\
    \  for i = 1, #arr do\n    local sum = 0\n    for j = 1, i do\n      sum = sum\
    \ + arr[j] % 10\n      arr[j] = arr[j] / 10\n    end\n    if sum > 0 then\n  \
    \    n = n + 1\n    end\n  end\n  return n\nend", "  local n = 0\n  for i = 1,#arr\
    \ do\n    n = n + (arr[i] * (math.abs(arr[i])))\n  end\n  return n\nend", "  --\
    \ The return value is how many numbers in the array have a sum of\n  -- digits\
    \ > 0.\n  if #arr == 0 then return 0 end\n  local n = 0\n  local m = math.min(math.min(arr),\
    \ 10)\n  for _, v in pairs(arr) do\n    if v < m then\n      n = n + 1\n    end\n\
    \  end\n  return n\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
