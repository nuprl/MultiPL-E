name: HumanEval_59_largest_prime_factor
language: lua
prompt: "-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  -- >>> largest_prime_factor(13195)\n-- 29\n-- >>> largest_prime_factor(2048)\n--\
  \ 2\nlocal function largest_prime_factor(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_prime_factor\n\
  \    lu.assertEquals(candidate(15), 5)\n    lu.assertEquals(candidate(27), 3)\n\
  \    lu.assertEquals(candidate(63), 7)\n    lu.assertEquals(candidate(330), 11)\n\
  \    lu.assertEquals(candidate(13195), 29)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Start with the smallest prime factor.\n  local prime = 1\n  --\
    \ Find the largest factor that is smaller than or equal to n.\n  -- This is because\
    \ the largest prime factor is necessarily smaller than n.\n  while n % prime ==\
    \ 0 do\n    prime = prime + 1\n  end\n  -- Return n / prime to see if it's prime.\
    \ If not, return the largest prime factor of n.\n  -- >>> largest_prime_factor(91750)\n\
    \  -- 44\n  -- >>> largest_prime_factor(91752)\n  -- 50\n  return n / prime\n\
    end", "  -- Prime factors are easy to calculate!\n  -- http://en.wikipedia.org/wiki/Prime_number#Prime-factorization\n\
    \  if n <= 2 then return 1 end\n  local factors = [1]\n  -- Prime factors of n\
    \ are 2 to n+1 and only 2 are prime.\n  -- Thus 2 is the first prime factor of\
    \ n (2 <= n+1).\n  for i = 2, n do factors[#factors+1] = i end\n  -- The first\
    \ prime factor of n is the smallest prime factor of n.\n  -- The smallest prime\
    \ factor of n is 2. The smallest prime factor of 3 is 2.\n  -- If the smallest\
    \ prime factor of n is 2, the smallest prime factor of n+1 is 2.\n  -- So 2 is\
    \ the largest prime factor of n.\n  -- We only have to test odd numbers for being\
    \ prime.\n  for i = 2, #factors do -- odd number\n    if factors[i] % 2 ~= 0 then\
    \ return nil end\n  -- If the smallest prime factor of n is 2, the smallest prime\
    \ factor of n+1 is 2.\n    -- And if n+1 is a prime factor of n, the smallest\
    \ prime factor of n+1 is 2.\n    -- So we only have to test odd numbers for being\
    \ prime.\n    if factors[#factors+1] == 2 then return nil end\n  end\n  -- If\
    \ n is prime, then it is the largest prime factor of n.\n  return #factors\nend",
  "    local function is_factor(num, factors)\n        for i = 2, #factors do\n  \
    \          if num % i == 0 then\n                return false\n            elseif\
    \ i > num and factors[i] == 1 then\n                return true\n            end\n\
    \        end\n        return false\n    end\n    local function largest_factor(num,\
    \ factors)\n        local f = nil\n        for i = 2, #factors do\n          \
    \  if factors[i] > f then\n                f = factors[i]\n            end\n \
    \       end\n        return f\n    end\n    local function prime_factors(n)\n\
    \        local factors = {}\n        if n == 1 then\n            return {2}\n\
    \        end\n        local q = math.floor(math.sqrt(n))\n        for i = 2, q\
    \ do\n            local p = n % i\n            if p == 0 then\n              \
    \  table.insert(factors, i)\n            end\n        end\n        if q * q ==\
    \ n then\n            table.insert(factors, q)\n        end\n        if q * q\
    \ > n then\n            for i = 1, #factors do\n                factors[i] = largest_factor(n,\
    \ factors)\n            end\n        end\n        return factors\n    end\n  \
    \  return largest_factor(n, prime_factors(n))\nend\n</code>\n<|/ a tags=prime-factoring,lua\
    \ |>\n<| a dscore=0 tags=prime-factoring,lua |>\n<code>", "    local m = n / 2\n\
    \    local i = 2\n    while i * i <= m do\n        while i * i <= m do\n     \
    \       if m % i == 0 then\n                return nil\n            end\n    \
    \        i = i + 1\n        end\n        m = m / i\n        i = 2\n    end\n \
    \   return m\nend", "    if n <= 2 then\n        return nil\n    end\n    local\
    \ max_num = 2 ^ n - 1\n    local p = 2\n    while not (max_num & (max_num - 1))\
    \ do\n        if p > n then\n            return nil\n        end\n        if n\
    \ % p == 1 then\n            p = p * 2\n        else\n            p = p + 1\n\
    \        end\n        max_num = max_num / p\n    end\n    return p\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nA simple recursive version I made:\n<code>",
  "    -- Initialize a counter for prime factors and initialize a list of primes.\n\
    \    local i, factors, primes\n    local p, factors", "\tif n <= 1 then\n\t\t\
    return\n\tend\n\tlocal max_n = 1\n\tlocal max_prime = 1\n\tlocal i = 1\n\twhile\
    \ i <= n do\n\t\tlocal next_n = n - 1\n\t\twhile next_n >= 2 * i do\n\t\t\tlocal\
    \ next_prime = next_n % i\n\t\t\tif next_prime > max_prime then\n\t\t\t\tmax_n\
    \ = next_n\n\t\t\t\tmax_prime = next_prime\n\t\t\tend\n\t\t\tnext_n = next_n /\
    \ i\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn max_n\nend", '    local limit = 10^9',
  "  -- Check for small numbers.\n  if n < 2 then\n    return 1\n  end\n  -- Check\
    \ if n is a prime.\n  if n <= 1 then\n    return n\n  end\n  -- Initialization.\n\
    \  local p = 2\n  -- Loop for testing.\n  while p < n do\n    if n % p == 0 then\n\
    \      return p\n    end\n    -- Increment.\n    p = p * 2\n  end\n  -- Return\
    \ n.\n  return n\nend", "  local function find(n)\n    if n == 0 then\n      return\
    \ nil\n    end\n    if n == 1 then\n      return 1\n    end\n    if n % 2 == 0\
    \ then\n      return find(n / 2)\n    else\n      return find(3 * n + 1) / 2\n\
    \    end\n  end\n  return find(n)\nend", "   -- A prime factor of 0 has no largest\
    \ prime factor.\n   if n == 0 then return 0 end", "\t-- Only need to test odd\
    \ numbers because 2 is the only even prime number.\n\tif n%2==0 then\n\t\tlocal\
    \ factors={}\n\t\tlocal primes={}\n\t\tlocal factor\n\t\t-- Test all the factors\
    \ of n.\n\t\tfor factor=2,n,2 do\n\t\t\t-- Test all odd numbers less than or equal\
    \ to this factor to see if they are prime or not.\n\t\t\tfor factor=factor,n,2\
    \ do\n\t\t\t\tif n%factor==0 then\n\t\t\t\t\t-- If the current number is a factor,\
    \ add it to the list of factors.\n\t\t\t\t\tif factors[factor]==nil then\n\t\t\
    \t\t\t\tfactors[factor]=factor\n\t\t\t\t\telse\n\t\t\t\t\t\t-- If the factor isn't\
    \ in the list of factors, add the new factor to the list of factors.\n\t\t\t\t\
    \t\tif factors[factor]==nil then\n\t\t\t\t\t\t\tfactors[factor]=factor\n\t\t\t\
    \t\t\telse\n\t\t\t\t\t\t\t-- If the factor exists, increment the number count\
    \ of the factor in the list of factors.\n\t\t\t\t\t\t\tfactors[factor]=factors[factor]+1\n\
    \t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\t-- If the number is a prime, add it\
    \ to the list of primes.\n\t\t\t\t\tif primes[factor]==nil then\n\t\t\t\t\t\t\
    primes[factor]=factor\n\t\t\t\t\telse\n\t\t\t\t\t\t-- If the prime doesn't exist\
    \ in the list of primes, add the new prime to the list of primes.\n\t\t\t\t\t\t\
    if primes[factor]==nil then\n\t\t\t\t\t\t\tprimes[factor]=factor\n\t\t\t\t\t\t\
    else\n\t\t\t\t\t\t\t-- If the prime exists, increment the number count of the\
    \ prime in the list of primes.\n\t\t\t\t\t\t\tprimes[factor]=primes[factor]+1\n\
    \t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t-- Return\
    \ the first factor that appears in the list of factors.\n\t\treturn factors[#factors]\n\
    \telse\n\t\t-- If n is even then return the next largest odd number in the sequence\
    \ of odd numbers.\n\t\tlocal max=0\n\t\tlocal odds={}\n\t\tlocal odds_cnt=0\n\t\
    \tlocal factor\n\t\tfor factor=2,n,2 do\n\t\t\todds[factor]=true\n\t\tend\n\t\t\
    for odds_cnt=2,n,2 do\n\t\t\tif odds_cnt>max then\n\t\t\t\tmax=odds_cnt\n\t\t\t\
    end\n\t\tend\n\t\treturn max\n\tend\nend", "  -- First, check primality\n  if\
    \ n < 2 then\n    return nil\n  end\n  if n == 2 then\n    return 2\n  end\n \
    \ -- Now check for factors\n  for i = 2, n do\n    if n % i == 0 then\n      return\
    \ nil\n    end\n  end\n  -- No factors found. Return -1.\n  return -1\nend", " \
    \   if n == 2 then\n        return 2;\n    end\n    -- Get all prime factors of\
    \ n\n    local factors = prime_factors(n)\n    -- Return the max prime factor\n\
    \    return tonumber(factors[#factors])\nend", "  -- The sieve of Eratosthenes\
    \ is almost certainly a more efficient method, but this is\n  -- a fun exercise.\
    \ Go ahead and implement it.\n  -- https://www.geeksforgeeks.org/sieve-of-eratosthenes/\n\
    \  return 2\nend", "  if n < 2 then return nil end\n  -- We always call this function\
    \ with n a prime number.\n  -- If n is prime then n = 1 and then n is returned.\n\
    \  -- If the number is composite then we compute the prime factorization and take\
    \ the largest.\n  local function compute_prime_factorization(n)\n    -- First\
    \ find the prime factors of n\n    local factors = {}\n    for i = 2, n do\n \
    \     if n % i == 0 then\n        -- This number is not prime\n        -- If this\
    \ number is not prime then n is composite\n        if n > 1 then return nil end\n\
    \        -- This is the largest prime factor of n\n        -- This is the only\
    \ prime factor of n\n        -- We save this factor in factors\n        table.insert(factors,\
    \ i)\n      end\n    end\n    -- Now we have the prime factorization\n    -- If\
    \ we have one factor then the number n is prime\n    -- Otherwise we return nil\n\
    \    -- If n is a composite number then n is prime\n    if #factors == 1 then\n\
    \      -- Return only the largest prime factor\n      return largest(factors)\n\
    \    end\n    -- If we get to here then n is not prime\n    -- We cannot make\
    \ any statements about n\n    return nil\n  end", "  -- If n is a prime, then\
    \ n! > 1 so n's largest prime factor is 1.\n  if n <= 1 then\n    return 1\n \
    \ end", "  assert(n > 1)\n  local factor = 2\n  while n > factor do\n    factor\
    \ = factor * 2\n  end\n  -- TODO: Add fast check to make sure factors are not\
    \ too big.\n  return factor\nend", "  -- Find the largest prime factor of n\n\
    \  -- n is assumed to be > 1\n  -- From the Sieve of Eratosthenes page 49\n  --\
    \ n is assumed to be > 2\n  -- From the Sieve of Eratosthenes page 50\n  -- n\
    \ is assumed to be > 3", "  -- We start off by trying to find a factor of n that\
    \ is less than or equal to n.\n  -- (If n = p * q, where p and q are primes, then\
    \ (p-1)(q-1) is a factor of n.)\n  -- From this point, we'll loop only from 2\
    \ to sqrt(n).", "\t-- http://en.wikipedia.org/wiki/Primality_test\n\tif n == 2\
    \ then return 2 end\n\tif n == 1 then return 1 end\n\t-- If n is even and we've\
    \ already checked that n is prime, return 1.\n\tif n % 2 == 0 and prime_table[n]\
    \ then return 1 end\n\t-- If n is even, check all odd factors up to the square\
    \ root of n.\n\tlocal i = 2\n\twhile i * i <= n do\n\t\tif n % i == 0 then\n\t\
    \t\t-- If the next factor is a prime, we've found a factor > n\n\t\t\t-- so return\
    \ the factor. Also check that the factor is not prime.\n\t\t\tif prime_table[i]\
    \ and prime_table[i] % n ~= 0 then\n\t\t\t\treturn i\n\t\t\tend\n\t\tend\n\t\t\
    i = i + 2\n\tend\n\t-- If no factor > n was found, return 1.\n\treturn 1\nend",
  "    -- TODO: this could probably be sped up by a pysix or two\n    if n == 1 then\n\
    \        return n\n    end\n    -- TODO: this could probably be sped up by a pysix\
    \ or two\n    if n < 3 then\n        return nil\n    end\n    -- TODO: this could\
    \ probably be sped up by a pysix or two\n    if n < 7 then\n        return 3\n\
    \    end\n    -- TODO: this could probably be sped up by a pysix or two\n    local\
    \ max_prime = 1\n    local max_factor = nil\n    for i = 2,n do\n        local\
    \ prime, factor = p:isprime(i)\n        if prime ~= nil then\n            if factor\
    \ > max_factor then\n                max_factor = factor\n                max_prime\
    \ = prime\n            end\n        end\n    end\n    return max_prime\nend",
  "    local max_i = 2\n    local max_n = 1\n    local i = 1\n    while i <= math.sqrt(n)\
    \ do\n        local n_is_prime = true\n        for d = 2, math.sqrt(n) do\n  \
    \          if n % d == 0 then\n                n_is_prime = false\n          \
    \      break\n            end\n        end\n        if n_is_prime then\n     \
    \       max_n = max_i * max_n\n            max_i = i\n        end\n        i =\
    \ i + 1\n    end\n    return max_i * max_n\nend", "    if n > 2 then\n       \
    \ while n % 2 is do\n            n = math.floor(n / 2)\n        end\n        return\
    \ n\n    end\n    return 1\nend", "   -- Make sure n is positive\n   if n < 1\
    \ then return end\n   -- If n is divisible by 2, return 2\n   if n == 1 then return\
    \ 2 end\n   -- If n is evenly divisible by 2, return its square root\n   if n\
    \ % 2 == 0 then return math.sqrt(n) end\n   -- Otherwise, test only the odd integers\n\
    \   for i=3,n,2 do\n      -- If n is divisible by i, and is not prime, return\
    \ i\n      if n % i == 0 then\n         if n ~= i^2 then\n            return i\n\
    \         end\n      end\n   end\n   -- If n is composite, return nil\n   return\
    \ nil\nend", "   -- http://en.wikipedia.org/wiki/Largest-prime-factor\n   -- Compute\
    \ primes up to sqrt(n)\n   local i = 1\n   local p = 1\n   while i * i <= n do\
    \ i = i * p end\n   p = n / i\n   -- Now see if the number is prime\n   while\
    \ p > 1 do\n      if n % p == 0 then\n         return nil\n      else\n      \
    \   p = p - 1\n      end\n   end\n   return i\nend", "  -- https://en.wikipedia.org/wiki/Prime_number#Number_of_prime_divisors\n\
    \  local factors, i = {}, 1\n  repeat\n    local p = math.floor(n / i) + 1\n \
    \   local q = n - p * i\n    if p * i > n or q > n then\n      break\n    end\n\
    \    factors[#factors + 1] = i\n    i = p\n  until n % i == 0\n  -- The largest\
    \ prime factor is then the last element of factors.\n  return factors[#factors]\n\
    end", "  -- Base case: n is 1 or even.\n  -- n is odd and 1 is a prime number.\n\
    \  if n <= 1 then\n    return n\n  end", "  -- Check for small numbers.\n  --\
    \ If they are already factors, return them.\n  if n < 2 then return n end\n  if\
    \ n == 2 then return 2 end", "  local largest = 1\n  local is_prime\n  -- If n\
    \ is divisible by primes less than or equal to n / 2 then\n  -- n has a large\
    \ prime factor so return n.\n  if n <= 1 or n % 2 == 0 then return n end\n  --\
    \ If n is divisible by primes equal to n / 2 then\n  -- return two - n / 2.\n\
    \  if n % 2 == 0 then\n    largest = 2\n  else\n    -- For each prime factor p\
    \ of n do\n    -- if p is less than n / 2 then\n    --   largest = largest * p\
    \ + 1\n    -- else\n    --   is_prime = true\n    --   for i = 2 to p-1 do\n \
    \   --     if p * i >=  n then\n    --       is_prime = false\n    --     end\n\
    \    --     break\n    --   end\n    -- end\n    -- if is_prime == true then\n\
    \    --   largest = largest * n\n    -- end\n    -- largest = largest + 1\n  \
    \  for i = 2, n do\n      if n % i == 0 then\n        is_prime = true\n      \
    \  break\n      end\n    end\n    if is_prime == true then\n      largest = largest\
    \ + 2\n    else\n      largest = largest + 1\n    end\n  end\n  return largest\n\
    end", "   -- The prime factors of n are \n   -- (a) n-1 if n is even\n   -- (b)\
    \ n+1 if n is odd\n   -- In each case:\n   --    * If n is even, divide by 2\n\
    \   --    * If n is odd, divide by 3 and double the result\n   -- The largest\
    \ prime factor is thus either of the two factors.\n   --\n   -- The sieve algorithm\
    \ is a nice example of how to find large factors.\n   --\n   -- Sieve method:\
    \ generate all prime factors and store in a list.\n   -- Then enumerate pairs\
    \ (p, q) where p and q are prime factors.\n   -- In the sieve method, consider\
    \ any integer q not yet tested as prime\n   -- and just multiply its multiples.\n\
    \   --\n   -- This method is optimal since we do no primality testing: we start\n\
    \   -- with the factors 2, 3 and 5 and then only test against the odd numbers.\n\
    \   -- This has logarithmic running time complexity.\n   --\n   -- We use the\
    \ Sieve of Eratosthenes to generate primes up to sqrt(n).\n   -- We keep a boolean\
    \ array which is True for each prime number we have.\n   -- When asked to produce\
    \ a prime factor, if the array element at the\n   -- index `p` is False we know\
    \ that the number is a prime and can\n   -- just return `p`. If the array element\
    \ at the index is True, we have\n   -- found a composite factor which must be\
    \ the largest. Return the\n   -- largest composite factor found.\n   --\n   --\
    \ References:\n   -- http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n   --\
    \ http://stackoverflow.com/questions/4114163/sieve-of-eratosthenes\n   -- http://en.wikipedia.org/wiki/Sieve_of_Atkin\n\
    \   -- \n   -- Note: this algorithm could be further improved upon. This implementation\n\
    \   -- was written to perform well for a small number of factors, but\n   -- could\
    \ take a long time for large factors.", "  if n < 2 then\n    return 1\n  end\n\
    \  if n % 2 == 0 then\n    return 2\n  end\n  local result = 1\n  local m = 3\n\
    \  repeat\n    if n % m == 0 then\n      result = result * (m / n)\n      n =\
    \ n / m\n    end\n    m = m + 1\n  until n > 1\n  return result\nend", "  -- Check\
    \ special case 1.\n  if n > 1 then\n    -- Sieve of Eratosthenes for n > 1\n \
    \   local primes = primes2:new{prime_factors = n:new(prime_factor_table)} -- Create\
    \ prime factors table using Eratosthenes\n    for i = 2, n do\n      primes.prime_factors[i]:add(i\
    \ - 1) -- Add i - 1 to each prime factor\n    end\n    -- Find the largest prime\
    \ factor by comparing each prime factor to n\n    local largest_prime_factor =\
    \ primes.prime_factors[n]\n    for i = primes.prime_factors[n] + 1, #primes.prime_factors\
    \ do\n      if #largest_prime_factor > i then\n        largest_prime_factor =\
    \ primes.prime_factors[i]\n      end\n    end\n    return largest_prime_factor\n\
    \  end\n  -- Check special case 2.\n  if n % 2 == 0 then\n    -- If n is even,\
    \ then it is a prime factor.\n    return 2\n  end\n  -- Check special case 3.\n\
    \  if n % 3 == 0 then\n    -- If n is divisible by 3, then it is a prime factor.\n\
    \    return 3\n  end\n  -- Check special case 4.\n  if n % 5 == 0 then\n    --\
    \ If n is divisible by 5, then it is a prime factor.\n    return 5\n  end\n  --\
    \ Check special case 5.\n  if n % 7 == 0 then\n    -- If n is divisible by 7,\
    \ then it is a prime factor.\n    return 7\n  end\n  -- If n is divisible by 2\
    \ and is not prime, then it is a prime factor.\n  -- Check special case 6.\n \
    \ if n % 2 == 0 then\n    -- If n is even, then it is a prime factor.\n    return\
    \ 2\n  end\n  -- Check special case 7.\n  if n % 3 == 0 then\n    -- If n is divisible\
    \ by 3, then it is a prime factor.\n    return 3\n  end\n  -- If n is divisible\
    \ by 5 or 7, then it is a prime factor.\n  return 5\nend", "    local d = 2\n\
    \    while d <= n do d = d + (n % d) + 1 end\n    return d - 1\nend", "  -- The\
    \ idea of primes came from https://primes.utm.edu/lists/small/millions/\n  --\
    \ See e.g. https://en.wikipedia.org/wiki/Prime_number#Prime-factorization\n  --\
    \ We implement a sieve of Eratosthenes to find all prime factors\n  -- of n between\
    \ 2 and n.\n  -- The sieve is implemented as a list of lists. The outermost list\n\
    \  -- represents a number, while the inner lists represent multiples of that\n\
    \  -- number, as shown below:\n  --  >>> [[], [2, 3], [6, 4, 1]]\n  --  >>> [2,\
    \ 3, 6, 4, 1]\n  --  >>> [2] + [3] + [6, 4, 1]\n  --  >>> [2, 3] + [6, 4, 1]\n\
    \  --  >>> [2], [3, 6], [4, 1]", "\tif n < 2 then return end", "    -- We use\
    \ a variant of binary search for factorization.\n    local function binarySearchFactorization(p,\
    \ limit)\n        local first = 0\n        local last = limit - 1", "    local\
    \ m = 2\n    while n ~= 1 do\n        if n % m == 0 then\n            m = m +\
    \ 1\n        end\n        n = n / m\n    end\n    return m\nend", "  assert(n\
    \ > 1)\n  -- Check if n is prime.\n  if n % 2 == 0 then\n    return 2\n  end\n\
    \  -- Divide n by 2.\n  local n = n / 2\n  -- Loop while n > 1.\n  while n > 1\
    \ do\n    -- Check if n is prime.\n    if n % 2 == 0 then\n      -- Check if n\
    \ > largest prime factor so far.\n      if largest_prime_factor(n) > largest_prime_factor()\
    \ then\n        -- Update largest prime factor.\n        largest_prime_factor\
    \ = n\n      end\n      -- Divide n by 2.\n      n = n / 2\n    else\n      --\
    \ Divide n by 2.\n      n = n / 2\n    end\n  end\n  return n\nend", "    -- Base\
    \ cases\n    if n == 1 then\n        return 1\n    end\n    if n == 0 then\n \
    \       return 0\n    end\n    -- Test for primeness\n    if n % 2 == 0 then\n\
    \        return largest_prime_factor(n / 2)\n    end\n    -- Only odd numbers\
    \ can be factors\n    local max = 1\n    for i = 2, n do\n        if n % i ==\
    \ 0 then\n            max = i\n        else\n            return i\n        end\n\
    \    end\n    return max\nend", "    local i = 1\n    local p = 2\n    while i\
    \ < n do\n        if n % i == 0 then\n            i = i/2\n        else\n    \
    \        i = i + p\n            p = p * 2\n        end\n    end\n    return i\n\
    end", "  local factors = {}\n  factors[1] = n\n  local p = 2\n  while p <= sqrt(n)\
    \ do\n    local q = (p + n - 1) / 2\n    factors[#factors + 1] = p\n    if isqrt(p\
    \ * q) <= n then\n      p = q\n    else\n      n = p\n    end\n  end\n  return\
    \ factors[#factors + 1]\nend", "  if n < 2 then return nil end\n  for i=2,n do\n\
    \    if n % i == 0 then return i end\n  end\nend", "  if n < 2 then return end\n\
    \  n = math.ceil(n)\n  if n % 2 == 0 then return end\n  local p = 2\n  local max_p\
    \ = 1\n  while p <= n do\n    if n % p == 0 then\n      if p > max_p then max_p\
    \ = p end\n      n = n / p\n      p = p + 1\n    else\n      if p > max_p then\
    \ max_p = p end\n      p = p + 1\n    end\n  end\n  return max_p\nend", "    local\
    \ factor = 1\n    while n > 1 do\n        factor = factor * n\n        n = math.floor(n/factor)\n\
    \    end\n    return factor\nend", "    if n < 1 then\n        n = 1\n    end\n\
    \    local p = 2\n    while p * p <= n do\n        local q = 2\n        while\
    \ q * q <= p do\n            if n%p == 0 then\n                break\n       \
    \     elseif p*q > n then\n                return nil\n            end\n     \
    \       q = q + 1\n        end\n        p = p + 1\n    end\n    return p\nend",
  "   -- https://en.wikipedia.org/wiki/Primality_test\n   -- If n is prime then there\
    \ is only one factor to consider (the number itself).\n   -- Also known as the\
    \ Euler's totient function.\n   -- >>> largest_prime_factor(11)\n   -- 2\n   --\
    \ >>> largest_prime_factor(12)\n   -- 2\n   -- >>> largest_prime_factor(147)\n\
    \   -- 3\n   -- >>> largest_prime_factor(29)\n   -- 3\n   -- >>> largest_prime_factor(2937)\n\
    \   -- 3\n   -- >>> largest_prime_factor(3937)\n   -- 3\n   -- >>> largest_prime_factor(8191)\n\
    \   -- 11\n   -- >>> largest_prime_factor(8193)\n   -- 11\n   -- >>> largest_prime_factor(8193)\n\
    \   -- 11\n   -- >>> largest_prime_factor(123)\n   -- 5\n   -- >>> largest_prime_factor(1277)\n\
    \   -- 7\n   -- >>> largest_prime_factor(137)\n   -- 7\n   -- >>> largest_prime_factor(29372937)\n\
    \   -- 3\n   -- >>> largest_prime_factor(293729372937)\n   -- 3\n   -- >>> largest_prime_factor(2937293729372937)\n\
    \   -- 3\n   -- >>> largest_prime_factor(29372937293729372937)\n   -- 5\n   --\
    \ >>> largest_prime_factor(2937293729372937293729372937)\n   -- 7\n   if n % 2\
    \ == 0 then\n      return n\n   end", "    local factors = {}\n    for i = 2,\
    \ n do\n        if n % i == 0 then\n            factors[i] = n\n            n\
    \ = math.ceil(n/i)\n        end\n    end\n    return math.max(factors)\nend",
  "    local function factor(n)\n        local factors = {}\n        for i = 2, n\
    \ do\n            if n % i == 0 then\n                table.insert(factors, i)\n\
    \                n = n / i\n            end\n        end\n        \n        if\
    \ n == 1 then\n            return 1\n        end", "  -- Sieve of Eratosthenes\n\
    \  local p = 2\n  while p < n do\n    if n % p == 0 then\n      local r = p --\
    \ The maximum prime factor so far.\n      for i = p * p + 2 .. n / p * p + p -\
    \ 1; i > n; i -= p do\n        local t = i / p\n        if n % t == 0 then\n \
    \         r = t\n          break\n        end\n      end\n      n = r\n    end\n\
    \    p = p + 1\n  end\n  return n\nend", "  if n == 2 then return 2 end\n  local\
    \ factor = 1\n  for factor = 2 to n do\n    if n % factor == 0 then\n      factor\
    \ = math.floor(n/factor)\n      return factor\n    end\n  end\nend", "    -- First\
    \ check that the input is a positive integer.\n    if n < 1 then\n        return\
    \ nil\n    end", "    local p = 2\n    while p:lt(n) do\n        if n%p ~= 0 then\n\
    \            return p\n        end\n        p = p * 2\n    end\n    return n\n\
    end", "    local factors = {}\n    local primes = {}\n    local i = 1\n    local\
    \ p = n\n    while i <= math.sqrt(n) do\n        if n % i == 0 then\n        \
    \    factors[i] = i\n            primes[i] = true\n        end\n        i = i\
    \ + 1\n    end\n    local lp = nil\n    for i = 1, n do\n        if not primes[i]\
    \ then\n            if lp ~= nil then\n                lp = (lp * factors[i])\
    \ / i\n            else\n                lp = factors[i]\n            end\n  \
    \      end\n    end\n    return lp\nend", "  local is_prime, p, q = false, 2,\
    \ 3\n  local limit, smallest_factor = math.max(2, math.sqrt(n)), 2\n  -- Use a\
    \ breadth-first search instead of depth-first search to avoid consuming all the\
    \ available stack space.\n  while true do\n    if p * p > n then\n      break\n\
    \    end\n    limit = smallest_factor * limit\n    if n % limit == 0 then\n  \
    \    is_prime = true\n      p, q = p, limit / q\n    else\n      smallest_factor\
    \ = q\n    end\n  end\n  return n and p or nil\nend", "   if n == 1 then return\
    \ n end\n   local prime = 1\n   local factor = 2\n   while factor <= n do\n  \
    \    local tmp = math.floor((factor * prime) / 2)\n      if tmp > n then return\
    \ n end\n      if tmp > prime then\n         prime = tmp\n         factor = tmp\n\
    \      else\n         factor = tmp + 1\n      end\n   end\n   return factor\n\
    end", "  -- Check for trivial cases.\n  if n == 1 then\n    return n\n  elseif\
    \ n == 0 then\n    return 0\n  end", "\tlocal function next_prime(n)\n\t\t-- Check\
    \ all the even numbers greater than the square root of n\n\t\tfor i=1,n do\n\t\
    \t\tif (n % i == 0) and (i ~= n) then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\
    \t\treturn true\n\tend", "    assert(n > 1, 'n must be greater than 1')\n    local\
    \ d = 2\n    while d <= n do\n        if n % d == 0 then\n            return d\n\
    \        end\n        d = d + 1\n    end\n    return n\nend", "  -- Only even\
    \ factors matter\n  if n%2==0 then\n    -- Divide by 2 to eliminate even factor\n\
    \    local factor=2\n    -- Repeat until we find a prime factor of n that's >=\
    \ 2\n    repeat\n      -- Divide n by 2 until we find a prime factor\n      factor=factor*2\n\
    \      -- If we found a prime factor then our number is prime\n      -- If no\
    \ prime factors were found then the number is composite\n      if factor>=n then\
    \ return factor\n    until factor>=n\n    -- If the loop terminates because no\
    \ prime factors were found\n    -- then n is not prime\n    return nil\n  end\n\
    \  -- If n is odd then there's no prime factor and no factors are >= 2,\n  --\
    \ so n is prime\n  if n%2==1 then return nil end\n  -- The only even prime factor\
    \ is 2\n  if n==2 then return 2\n  -- A composite number is one that has at least\
    \ as many factors as n\n  -- and whose largest factor is at least 2.\n  local\
    \ factor=2\n  repeat\n    -- Divide n by 2 until we find an even prime factor\n\
    \    factor=factor*2\n    until factor>=n\n    -- If we found an even prime factor\
    \ then our number is prime\n    -- If no even prime factors were found then the\
    \ number is composite\n    if factor>=n then return factor\n  until factor>=n\n\
    \  -- If the loop terminates because no even prime factors were found\n  -- then\
    \ n is not prime\n  return nil\nend", "    local max_factor = 1\n    for i = 2,\
    \ n do\n        if n % i == 0 then\n            n = n / i\n            if n >\
    \ max_factor then\n                max_factor = n\n            end\n        end\n\
    \    end\n    return max_factor\nend", "   -- Make sure n is a positive integer\n\
    \   n = tonumber(n)\n   if n == 0 then\n      return 1\n   end\n   local i, j\
    \ = 2, 1\n   while i < n do\n      local d = n % i\n      if d ~= 0 then\n   \
    \      return i\n      end\n      i = i + 1\n      if i % j == 0 then\n      \
    \   j = j * i\n      end\n   end\n   return j\nend", "  -- Check for small numbers.\n\
    \  local function is_small_number(n)\n    return n <= 2 or (n % 2) == 0 and (n\
    \ % 3) == 0\n  end\n  -- Check if n is prime.\n  local function is_prime(n)\n\
    \    -- Check if n is smaller than 3.\n    if is_small_number(n) then\n      return\
    \ nil\n    end\n    -- Test all possible factors.\n    local function factors(n)\n\
    \      local factors = {}\n      for i = 2, n do\n        if n % i == 0 then\n\
    \          table.insert(factors, i)\n        end\n      end\n      return factors\n\
    \    end\n    -- Check all possible factors.\n    for _, factor in ipairs(factors(n))\
    \ do\n      if n % factor == 0 then\n        return factor\n      end\n    end\n\
    \  end\n  -- If n is not a prime, check if n is greater than 3.\n  local function\
    \ is_greater_than_3(n)\n    if is_small_number(n) then\n      return nil\n   \
    \ end\n    -- Test all possible factors.\n    local function factors(n)\n    \
    \  local factors = {}\n      for i = 2, n do\n        if n % i == 0 then\n   \
    \       table.insert(factors, i)\n        end\n      end\n      return factors\n\
    \    end\n    -- Check all possible factors.\n    for _, factor in ipairs(factors(n))\
    \ do\n      if n % factor == 0 then\n        return factor\n      end\n    end\n\
    \  end\n  if is_prime(n) then\n    return n\n  elseif is_greater_than_3(n) then\n\
    \    return nil\n  else\n    -- Reckless way of finding largest factor.\n    for\
    \ _ = 1, n do\n      local max_factor = 0\n      for _, factor in ipairs(factors(n))\
    \ do\n        if factor > max_factor then\n          max_factor = factor\n   \
    \     end\n      end\n      if max_factor > 1 then\n        return max_factor\n\
    \      end\n    end\n  end\n  return nil\nend", "    local factor = 1\n    for\
    \ i = 2, n do -- Iterate through all factors until factor = 2^i (i is not prime)\n\
    \        if n % i == 0 then\n            factor = i\n            break\n     \
    \   end\n    end\n    return factor\nend", "    if n < 2 then\n        return\
    \ 1\n    end\n    local max = 1\n    local factor = 2\n    while n > 1 do\n  \
    \      -- Only check the square roots if a factor has been found.\n        if\
    \ n % factor == 0 then\n            max = factor\n        end\n        factor\
    \ = factor * 2\n        n = n / factor\n    end\n    return max\nend", "    --\
    \ Base case: n is 1.\n    if n == 1 then\n        return n", "    -- Handle up\
    \ to n = 120 by incrementing n by 2\n    if n > 120 then\n        n = n + 1\n\
    \    end\n    -- Make n odd so it's guaranteed odd\n    n = math.floor(n/2)\n\
    \    -- Repeat while n > 1 is the only factor available\n    while n > 1 do\n\
    \        -- See if any prime factors exceed n\n        local factors = {}\n  \
    \      for i=1, prime_factors[] do\n            if n % i == 0 then\n         \
    \       table.insert(factors, i)\n            end\n        end\n        -- and\
    \ if we have found a prime factor\n        if #factors > 0 then\n            --\
    \ return the largest prime factor of n\n            return table.max(factors)\n\
    \        else\n            -- if we can't find any factors\n            -- add\
    \ 2 to n and try to divide again\n            n = math.floor(n/2) + 2\n      \
    \  end\n    end\n    -- Handle odd numbers\n    return 2\nend", "    if n <= 1\
    \ then\n        return nil\n    end\n    local i, count = 1, 2\n    while i *\
    \ i <= n do\n        i = i + 1\n        if i * i > n then\n            return\
    \ nil\n        end\n    end\n    while count < n do\n        i = i / 2\n     \
    \   if i % 2 == 0 then\n            return i\n        end\n        count = count\
    \ + 1\n    end\nend", "    local largest = 1\n    for i = 3, sqrt(n), 2 do\n \
    \       if n % i == 0 then\n            largest = i\n        end\n    end\n  \
    \  return largest\nend", "  -- The naive approach is O(sqrt(n)).\n  -- There are\
    \ faster approaches, e.g. trial division.\n  -- But none of them beats trial division\
    \ by hand.\n  -- The faster approach would be to use sieve of Eratosthenes or\
    \ a sieve of Atkin.\n  -- Both are O(sqrt(n)) but since we only need the largest\
    \ primes up to sqrt(n), there is no need to calculate all of them up to sqrt(n).",
  "  local factors = {}\n  local root = 1\n  while n > 1 do\n    local i = 1\n   \
    \ while i <= n do\n      if n % i == 0 then\n        if factors[i] ~= nil then\n\
    \          factors[i] = nil\n        else\n          factors[i] = i\n        end\n\
    \      else\n        i = i + 1\n      end\n    end", "   -- Use Sieve of Eratosthenes\
    \ to find the largest prime factor of n.\n   -- Note that this implementation\
    \ is slightly different than the one given\n   -- in the textbook (the one that\
    \ uses the Miller-Rabin test is more efficient),\n   -- so we'll use the one in\
    \ the textbook here.", "  -- Return the largest prime factor of n. Assume n >\
    \ 1 and is not a prime.\n  -- Based on Sieve of Eratosthenes:\n  --   http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \  --   http://stackoverflow.com/questions/22119941/sieve-of-eratosthenes-in-ocaml\n\
    \  -- >>> largest_prime_factor(2718281828)\n  -- 5\n  -- >>> largest_prime_factor(1966521507)\n\
    \  -- 7\n  -- >>> largest_prime_factor(9795985)\n  -- 11\n  -- >>> largest_prime_factor(9795985)\n\
    \  -- 11\n  if n <= 2 then return n end", "    -- See http://stackoverflow.com/questions/286057/maximum-number-of-primes-in-a-given-range\n\
    \    local function next(i)\n        if i == 1 then\n            return 2\n  \
    \      else\n            for j = 3, i, 2 do\n                if i % j == 0 then\n\
    \                    return i\n                end\n            end\n        end\n\
    \    end\n    local function factor(n)\n        if n % 2 == 0 then\n         \
    \   return 2\n        end\n        local i = 3\n        local factors = { 1 }\n\
    \        while i <= n do\n            while n % i == 0 do\n                i =\
    \ next(i)\n                if i == n then\n                    return factors[n]\n\
    \                end\n            end\n            n = n / i\n            table.insert(factors,\
    \ i)\n        end\n        return factors[n]\n    end\n    return factor(n)\n\
    end", "    local factor = 1\n    while n ~= 1 do\n        if n % factor == 0 then\n\
    \            n = n / factor\n        else\n            factor = factor + 1\n \
    \       end\n    end\n    return factor\nend", "   -- Handle even and odd numbers.\n\
    \   if n % 2 == 0 then\n      if n <= 3999 then\n         return 2\n      elseif\
    \ n < 799 then\n         return 3\n      elseif n < 2391 then\n         return\
    \ 5\n      elseif n < 799 then\n         return 7\n      else\n         return\
    \ 11\n      end\n   end\n   -- Start with an arbitrary number and try incrementing\
    \ until we find a factor of n.\n   local a = 2\n   -- Try powers of 2 from 2 up\
    \ to sqrt(n). If we find a factor, keep going.\n   while a <= math.sqrt(n) do\n\
    \      -- We found a factor!\n      if n % a == 0 then\n         return a\n  \
    \    end\n      a = a * 2\n   end\n   return nil\nend", "    local prime_factor\
    \ = nil\n    for prime = 2, n do\n        if n % prime == 0 then\n           \
    \ prime_factor = prime\n            n = n / prime\n        else\n            break\n\
    \        end\n    end\n    return prime_factor\nend", "  -- https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_numbers_s_%24prime_divisors\n\
    \  -- >>> prime_divisors(13195)\n  -- {2, 3, 5, 7, 11, 13, 17, 19}\n  -- >>> prime_divisors(2048)\n\
    \  -- {2, 4, 6, 8}\n  local prime_divisors = require(\"math\").prime_divisors",
  "  assert(n > 1 and n ~= n^2)\n  local p = 2\n  local f = 2\n  local g = n\n  while\
    \ g > 1 do\n    local i = math.floor(math.log(n, p))\n    assert(i > 0)\n    local\
    \ t = math.ceil(p * math.pow(g, i))\n    f = f + 1\n    g = math.floor(n / t)\n\
    \    p = t\n  end\n  f = f - 1\n  return f\nend", "  local primes = {}\n  local\
    \ i = 2\n  while i <= n do\n    if n % i == 0 then\n      primes[#primes + 1]\
    \ = i\n      n = n/i\n    else\n      i = i + 1\n    end\n  end\n  return primes[#primes]\n\
    end", "    -- Base case: n is 1 or less. We need to return n.\n    if n <= 1 then\n\
    \        return n\n    end", "  if n < 2 then\n    return nil\n  elseif n < 3\
    \ then\n    return n\n  else\n    if n % 2 == 0 then\n      return largest_prime_factor(n\
    \ / 2)\n    else\n      local i = 3\n      while i * i <= n do\n        local\
    \ prime_factor = i\n        local remainder = n % prime_factor\n        if remainder\
    \ == 0 then\n          return prime_factor\n        end\n        i = i + 2\n \
    \     end\n    end\n  end\nend", "  local m = n / 2\n  local i = 2\n  while i\
    \ <= m do\n    if n % i == 0 then\n      m = m / i\n      break\n    end\n   \
    \ i = i + 1\n  end\n  return m\nend", "  -- First try trial division without division.\n\
    \  if n == 1 then\n    return 1\n  end\n  -- A natural way to calculate the greatest\
    \ prime factor is to\n  -- add all the numbers from 2 to the number. The sum of\
    \ the\n  -- numbers multiplied by every number from 2 to n would be the\n  --\
    \ largest prime factor. Hence we only need to loop till n/2.\n  for i = 2, n do\n\
    \    if n % i == 0 then\n      return i\n    end\n  end\n  -- No prime factor\
    \ is largest.\n  return nil\nend", "  -- n is assumed to be a prime\n  local d\
    \ = 2\n  while d * d <= n do\n    if n % d == 0 then\n      n = n / d\n      d\
    \ = 2\n    else\n      d = d + 1\n    end\n  end\n  return d\nend", "    local\
    \ factor = 2\n    local max_factor = 2\n    local i = 1\n    while i <= math.sqrt(n)\
    \ do\n        if n % i == 0 then\n            factor = factor * i\n          \
    \  if factor > max_factor then\n                max_factor = factor\n        \
    \    end\n        end\n        i = i + 1\n    end\n    return max_factor\nend",
  "    local factor\n    local i\n    for i = 2, math.sqrt(n) + 1 do\n        if n\
    \ % i == 0 then\n            factor = i\n            break\n        end\n    end\n\
    \    return factor\nend", "    local m = 2\n    local p = 1\n    while not n %\
    \ p then\n        m, p = m, p + 1\n    end\n    return m\nend", "  -- Check n\
    \ is a positive integer.\n  local function is_positive(n)\n    return n and n\
    \ >= 1\n  end", "   if n == 1 then\n      return n\n   else\n      local m = math.ceil(math.sqrt(n))\n\
    \      if n % 2 == 0 then return m end\n      for i = 4, m, 2 do\n         if\
    \ n % i == 0 then return n end\n      end\n   end\nend", "   -- This can be optimized\
    \ for speed, but I didn't want to bother with it.\n   if n == 2 then return 2\
    \ end\n   if n < 2 then return 1 end", "  -- https://math.stackexchange.com/questions/15652/what-is-the-greatest-factor-of-a-prime-number\n\
    \  local factor = 1\n  while true do\n    if n % factor == 0 then\n      return\
    \ factor\n    end\n    factor = factor + 1\n    if factor % prime_size ~= 0 then\n\
    \      -- If it is not divisible by primes up to the square root of the number\
    \ then it is not prime\n      return nil\n    end\n    factor = factor / prime_size\n\
    \  end\nend", "    local factors\n    for i = 2, n do -- Iterate from 2 to n /\
    \ 2\n        local divisor = i\n        -- Keep dividing n by i until i equals\
    \ 1.\n        while n % i == 0 do\n            n = n / i\n            divisor\
    \ = i\n        end\n        if divisor > factors then\n            factors = divisor\n\
    \        end\n    end\n    return factors\nend", "    local m = 1\n    for i =\
    \ 2, n do\n        if n % i == 0 then\n            m = i\n        end\n    end\n\
    \    return m\nend", "  if n == 1 then\n    return 2\n  end\n  if n % 2 == 0 then\n\
    \    return 2\n  end\n  local d = 3\n  while d <= math.sqrt(n) do\n    if n %\
    \ d == 0 then\n      return d\n    end\n    d = d + 1\n  end\n  return n\nend",
  "    local i = 1\n    local result = 2\n    while i <= n do\n        if n % i ==\
    \ 0 then\n            if i ~= n then\n                result = i\n           \
    \ end\n        end\n        i = i + 1\n    end\n    return result\nend", "\t--\
    \ If the number is 1, then return 1, since 1 is a prime factor.\n\tif n == 1 then\
    \ return 1 end", "  local factors, is_prim = factorize(math.floor(n))\n  if is_prim\
    \ then -- If n is a prime, factors are equal to n.\n    return n \n  else -- Otherwise,\
    \ take the largest prime factor.\n    local max_factor_idx = #factors\n    local\
    \ max_factor = 1\n    for i = 1, max_factor_idx do -- Calculate largest prime\
    \ factor.\n      if is_prime[i] then -- If i is a prime, factor i is equal to\
    \ i.\n        max_factor = i\n        break\n      elseif n % i == 0 then -- If\
    \ i is not a prime and n is not a prime, factorize n.\n        factors, is_prim\
    \ = factorize(n)\n        n = n / i\n      end\n    end\n    return max_factor\
    \ * factors[max_factor_idx]\n  end\nend", "    -- Use a sieve of Eratosthenes\
    \ to generate the largest prime factors.\n    -- See https://stackoverflow.com/a/3018122/124376\
    \ and https://stackoverflow.com/a/5643096/124376\n    if n < 2 then\n        return\
    \ nil\n    end\n    local x = 2\n    local max_x = math.floor(math.sqrt(n))\n\
    \    while x > max_x do\n        local i = 1\n        while i <= n do\n      \
    \      local m = n / i\n            if m == i then\n                return i\n\
    \            end\n            i = i * x + 2\n        end\n        x = x + 1\n\
    \    end\n    return x\nend", "    local max_factor = 2\n    local p = nil", " \
    \   -- Trial division with primes ending in 5 is a straight linear search.\n \
    \   local function sieve(end)\n        local primes = {}\n        for i = 2, end\
    \ do\n            if primes[i] then\n                return i\n            end\n\
    \            primes[#primes + 1] = 5 * i + i\n        end\n        return end\n\
    \    \n    local function is_factor(k, i)\n        if k == 0 then\n          \
    \  return true\n        elseif k % i == 0 then\n            return false\n   \
    \     else\n            return sieve(i - 1) == nil\n        end\n    end\n   \
    \ \n    local function largest_prime_factor(n)\n        -- Sieve of Eratosthenes\
    \ from http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python\n\
    \        local primes = {}\n        for i = 2, n do\n            primes[#primes\
    \ + 1] = false\n        end\n        local max_p = 1\n        for p = 2, n do\n\
    \            if primes[p] then\n                for i = p * p, n, p do\n     \
    \               primes[#primes + 1] = false\n                end\n           \
    \     max_p = p\n            end\n        end\n        return max_p\n    end\n\
    \    \n    -- Return largest prime factor.\n    -- Assume n > 1 and is not a prime.\n\
    \    if n <= 1 then\n        return n\n    elseif n % 2 == 0 then\n        local\
    \ p = largest_prime_factor(n / 2)\n        if p * p > n then\n            return\
    \ p\n        else\n            return nil\n        end\n    else\n        return\
    \ is_factor(largest_prime_factor(n), n)\n    end\nend\n</cell>\n<cell>", "  if\
    \ n < 2 then return end\n  local i = 2\n  while i * i <= n do\n    if n % i ==\
    \ 0 then return i end\n    i = i * i\n  end\n  return n\nend", "  if n == 2 then\
    \ return 1 end\n  -- We only need every second prime to reach our limit.\n  local\
    \ i = 1\n  local factor = nil\n  while i < n do\n    local prime = 1\n    while\
    \ n % prime == 0 do\n      prime = prime + 1\n    end\n    if i > 1 and prime\
    \ > factor then\n      factor = prime\n    end\n    i = i + 2\n  end\n  return\
    \ factor\nend", "  assert(n > 1)\n  assert(not prime_check(n))\n  local function\
    \ factor()\n    local p = 1\n    while not prime_check(p) and p <= n do\n    \
    \  p = p * p\n    end\n    return p\n  end\n  local prime = factor()\n  if n ==\
    \ prime then\n    return n\n  elseif prime == 1 then\n    return 0\n  else\n \
    \   -- Find the highest factor smaller than n and subtract it from the number\
    \ to get the next highest factor\n    local max_small = math.pow(prime, 2)\n \
    \   local n1 = n - max_small\n    -- find the highest factor smaller than n\n\
    \    local max_large = math.pow(prime, n1)\n    return max_large - max_small +\
    \ 1\n  end\nend", "  if n==1 then\n    return 1\n  else\n    local m = 2\n   \
    \ while m * m <= n do\n      if n % m == 0 then\n        return m\n      end\n\
    \      m = m + 1\n    end\n  end\nend", "    local max_factor = 1\n    local prime_factor\
    \ = 2\n    while prime_factor <= n do\n        if n % prime_factor == 0 then\n\
    \            max_factor = max(max_factor, prime_factor)\n        end\n       \
    \ prime_factor = prime_factor + 2\n    end\n    return max_factor\nend", "  --\
    \ Factor the prime factorization of n.\n  -- The prime factorization is defined\
    \ as\n  --\n  --   f(n) = f(n-1) * f(n-2) * ... * f(1)\n  --\n  -- for all n >=\
    \ 2.", "  if n < 2 then\n    return nil\n  elseif n < 4 then\n    return 2\n \
    \ else\n    local i = 3\n    while i * i <= n do\n      if n % i == 0 then\n \
    \       return i\n      end\n      i = i * i\n    end\n  end\nend", "  local primes\
    \ = prime_factors(n)\n  local largest = 0\n  for i,pname in ipairs(primes) do\n\
    \    if pname > largest then\n      largest = pname\n    end\n  end\n  return\
    \ largest\nend", "  -- Base case: n is a prime\n  if n <= 2 then return end",
  "   -- A prime factor will be at least 2\n   if n <= 1 then return 1 end\n   --\
    \ Factor n is larger than all numbers smaller than n squared.\n   -- So n is prime\
    \ if and only if n is divisble by any prime\n   -- factor smaller than n.\n  \
    \ for i = 2, n do\n      -- If n is a prime factor of i then n must be evenly\
    \ divisable by i^2\n      if n ~= i then\n         -- Check if n divides i^2 without\
    \ remainder.\n         if n % i == 0 then\n            -- n is not a prime factor\
    \ of i, so n is no larger than i^2.\n            return i\n         end\n    \
    \  end\n   end\n   -- n must be evenly divisable by all primes up to n.\n   return\
    \ n\nend\n</code>\nNow the code you actually need is as simple as this:\n<code>",
  "\t-- Check for special cases. There are more efficient ways to do this,\n\t-- but\
    \ this is the clearest way I can think of.", "   -- Use Horner's method for computing\
    \ GCD.\n   -- This algorithm is known to run in expected linear time.\n   -- See\
    \ \"The Design of Computer Algorithms\" by Menezes, Osorio, Pacetto, & P. Sockably.\n\
    \   -- Chapter 7\n   local function gcd(a, b)\n      if a == 0 and b == 0 then\n\
    \         return 1\n      end\n      if a > b then\n         local temp = a\n\
    \         a = b\n         b = temp\n      end\n      while a > 1 do\n        \
    \ local q = a % b\n         a = b\n         b = q\n      end\n      return b\n\
    \   end\n   if n == 2 then\n      return 2\n   end\n   local result = 1\n   local\
    \ prime = 2\n   local max_factor = 2\n   while prime <= n do\n      if n % prime\
    \ == 0 then\n         result = prime * result\n         if result > n then\n \
    \           result = n\n         end\n      elseif n % (prime * 2) == 0 then\n\
    \         result = prime * result + 2\n         if result > n then\n         \
    \   result = n\n         end\n      elseif n % (prime * 3) == 0 then\n       \
    \  result = prime * result + 3\n         if result > n then\n            result\
    \ = n\n         end\n      elseif n % (prime * 5) == 0 then\n         result =\
    \ prime * result + 5\n         if result > n then\n            result = n\n  \
    \       end\n      elseif n % (prime * 7) == 0 then\n         result = prime *\
    \ result + 7\n         if result > n then\n            result = n\n         end\n\
    \      elseif n % (prime * 11) == 0 then\n         result = prime * result + 11\n\
    \         if result > n then\n            result = n\n         end\n      elseif\
    \ n % (prime * 13) == 0 then\n         result = prime * result + 13\n        \
    \ if result > n then\n            result = n\n         end\n      elseif n % (prime\
    \ * 17) == 0 then\n         result = prime * result + 17\n         if result >\
    \ n then\n            result = n\n         end\n      elseif n % (prime * 19)\
    \ == 0 then\n         result = prime * result + 19\n         if result > n then\n\
    \            result = n\n         end\n      elseif n % (prime * 23) == 0 then\n\
    \         result = prime * result + 23\n         if result > n then\n        \
    \    result = n\n         end\n      elseif n % (prime * 29) == 0 then\n     \
    \    result = ", "    local largest = n / 2\n    while largest * largest <= n\
    \ do\n        largest = largest + 1\n    end\n    return largest\nend", "  --\
    \ We use a sieve, since it is faster to sieve odd numbers than primes.\n  -- We\
    \ use the fact that 2 is a prime and 3 only has 2 factors.\n  -- See http://primes.utm.edu/notes/faq/notes003.html\n\
    \  -- See also http://primes.utm.edu/notes/faq/notes011.html", "\tlocal factors\
    \ = {}\n\t-- Prime factors are only odd integers.\n\tlocal next_num = math.floor(n/2)\n\
    \t-- Iterate through all the prime numbers till n\n\twhile next_num ~= 1 do\n\t\
    \t-- If the current number is prime, then add it to the list.\n\t\tif next_num\
    \ > 1 and not prime_checker(next_num) then\n\t\t\t-- The current number is not\
    \ prime if it is of the form 4n+1 or 4n+3\n\t\t\tif next_num % 2 == 0 and next_num\
    \ ~= n then\n\t\t\t\tfactors[next_num] = 2\n\t\t\telse\n\t\t\t\t-- If the current\
    \ number is not prime, then it is of the form 4n+2 so add it to the list.\n\t\t\
    \t\tfactors[next_num] = 1\n\t\t\tend\n\t\tend\n\t\tnext_num = next_num + 2\n\t\
    end\n\t-- Return the number that has the largest prime factor.\n\t-- Since the\
    \ numbers are stored as odd integers, 1 is the largest.\n\treturn factors[1]\n\
    end", "\tassert(n > 1)\n\tlocal factor = 1\n\tfor i = 1, n do\n\t\tlocal m = n\
    \ % i\n\t\tif not m then\n\t\t\tfactor = factor * i\n\t\t\tn = n / i\n\t\tend\n\
    \tend\n\treturn factor\nend", "  local divisor = 1\n  local prime = 2\n  while\
    \ prime <= n do\n    while n % prime == 0 do\n      divisor = prime\n      prime\
    \ = prime + 1\n    end\n    n = n / prime\n  end\n  return divisor\nend", "  \
    \  local divisor = math.floor(math.sqrt(n)) + 1\n    local i = 1\n    while i\
    \ * divisor <= n do\n        local new_i = i * divisor\n        if new_i == n\
    \ then\n            return n -- It's a prime factor.\n        elseif new_i % divisor\
    \ == 0 then\n            return n -- It's not a prime factor because new_i is\
    \ a multiple of divisor.\n        else\n            divisor = divisor * 2\n  \
    \      end\n        i = i + 1\n    end\n    return n -- It's a prime factor greater\
    \ than n.\nend", "  local p = 2\n  local q = 2\n  local r = 1", "   if n < 2 then\n\
    \      return nil\n   end", "  -- Base case\n  if n < 2 then\n    return 1\n \
    \ end\n  -- Check if n is a prime\n  -- Skip even numbers\n  local is_prime =\
    \ true\n  for i = 2,n do\n    if n % i == 0 then\n      is_prime = false\n   \
    \   break\n    end\n  end\n  if is_prime then\n    return n\n  end\n  -- Find\
    \ the largest factor of n greater than or equal to its square root\n  local factor\
    \ = 1\n  while n % factor == 0 do\n    factor = factor * 2\n  end\n  return factor\n\
    end", "  if n < 2 then\n    return nil\n  end\n  for i = 1, n do\n    local prime\
    \ = i\n    for j = 2, i do\n      prime = prime % j\n      if prime == 0 then\n\
    \        break\n      end\n    end\n    if prime > n then\n      return i\n  \
    \  end\n  end\n  return nil\nend", "    local primeFactors = {}\n    for i=2,n\
    \ do\n        local isPrime = true\n        for j=1,i do\n            if n % i\
    \ == 0 then\n                isPrime = false\n            end\n        end\n \
    \       if isPrime then\n            table.insert(primeFactors, i)\n        end\n\
    \    end\n    return table.remove(primeFactors, 1)\nend", "\t-- Sieve of Eratosthenes\
    \ (http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n\t-- http://stackoverflow.com/questions/24101540/fastest-way-to-find-the-prime-factors-of-a-number-in-python\n\
    \t-- http://stackoverflow.com/questions/1270337/python-program-to-find-the-greatest-prime-factor-of-a-number",
  "  -- We could use bitwise operations on the primes table, but that's very slow.\n\
    \  -- We use the Sieve of Eratosthenes with a bit of extra caching.\n  local is_prime[#primes\
    \ + 1] = true\n  is_prime[1]=true\n  local d = 2 -- The \"running number\".\n\
    \  local prime = 2 -- The largest prime found so far.\n  local m = 2 -- The next\
    \ candidate prime\n  local k = 0 -- The running index for the sieve\n  repeat\n\
    \    if is_prime[k] then\n      if k > m then -- If we've found a new largest\
    \ prime factor.\n        prime = k\n        m = k + 1 -- The next candidate prime.\n\
    \      end\n      k = k + d -- Move to the next candidate prime.\n    end\n  \
    \  local is_composite = false -- Use a bitwise AND operation instead of a modulo\
    \ operation.\n    for i = d, n, d do -- Try all numbers from n to the square root\
    \ of n.\n      if ((n % i) == 0) then -- If the number is composite.\n       \
    \ is_composite = true\n        break\n      end\n    end\n    -- Exit the loop\
    \ if we found a prime factor.\n    if is_prime then\n      is_prime[prime] = false\n\
    \      return prime\n    end\n    -- Continue with the next number in the sieve.\n\
    \    k = k + 1 \n  until k > m and k < #is_prime\n  -- If we get here then we\
    \ know that k >= m and n is not a prime.\n  prime = k\n  m = k + 1 -- The next\
    \ candidate prime.\n  is_prime[prime] = false\n  return prime\nend\n</cell>\n\
    <code language=julia-1.5>\nlargest_prime_factor(13195)\n</cell>\n<code language=julia-1.5>\n\
    largest_prime_factor(2048)\n</cell>\n<text>\nExercise 3: Design a composite number\
    \ generator using a Sieve of Eratosthenes and Julia's @inbounds macro.\nNow suppose\
    \ we want to write a composite number generator for composite numbers. That is,\
    \ all prime factors of n should be used and each must be greater than or equal\
    \ to one another.", "  -- Check for n being 1 or less\n  if n < 2 then\n    return\
    \ 1\n  end", "  -- Initialize with n. If n is a prime, return n+1.\n  -- If n\
    \ is even, return the highest odd number larger than n.\n  -- If n is odd, return\
    \ the highest odd number smaller than n.\n  -- Note that even numbers in range(3,n)\
    \ are not considered prime since it is\n  -- not divisible by 3.\n  local function\
    \ odd(n)\n    return n and math.floor(n/2) % 2 == 0 and n or nil\n  end\n  local\
    \ function even(n)\n    return n and math.floor(n/2) % 2 ~= 0 and n or nil\n \
    \ end\n  -- If n is a composite number, return nil.\n  -- If n is odd and divisible\
    \ by 2, return 2.\n  -- If n is odd and divisible by 3, return 3.\n  -- If n is\
    \ odd and divisible by 5, return 5.\n  -- If n is odd and divisible by 7, return\
    \ 7.\n  -- If n is odd and divisible by 11, return 11.\n  -- If n is odd and divisible\
    \ by 13, return 13.\n  -- If n is odd and divisible by 17, return 17.\n  -- If\
    \ n is odd and divisible by 19, return 19.\n  -- If n is odd and divisible by\
    \ 23, return 23.\n  -- If n is odd and divisible by 29, return 29.\n  -- If n\
    \ is odd and divisible by 31, return 31.\n  -- If n is odd and divisible by 37,\
    \ return 37.\n  -- If n is odd and divisible by 41, return 41.\n  -- If n is odd\
    \ and divisible by 43, return 43.\n  -- If n is odd and divisible by 47, return\
    \ 47.\n  -- If n is odd and divisible by 53, return 53.\n  -- If n is odd and\
    \ divisible by 59, not prime since it is divisible by 3.\n  -- If n is odd and\
    \ divisible by 61, return 61 (note that 61's prime factors are\n  -- 3,5 and 7).\n\
    \  -- If n is odd and divisible by 71, return 71.\n  -- If n is odd and divisible\
    \ by 73, return 73.\n  -- If n is odd and divisible by 79, not prime since it\
    \ is divisible by 7.\n  -- If n is odd and divisible by 81, return 81 (note that\
    \ 81's prime factors are\n  -- 3,5 and 11).\n  -- If n is odd and divisible by\
    \ 83, return 83 (note that 83's prime factors are\n  -- 3,", "   if n < 2 then\n\
    \      return nil\n   end\n   if n == 2 then\n      return 1\n   end\n   if n\
    \ % 2 == 0 then\n      return nil\n   end\n   local max = 3\n   for i = 5, n do\n\
    \      local tmp = i\n      for j = i * 2, n, 2 do\n         if j > n then\n \
    \           j = j - n\n            tmp = tmp * j\n         end\n      end\n  \
    \    if tmp > max then\n         max = tmp\n      end\n   end\n   return max\n\
    end", "    local function is_prime(p)\n        for i = 2, p do\n            if\
    \ n % i == 0 then\n                return nil\n            end\n        end\n\
    \        return true\n    end", "\t-- Prime factors are calculated using Extended\
    \ Euclid's algorithm.\n\t-- For details, see http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.\n\
    \tlocal function extended_euclidean(m, n)\n\t\treturn m * n / math.gcd(m, n)\n\
    \tend", "    local largest = 1\n    for i = 2, n do\n        if n % i == 0 then\n\
    \            largest = i\n        end\n    end\n    return largest\nend", "  \
    \  -- If the number is a power of 2, it is the largest prime factor.\n    if n\
    \ <= 1 then return 1 end", "    local i = 1\n    local c = 0\n    while i * i\
    \ <= n do\n        local r = n % i\n        if r == 0 then\n            i = i\
    \ + 1\n        else\n            n = n / i\n            i = i + 1\n          \
    \  c = i\n        end\n    end\n    return c\nend", "  local i = 1\n  while i\
    \ * i <= n do\n    if n % i == 0 then\n      if i * i > n then\n        i = 2\n\
    \      else\n        n = n / i\n      end\n    else\n      i = i + 1\n    end\n\
    \  end\n  return i\nend", "    local m = n - 1\n    local i = 1\n    local p =\
    \ 2\n    local isprime = 1\n    while i <= m do\n        if n % i == 0 then\n\
    \            if i ~= n then isprime = 1 end\n            i = i * (p - 1)\n   \
    \         n = n / i\n        else\n            p = p + 1\n            i = i +\
    \ 1\n        end\n    end\n    return n >= 1 and n or nil\nend", "  if n < 2 then\
    \ return 1 end\n  local p = 2\n  while p*p <= n do\n    if n % p == 0 then return\
    \ p end\n    local q = p*p\n    p, q = p+1, q+1\n  end\n  return n\nend", "  \
    \  local function factor(n, count)\n        count = count or 0\n        if n ==\
    \ 1 then\n            return count\n        else\n            for i = 2, n do\n\
    \                count = i * count\n                if n % i == 0 then\n     \
    \               count = count + 1\n                    break\n               \
    \ end\n            end\n        end\n        return count\n    end", "  local\
    \ factor = 1\n  for i = 2, n do\n    if n % i == 0 then\n      factor = i\n  \
    \    break\n    end\n  end\n  return factor\nend", "    local factors\n    repeat\n\
    \        factors = {}\n        for i = 2, n do\n            -- Test for divisibility\
    \ by all prime factors <= sqrt(n)\n            if n % i == 0 then\n          \
    \      -- i^2 > n, so no prime factor found\n                return nil\n    \
    \        end\n            -- Add i to the factors, unless i is divisible by n\n\
    \            if i ~= n and n % i == 0 then\n                table.insert(factors,\
    \ i)\n            end\n        end\n    until not table.empty( factors )\n   \
    \ -- return n, since it is the largest prime factor found\n    return n\nend",
  "\t-- Handle small prime factors.\n\tif n < 2 then return 2 end", "    local p,\
    \ s, d = n % 2, n, 1\n    while d % 2 == 0 and d > 1 do\n        p = p + 1\n \
    \       s, d = s, d / 2\n    end\n    return p, s\nend", "    local factors =\
    \ factor(n)\n    return factors[#factors] or nil\nend", "  -- Base case: n <=\
    \ 1\n  if n <= 1 then\n    return 1\n  end", "  -- This would require an O(sqrt(n))\
    \ algorithm\n  -- It would be easy to implement using the Sieve of Eratosthenes\n\
    \  -- -- For a number n > 1, a prime factor > 1 is a factor of the smallest number\
    \ > n/2.\n  -- The smallest prime factor of n must be larger than n.\n  -- So\
    \ a prime factor is always a factor of the smallest number > n/2\n  -- >>> largest_prime_factor(100)\n\
    \  -- 4\n  -- >>> largest_prime_factor(115)\n  -- 3\n  -- >>> largest_prime_factor(170)\n\
    \  -- 3\n  -- >>> largest_prime_factor(19)\n  -- 5\n  -- >>> largest_prime_factor(20000)\n\
    \  -- 7\n  -- >>> largest_prime_factor(25)\n  -- 7\n  -- >>> largest_prime_factor(1025)\n\
    \  -- 13\n  -- >>> largest_prime_factor(1000000007)\n  -- 5\n  -- >>> largest_prime_factor(1000000009)\n\
    \  -- 11\n  -- >>> largest_prime_factor(10000000070)\n  -- 11", "    local max_divisor\
    \ = 1\n    local max_divisor2 = 0", "  -- If n is even then it is even.\n  if\
    \ n ~= math.floor(n) then\n    return nil\n  end", "    local largest = 1\n  \
    \  for i = 2, n do\n        if n % i == 0 then\n            if i > largest then\n\
    \                largest = i\n            end\n        end\n    end\n    return\
    \ largest\nend", "   -- See http://primes.utm.edu/lists/small/millions.txt for\
    \ a list of primes\n   -- with more than 100,000 divisiors.\n   if n > 20000 then\n\
    \      return nil\n   end", "  -- Sieve of Eratosthenes trial division\n  --\n\
    \  -- The sieve of eratosthenes is an algorithm that finds the largest prime factor\
    \ of a number \n  -- and also tests to see if it is prime.\n  --\n  -- First we\
    \ set up the sieve. We'll go through the number one by one\n  -- and test each\
    \ number to see if it is a prime number, or is a test number\n  -- and if it's\
    \ prime we will add it to a list of prime numbers.\n  --\n  -- The list will look\
    \ like this:\n  --\n  --     2, 3, 5, 7, 11, 13, 17, 19\n  --\n  -- and so on\
    \ with each number greater than the previous.\n  --\n  local sieve = {}", "  \
    \  -- Base case for recursion.\n    if n == 1 then\n        return 1;\n    end",
  "  -- Base case:\n  if n==1 then return 1\n  -- If n is prime then it's no prime\
    \ factor.\n  -- If n is greater than 1 then n-1 is prime so this factor is less\
    \ than n.\n  if n%2==0 then return nil end\n  -- If n is divisible by three then\
    \ it's no prime factor.\n  -- If n is divisible by six then it is no prime factor\
    \ because it is also divisible by five.\n  -- If n is divisible by nine then it\
    \ is no prime factor because it is also divisible by two.\n  if n%3==0 or n==5\
    \ then return nil end\n  -- If n is divisible by three and six then it is no prime\
    \ factor because it is also divisible by four.\n  if n%6==0 or n==8 then return\
    \ nil end\n  -- If n is divisible by three and nine then it is no prime factor\
    \ because it is also divisible by one.\n  if n%9==0 or n==11 then return nil end\n\
    \  -- If we made it here then n is not prime so it is prime or composite factor\
    \ of n.\n  -- If n is divisible by two, five, ten, twenty, or hundred then it\
    \ is prime otherwise it is composite factor of n.\n  return n\nend", "   if n\
    \ <= 1 then return 1 end\n   if n % 2 == 0 then return n end\n   if n % 3 == 0\
    \ then return n end\n   if n % 5 == 0 then return n end\n   if n % 7 == 0 then\
    \ return n end\n   return n - 1\nend", '  if n < 2 then return 1 end', "  local\
    \ max_factor = 1\n  local p = 2\n  while p < n do\n    if n % p == 0 then\n  \
    \    max_factor = max( max_factor, p + 1 )\n    end\n    p = p + 2\n  end\n  return\
    \ max_factor\nend", "  -- The Largest Prime Factor of N is N! (where N is greater\
    \ than 1)\n  -- http://en.wikipedia.org/wiki/Largest_prime_factor", "    local\
    \ factor = 1\n    local i = 1\n    while i * factor <= n do\n        if n % i\
    \ == 0 then\n            factor = 0\n        else\n            factor = math.floor(n\
    \ / i)\n        end\n        i = i * 2\n    end\n    return factor\nend", "  \
    \  local m\n    if n < 3 then return 1 end\n    for m = 2, 3, 4 do\n        local\
    \ q = n % m\n        if q == 0 and m > 2 then return m end\n        n = n / m\n\
    \    end\nend", "  if n == 1 then return 1 end\n  local lf, r = math.floor(math.log(n)\
    \ / math.log(2)), math.ceil(math.sqrt(n))\n  while lf < r and n % 2 == 0 do\n\
    \    n, r = r, n / 2\n  end\n  while lf < r and n % 2 == 1 do\n    n, r = r, n\
    \ / 2\n  end\n  if lf > r then return lf else return r end\nend", "    if n ==\
    \ 0 then return 1 end\n    local i = 1\n    while i * i <= n do\n        if n\
    \ % i == 0 then\n            n = n / i\n        else\n            i = i + 1\n\
    \        end\n    end\n    return n\nend", "    if n < 2 then\n        error('Not\
    \ prime number', 2)\n    end", "  local result = 2\n  local d = math.sqrt(n)\n\
    \  if d < 2 then return result else return largest_prime_factor(d) end\n  local\
    \ i = 1\n  while i * i <= n do\n    if n % i == 0 then return i\n    end\n   \
    \ i = i + 1\n  end\n  return result\nend", "  -- First approximation\n  --\n \
    \ --     FLOOR(n/log(E))\n  --     ------------------\n  --         n   if n is\
    \ prime\n  --        -1   otherwise\n  -- Reference: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \  --\n  -- Reference: https://en.wikipedia.org/wiki/Euler%27s_totient_function\n\
    \  -- Reference: http://primes.utm.edu/notes/faq/eratosthenes.html", "    -- Use\
    \ Sieve of Eratosthenes and check if n is a prime number.\n    -- Use Lucas Numbers\
    \ and return prime factors\n    if n < 2 then\n        return nil\n    end\n \
    \   -- Use Lucas Numbers\n    if n < 7 then\n        return n\n    end", "   \
    \ local factor = 1\n    local i = 1\n    while factor <= n do\n        factor\
    \ = math.pow(i, factor, n)\n        i = i + 1\n    end\n    return factor\nend",
  "    -- Initialization\n    local r = 1\n    local i = 2\n    -- Perform trial division\n\
    \    while i <= n do\n        if n % i == 0 then\n            r = i\n        \
    \    n = n / i\n            i = 2\n        else\n            i = i + 1\n     \
    \   end\n    end\n    -- Return largest prime factor of n\n    return r\nend\n\
    </cell>\n<cell>", "    local factors = {}\n    local m = 2", "    local factors\
    \ = prime_factors(n)\n    local largest_prime_factor = nil\n    local largest\
    \ = 1\n    for _, factor in ipairs(factors) do\n        if factor > largest then\n\
    \            largest = factor\n            largest_prime_factor = factor\n   \
    \     end\n    end\n    return largest_prime_factor\nend", "  local n\n  if n\
    \ % 2 == 1 then return n end\n  for prime_number = 3, n / 2, 2 do\n    if n %\
    \ prime_number == 0 then\n      return prime_number\n    end\n  end\nend", " \
    \  if n > 1 then\n      local i = 1\n      while i * i <= n do\n         if n\
    \ % i == 0 then\n            i = 2\n            while i * i <= n do\n        \
    \       if n % i == 0 then\n                  return i\n               else\n\
    \                  i = i * 2\n               end\n            end\n         else\n\
    \            i = i * 2\n         end\n      end\n      return i\n   else\n   \
    \   return 1\n   end\nend", "  if n < 2 then return nil end\n  if prime_list[n]\
    \ then return n end\n  -- Increase n by 2 and see if it is prime. If it is composite,\
    \ go back to step 1.\n  local i = 2\n  while i * i <= n do\n    local ii = i *\
    \ i\n    if prime_list[ii] then return ii end\n    n = ii\n    i = i + 2\n  end\n\
    \  return nil\nend", "  if n % 2 == 0 then return 2 end\n  -- Find largest factor\
    \ p such that p * p > n and p is not a prime\n  -- for p * p > n, there are only\
    \ two factors: 2 and n - 1\n  -- for p * p <= n, there are three factors: n +\
    \ 1 and the largest prime factor of p\n  local largest_prime_factor = 1\n  while\
    \ n > largest_prime_factor:\n    largest_prime_factor = math.floor((math.pow(largest_prime_factor,\
    \ 2) + math.pow(n - largest_prime_factor, 2))/2)\n  -- Now n is prime, find the\
    \ largest factor of n\n  while n % largest_prime_factor == 0 do\n    largest_prime_factor\
    \ = largest_prime_factor * 2\n  end\n  -- Now largest prime factor is less than\
    \ n\n  assert(largest_prime_factor < n)\n  return largest_prime_factor\nend",
  "  if n < 2 then\n    return nil\n  elseif n == 1 then\n    return 2\n  elseif n\
    \ % 2 == 0 then\n    return 2\n  elseif n % 3 == 0 then\n    return 3\n  elseif\
    \ n % 5 == 0 then\n    return 5\n  elseif n % 7 == 0 then\n    return 7\n  else\n\
    \    return largest_prime_factor(n - 1) / n\n  end\nend", "  -- Largest prime\
    \ factor is 1 because n cannot be a prime number.\n  if n <= 1 then return 1 end",
  "  -- Sieve of Eratosthenes for large values of n.\n  local function factorizer(n)\n\
    \    local function next(i, f)\n      if i < f then\n        return i, factorizer(n\
    \ - i * i)\n      elseif n % i == 0 then\n        return next(i + 1, f), i\n \
    \     else\n        return next(i - 1, f), i\n      end\n    end\n    local i,\
    \ f = next(n, 2)\n    if f == n then\n      return i\n    else\n      return next(i,\
    \ f + 1)\n    end\n  end\n  return factorizer(n)[1]\nend", "\tif n == 2 then return\
    \ n end\n\tif n == 1 then return n end\n\tif n % 2 == 1 then return n end\n\t\
    local i = 3\n\twhile i * i <= n do\n\t\tlocal c = math.mod(n, i)\n\t\tif c ==\
    \ 1 then return i end\n\t\ti = i + 2\n\tend\n\treturn n\nend", "    -- The largest\
    \ prime factor is n-1 if n is prime. It is a factor of n if n/p\n    -- has the\
    \ same largest prime factor. Let m = p-1. Then, m = n-1 if n/m has\n    -- the\
    \ same largest prime factor of n. This follows immediately from the fact that\n\
    \    -- m > p-1.\n    local m = math.floor(n/2)\n    local p = 2\n    while p\
    \ <= m do\n        if n % p == 0 then\n            -- The prime factor p of n\
    \ is larger than n/p, so n is not prime and n / p is\n            -- not a factor.\n\
    \            if n > m then\n                return nil\n            else\n   \
    \             return p\n            end\n        elseif n/p > n then\n       \
    \     -- n/p is larger than n so n/p has a larger prime factor than p.\n     \
    \       -- n/p has the same largest prime factor as p.\n            if p > m then\n\
    \                return nil\n            else\n                return p\n    \
    \        end\n        elseif n <= (m/p) then\n            -- n/p is smaller than\
    \ n/p so n/p has the same largest prime factor as m.\n            if p > m then\n\
    \                return nil\n            else\n                return p\n    \
    \        end\n        else\n            -- n/p is larger than n/m so n/p has the\
    \ same largest prime factor as m.\n            if p > m then\n               \
    \ return nil\n            else\n                return p\n            end\n  \
    \      end\n        -- p is now the smallest prime factor.\n        local q, r\
    \ = math.divmod(n, p)\n        p = p * q\n    end\n    -- n must be a prime.\n\
    \    if n <= (m/p) then\n        return nil\n    else\n        return p\n    end\n\
    end", "  -- Create a table of all primes and test if n is prime\n  local primes\
    \ = {1};\n  local m = primes[1];\n  for i = 2, n do\n    for j = 1, i do\n   \
    \   local candidate = m * i;\n      if n % candidate == 0 then\n        m = candidate;\n\
    \      end\n    end\n    if m > primes[1] then\n      primes[1] = m\n    end\n\
    \  end\n  -- If n is a prime then return it\n  if primes[1] == n then\n    return\
    \ primes[1]\n  end\n  -- If n is not a prime then iterate over all primes found\
    \ and return the greatest one\n  local g = primes[1]\n  for i = 2, #primes do\n\
    \    if primes[i] < n then\n      g = primes[i]\n    end\n  end\n  return g\n\
    end", "  -- For factors less than two, just return the number\n  if n < 2 then\
    \ return n end", "  -- A more rigorous test would test primality by performing\
    \ the Berlekamp\u2013Massey\n  -- algorithm to find a prime factor, but this suffices\
    \ for our purposes.\n  local limit = 1\n  while limit < n do\n    limit = limit\
    \ * 2\n  end\n  -- Now that limit is even, we can begin testing factors <= limit.\n\
    \  limit = limit - 1\n  local i = 1\n  while limit % i == 0 do\n    limit = limit\
    \ / i\n    i = i * 2\n  end\n  return limit\nend", "  -- Test for divisibility\
    \ by all prime factors.\n  for i = 2, n do\n    if n % i == 0 then return i end\n\
    \  end\n  -- If n is prime, return the smallest possible prime factor larger than\
    \ sqrt(n).\n  return n / smallest_prime_factor(n)\nend", "    local largest_factor\
    \ = 1\n    for i = 2, n do\n        local factor = 1\n        for j = i, n do\n\
    \            factor = factor * j\n        end\n        if factor > largest_factor\
    \ then\n            largest_factor = factor\n        end\n    end\n    return\
    \ largest_factor\nend", "  if n < 2 then\n    return nil\n  end\n  local function\
    \ is_prime(n)\n    return n % 2 == 0 or n <= 1\n  end\n  local limit = math.sqrt(n)\n\
    \  local i = 1\n  repeat\n    i = i + 2\n    while i < limit and n % i == 0 do\n\
    \      i = i + 2\n    end\n    if i < limit and is_prime(i) then\n      return\
    \ i\n    end\n  until n > limit\n  return nil\nend", "  if n < 2 then\n    return\
    \ nil\n  end", "  -- Base cases\n  -- 0 => 1\n  if n == 0 then return 1 end\n\
    \  -- 1 => n\n  if n == 1 then return n end\n  -- 2 => 3\n  if n == 2 then return\
    \ 3 end\n  -- 3 => 6\n  if n == 3 then return 6 end\n  -- 4 => 9\n  if n == 4\
    \ then return 9 end\n  -- 5 => 12\n  if n == 5 then return 12 end\n  -- 6 => 18\n\
    \  if n == 6 then return 18 end\n  -- 7 => 27\n  if n == 7 then return 27 end\n\
    \  -- 8 => 36\n  if n == 8 then return 36 end\n  -- 9 => 45\n  if n == 9 or n%2\
    \ == 0 then return 45  end", "    -- Prime factors of 2 are 2 and 3, all other\
    \ primes are < sqrt(n)\n    if n == 2 then return 2 end\n    if n % 2 == 0 then\n\
    \        if n % 4 == 1 then return 4 end\n        if n % 8 == 1 then return 8\
    \ end\n        if n % 16 == 1 then return 16 end\n        if n % 32 == 1 then\
    \ return 32 end\n        if n % 64 == 1 then return 64 end\n        if n % 256\
    \ == 1 then return 256 end\n    end\n    local sq = math.floor(math.sqrt(n))\n\
    \    local num = 1\n    for i = 2, sq do\n        if n % i == 0 then\n       \
    \     num = num * i + (n / i)\n            n = n / i\n            break\n    \
    \    end\n    end\n    return num\nend", '  if n < 2 then return nil end', " \
    \ local max_factor = 1\n  while n > 1 do\n    if n % 2 == 1 then\n      max_factor\
    \ = max_factor * 2\n      n = n / 2\n    elseif n % 3 == 0 then\n      max_factor\
    \ = max_factor * 3\n      n = n / 3\n    elseif n % 5 == 0 then\n      max_factor\
    \ = max_factor * 5\n      n = n / 5\n    end\n  end\n  return max_factor\nend",
  "  -- Make sure n is positive.\n  n = math.abs(n)\n  -- Set a limit on how much\
    \ we care about factoring n.\n  local limit = 30\n  -- Set a prime that we want\
    \ to break out of our factoring loop.\n  local prime = 2\n  -- Set a prime that\
    \ we will break out of.\n  local prime_candidate = 2\n  -- Begin looping until\
    \ we break out of our limit or we run out of factors.\n  while limit > 0 do\n\
    \    -- Test to see if n is divisible by the prime we found previously.\n    if\
    \ n % prime == 0 then\n      -- If it is, we're done!\n      return prime\n  \
    \  end\n    -- Otherwise, we're not done yet. Factor n by our current prime and\
    \ update.\n    n = n / prime\n    limit = limit - 1\n    -- We check to see if\
    \ our current prime is composite.\n    if prime % prime_candidate == 0 then\n\
    \      -- If it is, we know that n is not prime and we can break out of the loop.\n\
    \      prime = prime_candidate\n      prime_candidate = prime\n    else\n    \
    \  -- If it isn't, we can try a different prime and update our current prime.\n\
    \      prime = prime + 1\n      prime_candidate = prime\n    end\n  end\n  --\
    \ If n is a prime factor, return it.\n  return prime\nend", "  if n == 1 then\
    \ return end\n  local f, rem = n % 2, 2\n  while rem do\n    local tmp = n % rem\n\
    \    if tmp then rem = rem - tmp else return f end\n    f = f + 1 if f < rem end\n\
    \  end\n  return f\nend", "   -- Based on the Sieve of Eratosthenes algorithm\
    \ from Wikipedia.\n   -- http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \   -- http://www.cs.berkeley.edu/~wkahan/JSSc/Sieve-Eratosthenes.java\n   --\
    \ Also available at:\n   -- https://code.google.com/p/primesieve/\n   -- http://primes.utm.edu/lists/small/1000prime.html\n\
    \   local max_factor = 0\n   local prime_factors = [1]\n   local prime = 1\n \
    \  local i = 1\n   while i <= n do\n      -- Keep the primes we haven't found\
    \ yet.\n      if prime_factors[i] < 1 then\n         -- Find next prime that hasn't\
    \ been found yet.\n         prime, i = next_prime(i)\n         if prime == i then\n\
    \            -- If we made it to here then no more prime factors can be found,\n\
    \            -- and we know the largest prime factor is one less than the number\n\
    \            -- of candidates we have found.\n            if max_factor == 0 then\n\
    \               max_factor = i\n            else\n               -- We've found\
    \ another prime which is larger.\n               if max_factor < i - 1 then\n\
    \                  max_factor = i - 1\n               end\n            end\n \
    \        else\n            -- If we made it to here then we know the number is\
    \ a prime.\n            -- Add 2 to the list of candidates.\n            prime_factors[i]\
    \ = 2\n         end\n      end\n      -- If we've already found a prime factor\
    \ then there is no point in\n      -- checking any more ones for primality because\
    \ any larger prime\n      -- has already been found and thus found factors will\
    \ just be smaller.\n      if prime_factors[i] ~= 0 then\n         break\n    \
    \  end\n      -- Increment by 2 and check whether this is a prime.\n      prime_factors[i\
    \ + 1] = prime_factors[i] + 2\n      prime = i + 2\n      i = i + 2\n   end\n\
    \   return max_factor\nend", "  -- Return the largest prime factor of n. Assume\
    \ n > 1 and is not a prime.\n  -- >>> largest_prime_factor(13195)\n  -- 29\n \
    \ -- >>> largest_prime_factor(2048)\n  -- 2\n  if n <= 1 then\n    return nil\n\
    \  end\n  if n % 2 == 1 then\n    local factor = 1\n    while n > factor do\n\
    \      factor = factor + 1\n      n = n / factor\n    end\n    return factor\n\
    \  end", "  -- Sieve of Eratosthenes -- see http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \  -- In our case, we'll generate all prime factors from 2 to sqrt(n).\n  -- This\
    \ should give us all prime factors of n, not just n! (which is the\n  -- same\
    \ as n squared).\n  local primes = {}\n  local prime_candidate = 2\n  while prime_candidate\
    \ < n do\n    prime_candidate = prime_candidate + primes[prime_candidate]\n  end\n\
    \  prime_candidate = n - 1\n  while prime_candidate > 0 do\n    primes[prime_candidate]\
    \ = nil\n    prime_candidate = prime_candidate - 1\n  end\n  -- Now that we've\
    \ generated the prime factors, find the largest one.\n  -- This will be the largest\
    \ prime factor for our input.\n  -- The largest prime factor is at most sqrt(n),\
    \ so the largest\n  -- prime factor will be the square root of n. Since n is always\
    \ a prime\n  -- number <= sqrt(n), we can simply return the square root.\n  return\
    \ math.sqrt(n)\nend", "  if n <= 1 then\n    return 1\n  end\n  local i = 1\n\
    \  local m\n  while i <= n do\n    m = n / i\n    if m ~= i * m then\n      i\
    \ = i + 1\n    end\n  end\n  return i\nend\nreturn largest_prime_factor", "  if\
    \ n < 2 then return 1 end\n  local max_i = 2\n  local i = 1\n  while i <= math.sqrt(n)\
    \ do\n    if n % i == 0 then\n      if i > max_i then\n        max_i = i\n   \
    \   end\n    end\n    i = i + 1\n  end\n  if max_i == n then return max_i end\n\
    \  local m = n % max_i\n  if max_i == n then return m end\n  while m % 2 == 0\
    \ do\n    m = m / 2\n  end\n  while m % 3 == 0 do\n    m = m / 3\n  end\n  return\
    \ m\nend", '    local prime_factor = nil', "    local max_prime = 1\n    while\
    \ n ~= 1 do\n        if n % max_prime == 0 then\n            max_prime = max_prime\
    \ + 2\n        end\n        n = math.floor(n/max_prime)\n    end\n    return max_prime\n\
    end", "  assert(n > 1)\n  for i = 2, sqrt(n) + 1 do\n    if n % i == 0 then\n\
    \      return i\n    end\n  end\n  return n\nend", "  if n < 1 then return nil\
    \ end\n  if n < 2 then return 1 end\n  for i = 2, n do\n    if n % i == 0 then\n\
    \      return i\n    end\n  end\n  return nil\nend", "    assert(n >= 1)\n   \
    \ assert(n <= 20)\n    local m = 1\n    while n > 1 do\n        local m = math.min(m\
    \ * 2, n)\n        n = math.floor((n - 1) / 2)\n    end\n    return m\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
