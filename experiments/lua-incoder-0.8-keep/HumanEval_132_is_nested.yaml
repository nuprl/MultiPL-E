name: HumanEval_132_is_nested
language: lua
prompt: "-- Create a function that takes a string as input which contains only square\
  \ brackets.\n-- The function should return True if and only if there is a valid\
  \ subsequence of brackets \n-- where at least one bracket in the subsequence is\
  \ nested.\n-- is_nested('[[]]') \u279E True\n-- is_nested('[]]]]]]][[[[[]') \u279E\
  \ False\n-- is_nested('[][]') \u279E False\n-- is_nested('[]') \u279E False\n--\
  \ is_nested('[[][]]') \u279E True\n-- is_nested('[[]][[') \u279E True\nlocal function\
  \ is_nested(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_nested\n\
  \    lu.assertEquals(candidate('[[]]'), true)\n    lu.assertEquals(candidate('[]]]]]]][[[[[]'),\
  \ false)\n    lu.assertEquals(candidate('[][]'), false)\n    lu.assertEquals(candidate('[]'),\
  \ false)\n    lu.assertEquals(candidate('[[[[]]]]'), true)\n    lu.assertEquals(candidate('[]]]]]]]]]]'),\
  \ false)\n    lu.assertEquals(candidate('[][][[]]'), true)\n    lu.assertEquals(candidate('[[]'),\
  \ false)\n    lu.assertEquals(candidate('[]]'), false)\n    lu.assertEquals(candidate('[[]][['),\
  \ true)\n    lu.assertEquals(candidate('[[][]]'), true)\n    lu.assertEquals(candidate(''),\
  \ false)\n    lu.assertEquals(candidate('[[[[[[[['), false)\n    lu.assertEquals(candidate(']]]]]]]]'),\
  \ false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   -- We need to keep track of the first and last bracket we encounter\
    \ \n   local i1, i2, i3 = 1, #string, -1\n   -- And keep track of if we are in\
    \ a square bracket expression\n   local in_square_bracket = false\n   -- We use\
    \ a stack so that we preserve the order in which brackets are encountered\n  \
    \ local stack = {}\n   -- If the string is empty, we return True\n   if string\
    \ == nil then return true end\n   -- If the string is only one character, we return\
    \ True\n   if #string == 1 then return string == string[1] end\n   -- We iterate\
    \ through the characters and keep track of each bracket\n   for i = 1, #string\
    \ do\n      local c = string[i]\n      -- If we are currently in a bracket expression,\
    \ push the bracket to the stack\n      if c == '[' then\n         if in_square_bracket\
    \ == false then\n            -- We set the first and last index that we encounter\
    \ as the last index of our stack\n            -- We do this because we don't want\
    \ to consider any brackets after the first bracket\n            -- This is because\
    \ we do not want the square brackets to ever be part of a valid expression\n \
    \           stack[1] = {\n               i1,\n               i2,\n           \
    \    i3\n            }\n            -- And we are going to push all the brackets\
    \ to the stack\n            in_square_bracket = true\n         else\n        \
    \    stack[#stack + 1] = {\n               i1,\n               i2,\n         \
    \      i3\n            }\n         end\n      -- If we are not in a bracket expression,\
    \ we just keep track of the last index\n      elseif c == ']' then\n         --\
    \ If this is the last bracket, we can safely pop the stack\n         if in_square_bracket\
    \ == true then\n            -- Set the last index as the first index\n       \
    \     stack[#stack + 1] = {\n               i1,\n               i2,\n        \
    \       i3\n            }\n            -- Remove the last bracket from the stack\n\
    \            in_square_bracket = false\n         end\n      -- If we are currently\
    \ in a bracket expression, we just push it to the stack\n      elseif in_square_bracket\
    \ == true then\n         stack[#stack + 1] = {\n            i1,\n            i2,\n\
    \            i3\n         }\n      end\n      -- We also keep track of the current\
    \ index\n      i1, i2, i3 = i + 1, i2, i3 + 1\n   end\n   -- If we encounter a\
    \ closing bracket, we know that at least one bracket was encountered \n   -- So\
    \ we return True\n   return stack[1][3]\nend", "    local stack = {string}\n \
    \   local function is_closed_bracket(character)\n        if stack[#stack] == nil\
    \ then\n            return false\n        end\n        return stack[#stack] ==\
    \ character\n    end\n    \n    while #stack > 1 do\n        local current_bracket\
    \ = stack[1]\n        local stack_size = #stack\n        if current_bracket ~=\
    \ '[' and current_bracket ~= '{' then\n            return false\n        end\n\
    \        if #stack == stack_size then\n            return true\n        end\n\
    \        local current_closed_bracket = is_closed_bracket(current_bracket)\n \
    \       \n        if not current_closed_bracket then\n            return false\n\
    \        end\n        local new_stack = stack[#stack:1]\n        stack[stack_size]\
    \ = new_stack\n        stack = stack:new_table()\n    end\n    return false\n\
    end", "  local index = 1\n  -- Iterate through the string and check each character\
    \ until we find the closing bracket\n  while index <= #string do\n    index =\
    \ string.find(string, ']', index) or #string\n    \n    -- If the character is\
    \ a opening bracket, increment index\n    if string.sub(string,index,index+1)=='['\
    \ then\n      index = index + 1\n      \n    -- If the character is a closing\
    \ bracket, decrement index\n    elseif string.sub(string,index,index+1)==']' then\n\
    \      index = index + 1\n      \n    -- If neither opening or closing bracket\
    \ was found, return false\n    else\n      return false\n    end\n  end\n  \n\
    \  return true\nend", "  local open_brackets, closed_brackets = 0, 1\n  \n  for\
    \ i, c in string.gmatch( string, '%b[]') do\n    if c == open_brackets then open_brackets\
    \ = open_brackets + 1 \n    if c == closed_brackets then closed_brackets = closed_brackets\
    \ + 1 \n  end", "    local open_brackets = { [[[\n        ]]]]] }\n    local close_brackets\
    \ = open_brackets\n    local bracket_count = #string\n    while bracket_count\
    \ > 0 do\n        local close_bracket = close_brackets[math.random(1, #close_brackets)]\n\
    \        if open_brackets[close_bracket] then\n            close_brackets[close_bracket]\
    \ = nil\n            bracket_count = bracket_count - 1\n        else\n       \
    \     close_brackets[close_bracket] = true\n        end\n    end\n    return (bracket_count\
    \ > 0 and #open_brackets == 0)\nend", "  -- Write your code here\n  return string.find(string,'[[[{')\
    \  ~= nil\nend", "  -- A function that checks whether or not a string contains\
    \ only square brackets \n  -- returns True if the string contains only brackets,\
    \ and False otherwise.\n  return string.find(string, '[%[[]') ~= nil \nend", " \
    \ local opening = {'[', '{', '('}\n  local closing = {']', '}', ')'}\n  local\
    \ opened_brackets = 1\n  local closed_brackets = 0", "\tlocal bracket_count =\
    \ 0\n\tlocal open_bracket_count = 0\n\t\n\t-- Loop over each character in the\
    \ string and increase the counter if the character is a bracket\n\tfor i,c in\
    \ pairs(string) do\n\t\tif c == '[' then\n\t\t\topen_bracket_count = open_bracket_count\
    \ + 1\n\t\telseif c == ']' then\n\t\t\tbracket_count = bracket_count - 1\n\t\t\
    end\n\tend\n\t\n\tif bracket_count == 0 and open_bracket_count == 0 then\n\t\t\
    return false\n\telseif bracket_count ~= open_bracket_count then\n\t\treturn true\n\
    \telse\n\t\treturn false\n\tend\nend", "\tif string == nil then\n\t\treturn false\n\
    \tend", "    -- Check for empty string\n    if string == '' then return end",
  "  local brackets = string\n  local open = 0\n  local close = 0\n  local open_brackets\
    \ = 0\n  local is_open = false\n  local is_close = false\n  local open_brackets_temp\
    \ = 0\n  local is_open_brackets_temp = false\n  local close_brackets_temp = 0\n\
    \  local is_close_brackets_temp = false\n  local brackets_count = 0\n  while open\
    \ ~= close do\n    open_brackets_temp = (open_brackets + 1) \n    is_open_brackets_temp\
    \ = open_brackets_temp == 1 or (open_brackets_temp == 2 and is_open)\n    close_brackets_temp\
    \ = (close_brackets + 1) \n    is_close_brackets_temp = close_brackets_temp ==\
    \ 1 or (close_brackets_temp == 2 and is_close)\n    brackets = brackets .. open\n\
    \    open = string.find(brackets, ']')\n    close = string.find(brackets, '[')\
    \ \n    if open == nil then\n      if is_close then\n        return true\n   \
    \   else\n        return false\n      end\n    elseif open > close then\n    \
    \  if open_brackets == 1 then\n        return true\n      else\n        return\
    \ false\n      end\n    else\n      if open_brackets_temp == 1 then\n        if\
    \ is_open_brackets_temp then\n          return true\n        else\n          return\
    \ false\n        end\n      else\n        if is_close_brackets_temp then\n   \
    \       return true\n        else\n          return false\n        end\n     \
    \ end\n    end\n  end\n  return true\nend", "\tlocal pos = 1\n\tlocal brackets\
    \ = 0\n\twhile pos < #string do\n\t\tlocal c = string[pos]\n\t\tif c == '[' then\n\
    \t\t\tbrackets = brackets + 1\n\t\telseif c == ']' then\n\t\t\tbrackets = brackets\
    \ - 1\n\t\telseif brackets == 0 and c ~= '[' then\n\t\t\treturn false\n\t\tend\n\
    \t\tpos = pos + 1\n\tend\n\treturn brackets == 0\nend", "  assert(type(string)\
    \ == 'string', 'string required')\n  local bracket_count = 0\n  for i=1,#string\
    \ do\n    if string[i] == '[' then\n      bracket_count = bracket_count + 1\n\
    \    elseif string[i] == ']' then\n      bracket_count = bracket_count - 1\n \
    \   end\n    if bracket_count < 0 then\n      return false\n    end\n  end\n \
    \ return true\nend", "\t-- Iterate over the string, counting the number of left\
    \ brackets\n\t-- encountered. When that number becomes 0, we have found a nested\
    \ brackets\n\t-- sequence.\n\tfor i = 0, string.lenght - 1 do\n\t\tif string[i]\
    \ ~= '[' then\n\t\t\tbreak\n\t\tend\n\t\t-- The counter does not increase if we\
    \ have already seen a left bracket,\n\t\t-- because that means that we have encountered\
    \ a sequence of right\n\t\t-- brackets, which is impossible.\n\t\tif string.sub(i,\
    \ 1).lenght == 0 then\n\t\t\treturn true\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn\
    \ false\nend", "\t-- Split string by brackets\n\tlocal nested = string.gsub(string,\
    \ '[[]', '{}')\n\t-- Replace all nested brackets\n\tfor i = 1, #nested do \n\t\
    \tnested = string.gsub(nested, '{%d}', '{}')\n\tend\n\t-- Split string by braces\n\
    \tlocal not_nested = string.gsub(string, '{}', '[]')\n\t-- Remove all non-nested\
    \ brackets\n\tnested = string.gsub(nested, '[]', '[')\n\tnot_nested = string.gsub(not_nested,\
    \ '[]', '[')\n\t\n\t-- If nested is empty, there are no brackets in string\n\t\
    return not nested or #nested == 0\nend", "\t-- If the string contains only square\
    \ brackets\n\tif string.find(string, '[]') ~= nil then\n\t\treturn true\n\tend",
  "  -- Your code here!\n  -- \u2B07\uFE0F\nend", "  local bracket_stack = { 0 }\n\
    \  return string:gsub(\"%a\", function(c)\n    if not bracket_stack[#bracket_stack]\
    \ then\n      local opening = string.sub(c, 1, 1)\n      local closing = string.sub(c,\
    \ 1, 2)\n      if opening ~= '[' or closing ~= ']' then return false end\n   \
    \   bracket_stack[#bracket_stack] = opening and closing and closing:len()\n  \
    \  else\n      local opening = string.sub(c, 1, bracket_stack[#bracket_stack])\n\
    \      local closing = string.sub(c, 2, bracket_stack[#bracket_stack] - 1)\n \
    \     if opening ~= '[' or closing ~= ']' then return false end\n      local count\
    \ = bracket_stack[#bracket_stack] ~= closing:len() and 1 or 0\n      if count\
    \ > 0 then bracket_stack[#bracket_stack] = closing end\n    end\n    bracket_stack[#bracket_stack]\
    \ = nil\n    return true\n  end)\nend", "    if string == '' then return false\
    \ end\n    if string[1] == '[' then return is_nested(string) end\n    if string[#string]\
    \ == '[' then return is_nested(string) end\n    return true\nend\n</cell>\n<cell>",
  "    local opening_bracket = 0\n    local closing_bracket = 0\n    local level =\
    \ 0\n    local open_bracket\n    local close_bracket\n    for _, character in\
    \ ipairs(string) do\n        if character == '[' then\n            open_bracket\
    \ = opening_bracket\n            opening_bracket = open_bracket + 1\n        elseif\
    \ character == ']' then\n            close_bracket = closing_bracket\n       \
    \     closing_bracket = close_bracket + 1\n        elseif character == '[' then\n\
    \            level = level + 1\n        elseif character == ']' then\n       \
    \     if level == 0 then\n                return false\n            end\n    \
    \        level = level - 1\n        end\n    end\n    if opening_bracket ~= closing_bracket\
    \ then return false end\n    if open_bracket ~= close_bracket then return false\
    \ end\n    return true\nend", "\tstring = string or '[]'\n\tlocal open_brackets\
    \ = string.gsub(string, \"%[(%+)\", \"\")\n\tlocal close_brackets = string.gsub(string,\
    \ \"%]%+\", \"\")", "    -- If string contains only one square bracket, return\
    \ False\n    if string.find ('[[]]') ~= nil then\n        return false\n    end\n\
    \    local open_bracket = string.find ('[[]')\n    local close_bracket = string.find\
    \ ('[[]]')\n    local i = 1\n    while open_bracket ~= nil do\n        -- If i\
    \ is greater than the length of string, return false\n        if i > #string then\n\
    \            return false\n        end\n        -- If open_bracket is less than\
    \ close_bracket, return false\n        if open_bracket < close_bracket then\n\
    \            return false\n        end\n        if string[open_bracket] == '['\
    \ and string[close_bracket] == ']' then\n            open_bracket = string.find\
    \ ('[[]', open_bracket + 1)\n            close_bracket = string.find ('[[]]',\
    \ open_bracket + 1)\n        elseif string[open_bracket] == '[' then\n       \
    \     open_bracket = string.find ('[[]', open_bracket + 1)\n        elseif string[close_bracket]\
    \ == '[' then\n            close_bracket = string.find ('[[]]', close_bracket\
    \ + 1)\n        elseif string[close_bracket] == '}' then\n            close_bracket\
    \ = string.find ('[[]]', close_bracket + 1)\n        else\n            return\
    \ false\n        end\n        i = i + 1\n    end\n    -- If open_bracket is greater\
    \ than the length of string, return false\n    if open_bracket > #string then\n\
    \        return false\n    end\n    -- If close_bracket is greater than the length\
    \ of string, return false\n    if close_bracket > #string then\n        return\
    \ false\n    end\n    -- Otherwise, return true\n    return true\nend", "\t--\
    \ Get the brackets, ignoring the inner ones.\n\tlocal open_brackets = string.gsub(string,\
    \ \"[\", \"\")\n\tlocal closed_brackets = string.gsub(string, \"]\", \"\")\n\t\
    -- The result can be False if the string has no valid brackets \n\t-- or it can\
    \ be True if the string has only brackets \n\t-- and no valid subsequence.\n\t\
    return open_brackets == closed_brackets\nend", "    local i = 1\n    while i <=\
    \ string.count ('[[]', string) and i <= string.count ('[]]', string) do\n    \
    \    if string.sub (string, 1, i) == '[' then\n            i = i + 1 \n      \
    \  elseif string.sub (string, 1, i) == ']' then\n            i = i + 1\n     \
    \   elseif i == string.count ('[[]', string) + 1 then\n            return false\n\
    \        else\n            i = i + 1\n        end\n    end\n    return string.sub\
    \ (string, 1, i) == ''\nend", "   for i = 1, #string do\n      local c = string.sub(i,\
    \ i)\n      if c ~= ']' and c ~= '[' then\n         return false\n      end\n\
    \   end\n   return true\nend", "  -- Check for empty string\n  if string.lenth\
    \ <= 0 then return end\n  -- Check for brackets at beginning of string\n  if string.sub(1,\
    \ 1):find('[]') ~= nil then return false end\n  -- Check all nesting levels \n\
    \  local is_nested = true\n  local current_level = string.len(string.sub(1, 1))\
    \ + 1\n  local last_open_bracket = string.sub(1, 1)\n  for i = 1, string.len(string)\
    \ do\n    if string.sub(i, 1) ~= '[]' then \n      -- Check for brackets starting\
    \ in current_level\n      if string.sub(i, 1):find('[' .. last_open_bracket) ~=\
    \ nil then\n        last_open_bracket = string.sub(i, 1)\n        current_level\
    \ = string.len(string.sub(i, 1)) + 1\n      else\n        is_nested = false\n\
    \      end\n    else\n      -- Check for the closing bracket\n      if string.sub(i,\
    \ 1) ~= '[' then is_nested = false end\n    end\n  end\n  return is_nested\nend",
  "    local opening_char = '['\n    local closing_char = ']'\n    local opening_bracket\
    \ = 1\n    local closing_bracket = 1", "\tlocal count = 0\n\tfor i,c in string.gmatch(\
    \ string, \"%a\" ) do\n\t\tcount = count + 1\n\t\tif c == '[' then\n\t\t\tcount\
    \ = count - 1\n\t\telseif c == ']' then\n\t\t\tcount = count + 1\n\t\tend\n\t\
    end\n\treturn count == 0\nend", "\tlocal is_nested = false\n\t\n\tlocal bracket_count\
    \ = 0\n\tlocal last_bracket_found = -1\n\tlocal bracket_start = -1\n\tlocal bracket_end\
    \ = -1\n\t\n\tlocal i, j = string.find(string, '[')\n\twhile i > 0 do\n\t\tif\
    \ string.find(string, '[[', j) then\n\t\t\tbracket_start = string.find(string,\
    \ '[[', j) + 2\n\t\t\tbracket_end = string.find(string, ']]', j)\n\t\t\t\n\t\t\
    \t-- Check every consecutive pair of brackets.\n\t\t\twhile bracket_start < bracket_end\
    \ do\n\t\t\t\tif string.find(string, '[[', bracket_start) then\n\t\t\t\t\t-- Check\
    \ for a nested bracket.\n\t\t\t\t\tlocal nesting_bracket_start = string.find(string,\
    \ '[[', bracket_start) + 2\n\t\t\t\t\tlocal nesting_bracket_end = string.find(string,\
    \ ']]', nesting_bracket_start) -- If there is an even number of nested brackets,\n\
    \t\t\t\t\t-- then the closing bracket must be in the same column.\n\t\t\t\t\t\n\
    \t\t\t\t\t-- If the closing bracket is on the same line, then there are no nested\
    \ brackets.\n\t\t\t\t\tif nesting_bracket_end > nesting_bracket_start then\n\t\
    \t\t\t\t\tif string.find(string, ']]', nesting_bracket_end) then\n\t\t\t\t\t\t\
    \tif nesting_bracket_end - nesting_bracket_start == 2 then\n\t\t\t\t\t\t\t\tis_nested\
    \ = true\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\
    \t\t-- Else, the closing bracket is on a different line, so there is a nested\
    \ bracket.\n\t\t\t\t\telse\n\t\t\t\t\t\tbracket_count = bracket_count + 1\n\t\t\
    \t\t\t\t\n\t\t\t\t\t\tif bracket_count == 2 then\n\t\t\t\t\t\t\tis_nested = true\n\
    \t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\t-- Increment the bracket\
    \ count and end the inner loop by breaking the outer loop.\n\t\t\t\t\tbracket_count\
    \ = bracket_count + 1\n\t\t\t\t\tj = nesting_bracket_end\n\t\t\t\telse\n\t\t\t\
    \t\t-- Check for the next bracket.\n\t\t\t\t\tlocal next_bracket_start = string.find(string,\
    \ '[[', bracket_start)\n\t\t\t\t\tif next_bracket_start ~= -1 then\n\t\t\t\t\t\
    \tif string.find(string, ']]', next_bracket_start) then\n\t\t\t\t\t\t\tbracket_count\
    \ = bracket_count + 1\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif bracket_count == 2 then\n\
    \t\t\t\t\t\t\t\tis_nested = true\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\
    \t\tj = next_bracket_start\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\tbracket_start\
    \ = next_bracket_start\n\t\t\t\t\telse\n\t\t\t\t\t\t-- If there are no brackets\
    \ left in the substring, then there is no ", "\t-- Check if there is at least\
    \ one pair of brackets\n\tif string:find(brackets.lbracket, 1) or string:find(brackets.rbracket,\
    \ 1) then\n\t\t-- Check if the number of open brackets is equal to the number\
    \ of close brackets\n\t\treturn brackets.openbrackets == brackets.closebrackets\n\
    \telse\n\t\treturn false\n\tend\nend", "    local stack = {[]}\n    local result\
    \ = 0\n    for i,v in string.gmatch(string,'%[[]') do\n        if stack[1] ==\
    \ '[]' then\n            stack[1] = v\n        else\n            if stack[#stack]\
    \ == '[]' then\n                stack[#stack] = v\n                stack[#stack+1]\
    \ = '[]'\n            else\n                stack[#stack] = v\n            end\n\
    \        end\n        if stack[#stack] == '[]' then\n            result = result\
    \ + 1\n        end\n    end\n    return result == 0\nend", "    local index =\
    \ 0\n    while index <= #string do\n        if string[index] == '[' then\n   \
    \         if string[index + 1] == '[' then\n                index = index + 2\n\
    \            elseif string[index + 1] == ']' then\n                index = index\
    \ + 2\n            else\n                return false\n            end\n     \
    \   else\n            return false\n        end\n    end\n    return true\nend",
  "  local brackets = {}\n  for i = 1, #string do\n    local b = string[i]\n    if\
    \ b == '[' then\n      if brackets[#brackets+1] == nil then\n        brackets[#brackets+1]\
    \ = {i}\n      else\n        table.insert(brackets[#brackets+1], {i})\n      end\n\
    \    elseif b == ']' then\n      if brackets[#brackets] ~= nil then\n        for\
    \ j = #brackets[#brackets] - 1, 1, -1 do\n          local i = brackets[#brackets][j]\n\
    \          brackets[#brackets] = {i}\n        end\n      end\n    end\n  end\n\
    \  return #brackets > 0\nend", "    local brackets_stack = stack()\n    for _,\
    \ char in string.gmatch( string, '%[%[()' ) do\n        if char == '[' then\n\
    \            brackets_stack:push( char )\n        elseif char == ']' then\n  \
    \          if brackets_stack:len() == 1 then\n                return false\n \
    \           end\n            brackets_stack:pop()\n        end\n    end\n    return\
    \ brackets_stack:len() == 0\nend", "    local brackets = string.gsub(string, \"\
    [[][\", \"\")\n    local nesting = string.gsub(brackets, \"[][]\", \"\")\n   \
    \ return nesting ~= brackets\nend", "\t-- Base case\n\t-- Return true if string\
    \ is empty\n\tif string == \"\" then return true end", "   -- Define recursive\
    \ function.\n   local function is_nested_helper(string, index, nested, depth)\n\
    \      -- Base case: when the index is past the end of the string, return True\n\
    \      if index == #string then\n         return nested\n      end", "\t-- Initialize\
    \ the result to the string passed in.\n\tlocal result = string", "   -- Initialize\
    \ with false because string could be empty.\n   local is_nested = false\n   for\
    \ i = 1, #string do\n      -- If current char is not a bracket, set is_nested\
    \ false.\n      if string[i] ~= '[' or string[i] ~= ']' then\n         is_nested\
    \ = false\n         break\n      end\n      -- Else, if current char is a bracket,\
    \ check if bracket is nested.\n      if string[i] == '[' then\n         if #string\
    \ < i + 1 then is_nested = false break\n         if string[i + 1] == '[' then\
    \ is_nested = true break end\n      elseif string[i] == ']' then\n         if\
    \ #string < i + 1 then is_nested = false break\n         if string[i + 1] == ']'\
    \ then is_nested = true break end\n      end\n   end\n   return is_nested\nend",
  "  return string ~= '' and string.find(string, \"[\") > -1\nend\n</cell>\n<cell>",
  "\tlocal brackets = {}\n\tlocal last = -1\n\tlocal open_brackets = 2", "   local\
    \ brackets = {}\n   for i = 1, string.lent -1 do\n      local character = string.sub(i,\
    \ i + 1)\n      if character ~= '[' then return false end\n      table.insert(brackets,\
    \ character)\n   end\n   if string.sub((string.lent - 1), string.lent) ~= '['\
    \ then return false end\n   if #brackets ~= 1 then return false end\n   return\
    \ true\nend", "    local stack = {}\n    local open_brackets\n    local close_brackets\n\
    \    for index, value in ipairs(string) do\n        if value == ']' and open_brackets\
    \ == '[' then\n            close_brackets = value\n        elseif value == '['\
    \ then\n            if open_brackets ~= '[' then\n                table.insert(stack,\
    \ value)\n            end\n            open_brackets = value\n        elseif value\
    \ == ']' and open_brackets ~= '[' then\n            if close_brackets ~= ']' then\n\
    \                return false\n            end\n            open_brackets = close_brackets\n\
    \            table.insert(stack, close_brackets)\n        elseif open_brackets\
    \ ~= '[' then\n            close_brackets = value\n        end\n    end\n    return\
    \ stack[1] == '[' and stack[#stack] == ']'\nend", "   if string:find('[', '[')>-1\
    \ then\n      return true\n   else\n      return false\n   end\nend", "\tlocal\
    \ bracket_count = 0\n\tlocal curly_count = 0\n\tlocal open_bracket = 0\n\tlocal\
    \ open_bracket1 = 0\n\tlocal open_bracket2 = 0\n\tlocal open_bracket3 = 0\n\t\
    local open_bracket4 = 0\n\tlocal open_bracket5 = 0\n\tlocal open_bracket6 = 0\n\
    \tlocal open_bracket7 = 0\n\tlocal open_bracket8 = 0\n\tlocal open_bracket9 =\
    \ 0\n\tlocal open_bracket10 = 0\n\tlocal open_bracket11 = 0\n\tlocal open_bracket12\
    \ = 0\n\tlocal open_bracket13 = 0\n\tlocal open_bracket14 = 0\n\tlocal open_bracket15\
    \ = 0\n\tlocal open_bracket16 = 0\n\tlocal open_bracket17 = 0\n\tlocal open_bracket18\
    \ = 0\n\tlocal open_bracket19 = 0\n\tlocal open_bracket20 = 0\n\tlocal open_bracket21\
    \ = 0\n\tlocal open_bracket22 = 0\n\tlocal open_bracket23 = 0\n\tlocal open_bracket24\
    \ = 0\n\tlocal open_bracket25 = 0\n\tlocal open_bracket26 = 0\n\tlocal open_bracket27\
    \ = 0\n\tlocal open_bracket28 = 0\n\tlocal open_bracket29 = 0\n\tlocal open_bracket30\
    \ = 0\n\tlocal open_bracket31 = 0\n\tlocal open_bracket32 = 0\n\tlocal open_bracket33\
    \ = 0\n\tlocal open_bracket34 = 0\n\tlocal open_bracket35 = 0\n\tlocal open_bracket36\
    \ = 0\n\tlocal open_bracket37 = 0\n\tlocal open_bracket38 = 0\n\tlocal open_bracket39\
    \ = 0\n\tlocal open_bracket40 = 0\n\tlocal open_bracket41 = 0\n\tlocal open_bracket42\
    \ = 0\n\tlocal open_bracket43 = 0\n\tlocal open_bracket44 = 0\n\tlocal open_bracket45\
    \ = 0\n\tlocal open_bracket46 = 0\n\tlocal open_bracket47 = 0\n\tlocal open_bracket48\
    \ = 0\n\tlocal open_bracket49 = 0\n\tlocal open_bracket50 = 0\n\tlocal open_bracket51\
    \ = 0\n\tlocal open_bracket52 = 0\n\tlocal open_bracket53 = 0\n\tlocal open_bracket54\
    \ = 0\n\tlocal open_bra", "   if string == '' or string.sub(1, 1) ~= '[' then\
    \ return false end\n   for i = 1, string.len() - 1 do\n      local char = string.sub(i,\
    \ i)\n      if not (string.sub(i + 1, i + 2) == '[]' and char == ']') then return\
    \ false end\n   end\n   return true\nend", "    local brackets = 0\n    for i\
    \ = 1, string.len do\n        if string[i] == '[' then\n            brackets =\
    \ brackets + 1\n            if string[i+1] == ']' then\n                brackets\
    \ = brackets - 1\n            end\n        elseif string[i] == ']' then\n    \
    \        brackets = brackets - 1\n            if brackets < 1 then\n         \
    \       return true\n            end\n        end\n    end\n    return false\n\
    end", "    local count = 0\n    local open = 0\n    local close = 0", "    --\
    \ Create a boolean array where each position in the array is False \n    -- except\
    \ for the last character in the string.\n    local brackets = {string[1] == '['\
    \ and string[#string] == ']'}\n    -- The string should start and end with a closing\
    \ bracket.\n    return brackets and (brackets and string[#string - 1] == '[')\n\
    end", "\t-- Base case\n\tif string == '' then\n\t\treturn false\n\tend", "  --\
    \ Base case\n  if string == '' or string ~= string.rep('[[]', string.len(string)\
    \ - 1) then\n    return false\n  end\n  \n  local start = string.find(string,\
    \ '[')\n  \n  if start == -1 then\n    return false\n  end\n  \n  -- Create a\
    \ table with all the indices of '['\n  local bracket_count = #(string.sub(string,\
    \ start, start))\n  \n  -- Look at each index in the string from the start\n \
    \ for index = 1, bracket_count do\n    -- If the index has another '[' before\
    \ it\n    if string.sub(string, 1, start) == '[' then\n      -- Return false if\
    \ there is not an empty substring between bracket indices.\n      if string.sub(string,\
    \ 1, index + 1) ~= string.sub(string, 1, index + 2) then\n        return false\n\
    \      end\n      \n      -- If the index has another ']' after it\n      if string.sub(string,\
    \ index + 2, string.len(string) - 1) ~= ']' then\n        return false\n     \
    \ end\n    end\n    \n    -- If the index is the last index, return false\n  \
    \  if index == bracket_count then\n      return false\n    end\n    \n    -- If\
    \ the index is not the last index\n    if index + 1 != bracket_count then\n  \
    \    -- If the character before the last index is '['\n      if string.sub(string,\
    \ 1, index - 1) ~= '[' then\n        return false\n      end\n      \n      --\
    \ If the character after the last index is '['\n      if string.sub(string, (index\
    \ - 1), string.len(string) - 1) ~= '[' then\n        return false\n      end\n\
    \    end\n    \n    -- Set the new start index\n    start = index + 1\n  end\n\
    \  \n  return true\nend", "\t-- If the string has no brackets, return False\n\t\
    if not string then return false end\n\t\n\t-- If the string contains only brackets,\
    \ return true\n\tif string.find(string, '[') == string.find(string, ']') then\
    \ return true end\n\t\n\t-- Iterate through the string and check if there are\
    \ any nested brackets\n\t-- by removing brackets and checking the new string.\n\
    \tfor i = 0, string.len(string) do\n\t\t-- Remove the opening bracket\n\t\tstring\
    \ = string.sub(string, 1, i)\n\t\t\n\t\t-- Check if the string has nested brackets\n\
    \t\tif string.find('[') ~= string.find(string, '[')\n\t\t\tthen return false end\n\
    \t\t\n\t\t-- Remove the closing bracket\n\t\tstring = string.sub(string, string.len(i)\
    \ + 1)\n\tend\n\t\n\t-- Return true to indicate that the string contained a nested\
    \ bracket\n\treturn true\nend", "\tlocal pattern = \"(^|[^^])[(]([^)]*)[)](.*$)\"\
    \ -- Match a \"[\" at the beginning or start of a line.\n\treturn string.find(string,\
    \ pattern, 1, true) ~= nil\nend", "   local open_brackets = 0\n   for i=1, #string\
    \ do\n      if string[i] == '[' then\n         open_brackets = open_brackets +\
    \ 1\n      elseif string[i] == ']' then\n         if open_brackets == 0 then\n\
    \            return false\n         else\n            open_brackets = open_brackets\
    \ - 1\n         end\n      end\n   end", "    local open = {\n        open = \"\
    [\",\n        close = \"]\"\n    }\n    local close = {\n        open = \"(\"\
    ,\n        close = \")\"\n    }\n    for index, character in string.gmatch( string,\
    \ \"([^\"..open[string.sub(string, 1, 1)]..close[string.sub(string, string.len(string)\
    \ - 1, string.len(string))])\" )\n    do\n        if string.find(character, \"\
    [\") == nil then\n            return false\n        end\n    end\n    return true\n\
    end", "  if string.match then\n    return string:match('[[][[]([^[]*[[]([^[]*)[[]([^[]*)[[][[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)[[]([^[]*)",
  "  for i, c in ipairs(string) do\n    if c == '[' then return False end\n    if\
    \ c == ']' then return False end\n  end\n  return True\nend", "   -- Only count\
    \ the opening brackets\n   if string.find(string, '[') ~= nil then \n      --\
    \ Remove everything before the opening bracket\n      string = string.sub(string,\
    \ 1, string.find(string, '['))\n      -- If the string is empty or only contains\
    \ brackets, return False\n      if string ~= '' then \n         return true\n\
    \      else\n         return false\n      end\n   else \n      return false\n\
    \   end\nend", "   return string=='[]' or string.sub(1,2)=='[[' or string.sub(1,2)=='[['\n\
    end", "  string = string.gsub(string, '[', '') -- Remove all brackets.\n  local\
    \ brackets = string.gsub(string, '[]', '') -- Remove all nested brackets.\n  if\
    \ string.find(brackets, string) == 0 then -- If there are no nested brackets.\n\
    \    return true\n  else -- Otherwise, there are brackets but no nested brackets.\n\
    \    return false\n  end\nend", "    local bracket_stack = {}\n    local open_brackets\
    \ = {\n        ['['] = 1, ['{'] = 1, ['('] = 1\n    }\n    local close_brackets\
    \ = {\n        ']' = 1, '}' = 1, ')' = 1\n    }\n    local close_bracket_count\
    \ = 0", "   return string.FindSubString('[[]') ~= nil\nend", "\tlocal index =\
    \ 1\n\twhile true do\n\t\tif string.find('[[]', index) == nil then\n\t\t\treturn\
    \ true\n\t\tend\n\t\tindex = string.find('[[]', index) + 2\n\t\tif index > #string\
    \ - 1 then\n\t\t\treturn false\n\t\tend\n\t\tindex = string.find('[[', index)\n\
    \t\tif index == nil then\n\t\t\treturn false\n\t\tend\n\t\tindex = string.find(']',\
    \ index)\n\t\tif index == nil then\n\t\t\treturn false\n\t\tend\n\t\tindex = string.find('[[]',\
    \ index)\n\t\tif index == nil then\n\t\t\treturn false\n\t\tend\n\tend\nend",
  "   if string.find(string, '[]') then\n      -- This string has at least one nested\
    \ bracket\n      return true\n   else\n      -- This string has no nested brackets\n\
    \      return false\n   end\nend", "   local brackets = string\n   brackets =\
    \ string.gsub(brackets, '[', '') -- remove all brackets\n   brackets = string.gsub(brackets,\
    \ ']', '') -- remove all closing brackets\n   if brackets:sub(1, 1) == '[' then\n\
    \      brackets = brackets:sub(2)\n   end\n   if brackets:sub(1, 1) == ']' then\n\
    \      brackets = brackets:sub(2)\n   end\n   brackets = brackets:gsub('[]','')\n\
    \   return brackets:len() > 0 and brackets:match('[]') ~= nil \nend", "  return\
    \ string.gsub('[[]]', '') == '' and string.gsub('[[][]]', '') ~= '' and string.gsub('[[]',\
    \ '') == '' and string.gsub('[[]', '') ~= ''\nend", "  local function validate(s)\n\
    \    local brackets = {}\n    local i = 1, #s\n    while i <= #s do\n      if\
    \ s[i] ~= \"]\" then\n        brackets[#brackets + 1] = {s, i}\n      end\n  \
    \    if s[i] == \"]\" then\n        return brackets\n      end\n      i = i +\
    \ 1\n    end\n    return nil\n  end\n  return validate(string)\nend", "    return\
    \ string.find('[[]') ~= nil\nend", "  for match in (string.gsub(string, \"%[%[(%[%[%[\"\
    ):g..\"%]%)]%]%)\") do\n    if match == \"[\" then\n      local closes = false\n\
    \      for match2 in (string.gsub(string, \"%]%[(%[%[%[\"):g..\"%]%)]%)\") do\n\
    \        if match2 == \"]\" then\n          closes = true\n          break\n \
    \       elseif match2 == \"[\" then\n          closes = false\n        end\n \
    \     end\n      if not closes then\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "\tlocal pos = 1\n\t-- Iterate through the string\
    \ and keep track of all brackets\n\twhile pos <= string.len and string[pos] ~=\
    \ '[' do\n\t\tpos = pos + 1\n\tend\n\t\n\t-- Iterate again through string and\
    \ keep track of all nested brackets\n\tlocal nested = 0\n\twhile pos <= string.len\
    \ do\n\t\tif string[pos] == '[' then\n\t\t\tnested = nested + 1\n\t\tend\n\t\t\
    if string[pos] == ']' and nested > 0 then\n\t\t\tnested = nested - 1\n\t\tend\n\
    \t\tpos = pos + 1\n\tend\n\t\n\treturn nested == 0\nend", "    local brackets\
    \ = 0\n    local open_brackets = 0\n    local closing_brackets = 0\n    local\
    \ open_brackets_positions = {}\n    local closing_brackets_positions = {}\n  \
    \  local closing_brackets_positions_count = 0\n    local function is_open_bracket(i)\n\
    \        local position = i - 1\n        if open_brackets_positions[position]\
    \ == nil then\n            open_brackets_positions[position] = i\n        end\n\
    \        if open_brackets_positions[position] == i then\n            open_brackets_positions[position]\
    \ = nil\n            open_brackets_positions[position] = i\n            open_brackets_positions[position]\
    \ = i\n            open_brackets = open_brackets + 1\n        else\n         \
    \   return false\n        end\n        return true\n    end\n    local function\
    \ is_closing_bracket(i)\n        local position = i - 1\n        if closing_brackets_positions[position]\
    \ == nil then\n            closing_brackets_positions[position] = i\n        \
    \    closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets\
    \ = closing_brackets + 1\n        end\n        if closing_brackets_positions[position]\
    \ == i then\n            closing_brackets_positions[position] = nil\n        \
    \    closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[position] = i\n            closing_brackets_positions[position]\
    \ = i\n            closing_brackets_positions[", "    local brackets = {\n   \
    \     bracket = 1,\n        brackets = 1,\n        brackets_closed = false,\n\
    \    }\n    local open = 0\n    local close = 0\n    for i=1,#string do\n    \
    \    if string.sub(string,i,i) ~= '[' then\n            if brackets.brackets_closed\
    \ then\n                if brackets.bracket == 0 then\n                    brackets.brackets_closed\
    \ = false\n                elseif brackets.bracket == open then\n            \
    \        brackets.bracket = open + 1\n                else\n                 \
    \   brackets.bracket = open - 1\n                end\n            end\n      \
    \  elseif string.sub(string,i,i) = '[' then\n            if brackets.brackets_closed\
    \ then\n                brackets.bracket = brackets.bracket\n            else\n\
    \                brackets.bracket = brackets.bracket+1\n            end\n    \
    \    elseif string.sub(string,i,i) = ']' then\n            if brackets.brackets_closed\
    \ then\n                brackets.bracket = brackets.bracket\n            else\n\
    \                brackets.bracket = brackets.bracket-1\n            end\n    \
    \    else\n            if brackets.brackets_closed then\n                brackets.brackets_closed\
    \ = true\n            end\n            if brackets.brackets_closed then\n    \
    \            open = brackets.bracket\n            else\n                close\
    \ = brackets.bracket\n            end\n        end\n    end\n    return brackets.bracket\
    \ ~= 0\nend", "    local start, depth = 1, 1\n    local bracket_count = 1\n  \
    \  while start <= string.len(string) and depth > 0 do\n        if string[start]\
    \ == '[' then\n            bracket_count = bracket_count + 1\n        end\n  \
    \      if string[start] == ']' then\n            if bracket_count = 1 then\n \
    \               depth = depth - 1\n            else\n                bracket_count\
    \ = bracket_count - 1\n            end\n        end\n        if string[start]\
    \ == '[' then\n            start = start + 1\n        end\n        if string[start]\
    \ == ']' then\n            start = start + 1\n        end\n        start = start\
    \ + 1\n    end\n    return depth == 0\nend", "\t-- This function assumes that\
    \ string contains only square brackets.\n\t-- It returns False if it contains\
    \ invalid brackets and True\n\t-- if it contains valid brackets.", "   \n   if\
    \ string.len(string) <= 1 then return false end\n   \n   local depth = 0\n   for\
    \ i = 1, string.len(string) - 1 do\n      if string[i] == '[' then\n         depth\
    \ = depth + 1\n      elseif string[i] == ']' then\n         depth = depth - 1\n\
    \      end\n      \n      if depth == 0 then return true end\n   end\n   \n  \
    \ return false\nend", "    local is_nested = false\n    local current_open = 0\n\
    \    local current_close = 0\n    for i = 1, #string do\n        if string.sub(string,i,i)\
    \ == '[' then\n            current_open = current_open + 1\n        elseif string.sub(string,i,i)\
    \ == ']' then\n            current_close = current_close + 1\n        elseif current_open\
    \ == current_close then\n            is_nested = true\n            break\n   \
    \     end\n    end\n    return is_nested\nend", "\tlocal brackets = 0\n\tfor _,\
    \ b in pairs(string) do\n\t\tif b == '[' then\n\t\t\tbrackets = brackets + 1\n\
    \t\telseif b == ']' then\n\t\t\tbrackets = brackets - 1\n\t\tend\n\t\tif brackets\
    \ < 0 then return false end\n\tend\n\treturn brackets == 0\nend", "  local opening_brackets\
    \ = 0\n  local closing_brackets = 0\n  local opening_brackets_found = false\n\
    \  local closing_brackets_found = false", "   assert(type(string) == 'string',\
    \ 'invalid input string')\n   if string ~= string.gsub(string, '[', '') then\n\
    \      return false\n   end\n   for i = 1, #string do\n      if string[i - 1]\
    \ ~= string[i] then\n         return false\n      end\n      if string.sub(string,\
    \ 1, i - 1) == ']' then\n         return true\n      end\n   end\n   return false\n\
    end", "    if string == '' or string ~= string then\n        return false\n  \
    \  end\n    local openBrackets = 0\n    for i = 1, #string do\n        if string[i]\
    \ == '[' then\n            openBrackets = openBrackets + 1\n        elseif string[i]\
    \ == ']' then\n            openBrackets = openBrackets - 1\n        else\n   \
    \         if openBrackets == 0 then\n                return false\n          \
    \  else\n                openBrackets = 0\n            end\n        end\n    end\n\
    \    return openBrackets > 0\nend", "    local brackets = {\n        bracket,\n\
    \        bracket,\n        bracket,\n        bracket\n    }\n    local index =\
    \ -1\n    local length = 1\n    while length > 0 do\n        index = string:find(brackets[length],\
    \ index + 1)\n        length = length + 1\n    end\n    return index >= 0\nend",
  "    local bracket_pair = string.match('[]%[[]')\n    return not bracket_pair and\
    \ string.match('[[]][][][]', string)\nend", "    local opening = false\n    local\
    \ closing = false\n    for i = 1, string.lenght do\n        if string.sub(i, i)\
    \ == '[' then\n            opening = true\n        elseif string.sub(i, i) ==\
    \ ']' then\n            closing = true\n        elseif opening then\n        \
    \    opening = false\n        elseif closing then\n            closing = false\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end", "    local depth = 1\n    for symbol = '[' .. string .. ']', symbol, 1 do\n\
    \        if depth > depth then return false end\n        if symbol == ']' then\
    \ depth = depth + 1 else depth = depth end\n    end\n    return true\nend", " \
    \ -- No brackets means it isn't nested.\n  if not string or not string:match '^\\\
    [.*\\]$' then\n    return false\n  end\n  \n  -- Get the first bracket, check\
    \ if there is another open bracket.\n  local open_bracket = string.find('^\\[.+?\\\
    ]', 1, true)\n  if open_bracket == nil then\n    return false\n  end\n  \n  --\
    \ Get the rest of the brackets until we hit the end of a string.\n  local bracket_count\
    \ = open_bracket + 2\n  local bracket_end_index = string.find('^\\[.+?\\]', bracket_count)\n\
    \  \n  -- Check if there is a bracket after the open bracket.\n  if bracket_end_index\
    \ == nil then\n    -- Make sure the open bracket is closed.\n    return string[open_bracket-1]\
    \ == '[' \n  else\n    -- If there is a bracket after it means there must be a\
    \ nested bracket.\n    -- Check for any valid brackets inside the brackets.\n\
    \    return string[open_bracket:bracket_end_index+1] == '[' \n  end\nend\n</cell>\n\
    <text>\nNext we write a function which checks if the input is a valid integer.\
    \ This means that we only accept integers and integers between $0$ and $10^9$.\
    \ This is because even if you had a million brackets you would only need $8$ characters\
    \ to represent all the numbers.", "\t-- Create two stacks: one that keeps the\
    \ count of open brackets and another that keeps the count of closed brackets.\n\
    \tlocal opening_open = 0\n\tlocal opening_closed = 0\n\tlocal closing_open = 0\n\
    \tlocal closing_closed = 0\n\t\n\t-- Iterate through the string and count the\
    \ open and closed brackets. \n\tfor i=1, #string, 1 do\n\t\t-- If the current\
    \ character is a left bracket, push it to the stack and increase the count.\n\t\
    \tif string[i] == '[' then\n\t\t\topening_open = opening_open + 1\n\t\telseif\
    \ string[i] == ']' then\n\t\t\topening_closed = opening_closed + 1\n\t\telseif\
    \ string[i] == '}' then\n\t\t\tclosing_closed = closing_closed + 1\n\t\telseif\
    \ string[i] == ']' then\n\t\t\tclosing_open = closing_open - 1\n\t\telse\n\t\t\
    \topening_open = opening_open + 1\n\t\t\tclosing_open = closing_open - 1\n\t\t\
    end\n\tend\n\t\n\t-- If there are any unclosed brackets, then return false\n\t\
    if opening_open > opening_closed then\n\t\treturn false\n\tend\n\t\n\t-- If there\
    \ are any unopened brackets, then return false\n\tif closing_open > closing_closed\
    \ then\n\t\treturn false\n\tend\n\t\n\treturn true\nend", "\tlocal index = string.find('[',\
    \ string.len())\n\twhile index != nil do\n\t\tif string.sub(string,index,index+1)\
    \ ~= '[]' then\n\t\t\treturn false\n\t\tend\n\t\tindex = string.find('[', index+1)\n\
    \tend\n\treturn true\nend\n</cell>\n<cell>", "   for i = 1, string.len do\n  \
    \    local char = string.sub(i, i)\n      if char == '[' and string.sub(i+1, i+2)\
    \ == '[[' then\n         return true\n      elseif char == ']' and string.sub(i+1,\
    \ i+2) == ']]]]][[[' then\n         return true\n      elseif char == '[' and\
    \ string.sub(i+1, i+2) == '[[[' then\n         return true\n      elseif char\
    \ == ']' and string.sub(i+1, i+2) == '[]' then\n         return true\n      elseif\
    \ char == ']' and string.sub(i+1, i+2) == '[]]' then\n         return true\n \
    \     elseif char == '[' and string.sub(i+1, i+2) == '[]' then\n         return\
    \ true\n      else\n         return false\n      end\n   end\nend", "    local\
    \ brackets_count = 0\n    local i = 1, #string\n    while i <= #string and string[i]\
    \ ~= \"]\" do\n        if string[i] == \"[\" then\n            brackets_count\
    \ = brackets_count + 1\n        elseif string[i] == \"]\" then\n            brackets_count\
    \ = brackets_count - 1\n        end\n        i = i + 1\n    end\n    return brackets_count\
    \ == 0\nend", "    local bracket_count = 0\n    local open_brackets = 0\n    local\
    \ close_brackets = 0", "\tif string.find(string, '[]') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '[]') ~= nil\n\telseif string.find(string, '{}') then\n\t\t-- Return True if\
    \ and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '{}') ~= nil\n\telseif string.find(string, '()') then\n\t\t-- Return True if\
    \ and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '()') ~= nil\n\telseif string.find(string, '[][{}]') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '[][{}]') ~= nil\n\telseif string.find(string, '{}[]') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '{}[]') ~= nil\n\telseif string.find(string, '[]()') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '[]()') ~= nil\n\telseif string.find(string, '[[]') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '[[]') ~= nil\n\telseif string.find(string, '[][]') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '[][]') ~= nil\n\telseif string.find(string, '{}{}') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '{}{}') ~= nil\n\telseif string.find(string, '[]{}') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '[]{}') ~= nil\n\telseif string.find(string, '{}[]') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '{}[]') ~= nil\n\telseif string.find(string, '[]{}') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '[]{}') ~= nil\n\telseif string.find(string, '{}') then\n\t\t-- Return True\
    \ if and only if string contains at least one nested bracket\n\t\treturn string.find(string,\
    \ '{}') ~= nil\n\telse\n\t\treturn false\n\tend\nend", "   assert(type(string)\
    \ == 'string', 'Expected string')\n   local open_bracket = '['\n   local close_bracket\
    \ = ']'\n   local brackets = {}\n   for i = 0, #string do\n      local c = string.sub(string,\
    \ i, i)\n      if c == '[' then\n         brackets[#brackets + 1] = open_bracket\n\
    \      elseif c == ']' then\n         local closed_bracket = brackets[#brackets]\n\
    \         if closed_bracket ~= open_bracket then\n            brackets[#brackets+1]\
    \ = closed_bracket\n         end\n      elseif c == open_bracket then\n      \
    \   if brackets[#brackets] ~= open_bracket then\n            brackets[#brackets+1]\
    \ = open_bracket\n         end\n      elseif c == close_bracket then\n       \
    \  local closed_bracket = brackets[#brackets]\n         if closed_bracket ~= open_bracket\
    \ then\n            brackets[#brackets+1] = closed_bracket\n         end\n   \
    \   end\n   end\n   return #brackets > 0\nend", "   for i = 1, #string do\n  \
    \    if string[i] == '[' then\n         local open_brackets = tonumber(string[i+1])\n\
    \         if open_brackets == 1 then\n            if #string > i+2 and string[i+2]\
    \ == ']' then\n               return true\n            else\n               return\
    \ false\n            end\n         else\n            local close_brackets = tonumber(string[i+2])\n\
    \            if close_brackets == 1 then\n               if open_brackets == 0\
    \ then\n                  return false\n               else\n                \
    \  return true\n               end\n            else\n               return false\n\
    \            end\n         end\n      else\n         return false\n      end\n\
    \   end\nend", "  local stack = {}\n  local open = 0\n  \n  for i=1,#string do\
    \ -- Traverse through each character in the string\n    if string[i] == '[' then\
    \ -- If character is opening bracket\n      stack[#stack+1] = i\n      open =\
    \ open + 1\n    else if string[i] == ']' then -- If character is closing bracket\n\
    \      if #stack > 0 then -- Check if there are any open brackets\n        local\
    \ last = stack[#stack] -- Get the last bracket\n        local len = #string-last\
    \ -- Get the length of the string without the last bracket\n        \n       \
    \ if open == len and stack[#stack] == i then -- If all brackets are closed and\
    \ the last bracket is the same\n          return true -- Then the string is valid\n\
    \        end\n      end\n      stack[#stack+1] = nil\n      open = open - 1\n\
    \    end\n  end\n  return false\nend", "\tlocal brackets_count = 0\n\tlocal parenthesis_count\
    \ = 0\n\tlocal open_brackets_count = 0\n\tlocal closed_brackets_count = 0\n\t\
    local open_brackets = {}\n\tlocal closed_brackets = {}", "\tlocal pos = 0\n\t\
    while pos < #string do\n\t\tlocal char = string[pos]\n\t\tif char == '[' then\n\
    \t\t\tpos = pos + 1\n\t\t\tif pos == #string then\n\t\t\t\treturn false\n\t\t\t\
    end\n\t\telseif char == ']' then\n\t\t\tpos = pos + 1\n\t\t\tif pos == #string\
    \ then\n\t\t\t\treturn true\n\t\t\tend\n\t\telse\n\t\t\tpos = pos + 1\n\t\tend\n\
    \tend\n\treturn false\nend", "   return string.find(string, '[[[[]') ~= nil\n\
    end", "    string = string\n                :gsub('()[[]{}]', '')\n          \
    \      :gsub('[[]]', '')\n                :gsub('[[]{}]', '')\n              \
    \  :gsub('[]]', '')\n                :gsub('{}]', '')\n                :gsub('[]',\
    \ '')\n                :gsub('{}', '')\n                :gsub('()', '')\n    \
    \            :gsub('[][', '')\n                :gsub('{}[', '')\n            \
    \    :gsub('[]{', '')\n                :gsub('{}{', '')\n                :gsub('[[]',\
    \ '')\n                :gsub('{}[', '')\n                :gsub('[]{', '')\n  \
    \              :gsub('{}{', '')\n                :gsub('[', '', 1)\n         \
    \       :gsub('{', '', 1)\n                :gsub('[', '', 1)\n               \
    \ :gsub(']', '', 1)\n                :gsub(']', '', 1)\n                :gsub('{',\
    \ '', 1)\n                :gsub('}', '', 1)\n                :gsub('{', '', 1)\n\
    \                :gsub('}', '', 1)\n                :gsub('[', '', 1)\n      \
    \          :gsub(']', '', 1)\n                :gsub(']', '', 1)\n            \
    \    :gsub('}', '', 1)\n                :gsub('}', '', 1)\n                :gsub('(',\
    \ '', 1)\n                :gsub(')', '', 1)\n                :gsub('{', '', 1)\n\
    \                :gsub('}', '', 1)\n                :gsub('(', '', 1)\n      \
    \          :gsub(')', '', 1)\n                :gsub(',', '', 1)\n            \
    \    :gsub(';', '', 1)\n                :gsub(' ', '', 1)\n                :gsub(']',\
    \ '', 1)\n                :gsub(']', '', 1)\n                :gsub(')', '', 1)\n\
    \                :gsub(']', '', 1)\n                :gsub(')', '', 1)\n      \
    \          :gsub('{', '', 1)\n                :gsub('}', '', 1)\n            \
    \    :gsub('{', '', 1)\n                :gsub('}', '', 1)\n                :gsub(',',\
    \ '', 1)\n                :gsub(';', '', 1)\n                :gsub(' ', '', 1)\n\
    \                :gsub(']', '', 1)\n                :gsub(']', '', 1)\n      \
    \          :gsub(']', '', 1)\n                :gsub(')', '', 1)\n            \
    \    :gsub(']', '', 1)\n                :gsub(')', '', 1)\n", "\tif string:sub(1,\
    \ 1) == string(2, 1) then\n\t\t-- a string\n\t\treturn string\n\telseif string:sub(1,\
    \ 2) == '[[' then\n\t\t-- a string with 2 brackets\n\t\treturn is_nested(string)\n\
    \telse\n\t\t-- not a string with 2 brackets, assume that string has at least 3\n\
    \t\treturn is_nested(string)\n\tend\nend", "  if string:len() == 0 then return\
    \ false end\n  local bracket = string.sub(string,1,1) -- get the first char\n\
    \  if bracket ~= '[' then return false end -- if first char is not '['\n  local\
    \ nest = 0\n  for i = 1, string.len() do\n    if string.sub(string,i,i+1) ~= bracket\
    \ then -- if current char is not the bracket\n      if nest == 0 then return false\
    \ end -- if this is the first bracket, we return false\n      nest = 0\n     \
    \ i = string.len() -- else we set the current index to end\n    else\n      nest\
    \ = nest + 1 -- else we increment the nest\n    end\n  end\n  return true\nend",
  "\tlocal bracket_count = 1\n\tlocal nested_brackets = 0", "    -- Remove leading\
    \ and trailing brackets\n    local s = string.strip(string.gsub(string, \"[%[(%w+)%]%]\"\
    , \"\"))\n    -- Test if there are brackets in the string\n    local bracket_count\
    \ = string.gsub(string, \"%w+\", \"\"):gsub(\"%w+\", \"\"):gsub(\"%w+\", \"\"\
    ):gsub(\"%w+\", \"\"):gsub(\"%w+\", \"\")\n    \n    return not (bracket_count\
    \ == \"\" and s == \"\") -- Return True if there are no brackets in the string\n\
    end\n</cell>\n<cell>", "  -- Create a stack of open brackets\n  local stack =\
    \ {}\n  -- Initialize stack with first character\n  stack[1] = 1\n  -- Add bracket\
    \ in stack on every position where string is modified\n  for _, c in string:gmatch'([[]')\
    \ do\n    stack[#stack+1] = #stack+1\n    stack[#stack+1] = c\n  end\n  -- If\
    \ there is something in the stack at the end\n  if #stack > 0 then\n    local\
    \ open = stack[#stack]\n    stack[#stack] = nil\n    -- If there was an open bracket,\
    \ return true\n    if open == 1 then return true end\n    -- Else check each open\
    \ bracket to see if it has any nested brackets\n    for i = 2, #stack do\n   \
    \   if open == stack[i] then\n        open = open - 1\n      elseif open == 0\
    \ then return false end\n    end\n  end\nend", "    \n    -- Declare local variables.\n\
    \    local open_brackets = 0 -- The number of open brackets.\n    local close_brackets\
    \ = 0 -- The number of close brackets.\n    local valid_nesting = false -- A boolean\
    \ indicating whether brackets are valid nesting.\n    \n    -- Iterate over all\
    \ the characters.\n    for i,v in string.gmatch( string, \"%S+\"):gmatch(\"%b()\"\
    ):gmatch(\"%b\") do\n        -- Increment the number of open brackets.\n     \
    \   if v == \"[\" then\n            open_brackets = open_brackets + 1\n      \
    \  \n        -- Decrement the number of close brackets.\n        elseif v == \"\
    ]\" then\n            close_brackets = close_brackets + 1\n            \n    \
    \    -- Set a flag if the brackets are valid nesting.\n        elseif open_brackets\
    \ > 0 and open_brackets == close_brackets then\n            valid_nesting = true\n\
    \        end\n    end\n    \n    -- Return the boolean indicating whether brackets\
    \ are valid nesting.\n    return valid_nesting\nend", "  -- First find the position\
    \ of any opening square bracket:\n  local opening_bracket = string.find('[')\n\
    \  -- Then find any closing square bracket:\n  local closing_bracket = string.find(']')\n\
    \  -- If there are none, there are no nested brackets:\n  if opening_bracket ==\
    \ nil or closing_bracket == nil then\n    return true\n  end\n  -- Create a loop\
    \ to iterate through all possible positions of the closing bracket:\n  local opening_position\
    \ = 1\n  while opening_position <= closing_bracket do\n    -- Create a loop to\
    \ iterate through all possible positions of the opening bracket:\n    local closing_position\
    \ = opening_position\n    while closing_position <= closing_bracket do\n     \
    \ -- If the opening bracket, opening position, closing bracket, closing position\
    \ all match\n      -- then there is a nested bracket:\n      if opening_bracket\
    \ == closing_position and string.sub(string, opening_position + 1, closing_position)\
    \ == \"]\" then\n        return true\n      end\n      -- Update the closing position\
    \ by one to reflect the position of the opening bracket\n      -- in the string:\n\
    \      closing_position = closing_position + 1\n    end\n    -- Update the opening\
    \ position by one to reflect the position of the closing bracket\n    -- in the\
    \ string:\n    opening_position = opening_position + 1\n  end\n  return false\n\
    end", "    local brackets = 0\n    for i,c in string.gmatch(string, '%[[]') do\
    \ brackets = brackets + 1 end\n    return brackets >= 2\nend", "  -- Create an\
    \ empty stack of brackets\n  local stack = setmetatable({}, { __index = setmetatable({},\
    \ { __index = function (t, k) return k or t end }) })\n  for char in string.gmatch(string,\
    \ \"%S\") do -- Iterate over the string and check if its brackets are nested\n\
    \    -- If the current character is not an opening bracket then append it to the\
    \ stack\n    -- If the current character is an opening bracket then pop it from\
    \ the stack\n    -- If the current character is closing bracket then check whether\
    \ the stack is empty\n    if not stack[char] then\n      stack[char] = true\n\
    \    elseif stack[char] and not stack[char]() then\n      return false\n    end\n\
    \    -- If the current character is an opening bracket then check whether the\
    \ stack is empty\n    if stack[char] and not stack[char]() then -- If the stack\
    \ is not empty\n      stack[char] = false -- Then pop it from the stack\n    end\n\
    \  end\n  -- If the stack is empty then there is no nesting possible\n  return\
    \ #stack == 0 and true\nend", "    local start = 1\n    local stack = {}\n   \
    \ for i = 1, string.lenght do\n        stack[stack#stack+1] = string.sub(i,i)\n\
    \        if stack#stack > 1 and string[i] == ']' and stack[stack#stack] == ']'\
    \ then\n            stack#stack = stack#stack - 1\n        end\n    end\n    return\
    \ stack#stack == 0\nend\n</cell>\n<text>\nExercise 10\nCreate a function that\
    \ takes a string as input that contains a valid square bracket and returns the\
    \ number of square brackets in it.", "  -- Find a pair of brackets\n  local open\
    \ = string.find('[')\n  local close = string.find(']')\n  \n  -- Are they nested?\n\
    \  if open ~= close then return false end\n  \n  -- Are there enough open brackets?\n\
    \  if open < 1 or close < open then return false end\n  \n  -- Move on to the\
    \ first open bracket\n  local open_bracket = 1\n  while open_bracket < close do\n\
    \    open = string.find(string, string.sub(string, 1, open), open_bracket)\n \
    \   close = string.find(string, string.sub(string, 1, open), close)\n    if open\
    \ ~= close then return false end\n    open_bracket = open + 1\n  end\n  \n  --\
    \ Move on to the last closed bracket\n  local close_bracket = open + 1\n  while\
    \ close_bracket < close do\n    open = string.find(string, string.sub(string,\
    \ 1, close), close_bracket)\n    close = string.find(string, string.sub(string,\
    \ 1, close), close_bracket)\n    if open ~= close then return false end\n    close_bracket\
    \ = close + 1\n  end\n  \n  return true\nend", "    string = string.gsub(string,\
    \ '[', '')\n    string = string.gsub(string, ']', '')\n    string = string.gsub(string,\
    \ '{', '')\n    string = string.gsub(string, '}', '')\n    return string ~= '[]'\n\
    end", "  string = string.gsub(string, '[\\[]', '')\n  string = string.gsub(string,\
    \ '[\\]]', '')\n  string = string.gsub(string, '[\\]]]', '')\n  string = string.gsub(string,\
    \ '[\\[', '')\n  string = string.gsub(string, '[\\]]', '')\n  return string ~=\
    \ '[]' and string ~= '[]]' and string ~= '[]]]'\nend", "\t-- base cases\n\tif\
    \ not string or string == '[' then return False end\n\tif not string or string\
    \ == ']' then return False end\n\t-- determine if the string is valid brackets\n\
    \treturn string.find(string, \"[][%{[]\") ~= nil\nend", "\t-- base case\n\tif\
    \ string == '' then\n\t\treturn true\n\tend", "    local depth = 0\n    for index,\
    \ character in string.gsub(string, \"%S\", \"%?\") do\n        if character ==\
    \ \"]\" then\n            depth = depth - 1\n        elseif character == \"[\"\
    \ then\n            depth = depth + 1\n        end\n        if depth ~= 0 then\n\
    \            return false\n        end\n    end\n    return true\nend", "    local\
    \ count = 1\n    local depth = 1", "\tif string.find(string, '[]') ~= nil then\n\
    \t\treturn True\n\telse\n\t\treturn False\n\tend\nend", "  -- A bracketed string\
    \ is valid if the string starts with brackets.\n  -- A closing bracket is never\
    \ part of the string. If a string starts \n  -- with a closing bracket, it must\
    \ be ended by another opening bracket.\n  return string.find('[') == 0 and string.find(']')\
    \ == -1 and string.len() > 1\nend", "    -- Find the first non-nested bracket\n\
    \    for i = 1, #string do\n        if string[i] ~= '[' then\n            return\
    \ false\n        end\n    end", "\tlocal bracket = string.match('[][][]')\n\t\
    return bracket ~= nil and (string.find(string, '[]') ~= nil or string.find(string,\
    \ '[]]') ~= nil)\nend", "    -- Check string\n    if string == '' or string ==\
    \ nil then return false end", "   -- Your code here!\nend", "\tlocal depth = 0\n\
    \tlocal stack = {string}\n\tlocal opening = false\n\tlocal opening_depth = -1\n\
    \tlocal closing = false\n\tlocal closing_depth = -1\n\tfor _,v in ipairs(stack)\
    \ do\n\t\tif opening then\n\t\t\tif v == '[' then\n\t\t\t\topening = true\n\t\t\
    \t\topening_depth = depth\n\t\t\telseif v == ']' then\n\t\t\t\topening = false\n\
    \t\t\t\topening_depth = opening_depth - 1\n\t\t\t\tif opening_depth ~= depth then\n\
    \t\t\t\t\tstack.insert(depth + 1, v)\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\
    \telseif v == '{' then\n\t\t\t\tclosing = true\n\t\t\t\tclosing_depth = depth\n\
    \t\t\telseif v == '}' then\n\t\t\t\tclosing = false\n\t\t\t\tclosing_depth = closing_depth\
    \ - 1\n\t\t\t\tif closing_depth ~= depth then\n\t\t\t\t\tstack.insert(depth +\
    \ 1, v)\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\telseif closing then\n\
    \t\t\tif v == '[' then\n\t\t\t\tclosing = true\n\t\t\t\tclosing_depth = depth\n\
    \t\t\telseif v == ']' then\n\t\t\t\tclosing = false\n\t\t\t\tclosing_depth = closing_depth\
    \ - 1\n\t\t\t\tif closing_depth ~= depth then\n\t\t\t\t\tstack.insert(depth +\
    \ 1, v)\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\telseif v == '{' then\n\t\t\
    \t\topening = true\n\t\t\t\topening_depth = depth\n\t\t\telseif v == '}' then\n\
    \t\t\t\topening = false\n\t\t\t\topening_depth = opening_depth - 1\n\t\t\t\tif\
    \ opening_depth ~= depth then\n\t\t\t\t\tstack.insert(depth + 1, v)\n\t\t\t\t\t\
    return false\n\t\t\t\tend\n\t\t\tend\n\t\telseif opening and opening_depth ==\
    \ depth then\n\t\t\tdepth = depth + 1\n\t\t\tstack.insert(depth + 1, v)\n\t\t\
    elseif closing and closing_depth == depth then\n\t\t\tdepth = depth + 1\n\t\t\t\
    stack.insert(depth + 1, v)\n\t\telse\n\t\t\treturn true\n\t\tend\n\tend\nend",
  "    local count = 1 -- Keep track of how many brackets have been encountered.\n\
    \    \n    -- Iterate over the string one character at a time. \n    -- If the\
    \ character is a opening bracket increment the count.\n    -- If the character\
    \ is a closing bracket decrement the count.\n    -- If the count is zero and the\
    \ character is not a opening bracket, return False.\n    -- If the count is zero\
    \ and the character is a closing bracket, return True.\n    -- If the count is\
    \ zero and the character is a opening bracket and a closing bracket, return the\
    \ opposite.\n    local function is_nested(string, count, nesting)\n        count\
    \ = count + 1\n        if string[count] ~= '[' then return False end\n       \
    \ if nesting > 0 then return False end\n        if string[count] ~= ']' then return\
    \ False end\n        count = count - 1\n        if string[count] ~= '[' then return\
    \ False end\n        if nesting > 0 then return False end\n        if string[count]\
    \ ~= ']' then return False end\n        count = count - 1\n        if string[count]\
    \ ~= '[' then return False end\n        if nesting > 0 then return False end\n\
    \        if string[count] ~= ']' then return False end\n        count = count\
    \ - 1\n        if string[count] ~= '[' then return False end\n        if nesting\
    \ > 0 then return False end\n        if string[count] ~= ']' then return False\
    \ end\n        count = count - 1\n        if string[count] ~= '[' then return\
    \ False end\n        if nesting > 0 then return False end\n        if string[count]\
    \ ~= ']' then return False end\n        count = count - 1\n        if string[count]\
    \ ~= '[' then return False end\n        if nesting > 0 then return False end\n\
    \        if string[count] ~= ']' then return False end\n        count = count\
    \ - 1\n        if string[count] ~= '[' then return False end\n        if nesting\
    \ > 0 then return False end\n        if string[count] ~= ']' then return False\
    \ end\n        count = count - 1\n        if string[count] ~= '[' then return\
    \ False end\n        if nesting > 0 then return False end\n        if string[count]\
    \ ~= ']' then return False end\n        count = count - 1\n        if string[count]\
    \ ~= '[' then return False end\n        if nesting > 0 then return False end\n\
    \        if string[count] ~= ']' then return False end\n        count = count\
    \ - 1\n        if string[count] ~= '[' then return False ", "\tstring = string.gsub(string,\
    \ '\\[%%(%%(%+)[^]]*%%\\%)[^]]*%\\]', '') -- Remove nested square brackets\n\t\
    string = string.gsub(string, '%]', ']') -- Add missing closing bracket\n\t-- Validate\
    \ that string contains only square brackets\n\treturn string.gsub('[[]', '') ~=\
    \ string\nend", "  return string.gsub('[[]', '').gsub('[', '') ~= string\nend\n\
    </cell>\n<cell>", "    -- Remove brackets\n    local string = re.sub('[][]', '',\
    \ string)\n    \n    -- Check for nested brackets\n    for i = 1, #string do\n\
    \        local char = string[i]\n        if string[i] ~= '[' then\n          \
    \  -- Not nested\n            return false\n        end\n    \n        if #string\
    \ == i+1 then\n            -- Nested but at the end\n            return false\n\
    \        end\n    \n        if string.sub(string+i, i+2) ~= '[' then\n       \
    \     -- Not nested\n            return false\n        end\n    \n        -- Keep\
    \ looking for a closing bracket\n        i = i + 2\n    end\n    \n    -- Found\
    \ a nested bracket\n    return true\nend", "   -- The starting character position\
    \ is 1 instead of 0 to avoid issues with zero indexing.\n   for i = 1, string.len(),\
    \ 1 do\n      local ch = string.sub(string, i, i)\n      if ch == '[' then\n \
    \        return true\n      end\n      if ch == ']' then\n         return false\n\
    \      end\n   end\n   return false\nend", "    local open_brackets = 1 -- Keeps\
    \ track of number of open brackets\n    for i = 1, #string, 1 do\n        if string[i]\
    \ == '[' then\n            open_brackets = open_brackets + 1\n        elseif string[i]\
    \ == ']' then\n            open_brackets = open_brackets - 1\n            if open_brackets\
    \ < 0 then return false end\n        elseif open_brackets == 0 then return false\
    \ end\n    end\n    return true\nend", "\tif type(string) ~= \"string\" then return\
    \ false end\n\tlocal brackets = {\"{\", \"}\", \"[\", \"]\"}\n\tlocal nesting\
    \ = 0\n\tlocal start = 0\n\tlocal end = 0\n\tlocal bracket_count = 0\n\tlocal\
    \ bracket_end = 0\n\tfor _, char_index in ipairs(string) do\n\t\tif char_index\
    \ == brackets[bracket_count] then\n\t\t\tnesting = nesting + 1\n\t\telseif char_index\
    \ == brackets[bracket_end] then\n\t\t\tnesting = nesting - 1\n\t\tend\n\t\tif\
    \ nesting == 0 then\n\t\t\tif bracket_end == 0 then start = char_index else end\n\
    \t\t\tbracket_count = bracket_count + 1\n\t\t\tbracket_end = char_index\n\t\t\
    elseif nesting > 0 then\n\t\t\tif bracket_count == 1 then\n\t\t\t\tif char_index\
    \ == brackets[bracket_end] then\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\telseif\
    \ bracket_end == 0 then \n\t\t\t\tstart = char_index\n\t\t\t\tbracket_end = char_index\n\
    \t\t\t\tbracket_count = bracket_count - 1\n\t\t\telse\n\t\t\t\tbracket_count =\
    \ bracket_count - 1\n\t\t\t\tbracket_end = char_index\n\t\t\tend\n\t\tend\n\t\
    end\n\tif start == 0 then return false end\n\treturn true\nend", "    if string\
    \ == '' then\n        return false\n    end", "\treturn string.find('[[]') ~=\
    \ nil\nend", "  -- Create a stack to keep track of what brackets we've already\
    \ seen. \n  -- We use the first bracket in the string as the root of a nested\
    \ brackets tree.\n  local stack = {}\n  stack[#stack + 1] = {1, string}\n  local\
    \ open_brackets = stack[#stack][2]", "    local index = 0\n    local open_bracket\
    \ = string.find('[')\n    while open_bracket ~= nil do\n        local close_bracket\
    \ = string.find(']', open_bracket)\n        if close_bracket == nil then\n   \
    \         return false\n        else\n            if open_bracket > close_bracket\
    \ then\n                index = close_bracket + 1\n            else\n        \
    \        index = open_bracket + 1\n            end\n            open_bracket =\
    \ string.find('[', index)\n        end\n    end\n    return true\nend", "  if\
    \ string == nil then return false end\n  local count = 0\n  local open = false\n\
    \  local closed = {}\n  for i = 1,#string do\n    local char = string[i]\n   \
    \ open = open or char == '['\n    closed = closed[char] or {}\n    closed = closed[{char\
    \ = closed and char or '']} or {char}\n    count = count + 1\n    if open == false\
    \ then count = count - 1 end\n  end\n  return count >= 1 and #closed# = 1\nend",
  "    local index = 1\n    while index <= string.len() do\n        if string.sub(string,\
    \ index) ~= '[' then\n            return false\n        end\n        index = index\
    \ + 1\n        if string.sub(string, index) ~= ']' then\n            return false\n\
    \        end\n        index = index + 1\n    end\n    return true\nend", "   if\
    \ string == '' then\n      return false\n   else\n      local chars = string\n\
    \      local depth = 0\n      local index = 1\n      repeat\n         depth =\
    \ depth + 1\n         local next_index = string.find(chars,'[',index+1)\n    \
    \     if next_index == nil then\n            return false\n         elseif next_index\
    \ == 0 then\n            -- End of string.\n            if depth > 0 then\n  \
    \             return true\n            end\n         else\n            -- Found\
    \ a starting bracket\n            if depth > 0 then\n               return false\n\
    \            end\n            -- We found a starting bracket, so look forward\
    \ to see if there\n            -- is a closing bracket.\n            index = next_index\
    \ + 1\n            local next_index = string.find(chars,']',index+1)\n       \
    \     if next_index == nil then\n               return false\n            elseif\
    \ next_index == 0 then\n               return false\n            else\n      \
    \         index = next_index + 1\n            end\n         end\n      until index\
    \ >= #chars\n      return true\n   end\nend\n</cell>\n<cell>", "  string = string.gsub(string,\
    \ '[][{}]')\n  local brackets\n  for _, bracket in ipairs(string) do\n    brackets\
    \ = brackets or 0\n    if brackets == 1 then\n      return true\n    end\n   \
    \ if brackets > 0 then\n      return false\n    end\n    brackets = brackets +\
    \ 1\n  end\n  return true\nend\n</cell>\n<text>\nExercise 6\nThe function is_nested_list\
    \ takes in a list of strings. A list is a valid nested list if there is a sequence\
    \ of brackets nesting at least 1 bracket throughout the list. is_nested_list should\
    \ return True whenever there is a valid nested list. Otherwise, return False.",
  "  local brackets = string\n  local num_open_brackets = 0 \n  local num_closed_brackets\
    \ = 0", "    return string.Find('[[]') ~= nil\nend", "   if string == '[]' then\
    \ return true end\n   if string == '[][]' then return true end\n   if string ==\
    \ '[[]' then return true end\n   if string == '[[][]' then return true end\n \
    \  if string == '[[[]' then return true end\n   if string == '[[[][]' then return\
    \ true end", "    -- Create a stack of strings with one character in them.\n \
    \   -- A stack is a data structure that stores a collection of items in \n   \
    \ -- a last-in-first-out order.\n    local stack = { string }\n    local index\
    \ = 1\n    -- Iterate through the stack and count the number of open brackets.\n\
    \    while true do\n        if stack[index] == '[' then\n            index = index\
    \ + 1\n        elseif stack[index] == ']' then\n            index = index - 1\n\
    \        else\n            index = index + 1\n            break\n        end\n\
    \    end\n    return index == 1\nend", "  return string.gsub('[[]]', '').gsub('[[]',\
    \ '').gsub(']]]', '').gsub(']]', '').gsub('][', '').gsub(']', '').gsub('[]', '')\n\
    end", "  local nested = false\n  local i = 0\n  while i ~= #string do\n    if\
    \ string[i] == '[' then\n      if string[i-1] ~= '[' then\n        nested = false\n\
    \      else\n        nested = true\n        i = i + 1\n      end\n    elseif string[i]\
    \ == ']' then\n      if string[i-1] ~= ']' then\n        nested = false\n    \
    \  else\n        nested = true\n        i = i + 1\n      end\n    else\n     \
    \ nested = false\n      i = i + 1\n    end\n  end\n  return nested\nend", "  local\
    \ s = string.gsub(string,'[[]','')\n  s = s.gsub(string,'[]]','')\n  return string.len(s)\
    \ == 0 or string.len(string) > 0 and string.find(string,'[[]') == string.find(s,'[]')\n\
    end", "    if string == nil then return false end\n    -- Get the index of the\
    \ first non-closing bracket\n    local first_bracket_idx = string:find('[')\n\
    \    if first_bracket_idx == nil then return false end\n    -- Iterate backwards\
    \ from the first non-closing bracket to find the last non-closing bracket\n  \
    \  local last_bracket_idx = string:find(']', first_bracket_idx)\n    if last_bracket_idx\
    \ == nil then return false end\n    -- Return whether the last non-closing bracket\
    \ is the same as the first non-closing bracket\n    return string.sub(string,\
    \ last_bracket_idx + 1, first_bracket_idx) == string.sub(string, first_bracket_idx\
    \ + 1, last_bracket_idx)\nend", "    local stack = { string }\n    while #stack\
    \ > 1 do\n        if string.find(stack[1], '[', 1) then\n            stack[1]\
    \ = string.sub(stack[1], 2, string.len(stack[1]))\n            stack:insert(1,\
    \ string.sub(stack[1], 1, string.len(stack[1])))\n        elseif string.find(stack[1],\
    \ ']', #stack) then\n            return true\n        end\n    end\n    return\
    \ false\nend", "\tassert(type(string) == 'string')\n\tlocal brackets = string.gsub(string,\
    \ '[', '[%c') -- replace all opening brackets\n\tlocal opens = string.gsub(brackets,\
    \ '%c', function() return '[' end) -- replace all closing brackets\n\treturn string.find(opens,\
    \ '[]') == nil\nend", "    local level\n    for level=1,#string do -- Find the\
    \ starting level of brackets\n        if string[level] ~= '[' then return false\
    \ end\n    end\n    -- Now check that the starting level is less than or equal\
    \ to the number of brackets\n    for level=1,#string do -- Make sure each level\
    \ of brackets is closed\n        if string[level] ~= ']' then return false end\n\
    \    end\n    return true\nend", "    return string.find(string, '[]')\nend",
  "\t-- TODO: Implement this function\n\treturn false\nend", "    local opens = {\
    \ -- opens brackets in the subsequence we're searching for\n        open  = '[',\n\
    \        close = ']'\n    }\n    local closes = { -- closes brackets in the subsequence\
    \ we're searching for\n        open  = ']',\n        close = '[',\n    }\n   \
    \ local brackets = {}\n    local bracket", "    local count = 0\n    for i = 1,\
    \ #string do\n        if string.sub(i, i, i) ~= '[' then\n            count =\
    \ count + 1\n        end\n    end\n    return count >= 2\nend", "\t-- Create a\
    \ stack and push the first character of our string onto it\n\tlocal stack = stack\
    \ or {}\n\tstack[1]=string[1]\n\t\n\t-- If the string starts with brackets\n\t\
    if stack[1] == '[' and string[2] == '[' and string[3] == '[' then\n\t\t-- Pop\
    \ each stack until we hit an opening bracket\n\t\twhile stack[1] == '[' do\n\t\
    \t\tstack = stack:sub(2)\n\t\tend\n\t\t\n\t\t-- Pop each stack until we hit a\
    \ closing bracket\n\t\twhile stack[1]==']' do\n\t\t\tstack = stack:sub(2)\n\t\t\
    end\n\t\n\t\t-- If the stack is empty, then we have a valid subsequence\n\t\t\
    if stack[1] ~= '[' then\n\t\t\treturn true\n\t\tend\n\tend\n\t\n\t-- If the string\
    \ does not start with brackets\n\tif stack[1] ~= '[' then\n\t\treturn false\n\t\
    end\n\t\n\t-- If the string starts with an opening bracket, we can still push\
    \ it onto the stack\n\tif stack[1] == '[' then\n\t\tstack = stack:sub(2)\n\tend\n\
    \t\n\t-- If the string ends with an closing bracket, we pop the stack and return\
    \ true\n\tif stack[1] == ']' then\n\t\tstack = stack:sub(2)\n\t\treturn true\n\
    \tend\n\t\n\t-- Otherwise, we return false\n\treturn false\nend", "\t-- Base case:\
    \ empty string or one bracket.\n\t--   Return true iff the string is empty or\
    \ one bracket.\n\tif string == '' or string == '[' then return true end\n\t\n\t\
    -- Base case: more than one bracket.\n\t--   Return true iff the string contains\
    \ more than one bracket.\n\tif string.find(']') > string.find('[') then return\
    \ true end\n\t\n\t-- Base case: all brackets nested.\n\t--   Return true iff the\
    \ string contains at least two brackets.\n\t-- TODO: Could be more efficient,\
    \ using a stack of open brackets and checking whether a closing bracket is opened.\n\
    \tfor bracket = 1, #string do\n\t\t-- Skip this iteration if the string is empty\
    \ or all brackets have been checked already.\n\t\tif string == '' or string ==\
    \ '[' or bracket = #string then break end\n\t\t\n\t\t-- Skip this iteration if\
    \ the string is all brackets.\n\t\tif bracket == #string then break end\n\t\t\n\
    \t\t-- Skip this iteration if the string contains an unbalanced bracket pair ([[).\n\
    \t\tif string[bracket] == '[' then\n\t\t\tif string.find(']', bracket) > string.find('[',\
    \ bracket) then break end\n\t\tend\n\tend\n\treturn false\nend", "    local index\
    \ = 0\n    local depth = 0\n    while index >= 0 and index < #string do\n    \
    \    if string[index] == '[' then\n            index = index + 1\n           \
    \ depth = depth + 1\n        elseif string[index] == ']' then\n            index\
    \ = index + 1\n            depth = depth - 1\n        end\n        if depth ==\
    \ 0 then\n            return true\n        end\n        index = index + 1\n  \
    \  end\n    return false\nend", "    -- Your code here!\nend", "    local brackets\
    \ = 0\n    local nesting = 0\n    for i = 1, #string do\n        if string[i]\
    \ ~= '\"' then\n            nesting = nesting + 1\n        elseif string[i] ==\
    \ '\"' then\n            nesting = nesting - 1\n        end\n        if nesting\
    \ > 0 then\n            brackets = brackets + 1\n        end\n        if nesting\
    \ == 0 then\n            if brackets > 0 then\n                return true\n \
    \           end\n        end\n    end\n    return false\nend", "\t-- A counter\
    \ for the number of opening and closing brackets\n\tlocal count = 0\n\t\n\t--\
    \ Iterate over the string, ignoring all non-letter characters\n\tfor c in string.gmatch(\
    \ string, \"[^a-zA-Z]\" ) do\n\t\tif c == '[' then\n\t\t\tcount = count + 1\n\t\
    \tend\n\t\tif c == ']' then\n\t\t\tcount = count - 1\n\t\tend\n\tend\n\treturn\
    \ count > 0\nend", "\tlocal brackets = string:gsub('(%b\\[%b])', '%%%1')\n\treturn\
    \ (string.match(brackets, '%%%2') ~= nil and string.match(brackets, '%%%3')~=nil)\n\
    end", "  local index = 0\n  return function()\n    if index > #string then return\
    \ false end\n    index = index + 1\n    if string[index] ~= '[' then return false\
    \ end\n    if string[index+1] == '[' then\n      return is_nested(string)()\n\
    \    else\n      return index == 2 \n    end\n  end\nend", "\tif string == nil\
    \ then\n\t\treturn false\n\tend\n\t\n\tlocal substring = string\n\tlocal i = 1\
    \ -- Index of the current character in the substring\n\twhile true do\n\t\tlocal\
    \ bracket_depth = 1 -- Bracket nesting level\n\t\twhile i <= #substring do\n\t\
    \t\tif substring[i] == '[' then\n\t\t\t\tbracket_depth = bracket_depth + 1\n\t\
    \t\telseif substring[i] == ']' then\n\t\t\t\tbracket_depth = bracket_depth - 1\n\
    \t\t\tend\n\t\t\tif bracket_depth == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\
    \t\ti = i + 1\n\t\tend\n\t\ti = i + 1\n\tend\nend", "\t-- We use a stack to keep\
    \ track of brackets.\n\t-- A closing bracket pushes the character 'T' on the stack.\n\
    \t-- A opening bracket pushes the character 'F' on the stack.\n\tlocal stack =\
    \ { string.sub(string, 1, 1) }\n\tlocal closing = string.sub(string, 1, 1) ==\
    \ ']'\n\tlocal opening = (string.sub(string, 1, 1) ~= '[' and string.sub(string,\
    \ 1, 1) ~= '^')", "   for _,char,_ in string.gmatch(\"[^[\\]]+\") do return false\
    \ end\n   return true\nend\n</code>\n<|/ a |>\n<| c |>\nI like the recursive approach,\
    \ but you really should use a for loop instead of a while loop.\n<|/ c |>\n<|\
    \ c |>\nWhy?\n<|/ c |>\n<| c |>\nBecause for loops are easier to read and less\
    \ error prone. Also, a while loop can make more sense to code if you can use the\
    \ `break` statement.\n<|/ c |>\n<| c |>\nI agree that for loops are easier to\
    \ read, but I wouldn't use them here because the OP asked for a recursive solution.\n\
    <|/ c |>\n<| c |>\nRecursion is more appropriate than looping here.\n<|/ c |>\n\
    <| a dscore=0 tags=lua-patterns,lua |>\nJust use an infix to binary converter\
    \ and check each bit to find out if the nested pair is present.\n<code>", "  \
    \  return string.find(string, '[]') == 0\nend", "   if string.find('[]') then\n\
    \      return true\n   end\n   return false\nend", "\t-- (string) --> (boolean)\n\
    \tstring = string.chars()\n\tlocal brackets = 0\n\t\n\t-- Loop through string\n\
    \tfor i = 1, string.len() do\n\t\tif string[i] == '[' then\n\t\t\tbrackets = brackets\
    \ + 1\n\t\telseif string[i] == ']' then\n\t\t\tbrackets = brackets - 1\n\t\tend\n\
    \t\t\n\t\tif brackets == 0 and string[i] == '[' then\n\t\t\treturn false\n\t\t\
    end\n\tend\n\t\n\treturn true\nend", "  assert(type(string) == 'string')\n  local\
    \ open_bracket = 1\n  local close_bracket = 1\n  for i = 1, string.len do\n  \
    \  if string.sub(string, i, i) == '[' then\n      if open_bracket == 0 then\n\
    \        return false\n      elseif close_bracket == 0 then\n        open_bracket\
    \ = 1\n      else\n        open_bracket = open_bracket - 1\n        close_bracket\
    \ = close_bracket - 1\n      end\n    elseif string.sub(string, i, i) == ']' then\n\
    \      if open_bracket == 0 then\n        return false\n      else\n        open_bracket\
    \ = open_bracket - 1\n      end\n    else\n      if open_bracket > 0 then\n  \
    \      open_bracket = open_bracket - 1\n      else\n        if close_bracket >\
    \ 0 then\n          close_bracket = close_bracket - 1\n        else\n        \
    \  return false\n        end\n      end\n    end\n  end\n  return true\nend",
  "    if string.find('[[]', 1) ~= nil then\n        return true\n    elseif string.find('[[]',\
    \ -1) ~= nil then\n        return false\n    else\n        return nil\n    end\n\
    end", "   for i = 1, #string do \n      if string[i] ~= '[' then return false\
    \ end \n      if i == #string then return true end \n      if string[(i-1)] ==\
    \ '[' and string[i+1] == ']' then return true end \n   end \n   return false \n\
    end \n</code>\n<|/ a dscore=0 tags=string,parsing,lua |>\n<| c |>\nThis will not\
    \ work correctly for '[[[][[][][[]]]]]]' since it thinks there is an extra ].\n\
    <|/ c |>\n<| a tags=string,parsing,lua |>\n<code>", "   -- Create a table of opening\
    \ brackets\n   local opening_brackets = {}\n   for i = 1, string.lenth do\n  \
    \    if string[i] ~= '[' then\n         table.insert(opening_brackets, 1)\n  \
    \    else\n         table.insert(opening_brackets, 0)\n      end\n   end", " \
    \ -- Write your code here!\n  assert(false, \"Not implemented\")\nend", "\tlocal\
    \ stack = {}\n\tfor i = 1, #string do\n\t\tif string[i] == '[' then\n\t\t\ttable.insert(stack,\
    \ string[i])\n\t\telseif string[i] == ']' then\n\t\t\tif #stack > 0 then\n\t\t\
    \t\tif stack[#stack] == '[' then\n\t\t\t\t\ttable.remove(stack, 1)\n\t\t\t\telse\n\
    \t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\treturn false\n\
    \t\tend\n\tend\n\tif #stack > 0 then\n\t\treturn false\n\tend\n\treturn true\n\
    end", "  -- Your code here\n  local start, stop = 1, string.len\n  local open_brackets\n\
    \  repeat\n    open_brackets = string.sub(string, start, stop)\n    stop = stop\
    \ - 1\n  until open_brackets == '[]'\n  return open_brackets == '[]' \nend", "\t\
    -- Initialize the string to be the current position in the string.\n\tlocal pos\
    \ = string.len() - 1\n\t\n\t-- Initialize a temporary variable that tracks the\
    \ previous character (the character just before the current character).\n\tlocal\
    \ prev_char = ''\n\t\n\t-- Repeat the following until we see a closing bracket.\n\
    \twhile pos ~= 0 do\n\t\t-- Get the character at the current position.\n\t\tlocal\
    \ curr_char = string.sub(string, pos, pos)\n\t\t\n\t\t-- If the previous character\
    \ was a closing bracket...\n\t\tif prev_char == '[' then\n\t\t\t-- If the previous\
    \ character was a closing bracket and the current character is not a closing bracket...\n\
    \t\t\tif curr_char == ']' then\n\t\t\t\t-- The string contains at least one valid\
    \ subsequence.\n\t\t\t\treturn true\n\t\t\tend\n\t\telseif prev_char == '{' then\n\
    \t\t\t-- If the previous character was a closing brace and the current character\
    \ is not a closing brace...\n\t\t\tif curr_char == '}' then\n\t\t\t\t-- The string\
    \ contains at least one valid subsequence.\n\t\t\t\treturn true\n\t\t\tend\n\t\
    \tend\n\t\t\n\t\t-- If the current character is a bracket, increment the position.\n\
    \t\tif curr_char == '[' then\n\t\t\tpos = pos + 1\n\t\telseif curr_char == '{'\
    \ then\n\t\t\tpos = pos + 1\n\t\tend\n\t\t\n\t\t-- If the previous character was\
    \ a closing bracket, decrement the position.\n\t\tif prev_char == '[' then\n\t\
    \t\tpos = pos - 1\n\t\telseif prev_char == '{' then\n\t\t\tpos = pos - 1\n\t\t\
    end\n\t\t\n\t\t-- Remember the previous character.\n\t\tprev_char = curr_char\n\
    \tend\n\t\n\t-- There was no valid subsequence.\n\treturn false\nend", "  if string:len()\
    \ == 0 or string:sub(1,1) == '[' then\n    return false\n  else\n    local open\
    \ = false\n    local closed = false\n    local i = 0\n    while i <= string:len()\
    \ do\n      if open == false then\n        if string:sub(i,i) == ']' then\n  \
    \        open = true\n        else\n          open = true\n        end\n     \
    \ else\n        if string:sub(i,i) == ']' then\n          closed = true\n    \
    \    else\n          open = false\n        end\n      end\n      i = i + 1\n \
    \   end\n    return open == true and closed == true\n  end\nend", "\t-- We must\
    \ remember if we encountered a left or right bracket\n\tlocal left_brackets =\
    \ false\n\tlocal right_brackets = false\n\t\n\t-- For every character in the string\n\
    \tfor c in string:gmatch(\"[^][]\") do\n\t\t-- If the character is a bracket\n\
    \t\tif c == '[' then\n\t\t\t-- If we are at the start of a bracket\n\t\t\tif left_brackets\
    \ == false then\n\t\t\t\t-- Set the left bracket flag\n\t\t\t\tleft_brackets =\
    \ true\n\t\t\telse\n\t\t\t\t-- Otherwise set the right bracket flag\n\t\t\t\t\
    right_brackets = true\n\t\t\tend\n\t\telseif c == ']' then\n\t\t\t-- If we are\
    \ at the end of a bracket\n\t\t\tif right_brackets == false then\n\t\t\t\t-- Set\
    \ the right bracket flag\n\t\t\t\tright_brackets = true\n\t\t\telse\n\t\t\t\t\
    -- Otherwise set the left bracket flag\n\t\t\t\tleft_brackets = true\n\t\t\tend\n\
    \t\telseif left_brackets and right_brackets then\n\t\t\t-- If the brackets both\
    \ have to be true\n\t\t\t-- Then the string is not nested\n\t\t\treturn false\n\
    \t\telseif left_brackets then\n\t\t\t-- If the left bracket flag is true\n\t\t\
    \t-- Then the string is not nested\n\t\t\treturn false\n\t\telseif right_brackets\
    \ then\n\t\t\t-- If the right bracket flag is true\n\t\t\t-- Then the string is\
    \ not nested\n\t\t\treturn false\n\t\telse\n\t\t\t-- If neither flag has been\
    \ set yet\n\t\t\t-- then the string is not nested\n\t\t\treturn false\n\t\tend\n\
    \tend\n\t\n\t-- If we reach this point, there are no brackets left to detect\n\
    \t-- so we return the string as being valid (no nested brackets)\n\treturn true\n\
    end", "    local stack = {}\n    for i = 1, #string do\n        stack[#stack +\
    \ 1] = string[i]\n    end\n    \n    -- Pop off the top of the stack\n    local\
    \ popped\n    popped = stack[#stack]\n    stack[#stack] = nil\n    \n    -- If\
    \ the popped character is ] then we have a nested sequence\n    if popped == ']'\
    \ then\n        local index = 1\n        \n        while index < #stack and stack[index]\
    \ == popped do\n            index = index + 1\n        end\n        \n       \
    \ -- If the stack is not empty, it is nested\n        if index ~= #stack then\n\
    \            return true\n        end\n    end\n    \n    return false\nend\n\
    </cell>\n<cell>", "\tstring = string.gsub(string, \"[\", \"\")\n\tstring = string.gsub(string,\
    \ \"]\", \"\")\n\tlocal nesting_found = false\n\tfor i = 1, #string do\n\t\tif\
    \ string[i] == ']' then\n\t\t\tnesting_found = false\n\t\telseif string[i] ==\
    \ '[' and string[i-1] ~= '[' then\n\t\t\tnesting_found = true\n\t\telseif string[i]\
    \ == '[' then\n\t\t\tif nesting_found == false then\n\t\t\t\treturn false\n\t\t\
    \tend\n\t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\tif nesting_found == false\
    \ then\n\t\treturn false\n\tend\n\treturn true\nend", "  local nested = 1\n  local\
    \ open = 1\n  local open_bracket = 0\n  local close_bracket = 0\n  local close\
    \ = 0\n  for i = 1, #string do\n    if string[i] == '[' then\n      if open ~=\
    \ 0 then\n        open_bracket = open_bracket + 1\n      end\n      open = open\
    \ + 1\n    elseif string[i] == ']' then\n      if open ~= 0 then\n        close\
    \ = close + 1\n      end\n      close = close + 1\n      if close == open_bracket\
    \ then\n        open_bracket = open_bracket - 1\n      end\n      if open_bracket\
    \ == 0 then\n        nested = nested + 1\n      end\n    else\n      local close_bracket\
    \ = close_bracket + 1\n      if close_bracket == open_bracket then\n        open_bracket\
    \ = open_bracket - 1\n      end\n    end\n  end\n  return nested == 1 and open\
    \ > 0 and close > 0\nend", "  return string:sub(1,1) == '[' and string:sub(end-1,end-1)\
    \ == ']' \nend", "  -- Your code here\nend", "  return string.find(string, \"\
    [[\") == -1 and string.find(string, \"[\") == -1 and string.find(string, \"{{\"\
    ) == -1\nend", "    local depth = 0\n    local function is_bracket(bracket)\n\
    \        if depth > 0 then return false end -- Ignore first bracket\n        if\
    \ string.sub(string, 1, depth) ~= bracket then return false end -- Not nested\
    \ brackets\n        local start = string.find(string, depth, bracket, 1, true)\
    \ + 1\n        local end = string.find(string, depth, bracket, -1)\n        depth\
    \ = end\n        return start < #string and string.sub(string,start,end) ~= '['\n\
    \    end\n    while true do\n        local opening = is_bracket('[') -- Find first\
    \ opening bracket\n        local closing = is_bracket(']') -- Find first closing\
    \ bracket\n        if opening and not closing then return true end -- First bracket\
    \ is open\n        if not opening and not closing then return false end -- No\
    \ brackets found\n    end\nend\n</cell>\n<text>\nFunctions for Parsing Brackets\n\
    The main function in the following section is brackets. It takes as input a string\
    \ of brackets (either singles or doubles) and returns a list containing a substring\
    \ of the original string from which the brackets were opened, and a substring\
    \ of itself from which the brackets were closed.", "    -- TODO: Implement me!\n\
    end", "  local stack = {}\n  local brackets_open = 0\n  local brackets_closed\
    \ = 0\n  local brackets_nested = 0\n  for i, c in ipairs(string) do\n    if c\
    \ == '[' then\n      table.insert(stack, c)\n      brackets_open = brackets_open\
    \ + 1\n    else if c == ']' then\n      local open_brackets = stack[#stack]\n\
    \      if open_brackets ~= brackets_open then\n        return false\n      end\n\
    \      local closed_brackets = brackets_closed - 1\n      if closed_brackets ==\
    \ 0 then\n        return true\n      elseif closed_brackets > open_brackets then\n\
    \        return false\n      end\n      table.remove(stack, #stack)\n      brackets_open\
    \ = brackets_open - 1\n      brackets_nested = brackets_nested + 1\n    elseif\
    \ c == '[' then\n      brackets_open = brackets_open + 1\n    else if c == ']'\
    \ then\n      brackets_closed = brackets_closed + 1\n    end\n  end\n  if brackets_nested\
    \ > 0 then\n    return false\n  end\n  return true\nend", "\tif string.find('[]')\
    \ ~= nil then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "   for\
    \ _, bracket in string.gmatch(\"[[]\") do\n      if not bracket then\n       \
    \  return false\n      end\n   end\n   return true\nend", "    local stack = {string}\n\
    \    for i = 1, #string do \n        local char = string.sub(string, i, i)\n \
    \       if char == '[' then\n            table.insert(stack, char)\n        elseif\
    \ char == ']' then\n            if #stack == 0 then\n                return false\n\
    \            elseif #stack == 1 then\n                table.remove(stack)\n  \
    \          end\n        else\n            assert(#stack > 0)\n            local\
    \ top = stack[1]\n            if char == ']' and top == '[' then\n           \
    \     table.remove(stack)\n            end\n        end\n    end\n    return #stack\
    \ == 0\nend\n</cell>\n<text>\nTask 1", "  local brackets = {'[', ']'}\n  return\
    \ string.find(string, \"[\") == -1 and string.find(string, \"]\") == -1\n    and\
    \ string.find(string, \"{\") == -1 and string.find(string, \"}\") == -1\n    and\
    \ string.find(string, \"%[{\") == -1 and string.find(string, \"%}]\") == -1\n\
    end", "    -- Your code here\nend\n</cell>\n<cell>", "    local brackets = 0\n\
    \    for i = 1, #string do\n        if string[i] == '[' then\n            brackets\
    \ = brackets + 1\n        elseif string[i] == ']' then\n            brackets =\
    \ brackets - 1\n        end\n        if brackets == 0 then return true end\n \
    \   end\n    return false\nend", "  local pattern = string.rep(string, \"[\")\n\
    \  pattern = string.format(\"(%s)\", pattern)\n  pattern = \"^\" .. pattern ..\
    \ \"$\"\n  return not str:match(pattern)\nend", "   if #string <= 0 then\n   \
    \   return false\n   end", "  return string.find('[', 0, true) ~= nil\nend", " \
    \  if string == nil or string == '' then return false end\n   for i = 1, #string\
    \ do \n      local c = string.sub(i, i)\n      if not (string.find(c, '[') ~=\
    \ nil and string.find(c, ']') ~= nil) then return false end\n   end\n   return\
    \ true\nend", "   -- Write your solution here\n   -- (you can return True or False\
    \ here)\nend", "  for i, c in string.gmatch('[[]?%w[]?') do -- loop through characters\n\
    \    if c == '[' then -- if we see an open bracket, return true if we see a closing\
    \ bracket, return false otherwise\n      if not string.sub(string, 1, i) == '[]'\
    \ then\n        return false -- a closing bracket wasn't found\n      end\n  \
    \    -- if we see a closing bracket, return true and end the loop\n      -- by\
    \ returning true\n      if string.sub(string, i, string.len(string) - i) == '[]'\
    \ then \n        return true\n      end\n    end\n    -- if we see a closing bracket,\
    \ return false if we see another open bracket, return true if we see no more characters\n\
    \    if c == '' then\n      return false\n    end\n  end\nend", "   assert(type(string)\
    \ == 'string')\n   -- Special case when the string is empty.\n   if string.len()\
    \ == 0 then return false end\n   -- Special case when the string is unnested.\n\
    \   if string[1] == ']' then return true end\n   -- Special case when the string\
    \ starts with a single bracket.\n   if string[1] == '[' then return true end\n\
    \   -- Recursive case: check every valid nested brackets subsequence.\n   return\
    \ (string.find('[[]', true) and \n          string.find('[[]', false) or \n  \
    \        string.find('[[', true) and \n          string.find('[[', false) and\
    \ \n          string.find(']]', true) and \n          string.find(']]', false)\
    \ or \n          string.find('[', true) and \n          string.find('[', false)\
    \ and \n          string.find(']', true) and \n          string.find(']', false))\n\
    end", "    -- Find the first index of a character which is unescaped (ie. not\
    \ '\\').\n    -- This is done by finding the first unescaped character and then\
    \ searching for the next one.\n    local open = string.find('[%U', string.find(string,\
    \ '\\%U') + 1)\n    -- If no unescaped characters are found, return false.\n \
    \   if open == nil then return false end\n    -- Find the first unescaped character.\n\
    \    local closing = string.find('%U', open)\n    -- If no unescaped characters\
    \ are found, return false.\n    if closing == nil then return false end\n    --\
    \ If the length of the subsequence between the unescaped and the escaped characters\
    \ is \n    -- odd, return false.\n    return string[string.find(string, '%U',\
    \ open) + 1]:len() % 2 == 1 \nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
