name: HumanEval_16_count_distinct_characters
language: lua
prompt: "-- Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n-- >>> count_distinct_characters('xyzXYZ')\n-- 3\n-- >>> count_distinct_characters('Jerry')\n\
  -- 4\nlocal function count_distinct_characters(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_distinct_characters\n\
  \    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('abcde'),\
  \ 5)\n    lu.assertEquals(candidate('abcdecadeCADE'), 5)\n    lu.assertEquals(candidate('aaaaAAAAaaaa'),\
  \ 1)\n    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return #(Set('') -- Set() is a table of unique elements (each element\
    \ only occurs once)\n                ++ Set('a')\n                ++ Set('A')\n\
    \                ++ Set('z')\n                ++ Set('Z')\n                ++\
    \ Set('0')\n                ++ Set('9')\n                ++ Set('!'))\n      \
    \      -- ^ Set() is a table of unique elements (each element only occurs once)\n\
    \            --   ++ Set() is a table of unique elements (each element only occurs\
    \ once)\n            --     ++ Set() is a table of unique elements (each element\
    \ only occurs once)\n            --       ++ Set() is a table of unique elements\
    \ (each element only occurs once)\n            --         ++ Set() is a table\
    \ of unique elements (each element only occurs once)\n            --         \
    \  ++ Set() is a table of unique elements (each element only occurs once)\n  \
    \          --             ++ Set() is a table of unique elements (each element\
    \ only occurs once)\n            --               ++ Set() is a table of unique\
    \ elements (each element only occurs once)\n            --                 ++\
    \ Set() is a table of unique elements (each element only occurs once)\n      \
    \      --                   ++ Set() is a table of unique elements (each element\
    \ only occurs once)\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' is also\
    \ a distinct character\n            --\n            --   + 1 because '0' ", " \
    \   -- Create a frequency table of distinct characters in the string\n    local\
    \ character_frequency = {}\n    for _ = 1, #string do\n        table.insert(character_frequency,\
    \ string.sub(string,_, string.len() ))\n    end\n    -- Return the number of distinct\
    \ characters\n    return #character_frequency\nend", "  local distinct_count =\
    \ 0\n  for char in string.gmatch(\"[%a%A]\", \"%c\") do\n    distinct_count =\
    \ distinct_count + 1\n  end\n  return distinct_count\nend", "    if string ==\
    \ nil then\n        return 0\n    end\n    if string.bytes == nil then\n     \
    \   return 0\n    end", "  -- Get the string length\n  local len_string = string.len",
  "  if string == nil then return 0 end\n  local count = 0\n  for i = 1, #string do\n\
    \    count = count + 1\n    if string.sub(i, i+1, string.sub(i, i+1)) == string.sub(i,\
    \ i+1) then\n      count = count + 1\n    end\n  end\n  return count\nend", " \
    \ if type(string) ~= 'string' then\n    error('First argument must be a string.')\n\
    \  end\n  if #string == 0 then\n    return 0\n  end\n  local counter = 1\n  local\
    \ current_character = string[1]\n  for i = 2, #string do\n    if string[i] ~=\
    \ current_character then\n      counter = counter + 1\n      current_character\
    \ = string[i]\n    end\n  end\n  return counter\nend", "\tlocal count, i = 1,\
    \ 1\n\twhile i do\n\t\tcount = count + 1\n\t\ti = string.find(string, '%c', i,\
    \ true)\n\tend\n\treturn count\nend", "  local distinctChars = { }\n  local charCounter\
    \ = 0\n  for _, _ in pairs(string) do\n    if string.sub(string, 1, charCounter)\
    \ == string.sub(string, charCounter) then\n      table.insert(distinctChars, string.sub(string,\
    \ charCounter))\n      charCounter = charCounter + 1\n    else\n      charCounter\
    \ = charCounter + 1\n    end\n  end\n  return table.count(distinctChars)\nend",
  "   local count = 0\n   for char in string.gmatch( string, '%a' ) do\n      if string.lower(char)\
    \ == string.lower(char) then\n         count = count + 1\n      end\n   end\n\
    \   return count\nend", "  return string.gsub(string, '%c'):sub(1, 1):upper():byte()\
    \ -- Count the number of distinct characters\nend", "    if string == nil then\n\
    \        return 0\n    end", "    return #string.match(string, '[^'..string.char(191)\
    \ .. '-]'):gcount\nend", "   local distinct = 0\n   for i = 0, string.len(string)\
    \ - 1 do\n      if not string.sub(string,i, i+1) ~= string.sub(string,i+1, i+2)\
    \ then\n         distinct = distinct + 1\n      end\n   end\n   return distinct\n\
    end", "    if string == nil then return nil end\n    local count = 0\n    for\
    \ char in string.gmatch(\"[%a\u0410-\u042F(){}]\", \"G\") do\n        if string.match(string,\
    \ char) ~= nil then\n            count = count + 1\n        end\n    end\n   \
    \ return count\nend", "\tlocal distinct = 0\n\tfor i=1,#string do\n\t\tif not\
    \ string.sub( string, i, i+1 ):lower() then\n\t\t\tdistinct = distinct + 1\n\t\
    \tend\n\tend\n\treturn distinct\nend", "    local result = 1\n    for i = 1, #string\
    \ do\n        if string.sub(i, i, i) ~= string.sub(i, 1, i) then result = result\
    \ + 1 end\n    end\n    return result\nend", "  local count = 1\n  for i = 1,\
    \ #string do\n    count = count + (string[i]:lower())\n  end\n  return count\n\
    end", "    local count = 0\n    for _, c in string:gmatch(\".\") do\n        if\
    \ c:upper() ~= c and c:lower() ~= c then\n            count = count + 1\n    \
    \    end\n    end\n    return count\nend", "    local distinct_char_count = 0\n\
    \    for _,c in ipairs(string) do\n        if string.lower(c) ~= string.upper(c)\
    \ then\n            distinct_char_count = distinct_char_count + 1\n        end\n\
    \    end\n    return distinct_char_count\nend", "    local count = 0\n    for\
    \ ch in string:gmatch(\"[%a]+\") do count = count + 1 end\n    return count\n\
    end", "  local count = 0\n  local last_character = nil\n  for i = 1, #string do\n\
    \    if string[i] ~= last_character then\n      count = count + 1\n      last_character\
    \ = string[i]\n    end\n  end\n  return count\nend", "  local distinct_characters\
    \ = 0\n  for i = 1, #string do\n    local character = string[i]\n    if character\
    \ ~= character then\n      distinct_characters = distinct_characters + 1\n   \
    \ end\n  end\n  return distinct_characters\nend", "    local chars = {}\n    for\
    \ _, _ in pairs(string) do\n        table.insert(chars, tostring(_))\n    end\n\
    \    return #chars\nend", "  return string.gsub(string.gsub(string, '%W', ''),\
    \ '[%]', '')\nend", "    local c = 0\n    local last_case = false", '  return
    string:gsub("%w+"):gsub("%d+"):gsub("%d%d%d%d%d%d%d"):gsub("%x"):gsub("%d"):gsub("%c"):gsub("%w"):gsub("%d+"):gsub("%d*"):gsub("%d-"):gsub("%d%w"):gsub("%d%d"):gsub("%d%d*"):gsub("%d%d-"):gsub("%d%d%w"):gsub("%d%d%d"):gsub("%d%d%d*"):gsub("%d%d%d-"):gsub("%d%d%d%w"):gsub("%d%d%d%d"):gsub("%d%d%d%d*"):gsub("%d%d%d%d-"):gsub("%d%d%d%d%w"):gsub("%d%d%d%d%d"):gsub("%d%d%d%d%d*"):gsub("%d%d%d%d%d-"):gsub("%d%d%d%d%d%w"):gsub("%d%d%d%d%d%d"):gsub("%d%d%d%d%d%d*"):gsub("%d%d%d%d%d%d-"):gsub("%d%d%d%d%d%d%w"):gsub("%d%d%d%d%d%d%d"):gsub("%d%d%d%d%d%d%d*"):gsub("%d%d%d%d%d%d%d-"):gsub("%d%d%d%d%d%d%d%w"):gsub("%d%d%d%d%d%d%d%d"):gsub("%d%d%d%d%d%d%d%d*"):gsub("%d%d%d%d%d%d%d%d-"):gsub("%d%d%d%d%d%d%d%d%w"):gsub("%d%d%d%d%d%d%d%d%d"):gsub("%d%d%d%d%d%d%d%d*"):gsub("%d%d%d%d%d%d%d%d-"):gsub("%d%d%d%d%d%d%d%d%w"):gsub("%d%d%d%d%d%d%d%d%d"):gsub("%d%d%d%d%d%d%d%d*"):gsub("%d%d%d%d%d%d%d%d-"):gsub("%d%d%d%d%d%d%d%d%w"):gsub("%d%d%d%d%d%d%d%d%d"):gsub("%d%d%d%d%d%d%d%d*"):gsub("%d%d%d%d%d%d%d%d-"):gsub("%d%d%d%d%d%d%d%d%w"):',
  "   local count = 0\n   for _,c in pairs(string) do count = count + 1 end\n   return\
    \ count\nend", "  local distinct_characters = 0\n  local uppercase_count = 0\n\
    \  local lowercase_count = 0\n  for _, _, _, _ in string.gmatch(string, \"([A-Z]+)\"\
    ) do\n    uppercase_count = uppercase_count + 1\n  end\n  for _, _, _, _ in string.gmatch(string,\
    \ \"([a-z]+)\") do\n    lowercase_count = lowercase_count + 1\n  end\n  distinct_characters\
    \ = uppercase_count + lowercase_count\n  return distinct_characters\nend", " \
    \  local distinct_characters = {}\n   for i = 1, #string do\n      local c = string.sub(i,\
    \ i)\n      if not distinct_characters[c] then\n         distinct_characters[c]\
    \ = 1\n      else\n         distinct_characters[c] = distinct_characters[c] +\
    \ 1\n      end\n   end\n   return #distinct_characters\nend", "  -- Return 0 for\
    \ an empty string, otherwise the number of distinct characters\n  return string.gsub(\n\
    \    string, '(^.)(%a+)', function(c) return #c + 1 end\n  ) + string.gsub(\n\
    \    string, '(%a+)(%a+)', function(c) return #c + 1 end\n  )\nend", "    local\
    \ ret = 0\n    for _, item in pairs(string) do\n        ret = ret + 1\n    end\n\
    \    return ret\nend", "\treturn string:gsub(\".\", function(_)\n\t\treturn string:match(\"\
    %w\"):len()\n\tend)\nend", "  local distinct_characters = 0\n  for i = 1, #string\
    \ do\n    if string.sub(i, i, i) ~= \"\" then distinct_characters = distinct_characters\
    \ + 1 end\n  end\n  return distinct_characters\nend", '  local num_distinct_characters
    = 0', "  if string.len() == 0 then return 0 end\n  local char_table = { string.byte(1)\
    \ }\n  for i = 1, string.len() do\n    char_table[i] = 0\n  end", "   local chars\
    \ = {}\n   for i = 1, #string do\n      if chars[string.sub(i, i, i)] == nil then\n\
    \         chars[string.sub(i, i, i)] = 1\n      else\n         chars[string.sub(i,\
    \ i, i)] = chars[string.sub(i, i, i)] + 1\n      end\n   end\n   return #chars\n\
    end", "   if string.len(string) == 0 then\n      return 0\n   elseif string.len(string)\
    \ == 1 then\n      return 1\n   else\n      local count = {}\n      for c in string.gmatch(\
    \ string, \"([^\" .. string.char(32) .. \"]+)\") do\n         if not count[c]\
    \ then\n            count[c] = 1\n         else\n            count[c] = count[c]\
    \ + 1\n         end\n      end\n      local n = #count\n      for c in string.gmatch(\
    \ string, \"([^\" .. string.char(32) .. \"]+)\") do\n         if count[c] <= n\
    \ then\n            n = count[c]\n         end\n      end\n      return n\n  \
    \ end\nend", "  local count = 1\n  for i = 1, #string do\n    if string.sub(string,\
    \ i, i) ~= string.sub(string, i - 1, i) then\n      count = count + 1\n    end\n\
    \  end\n  return count\nend", "   -- If string is nil, return nil\n   -- If string\
    \ is an empty string, return 1\n   -- If string's length is less than 2, return\
    \ nil\n   if string == nil or string == '' or string.len() < 2 then\n      return\
    \ nil\n   end\n   -- Initialize a table to store character counts\n   local counts\
    \ = {}\n   -- Iterate through each character in the string\n   for i = 1, string.len()\
    \ do\n      -- If the character is not in the counts table, add it with a count\
    \ of 1\n      if not counts[string.sub(i, 1, 1)] then\n         counts[string.sub(i,\
    \ 1, 1)] = 1\n      else\n         -- Increment the character count if it was\
    \ already in the counts table\n         counts[string.sub(i, 1, 1)] = counts[string.sub(i,\
    \ 1, 1)] + 1\n      end\n   end\n   -- Return the number of distinct characters\
    \ in the string\n   return table.len(counts)\nend", "    local count_char = {}\n\
    \    for _, char in pairs(string.gmatch'([^%s]+)') do\n        count_char[char]\
    \ = count_char[char] or 0\n        count_char[char] = count_char[char] + 1\n \
    \   end\n    count_char = count_char\n    return table.values(count_char)\nend",
  "   local chars = {}\n   for char in string.gmatch(string, '([A-Za-z]+)') do\n \
    \     table.insert(chars, char)\n   end\n   return #chars\nend", "   if string\
    \ == nil then return 0 end\n   return (string.gsub(string, '%W', function()\n\
    \      local count = nil\n      local last_char = nil\n      repeat\n\t last_char\
    \ = last_char or string[#string]\n\t count = count or 0\n\t count = count + 1\n\
    \t string = string.sub(string, 1, #string - 1)\n      until string == last_char\n\
    \      return count\n   end))\nend", "  return string\n    or\n  assert(string.len(string)\
    \ > 0)\n    or 0\nend", "\tlocal num_distinct_char = 0\n\tlocal _character_table\
    \ = {}\n\tfor i = 1, #string do\n\t\tlocal character = string[i]\n\t\tif _character_table[character]\
    \ then\n\t\t\t_character_table[character] = _character_table[character] + 1\n\t\
    \telse\n\t\t\t_character_table[character] = 1\n\t\t\tnum_distinct_char = num_distinct_char\
    \ + 1\n\t\tend\n\tend\n\treturn num_distinct_char\nend", "  local count = 0\n\
    \  for i=1,#string do\n    if string.sub(string,i,i) ~= string.sub(string,i,i)\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "  local\
    \ characters = {}\n  for _, character in ipairs(string) do\n    table.insert(characters,\
    \ character)\n  end\n  return #characters\nend", "  local unique_characters =\
    \ {}\n  for i = 1, #string do\n    table.insert(unique_characters, string[i])\n\
    \  end\n  return #unique_characters\nend", "\tlocal characters = {}\n\tlocal count\
    \ = 1 -- the count of the number of distinct characters found", "\tlocal count\
    \ = 0\n\tfor c = string.gmatch(\"%[%a]\", function(c) count = count + 1 end) do\n\
    \t\treturn count\n\tend\nend", "  local count = nil\n  \n  while true do\n   \
    \ local _, res = string.gsub('(^[^' .. string.upper(string.letters) .. ']+)',\
    \ '')\n    count = count or string.len(res)\n    \n    if not res then\n     \
    \ return count\n    end\n    \n    string = string.gsub(string, '(^[' .. string.upper(string.letters)\
    \ .. '])+', '')\n  end\nend", "  local n = 0\n  for _,c in string.gmatch('^[%a\xE1\
    \xE4\xE2\xE3\xC3\xE2\xE9\xE8\xEB\xED\xEE\xEF\xEC\xEE\xEC\xEC\xEE\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\
    \xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC\xEC", "  if string == nil then return 0 end\n\
    \  local count = {}\n  for i = 1, #string do\n    local ch = string.sub(i, i,\
    \ i)\n    if count[ch] == nil then\n      count[ch] = 0\n    end\n    count[ch]\
    \ = count[ch] + 1\n  end\n  return #count\nend", "\tlocal seen = {}\n\tfor _,\
    \ character in ipairs(string) do\n\t\tif not seen[character] then\n\t\t\tseen[character]\
    \ = true\n\t\t\tcount = count + 1\n\t\tend\n\tend\n\treturn count\nend", "   \
    \ local count = 0\n    for i=1,string-1 do\n        if string.sub(string,i,i)\
    \ ~= string.sub(string,i,i) then count = count + 1 end\n    end\n    return count\n\
    end", "\tlocal counts = {}", "  return string.gsub(string.lower(string), '[^a-zA-Z0-9]+',\
    \ '') -- \"[^a-zA-Z0-9]+\" to remove any non-alphanumeric characters\nend", " \
    \ return #string.gsub(string.lower(string), '[%Aa]', '') -- Replace all the letters\
    \ with their lowercase counterparts.\nend", "  if string == nil then return 0\
    \ end\n  local ret = 0\n  for i=1,#string do\n    local char = string.sub( string,\
    \ i, i )\n    ret = ret + #char\n  end\n  return ret\nend", "  local distinct_chars\
    \ = {}\n  for _, character in string.gmatch(\"[%w]\") do\n    table.insert(distinct_chars,\
    \ character)\n  end\n  return #distinct_chars\nend", "    return string:gsub('.',\
    \ function(c) c:lower() end)\nend", "\tlocal count = {}\n\tstring.gsub(string,\
    \ \"([^\" .. string.gsub(string.gsub(string, \"%S\", string), \"[^%S]*\", \"\"\
    ) .. \"]+)\", function(x)\n\t\tlocal i, n = x:find(string.upper)\n\t\tif i > 0\
    \ then\n\t\t\tcount[i] = count[i] or 1\n\t\t\tcount[i] = count[i] + 1\n\t\telse\n\
    \t\t\tcount[i] = 1\n\t\tend\n\tend)\n\treturn table.concat(count)\nend", "  local\
    \ characters = {}\n  for _, c in string.gmatch(regex_char_class, 'g') do\n   \
    \ table.insert(characters, c:lower())\n  end\n  local distinct_char_count = #characters\n\
    \  for _, c in string.gmatch(regex_char_class, 'g') do\n    distinct_char_count\
    \ = distinct_char_count - #string.sub(characters, 1, c) -- subtracts the number\
    \ of characters in this set from the total number of characters in the set (which\
    \ gives us a measure of case).\n  end\n  return distinct_char_count\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nIt's not the answer to the question. Also, I don't\
    \ think it is correct in some cases.\n<|/ c |>\n<| c |>\nI agree with you on this\
    \ one, but the OP accepted the answer, so perhaps they figured out how to adapt\
    \ it to their needs.\n<|/ c |>\n<| a dscore=0 |>\nA bit late to the party, but\
    \ I thought I'd offer a simpler solution if you happen to only have to worry about\
    \ letters. \n<code>", "  local count = 1\n  for i=1,#string do -- Iterate over\
    \ the string character by character\n    count = count + (string.sub(string,i,i)):lower()\
    \ == string.sub(string,i,i) or 1 -- Check if the current character is the same\
    \ as the previous one. If so, then we're counting 1 more character. Otherwise,\
    \ we're counting 1 less character\n  end\n  return count\nend", "  local distinct_chars\
    \ = {}\n  for k, v in pairs(string) do distinct_chars[v] = true end\n  return\
    \ #distinct_chars\nend", "  if string == nil then return nil end\n  local n =\
    \ 0\n  local c\n  for c in string.gmatch(string, \"%c\") do n = n+1 end\n  return\
    \ n\nend", "  local result = {}\n  local i = 1\n  while true do\n    if string.sub(i,\
    \ i+1) ~= string.sub(i, i+1) then\n      if result[string.sub(i, i-1)] == nil\
    \ then\n        result[string.sub(i, i-1)] = 1\n      else\n        result[string.sub(i,\
    \ i-1)] = result[string.sub(i, i-1)] + 1\n      end\n    end\n    i = i + 1\n\
    \    if i == string.len(string) then\n      break\n    end\n  end\n  return #result\n\
    end", "    local chars = {}\n    for _, char in string.gmatch(\"[%a\xE0\xE1\xE2\
    \xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\
    \xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF%A\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\
    \xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\
    %C\xC7\xD1\xC6\xD8%D\xD0\xCC\xCE\xCF%E\xD8\xD2\xD9%F%G%H%I%J%K%L%M%N%O%P%Q%R%S%T%U%V%W%X%Y%Z%_%:%,.#]\"\
    ) do\n        table.insert(chars, char)\n    end", "  local count = 0\n  for _,\
    \ character in pairs(string) do\n    count = count + 1\n  end \n  return count\n\
    end\n</cell>\n<code language=julia-1.3>\ncount_distinct_characters('abc')\n</cell>\n\
    <text>\n2.3 Word count\nThe second step is to make a word count function, which\
    \ takes in a string, splits it into its separate words, and then counts the number\
    \ of times each word appears.", "  local distinct_chars = {}\n  for i = 1, #string\
    \ do\n    local char = string[i]\n    local count = distinct_chars[char] or 0\n\
    \    distinct_chars[char] = count + 1\n  end\n  return #distinct_chars\nend",
  "  return string.gsub(string, \"[^\" .. string.char(string.ascii_lowercase) .. \"\
    ]+\", \"\"):gsub(\"%S+\", \"\")\nend", "  local count = {}\n  for i = 1, #string\
    \ do\n    count[string.sub(i, i)] = count[string.sub(i, i)] or 0\n    count[string.sub(i,\
    \ i)] = count[string.sub(i, i)] + 1\n  end\n  return #count\nend", "  local characters\
    \ = {}\n  local count = 1", "  return #string:gsub(\"%a\", function()\n      local\
    \ chars = {string.byte(string.sub(string,1,1)), string.byte(string.sub(string,2,2)),\
    \ string.byte(string.sub(string,3,3))}\n      if chars[1] and chars[2] and chars[3]\
    \ then\n        return chars[1] + chars[2] + chars[3]\n      elseif chars[1] then\n\
    \        return chars[1]\n      elseif chars[2] then\n        return chars[2]\n\
    \      elseif chars[3] then\n        return chars[3]\n      end\n    end)\nend",
  "    local distinct_characters = 0\n    for _, character in string.gmatch(\"(.)\"\
    ) do\n        distinct_characters = distinct_characters + 1\n    end\n    return\
    \ distinct_characters\nend", "    -- This code assumes that the lowercase version\
    \ of every word in the string is the same as the lowercase\n    -- version of\
    \ that word in the original string. If not, the program will crash.\n    local\
    \ distinct_char_count = 0\n    local string_length = string.len(string)\n    for\
    \ i = 1, string_length do\n        local char = string.sub(i, i, string_length)\n\
    \        local lowercase = string.lower(char)\n        if distinct_char_count\
    \ == 0 or distinct ~= lowercase then\n            distinct_char_count = distinct_char_count\
    \ + 1\n        end\n    end\n    return distinct_char_count\nend", "\t-- Note:\
    \ This can be implemented in a more elegant way by using a dictionary\n\t--  \
    \     and iterating over all characters. However, this would require more\n\t\
    --       refactoring.\n\tlocal distinct_characters = 0\n\tlocal characters = string.gsub(string,\
    \ '%w', '') -- Remove all special characters\n\tfor _, character in pairs(characters)\
    \ do\n\t\tdistinct_characters = distinct_characters + 1\n\tend\n\treturn distinct_characters\n\
    end", "  -- Count the number of distinct characters in the given string.\n  --\
    \ This counts the number of case-insensitive duplicate characters in the string.\n\
    \  --\n  -- >>> count_distinct_characters('aaabbb')\n  -- 4\n  --\n  -- >>> count_distinct_characters('xyzXYZ')\n\
    \  -- 3\n  --\n  -- >>> count_distinct_characters('Jerry')\n  -- 4\n  --\n  --\
    \ >>> count_distinct_characters('Z')\n  -- 1\n  --\n  -- >>> count_distinct_characters('AA')\n\
    \  -- 1\n  --\n  -- >>> count_distinct_characters('AAA')\n  -- 1\n  --\n  -- >>>\
    \ count_distinct_characters('ZZZZ')\n  -- 1\n  --\n  -- >>> count_distinct_characters('Strawberry')\n\
    \  -- 1\n  --\n  -- >>> count_distinct_characters('Z')\n  -- 1\n  --\n  -- >>>\
    \ count_distinct_characters('AB')\n  -- 2\n  --\n  -- >>> count_distinct_characters('a')\n\
    \  -- 1\n  --\n  -- >>> count_distinct_characters('')\n  -- 0\n  --\n  -- >>>\
    \ count_distinct_characters('')\n  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n\
    \  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n  -- 0\n  --\n  -- >>>\
    \ count_distinct_characters(nil)\n  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n\
    \  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n  -- 0\n  --\n  -- >>>\
    \ count_distinct_characters(nil)\n  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n\
    \  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n  -- 0\n  --\n  -- >>>\
    \ count_distinct_characters(nil)\n  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n\
    \  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n  -- 0\n  --\n  -- >>>\
    \ count_distinct_characters(nil)\n  -- 0\n  --\n  -- >>> count_distinct_characters(nil)\n\
    \  -- 0\n  --\n  -- >>> count_distinct_characters(' ABC')\n  -- 1\n  --\n  --\
    \ >>> count_distinct_characters('ABC')\n  -- 2\n  --\n  -- >>> ", "\tlocal total\
    \ = 0\n\tlocal currentChar = string.sub(1,1)\n\tlocal prevChar = string.sub(1,1)\n\
    \tfor i = 1, string.len() do\n\t\tif currentChar ~= prevChar then\n\t\t\ttotal\
    \ = total + 1\n\t\tend\n\t\tcurrentChar = string.sub(i,1)\n\t\tprevChar = currentChar\n\
    \tend\n\treturn total\nend", "  local count = 0\n  for _ in string:gmatch(\"[^%s]+\"\
    ) do count = count + 1 end\n  return count\nend", "  local count = 0\n  for _,\
    \ character in pairs(string) do\n    count = count + 1\n  end\n  return count\n\
    end", "  return #string ~= 0 and (string.lower:gsub(\".\", function (char)\n \
    \   return string.lower:sub(string.lower:find(char, 1, true) + 1, string.lower:find(char,\
    \ string.lower:len(char), true) - string.lower:find(char, string.lower:len(char),\
    \ true) - 1)\n  end)^0) or 1\nend", "  if string == nil then\n    return 0\n \
    \ end\n  local count = 0\n  local uppercase\n  local lowercase\n  local capital\n\
    \  local lower\n  local i\n  for i = 1, #string do\n    uppercase = string.upper(string,\
    \ i)\n    lowercase = string.lower(string, i)\n    capital  = string.sub(string,\
    \ i, i)\n    lower    = string.sub(string, i, i)\n    if uppercase ~= nil then\n\
    \      if uppercase == lowercase and uppercase ~= capital  and lowercase ~= upper\
    \ then\n        count = count + 1\n      end\n    end\n  end\n  return count\n\
    end", "    local count = 0\n    for character in string.gmatch('([A-Z]+)') do\n\
    \        if string.match(string, character) == nil then\n            count = count\
    \ + 1\n        end\n    end\n    return count\nend", "  if string.len == 0 then\n\
    \    return 0\n  end\n  local counter = 1\n  local new_string\n  local last_char\n\
    \  for char in string do\n    if not new_string then\n      new_string = char\n\
    \      last_char = char\n    else\n      if last_char == char then\n        counter\
    \ = counter + 1\n      else\n        new_string = new_string .. last_char\n  \
    \      last_char = char\n        counter = 1\n      end\n    end\n  end\n  return\
    \ counter\nend", "  local count = {}\n  for _, c in pairs(string) do\n    count[c]\
    \ = count[c] + 1 if not count[c] or count[c] < string.len(c) then\n      count[c]\
    \ = 1\n    end\n  end\n  return table.concat(count)\nend", "  -- We use ascii\
    \ table for fast lookup\n  local char_count = 0\n  for _, v in ipairs(string.gmatch'([%a])')\
    \ do\n    char_count = char_count + 1\n  end\n  return char_count\nend", "  local\
    \ count = 0\n  for _, char in string.gmatch(string, '.') do\n    count = count\
    \ + 1\n  end\n  return count\nend", "  local characters = {}\n  for _, character\
    \ in ipairs(string) do\n    table.insert(characters, character)\n  end\n  local\
    \ character_count = #characters\n  for _, character in ipairs(string) do\n   \
    \ character_count = character_count - 1\n    if character_count == 0 then\n  \
    \    return character_count - 1\n    end\n  end\n  return character_count\nend",
  "\tlocal number_of_unique_characters = 0\n\tfor _, char in string.gmatch(string,\
    \ '%a+') do\n\t\tnumber_of_unique_characters = number_of_unique_characters + 1\n\
    \tend\n\treturn number_of_unique_characters\nend", "  local unique = {}\n  for\
    \ _, char in string:gmatch'(.-)' do unique[tolower(char)] = true end\n  local\
    \ count = 0\n  for char in unique:keys() do count = count + 1 end\n  return count\n\
    end", "    if string.len(string) == 0 then return 0 end\n    local chars = {}\n\
    \    local count = 0\n    for i = 1, string.len(string) do\n        char = string.sub(\
    \ string, i, i)\n        if not chars[char] then\n            count = count +\
    \ 1\n            table.insert( chars, char)\n        end\n    end\n    return\
    \ count\nend", "  local characters = {}\n  local count = 1", "    local characters\
    \ = {}\n    local char_map = {}\n    \n    for _, c in ipairs(string) do\n   \
    \     table.insert(characters, c)\n        char_map[c] = true\n    end\n    \n\
    \    for _, c in ipairs(characters) do\n        char_map[c] = nil\n    end\n \
    \   \n    return #characters\nend", "  -- Use a lookup table to keep track of\
    \ character frequency\n  local counts = {}", "   if string == nil then\n     \
    \ string = \"\"\n   end\n   local characters = string.gsub(string.gsub(string,\
    \ '[%a~%A~%w~%W~%p~%P~%_~%-~%-~%w~%W~%p~%P~%_~%-~%-~%p~%P~%_~%-~%-~%]', ''), '[~]',\
    \ '') -- get rid of special chars\n   local lengths = {}\n   for i = 1, #characters\
    \ do\n      local length = #characters[i]\n      if lengths[length] == nil then\n\
    \         lengths[length] = 1\n      else\n         lengths[length] = lengths[length]\
    \ + 1\n      end\n   end\n   return #lengths\nend", "    local count = 0\n   \
    \ for i = 1, #string do\n        if string.sub(string, i, i) ~= string.sub(string,\
    \ i - 1, i) then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "   local uniques = {}\n   for _, v in ipairs(string) do\n    \
    \  if uniques[v] == nil then\n         uniques[v] = 1\n      else\n         uniques[v]\
    \ = uniques[v] + 1\n      end\n   end\n   return #uniques\nend", "  local result\
    \ = 0\n  for i = 1, #string do\n    local char = string.sub(i, i)\n    if char\
    \ == 'a' or char == 'e' or char == 'i' or char == 'o' or char == 'u' then\n  \
    \    result = result + 1\n    end\n  end\n  return result\nend", "  -- Iterate\
    \ over every character in the string\n  local count = 1\n  for _,character in\
    \ string.gmatch(\"(.)(.)\") do\n    -- If the character matches the previous character,\
    \ increment the count\n    if string ~= character and string.gsub(string, '^'\
    \ .. character .. '$') ~= '^' .. character .. '$' then\n      count = count +\
    \ 1\n    end\n  end\n  return count\nend", "  if string.sub or string.gsub or\
    \ string.match then\n    return #string.gsub(string.lower(string), '[%a]+', '')\n\
    \  else\n    return #string\n  end\nend", "    local c = 0\n    for c = 1, #string\
    \ do\n        if string.sub(string,c,c) == string.sub(string,c,c) then\n     \
    \       c = c + 1;\n        end\n    end\n    return c\nend", "  if string ==\
    \ nil then\n    return 0\n  end\n  local count = 0\n  local prevChar = nil\n \
    \ for i=1, #string do\n    if string.sub(i, i) ~= prevChar then\n      count =\
    \ count + 1\n    end\n    prevChar = string.sub(i, i)\n  end\n  return count\n\
    end", "  if type(string) ~= 'string' then return 0 end\n  local n = 1\n  for c\
    \ in string.gmatch(string, \"%W\") do\n    n = n + 1 -- Count each distinct character\
    \ without considering case\n  end\n  return n\nend", "  local result = 1\n  for\
    \ _ in string.gmatch(\"%a\", '%W') do\n    result = result + 1\n  end\n  return\
    \ result\nend", "  return #set(string) - #set(key:lower(string))\nend", "    local\
    \ length = {}\n    for i=1,#string do\n        if string.sub(i, 1, i)~=string.sub(i,\
    \ #string) then\n            length[string.sub(i, 1, i)] = 0\n        else\n \
    \           length[string.sub(i, 1, i)]+=1\n        end\n    end\n    return #length\n\
    end", "  local seen = {}\n  local distinct = 0\n  for _, char in pairs(string)\
    \ do\n    if seen[char] ~= nil then\n      seen[char] = nil\n      distinct +=\
    \ 1\n    end\n    seen[char] = true\n  end\n  return distinct\nend", "    local\
    \ count = 0\n    for _, char in pairs(string) do\n        if string.match(string.lower(char),\
    \ '[%z]') then count = count + 1 end\n    end\n    return count\nend", "    if\
    \ string == nil then return 0 end\n    local characters = {}\n    local result\
    \ = 0\n    for i = 1, string.n do\n        local char = string.sub(i, i)\n   \
    \     if not characters[char] then\n            characters[char] = 1\n       \
    \ else\n            characters[char] = characters[char] + 1\n        end\n   \
    \ end\n    for char, count in pairs(characters) do\n        if count > 1 then\n\
    \            result = result + 1\n        end\n    end\n    return result\nend",
  "\tlocal hash = {}\n\tfor _, char in string.gmatch(\"[%a]+\") do\n\t\thash[char]\
    \ = hash[char] + 1 -- Increment the counter for each character in the string\n\
    \tend\n\treturn #hash\nend", "\t-- Count distinct characters in a string\n\t--\
    \ Example\n\t-- >>> count_distinct_characters('abracadaba')\n\t-- 4\n\t-- >>>\
    \ count_distinct_characters('abracadaba')\n\t-- 5\n\t-- >>> count_distinct_characters('abracadaba')\n\
    \t-- 7\n\t-- >>> count_distinct_characters('abracadaba')\n\t-- 8", "    if not\
    \ string then return 0 end\n    local char_mapping = {}\n    local count = 1\n\
    \    for character in string.gmatch(\"[%w]\") do\n        table.insert(char_mapping,\
    \ character)\n        count = count + 1\n    end\n    return count\nend", "\t\
    local n = 0\n\tstring.gsub(string, \"[%w]\", function(c)\n\t\tn = n + 1\n\tend)\n\
    \treturn n\nend", '  local characters = {}', "  return #string + 1 -- This is\
    \ necessary for cases like \"Jerry\" where J is counted as a distinct character\n\
    end", "\tlocal count = 0\n\tlocal lowercase_letters = {}", "\treturn string.gsub(string.gsub(string,\
    \ '(.)', '%1'), '.', '~0')\nend", "    local count = 0\n    for i = 1, #string\
    \ do\n        if string.sub(i, i, i) ~= string.sub(i, i) then count = count +\
    \ 1 end\n    end\n    return count\nend\n</cell>\n<text>\nExercise 3\nWhat is\
    \ the sum of the digits in each number from $0$ to $10$?", "  local distinct =\
    \ 0\n  for _ in string.gmatch(string, '(.)') do\n    distinct = distinct + 1\n\
    \  end\n  return distinct\nend", "    local count = { }\n    for c in string.gmatch(string,\
    \ \"%a\") do\n        count[c] = count[c] + 1 or 1\n    end\n    return #count\n\
    end", "  if string.count then\n    return string.count(string.upper, string) +\
    \ string.count(string.lower, string)\n  else\n    return string.upper:len(string)\
    \ + string.lower:len(string)\n  end\nend", "    local unique, count = {}, {}\n\
    \    for _, _, _, character in string.gmatch('^(.)(.)') do\n        if unique[character]\
    \ ~= nil then\n            unique[character] = unique[character] + 1\n       \
    \ else\n            unique[character] = 1\n        end\n    end\n    for _, character\
    \ in pairs(unique) do\n        count[character] = count[character] + 1\n    end\n\
    \    return count\nend", "    local distinct = 0\n    for i=1,string.leng do\n\
    \        if string.sub(i,i,i) ~= string.sub(i,i,i) then -- not case-sensitive\n\
    \            distinct  = distinct + 1\n        end\n    end\n    return distinct\n\
    end", "  if string == nil then return 0 end\n  local count = 0\n  for c in string.gmatch(\"\
    [^%w]\") do\n    if string.find(string, \"[%w]\", string.len(c), true) ~= nil\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "    if\
    \ not string then return 0 end\n    local count = 0\n    for i = 1, #string do\n\
    \        if string.sub(i, i, i) ~= nil then\n            count = count + 1\n \
    \       end\n    end\n    return count\nend", "  return string.gsub(string, '[^%s]+',\
    \ 1, string, 'jo')\nend", "   -- Return an iterator over the characters in the\
    \ string that have different case from all other characters.\n   local chars =\
    \ {}\n   for _,c in ipairs(string) do\n      if chars[c] then\n         chars[c]\
    \ = chars[c] + 1\n      else\n         chars[c] = 1\n      end\n   end\n   return\
    \ table.concat(chars)\nend", "    return #set(string):gsub(\"[%A]\", \"\"):gsub(\"\
    [%z]\", \"\"):gsub(\"[^%a%z]\", \"\"):gsub(\"[^%A%Z]\", \"\"):gsub(\"[^%z%A]\"\
    , \"\")\nend", "  local result = 1\n  for i = 1, #string do\n    local char =\
    \ string[i]\n    local lower = char:lower()\n    local upper = char:upper()\n\
    \    if lower and lower ~= upper then\n      result = result + 1\n    else\n \
    \     result = result + 1\n    end\n  end\n  return result\nend", "  local characters\
    \ = {}\n  for i = 1, string.len do\n    table.insert(characters, string.sub(i,\
    \ 1, i))\n  end", "\tlocal hash = {}\n\tfor _,c in ipairs(string) do\n\t\thash[c]\
    \ = hash[c] + 1 or 1\n\tend\n\treturn #hash\nend", "  if string.lower(string)\
    \ ~= string then\n    local table = {}\n    for i = string.len(string), 0, -1\
    \ do\n      table[i] = string[i]\n    end\n    table.sort(table)\n    local count\
    \ = 0\n    for i = 1, table.len() do\n      if i ~= 1 then\n        count = count\
    \ + 1\n      end\n    end\n    return count\n  end\n  return string.len(string)\n\
    end", "  -- This works by first counting the number of distinct characters, then\
    \ adding up all the characters\n  -- that follow each distinct character.\n  --\
    \ This algorithm will find all the characters (regardless of the case) that follow\
    \ each distinct character.", "\tlocal c = 0\n\tfor i = 1, #string do c = c + (string.sub(string,i,i)\
    \ == string.sub(string,i,i) end) end\n\treturn c\nend", "  local count = 0\n \
    \ for c in string.gmatch( string, \"%a\") do\n    count = count + 1\n  end\n \
    \ return count\nend", "    local characters = {}\n    for character in string.gmatch(string,\
    \ '%c') do\n        table.insert(characters, character)\n    end\n    return table.getn(characters)\n\
    end", "   -- First, find the length of the string:\n   local len = 0\n   for _,\
    \ char in string:gmatch('%z') do len = len + 1 end", "    if not string then\n\
    \        return 0\n    end", "  -- We start by counting the characters in the\
    \ string without regard to case\n  local count = 1\n  for i=1, #string do\n  \
    \  if string.sub(i, i) ~= string.sub(string[i], string[i]) then\n      count =\
    \ count + 1\n    end\n  end\n  return count\nend", "  return #({}) - count_characters(string)\n\
    end", "    return #string.gsub(string.lower(string), '[%z\\1-\\127]', '')\nend",
  "\tlocal i = 0\n\tlocal count = 0\n\tfor c in string.gmatch(string, \"([^\\n]+)\"\
    ) do\n\t\tcount = count + 1\n\t\ti = i + 1\n\t\tif i % 26 == 0 then\n\t\t\tcount\
    \ = count + 1\n\t\tend\n\tend\n\treturn count\nend", "  -- Get the number of distinct\
    \ characters in the string\n  local count = 0\n  for _, character in string.gmatch('([A-Z]+)')\
    \ do\n    count = count + 1\n  end", "  if string.len > 0 then\n    local alphabet\
    \ = {}\n    for letter in string.gmatch '[%a]:([%a])+', 'match' do\n      alphabet[letter]\
    \ = true\n    end\n    return #alphabet\n  end\n  return 0\nend", "    if string\
    \ == nil then\n        return 0\n    end\n    if string.bytes == nil then\n  \
    \      return #string\n    end\n    local count = 0\n    local letter\n    for\
    \ letter, index in string.gmatch(string, \"(%a+)\") do\n        if letter ~= 'A'\
    \ and letter ~= 'a' and letter ~= '0' then\n            count = count + 1\n  \
    \      end\n    end\n    return count\nend", "  local output = {}\n  for i, c\
    \ in ipairs(string) do\n    table.insert(output, tostring(c))\n  end\n  return\
    \ #output\nend", "  return string.gsub(string.gsub(string, '([^A-Za-z])', ''),\
    \ '([A-Za-z])', function() return #1 end)\nend", "  local counts = {}\n  for char\
    \ in string:gmatch'[%s]'\n    do\n      counts[#counts+1] = #char\n    done\n\
    \  return #counts\nend", "    local counts = {}\n    for i = 1, string.len do\n\
    \        local char = string[i]\n        local count = counts[char]\n        counts[char]\
    \ = count or 1\n    end\n    return #counts\nend", "  local result = 0\n  for\
    \ _, ch in ipairs(string:gsub(\"%l\", \"\")) - \"_\" do\n    local lowercase =\
    \ ch:lower()\n    local uppercase = ch:upper()\n    if lowercase == uppercase\
    \ then\n      result = result + 1\n    end\n  end\n  return result\nend", "  \
    \  return string\n        :gsub(\"([^\" .. string.char(65) .. \"]+)\", function\
    \ (_) return string.upper(_):byte() end)\n        :gsub(\"([^\" .. string.char(97)\
    \ .. \"]+)\", function (_) return string.lower(_):byte() end)\n        :gsub(\"\
    ^%W\", function (_) return _:byte() end)\n        :gsub(\"%W\", function (_) return\
    \ string.lower(_):byte() end)\n        :byte()\nend", "    local count = 0\n \
    \   for _, chars in pairs(string:gsub(\"%W\", \"\")) do\n        count = count\
    \ + 1\n    end\n    return count\nend", "  return #({})+#string.gsub(string.lower(string),\
    \ '%a'):gsub('(.)%W*$',string[#string]+'\\1')\nend", "  local total = 0\n  for\
    \ char in string.gmatch (string, '%a') do\n    total = total + 1\n  end\n  return\
    \ total\nend", "  local distinct = 0\n  for index, letter in string.gmatch(\"\
    ^%a\") do\n    local character = string.char(letter)\n    if character ~= letter\
    \ then\n      distinct = distinct + 1\n    end\n  end\n  return distinct\nend",
  "  local count = 1\n  for i = 1, #string do\n    if string[i]~=string[i+1] then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "    local chars\
    \ = {}\n    for c in string.gmatch(string, \".\") do\n        if chars[c] == nil\
    \ then\n            chars[c] = 0\n        end\n        chars[c] = chars[c] + 1\n\
    \    end\n    return #chars\nend", "  -- We assume that input string is lower\
    \ case\n  -- We also assume that input string is always composed of lower case\
    \ alphabets\n  -- (ASCII letters only)\n  if string:len() < 1 then\n    return\
    \ 0\n  end\n  local n = 0\n  for i = 1, string:len() do\n    n = n + count_distinct_characters_helper(string,\
    \ i)\n  end\n  return n\nend", "   local characters = {}\n   for _,v in ipairs(string:gsub(\"\
    %w\",\"%w\"):gsub(\"%d\",\"%d\"):gsub(\"%f\",\"%f\")):gsub(\"[<>]\",\"%\"):gsub(\"\
    %w\",\"%w\"):gsub(\"%d\",\"%d\"):gsub(\"%f\",\"%f\") do\n      table.insert(characters,v)\n\
    \   end\n   return table.sort(characters)\nend", "\tlocal distinct = 0\n\tfor\
    \ _, char in string.gmatch('[^' .. string.upper(string.char(#string.char)) ..\
    \ ']+') do\n\t\tdistinct = distinct + 1\n\tend\n\treturn distinct\nend", "   \
    \ return count_distinct_characters_helper(string, \"\", \"\")\nend", "  return\
    \ #string > 0 and (#string - 1) or 0\nend", "\t-- The string must only consist\
    \ of uppercase or lowercase alphabets\n\tassert(string\n\t\t:gsub(\"%a\", function()\n\
    \t\t\treturn '%A'\n\t\tend)\n\t\t:gsub(\"%A\", function()\n\t\t\treturn '%a'\n\
    \t\tend)\n\t\t:gsub(\"%A\", function()\n\t\t\treturn '%A'\n\t\tend)\n\t\t:gsub(\"\
    %c\", function()\n\t\t\treturn '%C'\n\t\tend)\n\t\t:gsub(\"%C\", function()\n\t\
    \t\treturn '%c'\n\t\tend)\n\t\t:gsub(\"%d\", function()\n\t\t\treturn '%D'\n\t\
    \tend)\n\t\t:gsub(\"%D\", function()\n\t\t\treturn '%d'\n\t\tend)\n\t\t:gsub(\"\
    %e\", function()\n\t\t\treturn '%E'\n\t\tend)\n\t\t:gsub(\"%E\", function()\n\t\
    \t\treturn '%e'\n\t\tend)\n\t\t:gsub(\"%f\", function()\n\t\t\treturn '%F'\n\t\
    \tend)\n\t\t:gsub(\"%F\", function()\n\t\t\treturn '%f'\n\t\tend)\n\t\t:gsub(\"\
    %g\", function()\n\t\t\treturn '%G'\n\t\tend)\n\t\t:gsub(\"%G\", function()\n\t\
    \t\treturn '%g'\n\t\tend)\n\t\t:gsub(\"%h\", function()\n\t\t\treturn '%H'\n\t\
    \tend)\n\t\t:gsub(\"%H\", function()\n\t\t\treturn '%h'\n\t\tend)\n\t\t:gsub(\"\
    %i\", function()\n\t\t\treturn '%I'\n\t\tend)\n\t\t:gsub(\"%I\", function()\n\t\
    \t\treturn '%i'\n\t\tend)\n\t\t:gsub(\"%j\", function()\n\t\t\treturn '\\a'\n\t\
    \tend)\n\t\t:gsub(\"%j\", function()\n\t\t\treturn '\\a'\n\t\tend)\n\t\t:gsub(\"\
    %j\", function()\n\t\t\treturn '\\a'\n\t\tend)\n\t\t:gsub(\"%j\", function()\n\
    \t\t\treturn '\\a'\n\t\tend)\n\t\t:gsub(\"%j\", function()\n\t\t\treturn '\\a'\n\
    \t\tend)\n\t\t:gsub(\"%k\", function()\n\t\t\treturn '%K'\n\t\tend)\n\t\t:gsub(\"\
    %K\", function()\n\t\t\treturn '%k'\n\t\tend)\n\t\t:gsub(\"%l\", function()\n\t\
    \t\treturn '%L'\n\t\tend)\n\t\t:gsub(\"%L\", function()\n\t\t\treturn '%l'\n\t\
    \tend)\n\t\t:gsub(\"%m\", function()\n\t\t\treturn '%M'\n\t\tend)\n\t\t:gsub(\"\
    %M\", function()\n\t\t\treturn '%m'\n\t\tend)\n\t\t:", "    local count = 0\n\
    \    local has_upper_case = false\n    local has_lower_case = false", "\tlocal\
    \ distinct_count = 0\n\tfor _, c in string.gmatch('([A-Za-z0-9]+)') do\n\t\tdistinct_count\
    \ = distinct_count + string.len(c) - string.len(tolower(c))\n\tend\n\treturn distinct_count\n\
    end", "    return #set(string:gsub(\"%c\",function()\n        local ln = string.len(string.sub(string,\
    \ 1, string.len(string)))\n        return string.char(tonumber(string.sub(string,\
    \ 1, ln)))\n    ))\nend", "    local characters = {}\n    for i=1,string.len do\n\
    \        table.insert(characters, string.sub(string,i,i))\n    end\n    return\
    \ #characters\nend", "  return math.ceil(#string / 2)\nend", '  local count =
    0', "\tlocal count = 0\n\tfor i = 1, #string do\n\t\tcount = count + 1\n\t\tif\
    \ string.sub(i, 1, i) ~= string.sub(i, 1, i) then\n\t\t\treturn count\n\t\tend\n\
    \tend\n\treturn count\nend", "   local distinct_chars = {}\n   for _ = 1, string.len()\
    \ do\n      if distinct_chars[string.sub(string,1,1)] then\n         distinct_chars[string.sub(string,1,1)]\
    \ = distinct_chars[string.sub(string,1,1)] + 1\n      else\n         distinct_chars[string.sub(string,1,1)]\
    \ = 1\n      end\n   end\n   return table.concat(distinct_chars, \"\")\nend",
  "    local chars = {}\n    for c in string.gmatch(string, \".\") do\n        if\
    \ chars[c] == nil then\n            chars[c] = 1 -- start counting from 1, not\
    \ 0\n        else\n            chars[c] = chars[c] + 1 -- count how many times\
    \ this character was seen\n        end\n    end", "  if string == nil then return\
    \ 0 end\n  local characters = {}\n  for character in string.gmatch'([^%s]+)' do\n\
    \    table.insert(characters, character)\n  end\n  local uniques = {}\n  table.sort(characters)\n\
    \  local character_index = 1\n  for _, character in ipairs(characters) do\n  \
    \  if character_index == 1 then\n      table.insert(uniques, character)\n    else\n\
    \      if uniques[character_index - 1] == character then\n        uniques[character_index]\
    \ = nil\n      end\n    end\n    character_index = character_index + 1\n  end\n\
    \  return table.concat(uniques)\nend", "  if string == nil then return 0 end\n\
    \  local counts = { }\n  for i = 1, #string do\n    local character = string.sub(i,\
    \ i)\n    if counts[character] == nil then counts[character] = 1 else counts[character]\
    \ = counts[character] + 1 end\n  end\n  return #counts\nend", "\tlocal chars =\
    \ {}\n\tfor i, v in ipairs(string) do\n\t\tif chars[v] == nil then\n\t\t\tchars[v]\
    \ = true\n\t\t\tchars[string.lower(v)] = true\n\t\t\tchars[string.upper(v)] =\
    \ true\n\t\tend\n\tend\n\tlocal count = 0\n\tfor _, char in pairs(chars) do\n\t\
    \tcount = count + 1\n\tend\n\treturn count\nend", "    local count = 1\n    for\
    \ i = 1, #string do\n        count = count + 1\n        if string:sub(i, i):upper()\
    \ == string:sub(i, i):lower() then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "    local characters = {}\n    for i = 1, #string\
    \ do\n        table.insert(characters, string.sub(i, i))\n    end\n    local result\
    \ = 0\n    for _, character in ipairs(characters) do\n        if characters[character]\
    \ ~= nil then\n            character = tolower(character)\n            result\
    \ = result + 1\n        end\n    end\n    return result\nend", "  -- The original\
    \ implementation was written by Wasif Hasan (removed@example.com)\n  local counts\
    \ = {}\n  for i = 1, #string do\n    local letter = string.sub(i, i)\n    local\
    \ value = string.sub(i, i + 1)\n    if counts[letter] == nil then\n      counts[letter]\
    \ = 0\n    end\n    counts[letter] = counts[letter] + 1\n  end\n  local result\
    \ = 0\n  for letter, count in pairs(counts) do\n    result = result + count *\
    \ letter\n  end\n  return result\nend", "  local values = {}\n  for _, c in ipairs(string)\
    \ do\n    if values[c] == nil then\n      values[c] = 0\n    end\n    values[c]\
    \ = values[c] + 1\n  end\n  return #values\nend", "    local distinct_characters\
    \ = {}\n    for i = 1, #string do\n        local char = string.sub(i, i)\n   \
    \     -- TODO: Add support for other languages\n        if char then\n       \
    \     if char == '~' then\n                -- TODO: Support unicode characters\n\
    \                -- local count = string.len(string.gsub(string.sub(string, '%',\
    \ '%%'), '+'))\n                local count = string.len(string.gsub(string.sub(string,\
    \ '%', '%%'), '+', '?'))\n                distinct_characters[char] = count\n\
    \            else\n                distinct_characters[char] = string.len(char)\n\
    \            end\n        end\n    end\n    table.sort(distinct_characters)\n\
    \    return #distinct_characters\nend", "    local counts = {}\n    for _, c in\
    \ string.gmatch(string, \"([^ ]+)\") do\n        counts[c] = counts[c] + 1 or\
    \ 1\n    end\n    return #counts\nend", "    local counts = {}\n    for character\
    \ in string.gmatch('^%l') do\n        counts[character] = counts[character] +\
    \ 1 or 1\n    end\n    return #counts\nend", "    local unique = {}\n    local\
    \ count = 0\n    for _,s in ipairs(string) do\n        if unique[s] ~= nil then\n\
    \            count = count + 1\n        else\n            unique[s] = true\n \
    \       end\n    end\n    return count\nend", "  return #string - count_distinct_characters(select_lower(string))\
    \ -- count distinct characters, minus lower case letters\nend", "  return count_distinct_characters_internal(string,\
    \ true, true, true, true, nil)\nend", "    if not string then return 0 end\n \
    \   local counts = makedict()\n    local c = 0\n    for _, c in ipairs(string)\
    \ do\n        if counts[c] ~= nil then counts[c] = counts[c] + 1 end\n       \
    \ counts[c] = counts[c] + 1\n    end\n    return #counts\nend", "    local count\
    \ = 0\n    local currentChar, previousChar = '', ''\n    for i = 1, #string do\n\
    \        currentChar = string[i]\n        if previousChar ~= '' then\n       \
    \     if currentChar ~= previousChar then\n                count = count + 1\n\
    \            end\n        end\n        previousChar = currentChar\n    end\n \
    \   return count\nend", "  local distinct_characters = {}\n  for _, character\
    \ in pairs(string) do\n    table.insert(distinct_characters, character)\n  end",
  '  if string == nil then return 0 end', "  if string.match('^%a+$', string) then\n\
    \    return #string\n  end\n  local count = 0\n  for i = 1, #string do\n    local\
    \ char = string.sub(i, i)\n    if string.match(string, '[%a'..char..'z]+') then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "    if string.len()\
    \ == 0 then\n        return 0\n    end\n    local result = 0\n    for i = 1, string.len()\
    \ do\n        local char = string.sub(i, i, i)\n        result = result + 1\n\
    \        if string.find(string.lower(char), string.lower(char)) then\n       \
    \     result = result + 1\n        end\n    end\n    return result\nend", '   if
    string == nil then return 0 end', "  local count = 0\n  for i = 1, #string do\n\
    \    count = count + (string:sub(i):lower():match(\"[%a]+\"):len())\n  end\n \
    \ return count\nend", "  if string == nil then return 0 end\n  local count, letter,\
    \ count = 0, 0, 1\n  for letter in string:gmatch(\"%a\") do\n    if letter ==\
    \ letter then count = count + 1 else count = 1 end\n  end\n  return count\nend",
  "  if string == '' then\n    return 1\n  end\n  local total = 0\n  local current\
    \ = ''\n  for i = 1, #string do\n    if current:sub(1, 1) == string.sub(i, i)\
    \ then\n      current = current .. string.sub(i, i)\n    else\n      total = total\
    \ + 1\n      current = string.sub(i, i)\n    end\n  end\n  return total\nend",
  "  local count = 0\n  for char in string.gmatch(string, \"%a\") do\n    count =\
    \ count + 1\n  end\n  return count\nend", "    local count = 0\n    for _, value\
    \ in ipairs(string:gsub('%D+', '')) do\n        if _ == value then\n         \
    \   count = count + 1\n        else\n            count = 0\n            break\n\
    \        end\n    end\n    return count\nend", "  local chars = {}\n  for char\
    \ in string.gmatch(\"[%a%A]+\", \"g\") do\n    if chars[char] == nil then\n  \
    \    chars[char] = 1\n    else\n      chars[char] = chars[char] + 1\n    end\n\
    \  end\n  return #chars\nend", "\t-- Use a set to count the distinct characters.\
    \ A set is a collection of unique elements and therefore\n\t-- returns an integer\
    \ as the number of distinct characters found.\n\t-- The set function returns true\
    \ when a set exists and can be written to the output buffer or false otherwise.\n\
    \t-- A set is empty if all elements are equal.\n\tlocal distinct_characters =\
    \ {} -- Create a new set that stores all the distinct characters in the string\
    \ being passed in."]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
