name: HumanEval_161_solve
language: lua
prompt: "-- You are given a string s.\n-- if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n-- otherwise keep it as it is.\n-- If the string\
  \ contains no letters, reverse the string.\n-- The function should return the resulted\
  \ string.\n-- Examples\n-- solve(\"1234\") = \"4321\"\n-- solve(\"ab\") = \"AB\"\
  \n-- solve(\"#a@C\") = \"#A@c\"\nlocal function solve(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solve\n\
  \    lu.assertEquals(candidate('AsDf'), 'aSdF')\n    lu.assertEquals(candidate('1234'),\
  \ '4321')\n    lu.assertEquals(candidate('ab'), 'AB')\n    lu.assertEquals(candidate('#a@C'),\
  \ '#A@c')\n    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')\n    lu.assertEquals(candidate('#6@2'),\
  \ '2@6#')\n    lu.assertEquals(candidate('#$a^D'), '#$A^d')\n    lu.assertEquals(candidate('#ccc'),\
  \ '#CCC')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local result = \"\"\n    for i=1, #s, 1 do\n        local l = string.lower(s[i])\n\
    \        if string.find(l, string.upper(l)) then\n            result = result\
    \ .. string.upper(s[i])\n        elseif string.find(l, string.lower(l)) then\n\
    \            result = result .. string.lower(s[i])\n        else\n           \
    \ result = result .. s[i]\n        end\n    end\n    return result\nend", "  \
    \  local result = ''\n    local start = 1\n    local count\n    for start = 1,#s\
    \ do\n        if string.sub(s, start, start+1) = 'A' then\n            count =\
    \ string.sub(s, start+2, start+1)\n            count = string.gsub(count, \"[AEIOUY]\"\
    , string.upper)\n        elseif string.sub(s, start, start+1) = 'E' then\n   \
    \         count = string.sub(s, start+2, start+1)\n            count = string.gsub(count,\
    \ \"[AEIOUY]\", string.lower)\n        else\n            result = result .. string.sub(s,start,start+1)\n\
    \        end\n    end\n    return result .. s\nend", "  s = s:gsub(\"(^|.)%l\"\
    ,function(s) return string.upper(string.sub(s,1,1)) + string.lower(string.sub(s,2,-1))..string.upper(string.sub(s,-1,-1))\
    \ end)\n  s = s:gsub(\"%l\",function(s) return string.upper(string.sub(s,2,-1))\
    \ + string.lower(string.sub(s,1,1)) end)\n  return s\nend", "  s = s..''\n  local\
    \ len = 0\n  for i=1,#s do\n    if string.sub(s,i,i)~='' then\n      len = len+1\n\
    \      break\n    end\n  end\n  s = string.sub(s,1,len)\n  if #s <= 1 then return\
    \ s end\n  local res\n  if string.sub(s,1,1)~='' then\n    local i = 1\n    local\
    \ start = 1\n    while i<=#s do\n      local char = string.sub(s,start,i)\n  \
    \    if toupper(char) == char then\n        local len = i-(start+1)\n        res\
    \ = string.sub(s,start,len..len)\n        start = len+1\n      else\n        res\
    \ = string.sub(s,start,i)\n        start = i\n      end\n      i = i+1\n    end\n\
    \  end\n  return res\nend\nprint(solve(\"1234\"))\nprint(solve(\"ab\"))\nprint(solve(\"\
    #a@C\"))\nprint(solve(\"#a@C\"))", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local result = ''\n  local s = s:lower()\n  for i = 1, #s do\n    if alphabet:find(s[i\
    \ - 1], 1, #alphabet) ~= nil then\n      if tostring(s:sub(i, i + 1)) == 'a' or\
    \ tostring(s:sub(i, i + 1)) == 'b' then\n        result = result .. 'b'\n    \
    \  elseif tostring(s:sub(i, i + 1)) == 'c' or tostring(s:sub(i, i + 1)) == 'd'\
    \ then\n        result = result .. 'd'\n      elseif tostring(s:sub(i, i + 1))\
    \ == 'e' or tostring(s:sub(i, i + 1)) == 'f' then\n        result = result ..\
    \ 'f'\n      elseif tostring(s:sub(i, i + 1)) == 'g' or tostring(s:sub(i, i +\
    \ 1)) == 'h' then\n        result = result .. 'h'\n      elseif tostring(s:sub(i,\
    \ i + 1)) == 'i' or tostring(s:sub(i, i + 1)) == 'j' then\n        result = result\
    \ .. 'j'\n      elseif tostring(s:sub(i, i + 1)) == 'k' or tostring(s:sub(i, i\
    \ + 1)) == 'l' then\n        result = result .. 'l'\n      elseif tostring(s:sub(i,\
    \ i + 1)) == 'm' or tostring(s:sub(i, i + 1)) == 'n' then\n        result = result\
    \ .. 'n'\n      elseif tostring(s:sub(i, i + 1)) == 'o' or tostring(s:sub(i, i\
    \ + 1)) == 'p' then\n        result = result .. 'p'\n      elseif tostring(s:sub(i,\
    \ i + 1)) == 'q' or tostring(s:sub(i, i + 1)) == 'r' then\n        result = result\
    \ .. 'r'\n      elseif tostring(s:sub(i, i + 1)) == 's' or tostring(s:sub(i, i\
    \ + 1)) == 't' then\n        result = result .. 't'\n      elseif tostring(s:sub(i,\
    \ i + 1)) == 'u' or tostring(s:sub(i, i + 1)) == 'v' then\n        result = result\
    \ .. 'v'\n      elseif tostring(s:sub(i, i + 1)) == 'w' or tostring(s:sub(i, i\
    \ + 1)) == 'x' then\n        result = result .. 'x'\n      elseif tostring(s:sub(i,\
    \ i + 1)) == 'y' or tostring(s:sub(i, i + 1)) == 'z' then\n        result = result\
    \ .. 'z'\n      else\n        result = result .. s[i - 1]\n      end\n    else\n\
    \      result = result .. s[i - 1]\n    end\n  end\n  \n  return result\nend",
  "  s = string.lower(s)\n  if string.find(s, \"#\") == nil then\n    return s\n \
    \ end\n  local index = 0\n  local result = ''\n  while true\n    do\n      if\
    \ string.find(s, \"#\", index) then\n        local letter = string.sub(s,index,index+1)\n\
    \        index = string.find(s, \"#\", index+1)\n        if letter:byte() ~= nil\
    \ then\n          if letter:byte() ~= 32:byte() then\n            letter = string.upper(letter)\n\
    \          end\n          letter = letter:sub(1,-1)\n        end\n        result\
    \ = result .. letter\n      else\n        result = result .. s\n        break\n\
    \      end\n    end\n  return result\nend", "    local ret = \"\"\n    for i=1,#s,1\
    \ do\n        local lc = string.lower(s[i])\n        if lc == s[i] then\n    \
    \        ret = string.upper(ret) or string.lower(ret)\n        else\n        \
    \    ret = string.upper(ret) or string.lower(ret) or s[i]\n        end\n    end\n\
    \    return ret\nend\n</cell>\n<text>\n5. Solutions\n5.1 Using Lua 5.3\nWrite\
    \ a Lua function that takes a string as an argument, and returns the string reversed.\
    \ You should be able to test this function to verify it returns the expected result.\
    \ For some reason, you are not allowed to use the built-in reverse function.\n\
    Test your function with the following:\nassert(solve(\"1234\")==\"4321\")\nassert(solve(\"\
    ab\")==\"AB\")\nassert(solve(\"#a@C\")==\"#A@c\")\n5.2 Using Lua 5.4\nUse the\
    \ following Lua code:", "    local result = \"\"\n    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    for i = 1, #s do\n        if alphabet:sub(#alphabet, #alphabet) == s[i]\
    \ then\n            result = result .. toupper(alphabet:sub(#alphabet, #alphabet))\n\
    \        else\n            result = result .. s[i]\n        end\n    end\n   \
    \ return result\nend", "    local result = \"\"\n    for i = 1, #s do\n      \
    \  if string.sub(s,i,i) ~= nil then\n            -- If the character is a letter,\
    \ convert it from lower case to upper case\n            if string.sub(s,i,i) ~=\
    \ string.sub(s,i,i):lower() then\n                result = result .. string.sub(s,i,i:lower())\
    \ .. string.sub(s,i,i) .. string.sub(s,i,i:lower())\n            else\n      \
    \          result = result .. string.sub(s,i,i) \n            end\n        else\n\
    \            result = result .. string.sub(s,i,i) \n        end\n    end\n   \
    \ return result\nend", '   if s == nil then return nil end', "  local s = string.gsub(s,\
    \ \"%a\", \"\")\n  local function helper(str, i)\n    if str:sub(i, i) ~= '^a'\
    \ then\n      return helper(str, i-1)\n    else\n      i = i+1\n      if str:sub(i,\
    \ i) ~= '^A' then\n        return helper(str, i-1)\n      else\n        str =\
    \ string.gsub(str:sub(i, i), \"([a-z])([A-Z])\", \"\\1\\2\")\n        return helper(str,\
    \ i-1)\n      end\n    end\n  end\n  return helper(s, #s)\nend", "  local s =\
    \ string.gsub(s, \"%l\", string.upper)\n  s = string.gsub(s, \"%L\", string.lower)\n\
    \  return s\nend", "   local out=\"\"\n   for i=1,#s do\n      local c=s:sub(i,i)\n\
    \      if c:byte()>47 and c:byte()<58 then\n         c=string.upper(c)\n     \
    \ elseif c:byte()>64 and c:byte()<91 then\n         c=string.lower(c)\n      end\n\
    \      out=out..c\n   end\n   return out\nend", "  local result = string.gsub(s,\
    \ \"[a-z]\", function (c)\n    if string.find(string.upper(string.sub(c, 1)),\
    \ \"[AEIOU]\") then\n      return string.upper(string.sub(c, 1))\n    else\n \
    \     return string.lower(string.sub(c, 1))\n    end\n  end)\n  return result\n\
    end", "\ts = s:upper()\n\tif s:sub(1,1) ~= 'a' then\n\t\treturn s\n\tend\n\ts\
    \ = s:sub(2)..s:sub(1)\n\ts = s:gsub(\"(.)\"..((#s)+1)..\"(.)\", \n\t\tfunction(x)\n\
    \t\t\tif tonumber(x) < #s then\n\t\t\t\treturn ((tonumber(x)+#s)-1)..((tonumber(x)-1)-1)..x\n\
    \t\t\tend\n\t\tend)\n\ts = s:gsub(\"(.)\"..((#s)+1)..\"(.)\", \n\t\tfunction(x)\n\
    \t\t\tif tonumber(x) > #s then\n\t\t\t\treturn ((tonumber(x)+#s)-1)..((tonumber(x)-1)-1)..x\n\
    \t\t\tend\n\t\tend)\n\treturn s\nend", "    local a1 = {}\n    local a2 = {}\n\
    \    local l = s:len()\n    local str = ''\n    if l:len() == 1 then\n       \
    \ str = s:sub(1,1)\n    else\n        for i = 1, l:len() do\n            if s:sub(i,i)\
    \ == s:sub(i,i) ~= '#' then\n                a1[#a1+1]  = s:sub(i,i)\n       \
    \     else\n                a2[#a2+1] = s:sub(i,i)\n            end\n        end\n\
    \        a1[#a1+1] = s:sub(l,l)\n        a2[#a2+1] = s:sub(l-2,l)\n    end\n \
    \   local len = 0\n    for i = 1, #a1 do\n        if a1[i] == a1[i] then\n   \
    \         len = len+1\n        elseif a2[i] == a2[i] then\n            len = len-1\n\
    \        else\n            str = str .. a1[i]\n        end\n    end\n    if len\
    \ == 0 then\n        return str:reverse()\n    end\n    local s\n    if #a1 >\
    \ #a2 then\n        s, a1, a2 = a2, a1, a1\n    end\n    local i = #a1\n    if\
    \ #a1 == 0 then\n        s, a1 = a2, a2\n    end\n    while i > 1 do\n       \
    \ str = str .. a1[i-1]\n        i = i-1\n    end\n    return str:reverse()\nend",
  "  local newS = \"\"\n  for i = 1, #s do\n    if string.find(string.char(string.lower(s[i])\n\
    \                           .. string.upper(string.sub(s,i,i)))\n            \
    \      , \"^[a-zA-Z]+$\") then\n      if s[i] ~= string.lower(s[i]) then\n   \
    \     newS = string.sub(s,1,i-1) .. string.upper(string.sub(s,i+1,#s))\n     \
    \ else\n        newS = string.sub(s,1,i-1) .. string.lower(string.sub(s,i+1,#s))\n\
    \      end\n    end\n  end\n  return newS\nend", "\t\n\tlocal rs = \"\"\n\t\n\t\
    for i=1,#s do\n\t\tif tonumber(s[i]) == tonumber(tolower(s[i])) then\n\t\t\trs\
    \ = toupper(tolower(s[i])) + rs\n\t\telse\n\t\t\trs = s[i] + rs\n\t\tend\n\tend\n\
    \t\n\treturn rs\nend", "    local result = \"\" -- result string\n    for c in\
    \ s:gmatch(\"[%a%#]\") do\n        if c == \"#\" then\n            result = \"\
    #\"\n        elseif c ~= \"@\" then\n            result = c .. result\n      \
    \  end\n    end\n    return result:reverse()\nend", "\t-- write your code in JavaScript\
    \ (Node.js 8.9.4)\n\ts = string.gsub(s, \"[^a-zA-Z]\", function(x)\n\t\treturn\
    \ toupper(x) or tolower(x)\n\tend)\n\ts = string.gsub(s, \"[a-z]\", function(x)\n\
    \t\treturn tolower(x) or toupper(x)\n\tend)\n\treturn s\nend", "    local stack\
    \ = {{}}\n    local tmp = \"\"\n    local i = 1\n    while i < #s do\n       \
    \ if string.sub(s, i, i) ~= '#' and string.sub(s, i, i) ~= '@' and string.sub(s,\
    \ i, i) ~= '$' then\n            tmp = string.sub(s, i, i)\n        else\n   \
    \         stack[#stack + 1] = string.sub(s,i,i)\n        end\n        i = i +\
    \ 1\n    end\n    tmp = stack[#stack]\n    stack[#stack] = tmp\n    stack[#stack]:reverse()\n\
    \    stack[#stack]:reverse()\n    return table.concat(stack)\nend\nprint(solve(\"\
    1234\"))\nprint(solve(\"ab\"))\nprint(solve(\"#a@C\"))", "    if s == \"\" then\
    \ return s end\n    for i,x in ipairs(s) do\n        if (x == \"@\" or x == \"\
    #\" or x == \"$\" or x == \"%\" or x == \"&\" or x == \"*\" or x == \"^\" or x\
    \ == \"?\" or x == \"-\" or x == \":\" or x == \">\" or x == \"<\" or x == \"\
    =\" or x == \"|\" or x == \"~\" or x == \"`\" or x == \"_\" or x == \"<\" or x\
    \ == \"[\") then\n            s = string.gsub(s,x,string.char(x))\n        end\n\
    \    end\n    return s\nend", "    local newS = \"\";\n    for i = 1, #s do\n\
    \        if (string.sub(s, i, i)):byte() ~= 0 then\n            if string.sub(s,\
    \ i, i):byte() >= 65 and string.sub(s, i, i):byte() <= 90 or string.sub(s, i,\
    \ i):byte() >= 97 and string.sub(s, i, i):byte() <= 122 then\n               \
    \ table.insert(newS, string.char(string.byte(string.sub(s,i,i)) + 32));\n    \
    \        else\n                table.insert(newS, string.sub(s, i, i));\n    \
    \        end\n        else\n            table.insert(newS, string.sub(s, i, i));\n\
    \        end\n    end\n    return newS\nend", "\tlocal a = string.gmatch(s, \"\
    [%z^%a^%A^%#^%@^%-]+\") \n\treturn string.gsub(string.gsub(s, \"[%z^%a^%A^%#^%@^%-]\"\
    , a .. \"A\"), \"[%z^%a^%A^%#^%@^%-]\", a .. \"a\")\nend", "  -- Write your code\
    \ in JavaScript (Node.js 8.9.4)\n  local chars = {}\n  for i = 1,#s do\n    if\
    \ chars[s:sub(i,i)] then\n      chars[s:sub(i,i)]:push(i)\n    else\n      chars[s:sub(i,i)]\
    \ = {i}\n    end\n  end\n  local res\n  for k,v in pairs(chars) do\n    local\
    \ tmp = string.char()\n    for i=1,#v do\n      tmp = string.sub(tmp,v[i-1]+1,v[i]-1)\n\
    \    end\n    if res ~= nil then \n      res = string.sub(res,#res+1,#res+1)\n\
    \    end\n    res = string.sub(res,0,#res-1)..tmp\n  end\n  return res\nend",
  "  local result = \"\"\n  for i = 1, #s do\n    local c = tolower(s[i])\n    local\
    \ upper = toupper(c)\n    local lower = \"a\"\n    if upper ~= c and upper ~=\
    \ nil then\n      if upper:sub(1, 1) == \"@\" then\n        upper = toupper(upper:sub(1,\
    \ 1))\n      elseif upper:sub(1, 1) == \"#\" then\n        upper = toupper(upper:sub(1,\
    \ 1))\n        lower = tolower(upper:sub(1, 1))\n      elseif upper:sub(1, 1)\
    \ ~= \"a\" then\n        upper = toupper(upper:sub(1, 1))\n        lower = tolower(upper:sub(1,\
    \ 1))\n      end\n    end\n    if upper ~= c and upper ~= nil then\n      result\
    \ = result .. upper\n    elseif lower ~= c and lower ~= nil then\n      result\
    \ = result .. lower\n    end\n  end\n  return result\nend", "\tif s == '' then\n\
    \t\treturn ''\n\tend", "  if s:match('^[a-z_]*') then\n    local _s = string.lower(s)\n\
    \    local _i = 0\n    local _lastchar = ''\n    local _lastcharupper = nil\n\
    \    local _ret = ''\n    while _i < #_s and #_ret < #_s do\n      _ret = _ret..string.upper(_s[_i].._lastchar)\n\
    \      _lastchar = _s[_i]\n      _lastcharupper = string.upper(_lastchar)\n  \
    \    _i = i + 1\n    end\n    return _ret .._lastcharupper\n  else\n    return\
    \ s\n  end\nend", "  if string.len(s) ~= 0 then\n    if string.sub(s,1,1) ~= '#'\
    \ then\n      return s.reverse()\n    end\n  end\n  return s\nend", "  -- Write\
    \ your code here\n  local result", "  -- Your code here\n  local result = \"#\"\
    \n  for i=1,#s do\n    if tonumber(s[i])>0 then \n      local temp = s[i]\n  \
    \    s[i]=toupper(s[i])\n      result = result..temp\n    else\n      result =\
    \ result..s[i]\n    end\n  end\n  return result\nend", "    if not s then\n  \
    \      return \"#a@c\"\n    end\n    local str = s:gsub(\"[%a]+\",function(s)\n\
    \        local letter = string.lower(s)\n        local result = string.reverse(letter)\n\
    \        return letter:gsub(\"%c\",string.upper):gsub(\"%c\",string.rep)(letter,string.len(letter)-1):gsub(\"\
    %c\",string.rep)(result,string.len(result)-1):result\n    end)\n    return str:sub(1,#str)\n\
    end", "  s = string.lower(s)\n  local result = \"\"\n  for i=1,#s do\n    if string.find(string.sub(s,i,i+1),\"\
    .\") > 0 then\n      result = result .. string.upper(string.sub(s,i,i+1)) .. string.sub(s,i+1,i+2)\n\
    \    else\n      result = result .. string.lower(string.sub(s,i,i+1))\n    end\n\
    \  end\n  if result == s then\n    return result\n  end\n  return string.upper(string.sub(result,1,1))\
    \ .. string.sub(result,2)\nend", "  \n  if s == \"\" then\n    return \"\" --\
    \ Nothing to reverse if there are no letters left\n  else\n    local result =\
    \ \"\"\n    for i = 1, #s do\n      if s[i] ~= '#' then\n        -- If there is\
    \ a letter left in the string then change its case from\n        -- lower case\
    \ to upper case or visa versa \n        if s[i] ~= 'a' and s[i] ~= 'A' and s[i]\
    \ ~= 'b' and s[i] ~= 'B' then\n          result = result .. toupper(s[i])\n  \
    \      else\n          result = result .. tolower(s[i])\n        end\n      else\n\
    \        result = result .. s[i] -- If the string has '#' then ignore it\n   \
    \   end\n    end\n  \n    -- Return result string with every '#' removed\n   \
    \ return result\n  end\nend", "  \n    local str={}\n    \n    for i,v in pairs(s:gmatch(\"\
    (.)%%(.)\"))do\n        if v:gsub(\"%$\",\"%%\"):sub(1,1)==v:sub(1,1) then\n \
    \           str:insert(v:sub(2,2))\n        else\n            str:insert(v)\n\
    \        end\n    end\n    \n    return table.concat(str,\"%%\")\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=lua,lua-patterns |>\nHere's a very simple one liner:\n\
    <code>", "  -- your code here\n  \nend", "   s = string.gsub(s, \" \", \"\")\n\
    \   for i = 1, #s do\n      if s[i] ~= nil then\n         if string.byte(s[i])\
    \ >= 97 and string.byte(s[i]) <= 122 then\n            s[i] = string.char(string.byte(s[i])\
    \ - 32)\n         else\n            s[i] = string.char(string.byte(s[i]) + 32)\n\
    \         end\n      end\n   end\n   return s\nend\n   ", "  s = string.lower(s)\n\
    \  s = string.gsub(s, \"(.)\", function(a, b) return a:lower() end)\n  if s ~=\
    \ s then return s end\n  return s\nend\nprint(solve(\"1234\"))\nprint(solve(\"\
    ab\"))\nprint(solve(\"#a@C\"))\nprint(solve(\"abc\"))", "    local new_s = string.gsub(s,\
    \ \"([a-z])\",\n            function(c) string.lower(c) end)\n    return string.gsub(new_s,\
    \ \" %l\", \n            function(c) string.upper(c) end)\nend\nprint(solve(read()))",
  "    local t = ''\n    for letter in string.gmatch( s, '%a') do\n        if letter:sub(1,1)\
    \ == letter then\n            t = letter:sub(2,1) .. letter:sub(3)\n        else\n\
    \            t = letter\n        end\n    end\n    if string.find( s, '^[%a]+$')\
    \ then\n        t =  '^[%a]+$'\n    end\n    if string.find( s, '%a') then\n \
    \       t = '%a'\n    end\n    if t:sub(1, 1) ~= '^' and t:sub(1, 1) ~= '$' then\n\
    \        t = t:sub(1, 1) .. t:sub(2, 1) .. t:sub(3)\n    end\n    if t:match('^[%a]+')\
    \ then\n        t = '^[%a]+$'\n    end\n    if t:match('%a') then\n        t =\
    \ '%a'\n    end\n    return t\nend\n</cell>\n<text>\n10. Check whether the given\
    \ string is a palindrome or not.", "  local ret = \"\"\n  for i = 1, #s do\n \
    \   if string.sub(s, i, i) ~= nil then\n      ret = string.sub(s, i, i) .. ret\n\
    \    else\n      ret = string.sub(s, i, i) .. ret\n    end\n  end\n  return ret\n\
    end", "    local len = #s\n    local str = ''\n    local result = ''", "\tlocal\
    \ str = \"\"\n\tfor char in string.gmatch(s, \"[^a-zA-Z]+\") do\n\t\tif string.find(char,\
    \ \"a\") > string.find(char, \"z\") then\n\t\t\tstr = str .. string.upper(char)\n\
    \t\telseif string.find(char, \"A\") > string.find(char, \"Z\") then\n\t\t\tstr\
    \ = str .. string.lower(char)\n\t\telse\n\t\t\tstr = str .. char\n\t\tend\n\t\
    end\n\treturn str\nend\nprint(solve(ARGV[1]));\n</cell>\n<text>\n\u0423\u043F\u0440\
    \u0430\u0436\u043D\u0435\u043D\u0438\u0435\n\u041D\u0430\u043F\u0438\u0448\u0438\
    \u0442\u0435 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0443, \u043A\u043E\
    \u0442\u043E\u0440\u0430\u044F \u043F\u043E\u043B\u0443\u0447\u0438\u0442 \u043F\
    \u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044E \u0441\u0432\
    \u043E\u0435 \u0432\u0432\u043E\u0434\u043D\u0443\u044E \u0444\u0430\u0439\u043B\
    \ \u0441\u043E \u0432\u0441\u0435\u043C\u0438 \u0441\u043B\u043E\u0432\u0430\u043C\
    \u0438, \u043F\u0435\u0440\u0435\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u0441\
    \u0442\u0440\u043E\u043A\u0443 \u0441 \u043A\u0430\u0436\u0434\u043E\u0439 \u043F\
    \u043E \u0441\u043B\u043E\u0432\u0430\u043C \u0442\u0438\u043F\u0430 \u0440\u0443\
    \u0441\u0441\u043A\u0438\u0445 \u0431\u0443\u043A\u0432.", "    local chars =\
    \ {}\n    for i = 1, #s do\n        local c = string.sub(s, i, i)\n        if\
    \ c == 'a' then\n            chars[#chars + 1] = 'A'\n        elseif c == 'b'\
    \ then\n            chars[#chars + 1] = 'B'\n        elseif c == 'c' then\n  \
    \          chars[#chars + 1] = 'C'\n        elseif c == 'd' then\n           \
    \ chars[#chars + 1] = 'D'\n        elseif c == 'e' then\n            chars[#chars\
    \ + 1] = 'E'\n        elseif c == 'f' then\n            chars[#chars + 1] = 'F'\n\
    \        elseif c == 'g' then\n            chars[#chars + 1] = 'G'\n        elseif\
    \ c == 'h' then\n            chars[#chars + 1] = 'H'\n        elseif c == 'i'\
    \ then\n            chars[#chars + 1] = 'I'\n        elseif c == 'j' then\n  \
    \          chars[#chars + 1] = 'J'\n        elseif c == 'k' then\n           \
    \ chars[#chars + 1] = 'K'\n        elseif c == 'l' then\n            chars[#chars\
    \ + 1] = 'L'\n        elseif c == 'm' then\n            chars[#chars + 1] = 'M'\n\
    \        elseif c == 'n' then\n            chars[#chars + 1] = 'N'\n        elseif\
    \ c == 'o' then\n            chars[#chars + 1] = 'O'\n        elseif c == 'p'\
    \ then\n            chars[#chars + 1] = 'P'\n        elseif c == 'q' then\n  \
    \          chars[#chars + 1] = 'Q'\n        elseif c == 'r' then\n           \
    \ chars[#chars + 1] = 'R'\n        elseif c == 's' then\n            chars[#chars\
    \ + 1] = 'S'\n        elseif c == 't' then\n            chars[#chars + 1] = 'T'\n\
    \        elseif c == 'u' then\n            chars[#chars + 1] = 'U'\n        elseif\
    \ c == 'v' then\n            chars[#chars + 1] = 'V'\n        elseif c == 'w'\
    \ then\n            chars[#chars + 1] = 'W'\n        elseif c == 'x' then\n  \
    \          chars[#chars + 1] = 'X'\n        elseif c == 'y' then\n           \
    \ chars[#chars + 1] = 'Y'\n        elseif c == 'z' then\n            chars[#chars\
    \ + 1] = 'Z'\n", "  local str  = tostring(s)\n  local str2 = \"\"\n  for i = 1,\
    \ #str do\n    if str[i] then\n      if str[i] == toupper(str[i]) then\n     \
    \   str2 = str2 .. tolower(str[i])\n      else\n        str2 = str2 .. str[i]\n\
    \      end\n    else\n      str2 = str2 .. str[i]\n    end\n  end\n  return str2\n\
    end", "    local result = \"\" -- We build the resulted string in this variable\n\
    \    for i = 1, #s do -- iterate through each character in the string in order\n\
    \        local char = string.sub(s,i,i) -- substring from position i to position\
    \ i\n        if char in string.ascii_uppercase or char in string.ascii_lowercase\
    \ then -- if the character is uppercase/lowercase\n            char = string.char(string.upper(char)..string.lower(char))\n\
    \        end\n        result = result..char -- append the character to the resulted\
    \ string\n    end\n    if result == \"\" then -- if the resulted string was empty\
    \ then we return the empty string\n        result = \"ERROR\"\n    end\n    return\
    \ result\nend\n</code>\n<|/ a tags=string,lua,case-sensitive |>\n<| a dscore=0\
    \ |>\n<code>", "    local n = 1\n    local result = \"\"\n    for i = 1,#s do\n\
    \        if string.sub(s,i,i) == string.sub(s,i,i) then\n            n = n+1\n\
    \        else\n            if n > 1 then\n                result = (string.sub(s,1,i)\
    \ + string.sub(s,i+1,i) + string.sub(s,i,n)\n                    + string.sub(s,n,i)\
    \ + string.sub(s,i+1,n) + string.sub(s,n,n-1) + string.sub(s,1,n-1))\n       \
    \         end\n                n = n-1\n            end\n        end\n    end\n\
    \    return result\nend\nprint(solve(\"1234\"))", "    local newS = ''\n    \n\
    \    for i,v in ipairs(s) do\n        if string.find(string.upper(v),string.upper(i))\
    \ then\n            newS = string.upper(i):sub(string.upper(i):find(string.upper(i)):lower(),string.upper(i):find(string.upper(i)):upper())\n\
    \        elseif string.find(string.lower(v),string.lower(i)) then\n          \
    \  newS = string.lower(i):sub(string.lower(i):find(string.lower(i)):upper(),string.lower(i):find(string.lower(i)):lower())\n\
    \        else\n            newS = newS..v\n        end\n    end\n    return newS\n\
    end", "   -- base case\n   if string.len(s)==0 or string.len(s)>1 then\n     \
    \ return s\n   end", "    local str = s:gsub(\"[%a%]\", function(c) return string.upper(c)\
    \ end):gsub(\"[%A%]\", function(c) return string.lower(c) end)\n    return str:sub(1,#str)\
    \ .. str:sub()\nend", "   local chars = string.gmatch(s, \"%p\")\n   local res\n\
    \   for _, char in ipairs(chars) do\n      res = char:toupper():reverse():char:tolower()\n\
    \   end\n   if chars == nil then\n      res = s:reverse()\n   end\n   return res\n\
    end", "    local newS = \"\"\n    for i = 1, #s, 2 do\n        if s[i] ~= \"\"\
    \ then\n            if s[i] == toupper(s[i]) then\n                newS = newS\
    \ .. tolower(s[i])\n            else\n                newS = newS .. s[i]\n  \
    \          end\n        else\n            newS = newS .. s[i]\n        end\n \
    \   end\n    return newS\nend\n</code>\n<|/ a |>\n<| a tags=lua dscore=2 |>\n\
    If you need to modify a string to make it all lowercase or all uppercase:\n<code>",
  "  s = s:upper()\n  for i=1,#s do\n    if s[i] then\n      s[i] = tostring(s[i])\n\
    \      s[i]=tostring(tostring(tostring(tostring(s[i],2,1),2,2),2,3),2,4)\n   \
    \ end\n  end\n  return s\nend", "   local str = \"\"\n   for i = 1, #s do\n  \
    \    if s[i] ~= \"\" then\n         str = str..string.lower(s[i])..string.upper(s[i])\n\
    \      else\n         str = str..string.lower(s[i])\n      end\n   end\n   return\
    \ str\nend", "    local n = 0\n    for i = 1, #s do\n        if string.sub(s,i,i)\
    \ ~= nil then\n            n = n + 1;\n        end\n    end\n    if n ~= 0 then\n\
    \        -- Find first letter\n        local x = string.find(s, \"A\");\n    \
    \    if x ~= nil then\n            -- Check if it is a capital letter\n      \
    \      if string.sub(s,x,x) ~= nil then\n                local res = string.sub(s,1,x)\
    \ + string.sub(s,x+1);\n                return res;\n            else\n      \
    \          -- Reverse it\n                return string.gsub(string.sub(s,x),\"\
    a\",\"A\");\n            end\n        end\n    end\n    return s;\nend", "   \
    \ local n\n    for n in string.gmatch(s, \"[^a-zA-Z]\") do\n        \n    end\n\
    \    return \"#a@C\"\nend", "\tlocal i, j = 1, #s\n\tlocal reversed_string = \"\
    \"\n\twhile j < i do\n\t\tlocal c = string.sub(s,i,j)\n\t\tif c == \"a\" or c\
    \ == \"A\" then\n\t\t\treversed_string = string.upper(reversed_string)\n\t\telseif\
    \ c == \"b\" or c == \"B\" then\n\t\t\treversed_string = string.lower(reversed_string)\n\
    \t\telse\n\t\t\treversed_string = reversed_string .. c\n\t\tend\n\t\ti = j\n\t\
    \tj = i\n\tend\n\treturn reversed_string\nend", "  -- Your code here\n  \n  --\
    \ Find the first non-letter character\n  local l=0\n  local last=string.len(s)-1\n\
    \  while not string.sub(s, l, last).match('[a-zA-Z]') do\n    last=l\n    l=l+1\n\
    \  end\n  \n  -- Loop over the string and make each character uppercase\n  local\
    \ res=\"\"\n  for i=1, string.len(s) do\n    if not string.sub(s, i, i+1).match('[a-zA-Z]')\
    \ then\n      res=res+string.upper(string.sub(s, i, i+1))\n    else\n      res=res+string.sub(s,\
    \ i, i)\n    end\n  end\n  \n  return res\nend\nprint(solve(string.char(string.len(\"\
    AB#A@c\"))))", "  -- base case\n  if s:find('[A-Za-z]') then\n    return s:upper()\n\
    \  elseif s:find('[a-z]') then\n    return s:lower()\n  else\n    return s:reverse()\n\
    \  end\nend", "    local t = {}\n    local i, j = 0, 0\n    for i = 1,#s do\n\
    \        t[i] = toupper(s[i])\n    end\n    while j < #t do\n        if t[j] ==\
    \ tolower(t[i]) then\n            t[i] = toupper(t[i])\n        else\n       \
    \     t[i] = t[i]\n        end\n        i = i+1\n        if i == #t then\n   \
    \         break\n        end\n    end\n    return table.concat(t)\nend", "   \
    \ local res,i,k = \"\",1,#s\n    while i <= k do\n        if s[i] ~= nil and s[i]\
    \ == s[i] then\n            if s[i] == \"a\" then res,i,k = res,i+1,\"a\"\n  \
    \          if s[i] == \"A\" then res,i,k = res,i+1,\"A\"\n            if s[i]\
    \ == \"b\" then res,i,k = res,i+1,\"b\"\n            if s[i] == \"B\" then res,i,k\
    \ = res,i+1,\"B\"\n            if s[i] == \"c\" then res,i,k = res,i+1,\"c\"\n\
    \            if s[i] == \"C\" then res,i,k = res,i+1,\"C\"\n            if s[i]\
    \ == \"d\" then res,i,k = res,i+1,\"d\"\n            if s[i] == \"D\" then res,i,k\
    \ = res,i+1,\"D\"\n            if s[i] == \"e\" then res,i,k = res,i+1,\"e\"\n\
    \            if s[i] == \"E\" then res,i,k = res,i+1,\"E\"\n            if s[i]\
    \ == \"f\" then res,i,k = res,i+1,\"f\"\n            if s[i] == \"F\" then res,i,k\
    \ = res,i+1,\"F\"\n            if s[i] == \"g\" then res,i,k = res,i+1,\"g\"\n\
    \            if s[i] == \"G\" then res,i,k = res,i+1,\"G\"\n            if s[i]\
    \ == \"h\" then res,i,k = res,i+1,\"h\"\n            if s[i] == \"H\" then res,i,k\
    \ = res,i+1,\"H\"\n            if s[i] == \"i\" then res,i,k = res,i+1,\"i\"\n\
    \            if s[i] == \"I\" then res,i,k = res,i+1,\"I\"\n            if s[i]\
    \ == \"j\" then res,i,k = res,i+1,\"j\"\n            if s[i] == \"J\" then res,i,k\
    \ = res,i+1,\"J\"\n            if s[i] == \"k\" then res,i,k = res,i+1,\"k\"\n\
    \            if s[i] == \"K\" then res,i,k = res,i+1,\"K\"\n            if s[i]\
    \ == \"l\" then res,i,k = res,i+1,\"l\"\n            if s[i] == \"L\" then res,i,k\
    \ = res,i+1,\"L\"\n            if s[i] == \"m\" then res,i,k = res,i+1,\"m\"\n\
    \            if s[i] == \"M\" then res,i,k = res,i+1,\"M\"\n            if s[i]\
    \ == \"n\" then res,i,k = res,i+1,\"n\"\n            if s[i] == \"N\" then res,i,k\
    \ = res,i+1,\"N\"\n            if s[i] == \"o\" then res,i,k = res,i+1,\"o\"",
  "  s = string.lower(s)\n  local t = {}\n  for c in s do\n    if string.find(string.format(\"\
    %c\", string.upper(c)), s, 1, true) == nil then\n      t = table.insert(t, c)\n\
    \    end\n  end\n  return table.concat(t)\nend", "  local letters = {}\n  for\
    \ i = 1, #s do\n    local c = string.sub(s,i,i)\n    letters[c] = letters[c] or\
    \ string.lower(c)\n  end\n  local reversed_s = \"\"\n  for i = #s, 1, -1 do\n\
    \    reversed_s = reversed_s .. letters[string.sub(s,i,i)] \n  end\n  return reversed_s\n\
    end", "    local s = s:gsub(\"([a-z])\", function(x)\n        return x == x:lower()\
    \ or x == x:upper() ? x:upper():x\n    end)\n    if s:find(\"[^a-z]\") then\n\
    \        return s:gsub(\"(.)\", function(x)\n            return x:lower() \n \
    \       end)\n    else\n        return s\n    end\nend\nprint(solve(\"ab\"))",
  "  -- write your code in JavaScript (Node.js 8.9.4)\n  return s\nend", "\tlocal\
    \ t = \"a\"\n\twhile s ~= \"\" do\n\t\tif isletter(s) then\n\t\t\tif t == \"a\"\
    \ then\n\t\t\t\ts = t:upper():reverse():lower()\n\t\t\t\tt = \"b\"\n\t\t\telseif\
    \ t == \"b\" then\n\t\t\t\ts = s:lower()\n\t\t\t\tt = \"a\"\n\t\t\tend\n\t\telse\n\
    \t\t\ts = s:reverse():lower()\n\t\tend\n\tend\n\treturn s\nend", "   local s =\
    \ string.lower(s)\n   return s:gsub(\"%a\", function(c)\n      local t  = string.upper(c)\n\
    \      return t ~= c and string.upper(t) or c\n   end) .. string.sub(s, 1, -1)\n\
    end", "    local str = s:gsub('.', function(c) \n        if (c:byte() == 95) return\
    \ \"a\"\n        else if (c:byte() == 97) return \"b\"\n        else if (c:byte()\
    \ == 123) return \"c\"\n        else return c\n    end) \n    return str:reverse()\
    \ \nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,lua,reverse,arrays |>\n\
    I wanted to reverse a string, and was able to do so without having to use tonumber()\
    \ or math.floor().\n<code>", "  if s:match(\"^[a-zA-Z]+$\") then \n    return\
    \ s:gsub(\"([A-Z]+)\",function(x)return x:lower() end)\n  else\n    return s:reverse()\n\
    \  end\nend\nprint(solve(\"1234\"))\nprint(solve(\"ab\"))\nprint(solve(\"#a@C\"\
    ))\nprint(solve(\"#$%^&$@#\"))\n</code>\n<|/ a |>\n<| c |>\nIt would be good if\
    \ you could add an explanation of the code. Code only answers are not always very\
    \ helpful.\n<|/ c |>\n<| a dscore=1 |>\nThis solution only works if the input\
    \ is letters and no other special characters:\n<code>\ndef reverse(s):\n    upper\
    \ = s.isupper()\n    res = \"\"\n    for i in range(len(s)):\n        if s[i].isalpha():\n\
    \            if upper:\n                res += s[i].upper()\n            else:\n\
    \                res += s[i].lower()\n        else:\n            res += s[i]\n\
    \    return res", "   local result\n   for i = 1, #s do\n      local c = string.sub(s,i,i)\n\
    \      if string.match(\"[A-z]\",c) then\n         c = string.upper(c)\n     \
    \ else\n         c = string.lower(c)\n      end\n      result = result .. c\n\
    \   end\n   return result\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWon't this\
    \ fail if a string is empty? The loop won't execute anything and result in an\
    \ empty string.\n<|/ c |>\n<| c |>\nThanks for noticing, I've just edited the\
    \ code to be more robust in that regard\n<|/ c |>\n<| a |>\nHere's my solution:\n\
    <code>", "    local result\n    for i, c in ipairs(s) do\n        if c:byte()\
    \ == 32 then\n            if string.byte(c:upper()) == 32 then\n             \
    \   if string.byte(c:lower()) == 32 then\n                    c = c:upper()\n\
    \                else\n                    c = c:lower()\n                end\n\
    \            else\n                c = c:upper()\n            end\n        else\n\
    \            c = c:lower()\n        end\n        result = result .. c\n    end\n\
    \    return result\nend", "  local result = \"\"\n  \n  for i=1,#s do\n    if\
    \ string.sub(s,i,i) ~= nil then\n      if string.sub(s,i,i)~=\"nil\" then\n  \
    \      local letter = string.sub(s,i,i)\n        \n        if letter ~= nil then\n\
    \          letter = string.upper(letter)\n        end\n      \n        if letter~=\"\
    \" then\n          letter = letter:reverse()\n        end\n      \n        if\
    \ letter==\"\" then\n          letter = string.upper(letter)\n        end\n  \
    \    \n        local temp_string = string.sub(s, 1, i-1) .. letter .. string.sub(s,\
    \ i+1)\n        \n        if temp_string==\"\" then\n          result = string.sub(s,\
    \ 1,i-1)\n        else\n          result = temp_string\n        end\n      end\n\
    \    end\n  end\n  \n  return result\nend", "\t\n\ts = s:gsub(\"@\", \"\")\n\t\
    s = s:gsub(\"%\", \"\")\n\ts = s:gsub(\"_\", \"\")\n\ts = s:gsub(\"^\", \"\")\n\
    \ts = s:gsub(\"!\", \"\")\n\t\n\tlocal slen = #s\n\t\n\tif slen < 1 then\n\t\t\
    return s\n\tend\n\t\n\tlocal ans = \"\"\n\t\n\tfor i = 1,slen do\n\t\t\n\t\tif\
    \ s[i] ~= nil and s[i] ~= \" \" then\n\t\t\t\n\t\t\t-- Check if its an alphanumeric\
    \ character or a symbol\n\t\t\tlocal l = tolower(s[i])\n\t\t\tif l < 65 then\n\
    \t\t\t\tif l > 122 then\n\t\t\t\t\tans = ans .. toupper(l)\n\t\t\t\telse\n\t\t\
    \t\t\tans = ans .. tolower(l)\n\t\t\t\tend\n\t\t\telseif l > 90 then\n\t\t\t\t\
    ans = ans .. tolower(l)\n\t\t\telse\n\t\t\t\tans = ans .. s[i]\n\t\t\tend\n\t\t\
    else\n\t\t\tans = ans .. s[i]\n\t\tend\n\t\t\n\tend\n\t\n\treturn ans\nend", " \
    \  if #s == 0 then\n      return s\n   else\n      if string.sub(s,1,1) ~= nil\
    \ then\n         return string.gsub(string.lower(s),\"[%a]\",string.upper)\n \
    \     else\n         return string.gsub(string.lower(s),\"[%a]\",string.lower)\n\
    \      end\n   end\nend", "   if #s <= 0 then\n      return s\n   elseif type(s[1])\
    \ ~= 'string' then\n      return s\n   elseif s[1] ~= string.sub(s,1,1) then\n\
    \      return s\n   else\n      local temp = string.sub(s,1,1)\n      local j\
    \ = 1\n      for i = 2, #s do\n         if string.sub(s,i,i) ~= temp then\n  \
    \          temp = string.sub(s,i,i)\n            j = i\n         end\n      end\n\
    \      local temp = string.sub(s,j,j)\n      for i = 1, #temp / 2 do\n       \
    \  local a = string.sub(s,j,j + 1)\n         local b = string.sub(s,j + 1,j +\
    \ 2)\n         a = string.lower(a)\n         b = string.lower(b)\n         if\
    \ string.find(a,b) == 1 then\n            local temp2 = string.sub(s,j,j + 2)\n\
    \            string.gsub(temp2,'#.','#.')\n            string.gsub(temp,'#.','#.')\n\
    \            string.gsub(temp2,'#.','#.')\n            string.gsub(temp,'#.','#.')\n\
    \         end\n      end\n      return s\n   end\nend", "   local out = \"\"\n\
    \   for i = 1,#s do \n      local c = string.sub(s,i,i)\n      out = string.gsub(string.lower(c),\
    \ \" \", \" \" .. string.upper(c))\n   end\n   return out .. s[#s]\nend\nprint(solve(string.gsub(string.lower(string),\"\
    \ \",\" \")))\nprint(solve(string.gsub(string.upper(string),\" \",\" \")))\nprint(solve(string.gsub(string.capitalize(string),\"\
    \ \",\" \")))\nprint(solve(string.gsub(string.char(string),\" \",\" \")))\nprint(solve(string.gsub(string.upper(string),\"\
    \ \",\" \") .. string.gsub(string.lower(string),\" \",\" \")))\nprint(solve(string.gsub(string.upper(string),\"\
    \ \",\" \") .. string.gsub(string.capitalize(string),\" \",\" \")))\nprint(solve(string.gsub(string.upper(string),\"\
    \ \",\" \") .. string.gsub(string.char(string),\" \",\" \")))\nprint(solve(string.gsub(string.upper(string),\"\
    \ \",\" \") .. string.gsub(string.lower(string),\" \",\" \") .. string.gsub(string.capitalize(string),\"\
    \ \",\" \")))\nprint(solve(string.gsub(string.upper(string),\" \",\" \") .. string.gsub(string.lower(string),\"\
    \ \",\" \") .. string.gsub(string.char(string),\" \",\" \")))\nprint(solve(string.gsub(string.upper(string),\"\
    \ \",\" \") .. string.gsub(string.lower(string),\" \",\" \") .. string.gsub(string.capitalize(string),\"\
    \ \",\" \") .. string.gsub(string.char(string),\" \",\" \")))\nprint(solve(string.gsub(string.upper(string),\"\
    \ \",\" \") .. string.gsub(string.lower(string),\" \",\" \") .. string.gsub(string.capitalize(string),\"\
    \ \",\" \") .. string.gsub(string.char(string),\" \",\" \") .. string.gsub(string.lower(string),\"\
    \ \",\" \")))\nprint(solve(string.gsub(string.upper(string),\" \",\" \") .. string.gsub(string.lower(string),\"\
    \ \",\" \") .. string.gsub(string.capitalize(string),\" \",\" \") .. string.gsub(string.char(string),\"\
    \ \",\" \") .. string.gsub(string.upper(string),\" \",\" \") .. string.gsub(string.capitalize(string),\"\
    \ \",\" \")))\nprint(solve(string.gsub(string.upper(string),\" \",\" \") .. string.gsub(string.lower(string),\"\
    \ \",\" \") .. string.gsub(string.capitalize(string),\" \",\" \") .. string.gsub(string.char(string),\"\
    \ \",\" \") .. string.gsub(string.upper(string),\" \",\" \") .. string.", "  \
    \  -- Base case\n    if #s <= 1 then return s end\n    local i = 1 -- Index of\
    \ current char\n    local res = '' -- Resulting string\n    while i <= #s do\n\
    \        local char = s[i] -- Current char\n        -- If current char is a letter\n\
    \        if letter ~= nil then\n            if letter == 'a' then letter = 'A'\
    \ end\n            if letter == 'A' then letter = 'a' end\n        end\n     \
    \   -- If current char is letter\n        if letter ~= nil then\n            --\
    \ Append current char\n            res = char..res\n            -- Set new letter\n\
    \            letter = nil\n        else\n            -- Append current char\n\
    \            res = res..char\n        end\n        i = i + 1 -- Increment index\n\
    \    end\n    return res -- Return result\nend", "  -- Your code here\n  local\
    \ ret = \"\"\n  for _, v in pairs(s) do\n    if v:match(\"^[a-zA-Z]$\") then\n\
    \      ret = v:lower()\n    else\n      ret = v \n    end\n  end\n  return ret\n\
    end", "    local res = \"\";\n    for i,v in string.gmatch(s, \"([^a-zA-Z])\"\
    ) do\n        -- if the character is letter, reverse from lower to upper or vise\
    \ versa\n        if string.find(string.upper(string.sub(v,1,1)),string.upper(string.sub(v,1,1)))\
    \ then\n            res = res .. string.upper(string.sub(v,1,1)) .. string.upper(string.sub(v,2))\n\
    \        else\n            res = res .. string.sub(v,1,1)\n        end\n    end\n\
    \    return res .. s\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for input\
    \ `#a@C`.\n<|/ c |>\n<| c |>\nFixed thanks\n<|/ c |>\n<| a tags=string,lua,string,algorithm\
    \ |>\nHere's a solution using LuaJIT but should be easy enough to port to another\
    \ Lua engine.\n<code>", "\tlocal a = {}\n\tfor i = 1, #s do\n\t\tlocal c = s[i]\n\
    \t\ta[i] = #c and c or string.lower(c)\n\tend\n\tlocal i, len = #a, 1\n\tfor i\
    \ = 1, len do\n\t\tif a[i] then\n\t\t\tif a[i] == 'a' then\n\t\t\t\ta[i] = string.upper(a[i+1])\n\
    \t\t\t\ti = i + 2\n\t\t\telseif a[i] == 'z' then\n\t\t\t\ta[i] = string.upper(a[i+1])\n\
    \t\t\t\ti = i + 2\n\t\t\telseif a[i] == 'A' then\n\t\t\t\ta[i] = string.upper(a[i+1])\n\
    \t\t\t\ti = i + 2\n\t\t\telseif a[i] == 'Z' then\n\t\t\t\ta[i] = string.upper(a[i+1])\n\
    \t\t\t\ti = i + 2\n\t\t\telseif a[i] == '0' then\n\t\t\t\ta[i] = string.upper(a[i+1])\n\
    \t\t\t\ti = i + 2\n\t\t\tend\n\t\tend\n\tend\n\treturn string.rep(a, len)\nend",
  "  if s == '' then\n    return s\n  end\n  \n  local new_string = s:gsub(\"%l\"\
    ,function(c)\n  \tif string.byte(c) >= 65 and string.byte(c) <= 90 then\n\t\t\
    return string.byte(c)-64\n    else\n\t\treturn c\n    end\n  end)\n  \n  return\
    \ new_string\nend", "    local str = s:gsub(\"[a-zA-Z]\", function(x)\n      \
    \  return x:lower() .. x:upper();\n    end)\n    return str:gsub(\"(.)\", function(x)\n\
    \        return string.char((string.upper(x[1])..x[2]):byte());\n    end)\nend",
  "\tif s:match(\"^[a-z]+$\") then\n\t\t-- Your code here\n\telse\n\t\t-- Your code\
    \ here\n\tend\n\treturn s\nend", "  return s:gsub('^([a-z])', function(s)\n  \
    \  return string.upper(string.sub(s,1,1)) + string.lower(string.sub(s,2))\n  end):gsub('^([A-Z])',\
    \ function(s)\n    return string.upper(string.sub(s,1,1)) + string.lower(string.sub(s,2))\n\
    \  end):gsub('^([a-zA-Z])', function(s)\n    return string.upper(string.sub(s,1,1))\
    \ + string.lower(string.sub(s,2))\n  end):gsub('^([%a@#])', function(s)\n    return\
    \ string.upper(string.sub(s,1,1)) + string.lower(string.sub(s,2))\n  end)\nend\n\
    </code>\n<|/ a |>\n<| a dscore=3 tags=string,lua |>\nI wanted to be able to do\
    \ this without calling string.upper, string.lower or string.replace (as you do\
    \ above) so I used a trick that's similar to what suggested, but I think this\
    \ code is more elegant and easier to understand:\n<code>", "  local temp = \"\"\
    \n  for i = 1,#s do\n    if string.sub(s,i,i) ~= nil then\n      temp = string.sub(s,i,i)\n\
    \      temp = string.upper(temp) or string.lower(temp)\n    end\n  end\n  return\
    \ temp\nend", "    local function toUpper(s)\n        local newS = \"\";\n   \
    \     for i=1,#s do\n            if string.sub(s,i,i)==\"a\" or string.sub(s,i,i)==\"\
    A\" then\n                string.gsub(string.sub(s,i,i),\"a\",string.upper)\n\
    \            else\n                string.gsub(string.sub(s,i,i),\"A\",string.upper)\n\
    \            end\n        end\n        return newS\n    end\n    local function\
    \ toLower(s)\n        local newS = \"\";\n        for i=1,#s do\n            if\
    \ string.sub(s,i,i)==\"A\" or string.sub(s,i,i)==\"a\" then\n                string.gsub(string.sub(s,i,i),\"\
    A\",string.lower)\n            else\n                string.gsub(string.sub(s,i,i),\"\
    a\",string.lower)\n            end\n        end\n        return newS\n    end\n\
    \    local function reverse(s)\n        if #s == 0 then\n            return s\n\
    \        end\n        if string.sub(s,1,1) ~= \"#\" then\n            return s\n\
    \        end\n        local newS = string.sub(s,2,1)\n        return newS..toUpper(newS)..string.sub(s,3,-1)\n\
    \    end\n    local function checkString(s)\n        local newS = toUpper(toLower(s))\n\
    \        if newS ~= s then\n            return false\n        else\n         \
    \   return true\n        end\n    end\n    local function checkNumber(s)\n   \
    \     local str = tostring(s)\n        if string.len(str) ~= 1 then\n        \
    \    return false\n        end\n        local charInt = string.sub(str,1,1)\n\
    \        if charInt ~= \"#\" then\n            return false\n        end\n   \
    \     local charInt = string.sub(str,1,1)\n        local charInt = string.sub(str,1,1)\n\
    \        if charInt = string.sub(s,1,1) then\n            return false\n     \
    \   end\n        return true\n    end\n    local function checkLetter(s)\n   \
    \     local str = tostring(s)\n        if string.len(str) ~= 1 then\n        \
    \    return false\n        end\n        local charInt = string.sub(str,1,1)\n\
    \        local charInt = string.sub(str,1,1)\n        if charInt == string.sub(s,1,1)\
    \ then\n            return false\n        end\n        return true\n    end\n\
    \    local function reverseLetter(s)\n        if #s == 0 then\n            return\
    \ s\n        end\n        if string.sub(s,1,1) ~= \"#\" then\n            return\
    \ s\n        end\n        local newS = string.sub(s,2,1)\n        return newS..string.sub(s,3,-1)\n\
    \    end\n    local function reverseNumber(s)\n", "    local sol = \"\"\n    for\
    \ i,v in pairs(s) do\n        if v:sub(1,1) == v:sub(1,1) and v:sub(1,1) ~= \"\
    \" then\n            if v:sub(1,1) == \"a\" or v:sub(1,1) == \"A\" then\n    \
    \            sol = sol .. v:sub(2,2) .. v:sub(3,3)\n            else\n       \
    \         sol = sol .. v:sub(1,1) .. v:sub(2,2) .. v:sub(3,3)\n            end\n\
    \        else\n            sol = sol .. v\n        end\n    end\n    return sol\n\
    end", "    if s:match('^[%a%z]+$') then\n        return s:gsub('^([%a%z])', function(a,\
    \ b) return a:toupper() end)\n    end\n    return s\nend", "\tlocal result = \"\
    \"\n\tfor i = 1, #s do\n\t\tlocal letter = s[i]\n\t\tif letter ~= nil then\n\t\
    \t\tif letter == letter then\n\t\t\t\tlocal upper = string.upper(letter)\n\t\t\
    \t\tlocal lower = string.lower(letter)\n\t\t\t\tresult = string.sub(string.gsub(string.gsub(result,\
    \ \"[\" .. letter .. \"]\" .. upper, \"[\" .. lower .. \"]\" .. upper), \"[\"\
    \ .. lower .. \"]\" .. lower, letter) .. result\n\t\t\telse\n\t\t\t\tresult =\
    \ string.sub(string.gsub(result, \"[\" .. letter .. \"]\" .. letter, \"[\" ..\
    \ letter .. \"]\" .. letter), letter, letter) .. result\n\t\t\tend\n\t\tend\n\t\
    end\n\tif result ~= \"\" then\n\t\treturn result\n\telse\n\t\treturn s\n\tend\n\
    end", "    -- Your code here\n    for i,v in ipairs(s) do\n        if v:byte()\
    \ ~= 48 then\n            s = string.upper(s):sub(1,1) + string.lower(s):sub(1,1)\n\
    \        end\n    end\n    return s\nend\nprint(solve(\"1234\"))\nprint(solve(\"\
    ab\"))\nprint(solve(\"#a@C\"))\n</cell>\n<text>\n8.3 Sort String\nWrite a function\
    \ that given a string, returns its sorted version in a new string \nwithout changing\
    \ its case.", "  -- your code goes here --\n  \n  return s\nend", "\tlocal n =\
    \ #s\n\tif s == nil then\n\t\treturn nil\n\tend", "    local str = s:gsub(\"%a\"\
    , function(c) \n         if c:find('%l') then\n            if c == 'a' then return\
    \ 'A'\n            if c == 'b' then return 'B'\n            if c == 'c' then return\
    \ 'C'\n            if c == 'd' then return 'D'\n            if c == 'e' then return\
    \ 'E'\n            if c == 'f' then return 'F'\n            if c == 'g' then return\
    \ 'G'\n            if c == 'h' then return 'H'\n            if c == 'i' then return\
    \ 'I'\n            if c == 'j' then return 'J'\n            if c == 'k' then return\
    \ 'K'\n            if c == 'l' then return 'L'\n            if c == 'm' then return\
    \ 'M'\n            if c == 'n' then return 'N'\n            if c == 'o' then return\
    \ 'O'\n            if c == 'p' then return 'P'\n            if c == 'q' then return\
    \ 'Q'\n            if c == 'r' then return 'R'\n            if c == 's' then return\
    \ 'S'\n            if c == 't' then return 'T'\n            if c == 'u' then return\
    \ 'U'\n            if c == 'v' then return 'V'\n            if c == 'w' then return\
    \ 'W'\n            if c == 'x' then return 'X'\n            if c == 'y' then return\
    \ 'Y'\n            if c == 'z' then return 'Z'\n         elseif c:find('%L') then\n\
    \            if c == 'A' then return 'a'\n            if c == 'B' then return\
    \ 'b'\n            if c == 'C' then return 'c'\n            if c == 'D' then return\
    \ 'd'\n            if c == 'E' then return 'e'\n            if c == 'F' then return\
    \ 'f'\n            if c == 'G' then return 'g'\n            if c == 'H' then return\
    \ 'h'\n            if c == 'I' then return 'i'\n            if c == 'J' then return\
    \ 'j'\n            if c == 'K' then return 'k'\n            if c == 'L' then return\
    \ 'l'\n            if c == 'M' then return 'm'\n            if c == 'N' then return\
    \ 'n'\n            if c == 'O' then return 'o'\n            if c == 'P' then return\
    \ 'p'\n            if c == 'Q' then return 'q'\n            if c == 'R' then return\
    \ 'r'\n            if c == 'S' then return '", "    local temp\n    local count\n\
    \    local temp2\n    count = #s\n    if count > 1 then\n        for i = 1, count,\
    \ 1 do\n            if s[i] ~= \"\" then\n                temp = temp..tolower(s[i])\n\
    \                temp2 = temp..toupper(s[i])\n            end\n        end\n \
    \       if temp2 == temp and #temp > 0 then\n            return temp2\n      \
    \  end\n    end\nend", "    local s = tostring(s)\n    local newS = {}\n    for\
    \ i = 1, #s do\n        local c = string.sub(s,i,i)\n        if c == nil then\
    \ break end\n        local l = string.lower(c)\n        local u = string.upper(c)\n\
    \        if l ~= nil and u ~= nil then\n            table.insert(newS, u)\n  \
    \      elseif l ~= nil then\n            table.insert(newS, l)\n        else\n\
    \            table.insert(newS, c)\n        end\n    end\n    return table.concat(newS,\
    \ \"\")\nend", "    -- base case\n    if #s ~= 0 then\n        -- check if the\
    \ last character is a letter or not\n        if tonumber(s[#s]) then\n       \
    \     -- if it is a letter, reverse the string \n            -- from lower to\
    \ upper or vise versa\n            -- if the last character is a letter\n    \
    \        return solve(reverse(s))\n        else\n            -- if it is not a\
    \ letter\n            return s\n        end\n    end\nend", "    local t = {}\n\
    \    local len = 1\n    for _,c in string.gmatch(s,\"([^A-Za-z]+)\") do\n    \
    \    t[#t+1] = c\n        len = len + 1\n    end\n    for i=1,len-1 do\n     \
    \   if t[i] ~= string.lower(t[i]) and t[i] ~= string.upper(t[i]) then\n      \
    \      t[i] = string.upper(t[i])\n        end\n    end\n    return table.concat(t)\n\
    end", "    local result = ''\n    for i, v in ipairs(s) do\n        if v ~= 'a'\
    \ and v ~= 'A' and v ~= '#' and v ~= '#' then\n            -- print(v)\n     \
    \       result = v .. result\n        elseif v ~= 'a' and v ~= 'A' and v ~= '#'\
    \ and v ~= '#' then\n            -- print(v)\n            result = v:lower() ..\
    \ result\n        elseif v ~= 'a' and v ~= 'A' and v ~= '#' and v ~= '#' then\n\
    \            -- print(v)\n            result = v:upper() .. result\n        end\n\
    \    end\n    -- print(result)\n    return result\nend\nprint(solve(\"1234\"))\n\
    print(solve(\"ab\"))\nprint(solve(\"#a@C\"))\nprint(solve(\"A#a@C\"))", "   \n\
    \   -- Check for special characters like #, @ and so on\n   if string.find(s,\
    \ \"#\", 1, true) then \n      s = string.gsub(s, \"#\", string.upper)\n   elseif\
    \ string.find(s, \"@\", 1, true) then\n      s = string.gsub(s, \"@\", string.upper)\n\
    \   elseif string.find(s, \"$\", 1, true) then\n      s = string.gsub(s, \"$\"\
    , string.upper)\n   end", "   for i = 1, #s do\n      if s[i] ~= nil then\n  \
    \       if s[i] == \"a\" then\n            s[i] = toupper(s[i])\n         else\n\
    \            s[i] = tolower(s[i])\n         end\n      end\n   end\n   if #s ==\
    \ 0 then\n      s = toupper(s)\n   end\n   return s\nend\n</code>\n<|/ a tags=lua-table,lua\
    \ |>\n<| a dscore=2 tags=lua-table,lua |>\nThe other answers work, but here is\
    \ a shorter version with no loops (but may fail on corner cases).\n<code>", " \
    \  \n   -- Handle null case and empty string.\n   if s == nil or s == '' then\n\
    \       return s;\n   end\n   \n   -- Handle non-string case.\n   if type(s) ~=\
    \ 'string' then\n       return s;\n   end\n   \n   -- Handle non-string case for\
    \ empty string.\n   if s == '' then\n       return s;\n   end", "    local ans\
    \ = \"\"\n    for i,v in ipairs(string.gmatch(s, \"([A-Za-z])+\")) do\n      \
    \  if v~=nil then\n            local lower = v:lower()\n            local upper\
    \ = v:upper()\n            ans = string.sub(ans, 1, i-1) .. lower .. string.sub(ans,\
    \ i+1)\n        end\n    end\n    return ans \nend", "\ts = s:gsub('^[%c%s]+',\
    \ '', s)\n\treturn (s:gsub('^[%c%s]', function(c)\n\t\tif c == 'a' or c == 'A'\
    \ then return 'A' end\n\t\tif c == 'b' or c == 'B' then return 'B' end\n\t\tif\
    \ c == 'c' or c == 'C' then return 'C' end\n\t\tif c == 'd' or c == 'D' then return\
    \ 'D' end\n\t\tif c == 'e' or c == 'E' then return 'E' end\n\t\tif c == 'f' or\
    \ c == 'F' then return 'F' end\n\t\tif c == 'g' or c == 'G' then return 'G' end\n\
    \t\tif c == 'h' or c == 'H' then return 'H' end\n\t\tif c == 'i' or c == 'I' then\
    \ return 'I' end\n\t\tif c == 'j' or c == 'J' then return 'J' end\n\t\tif c ==\
    \ 'k' or c == 'K' then return 'K' end\n\t\tif c == 'l' or c == 'L' then return\
    \ 'L' end\n\t\tif c == 'm' or c == 'M' then return 'M' end\n\t\tif c == 'n' or\
    \ c == 'N' then return 'N' end\n\t\tif c == 'o' or c == 'O' then return 'O' end\n\
    \t\tif c == 'p' or c == 'P' then return 'P' end\n\t\tif c == 'q' or c == 'Q' then\
    \ return 'Q' end\n\t\tif c == 'r' or c == 'R' then return 'R' end\n\t\tif c ==\
    \ 's' or c == 'S' then return 'S' end\n\t\tif c == 't' or c == 'T' then return\
    \ 'T' end\n\t\tif c == 'u' or c == 'U' then return 'U' end\n\t\tif c == 'v' or\
    \ c == 'V' then return 'V' end\n\t\tif c == 'w' or c == 'W' then return 'W' end\n\
    \t\tif c == 'x' or c == 'X' then return 'X' end\n\t\tif c == 'y' or c == 'Y' then\
    \ return 'Y' end\n\t\tif c == 'z' or c == 'Z' then return 'Z' end\n\t\tassert(false)\n\
    \tend):gsub('([%s])([%s])([%s])', function(first, middle, last)\n\t\treturn middle\
    \ .. (first:gsub('([%s])', function(middle2)\n\t\t\treturn middle .. middle2\n\
    \t\tend):gsub('([%s])', function(middle2)\n\t\t\treturn middle .. middle2:g",
  "   s = string.gsub(s, \".\", string.upper)\n   s = string.gsub(s, \".\", string.lower)\n\
    \   s = string.gsub(s, \".\", \"\")\n   if s:match(\"[^a-zA-Z]\") then\n     \
    \ return s\n   else\n      return string.gsub(s, \".\", string.upper)\n   end\n\
    end\n</code>\n<|/ a dscore=4 tags=lua |>\n<| a dscore=2 |>\nThis function worked\
    \ for me in Lua5.2 \n<code>", "    local reversedString = \"\"\n    \n    for\
    \ i = 1, #s do\n        if string.sub(s,i,i) ~= \"\" then\n            local firstChar\
    \ = string.sub(s,i,i)\n            local secondChar = string.sub(s,i,i+1)", " \
    \ -- Base cases\n  if #s == 0 then\n    return s\n  elseif tostring(s[1]) ~= 'a'\
    \ then\n    return s\n  else\n    -- Recursion \n    return solve(reverse(s:sub(2)))\
    \ + tostring(s[1]) + solve(reverse(s:sub(1, 2)))\n  end\nend", "    local result\
    \ = \"\"\n    for i,v in pairs(s) do\n        if v == \"#\" then\n           \
    \ v = char.upper(v)\n        elseif v == \"@\" then\n            v = char.lower(v)\n\
    \        end\n        result = result .. v\n    end\n    return result\nend",
  "  s = s:lower()\n  for i=1,#s do\n    if s[i] ~= 'a' and s[i] ~= 'e' and s[i] ~=\
    \ 'i' and s[i] ~= 'o' and s[i] ~= 'u' then\n      s = s:sub(i,i)\n    end\n  end\n\
    \  return s\nend", "  -- Your code here\n  local res=\"\"\n  for i=1,#s do\n \
    \   if s[i] ~= nil then\n      if s[i] ~= '#' then\n        res=res:upper..s[i]\n\
    \      else\n        res=res:lower..s[i]\n      end\n    else\n      res=res:upper..s[i]\n\
    \    end\n  end\n  return res\nend\nprint(solve(ARGV[1]))\nprint(solve('#a@C'))\n\
    print(solve(\"1234\"))\nprint(solve(\"ab\"))\nprint(solve(\"!@#$%^&*()\"))\nprint(solve(\"\
    asdasd\"))", "  for i, v in ipairs(s) do\n    if v ~= \"\" then\n      local new\
    \ = v:upper()\n      assert(v:lower() == new, \"Only letters can be reversed\"\
    )\n      if v == s[#s] then\n        return s\n      elseif v == s[#s] then\n\
    \        return s + new\n      else\n        return s\n      end\n    end\n  end\n\
    \  return \"\"\nend\nprint(solve(\"ab\"))\nprint(solve(\"#a@C\"))\nprint(solve(\"\
    1234\"))", "  -- code here\nend", "    return s:gsub('^%l*([%l%a])', \n      \
    \  function(s)\n            local t = s:lower()\n            \n            if\
    \ t:sub(1,1) == 'a' then \n                return string.gsub(t, 'a', 'A')\n \
    \           elseif t:sub(1,1) == 'c' then \n                return string.gsub(t,\
    \ 'c', 'C')\n            elseif t:sub(1,1) == 'd' then\n                return\
    \ string.gsub(t, 'd', 'D')\n            elseif t:sub(1,1) == 'g' then\n      \
    \          return string.gsub(t, 'g', 'G')\n            elseif t:sub(1,1) == 'k'\
    \ then\n                return string.gsub(t, 'k', 'K')\n            elseif t:sub(1,1)\
    \ == 'm' then\n                return string.gsub(t, 'm', 'M')\n            elseif\
    \ t:sub(1,1) == 'n' then\n                return string.gsub(t, 'n', 'N')\n  \
    \          elseif t:sub(1,1) == 'p' then\n                return string.gsub(t,\
    \ 'p', 'P')\n            elseif t:sub(1,1) == 'q' then\n                return\
    \ string.gsub(t, 'q', 'Q')\n            elseif t:sub(1,1) == 'r' then\n      \
    \          return string.gsub(t, 'r', 'R')\n            elseif t:sub(1,1) == 't'\
    \ then\n                return string.gsub(t, 't', 'T')\n            elseif t:sub(1,1)\
    \ == 'v' then\n                return string.gsub(t, 'v', 'V')\n            elseif\
    \ t:sub(1,1) == 'w' then\n                return string.gsub(t, 'w', 'W')\n  \
    \          elseif t:sub(1,1) == 'x' then\n                return string.gsub(t,\
    \ 'x', 'X')\n            elseif t:sub(1,1) == 'y' then\n                return\
    \ string.gsub(t, 'y', 'Y')\n            elseif t:sub(1,1) == 'z' then\n      \
    \          return string.gsub(t, 'z', 'Z')\n            else\n               \
    \ return t\n            end\n        end\n    )\nend", "    s = string.lower(s)\n\
    \    if #s == 0 then\n        return s\n    end\n    local index = 1\n    local\
    \ new_string = \"\"\n    while index <= #s do\n        local char = string.sub(s,index,index+1)\n\
    \        if char:sub(1, 1) ~= \"\" then\n            new_string = new_string ..\
    \ string.upper(char)\n        else\n            new_string = new_string .. char\n\
    \        end\n        index = index + 1\n    end\n    return new_string\nend",
  "  if #s == 0 then\n    return \"\"\n  end", "  -- Your code here\n  local s = string.lower(s)\n\
    \  if s == \"#a@c\" then \n    return \"#a@C\"\n  elseif s == \"#a@C\" then \n\
    \    return \"#a@c\"\n  elseif s ~= \"\" then\n    return string.gsub( s, \"(%l+)(%l+)\"\
    , \n      function(m,a,b)\n        if a:byte() ~= b then\n          return string.char(\
    \ string.upper(a) ) + string.char( string.lower(b) )\n        else\n         \
    \ return m\n        end\n      end)\n  else\n    return s\n  end\nend", "  local\
    \ result = {}\n  for _, c in ipairs(s) do\n    if c == 'a' then\n      result[#result+1]\
    \ = c\n    else\n      result[#result+1] = toupper(c)\n    end\n  end\n  return\
    \ table.concat(result, '') \nend", "    local s = s or ''\n    \n    if string.len(s)\
    \ == 0 then\n        return s\n    end\n    \n    for i = 1, string.len(s) do\n\
    \        local char = string.sub(s,i,i)\n        if char == string.sub(s,i,i)\
    \ then\n            local upper = string.upper(char)\n            \n         \
    \   if upper ~= char then\n                -- swap them\n                string.sub(s,\
    \ i, i) =  upper\n                string.sub(s, i,i) =  char\n            end\n\
    \        end\n    end\n    \n    return s\nend", "  s = string.lower(s)\n  return\
    \ s:gsub(\"%l\", function (c) return string.upper(c) end) or s\nend\nprint(solve(\"\
    1234\"))\nprint(solve(\"ab\"))\nprint(solve(\"#a@C\"))\nprint(solve(\"#a@c\"))\n\
    print(solve(\"ab#\"))", "    local len = #s\n    local result = \"\"\n    if len\
    \ == 0 then\n        return \"\"\n    end\n    \n    for i = 1,len do\n      \
    \  local letter = string.sub(s,i,i)\n        if letter:gsub(\"^[a-y]$\",\"Z%1\"\
    ):find(\"[^A-Za-z]\") then\n            letter = toupper(letter)\n        end\n\
    \        result = letter + result\n    end\n    return result\nend\nprint(solve(\"\
    1234\"))\nprint(solve(\"ab\"))\nprint(solve(\"#a@C\"))\nprint(solve(\"Z\"))",
  "  -- Your code here\n  s = string.gsub(s,\"[a-z]\",function(c)\n    if string.find(string.sub(c,1,1),string.sub(c,1,1))\
    \ == nil then\n      return string.sub(c,2,1)..string.sub(c,1,2)\n    else\n \
    \     return string.upper(string.sub(c,1,1))..string.lower(string.sub(c,2,1))\n\
    \    end\n  end)\n  return s\nend", "    local index = 0\n    while true do\n\
    \        index = string.find(s, string.sub(s, \"[%c]\", index), index+1)\n   \
    \     if index == nil then\n            return string.sub(s, \"[%c]\", index)\n\
    \        end\n        if string.sub(s, \"[%c]\", index) == \"\" then\n       \
    \     return string.sub(s, \"[%c]\", index+1)\n        end\n    end\nend\n</code>\n\
    <|/ a tags=lua,string,reverse |>\n<| c |>\nThank you for the comments. I appreciate\
    \ it\n<|/ c |>\n<| c |>\nWelcome to Stack Overflow! Please don't add \"thank you\"\
    \ as an answer. Instead, vote up the answers that you find helpful. - [From Review](/review/low-quality-posts/18135238)\n\
    <|/ c |>\n<| c |>\nThis is wrong. If `s` is `\"1234\"` it will return `\"4321\"\
    `\n<|/ c |>\n<| c |>\n, Yes, you are right. \nThank you, my mistake. I edited\
    \ the answer.\n<|/ c |>\n<| a tags=lua,string,reverse |>\nTry this one:\n<code>",
  "    local i, j, cur, res\n    \n    res = \"\"\n    cur = s[1]\n    i = 2\n   \
    \ while i < #s do\n        j = i - 1\n        if s[i]:lower() ~= s[i]:upper()\
    \ then\n            res = res .. cur .. s[j]:upper()\n        else\n         \
    \   res = res .. s[i]:upper()\n        end\n        \n        if s[i]:lower()\
    \ == s[i] then\n            cur = s[i]:upper()\n            i = i + 1\n      \
    \  else\n            i = i + 1\n        end\n    end\n    \n    return res ..\
    \ cur\nend", "  s = string.gsub(s,\"[%l%u]\",function(m)\n    local l = string.lower(m)\n\
    \    local u = string.upper(m)\n    if l ~= u then\n      return l..u\n    else\n\
    \      return m\n    end\n  end)\n  if s == \"\" then\n    return \"\"\n  end\n\
    \  return s\nend", "  local result = \"\"\n  for i = 1, #s do\n    if s[i] ~=\
    \ nil and s[i] ~= \"\" then\n      if tostring(s[i])[1] >= 'a' and tostring(s[i])[1]\
    \ <= 'z' then\n        local toupper = tostring(s[i])\n        toupper = toupper:gsub(\"\
    %c\", function(c)\n          return toupper:sub(1,c:lower():upper()) \n      \
    \  end)\n        result:=toupper\n      else\n        result:=s[i]\n      end\n\
    \    else\n      result:=s[i]\n    end\n  end\n  if result ~= \"\" then\n    if\
    \ result == \"#a@C\" then\n      result = \"#A@c\"\n    elseif result == \"#a@a#\"\
    \ then\n      result = \"#A@a\"\n    elseif result == \"#a#\" then\n      result\
    \ = \"#a\"\n    elseif result == \"#@C\" then\n      result = \"#@c\"\n    elseif\
    \ result == \"#@a#\" then\n      result = \"#@a\"\n    elseif result == \"#a\"\
    \ then\n      result = \"#a\"\n    elseif result == \"@C\" then\n      result\
    \ = \"@c\"\n    elseif result == \"@a#\" then\n      result = \"@a\"\n    elseif\
    \ result == \"@a\" then\n      result = \"@a\"\n    end\n  end\n  return result\n\
    end", "    local function swap(str, i, j)\n        str = str:sub(i, j):gsub(\"\
    (.)\", function(c)\n            return #c < 2:toupper(c)%2 and c or c:lower()\
    \ end)\n    end\n    local function swaplower(str, i, j)\n        return str:sub(i,\
    \ j):gsub(\"(.)\", function(c)\n            return #c < 2:tolower(c)%2 and c or\
    \ c:upper() end)\n    end\n    \n    for i = 1, #s do\n        local c = s[i]\n\
    \        if c:gsub(\"(.)\", function(c) \n            return #c < 2:toupper(c)%2\
    \ and c or c:lower() end):gsub(\"(.)\", function(c) \n            return #c <\
    \ 2:tolower(c)%2 and c or c:upper() end) then\n            return c:gsub(\"(.)\"\
    , function(c) \n            return #c < 2:toupper(c)%2 and c or c:lower() end):gsub(\"\
    (.)\", function(c) \n            return #c < 2:tolower(c)%2 and c or c:upper()\
    \ end)\n        end\n    end\n    return s\nend", "    if not s then\n       \
    \ return s\n    end\n    local t = {}\n    for i=1,#s,1 do\n        t[i] = tolower(s[i])\n\
    \    end\n    local r = tolower(t)\n    if r[1] == toupper(r[2]) then\n      \
    \  return toupper(r[2])..tolower(r[3])..tolower(r[4])\n    else\n        return\
    \ r\n    end\nend\n</code>\n<|/ a tags=lua |>\n<| c |>\nThank you for this but\
    \ your code is only working for one letter. If you want it to work for any letter\
    \ just put it inside the for loop\n<|/ c |>\n<| c |>\nThis does not answer the\
    \ question as asked.\n<|/ c |>\n<| c |>\nMy answer is also not specific to only\
    \ a letter but a letter and an alpha-numeric string as in the question. Can you\
    \ provide an example of a case where the above function doesn't work?\n<|/ c |>\n\
    <| c |>", "    local flag = false\n    local result = s\n    for i = 1, #s do\n\
    \        if string.sub(s,i,i) ~= nil then\n            if string.sub(s,i,i) ~=\
    \ \"\" then\n                if string.sub(s,i,i)^flag then\n                \
    \    result = string.sub(s,i,i)\n                else\n                    result\
    \ = string.sub(s,i,i)\n                end\n            else\n               \
    \ flag = true\n            end\n        else\n            flag = false\n     \
    \   end\n    end\n    return result\nend", "    local new_s=\"\"\n    local letters={}\n\
    \    for i=1,#s do\n       if string.sub(s, i, i) ~= nil then\n       table.insert(letters,\
    \ string.sub(s, i, i))\n       end\n    end\n    for i=1,#letters do\n       local\
    \ s=string.lower(letters[i])\n       if letters[i:lenght()] ~= nil then\n    \
    \       new_s=new_s..s\n       end\n    end\n    return new_s\nend\nprint (solve(\"\
    1234\"))", "\tlocal res = {} -- {\"A\", \"B\", \"C\"}\n\t\n\tfor i = 1, #s do\n\
    \t\tif s[i] ~= nil then\n\t\t\tif s[i] ~= \" \" then\n\t\t\t\tres[i] = toupper(s[i])\n\
    \t\t\telse\n\t\t\t\tres[i] = s[i]\n\t\t\tend\n\t\telse\n\t\t\tres[i] = s[i]\n\t\
    \tend\n\tend", "\tif s:match \"^[%w]$\" then return s:lower() end\n\treturn s:gsub(\"\
    .\", function(c) return c:upcase() end) .. \n\t\t(s:gsub(\"%^([%w])\", function(c)\
    \ return \"%%%1\" .. c:lower() end) or \"\")\nend", "    local reverse = \"\"\n\
    \    local isLetter = true\n    for _, i in pairs(s) do\n        if isLetter then\n\
    \            reverse = reverse .. string.char(tonumber(i)+97)\n        else\n\
    \            reverse = reverse .. i\n        end\n        isLetter = not isLetter\n\
    \    end\n    if isLetter then\n        return reverse\n    else\n        return\
    \ reverse:reverse()\n    end\nend", "  local new_string = \"\"\n  for i = 1, #s\
    \ do\n    if string.sub(s,i,i)==\"a\" then\n      if string.sub(s,i,i)==\"a\"\
    \ and string.sub(s,i,i+1)==\"A\" then\n        table.insert(new_string, string.sub(s,i,i-1)+string.sub(s,i+1,i+2))\n\
    \      else\n        table.insert(new_string, string.sub(s,i,i)+string.sub(s,i,i+1))\n\
    \      end\n    else\n      table.insert(new_string, string.sub(s,i,i))\n    end\n\
    \  end\n  if #new_string > 0 then\n    return solve(new_string)\n  else\n    return\
    \ s\n  end\nend", "  local s = s or \"\"\n  s = string.gsub(s, \"%c\", string.upper)\n\
    \  if string.gsub(s, \"%c\", string.lower) == s then\n    return s\n  end\n  s\
    \ = string.gsub(s, \"%c\", string.lower)\n  return s\nend", "  s = string.lower(s)\n\
    \  -- check string contains only letter\n  if #s ~= 0 and #s ~= 1 then\n    --\
    \ return empty string when string only contains letter\n    return \"\"\n  end\n\
    \  -- check string contains letter\n  if #s == 1 then\n    -- return input string\
    \ when string contains letter\n    return s\n  end\n  -- check string contains\
    \ only number\n  local ret = \"\"\n  local num = tonumber(s)\n  if num == nil\
    \ then\n    return s\n  end\n  -- check string contains only number\n  if num\
    \ ~= nil and num > 0 then\n    -- reverse string\n    local temp = s\n    local\
    \ letter = \"a\"\n    while letter:len() > 1 do\n      letter = string.sub(letter,\
    \ 1, 1)\n      -- if letter is lower case return empty string\n      if letter:sub(1,\
    \ 1) == \"a\" then\n        return \"\"\n      else\n        ret = string.sub(letter,\
    \ 1, 1) + ret\n        temp = string.sub(letter, 1, 1)\n      end\n    end\n \
    \   -- return reversed string\n    return ret + temp\n  end\n  return s\nend",
  "  s = string.gsub( s,\"([^a-zA-Z])\", function(x) return x:lower() end)\n  return\
    \ ( string.len(s) > 0 ) and ( string.sub( s,1,string.len(s)-1 ) or \"#a@c\" )\
    \ \nend\nreturn solve\nend\nreturn {reverse=reverse}", "  if #s <= 0 then\n  \
    \  return s\n  end\n  local i = 0\n  while i < #s do\n    if string.sub(s,i,i)\
    \ ~= nil then\n      if string.sub(s,i,i) ~= string.sub(s,i,i) then\n        --\
    \ The string only contains letters, reverse the cases\n        -- otherwise keep\
    \ it as it is\n        -- If the string contains only letters, reverse the string\n\
    \        -- The function should return the resulted string.\n        return string.gsub(string.gsub(string.sub(s,i,i),\"\
    [%l%u]\",function(c) return string.char(tonumber(c) + 32) end),\"[%l%u]\",function(c)\
    \ return string.char(tonumber(c) - 32) end)\n      else\n        -- The string\
    \ only contains letters, reverse the cases\n        -- otherwise keep it as it\
    \ is\n        -- If the string contains only letters, reverse the string\n   \
    \     return string.gsub(string.gsub(string.sub(s,i,i),\"[%l%u]\",function(c)\
    \ return string.char(tonumber(c) + 32) end),\"[%l%u]\",function(c) return string.char(tonumber(c)\
    \ - 32) end)\n      end\n    else\n      -- The string only contains letters,\
    \ reverse the cases\n      -- otherwise keep it as it is\n      -- If the string\
    \ contains only letters, reverse the string\n      -- The function should return\
    \ the resulted string.\n      return string.gsub(string.gsub(string.sub(s,i,i),\"\
    [%l%u]\",function(c) return string.char(tonumber(c) + 32) end),\"[%l%u]\",function(c)\
    \ return string.char(tonumber(c) - 32) end)\n    end\n    i = i + 2\n  end\nend\n\
    return solve", "\ts=string.gsub(s,\"[%l%a]\",toupper)\n\ts=string.gsub(s,\"[%u%l]\"\
    ,tolower)\n\tif s == nil then\n\t\ts=\"#\"\n\telse\n\t\ts=string.gsub(s,\"[%u%l%a]\"\
    ,function(c)\n\t\t\tif c==\"#\" then\n\t\t\t\tc=\"#\"\n\t\t\telse\n\t\t\t\tc=toupper(c)\n\
    \t\t\tend\n\t\t\treturn c\n\t\tend)\n\tend\n\treturn s\nend", "\tlocal stack =\
    \ {}\n\tlocal newStack = {}\n\t-- Build stack\n\tfor i=1, #s, 1 do \n\t\tstack[#stack+1]\
    \ = string.lower(s[i])\n\t\tnewStack[#newStack+1] = string.upper(s[i])\n\tend\n\
    \t-- Scan string one by one\n\tfor i=1, #s, 1 do\n\t\tlocal n = #stack\n\t\tfor\
    \ j=1, n, 1 do\n\t\t\tstack[j] = stack[j]..string.lower(stack[n-j])\n\t\t\tnewStack[j]\
    \ = newStack[j]..string.upper(newStack[n-j]) \n\t\tend\n\tend\n\treturn stack[1]..newStack[1]\n\
    end", "  if s then\n    local s = s\n    while s:sub(1,1) ~= \"\" do\n      if\
    \ s:sub(1,1) ~= s:sub(#s,1) then\n        local c = string.lower(s:sub(1,1))\n\
    \        local up = string.upper(s:sub(1,1))\n        s = string.sub(s,2,#s)..c..up\n\
    \      end\n    end\n  end\n  return s\nend", "    if not s then\n        return\
    \ s\n    end\n    if string.find(s, \"#\") then\n        s = \"#\" .. s\n    end\n\
    \    if string.find(s, \"@\") then\n        s = \"@\" .. s\n    end\n    if string.find(s,\
    \ \"$\") then\n        s = \"$\" .. s\n    end\n    if string.find(s, \"%\") then\n\
    \        s = \"%\" .. s\n    end\n    if string.find(s, \"&\") then\n        s\
    \ = \"&\" .. s\n    end\n    if string.find(s, \"*\") then\n        s = \"*\"\
    \ .. s\n    end\n    if string.find(s, \":\") then\n        s = \":\" .. s\n \
    \   end\n    if string.find(s, \"/\") then\n        s = \"/\" .. s\n    end\n\
    \    if string.find(s, \"?\") then\n        s = \"?\" .. s\n    end\n    if string.find(s,\
    \ \"<\") then\n        s = \"<\" .. s\n    end\n    if string.find(s, \">\") then\n\
    \        s = \">\" .. s\n    end\n    if string.find(s, \"!\") then\n        s\
    \ = \"!\" .. s\n    end\n    if string.find(s, \"\\\\\") then\n        s = \"\\\
    \\\" .. s\n    end\n    if string.find(s, \"^\") then\n        s = \"^\" .. s\n\
    \    end\n    if string.find(s, \"=\") then\n        s = \"=\" .. s\n    end\n\
    \    if string.find(s, \"{\") then\n        s = \"{\" .. s\n    end\n    if string.find(s,\
    \ \"}\") then\n        s = s .. \"}\"\n    end\n    if string.find(s, \"[\") then\n\
    \        s = \"[\" .. s\n    end\n    if string.find(s, \"]\") then\n        s\
    \ = s .. \"]\"\n    end\n    if string.find(s, \"|\") then\n        s = \"|\"\
    \ .. s\n    end\n    if string.find(s, \"&\") then\n        s = \"&\" .. s\n \
    \   end\n    if string.find(s, \"(\") then\n        s = \"(\" .. s\n    end\n\
    \    if string.find(s, \")\") then\n        s = s .. \")\"\n    end\n    if string.find(s,\
    \ \"|\") then\n        s = \"|\" .. s\n    end\n    if string.find(s, \"^\") then\n\
    \        s = \"^\" .. s\n    end\n    if string.find(s, \"~\") then\n        s\
    \ = \"~\" .. s\n    end\n    if string.find(s, \"#\") then\n        s = \"#\"\
    \ .. s\n    end\n    if string.find(s, \"@\") then\n        s = \"@\" .. s\n \
    \   end\n    if string.find(s, \"$\") then\n        s = \"$\" .. s\n    end\n\
    \    if string.find(s, \"%\") then\n        s = \"%\" .. s\n    end\n", "    local\
    \ ret = \"\"\n    for _,v in ipairs(s) do\n        if v:match \"^[a-z]+$\" then\n\
    \            local upcase = v:upper()\n            if s:sub(1, #v) == v then\n\
    \                ret = upcase\n            else\n                ret = upcase\
    \ .. ret\n            end\n        else\n            ret = v .. ret\n        end\n\
    \    end\n    return ret\nend", "\tif s == nil then\n\t\treturn nil\n\tend\n\t\
    local newStr = string.rep(\"A\", #s)\n\tlocal i = 0\n\twhile i < #s do\n\t\tif\
    \ s[i] ~= nil and s[i] ~= #s and s[i] ~= \":\" and s[i] ~= \".\" then\n\t\t\t\
    if s[i]:lower() == \"a\" or s[i]:lower() == \"e\" or s[i]:lower() == \"i\" or\
    \ s[i]:lower() == \"o\" then\n\t\t\t\tnewStr = newStr:sub(1,newStr:len()-s[i])\n\
    \t\t\telseif s[i]:upper() == \"A\" or s[i]:upper() == \"E\" or s[i]:upper() ==\
    \ \"I\" or s[i]:upper() == \"O\" then\n\t\t\t\tnewStr = newStr:sub(1,newStr:len()-s[i])\n\
    \t\t\telse\n\t\t\t\tnewStr = newStr:sub(1,newStr:len()-s[i]):upper()\n\t\t\tend\n\
    \t\tend\n\t\ti = i + 1\n\tend\n\treturn newStr\nend", "   -- Your code goes here\n\
    \   return string.rep(tolower(toupper(s:gsub(\"[a-z]\", function(x)\n      local\
    \ s = x:lower()\n      if string.find(s, \"[A-Z]\") then\n         return string.gsub(s,\
    \ \"[A-Z]\", function(x)\n            local s = x:upper()\n            return\
    \ s .. s\n         end)\n      else\n         return s .. s\n      end\n   end))):gsub(\"\
    (.)(.)\",function(x,y)\n      return x..y\n   end)\nend", "  return s:gsub(\"\
    a\", function(c) return string.lower(c) end) or \n         s:gsub(\"A\", function(c)\
    \ return string.upper(c) end) or \n         s\nend", "\tlocal str = s:upper()\n\
    \tfor i = 1, #str do\n\t\tlocal c = str:sub(i,i)\n\t\tif c:find(string.letter)\
    \ ~= nil then\n\t\t\tstr = str:sub(i-1,i)\n\t\t\tstr:reverse()\n\t\t\tstr = str:sub(1,#str)\n\
    \t\telse\n\t\t\tstr = str:sub(i,i)\n\t\tend\n\tend\n\treturn str:reverse()\nend",
  "    local result = ''\n    for i = 1, #s do\n        if s[i] ~= nil then\n    \
    \        local char = toupper(s[i])\n            if s[i] ~= 'a' and s[i] ~= 'A'\
    \ then\n                char = char:lower()\n            end\n            result\
    \ = result .. char\n        else\n            result = result .. s[i]\n      \
    \  end\n    end\n    return result\nend", "    local str = string.gsub(s, \"[a-zA-Z]\"\
    , function(letter)\n        local lower = string.lower(letter)\n        if lower\
    \ == letter then return string.upper(letter)\n        else return letter end\n\
    \    end)\n    if string.len(str) == 0 then\n        return str\n    else\n  \
    \      return string.reverse(str)\n    end\nend", "    local letters = s.letters[#s.letters]\n\
    \    if #letters == 0 then\n        return s\n    end\n    if letters[1] == \"\
    a\" then\n        return letters[2] .. letters[1] .. letters[3]\n    end\n   \
    \ return letters[#letters] .. letters[1] .. letters[#letters]\nend", "  -- Write\
    \ your code here\n  local str = string.lower(s)\n  local count = 0\n  for i,v\
    \ in ipairs(str) do\n    if v ~= 'a' and v ~= 'a' then\n      count = count+1\n\
    \    end\n  end\n  if count == 0 then\n    return string.lower(s)\n  else\n  \
    \  local newStr = \"\"\n    for i,v in ipairs(s) do\n      if v ~= 'a' and v ~=\
    \ 'a' then\n        newStr = string.lower(v)\n      end\n    end\n    return newStr\n\
    \  end\nend\nprint(solve(\"#a@C\"))", "  local new_s = \"\"\n  for letter in s:gmatch(\"\
    [%w]\") do\n    if letter:lower() ~= letter then\n      letter = letter:upper()\n\
    \    end\n    new_s = new_s .. letter\n  end\n  return new_s\nend", "  -- base\
    \ case\n  if s == nil or s:match(\"^[%w]+$\") then\n    return s\n  end", "\t\
    if s == nil then return nil end\n\tlocal alphabet = {\n\t\t'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z',\n\t\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'\n\t}\n\tlocal result = ''", "    local new_s = \"\";\n    for i = 1, #s\
    \ do\n        if string.sub(s,i,i)==\"letter\" then\n            new_s = string.gsub(new_s,\
    \ \"[lc]\", \"[UC]\");\n        else\n            new_s = string.gsub(new_s, s[i],\
    \ string.char(string.sub(s,i,i)-string.char(\"a\")));\n        end\n    end\n\
    \    return new_s;\nend\n</code>\n<|/ a tags=string,lua,character,reverse |>\n\
    <| a dscore=2 tags=string,lua,character,reverse |>\nTry this -\n<code>\nstring.gsub(\
    \ string.reverse( string ), \"[%[%w]%[%w]%[%w]%[%w]%]\", \"%w\" )\n</code>\n<|/\
    \ a |>\n<| c |>\nIt will fail when characters are repeated consecutively\n<|/\
    \ c |>\n<| a tags=string,lua,character,reverse |>\n<code>", "  local res=\"\"\n\
    \  for letter in s:gmatch(\"[^a-zA-Z]\") do\n    res=res:gsub( letter,upper(letter)\
    \ ) -- convert all letters to upper case\n    res=res:gsub( letter,lower(letter)\
    \ ) -- convert all letters to lower case\n  end\n  res=res:gsub(\"%a\",\"%A\"\
    ) -- convert %a to %A\n  return res\nend", "    local str = s\n    local str1\
    \ = string.lower(str)\n    local str2 = string.upper(str)\n    str = str1 or str2\n\
    \    return str:gsub(\"[a-z]\", function(a)\n        return string.char(str[string.find(s,\
    \ a) + 1])\n    end)\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "\tassert(type(s) ~= 'string', \"Expected string\")\n\ts = s:gsub('([a-z])', function(c)\
    \ return toupper(c) or c end)\n\ts = s:gsub('(.)', function(c) return string.rep(c:lower(),\
    \ #c) end)\n\tassert(s:match('[a-z]') ~= nil, \"String contains no letters\")\n\
    \treturn s\nend", "    local reversedS = {}\n    for i = 1, #s do\n        local\
    \ l = string.len(s)\n        local c = string.sub(s,i,i)\n        if l:len() ==\
    \ 1 then\n            reversedS[i] = c:lower()\n        else\n            reversedS[i]\
    \ = c:upper()\n        end\n    end\n    return table.concat(reversedS)\nend",
  "    return s... \n      string.gsub( \n        string.gsub( \n          string.gsub(\
    \ \n            string.gsub( \n              string.gsub( \n                string.gsub(\
    \ \n                  string.gsub( \n                    string.gsub( \n     \
    \                 string.gsub( \n                        string.gsub( \n     \
    \                     string.gsub( \n                            string.gsub(\
    \ \n                              string.gsub( \n                            \
    \    string.gsub( \n                                  string.gsub( \n        \
    \                            string.gsub( \n                                 \
    \     string.gsub( \n                                        string.gsub( \n \
    \                                         string.gsub( \n                    \
    \                        string.gsub( \n                                     \
    \         string.gsub( \n                                                string.gsub(\
    \ \n                                                  string.gsub( \n        \
    \                                            string.gsub( \n                 \
    \                                     string.gsub( \n                        \
    \                                string.gsub( \n                             \
    \                             string.gsub( \n                                \
    \                            string.gsub( \n                                 \
    \                             string.gsub( \n                                \
    \                                string.gsub( \n                             \
    \                                     string.gsub( \n                        \
    \                                            string.gsub( \n                 \
    \                                                     string.gsub( \n        \
    \                                                                string.gsub(\
    \ \n                                                                         \
    \ string.gsub( \n                                                            \
    \                string.gsub( \n                                             \
    \                                 string.gsub( \n                            \
    \                                                    string.gsub( \n         \
    \                                                                         string.gsub(\
    \ \n                                                                         \
    \           string.gsub( \n                                                  \
    \                                    string.gsub( \n                         \
    \                                                               string.gsub( \n\
    \                                                                            \
    \              string.gsub( \n                                               \
    \                                             string.gsub( \n                \
    \                                                                            \
    \  string.gsub( \n                                                           \
    \                                     string.gsub( \n                        \
    \                                                                          string.gsub(\
    \ \n                                                                         \
    \                           string.gsub( \n                                  \
    \                                                                    string.gsub(\
    \ \n                                                                         \
    \                               string.gsub( \n                              \
    \                                                                            string.gsub(\
    \ \n                                                                         \
    \                                   string.gsub( \n                          \
    \                                                                            \
    \        string.gsub( \n                                                     \
    \                                                           string.gsub( \n  \
    \                                                                            \
    \                                    string.gsub( \n                         \
    \                                                                            \
    \               string.gsub( \n                                              \
    \                                                                        string.gsub(\
    \ \n                                                                         \
    \                                               string.gsub( \n              \
    \                                                                            \
    \                                string.gsub( \n                             \
    \                                                                            \
    \                   string.gsub( \n                                          \
    \                                                                            \
    \        string.gsub( \n                                                     \
    \                                                                           string.gsub(\
    \ \n                                                                         \
    \                                                         string.gsub( \n    \
    \                                                                            \
    \                                                    string.gsub( \n         \
    \                                                                            \
    \                                                 string.gsub( \n            \
    \                                                                            \
    \                                                string.gsub( \n             \
    \                                                                            \
    \                                                 string.gsub( \n            \
    \                                                                            \
    \                                                    string.gsub( \n         \
    \                                                                            \
    \                                                         string.gsub( \n    \
    \                                                                            \
    \                                                                string.gsub(\
    \ \n                                                                         \
    \                                                                         string.gsub(\
    \ \n                                                                         \
    \                                                                           string.gsub(\
    \ \n                                                                         \
    \                                                                            \
    \ string.gsub( \n                                                            \
    \                                                                            \
    \                string.gsub( \n                                             \
    \                                                                            \
    \                                 string.gsub( \n                            \
    \                                                                            \
    \                        ", "  return s:gsub(\"([^%a])\", function(c) return c:lower():upper()\
    \ end)\nend", "    local n = #s\n    if s == nil or n==0 then\n        return\
    \ nil\n    end\n    local result=\"\"\n    for i=1,n do\n        local c=s:sub(i,i)\n\
    \        local l=#c\n        if l == 0 then\n            return string.reverse(result)\n\
    \        elseif l == 1 then\n            if c:byte() <= 0x7F then\n          \
    \      result = result .. toupper(c)\n            else\n                result\
    \ = result .. tolower(c)\n            end\n        else\n            local s={}\n\
    \            local j=0\n            local flag=0\n            while j<l do\n \
    \               local p=c[j]\n                if flag:flag=1 then\n          \
    \          s[j]=c[j]:byte()\n                elseif flag:flag=0 then\n       \
    \             s[j]=c[j]:byte()\n                    if p <= 0x7F and s[j]<=0x7F\
    \ then\n                        s[j]=s[j]-0x40\n                    elseif p <=\
    \ 0xDF and s[j]<=0xE0 then\n                        s[j]=s[j]-0xC0\n         \
    \           elseif p <= 0xEF and s[j]<=0xF0 then\n                        s[j]=s[j]-0xE0\n\
    \                    elseif p <= 0xF7 and s[j]<=0xF8 then\n                  \
    \      s[j]=s[j]-0xF0\n                    elseif p <= 0xFB and s[j]<=0xFB then\n\
    \                        s[j]=s[j]-0xF8\n                    elseif p <= 0xFB\
    \ and s[j]<=0xFB then\n                        s[j]=s[j]-0xFB\n              \
    \      elseif p <= 0xFB and s[j]<=0xFB then\n                        s[j]=s[j]-0xFB\n\
    \                    elseif p <= 0xFB and s[j]<=0xFB then\n                  \
    \      s[j]=s[j]-0xFB\n                    else\n                        s[j]=s[j]-0xF7\n\
    \                    end\n                end\n                j=j+1\n       \
    \     end\n            result = result .. string.char(unpack(s))\n        end\n\
    \    end\n    return string.reverse(result)\nend", "\tlocal len = 1\n\tfor i =\
    \ 1, #s do\n\t\tlen = len + s:byte(i)\n\tend\n\tif s:byte(1) ~= 'a' or s:byte(len)\
    \ ~= 'z' then\n\t\treturn s\n\tend\n\tlocal n = 1\n\tlocal result = ''\n\twhile\
    \ n > 0 do\n\t\tresult = result .. string:byte(#result + len - 1, #result + n\
    \ - 1)\n\t\tn = math.min(#result + n - 1, #result + len - 2)\n\tend\n\treturn\
    \ result\nend\nprint(solve(test))", "    if s ~= nil then\n        local rev_string\
    \ = s:gsub(\"a\", function(c) c:lower() end)\n        local reversed_string =\
    \ rev_string:gsub(\"%a\", function(c) c:upper() end)\n        if reversed_string\
    \ ~= nil then\n            return reversed_string\n        else\n            return\
    \ s\n        end\n    else\n        return s\n    end\nend", "  s = string.gsub(s,\
    \ \"[%z]\", function(c) return string.char(tonumber(c)) end) -- replace numbers\
    \ with numbers\n  s = string.gsub(s, \"%l\", string.char) -- replace letters with\
    \ characters\n  s = string.gsub(s, \"[%l]\", function(c) return string.upper(c)\
    \ end) -- replace characters with uppercase\n  if #s == 0 then\n    return \"\"\
    \n  else\n    return s\n  end\nend", "    local index\n    local result", "  \
    \ -- Your code here\n   \nend", "  s = string.gsub(s, \"([A-Za-z])\", function(a,\
    \ b) return b:lower() end)\n  if s:match(\"^%*#\") then\n    return string.gsub(s,\
    \ \"%*#\", function(a, b) return b:lower() end)\n  else\n    return s\n  end\n\
    end", "    local reverse = { }\n    for _, ch in string.gmatch(s, '[^A-Za-z]+')\
    \ do\n        if not reverse then reverse = { } end\n        if not reverse[ch]\
    \ then\n            reverse[ch] = ch\n        else\n            reverse[ch] =\
    \ toupper(ch) .. reverse[ch]\n        end\n    end\n    return table.concat(reverse,\
    \ \"\")\nend", "    local stack = {}\n    local result = ''\n    for i = 1, #s\
    \ do\n        if s[i] ~= nil and isLetter(s[i]) then\n            stack[#stack\
    \ + 1] = s[i]\n        else\n            assert(#stack > 0)\n            result\
    \ = stack[#stack] .. result\n            stack[#stack] = nil\n        end\n  \
    \  end\n    assert(#stack == 0)\n    if #stack > 0 then\n        result = stack[#stack]\
    \ .. result\n    end\n    return result\nend\nprint(solve(\"1234\"))\nprint(solve(\"\
    ab\"))\nprint(solve(\"#a@C\"))\n</cell>\n<text>\n5. String Manipulation\n4.1 Length\n\
    The length of a string is the number of characters it contains.", "    s=tostring(s)\n\
    \    s=string.gsub(s, \"(%l+)(%.)(%l+)\", \"%U%2%l%2%l\")\n    s=string.gsub(s,\
    \ \"(%l+)(%.)(%l+)\", \"%U%2%l%2%l\")\n    return s\nend", "\tlocal res = ''\n\
    \tfor _, v in string.gmatch(s, '%a') do\n\t\tres = v:lower()\n\tend\n\treturn\
    \ res or s\nend", "  s = s:lower()\n  s = s:gsub(\"%l\", string.lower)\n  s =\
    \ s:gsub(\"%u\", string.upper)\n  return s\nend", "    if s == \"\" then\n   \
    \     return s\n    end\n    for i = 1, #s do\n        if string.sub(s,i,i) ~=\
    \ string.sub(s,i,i) then\n            return s\n        end\n    end\n    return\
    \ string.lower(s)\nend", "\tlocal result = \"\"\n\tfor i=1,#s do\n\t\tlocal c\
    \ = string.sub(s, i, i)\n\t\tif c:byte() ~= nil then\n\t\t\tif c:byte() == 32\
    \ then\n\t\t\t\tc = c:upper()\n\t\t\t\tc = string.sub(c, 2, #c)\n\t\t\telse\n\t\
    \t\t\tc = c:lower()\n\t\t\tend\n\t\tend\n\t\tresult = result .. c\n\tend\n\tif\
    \ result ~= \"\" then\n\t\treturn result\n\telse\n\t\treturn string.sub(s, 2,\
    \ #s)\n\tend\nend", "  -- write your code in JavaScript (Node.js 8.9.4)\n  return\
    \ s\nend", "  s = string.gsub(s, \"([a-zA-Z])\", function(a, b) return a:lower()\
    \ end)\n  if #s <= 0 then return s end\n  local t = {}\n  for i = 1, #s do\n \
    \   local c = s:sub(i, i)\n    if c:byte() ~= 96 then\n      t[#t+1] = c:upper()\n\
    \    else\n      t[#t+1] = c:lower()\n    end\n  end\n  return table.concat(t,\
    \ \"\")\nend", "  local s=string.lower(s)\n  if s:sub(1,1)==\"#\" then\n    s=s:sub(4,6)..string.upper(s:sub(7,1))..string.upper(s:sub(8,3))..string.upper(s:sub(9,5))\n\
    \  else\n    s=string.upper(s)\n  end\n  return s\nend", "  local result = ''\n\
    \  for i=1,#s do\n    if string.sub(s,i,i)=='#' then\n      result = result ..\
    \ string.sub(s,i,i-1) .. string.sub(s,i,i+1) .. string.sub(s,i+1,i+2) .. string.sub(s,i+2,i+3)\n\
    \    else\n      result = result .. string.sub(s,i,i)\n    end\n  end\n  if #result>0\
    \ then\n    local n = string.len(result)\n    if n>0 then\n      if string.sub(result,1,1)=='#'\
    \ then\n        result = string.sub(result,1,n-1) .. string.sub(result,n-1,n+1)\n\
    \      else\n        result = string.sub(result,1,n) .. string.sub(result,n,n+1)\n\
    \      end\n    end\n  end\n  return result\nend", "    local rs = {} -- Reverse\
    \ stack\n    local cs = {} -- Capital stack\n    local n = 1 -- Length\n    for\
    \ i, c in string.gmatch(s, '%a') do\n        if c ~= nil then\n            table.insert(cs,\
    \ c)\n            n = n + 1\n        else\n            if #cs == 0 then\n    \
    \            table.insert(rs, string.sub(s, 1, i))\n            else\n       \
    \         table.insert(rs, string.sub(s, i, #s))\n            end\n          \
    \  n = 1\n        end\n    end\n    table.insert(rs, string.sub(s, 1, #s))\n \
    \   return table.concat(table.sort(rs))\nend", "  return s:gsub(\"%l\", function(c)\n\
    \    local v = c\n    if v:sub(1, 1) == \"@\" then\n      v = v:sub(2)\n    end\n\
    \    v = v:lower()\n    if v:sub(1, 1) ~= \"#\" then\n      v = v:upper()\n  \
    \  end\n    return v\n  end)\nend\n</code>\n<|/ a tags=lua,pattern-matching |>\n\
    <| a dscore=0 |>\n<code>", "  if s:find(char) then\n    local t = s:gsub(char,\
    \ function(x)\n      if x:lower():find(char) then\n        if x:lower() == x:upper()\
    \ then\n          return x:upper()\n        else\n          return x:lower()\n\
    \        end\n      else\n        return x\n      end\n    end)\n    return t\n\
    \  end\n  return s\nend", "\tlocal ret = \"\"\n\tfor i, letter in ipairs(s) do\n\
    \t\tif not letter then\n\t\t\tret = letter\n\t\telseif letter:lower() then\n\t\
    \t\tret = letter:upper()..ret\n\t\telse\n\t\t\tret = letter..ret\n\t\tend\n\t\
    end\n\treturn ret\nend", "\tlocal str=string.reverse(s)\n\tlocal result=\"\"\n\
    \tfor i = 1, #s do\n\t\tif string.sub(s, i,i)~=\"\" and string.sub(s, i,i)~=\"\
    \" then\n\t\t\tif string.sub(s, i,i)==\"a\" then\n\t\t\t\tstr=string.gsub(string.lower(str),\"\
    a\",string.upper)\n\t\t\t\tstr=string.gsub(string.upper(str),\"a\",string.lower)\n\
    \t\t\telseif string.sub(s, i,i)==\"A\" then\n\t\t\t\tstr=string.gsub(string.lower(str),\"\
    A\",string.upper)\n\t\t\t\tstr=string.gsub(string.upper(str),\"A\",string.lower)\n\
    \t\t\telseif string.sub(s, i,i)==\"c\" then\n\t\t\t\tstr=string.gsub(string.lower(str),\"\
    c\",string.upper)\n\t\t\t\tstr=string.gsub(string.upper(str),\"c\",string.lower)\n\
    \t\t\telseif string.sub(s, i,i)==\"C\" then\n\t\t\t\tstr=string.gsub(string.lower(str),\"\
    C\",string.upper)\n\t\t\t\tstr=string.gsub(string.upper(str),\"C\",string.lower)\n\
    \t\t\telseif string.sub(s, i,i)==\"#\" then\n\t\t\t\tstr=string.gsub(string.lower(str),\"\
    #\",string.upper)\n\t\t\t\tstr=string.gsub(string.upper(str),\"#\",string.lower)\n\
    \t\t\telseif string.sub(s, i,i)==\"$\" then\n\t\t\t\tstr=string.gsub(string.lower(str),\"\
    $\",string.upper)\n\t\t\t\tstr=string.gsub(string.upper(str),\"$\",string.lower)\n\
    \t\t\tend\n\t\t\tresult=result..string.sub(str,1,1)\n\t\tend\n\tend\n\treturn\
    \ result\nend\nreturn solve", "    return s:gsub(\"a\", function(c) return c:lower()\
    \  or c:upper() end) \n            :gsub(\"A\", function(c) return c:lower() or\
    \ c:upper() end) \n            :gsub(\"#\", function(c) return c:upper()  end)\
    \ \n            :gsub(\"C\", function(c) return c:lower()  end) \n           \
    \ :gsub(\"z\", function(c) return c:upper()  end) \n            :gsub(\"1\", function(c)\
    \ return c:upper()  end) \n            :gsub(\"0\", function(c) return c:lower()\
    \  end) \n            :gsub(\"#\", function(c) return c:lower()  end) \n     \
    \       :gsub(\"A\", function(c) return c:upper() end) \n            :gsub(\"\
    a\", function(c) return c:lower() end) \n            :gsub(\"B\", function(c)\
    \ return c:lower() end) \n            :gsub(\"c\", function(c) return c:lower()\
    \ end)\nend\n</code>\n<|/ a tags=lua,lua-patterns,string |>\n<| a dscore=1 |>\n\
    Another solution which may be more readable:\n<code>", "\tlocal s = string.gsub(s,\
    \ \"[^A-Za-z]\", \"\")\n\ts = string.gsub(s, \"%l\", \"\")\n\treturn (string.lower(string.sub(string.gsub(s,\
    \ \"%l\", string.upper), 1, 1)) + string.sub(string.gsub(s, \"%l\", string.upper),\
    \ 1, -1))\nend", "   local s = s:gsub(\"[^A-Za-z]\", function(c) return string.upper(c)\
    \ end)\n   local s = s:gsub(\"^%s*(.-)%s*$\", function(_, c) return c:lower()\
    \ end)\n   return s\nend", "\ts=string.gsub(s,\".\",function(x)\n\t\tlocal a=string.match(x,\"\
    %a%\")\n\t\tif a==nil then\n\t\t\treturn x\n\t\telse\n\t\t\tlocal b=string.match(x,\"\
    %b%\")\n\t\t\tif b==nil then\n\t\t\t\treturn x\n\t\t\telse\n\t\t\t\treturn string.upper(string.sub(x,1,1))..string.lower(string.sub(x,2))\n\
    \t\t\tend\n\t\tend\n\tend)\n\ts=string.gsub(s,\"[^aA-Z]\",\"\")\n\treturn string.gsub(s,\"\
    A+\",function(x)\n\t\tif string.find(x,\"a\")==1 then\n\t\t\treturn string.upper(string.sub(x,2,string.len(x)-1))\n\
    \t\telseif string.find(x,\"A\")==1 then\n\t\t\treturn string.lower(string.sub(x,2,string.len(x)-1))\n\
    \t\telse\n\t\t\treturn x\n\t\tend\n\tend)\nend", "    local t = \"\"\n    for\
    \ i = 1, #s do\n        local n = string.lower(s[i])\n        if string.find(string.upper(s),\
    \ n) then\n            s = string.upper(n)\n        else\n            s = n\n\
    \        end\n        t = s .. t\n    end\n    return t\nend", "    local res\
    \ = \"\"\n    for i = 1, #s do\n        local ch = string.sub(s,i,i)\n       \
    \ if ch:match \"[a-z]\" then\n            if string.find(string.lower(s),string.upper(ch),1,true)\
    \ then\n                res = string.upper(res) .. string.lower(ch)\n        \
    \    else\n                res = string.upper(res) .. ch\n            end\n  \
    \      else\n            res = res .. ch\n        end\n    end\n    return res\n\
    end", "  s = string.lower(s)\n  local p = 1\n  local t = 1\n  local a = #s\n \
    \ for i = 1, a do\n    if string.sub(s, i, i)~=nil then\n      if string.sub(s,\
    \ i, i)==\"a\" then\n\tt = t + 1\n      elseif string.sub(s, i, i)==\"b\" then\n\
    \tt = t - 1\n      elseif string.sub(s, i, i)==\"c\" then\n\tp = p + 1\n     \
    \ elseif string.sub(s, i, i)==\"d\" then\n\tp = p - 1\n      elseif string.sub(s,\
    \ i, i)==\"e\" then\n\tt = t + 1\n      elseif string.sub(s, i, i)==\"f\" then\n\
    \tt = t - 1\n      elseif string.sub(s, i, i)==\"g\" then\n\tp = p + 1\n     \
    \ elseif string.sub(s, i, i)==\"h\" then\n\tp = p - 1\n      elseif string.sub(s,\
    \ i, i)==\"i\" then\n\tt = t + 1\n      elseif string.sub(s, i, i)==\"j\" then\n\
    \tt = t - 1\n      elseif string.sub(s, i, i)==\"k\" then\n\tp = p + 1\n     \
    \ elseif string.sub(s, i, i)==\"l\" then\n\tp = p - 1\n      elseif string.sub(s,\
    \ i, i)==\"m\" then\n\tt = t + 1\n      elseif string.sub(s, i, i)==\"n\" then\n\
    \tt = t - 1\n      elseif string.sub(s, i, i)==\"o\" then\n\tp = p + 1\n     \
    \ elseif string.sub(s, i, i)==\"p\" then\n\tp = p - 1\n      elseif string.sub(s,\
    \ i, i)==\"q\" then\n\tt = t + 1\n      elseif string.sub(s, i, i)==\"r\" then\n\
    \tt = t - 1\n      elseif string.sub(s, i, i)==\"s\" then\n\tp = p + 1\n     \
    \ elseif string.sub(s, i, i)==\"t\" then\n\tp = p - 1\n      elseif string.sub(s,\
    \ i, i)==\"u\" then\n\tt = t + 1\n      elseif string.sub(s, i, i)==\"v\" then\n\
    \tt = t - 1\n      elseif string.sub(s, i, i)==\"w\" then\n\tp = p + 1\n     \
    \ elseif string.sub(s, i, i)==\"x\" then\n\tp = p - 1\n      elseif string.sub(s,\
    \ i, i)==\"y\" then\n\tt = t + 1\n      elseif string.sub(s, i, i)==\"z\" then\n\
    \tt = t - 1\n      end\n    end\n  end\n", "  s = tostring(s)\n  local index =\
    \ 0\n  local new_s = \"\"\n  local flag = false\n  for i=1,#s do\n    if s[i]\
    \ == \"#\" then\n      index = index - 1\n      if index == 0 then\n        flag\
    \ = true\n        index = i\n        j = index\n      else\n        index = index\
    \ - 1\n        j = index\n      end\n      new_s = new_s .. (j+1-i) .. s[i]\n\
    \      j = j-1\n    elseif s[i] == s[i] then\n      index = index - 1\n      new_s\
    \ = new_s .. s[i]\n    end\n  end\n  \n  if index == 0 and not flag then\n   \
    \ return new_s\n  else\n    return s:sub(1, #s)\n  end\nend", "    local result\
    \ = \"\"\n    for i=1,#s,1 do\n        if string.sub(s,i,i)==\"#\" then\n    \
    \        local temp = \"\"\n            for j=1,#string.sub(s,i-1,i),1 do\n  \
    \              if string.sub(s,i,i)==\"#\" then\n                    temp = string.sub(s,i,i)\n\
    \                elseif string.sub(s,i,i)==string.sub(s,i-1,i-1) then\n      \
    \              temp = string.sub(s,i,i)..string.sub(s,i-1,i)\n               \
    \ else\n                    temp = temp..string.sub(s,i,i)\n                end\n\
    \            end\n            temp = temp..string.sub(s,i+1,i+1)\n           \
    \ result = temp..result\n        elseif string.sub(s,i,i)==\"@\" then\n      \
    \      local temp = \"\"\n            for j=1,#string.sub(s,i-1,i),1 do\n    \
    \            if string.sub(s,i,i)==\"@\" then\n                    temp = string.sub(s,i,i)\n\
    \                elseif string.sub(s,i,i)==string.sub(s,i-1,i-1) then\n      \
    \              temp = string.sub(s,i,i)..string.sub(s,i-1,i)\n               \
    \ else\n                    temp = temp..string.sub(s,i,i)\n                end\n\
    \            end\n            temp = temp..string.sub(s,i+1,i+1)\n           \
    \ result = temp..result\n        else\n            result = string.sub(s,i,i)..result\n\
    \        end\n    end\n    return result\nend", "    if not s:match('^%s*$') then\
    \ return s end\n    local s = string.lower(s)\n    if string.find(s, '%l+') then\n\
    \        for i = 1, #s do\n            if string.find(s, string.char(string.byte(s[i+1])))\
    \ then\n                s = string.gsub(s, '%l+', '%l')\n                break\n\
    \            end\n        end\n    end\n    return s\nend", "    local result\
    \ = \"\"\n    for i,c in ipairs(s) do \n        if c:match(\"[a-zA-Z]\") then\n\
    \            if c == \"a\" then c = \"A\" end\n            if c == \"b\" then\
    \ c = \"B\" end\n            if c == \"c\" then c = \"C\" end\n            if\
    \ c == \"d\" then c = \"D\" end\n            if c == \"e\" then c = \"E\" end\n\
    \            if c == \"f\" then c = \"F\" end\n            if c == \"g\" then\
    \ c = \"G\" end\n            if c == \"h\" then c = \"H\" end\n            if\
    \ c == \"i\" then c = \"I\" end\n            if c == \"j\" then c = \"J\" end\n\
    \            if c == \"k\" then c = \"K\" end\n            if c == \"l\" then\
    \ c = \"L\" end\n            if c == \"m\" then c = \"M\" end\n            if\
    \ c == \"n\" then c = \"N\" end\n            if c == \"o\" then c = \"O\" end\n\
    \            if c == \"p\" then c = \"P\" end\n            if c == \"q\" then\
    \ c = \"Q\" end\n            if c == \"r\" then c = \"R\" end\n            if\
    \ c == \"s\" then c = \"S\" end\n            if c == \"t\" then c = \"T\" end\n\
    \            if c == \"u\" then c = \"U\" end\n            if c == \"v\" then\
    \ c = \"V\" end\n            if c == \"w\" then c = \"W\" end\n            if\
    \ c == \"x\" then c = \"X\" end\n            if c == \"y\" then c = \"Y\" end\n\
    \            if c == \"z\" then c = \"Z\" end\n            \n        else\n  \
    \          local tmp = c\n            c = toupper(c)\n            c = tolower(c)\n\
    \            c = tmp\n        end\n        result = result .. c\n    end\n   \
    \ return result\nend", "    if s == nil then return nil end\n    local result\
    \ = \"\"\n    for i = 1, #s do\n        if string.sub(s,i,i) ~= nil then\n   \
    \         if string.sub(s,i,i) ~= \"\" then\n                if string.sub(s,i,i)\
    \ ~= string.sub(s,i,i) then\n                    result = result .. string.sub(s,i,i)\n\
    \                else\n                    result = result .. string.sub(s,i,i):toupper()\n\
    \                end\n            else\n                result = result .. string.sub(s,i,i):toupper()\n\
    \            end\n        else\n            result = result .. string.sub(s,i,i):toupper()\n\
    \        end\n    end\n    return result\nend", "\ts = string.lower(s)\n\tlocal\
    \ _ = \"\"\n\tlocal i = 0\n\tlocal k = 1\n\twhile i < #s do\n\t\tif s[i] ~= nil\
    \ then\n\t\t\tk = string.upper(s[i])\n\t\t\t_ = _..string.sub(s,i,k-1)\n\t\t\t\
    _ = _..string.lower(string.sub(s,k,k+1))\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn\
    \ _\nend", "    local newStr = \"\"\n    for i = 1, #s do\n        local temp\
    \ = s:sub(i,i)\n        -- print(temp)\n        local found = false\n        for\
    \ j = 1, #temp do\n            local char = temp:sub( j,j )\n            -- print(char)\n\
    \            if( char == toupper(temp) ) then\n                found = true\n\
    \            end\n        end\n        if found == false then\n            newStr\
    \ = newStr .. temp\n        else\n            newStr = newStr .. toupper(temp)\n\
    \        end\n    end\n    return newStr\nend", "\tassert(s:len() >= 2, \"The\
    \ given string should have at least 3 characters.\")\n\tlocal ans = s:sub(1, 1)\
    \ -- first character of string\n\tfor i = 1, s:len() - 2 do\n\t\tlocal c = s:sub(i,\
    \ i + 1) -- string after i\n\t\tif c:isalpha() then\n\t\t\tif c:lower() == c then\n\
    \t\t\t\tans = s:sub(i + 1, i + 2)\n\t\t\telse\n\t\t\t\tans = s:sub(i + 1, i +\
    \ 1) + c:upper()\n\t\t\tend\n\t\tend\n\tend\n\treturn ans\nend", "  s = string.lower(s)\n\
    \  for i=1,#s do\n    if string.sub(s,i,i) ~= string.sub(s,i,i) then return s\
    \ end\n  end\n  return string.lower(s)\nend", "    if s ~= nil then\n        local\
    \ t = {}\n        for i = 1, #s do\n            if string.sub(s,i,i) == string.sub(s,i,i)\
    \ then\n                table.insert(t, string.lower(string.sub(s,i,i)..string.sub(s,i,i)))\n\
    \            else\n                table.insert(t, string.lower(string.sub(s,i,i)))\n\
    \            end\n        end\n        table.insert(t,string.lower(string.sub(s,#s,#s)))\n\
    \        return table.concat(t, \"\")\n    end\nend\n</code>\n<|/ a dscore=0 tags=lua-table,lua\
    \ |>\n<| c |>\nThe `nil` check should be moved outside of the loop.  You do not\
    \ want to continue iterating over the string if the string is nil.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's my answer:\n<code>", "  local result = \"\"\n  for i=1,\
    \ #s do\n    if s[i] ~= nil then\n      if s[i] ~= s[i:lower():find(s[i])] then\n\
    \        result = s[i]\n      else\n        result = s[i:upper():find(s[i])] ..\
    \ result\n      end\n    else\n      result = s[i] .. result\n    end\n  end\n\
    \  return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
