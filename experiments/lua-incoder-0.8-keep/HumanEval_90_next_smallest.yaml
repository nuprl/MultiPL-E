name: HumanEval_90_next_smallest
language: lua
prompt: "-- You are given a list of integers.\n-- Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n-- Return None if there is\
  \ no such element.\n-- next_smallest([1, 2, 3, 4, 5]) == 2\n-- next_smallest([5,\
  \ 1, 4, 3, 2]) == 2\n-- next_smallest([]) == None\n-- next_smallest([1, 1]) == None\n\
  local function next_smallest(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5,\
  \ 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if lst == nil then\n    return nil\n  end", "  if lst[1] then\n \
    \   return lst[1]\n  elseif lst[2] then\n    return lst[2]\n  else\n    return\
    \ nil\n  end\nend", "  local smallest = lst[1]\n  local index = 1\n  while index\
    \ < #lst do\n    local element = lst[index]\n    if element > smallest then\n\
    \      smallest = element\n    end\n    index = index + 1\n  end\n  return smallest\n\
    end", "  local smallest = nil\n  local small_idx = nil\n  for i = 1, #lst do\n\
    \    local idx = smallest\n    if smallest == nil then\n      smallest = lst[i]\n\
    \      small_idx = i\n    else\n      local dist = lst[i] - smallest\n      if\
    \ dist < 0 then\n        smallest = lst[i]\n        small_idx = i\n      end\n\
    \    end\n  end", "  local smallest = nil\n  for v in lst\n  do\n    if not smallest\
    \ or v < smallest then\n      smallest = v\n    end\n  end", "  if #lst == 0 then\n\
    \    return\n  end", "  local smallest = nil\n  for i = 1, #lst do\n    smallest\
    \ = lst[i] if not smallest or smallest[1] < lst[i] and smallest[1] == lst[i] end\n\
    \  end\n  return smallest\nend", "  -- find the smallest value\n  local smallest\
    \ = lst[1]\n  -- find the 2nd smallest value\n  for i = 2, #lst do\n    if lst[i]\
    \ < smallest then\n      smallest = lst[i]\n    end\n  end\n  return smallest\n\
    end", "  if lst == nil then\n    return\n  end\n  if #lst < 2 then\n    return\n\
    \  end\n  local min = lst[1]\n  local n = #lst\n  for i = 2, n do\n    local x\
    \ = lst[i]\n    if x < min then\n      min = x\n    end\n  end\n  return min\n\
    end", "  local smallest = lst[1]\n  for i = 2, #lst do\n    if lst[i] < smallest\
    \ then\n      smallest = lst[i]\n    end\n  end\n  return smallest\nend", "  if\
    \ lst[1] == nil then return nil end\n  for i = 2, #lst do\n    if lst[i] < lst[i-1]\
    \ then return lst[i-1] end\n  end\n  return nil\nend", "  if #lst == 0 then\n\
    \    return nil\n  else\n    local small = next_smallest(lst[1:])\n    if small\
    \ ~= nil then\n      return lst[#lst] + 1\n    else\n      return small\n    end\n\
    \  end\nend", "    local lst = lst or {}\n    if not lst then return nil end\n\
    \    local smallest = lst[1]\n    for i = 2, #lst do\n        if lst[i] < smallest\
    \ then return lst[i] end\n    end\nend", "  if lst == nil then return nil end\n\
    \  local _,i,n = unpack(lst)\n  for i = n,1,-1 do\n    if lst[i] < lst[i-1] then\
    \ return lst[i] end\n  end\nend", "  if #lst <= 1 then\n    return nil\n  end\n\
    \  if lst[1] == lst[1] then\n    return lst[1]\n  end\n  local smallest = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] < smallest then\n      smallest = lst[i]\n\
    \    end\n  end\n  return smallest\nend", "  if #lst == 0 then\n    return nil\n\
    \  end\n  local head = lst[1]\n  local tail = lst[#lst]\n  local i = 2\n  while\
    \ i < #lst do\n    if lst[i] < head then\n      head = lst[i]\n      i = i\n \
    \   else\n      lst[i] = head\n      return head\n    end\n  end\n  lst[i] = head\n\
    \  return head\nend", "  local smallest, smallest_idx, last_idx = 0, -1, -1\n\
    \  for _, v in ipairs(lst) do\n    smallest_idx = math.min(smallest_idx, last_idx)\n\
    \    smallest = smallest_idx and lst[smallest_idx] or smallest\n    last_idx =\
    \ v\n  end\n  return smallest and smallest\nend", "  for _, value in ipairs(lst)\
    \ do\n    local idx = #lst\n    while idx > 1 do\n      local idx = idx - 1\n\
    \      local value = lst[idx]\n      if value < value then\n        return lst[idx]\n\
    \      else\n        break\n      end\n    end\n  end\n  return nil\nend", " \
    \ if #lst==0 then return nil end\n  if #lst==1 then return lst[1] end\n  local\
    \ head=lst[1]\n  local tail=lst[2]\n  for i=3,#lst do if head<lst[i] then head=lst[i]\
    \ else tail=lst[i] end end\n  return tail\nend", "  if #lst == 0 then\n    return\
    \ nil\n  end", "  local smallest = nil\n  for _, value in ipairs(lst) do\n   \
    \ if smallest == nil or value < smallest then\n      smallest = value\n    end\n\
    \  end\n  return smallest\nend", "  local smallest = nil\n  local index = nil\n\
    \  for i = 1, #lst do\n    if smallest == nil then\n      smallest = lst[i]\n\
    \      index = i\n    elseif smallest:cadd(lst[i]) < 0 then\n      smallest =\
    \ lst[i]\n      index = i\n    end\n  end\n  if smallest ~= nil then\n    return\
    \ smallest\n  else\n    return nil\n  end\nend", "  if lst[1] == nil then return\
    \ nil end\n  if lst[1] == lst[2] then return lst[2] end\n  local idx = #lst\n\
    \  while idx > 1 do\n    idx = idx - 1\n    if lst[idx] < lst[idx - 1] then return\
    \ lst[idx] end\n  end\n  return nil\nend", "  if len(lst) == 0 then\n    return\
    \ nil\n  end", "   if #lst == 0 then\n      return nil\n   end\n   local cur =\
    \ lst[1]\n   for i = 2, #lst do\n      if not cur then\n         return lst[i]\n\
    \      end\n      if cur < lst[i] then\n         return lst[i]\n      end\n  \
    \    cur = nil\n   end\nend", "    local smallest = nil\n    local smallest_index\
    \ = nil\n    for i = 1, #lst do\n        if smallest == nil then\n           \
    \ smallest = lst[i]\n            smallest_index = i\n        elseif lst[i] < smallest\
    \ then\n            smallest = lst[i]\n            smallest_index = i\n      \
    \  end\n    end\n    if smallest == nil then\n        return nil\n    end\n  \
    \  return smallest\nend", "    if lst[1] == nil then return nil end\n    if lst[1]\
    \ == lst[2] then return lst[1] end\n    return lst[1]\nend", "  local smallest\
    \ = nil\n  for i = 2, #lst do\n    local value = lst[i]\n    if smallest and value\
    \ < smallest then\n      return nil\n    end\n    if smallest and smallest > value\
    \ then\n      return smallest\n    end\n    smallest = value\n  end\n  return\
    \ smallest\nend", "  local smallest = lst[1]\n  for i = 2, #lst do\n    if lst[i]\
    \ < smallest then smallest = lst[i]\n  end\n  return smallest\nend", "  if #lst\
    \ == 0 then return nil end\n  if lst[1] < lst[2] then return lst[1] else return\
    \ lst[2] end\nend", "  local smallest = {value = nil}\n  local min_value = nil\n\
    \  local i = 1\n  for v in lst:gmatch(\"%d+\") do\n    if smallest.value == nil\
    \ or v <= smallest.value then\n      smallest.value = v\n      smallest.index\
    \ = i\n      if v < min_value then\n        min_value = v\n      end\n    end\n\
    \    i = i + 1\n  end\n  if smallest.value == nil then\n    return nil\n  end\n\
    \  i = smallest.index + 1\n  for v in lst:gmatch(\"%d+\") do\n    if v ~= smallest\
    \ and v <= smallest.value and i <= #lst then\n      smallest.value = v\n     \
    \ smallest.index = i\n      if v < min_value then\n        min_value = v\n   \
    \   end\n    end\n    i = i + 1\n  end\n  return smallest.value\nend", "  local\
    \ smallest = lst[1]\n  for i = 2, #lst do\n    if smallest:leq(lst[i]) then\n\
    \      smallest = lst[i]\n    end\n  end\n  return smallest\nend", "  if #lst\
    \ == 0 then\n    return nil\n  end", "  if #lst == 0 then\n    return nil\n  end\n\
    \  if #lst == 1 then\n    return lst[1]\n  end\n  local elem = lst[1]\n  for i\
    \ = 2, #lst do\n    if elem < lst[i] then\n      elem = lst[i]\n    end\n  end\n\
    \  return elem\nend", "  local smallest = lst[1]\n  for i = 2, #lst do\n    if\
    \ lst[i] < smallest then\n      smallest = lst[i]\n    end\n  end\n  return smallest\n\
    end", "   if #lst < 2 then\n      return nil\n   end\n   local min1, min2 = lst[1],\
    \ lst[2]\n   for i=3, #lst do -- Skip the middle element\n      if lst[i] > min1\
    \ then\n         min2, min1 = min1, lst[i]\n      end\n   end\n   return min2\n\
    end", "  local size = #lst\n  local min = lst[1]\n  local pos = 1\n  while pos\
    \ < size and min > lst[pos] do\n    pos = pos + 1\n  end\n  if pos < size then\n\
    \    return lst[pos]\n  end\n  return nil\nend", "  if #lst == 0 then\n    return\
    \ nil\n  else\n    if lst[1] < lst[2] then\n      return lst[1]\n    else\n  \
    \    return lst[2]\n    end\n  end\nend", "  if lst[1] == nil then\n    return\
    \ nil\n  elseif lst[1] == lst[2] then\n    return lst[2]\n  else\n    return lst[1]\n\
    \  end\nend", "    local smallest = nil\n    for i=1,#lst do\n        if smallest==nil\
    \ then\n            smallest = lst[i]\n        else\n            if lst[i] < smallest\
    \ then\n                smallest = lst[i]\n            end\n        end\n    end\n\
    \    return smallest\nend", "  if lst[1] ~= lst[2] then return lst[2] end\n  if\
    \ #lst == 1 then return lst[1] end\n  if lst[1] == lst[2] then\n    if lst[1]\
    \ < lst[2] then return lst[1] end\n  end\n  for i = #lst, 2, -1 do\n    if lst[i]\
    \ > lst[i-1] then return lst[i] end\n  end\n  return nil\nend", "  if lst[1] then\n\
    \    return lst[1]\n  elseif lst[2] then\n    return lst[2]\n  else\n    return\
    \ nil\n  end\nend", "  if lst[1] == nil then return end end\n  if lst[2] == nil\
    \ then return lst[1] end\n  if lst[2] < lst[1] then return lst[2] end\n  return\
    \ lst[1]\nend", "    local smallest = lst[1]\n    for i = 2, #lst do\n       \
    \ if lst[i] < smallest then\n            smallest = lst[i]\n        end\n    end\n\
    \    return smallest\nend", "  if #lst == 1 then\n    return lst[1]\n  end", " \
    \ if lst[1] == nil then return end\n  local mid = math.ceil((lst[1] + lst[2])\
    \ / 2)\n  if mid == lst[1] then return lst[2] end\n  return mid\nend", "  if lst[1]\
    \ == nil then\n    return nil\n  elseif lst[2] > lst[1] then\n    return lst[2]\n\
    \  else\n    return lst[1]\n  end\nend", "  if #lst == 0 then return nil end\n\
    \  local smallest, idx = #lst, 1\n  while idx <= smallest do\n    local tmp =\
    \ lst[idx]\n    if tmp < smallest then\n      smallest, idx = tmp, idx + 1\n \
    \   else\n      return smallest\n    end\n  end\n  local tmp = lst[idx]\n  return\
    \ tmp\nend", "  local smallestIndex = nil\n  local smallestValue = nil\n  for\
    \ _, value in ipairs(lst) do\n    if smallestIndex == nil then\n      smallestIndex\
    \ = value\n      smallestValue = value\n    elseif value < smallestValue then\n\
    \      smallestIndex = value\n      smallestValue = value\n    end\n  end\n  return\
    \ smallestIndex\nend", "  if #lst <= 1 then return end\n  if lst[1] == lst[2]\
    \ then return nil end\n  local smallest = lst[1]\n  local rest = lst[2:end]\n\
    \  while #rest > 1 do\n    if smallest > rest[1] then\n      smallest = rest[1]\n\
    \    else\n      rest = rest[2:end]\n    end\n  end\n  return smallest\nend",
  "    local smallest, smallest_idx\n    for i = 1, #lst do\n        if smallest \
    \ == nil then\n            smallest = lst[i]\n            smallest_idx = i\n \
    \       else\n            if lst[i] < smallest then\n                smallest\
    \ = lst[i]\n                smallest_idx = i\n            end\n        end\n \
    \   end\n    return smallest_idx\nend", "    local idx = 1\n    for k, v in ipairs(lst)\
    \ do\n        if k < lst[idx - 1] then\n            idx = idx\n        else\n\
    \            idx = idx + 1\n        end\n    end\n    if idx == #lst then\n  \
    \      return nil\n    else\n        return lst[idx-1]\n    end\nend", "    if\
    \ lst == nil then\n        return nil\n    end\n    return lst[2]\nend", "  --\
    \ base case\n  if lst[1] == nil then\n    return nil\n  end\n  -- create new list\n\
    \  local lst2 = {}\n  -- insert all elements into new list\n  for i, e in pairs(lst)\
    \ do\n    lst2[#lst2 + 1] = e\n  end\n  -- sort lst2\n  table.sort(lst2)\n  --\
    \ return lst2[#lst2 + 1]\n  return lst2[#lst2 + 1]\nend", "    local smallest\
    \ = nil\n    for i = 1, #lst do\n        if smallest == nil or lst[i] < smallest\
    \ then\n            smallest = lst[i]\n        end\n    end\n    return smallest\n\
    end", "    if lst[1] == nil then\n        return nil\n    end\n    for i = 2,\
    \ #lst do\n        if lst[i] < lst[i - 1] then\n            return lst[i]\n  \
    \      end\n    end\n    return nil\nend", "   -- Write your code here.\n   local\
    \ minimum = lst[1]\n   for i = 2, #lst do\n      if minimum > lst[i] then\n  \
    \       minimum = lst[i]\n      end\n   end\n   return minimum\nend", "    local\
    \ i = #lst\n    if i < 1 then return nil end\n    if lst[i] == lst[i - 1] + 1\
    \ then return lst[i - 1] + 1 end\n    while i > 1 do\n        i = i - 1\n    \
    \    if lst[i] == lst[i - 1] + 1 then return lst[i - 1] + 1 end\n    end\n   \
    \ return nil\nend", "  if lst[1] and lst[2] and lst[3] and lst[4] then\n    return\
    \ lst[2]\n  end\n  local minimum = nil\n  local i = 2\n  while lst[i] do\n   \
    \ minimum = lst[i] \n    i = i + 1\n  end\n  return minimum\nend\n</cell>\n<cell>",
  "  local i = 0\n  local n = #lst\n  while i < n and lst[i] < lst[n] do i = i + 1\
    \ end\n  if i == n then return nil end\n  return lst[i + 1]\nend", "  if #lst\
    \ < 1 then return nil end\n  return lst[#lst]\nend", "  if len(lst) == 0 then\
    \ return end\n  if lst[1] < lst[2] then\n    return lst[2]\n  else\n    return\
    \ next_smallest(lst[3])\n  end\nend", "  if #lst == 1 then\n    return lst[1]\n\
    \  end\n  local elem = lst[1]\n  local low = 1\n  local high = #lst\n  while low\
    \ <= high do\n    local mid = math.floor((low + high) / 2)\n    local x = lst[mid]\n\
    \    if x < elem then\n      low = mid\n    else\n      high = mid\n    end\n\
    \  end\n  if low == #lst then\n    return nil\n  end\n  return lst[low]\nend",
  "    local smallest = lst[1]\n    for i = 2, #lst do\n        if lst[i] < smallest\
    \ then\n            smallest = lst[i]\n        end\n    end\n    return smallest\n\
    end", "  local smallest = lst[1]\n  for i = 2, #lst do\n    if lst[i] < smallest\
    \ then\n      smallest = lst[i]\n    end\n  end\n  return smallest\nend", "  if\
    \ lst[1] == nil then return nil end\n  local min_2 = lst[1]\n  for i = 2, #lst\
    \ do\n    if min_2 < lst[i] then\n      min_2 = lst[i]\n    end\n  end\n  return\
    \ min_2\nend", "    for i = 2, #lst do -- We go from the second element to the\
    \ end of the list\n        if lst[i] < lst[i-1] then\n            return lst[i]\n\
    \        end\n    end\n    return nil\nend", "  local smallest_idx\n  local smallest_val\
    \ = unpack(lst)[1]\n  local idx = 1\n  while idx <= #lst do\n    if lst[idx] <\
    \ smallest_val then\n      smallest_idx = idx\n      smallest_val = unpack(lst)[smallest_idx]\n\
    \    end\n    idx = idx + 1\n  end\n  return smallest_val\nend", "  return next(lst,\
    \ lst.index)\nend", "   if #lst == 0 then\n      return nil\n   end\n   if lst[1]\
    \ < lst[2] then\n      return lst[2]\n   else\n      return lst[1]\n   end\nend",
  "  -- Check if there are any elements.\n  if #lst==0 then\n    return nil\n  end",
  "  if lst[1] == nil then\n    return nil\n  end\n  local smallest = lst[1]\n  for\
    \ i = 2, #lst do\n    if lst[i] < smallest then\n      smallest = lst[i]\n   \
    \ end\n  end\n  return smallest\nend", "   if #lst == 0 then return nil end\n\
    \   local smallest = lst[1]\n   for i = 2, #lst do\n      if lst[i] < smallest\
    \ then smallest = lst[i] end\n   end\n   return smallest\nend", "  for i, v in\
    \ ipairs(lst) do\n    if i ~= 1 then\n      if v < lst[i] then\n        return\
    \ lst[i]\n      end\n    end\n  end\n  return nil\nend", "  local smallest = lst[1]\n\
    \  for i = 2, #lst do\n    if smallest[1] < lst[i] then\n      smallest = lst[i]\n\
    \    end\n  end\n  return smallest\nend", "  local smallest = nil\n  for k, v\
    \ in ipairs(lst) do\n    if smallest == nil or k < smallest then\n      smallest\
    \ = k\n    end\n  end\n  return smallest\nend", "  local smallest_index, smallest_value\
    \ = unpack(lst)\n  local smallest_index = smallest_index or 1\n  local length\
    \ = #lst\n  if smallest_index < length then\n    local value = lst[smallest_index]\n\
    \    smallest_index = smallest_index + 1\n    return smallest_index == length\
    \ and\n      smallest_value or\n      smallest_value < value and\n      smallest_value\
    \ or\n      next_smallest(lst)\n  end\nend", '  local smallest', "  local elem\
    \ = lst[1]\n  lst[1] = nil\n  local i = 2\n  repeat\n    local elem = lst[i]\n\
    \    lst[i] = nil\n    if elem then\n      -- If the current element is smallest,\
    \ then return it\n      if elem < elem then\n        return elem\n      else\n\
    \        -- Move the pointer to the next element\n        i = i + 1\n      end\n\
    \    else\n      -- Move the pointer to the next element\n      i = i + 1\n  \
    \  end\n  until not elem and i < #lst\n  return elem\nend", "    if lst[1] ==\
    \ nil then\n        return nil\n    end\n    local index = 2\n    while lst[index]\
    \ ~= lst[index - 1] do\n        index = index + 1\n    end\n    return lst[index]\n\
    end", "  if #lst > 1 then\n    local mid = math.floor(#lst / 2)\n    local smaller\
    \ = next_smallest(lst:sub(1, mid))\n    if smaller then\n      return lst[mid]\n\
    \    else\n      return smaller\n    end\n  end\n  return nil\nend", "  for i\
    \ = 2, #lst do\n    if lst[i - 2] < lst[i] then\n      return lst[i]\n    end\n\
    \  end\n  return nil\nend", "  if lst[1] == nil then return nil end\n  local min_value\
    \ = lst[1]\n  local smaller_values = lst[2:end]\n  for v in smaller_values do\n\
    \    if v < min_value then\n      min_value, smaller_values = v, smaller_values\n\
    \    end\n  end\n  return min_value\nend", "  for i = 2, #lst do\n    if lst[i]\
    \ < lst[i-1] then\n      return lst[i]\n    end\n  end\n  return nil\nend", " \
    \ if #lst == 0 then\n    return nil\n  end\n  local elem = lst[1]\n  for i = 2,\
    \ #lst do\n    if lst[i] < elem then\n      return elem\n    end\n    elem = lst[i]\n\
    \  end\n  return elem\nend", "  if #lst <= 0 then\n    return nil\n  end\n  local\
    \ smallest = lst[1]\n  for i = 2, #lst do\n    if lst[i] < smallest then\n   \
    \   smallest = lst[i]\n    end\n  end\n  return smallest\nend\nreturn next_smallest",
  "    local smallest = nil\n    for _, val in pairs(lst) do\n        if smallest\
    \ == nil or val < smallest then\n            smallest = val\n        end\n   \
    \ end\n    return smallest\nend", "  local i = 1\n  while i < #lst do\n    if\
    \ lst[i] < lst[i-1] then\n      local tmp = lst[i-1]\n      lst[i-1] = lst[i]\n\
    \      lst[i] = tmp\n    end\n    i = i + 1\n  end\n  \n  if i == 1 then return\
    \ nil end\n  \n  local min = lst[i]\n  local idx = i\n  while idx < #lst do\n\
    \    if lst[idx] < min then\n      min = lst[idx]\n    end\n    idx = idx + 1\n\
    \  end\n  \n  return min\nend", "  if #lst <= 1 then return nil end\n  if lst[1]\
    \ < lst[2] then return lst[1] end\n  return lst[2]\nend", "  local smallest, next_smallest,\
    \ next = lst, lst[1], lst[1]\n  for i=2,#lst do\n    if lst[i] < next then\n \
    \     smallest = next_smallest\n      next_smallest, next = lst[i], lst[i]\n \
    \   end\n  end\n  return next_smallest\nend", "  if lst[1] == nil then return\
    \ nil end\n  if lst[1] == lst[2] then return lst[2] end\n  return lst[1]\nend",
  "   if lst[1] == nil then return nil end\n   return lst[2]\nend", '   if #lst ==
    0 then return end', "  for i = 2, #lst do\n    if lst[i-1] <= lst[i] then\n  \
    \    return lst[i]\n    end\n  end\n  return nil\nend", "  if lst[1] == nil then\n\
    \    return nil\n  end\n  if #lst > 1 then\n    return lst[1]\n  end\n  return\
    \ next_smallest(lst[2:])\nend", "  local smallest\n  for i = 2, #lst do\n    if\
    \ lst[i] < smallest\n    or smallest == nil\n    then\n      smallest = lst[i]\n\
    \    end\n  end\n  return smallest\nend", "\tlocal smallest = nil\n\tfor idx,\
    \ x in ipairs(lst) do\n\t\tif smallest == nil then\n\t\t\tsmallest = x\n\t\t\t\
    continue\n\t\tend", "  local smallest, secondSmallest = nil, false\n  for i=1,\
    \ #lst do\n    local elm = lst[i]\n    if not smallest and elm < smallest then\n\
    \      secondSmallest = true\n      smallest = elm\n    elseif not secondSmallest\
    \ and elm > smallest then\n      secondSmallest = true\n      smallest = elm\n\
    \    end\n  end\n  return smallest and secondSmallest and smallest\nend\n</textarea></form>",
  "   if lst[1] < lst[2] then\n      return lst[2]\n   end\n   if lst[1] < lst[3]\
    \ then\n      return lst[3]\n   end\n   if lst[1] < lst[4] then\n      return\
    \ lst[4]\n   end\n   if lst[1] < lst[5] then\n      return lst[5]\n   end\nend",
  "  if #lst == 1 then\n    return lst[1]\n  end", "   if #lst == 1 then\n      return\
    \ lst[1]\n   end\n   local index = #lst\n   for i = 1, #lst - 1 do\n      if lst[i]\
    \ < lst[index] then\n         index = i\n      end\n   end\n   return lst[index\
    \ + 1]\nend", "  for _, _, _, next_value in ipairs(lst) do\n    if next_value\
    \ < lst[2] then\n      return next_value\n    end\n  end\n  return nil\nend",
  "  if lst[1] < lst[2] then\n    return lst[1]\n  else\n    return lst[2]\n  end\n\
    end", "  if #lst == 1 then\n    return lst[1]\n  elseif #lst > 1 then\n    local\
    \ n = 1\n    for i = 2, #lst do\n      if lst[i] < lst[n] then\n        n, i =\
    \ i, n\n      end\n    end\n    return lst[n]\n  else\n    return nil\n  end\n\
    end", "  if lst[1] == nil then return end\n  local _, _, i = select(2, lst)\n\
    \  if i == nil then return end\n  lst[i] = nil\n  return lst[i]\nend", "  local\
    \ min_value = lst[1]\n  lst[1] = nil\n  local i = 2\n  while i < #lst do\n   \
    \ if lst[i] < min_value then\n      min_value = lst[i]\n    end\n    i = i + 1\n\
    \  end\n  if min_value == nil then\n    return nil\n  end\n  local smallest_index\
    \ = i - 1\n  while smallest_index >= 1 do\n    lst[smallest_index] = nil\n   \
    \ smallest_index = smallest_index - 1\n  end\n  return min_value\nend", "  if\
    \ #lst < 2 then return nil end\n  local smallest = lst[1]\n  local pos = 1\n \
    \ for i = 2, #lst do\n    if lst[i] < smallest then smallest = lst[i] end\n  \
    \  if smallest > lst[pos] then return nil end\n    pos = pos + 1\n  end\n  return\
    \ smallest\nend", "  local smallest = lst[1]\n  \n  for i = 2, #lst do\n    if\
    \ smallest<lst[i] then\n      smallest = lst[i]\n    end\n  end\n  return smallest\n\
    end", "  for i = #lst, 1, -1 do\n    if lst[i] < lst[i - 1] then return lst[i]\
    \ end\n  end\n  return nil\nend", "  local smallest = 0\n  local next_index =\
    \ 1\n  local len = #lst\n  for i = 1, len do\n    if lst[i] < lst[smallest] then\n\
    \      smallest = next_index\n    end\n    next_index = next_index + 1\n  end\n\
    \  if smallest == 1 then return lst[1] end\n  return lst[smallest]\nend", "  \
    \  local current = 1\n    local found = 1\n    local smallest = 1\n    for i =\
    \ 1, #lst do\n        if lst[i] < smallest then\n            smallest = lst[i]\n\
    \            found = 1\n        elseif lst[i] == smallest and found == 1 then\n\
    \            current = i\n            found = 0\n        end\n    end\n    if\
    \ found == 1 then\n        return lst[current]\n    else\n        return nil\n\
    \    end\nend", "  for i, v in ipairs(lst) do\n    if i < 2 then\n      return\
    \ v\n    end\n  end\nend\n</cell>\n<text>\nThis isn't necessarily the most efficient\
    \ approach, but it's quite clear and understandable, and we can reuse it as much\
    \ as we want.", "  return lst and lst[next(lst, 2)] or nil\nend", "  local smallest\
    \ = lst[1]\n  for i = 2, #lst do\n    if lst[i] < smallest then\n      smallest\
    \ = lst[i]\n    end\n  end\n  return smallest\nend", "  local smallest = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] < smallest then\n      smallest = lst[i]\n\
    \    end\n  end\n  return smallest\nend", "  local smallest = nil\n  local count\
    \ = nil", "  local min_value = lst[1]\n  local min_idx = 1\n  for i = 2, #lst\
    \ do\n    if lst[i] < min_value then\n      min_value = lst[i]\n      min_idx\
    \ = i\n    end\n  end\n  return min_idx\nend", "    local smallest = lst[1]\n\
    \    for i = 2, #lst do\n        if smallest<lst[i] then\n            smallest\
    \ = lst[i]\n        end\n    end\n    return smallest\nend", "  if #lst == 0 then\n\
    \    return nil\n  else\n    return lst[#lst + 1]\n  end\nend", "  local smallest\
    \ = lst[1]\n  for i = 2, #lst do\n    if lst[i] < smallest then return nil end\n\
    \    smallest = lst[i]\n  end\n  return smallest\nend", "  for i, v in ipairs(lst)\
    \ do\n    if v < lst[i + 1] then\n      return v\n    end\n  end\n  return nil\n\
    end", "  local smallest = lst[1]\n  local index = 2\n  while index < #lst and\
    \ lst.data[index] < smallest do\n    smallest = lst.data[index]\n    index = index\
    \ + 1\n  end\n  return smallest\nend", "  -- Base case\n  if lst[1] == nil then\n\
    \    return nil\n  end", "    local smallest_value = lst[1]\n    local min_idx\
    \ = 1", "  local smallest\n  for i = 2, #lst do\n    if lst[i] < smallest then\n\
    \      smallest = lst[i]\n    end\n  end\n  return smallest\nend", "  local smallest,min_idx,new_list={},{},{}\n\
    \  for i,v in ipairs(lst) do\n    smallest[v]=v\n    min_idx[v]=i\n  end\n  local\
    \ next_idx=#lst+1\n  local max_idx=#lst\n  while true do\n    local v=lst[next_idx]\n\
    \    local next_key=smallest[v]\n    local next_idx=min_idx[next_key]\n    if\
    \ next_idx==max_idx then\n      new_list[#new_list+1]=v\n      return new_list\n\
    \    end\n    local next_key=smallest[lst[next_idx]]\n    local next_idx=min_idx[next_key]\n\
    \    if next_idx==max_idx then\n      new_list[#new_list+1]=v\n      return new_list\n\
    \    end\n    local next_key=smallest[lst[next_idx]]\n    local next_idx=min_idx[next_key]\n\
    \    smallest[v]=next_key\n    min_idx[v]=next_idx\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis doesn't work for negative numbers, which is why I added an\
    \ extra check.  When you have a negative number, the minimum index should be the\
    \ smallest positive index and this should work.\n<|/ c |>\n<| a |>\n<code>", " \
    \ -- Base case\n  if lst[1] ~= nil then\n    return lst[1]\n  end", "   local\
    \ min = lst[1]\n   for i = 2, #lst do\n      min = min > lst[i] and min or lst[i]\n\
    \   end\n   return min\nend", "  local len = #lst\n  if len == 0 then\n    return\
    \ nil\n  end\n  local i = 1\n  local tmp = 1\n  repeat\n    tmp = lst[i]\n   \
    \ if tmp <= tmp then\n      return tmp\n    end\n    i = i + 1\n  until i <= len\n\
    \  return nil\nend", "    local _, _, min, _ = lst:sort()\n    return min\nend",
  "    for i = #lst, 2, -1 do\n        if lst[i] < lst[i - 1] or i == 1 then\n   \
    \         return lst[i]\n        end\n    end\n    return nil\nend", "  local\
    \ smallest = lst[1]\n  local second_smallest = lst[2]\n  for i = 2, #lst do\n\
    \    local this_smallest = lst[i]\n    if this_smallest < second_smallest then\n\
    \      second_smallest = this_smallest\n      smallest = this_smallest\n    end\n\
    \  end\n  return smallest\nend", "  assert(type(lst) == 'table')\n  if #lst ==\
    \ 0 then return nil end\n  local smallest = lst[1]\n  for i = 2, #lst do\n   \
    \ local x = lst[i]\n    if x < smallest then return x end\n  end\n  return smallest\n\
    end", "    if lst == nil then\n        return nil\n    end\n    local min_index\
    \ = math.min(#lst, 2)\n    local min_value = lst[min_index]\n    local other_value\
    \ = lst[min_index + 1]\n    if other_value < min_value then\n        return min_value\n\
    \    else\n        return other_value\n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=lua |>\nFor anyone looking for an iterative solution:\n<code>", "  if\
    \ #lst == 0 then\n    return nil\n  end\n  local minv, v = lst[1], lst[1]\n  for\
    \ i = 2, #lst do\n    local vx = lst[i]\n    if vx < minv then\n      minv, v\
    \ = vx, vx\n    end\n  end\n  return v\nend", "  local smallest, i, curr = lst[1],\
    \ 1, lst[1]\n  for i = 2, #lst do -- find 2nd smallest element\n    if smallest\
    \ > lst[i] then\n      smallest, curr = lst[i], i\n    end\n  end\n  return curr,\
    \ smallest, i\nend\n</code>\n<|/ a |>\n<| c |>\nWhat is the purpose of \"smallest,\
    \ i, curr = lst[1], 1, lst[1]\" instead of just \"smallest, curr = lst[1]\"? Is\
    \ it because the first element can never be the smallest element?\n<|/ c |>\n\
    <| c |>\nThe purpose is to remember the smallest element and the index of the\
    \ smallest element (i for index, not for value).\n<|/ c |>\n<| c |>\nWhat is the\
    \ purpose of \"smallest, i, curr = lst[1], 1, lst[1]\" instead of just \"smallest,\
    \ curr = lst[1]\"? Is it because the first element can never be the smallest element?\n\
    <|/ c |>\n<| c |>\nYes, that is how I understood it, but I thought you might want\
    \ to explain that to me, because I didn't understand how it works.\n<|/ c |>\n\
    <| c |>\nI edited my answer to explain the meaning of this line.\n<|/ c |>\n<|\
    \ a |>\n<code>", "    local smallest = lst[1]\n    for i = 2, #lst do\n      \
    \  if lst[i] < smallest then return lst[i] end\n    end\n    return nil\nend",
  "  if lst:len() == 0 then\n    return nil\n  end\n  local idx = 1\n  while idx <\
    \ lst:len() do\n    local value = lst:get(idx)\n    if value == lst:get(idx-1)\
    \ then\n      return value\n    end\n    idx = idx + 1\n  end\n  return nil\n\
    end", "  if lst[1] == nil then return end\n  local min2 = lst[2]\n  if min2 ==\
    \ nil then return min2\n  else\n    local min1 = lst[1]\n    if min1 == nil then\
    \ return min2\n    else\n      min2, min1 = min1, min2\n    end\n  end\nend\n\
    print(next_smallest([1, 2, 3, 4, 5]))\nprint(next_smallest([5, 1, 4, 3, 2]))\n\
    print(next_smallest([]))\nprint(next_smallest([1, 1]))\n</cell>\n<text>\n4. Slicing\n\
    4.1 Slice\nThe slice function takes as arguments a list and an integer representing\
    \ a step value. It\u2019s return value is a new list.", "  if lst[1] < lst[2]\
    \ then\n    return lst[1]\n  elseif lst[1] > lst[2] then\n    return lst[2]\n\
    \  else\n    return nil\n  end\nend", "  if lst[1] > lst[2] then\n    return lst[2]\n\
    \  elseif lst[1] < lst[2] then\n    return lst[1]\n  else\n    return nil\n  end\n\
    end", "    local min_value = lst[1]\n    local i = 2\n    while i < #lst do\n\
    \        if lst[i] < min_value then\n            min_value = lst[i]\n        end\n\
    \        i = i + 1\n    end\n    return min_value\nend", "  local i = 0\n  for\
    \ _, e in pairs(lst) do\n    if i < 1 then return e end\n    if e < lst[i - 1]\
    \ then\n      i = i + 1\n    else\n      if i == 1 then return nil end\n     \
    \ i = i - 1\n    end\n  end\n  return lst[i + 1]\nend", "    if lst == nil then\n\
    \        return nil\n    end\n    if #lst == 1 then\n        return lst[1]\n \
    \   end\n    if lst[#lst] == lst[1] then\n        return nil\n    end\n    local\
    \ smallest = lst[1]\n    local index = 2\n    while index + 1 < #lst and lst[index\
    \ + 1] < smallest then\n        index = index + 1\n    end\n    return lst[index]\n\
    end", "   if lst == nil then return nil end\n   local small = lst[1]\n   local\
    \ rest = lst[2:]\n   if rest ~= nil and rest[1] ~= small then return next_smallest(rest)\
    \ end\n   return small\nend", "   if not lst[1] then\n      return nil\n   end\n\
    \   if #lst == 1 then\n      return lst[1]\n   end\n   return next(lst)\nend",
  "  local i = 1\n  while i < #lst and lst[i] <= lst[i - 1] do\n    i = i + 1\n  end\n\
    \  if i == #lst then return nil end\n  \n  return lst[i]\nend", "  local smallest\
    \ = lst[1]\n  local next_value = lst[2]\n  for i = 2, #lst do\n    smallest =\
    \ next_value\n    if lst[i] < smallest then\n      smallest = lst[i]\n    end\n\
    \  end\n  return smallest\nend", "  local smallest\n  for i=1,#lst do\n    if\
    \ smallest==nil then\n      smallest=lst[i]\n      break\n    end\n    if lst[i]<smallest\
    \ then\n      smallest=lst[i]\n    end\n  end\n  return smallest\nend", "    if\
    \ lst[1] == nil then\n        return nil\n    end\n    if lst[#lst] < lst[1] then\n\
    \        return lst[1]\n    else\n        return next_smallest(lst[#lst])\n  \
    \  end\nend", "  for i = 2, #lst do\n    if lst[i] < lst[i - 1] then\n      return\
    \ lst[i]\n    end\n  end\n  return nil\nend", "  if lst[1] == nil then return\
    \ nil end\n  if lst[1] < lst[2] then return lst[1] end\n  if lst[1] == lst[2]\
    \ then return nil end\n  return lst[2]\nend", "  if #lst < 1 then return nil end\n\
    \  local m = lst[1]\n  for i = 2, #lst do\n    if lst[i] < m then return m end\n\
    \    m = lst[i]\n  end\n  return nil\nend", "  if #lst > 1 then\n    return lst[#lst]\
    \ -- We need to return the 2nd smallest\n  else\n    return nil -- We didn't even\
    \ get 1 number\n  end\nend", "  local i = 1\n  while i <= #lst and lst[i] <= lst[i-1]\
    \ do\n    i = i + 1\n  end\n  return i ~= #lst and lst[i] or nil\nend", "  --\
    \ assert(lst)\n  for i = 2, #lst do\n    if lst[i] < lst[i-1] then\n      return\
    \ lst[i]\n    end\n  end\n  return nil\nend", "  local smallest, smallest_idx\
    \ = nil, -1\n  local i = 1\n  for i = 1, #lst do\n    local element = lst[i]\n\
    \    if not smallest then\n      smallest, smallest_idx = element, i\n    end\n\
    \    if element < smallest then\n      smallest, smallest_idx = element, i\n \
    \   end\n  end\n  return smallest and smallest_idx\nend", "  if lst[1] == nil\
    \ then return nil end\n  local smallest = lst[1]\n  for i = 2, #lst do\n    if\
    \ lst[i] < smallest then\n      smallest = lst[i]\n    end\n  end\n  return smallest\n\
    end", "  for i, v in pairs(lst) do\n    if i <= #lst and v < lst[i] then\n   \
    \   return v\n    end\n  end\nend", "  if lst == nil then\n    return nil\n  end\n\
    \  if #lst < 2 then\n    return lst[1]\n  end\n  local min_element = lst[1]\n\
    \  local min_element_index = 2\n  for i = 2, #lst do\n    local element = lst[i]\n\
    \    if element < min_element then\n      min_element = element\n      min_element_index\
    \ = i\n    end\n  end\n  return lst[min_element_index]\nend", "  if lst:len()\
    \ == 0 then\n    return nil\n  end\n  local smallest, index, value = lst:sort()\n\
    \  if smallest == value then\n    return nil\n  end\n  if index == 2 then\n  \
    \  return smallest\n  end\n  return next_smallest(lst:sublist(2))\nend", "  local\
    \ i = 1\n  while i < #lst do\n    if lst[i] < lst[i-1] then\n      i = i + 1\n\
    \    else\n      return lst[i]\n    end\n  end\nend", "  for i = 1, #lst - 1 do\n\
    \    if lst[i] < lst[i + 1] then\n      return lst[i + 1]\n    end\n  end\n  return\
    \ nil\nend", "  if lst[1] == nil then return nil end\n  if lst[1] == lst[2] then\
    \ return nil end\n  -- This will be the 2nd smallest element in the list.\n  return\
    \ lst[2]\nend", "  for _,x in ipairs(lst) do\n    if x < lst[#lst] then\n    \
    \  return x\n    end\n  end\n  return nil\nend", "  if #lst==0 then\n    return\
    \ nil\n  end\n  local min=lst[1]\n  for i=2,#lst do \n    if lst[i] < min then\
    \ \n      return lst[i]\n    end\n  end\n  return nil\nend\nprint(next_smallest([5,\
    \ 1, 4, 3, 2]))\nprint(next_smallest([2, 3, 4, 5]))\nprint(next_smallest([3, 2,\
    \ 5, 1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(next_smallest([-9,\
    \ -7, -5, -3, -1]))\nprint(next_smallest([-9, -7, -5, -3, -1]))\nprint(", "  \
    \  local pos = 1\n    local min_val = lst[1]\n    local count = 0\n    while pos\
    \ < #lst do\n        if lst[pos] < min_val then\n            min_val = lst[pos]\n\
    \            count = count + 1\n        end\n        pos = pos + 1\n    end\n\
    \    if count == #lst then\n        return nil\n    end\n    return min_val\n\
    end", "  if lst[1] == nil then return nil end\n  local index = #lst + 1\n  local\
    \ small, large\n  while index <= #lst do\n    local tmp = lst[index] == lst[index\
    \ + 1] and lst[index + 1] or lst[index]\n    local small, large = tmp , index\n\
    \    index = index + 1\n  end\n  return large or nil\nend", "\tlocal smallest,\
    \ second_smallest = lst[1], lst[2]\n\tfor i = 2, #lst do\n\t\tif smallest[1] <\
    \ lst[i] then\n\t\t\tsecond_smallest = smallest\n\t\t\tsmallest = lst[i]\n\t\t\
    elseif smallest[1] == lst[i] then\n\t\t\tsmallest = second_smallest\n\t\tend\n\
    \tend\n\treturn smallest\nend", "    local n = 1\n    local cur = lst[1]\n   \
    \ for _, v in ipairs(lst) do\n        if v < cur then\n            cur = v\n \
    \           n = n + 1\n        end\n    end\n    if n == 0 then\n        return\n\
    \    end\n    return cur\nend", "  if lst[1] == nil then\n    return nil\n  elseif\
    \ lst[1] == 1 then\n    return lst[2]\n  else\n    local smallest_idx = 1\n  \
    \  local smallest = lst[1]\n    for idx = 2, #lst do\n      local elm = lst[idx]\n\
    \      if elm < smallest then\n        smallest_idx = idx\n        smallest =\
    \ elm\n      end\n    end\n    return lst[smallest_idx]\n  end\nend", "   for\
    \ i = 1, #lst do\n      if lst[i] < lst[i-1] then\n         return lst[i-1]\n\
    \      end\n   end\n   return nil\nend", "  local smallest = nil\n  for i = 2,\
    \ #lst do\n    if lst[i] < smallest then\n      smallest = lst[i]\n    end\n \
    \ end\n  return smallest\nend", "  local smallest\n  for _, v in ipairs(lst) do\n\
    \    if not smallest then smallest = v end\n    if smallest ~= v then\n      smallest\
    \ = nil\n    end\n  end\n  if smallest then\n    return smallest\n  end\nend",
  "  if #lst > 0 then\n    return lst[1]\n  else\n    return nil\n  end\nend", " \
    \ local smallest = nil\n  local i = #lst\n  if i == 0 then return nil end\n  while\
    \ true do\n    i = i - 1\n    if i == 0 then return smallest end\n    local cur\
    \ = lst[i]\n    if smallest == nil then\n      smallest = cur\n    else\n    \
    \  if cur < smallest then\n        smallest = cur\n      end\n    end\n  end\n\
    end", "    if #lst == 0 then\n        return\n    end\n    local smallest = lst[1]\n\
    \    local index = 2\n    for i = 2, #lst do\n        if lst[i] < smallest then\n\
    \            smallest = lst[i]\n            index = i\n        end\n    end\n\
    \    return smallest, index\nend", "   if #lst < 2 then return nil end\n   if\
    \ #lst == 1 then return lst[1] end\n   local low = 1, #lst\n   local mid, high\
    \ = low / 2, low\n   while mid < high do\n      local element = lst[mid]\n   \
    \   if element < lst[low] then low = mid, mid = low / 2, low % 2 end\n      if\
    \ element < lst[high] then high = mid, mid = high / 2, high % 2 end\n      if\
    \ element == lst[mid] then return element end\n   end\n   return lst[high]\nend",
  "  local i, count = 1, 1\n  local last = lst[1]", "  local size = #lst\n  if size\
    \ <= 0 then\n    return nil\n  end\n  local index = size - 1\n  -- Loop backwards\
    \ to find the second smallest element\n  while index > 1 do\n    if lst[index]\
    \ < lst[index - 1] then\n      -- Move index\n      index = index - 1\n      --\
    \ Go to the next index\n    else\n      -- Found the 2nd smallest element\n  \
    \    return lst[index]\n    end\n  end\n  return nil\nend", "  local lst2 = {}\n\
    \  for i = 2, #lst do\n    lst2[i] = lst[i]\n  end\n  return lst2[table.sort(lst2)[2]]\n\
    end", "  -- Base case\n  if lst == nil then return nil end\n  -- Get the first\
    \ element and make that the smallest\n  local element = lst[1]\n  lst[1] = nil\n\
    \  -- Scan the list and remove every element that is smaller than the current\
    \ smallest element\n  for i = 2, #lst do\n    if lst[i] < element then\n     \
    \ element = lst[i]\n    end\n    lst[i] = nil\n  end\n  return element\nend",
  "  local smallest = lst[1]\n  for i = 2, #lst do\n    if smallest[1] < lst[i] then\n\
    \      smallest = lst[i]\n    end\n  end\n  return smallest\nend", "  for i =\
    \ 1, #lst do\n    if lst[i] < lst[i - 1] then\n      return lst[i]\n    end\n\
    \  end\n  return nil\nend", "    if lst == nil then\n        return nil\n    end\n\
    \    if lst[1] == lst[2] then\n        return lst[2]\n    end\n    return lst[1]\n\
    end", "   -- Base case\n   if #lst==0 then return nil end\n   -- Get element 1\n\
    \   local elem = lst[1]\n   -- Iterate over rest of the array\n   for i = 2, #lst\
    \ do\n      if elem<lst[i] then\n         elem = lst[i]\n      end\n   end\n \
    \  return elem\nend", "  local smallest = nil\n  local next_index = nil\n  for\
    \ i, v in pairs(lst) do\n    if smallest == nil then\n      smallest = v\n   \
    \   next_index = i\n    elseif v < smallest then\n      smallest = v\n      next_index\
    \ = i\n    end\n  end\n  if next_index == nil then\n    return nil\n  end\n  return\
    \ lst[next_index]\nend", "  local smallest = lst[1]\n  for i = 2, #lst do\n  \
    \  if lst[i] < smallest then\n      smallest = lst[i]\n    end\n  end\n  return\
    \ smallest\nend", "  local min_idx, min_val = 0, lst[1]\n  for idx = 2, #lst do\n\
    \    if lst[idx] < min_val then\n      min_val = lst[idx]\n      min_idx = idx\n\
    \    end\n  end\n  if min_idx < #lst - 1 then\n    return lst[min_idx + 1]\n \
    \ else\n    return nil\n  end\nend", "  if lst[1] == nil then\n    return nil\n\
    \  else\n    return lst[2]\n  end\nend", "    for i = 1, #lst do\n        if lst[i]\
    \ < lst[i - 1] then\n            return lst[i]\n        end\n    end\nend", " \
    \ local smallest = lst[1]\n  local i = 1\n  while i <= #lst do\n    if lst[i]\
    \ < smallest then\n      smallest = lst[i]\n    end\n    i = i + 1\n  end\n  return\
    \ smallest\nend\nprint(next_smallest([1, 2, 3, 4, 5]))\nprint(next_smallest([5,\
    \ 1, 4, 3, 2]))\nprint(next_smallest([]))\nprint(next_smallest([1, 1]))", "  if\
    \ lst[1] == nil then return nil end\n  local small = lst[1]\n  local pos = 1\n\
    \  for i = 2, #lst do\n    if lst[i] < small then small = lst[i] end\n    pos\
    \ = pos\n  end\n  return small\nend", "  if lst == nil then return nil end\n \
    \ local i = 1\n  local smallest = lst[1]\n  for i = 2, #lst do\n    if lst[i]\
    \ < smallest then\n      smallest = lst[i]\n    end\n  end\n  return smallest\n\
    end", "  return lst[2] or lst[1]\nend", "  if #lst <= 1 then\n    return nil\n\
    \  end\n  local min = lst[1]\n  local index = 2\n  while index <= #lst do\n  \
    \  local val = lst[index]\n    if val < min then\n      min = val\n    end\n \
    \   index = index + 1\n  end\n  return min\nend", "  if #lst == 0 then\n    return\
    \ nil\n  end\n  local minimum = lst[1]\n  for i = 2, #lst do\n    if lst[i] <\
    \ minimum then\n      minimum = lst[i]\n    end\n  end\n  return minimum\nend\n\
    print(next_smallest([3, 5, 1, 4, 2]))\nprint(next_smallest([3, 5, 1, 4, 2]))\n\
    print(next_smallest([5, 4, 3, 2, 1]))\nprint(next_smallest([5, 4, 3, 2, 1]))\n\
    print(next_smallest([]))\nprint(next_smallest([2, 1, 0]))\nprint(next_smallest([3,\
    \ 1, 2, 4, 5]))", "  for i = #lst, 2, -1 do\n    if lst[i] < lst[i-1] then\n \
    \     return lst[i]\n    end\n  end\n  return nil\nend", "  local smallest = nil\n\
    \  for i = #lst, 2, -1 do\n    if smallest==nil then\n      smallest = lst[i]\n\
    \    elseif lst[i]<smallest then\n      smallest = lst[i]\n    end\n  end\n  return\
    \ smallest\nend", "  if lst[1] ~= nil then\n    local smallest = lst[1]\n    for\
    \ i = 2, #lst do\n      if lst[i] < smallest then\n        smallest = lst[i]\n\
    \      end\n    end\n    return smallest\n  else\n    return nil\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
