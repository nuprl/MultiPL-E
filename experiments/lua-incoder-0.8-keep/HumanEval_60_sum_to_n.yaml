name: HumanEval_60_sum_to_n
language: lua
prompt: "-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n(30)\n\
  -- 465\n-- >>> sum_to_n(100)\n-- 5050\n-- >>> sum_to_n(5)\n-- 15\n-- >>> sum_to_n(10)\n\
  -- 55\n-- >>> sum_to_n(1)\n-- 1\nlocal function sum_to_n(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_to_n\n\
  \    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(6), 21)\n \
  \   lu.assertEquals(candidate(11), 66)\n    lu.assertEquals(candidate(30), 465)\n\
  \    lu.assertEquals(candidate(100), 5050)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local c = 0\n  for i = 1, n do c = c + (n-i+1) end\n  return c\n\
    end", "  if n < 2 then return n else return (n % 2 == 0) and sum_to_n(n / 2) or\
    \ n * 3 + 1 end\nend", "  if n <= 0 then\n    return 0\n  elseif n == 1 then\n\
    \    return 1\n  else\n    return n * sum_to_n(n - 1)\n  end\nend", "  -- The\
    \ sum of an arithmetic progression is the sum of the numbers\n  -- from 1 to n.\n\
    \  -- For a progression A to B, if B = A + k, and k = 1, then the\n  -- sum is\
    \ A + A + A + ... + B.\n  -- So the sum of an arithmetic progression A to n is\
    \ (n + 1)*(A + 1).\n  return math.max(n, 1) + math.min(1 + n, n)\nend", "  local\
    \ total = 0\n  for i = 1, n do\n    total = total + i\n  end\n  return total\n\
    end", "  local sum = 0\n  for i = 1, n do\n    sum = sum + i\n  end\n  return\
    \ sum\nend", "  if n <= 1 then return n else return n % 2 == 0 and n or n * sum_to_n(n-1)\
    \ / 2 end\nend", "\tlocal result = 0\n\tlocal i = 1\n\twhile i <= n do\n\t\tresult\
    \ = result + i\n\t\ti = i + 1\n\tend\n\treturn result\nend", "  local s = 0\n\
    \  for i = 1, n do\n    s = s + i\n  end\n  return s\nend", "    return math.floor(n\
    \ * math.log(n, 2) + .5) + 1\nend", "  return math.floor(math.exp(math.log(n)\
    \ / math.log(2)))\nend", "\tlocal sum = math.rawast\n\tlocal factor = 1\n\twhile\
    \ n >= 1 do\n\t\tsum = sum + n * factor\n\t\tfactor = factor * 10\n\t\tn = n /\
    \ 10\n\tend\n\treturn sum\nend", "  if n <= 1 then\n    return 1\n  else\n   \
    \ return n + sum_to_n(n - 1)\n  end\nend", "  local s = 0\n  for i = 1, n do\n\
    \    s = s + i\n  end\n  return s\nend", "  local s = 0\n  for i = 1,n do s =\
    \ s + i end\n  return s\nend", "  -- TODO: Don't let the number grow too big\n\
    \  local s = 0 -- The accumulator of sums\n  -- Iterate through the numbers from\
    \ 1 to n\n  for i in 1,n do\n    s = s + i\n  end\n  -- Return the accumulator\
    \ of sums\n  return s\nend", "  if n == 1 then return 1 end\n  return n + sum_to_n(n\
    \ - 1)\nend", "    local i, s = 0\n    repeat\n        i = i + 1\n        s =\
    \ s + i\n    until i > n\n    return s\nend", "  -- Create a table.\n  local table\
    \ = {}\n  -- Start summing from 1.\n  table.n = 1\n  -- While we still have numbers\
    \ to sum...\n  repeat\n    -- Add one to the sum and remove one from the value.\n\
    \    table.n = table.n + 1\n    table.n = table.n - 1\n  until table.n >= n\n\
    \  -- Return the sum of the table.\n  return table.n\nend", "  if n == 1 then\n\
    \    return 1\n  elseif n > 1 then\n    return sum_to_n(n - 1) + sum_to_n(n -\
    \ 2)\n  else\n    return 0\n  end\nend", "  if n < 1 then return 0 end\n  return\
    \ n + sum_to_n(n - 1)\nend", "    if n == 1 then\n        return 1\n    end\n\
    \    return n + sum_to_n(n-1)\nend", "  return assert(n >= 1, \"invalid n\")\n\
    end", "    local result = 0\n    for i=1,n do \n        result = result + i\n\
    \    end\n    return result\nend", "  if n > 0 then\n    return n + sum_to_n(n\
    \ - 1)\n  end\nend", "  return function(m)\n    if m == 0 then\n      return 1\n\
    \    else\n      return m + (n % m) * (sum_to_n(m))\n    end\n  end\nend", "\t\
    if n < 0 then\n\t\treturn n\n\telse\n\t\treturn n + sum_to_n(n-1)\n\tend\nend",
  "  if n <= 1 then\n    return n\n  end\n  return n + sum_to_n(n - 1)\nend", "  return\
    \ math.floor(math.exp((math.log(n))/math.log(2)))\nend", '  local n', "  return\
    \ math.pow(10, math.floor((math.log(n)/math.log(10))*10)+1) - math.pow(10, math.floor(math.log(n)/math.log(10)))\n\
    end", "\tif n < 1 then\n\t\treturn n\n\telse\n\t\tlocal s = n + n - 1\n\t\twhile\
    \ n > 0 do\n\t\t\ts = s + n\n\t\t\tn = n - 1\n\t\tend\n\t\treturn s\n\tend\nend",
  "  local result = 1\n  for i = 1, n do result = result + 1 end\n  return result\n\
    end", "  if n == 1 then\n    return 1\n  else\n    return n + sum_to_n(n - 1)\n\
    \  end\nend", "  if n == 0 then\n    return 1\n  elseif n < 0 then\n    -- Negative\
    \ numbers are not summable:\n    -- >>> sum_to_n(-1)\n    -- Traceback (most recent\
    \ call last):\n    -- ValueError: negative number cannot be summable\n    -- >>>\
    \ sum_to_n(2)\n    -- Traceback (most recent call last):\n    -- ValueError: negative\
    \ number cannot be summable\n    -- >>> sum_to_n(3)\n    -- Traceback (most recent\
    \ call last):\n    -- ValueError: negative number cannot be summable\n    -- >>>\
    \ sum_to_n(10)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(100)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-1)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-2)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-10)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-100)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-5)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-10)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-1)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-2)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-10)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-100)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-5)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-10)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-1)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-2)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-10)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-100)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-5)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-10)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be summable\n\
    \    -- >>> sum_to_n(-1)\n    -- Traceback (most recent call last):\n    -- ValueError:\
    \ negative number cannot be summable\n    -- >>> sum_to_n(-2)\n    -- Traceback\
    \ (most recent call last):\n    -- ValueError: negative number cannot be sum",
  "    return math.floor(n * (1 + math.log(n, n))) - math.floor(n/2)\nend", "   if\
    \ n == 1 then\n      return 1\n   else\n      return n * sum_to_n(n - 1)\n   end\n\
    end\n</cell>\n<text>\nThe function sum_to_n(n) above is recursive and it uses\
    \ the same concept as sum(n) to sum the numbers from 1 to n. The trick above is\
    \ that the sum_to_n(n) function returns n * sum_to_n(n - 1). For example, sum_to_n(4)\
    \ is calculated as 4 * sum_to_n(3). Let's try the example above.", "    local\
    \ s = 0\n    for i = 1, n do\n        -- Each number is being added and multiplied\
    \ by 2 until it reaches n.\n        s = s + i\n    end\n    return s\nend", " \
    \ if n <= 1 then\n    return 1\n  end", "  local total = 0\n  for i=1,n do\n \
    \   total = total + i\n  end\n  return total\nend", "  return n*(n+1)/2\nend\n\
    </cell>\n<text>\nThe following cell contains the entire script from the previous\
    \ cells. In it we define a function to take a file name as an argument, opens\
    \ that file, and writes the output to a new file with the same name but an extension\
    \ of \"csv\". Then we call that function on every file in the directory and save\
    \ the results to the \"output\" directory.", "  if n < 1 then\n    return 0\n\
    \  end\n  local total = 1\n  for i = 1, n do\n    total = total + i\n  end\n \
    \ return total\nend", "  if n == 0 then return 1 end\n  local sum = 1\n  for i\
    \ = 1, n do\n    sum = sum + i\n  end\n  return sum\nend", "  local s = 0\n  while\
    \ n do\n    s = s + n\n    n = n - 1\n  end\n  return s\nend", "  if n == 0 then\n\
    \    return 1\n  end\n  local function loop(n, sum)\n    if n == 0 then\n    \
    \  return sum\n    end\n    return loop(n-1, sum + n)\n  end\n  return loop(n,0)\n\
    end", "  return math.floor(n * (math.log(n) + math.log(math.max(n - 1, 1))))\n\
    end", "  local sum = 0\n  for i = 1, n do\n    sum = sum + i\n  end\n  return\
    \ sum\nend", "  if n > 0 then\n    return sum_to_n(n - 1) + n\n  else\n    return\
    \ 0\n  end\nend", "  local accum = 1\n  while n do\n    accum = accum + n\n  \
    \  n = n - 1\n  end\n  return accum\nend", "  local n1 = 1\n  while n1 < n do\n\
    \    n1 = n1 + 1\n  end\n  return n1\nend", "  if n <= 0 then\n    return 0\n\
    \  end\n  -- We want to return 1 + the previous partial sum.\n  local partial_sum\
    \ = 1\n  local i = 1\n  while i <= n do\n    partial_sum = partial_sum + i\n \
    \   -- We have used up all the numbers to compute partial sum.\n    -- Now sum\
    \ up the current partial sum.\n    i = i + 1\n  end\n  -- Return partial sum.\n\
    \  return partial_sum\nend", "  if n > 0 then\n    return n + sum_to_n(n-1)\n\
    \  else\n    return 1\n  end\nend", "    local r = 0\n    for i = 1, n do\n  \
    \      r = r + i\n    end\n    return r\nend\n</cell>\n<text>\nExample: Find all\
    \ the prime numbers less than 100", "  if n == 0 then\n    return 1\n  else\n\
    \    return n + sum_to_n(n - 1)\n  end\nend", "  -- Calculate the first n numbers\
    \ using an explicit loop.\n  -- This is slow, but it's OK because this code will\
    \ only ever be\n  -- evaluated on a finite set of input.\n  for x = 1, n do\n\
    \    local result = x + 1\n    if x == n then break end\n    local rest = x -\
    \ 1\n    local accum = sum_to_n(rest)\n    result = result + accum\n  end\n  return\
    \ result\nend", "  local n = 1\n  local sum = 1\n  while n <= n do\n    sum =\
    \ sum + n\n    sum = sum + n\n    n = n + 1\n  end\n  return sum\nend", "  if\
    \ n == 1 then\n    return 1\n  end", "  if n < 1 then\n    return 0\n  else\n\
    \    local n = math.floor(n)\n    local sum = 0\n    for i = 1, n do\n      sum\
    \ = sum + i\n    end\n    return sum\n  end\nend\n</cell>\n<text>\nExercise: Sum\
    \ to N!\nWrite a function that sums to infinity. It should use the function sum_to_n.",
  "  local s = (n*(n+1)/2)\n  return s\nend", "  local sum = 0\n  for _ = 1, n do\n\
    \    sum = sum + 1\n  end\n  return sum\nend", "  if n == 1 then\n    return 1\n\
    \  else\n    return n * sum_to_n(n - 1)\n  end\nend", "  if n == 0 then\n    local\
    \ ret = 0\n    return ret\n  end\n  if n <= 0 then\n    error(\"arg out of range\"\
    )\n  end\n  local ret = 0\n  local sum = 1\n  while sum < n do\n    sum = sum\
    \ + sum\n    ret = ret + sum\n  end\n  return ret\nend", "  if n == 0 then return\
    \ 0 else return n % 10 + sum_to_n(n / 10)\nend", "  local sum = 1\n  for _ = 1,\
    \ n do\n    sum = sum + sum_to_n(sum + 2)\n  end\n  return sum\nend", "  if n\
    \ == 0 then\n    return 1\n  else\n    return n + sum_to_n(n - 1)\n  end\nend",
  "  if n == 1 then\n    return 1\n  else\n    return sum_to_n(n - 1) + 1\n  end\n\
    end", "   if n == 0 then\n      return 1\n   else\n      return n * sum_to_n(n\
    \ - 1)\n   end\nend", "  if n < 1 then\n    return nil\n  end\n  return math.floor(n\
    \ / 2) + sum_to_n(n - math.floor(n / 2))\nend", "\tif n == 0 then return 1 end\n\
    \tlocal n2 = n*2\n\tif n2 <= n then return n end\n\tlocal m = (n - n2)/2\n\treturn\
    \ n*m + sum_to_n(m) + (n2 - n)*sum_to_n(n2)\nend", "  if n == 1 then\n    return\
    \ 1\n  else\n    return n + sum_to_n(n - 1)\n  end\nend", "  return math.floor(n\
    \ * (n + 1) / 2)\nend\nreturn sum_to_n", "\t-- Base cases: 0 sum is 1, 1 sum is\
    \ n, 2 sum is n*n, etc.\n\t-- >>> sum_to_n(0)\n\t-- 1\n\t-- >>> sum_to_n(1)\n\t\
    -- 1\n\t-- >>> sum_to_n(2)\n\t-- 2\n\t-- >>> sum_to_n(3)\n\t-- 6\n\t-- >>> sum_to_n(10)\n\
    \t-- 55\n\t-- >>> sum_to_n(100)\n\t-- 5050\n\t-- >>> sum_to_n(5)\n\t-- 15\n\t\
    -- >>> sum_to_n(10)\n\t-- 55\n\t-- >>> sum_to_n(1)\n\t-- 1\n\tif n == 0 then\n\
    \t\treturn 1\n\telseif n == 1 then\n\t\treturn n\n\telse\n\t\treturn n * sum_to_n(n\
    \ - 1)\n\tend\nend", "  n = n or 0\n  return function(x)\n    if x ~= 0 then\n\
    \      x = x + 1\n      return n(x)\n    end\n    return n\n  end\nend", "  if\
    \ n == 0 then\n    return 0\n  else\n    return 1 + sum_to_n(n - 1)\n  end\nend",
  "  if n == 0 then\n    return 0\n  else\n    return n + sum_to_n(n - 1)\n  end\n\
    end", "  return math.floor(math.log10(math.pow(10,math.floor(math.log10(n)-1))+1)+1)*n\
    \ + math.floor(math.log10(math.pow(10,math.floor(math.log10(n)-1)))+1)*(n-1) +\
    \ math.floor(math.log10(n)+1)\nend", "  local sum = 0\n  for i = 1,n do\n    sum\
    \ = sum + i\n  end\n  return sum\nend", "  return n+n .. '!'\nend\n</cell>\n<cell>",
  "\t-- We start with a partial sum of the first n-1 terms.\n\t-- The last term is\
    \ n*(n-1)/2, so we get to (n*n+1)/2\n\tlocal partial_sum = 0\n\tfor i = 1, n do\n\
    \t\t-- Each term is i*(i+1)/2, so we get to (i*(i+1))/2\n\t\tpartial_sum = partial_sum\
    \ + i * (i + 1)\n\tend\n\t-- We get the sum of the last term by adding the partial\
    \ sum with the partial sum of the last term + n.\n\t-- This gives us the final\
    \ sum.\n\treturn partial_sum + sum_to_n(n + 1)\nend", "  -- Return a sum of the\
    \ numbers from 1 to n.\n  if n == 1 then\n    return 1\n  else\n    return n +\
    \ sum_to_n(n-1)\n  end\nend", "  if n == 0 then\n    return 1\n  else\n    local\
    \ ns = n - 1\n    return 1 + sum_to_n(ns)\n  end\nend", "    local sum = 0\n \
    \   for i = 1, n do\n        sum = sum + i\n    end\n    return sum\nend", " \
    \ local s = 0\n  for i = 1, n do\n    s = s + i\n  end\n  return s\nend", "  if\
    \ n == 1 then\n    return 1\n  else\n    return n + sum_to_n(n - 1)\n  end\nend",
  "  if n > 0 then\n    return n + sum_to_n(n - 1)\n  else\n    return 1\n  end\n\
    end", "  if n == 1 then\n    return 1\n  end\n  if n == 2 then\n    return 1\n\
    \  end\n  if n % 2 == 0 then\n    local k = sum_to_n(n - 1)\n    return k * k\n\
    \  end\n  local k = sum_to_n(n - 1)\n  return k + k\nend", "  local total = 0\n\
    \  for i = 1, n do\n    total = total + i\n  end\n  return total\nend", "  return\
    \ math.floor(math.sqrt(n)) * (math.pow(2, math.ceil(math.log(math.abs(n), 2))))\n\
    end", "  return 1 .. n\nend", "    if n == 0 then\n        return 1\n    end\n\
    \    local s = n\n    repeat\n        s = s + 1\n    until s > n\n    return s\n\
    end", "  if n <= 0 then return end\n  if n > 1 then\n    return n + sum_to_n(n\
    \ - 1)\n  end\n  return n\nend", "  return math.floor(math.pow(n, 2) + math.pow(n,\
    \ 3))\nend", "  if n <= 0 then return 0 end\n  local s = 0.0\n  for i=1, n do\
    \ s = s + i end\n  return s\nend", "  return n * (n + 1) / 2\nend", "  return\
    \ math.floor(n * (n + 1)) / 2\nend", "  local c = 0\n  for i=1,n do\n    c = c\
    \ + i\n  end\n  return c\nend", "  if n == 0 then\n    return 1\n  else\n    return\
    \ n * sum_to_n(n - 1)\n  end\nend", "  -- Return a function that sums integers\
    \ from 1 to n.\n  -- >>> sum_to_n(30)()\n  -- 465\n  -- >>> sum_to_n(100)()\n\
    \  -- 5050\n  -- >>> sum_to_n(5)()\n  -- 15\n  -- >>> sum_to_n(10)()\n  -- 55\n\
    \  -- >>> sum_to_n(1)()\n  -- 1\n  local sum_up_to_n = function(n)\n    -- Return\
    \ a function that sums integers from 1 to n.\n    -- >>> sum_up_to_n(30)()\n \
    \   -- 465\n    -- >>> sum_up_to_n(100)()\n    -- 5050\n    -- >>> sum_up_to_n(5)()\n\
    \    -- 15\n    -- >>> sum_up_to_n(10)()\n    -- 55\n    -- >>> sum_up_to_n(1)()\n\
    \    -- 1\n    local num_sums = {}\n    for i = 1, n do\n      num_sums[i] = nil\n\
    \    end\n    return function() -- Return a function that sums integers from 1\
    \ to n.\n    -- >>> num_sums[1]()\n    -- nil\n    -- >>> num_sums[2]()\n    --\
    \ nil\n    -- >>> num_sums[3]()\n    -- nil\n    -- >>> num_sums[4]()\n    --\
    \ nil\n    -- >>> num_sums[5]()\n    -- nil\n    -- >>> num_sums[6]()\n    --\
    \ nil\n    -- >>> num_sums[7]()\n    -- nil\n    -- >>> num_sums[8]()\n    --\
    \ nil\n    -- >>> num_sums[9]()\n    -- nil\n    -- >>> num_sums[10]()\n    --\
    \ nil\n    -- >>> num_sums[11]()\n    -- nil\n    -- >>> num_sums[12]()\n    --\
    \ nil\n    -- >>> num_sums[13]()\n    -- nil\n    -- >>> num_sums[14]()\n    --\
    \ nil\n    -- >>> num_sums[15]()\n    -- nil\n    -- >>> num_sums[16]()\n    --\
    \ nil\n    -- >>> num_sums[17]()\n    -- nil\n    -- >>> num_sums[18]()\n    --\
    \ nil\n    -- >>> num_sums[19]()\n    -- nil\n    -- >>> num_sums[20]()\n    --\
    \ nil\n    -- >>> num_sums[21]()\n    -- nil\n    -- >>> num_sums[22]()\n    --\
    \ nil\n    -- >>> num_sums[23]()\n    -- nil\n    -- >>> num_sums[24]()\n    --\
    \ nil\n    -- >>> num_sums[25]()\n    -- nil\n    -- >>> num_sums[26]()\n    --\
    \ nil\n    -- >>> num_sums[27]()\n    -- nil\n    -- >>> num_sums[28]()\n", " \
    \ local sum = 0\n  for i = 1, n do sum = sum + i end\n  return sum\nend", "  if\
    \ n == 1 then\n    return 1\n  end\n  local m = math.floor((n - 1) / 2)\n  local\
    \ a, b = m - 1, n\n  while b <= n do\n    local x = a * 2 + b\n    a = x\n   \
    \ b = x\n  end\n  return a * 2\nend", "  if n == 0 then\n    return 1\n  elseif\
    \ n <= 1 then\n    return n\n  else\n    return n * sum_to_n(n - 1)\n  end\nend",
  "  if n < 1 then\n    error(\"invalid input\")\n  end\n  return n * sum_to_n(n -\
    \ 1)\nend", "  if n <= 0 then return end\n  if n == 1 then\n    return 1\n  end\n\
    \  return n * sum_to_n(n - 1)\nend", "  if n <= 1 then\n    return n\n  end\n\
    \  return sum_to_n(n - 1) + n\nend", "\tlocal s = 0\n\tfor i = 1, n do\n\t\ts\
    \ = s + i\n\tend\n\treturn s\nend", "  local sum = 0\n  for i = 1, n do\n    sum\
    \ = sum + i\n  end\n  return sum\nend", "  if n == 1 then return 1 else return\
    \ n * sum_to_n(n - 1)\nend", "  -- if we're dealing with a number bigger than\
    \ the sum of the number series up to the \n  -- first n numbers, return that number\
    \ -- otherwise, return 0 (the sum of number\n  -- series up to the first n numbers\
    \ is 1)\n  if n > sum(n) then\n    return n\n  else\n    -- return sum up to the\
    \ first n numbers + the sum of the rest of the numbers series up\n    -- to the\
    \ first n numbers\n    return sum(n + sum_to_n(n))\n  end\nend", "    if n <=\
    \ 0 then\n        return 0;\n    elseif n == 1 then\n        return 1;\n    else\n\
    \        return n*n + sum_to_n(n-1);\n    end\nend\n</cell>\n<text>\nChallenge\
    \ 9: Recursion", "  return math.floor(math.sqrt(math.pow(n, 2) + 1) + 0.5)\nend",
  "  if n == 1 then return 1 end\n  return 1 + sum_to_n(n - 1)\nend\n</cell>\n<text>\n\
    In our algorithm, $N$ is a parameter of the algorithm. For example, you can use\
    \ a larger or smaller set $N$, and you can use a higher or lower value $N$ for\
    \ $k$. Note that the same function can be used for different values of $N$.",
  "  return math.min(math.max(sum_to_n(n-1), 0), n)\nend", "  return 1 + sum_to_n(n\
    \ - 1)\nend", "  local sum = 0\n  for i = 1, n do\n    sum = sum + i\n  end\n\
    \  return sum\nend", "  return math.floor((math.log(n) / math.log (10)))\nend",
  "  return n*(n+1)/2\nend", "  local s = 0\n  for i = 1, n do\n    sum = sum + i\n\
    \  end\n  return s\nend", "\tlocal function sum_to_n_(n)\n\t\tif n > 0 then\n\t\
    \t\treturn sum_to_n_(n-1) + n\n\t\telse\n\t\t\treturn n\n\t\tend\n\tend\n\treturn\
    \ sum_to_n_(math.max(1,n))\nend", "  if n <= 0 then\n    return 0\n  else\n  \
    \  return sum_to_n(n - 1) + 1\n  end\nend", "  return n*(n+1)/2\nend", "   local\
    \ n = 1\n   local result = 1\n   while n > 1 do\n      n = n * 2\n      result\
    \ = result + n\n   end\n   return result\nend", "  if n == 0 then\n    return\
    \ 0\n  elseif n == 1 then\n    return 1\n  else\n    local sum = 1\n    for i\
    \ = 2, n do\n      sum = sum + i\n    end\n    return sum\n  end\nend", "  if\
    \ n == 0 then\n    return 1\n  else\n    return n + sum_to_n(n - 1)\n  end\nend",
  "  return math.floor(n/2) + sum_to_n(n-math.floor(n/2))\nend", "  return math.floor(n\
    \ * (2 * n - 1)) + 1\nend", "  if n == 0 then\n    return 1\n  else\n    return\
    \ n + sum_to_n(n - 1)\n  end\nend", "  local n2 = math.floor(n/2)\n  if n == n2\
    \ then\n    return n\n  end\n  return sum_to_n(n2) + n - n2*2\nend", "    if n\
    \ == 1 then\n        return 1\n    end\n    if n < 0 then\n        return 0\n\
    \    end\n    if n < 1000 then\n        return n * sum_to_n(n - 1)\n    end\n\
    \    local sum = 1\n    for i = 2, n do\n        sum = sum + i\n    end\n    return\
    \ sum\nend", "  return n and n + (sum_to_n(n-1) or 1)\nend", "  return math.floor((math.pow(math.e,\
    \ n) - 1) / math.e) + 1;\nend", "  -- Start with n = 1.\n  -- Repeat until n is\
    \ greater than or equal to zero,\n  -- and then subtract one from the result.\n\
    \  local n = 1\n  -- Store the result.\n  local total = 0\n  -- While n is greater\
    \ than or equal to zero,\n  -- repeat n times:\n  repeat\n    total = total +\
    \ n\n    n = n - 1\n  until n > 0 or n == 0\n  return total - 1\nend", "\tlocal\
    \ s = 0\n\tfor i = 1, n do s = s + i end\n\treturn s\nend\n</cell>\n<text>\nA\
    \ recursive function is one that is calling itself (calling a function). In Python,\
    \ this is the word function. Note that recursive functions are usually written\
    \ with def instead of function, as functions are first-class values.", "    return\
    \ math.floor(math.log(n, 2)) + math.floor(math.log(n, 2) ^ 2)\nend", "    if n\
    \ < 0 then return nil end\n    local s = math.floor(n)\n    return s + sum_to_n(n\
    \ - s)\nend", "    return n and n*(n+1)/2\nend", "  return math.floor(n/2) * math.floor(n/2)\
    \ + math.floor(n/2) + 1\nend", "\tif n < 1 then return 1 end\n\tlocal sum = 0\n\
    \tfor i = 1, n do\n\t\tsum = sum + i\n\tend\n\treturn sum\nend", "  return math.floor(math.pow(n,\
    \ math.ceil(math.log(math.max(1, n)) + 0.5))) * math.pow(n, math.ceil(math.log(math.max(1,\
    \ n)) / math.log(2)))\nend", "  local s = 0\n  for i = 1, n do\n    s = s + i\n\
    \  end\n  return s\nend", "  if n == 0 then\n    return 0\n  else\n    local n\
    \ = n + 1\n    return n * sum_to_n(n)\n  end\nend\n</cell>\n<text>\nLet's try\
    \ it out using our sum_to_n function.", "  if n == 1 then return 1 else return\
    \ n * sum_to_n(n - 1)\nend", "  if n == 1 then\n    return 1\n  end\n  return\
    \ n * sum_to_n(n - 1)\nend", "  return assert(tonumber(math.fsum(i for i in range(1,\
    \ n))))\nend", "  if n == 0 then\n    return 1\n  elseif n < 0 then\n    error(\"\
    a number n should be non-negative\")\n  end\n  return math.max(n + sum_to_n(n-1),\
    \ 1)\nend", "  local sum = 0\n  for i = 1, n do\n    sum = sum + i\n  end\n  return\
    \ sum\nend", "  if n == 0 then\n    return 0\n  end\n  local s = 0\n  for i =\
    \ 1, n do\n    local e = math.floor(i*(i+1)/2 + 1)\n    local f = math.floor((n-i)*(i+1)/2)\n\
    \    s = s + math.floor(i+(i+1)/2)*(e-1)\n    s = s + math.floor(n-i-1)*f\n  end\n\
    \  return s\nend", "  return math.max(n and n - (n % 2 and 1 or 0), 0)\nend",
  "  local result = 0\n  for i = 1, n do\n    local tmp = i * i\n    local n = i -\
    \ 1\n    local tmp2 = tmp + tmp\n    local tmp3 = tmp + n\n    result = result\
    \ + tmp2\n    result = result + tmp3\n  end\n  return result\nend", "  local total\
    \ = 0\n  for i = 1,n do total = total + i end\n  return total\nend", "  -- We\
    \ start with n = 1. We'll add 1 to n each time until we get to n.\n  -- So, we\
    \ start at 1 and work our way up to n. We'll add n+1 to n\n  -- and so on until\
    \ we get to n.\n  -- So, for example, if we start at n = 5, we add 5+5+5+5+5+5+5+5+5+5\
    \ = 45.\n  -- So, we can now just add 45 to get our final result. \n  -- Finally,\
    \ we return the result.\n  return n + sum_to_n(n+1)\nend", "  n = tonumber(n)\n\
    \  if n == nil then\n    error('n is nil')\n  end\n  if n < 0 then\n    error('sum_to_n\
    \ expects n to be positive')\n  end\n  return math.floor(n * (n / 2)) + math.floor(n\
    \ * (n - 1) / 2)\nend", "  local result = 0\n  for i = 1, n do\n    result = result\
    \ + i\n  end\n  return result\nend", "  if n <= 0 then return 0 end\n  local sum\
    \ = 0\n  for i = 1, n do sum = sum + i end\n  return sum\nend", "  if n <= 0 then\n\
    \    return 0\n  else\n    local k = 1\n    local sum = 0\n    while k <= n do\n\
    \      sum = sum + k\n      k = k + 1\n    end\n    return sum\n  end\nend", " \
    \ if n < 0 then\n    return nil\n  elseif n < 1 then\n    return 1\n  else\n \
    \   return n + sum_to_n(n - 1)\n  end\nend", "  return function(n)\n    if n <\
    \ 1 then\n      return nil\n    end", "  local n = 0\n  for i = 1, n do\n    n\
    \ = n + i\n  end\n  return n\nend", "  if n < 0 then\n    return 0\n  end\n  local\
    \ nsum = 0\n  for i = 1, n do\n    nsum = nsum + i\n  end\n  return nsum\nend",
  "    if n < 1 then\n        error('n must be positive!')\n    end\n    local s =\
    \ 0\n    while n ~= 1 do\n        s = s + n\n        n = math.floor(n/10)\n  \
    \  end\n    return s\nend", "  if n < 1 then\n    return n\n  else\n    return\
    \ sum_to_n(n-1) + n\n  end\nend", "  if n == 1 then return 1 end\n  if n == 0\
    \ then return 0 end\n  if n < 0 then return nil end\n  return n + sum_to_n(n -\
    \ 1)\nend", "  -- Initialize answer to zero\n  local sum = 0\n  -- While n is\
    \ positive...\n  while n ~= 0 do\n    -- Add 1 to n\n    sum = sum + 1\n    --\
    \ n decreases by 1\n    n = n - 1\n  end\n  return sum\nend", "  -- We use an\
    \ accumulator of 0 to start with.\n  -- In our case, we'll be adding 1 to this\
    \ number to form our total.\n  local accum = 0\n  for i = 0, n do\n    -- The\
    \ accum is what will be added to sum_to_n's total to form our total.\n    accum\
    \ = accum + 1\n    -- We increment i here because each time we do a for loop,\
    \ we are going to\n    -- skip over numbers and only add 1 to the total.\n   \
    \ i = i + 1\n    -- We return the accumulated total.\n    return accum\n  end\n\
    end", "  local s = 0\n  for i=1,n do\n    s = s + i\n  end\n  return s\nend",
  "  if n == 0 then\n    return 1\n  end\n  return n * sum_to_n(n - 1)\nend", "  if\
    \ n then\n    local s = 1\n    for i = 1, n do\n      s = s + i\n    end\n   \
    \ return s\n  else\n    return 0\n  end\nend", "  local r = 0\n  for i = 1, n\
    \ do\n    r = r + i\n  end\n  return r\nend", "  local s = 0\n  for i = 1, n do\n\
    \    s = s + i\n  end\n  return s\nend", "  if n >= 1 then\n    return n + sum_to_n(n\
    \ - 1)\n  else\n    return 1\n  end\nend", "  if n == 1 then return 1 end\n  return\
    \ n * sum_to_n(n - 1)\nend", "  n = tonumber(n)\n  if n == 0 then return 1 end\n\
    \  return n*(n+1)/2\nend\n</cell>\n<text>\nLet's see if this works:", "  if n\
    \ <= 0 then return nil end\n  local sum = 1\n  for i = 1, n do sum = sum + i end\n\
    \  return sum\nend\n</cell>\n<text>\nExercise\nCreate your own function sum_to_n\
    \ which sums the numbers from 1 to n.", "  local sum = 0\n  for i = 1, n do\n\
    \    sum = sum + i\n  end\n  return sum\nend", "  -- If n is negative, return\
    \ -1\n  if n < 0 then\n    return -1\n  -- Else, return n\n  else\n    return\
    \ n\n  end\nend", "  if n == 0 then\n    return 1\n  else\n    return n * sum_to_n(n\
    \ - 1)\n  end\nend", "  return math.min(n, math.floor(n/2) + 1)\nend\n</cell>\n\
    <text>\nExercise 4:\nImplement the binomial_coefficient(a,b) function, which returns\
    \ the coefficient of a binomial coefficient (the number of ways you can choose\
    \ k out of n items) when you can only use k items from a list of size n (a list).\
    \ You should use sum_to_n to simplify your implementations.", "  if n == 0 then\n\
    \    local result = 1\n  else\n    local result = 1 + sum_to_n(n - 1)\n  end\n\
    \  return result\nend", "  return n and n + (sum_to_n(n-1)) or 1\nend", "  if\
    \ n > 1 then\n    return sum_to_n(n - 1) + n\n  end\n  return 1\nend", "  local\
    \ result = 0\n  for i = 1, n do\n    result = result + i\n  end\n  return result\n\
    end", "  local total = 0\n  local i = 1\n  while i <= n do\n    total = total\
    \ + i\n    i = i + 2\n  end\n  return total\nend", "  if n < 1 then return 1 end\n\
    \  if n == 1 then return 1 end\n  if n == 2 then return 2 end\n  if n == 3 then\
    \ return 3 end\n  return n * sum_to_n(n - 1)\nend", "  if n < 1 then\n    return\
    \ n\n  else\n    return sum_to_n(n - 1) + n\n  end\nend", "  return coroutine.wrap(function()\n\
    \    local total = 0\n    for i = 1, n do total = total + i end\n    return total\n\
    \  end)()\nend", "  if n < 0 then\n    error(\"n must be positive number\")\n\
    \  elseif n >= 1 then\n    return n\n  elseif n == 2 then\n    return 1\n  else\n\
    \    return sum_to_n(n - 1) + n\n  end\nend", "  -- If n is nil or 0, return 0.\n\
    \  if not n or n == 0 then\n    return 0\n  end", "  local total = 0\n  for i\
    \ = 1,n do\n    total = total + i\n  end\n  return total\nend", "    if n < 1\
    \ then return 1 end\n    return n * sum_to_n(n - 1)\nend", "  if n == 1 then\n\
    \    return 1\n  else\n    return n + sum_to_n(n - 1)\n  end\nend", "  return\
    \ math.floor((math.exp(math.log(n) - math.log(0.5))\n    + math.sqrt(n)\n    +\
    \ math.log(0.5))\n    * math.pi * 2.0)\nend\nreturn sum_to_n\nend", "   if n ==\
    \ 0 then\n      return 1\n   elseif n > 0 then\n      return n + sum_to_n(n -\
    \ 1)\n   end\nend", "  local s = 0\n  for i = 1, n do\n    s = s + i\n  end\n\
    \  return s\nend", "  if n <= 0 then\n    return 0\n  end\n  return n + sum_to_n(n\
    \ - 1)\nend", "  if n > 0 then\n    return sum_to_n(n - 1) + 1\n  else\n    return\
    \ 0\n  end\nend", "    if n == 0 then\n        return 1\n    elseif n < 0 then\n\
    \        error(\"Sum to negative number: \" .. n)\n    end", "  if n < 1 then\n\
    \    error(\"Can't sum_to_n to \" .. tostring(n))\n  end\n  if n == 1 then\n \
    \   return 1\n  end\n  local f = n - 1\n  local s = 0\n  while n > 1 do\n    s\
    \ = s + f\n    f = f - 1\n  end\n  return s\nend\nreturn sum_to_n", "  if n ==\
    \ 0 then\n    return 1\n  else\n    local n = 1\n    while n <= n do\n      n\
    \ = n + n\n    end\n    return n\n  end\nend", "  -- Return the sum of all numbers\
    \ from 1 to n. Raise an exception\n  -- if n is less than 1.\n  if n < 1 then\n\
    \    error(\"The argument must be positive.\")\n  elseif n == 1 then\n    error(\"\
    The argument must not be 1.\")\n  else\n    local s = 1\n    for i = 1, n do\n\
    \      s = s + i\n    end\n    return s\n  end\nend", "  if n <= 0 then\n    return\
    \ 1\n  end\n  local sum = 1\n  for i = 1, n do\n    sum *= i\n  end\n  return\
    \ sum\nend", "  if n == 1 then return 1\n  else return n + sum_to_n(n - 1)\n \
    \ end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
