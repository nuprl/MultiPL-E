name: HumanEval_99_closest_integer
language: lua
results:
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- If\
    \ it's a number, then just round it\n    if type(value) == \"number\" then\n \
    \       return math.round(value)\n    end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfnxjv0gw.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Return\
    \ closest integer, for rounding away from zero.\n  return math.floor((math.floor(value\
    \ / 1) + 1)) * math.sign(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6scfwayz.lua:16:\
    \ attempt to call a nil value (field 'sign')\nstack traceback:\n\t/tmp/tmp6scfwayz.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp6scfwayz.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  value =\
    \ tonumber(value)\n  if not value or value == 0 then\n    return nil\n  end\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpr8sbym7a.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(math.abs(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcocvip1n.lua:23:\
    \ expected: -16, actual: 16\nstack traceback:\n\t/tmp/tmpcocvip1n.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ is_equidistant(a, b)\n    return math.abs(a - b) <= 1\n  end\n  if value:match('^-?%d+')\
    \ then\n    local value = tonumber(value)\n    local difference, closest\n   \
    \ -- Round away from zero\n    if value >= 0 then\n      difference, closest =\
    \ value - 0.5, value + 0.5\n    else\n      difference, closest = value - 0.5,\
    \ value - 0.5\n    end\n    -- Handle edge case\n    if difference == 0 then\n\
    \      difference, closest = 1, 0\n    end\n    -- Check if value is equidistant\
    \ to two integers\n    if difference == 0 then\n      if closest == 0 then\n \
    \       difference, closest = 1, 0\n      elseif closest == 1 then\n        difference,\
    \ closest = -1, 0\n      else\n        difference, closest = 0, 1\n      end\n\
    \    end\n    -- Check if value is equidistant to an integer\n    if difference\
    \ == 0 then\n      if closest == 0 then\n        difference, closest = 1, 0\n\
    \      elseif closest == 1 then\n        difference, closest = -1, 0\n      end\n\
    \    end\n    -- Check if value is equidistant to a floating point number\n  \
    \  if difference == 0 then\n      if closest == 0 then\n        difference, closest\
    \ = 1, 0\n      end\n    end\n    -- Round the closest value to nearest integer\n\
    \    closest = int(closest)\n    return closest\n  else\n    local sign = value:match('^-?%d+(-?%d)?')\n\
    \    if sign == '' then\n      local sign = value:match('^%d+(-?%d)?')\n    end\n\
    \    local difference, closest, round\n    local value = tonumber(value)\n   \
    \ local difference, closest = value - 0.5, value + 0.5\n    -- Handle edge case\n\
    \    if difference == 0 then\n      difference, closest = 1, 0\n    end\n    --\
    \ Check if value is equidistant to two integers\n    if difference == 0 then\n\
    \      if closest == 0 then\n        difference, closest = 1, 0\n      elseif\
    \ closest == 1 then\n        difference, closest = -1, 0\n      end\n    end\n\
    \    -- Check if value is equidistant to an integer\n    if difference == 0 then\n\
    \      if closest == 0 then\n        difference, closest = 1, 0\n      end\n \
    \   end\n    -- Check if value is equidistant to a floating point number\n   \
    \ if difference == 0 then\n      if closest == 0 then\n        difference, closest\
    \ = 1, 0\n      end\n    end\n    -- Round the closest value to nearest integer\n\
    \    closest = int(closest)\n    if sign ~= '-' then\n      closest = math.abs(\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpruaec9iy.lua:94: ')' expected (to close '(' at line 93) near\
    \ '='\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number then\n    number = math.round(number)\n  else\n\
    \    number = nil\n  end\n  if number ~= nil then\n    local left, right = math.floor(number),\
    \ math.ceil(number)\n    if left == left and right == right then\n      return\
    \ number\n    elseif left > 0 and right < 0 then\n      return right\n    elseif\
    \ left < 0 and right > 0 then\n      return left\n    else\n      return nil\n\
    \    end\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2hg37y78.lua:17:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmp2hg37y78.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp2hg37y78.lua:38: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local closest\n\
    \  for _, val in ipairs(values) do\n    if val == value then\n      break\n  \
    \  end\n    closest = val\n  end\n  if closest == nil then\n    return nil\n \
    \ end\n  if closest < value then\n    return closest\n  end\n  return closest+1\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\nattempt to\
    \ index a nil value\nstack traceback:\n\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   assert(type(value)\
    \ == 'string')\n   local numbers = string.gmatch(value, \"(%d*)%.?(%d*)\")\n \
    \  assert(#numbers == 2)\n   local digits = tonumber(numbers[1])\n   local fract\
    \ = tonumber(numbers[2])\n   -- Round digits to the closest integer.\n   -- If\
    \ fract is 0, we return the nearest integer to the whole number.\n   -- Otherwise,\
    \ return fract - digits + 1.\n   if fract == 0 then\n      return tonumber(numbers[1]):round()\n\
    \   end\n   return tonumber(numbers[1]):round(digits)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5i8egauk.lua:17:\
    \ attempt to get length of a function value (local 'numbers')\nstack traceback:\n\
    \t/tmp/tmp5i8egauk.lua:17: in local 'candidate'\n\t/tmp/tmp5i8egauk.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   local _,\
    \ closest = nil, nil -- The number closest to value, the closest\n   for _, v\
    \ in ipairs(value) do\n      if closest == nil then\n         closest, closest\
    \ = v, v\n      else\n         local d = abs(v - closest)\n         if d < closest\
    \ then\n            closest, closest = v, d\n         end\n      end\n   end\n\
    \   return closest\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbcptroqb.lua:32:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpbcptroqb.lua:32: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == \"-\" then return -math.floor(math.abs(value)) end\n  local num = tonumber(value)\n\
    \  if num == nil then\n    if value == \"inf\" then return math.inf end\n    if\
    \ value == \"nan\" then return math.nan end\n    error(\"Given value is not numeric:\
    \ \" .. value)\n  end\n  local lower, upper = 0, math.floor(num)\n  if math.abs(num\
    \ - lower) < math.abs(num - upper) then\n    return lower\n  end\n  return upper\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpawue9u57.lua:33:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpawue9u57.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if value\
    \ == nil then\n        return nil\n    end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphhzazy_3.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- We assume\
    \ that all positive numbers are equidistant from zero\n  if tonumber(value) >=\
    \ 0 then\n    -- The difference between the value and 0 is also the difference\n\
    \    -- of that value from one thousand, therefore dividing by 1000\n    local\
    \ difference = tonumber(value) - 1000\n    -- If the number is above the difference\
    \ of two thousands, round down\n    -- to the closest integer\n    if difference\
    \ > 0 then\n      return tonumber(math.ceil(difference))\n    else\n      return\
    \ tonumber(math.floor(difference))\n    end\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7y5jr1fl.lua:33:\
    \ expected: 10, actual: -990\nstack traceback:\n\t/tmp/tmp7y5jr1fl.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    return \"nil\"\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpzbuhbvjv.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- The first\
    \ if statement is for the case where value is nil.\n  if value == nil then\n \
    \   -- The second if statement is for the case where value is a string.\n    if\
    \ type(value)~='string' then\n      -- Return a nil value.\n      return nil\n\
    \    end\n    -- If the given value is an empty string, return nil.\n    if value\
    \ == '' then\n      return nil\n    end\n    -- If the given value is a number,\
    \ return it.\n    return tonumber(value)\n  end\n  -- The second if statement\
    \ is for the case where value is a number.\n  if type(value)~='number' then\n\
    \    -- Return a nil value.\n    return nil\n  end\n  -- If the given value is\
    \ greater than the largest representable integer,\n  -- return nil.\n  if tonumber(value)>1e11\
    \ then\n    return nil\n  end\n  -- If the given value is less than the smallest\
    \ representable integer,\n  -- return nil.\n  if tonumber(value)<-1e11 then\n\
    \    return nil\n  end\n  -- If the given value is equidistant from two integers,\
    \ round it away\n  -- from zero.\n  if tonumber(value)==1e11 then\n    return\
    \ tonumber(math.floor(value))\n  elseif tonumber(value)==-1e11 then\n    return\
    \ tonumber(math.ceil(value))\n  else\n    return tonumber(math.round(value))\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy0pwkw0n.lua:58:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpy0pwkw0n.lua:58: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor((value\
    \ + math.pi/2) / math.pi)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpipjkxes9.lua:21:\
    \ expected: 10, actual: 3\nstack traceback:\n\t/tmp/tmpipjkxes9.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ round(value)\n    if value == nil then return nil end\n    local sign = value\
    \ < 0 and -1 or 1\n    local factor = math.pow(10, math.floor(math.log10(value)))\n\
    \    return value * factor + sign * (factor / 2)\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4inhestm.lua:32: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = math.abs(value - math.floor(number))\n    return math.floor(number)\
    \ + difference + 1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphbe50g2d.lua:15:\
    \ bad argument #1 to 'floor' (number expected, got nil)\nstack traceback:\n\t\
    /tmp/tmphbe50g2d.lua:15: in local 'candidate'\n\t/tmp/tmphbe50g2d.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then return nil end\n  local num = tonumber(value)\n  if num == nil then\
    \ return nil end\n  local n1 = math.floor(num)\n  local n2 = num - n1\n  local\
    \ diff = n1\n  if n2 ~= 0 then\n    diff = -diff\n  end\n  if diff < 0 then\n\
    \    return n1\n  else\n    return n2\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu3yn4nb7.lua:34:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpu3yn4nb7.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ string_value = str(value) -- Ensure that value is a string\n    local result\
    \ = tonumber(string_value) -- Use tonumber to convert it to a number\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpc72bfqea.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- If no\
    \ number is given, return nil.\n  if value == nil then return end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsyvooloq.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ closest(a, b)\n    if a == nil then\n      return b\n    elseif b == nil then\n\
    \      return a\n    end\n    local abs = math.abs(a - b)\n    if abs < 0.5 then\n\
    \      return a\n    else\n      return b\n    end\n  end\n  local function round_away_from_zero(n)\n\
    \    local m = math.abs(n)\n    if m % 1 == 0 then\n      return m\n    end\n\
    \    return m - 0.5\n  end\n  local result = value\n  local pos = #value\n  while\
    \ pos do\n    local substr = value[pos:find(\"-\")]\n    if substr == \"\" then\n\
    \      break\n    end\n    local digit = tonumber(substr)\n    if digit == nil\
    \ then\n      return nil\n    end\n    local round_to = round_away_from_zero(digit)\n\
    \    result = closest(result,round_to)\n    pos = pos-1\n  end\n  return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpptrbsc_u.lua:38:\
    \ attempt to index a number value (local 'pos')\nstack traceback:\n\t/tmp/tmpptrbsc_u.lua:38:\
    \ in local 'candidate'\n\t/tmp/tmpptrbsc_u.lua:56: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal difference\
    \ = math.abs(value - closest_integer(value))\n\treturn math.floor(difference +\
    \ 0.5) -- Round to nearest integer.\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfgqkd_1_.lua:15:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmpfgqkd_1_.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmpfgqkd_1_.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmpfgqkd_1_.lua:15:\
    \ in upvalue 'closest_integer'\n\t/tmp/tmpfgqkd_1_.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmpfgqkd_1_.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmpfgqkd_1_.lua:15:\
    \ in upvalue 'closest_integer'\n\t/tmp/tmpfgqkd_1_.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmpfgqkd_1_.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmpfgqkd_1_.lua:15:\
    \ in upvalue 'closest_integer'\n\t...\n\t/tmp/tmpfgqkd_1_.lua:15: in local 'candidate'\n\
    \t/tmp/tmpfgqkd_1_.lua:22: in function 'test_humaneval'\n\nRan 1 tests in 0.140\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local int_value\
    \ = tonumber(value)\n  local int_max = math.max(int_value)\n  if int_max > 0 then\n\
    \    local diff = (int_value - int_max)\n    -- if diff is even return 0\n   \
    \ if diff % 2 == 0 then\n      return int_max\n    end\n    -- if diff is odd,\
    \ return the smallest int value that is larger than 0\n    -- or diff/2\n    local\
    \ diff2 = diff / 2\n    -- if diff2 even, return diff / 2\n    if diff2 % 2 ==\
    \ 0 then\n      return (int_max + diff2)/2\n    end\n    -- if diff2 odd, return\
    \ the smallest int value that is larger than 0\n    -- or diff2/2\n    local diff22\
    \ = diff2 / 2\n    return ((int_max + diff22) + diff22)/2\n  end\n  return int_max\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpicnqef97.lua:42:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpicnqef97.lua:42: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal x0\
    \ = tonumber(value)\n\tif x0 == value then return x0 end\n\tlocal x1, x2, x3,\
    \ x4 = tonumber(string.sub(value, 1, -1))\n\tif x1 == x2 or x1 == x3 then x0 =\
    \ x1 end\n\tif x4 == x2 or x4 == x3 then x0 = x4 end\n\treturn x0\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprisq6ka5.lua:26:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmprisq6ka5.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = tonumber(value) - tonumber(tonumber(value))\n    if difference\
    \ < 0 then\n        return tonumber(tonumber(value) - difference + 1)\n    else\n\
    \        return tonumber(value)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7k11wdj8.lua:27:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp7k11wdj8.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local closest\
    \ = 1\n  local rounding_threshold = math.floor((math.floor(value) + math.floor(value))\
    \ * 0.5)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdju_hsfp.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value:match(\"\
    ^%d%d+$\") then\n    return tonumber(value)\n  end\n  if value:match(\"^%d-%d+$\"\
    ) then\n    value = value:gsub(\"-\", \"+\"):gsub(\"^%d+\", \"0\"):gsub(\"%d+$\"\
    , \"\")\n    return tonumber(value)\n  end\n  if value:match(\"^%d+$\") then\n\
    \    return tonumber(value)\n  end\n  if value:match(\"^%d-$\") then\n    value\
    \ = value:gsub(\"-\", \"+\"):gsub(\"^%d+\", \"0\"):gsub(\"%d-$\", \"\")\n    return\
    \ tonumber(value)\n  end\n  return value\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8rmb6m2i.lua:36:\
    \ expected: 15, actual: \"14.5\"\nstack traceback:\n\t/tmp/tmp8rmb6m2i.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = value - math.floor(value)\n    if difference < 0 then return value\
    \ else return math.floor(value) end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmhvlpvr5.lua:23:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpmhvlpvr5.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function f(x)\n        if x <= value then return x end\n        if value < x\
    \ then return x end\n        if x > value then return value end\n        return\
    \ x\n    end\n    local function fd(x)\n        if x <= value then return x end\n\
    \        if value < x then return value end\n        if x > value then return\
    \ x end\n        return x\n    end\n    return (fd(f(value))) / 2\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxvo__cri.lua:33:\
    \ expected: 10, actual: 5\nstack traceback:\n\t/tmp/tmpxvo__cri.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == \"-\" then return -0 end\n  local num, err = tonumber(value)\n  if num ==\
    \ nil then\n    local _, err2 = tonumber(string.format(\"%.9f\", value))\n   \
    \ if err2 == nil then return nil, \"Could not convert \" .. value .. \" to an\
    \ integer.\" end\n    return nil, err2\n  end\n  if value == \"\" then return\
    \ nil, \"Value must not be empty.\" end\n  if num == 0 then return nil, \"Cannot\
    \ return an integer.\" end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9lqhfdkb.lua:35: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ closestInteger\n    for _, v in ipairs(value) do\n        if v ~= \"\" then\n\
    \            closestInteger = tonumber(v)\n            break\n        end\n  \
    \  end\n    -- The first value was not a number, but we assume it was a string\n\
    \    -- so we can return this value instead.\n    if closestInteger == nil then\n\
    \        closestInteger = tonumber(value)\n    end\n    -- If value is equidistant,\
    \ return the first integer\n    if closestInteger == value then\n        closestInteger\
    \ = tonumber(value)\n    end\n    return closestInteger\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt59h7ksg.lua:38:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpt59h7ksg.lua:38: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- If the\
    \ given number is equidistant from two integers, return the one\n  -- that is\
    \ farthest from zero.\n  if math.abs(value - math.floor(value)) > math.abs(value\
    \ - math.ceil(value)) then\n    return math.floor(value)\n  end\n  -- If the given\
    \ number is equidistant from two integers, return the one\n  -- that is closest\
    \ to zero.\n  if math.abs(value - math.floor(value)) < math.abs(value - math.ceil(value))\
    \ then\n    return math.ceil(value)\n  end\n  -- If the given number is equidistant\
    \ from two integers, return the one\n  -- that is closest to zero.\n  return math.floor(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvkqrjkoa.lua:34:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpvkqrjkoa.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ round_away_from_zero(n)\n    return math.floor(n - math.floor(n))\n  end\n \
    \ local result = tonumber(value)\n  if result ~= nil then\n    if result == 0\
    \ then\n      -- Special case for zero\n      return 0\n    elseif result < 0\
    \ then\n      -- Special case for negative numbers\n      return round_away_from_zero(-result)\n\
    \    else\n      -- Special case for positive numbers\n      return round_away_from_zero(result)\n\
    \    end\n  end\n  local closest_result = nil\n  local smallest_diff = nil\n \
    \ for i = 1, #_integers do\n    local diff = abs(result - _integers[i])\n    if\
    \ smallest_diff == nil then\n      closest_result = _integers[i]\n      smallest_diff\
    \ = diff\n    elseif smallest_diff > diff then\n      smallest_diff = diff\n \
    \     closest_result = _integers[i]\n    end\n  end\n  if smallest_diff ~= nil\
    \ then\n    return round_away_from_zero(smallest_diff)\n  end\n  -- No integer\
    \ was equidistant from any integer\n  return nil\nend\n_integers = {}\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb491w9g7.lua:54:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpb491w9g7.lua:54: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ result = value\n    for i=0,2 do\n        result = math.floor(result / 10) *\
    \ 10\n        if result == 0 then\n            break\n        end\n    end\n \
    \   if result == 0 then\n        return 0\n    end\n    return result\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn8qhuwgv.lua:32:\
    \ expected: 15, actual: 10\nstack traceback:\n\t/tmp/tmpn8qhuwgv.lua:32: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local difference\
    \ = value\n  local difference1 = difference\n  if difference >= 0 then\n    --\
    \ If difference is positive or 0, add it to the difference of its two\n    --\
    \ neighbors\n    difference1 = difference + 1\n  end\n  difference1 = math.floor(difference1)\n\
    \  -- Calculate the difference between neighboring integers\n  difference = math.abs(value\
    \ - difference1)\n  if difference > 1 then\n    -- If difference is more than\
    \ 1, return the closest integer\n    -- that does not equal value\n    return\
    \ difference1\n  end\n  return difference\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpov6jedov.lua:17:\
    \ attempt to compare number with string\nstack traceback:\n\t/tmp/tmpov6jedov.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmpov6jedov.lua:36: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    -- Special case for the value being nil.\n    return nil\n\
    \  elseif value == true then\n    -- Special case for truthy values.\n    return\
    \ 1\n  elseif value == false then\n    -- Special case for falsy values.\n   \
    \ return 0\n  else\n    -- Return the closest integer.\n    return math.floor(math.abs(value))\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3vjed7ib.lua:34:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp3vjed7ib.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local n\
    \ = tonumber(value)\n  if n then\n    local sign = math.sign(n)\n    local int_num\
    \ = abs(n)\n    local int_diff1 = int_num - 1\n    local int_diff2 = int_num +\
    \ 1\n    local rounding = 0\n    local rounding_diff1 = 0\n    local rounding_diff2\
    \ = 0\n    if int_num > 0 then\n      if int_diff1 < n and n ~= 0 then\n     \
    \   rounding = int_diff1\n        rounding_diff1 = sign * int_diff1\n      end\n\
    \      if int_diff2 < n and n ~= 0 then\n        rounding = int_diff2\n      \
    \  rounding_diff2 = sign * int_diff2\n      end\n    end\n    -- The above logic\
    \ could also be written as follows:\n    --\n    -- rounding = sign * (abs(int_diff1)\
    \ - abs(int_diff2))\n    --\n    -- However, that may introduce rounding errors,\
    \ since abs(int_diff1) can\n    -- have more digits than abs(int_diff2).\n   \
    \ local rounding_diff\n    if int_diff1 < int_diff2 and int_diff1 >= 0 then\n\
    \      rounding_diff = sign * (int_diff1 - int_diff2)\n    elseif int_diff2 <\
    \ int_diff1 and int_diff2 >= 0 then\n      rounding_diff = sign * (int_diff2 -\
    \ int_diff1)\n    end\n    if rounding ~= 0 then\n      return sign * round(rounding\
    \ / rounding_diff)\n    end\n  else\n    return 0\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4wt3ecy1.lua:17:\
    \ attempt to call a nil value (field 'sign')\nstack traceback:\n\t/tmp/tmp4wt3ecy1.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp4wt3ecy1.lua:57: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local sign,\
    \ value = string.reverse(type(value)), tonumber(value)\n  if sign ~= \"d\" then\n\
    \    error(\"argument must be a string\")\n  elseif value < 0 then\n    error(\"\
    argument cannot be negative\")\n  elseif sign == \"d\" then\n    -- Decimal number\n\
    \    local div = math.floor(value)\n    local mult = math.abs(value) - div\n \
    \   if mult < .5 then\n      return div - 1\n    else\n      return div + 1\n\
    \    end\n  else\n    -- Floating point\n    local div = math.floor(value / 2)\n\
    \    local mult = math.abs(value - div)\n    if mult < .5 then\n      return div\
    \ + 1\n    else\n      return div - 1\n    end\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphyfmvp__.lua:17:\
    \ argument must be a string\nstack traceback:\n\t/tmp/tmphyfmvp__.lua:17: in local\
    \ 'candidate'\n\t/tmp/tmphyfmvp__.lua:44: in function 'test_humaneval'\n\nRan\
    \ 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then return nil end\n  local tok = tonumber(value)\n  if tok ~= nil and\
    \ tok ~= tostring(value) then\n    return tok\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmplladfybw.lua:31: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ is_close_to_zero(v)\n    return v - math.floor(v) < 0.01\n  end\n  local function\
    \ is_equidistant(v1, v2)\n    return math.abs(v1 - v2) < 0.01\n  end\n  if type(value)\
    \ ~= \"string\" then\n    error(\"[closest_integer] expects a string but got a\
    \ \" .. type(value))\n  end\n  local match = string.find(value, \"[^.-]\")\n \
    \ if match == nil then\n    error(\"[closest_integer] expects a number but got\
    \ a \" .. value)\n  end\n  local integer = tonumber(string.sub(value, 1, match))\n\
    \  if type(integer) ~= \"number\" or integer < 0 then\n    error(\"[closest_integer]\
    \ expects a number but got a \" .. value)\n  end\n  if math.floor(integer) ==\
    \ integer then\n    error(\"[closest_integer] expects a number but got a \" ..\
    \ value)\n  end\n  local diff\n  if integer == math.floor(integer) then\n    diff\
    \ = math.abs(integer - math.floor(integer))\n  else\n    diff = math.abs(integer\
    \ - math.floor(integer))\n  end\n  if diff == 0 then\n    local last_decimal_value\
    \ = math.floor(integer)\n    local last_integer = math.floor(last_decimal_value)\n\
    \    local next_last_decimal_value = math.floor(last_decimal_value + 0.1)\n  \
    \  local next_integer = math.floor(next_last_decimal_value)\n    if next_integer\
    \ ~= last_integer then\n      diff = math.abs(last_integer - next_integer)\n \
    \   end\n  end\n  if diff < 0.1 then\n    integer = math.floor(integer)\n  else\n\
    \    integer = math.ceil(integer)\n  end\n  return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1hrjlhrl.lua:33:\
    \ [closest_integer] expects a number but got a 10\nstack traceback:\n\t/tmp/tmp1hrjlhrl.lua:33:\
    \ in local 'candidate'\n\t/tmp/tmp1hrjlhrl.lua:61: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    error(\"You cannot use nil as a number.\")\n  end\n  local\
    \ result\n  -- If we have a positive value, then subtract that value and see if\
    \ the\n  -- remainder is positive or zero.\n  if type(value) ~= 'string' or string.find(value,\
    \ \"^%-?%d+%.?%d+$\") then\n    if value ~= nil and type(value) ~= 'number' then\n\
    \      error(\"Value must be of type string or number. Got \" .. type(value))\n\
    \    end\n    result = value\n  else\n    -- Otherwise, check if the value is\
    \ between one and minus one\n    local num = tonumber(value)\n    if num ~= nil\
    \ and num > 0 then\n      if num ~= -1 and num ~= 1 and num ~= -num then\n   \
    \     result = num\n      else\n        -- Get the remainder after the number\
    \ has been rounded down\n        local remainder = math.modf(num)[1]\n       \
    \ if remainder == 0 then\n          result = num\n        else\n          -- Get\
    \ the number before the first decimal place after rounding\n          local firstDbl\
    \ = math.floor(num / 10)\n          -- Subtract the remainder\n          result\
    \ = firstDbl - remainder\n        end\n      end\n    else\n      result = nil\n\
    \    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp29rtzitd.lua:23:\
    \ Value must be of type string or number. Got string\nstack traceback:\n\t/tmp/tmp29rtzitd.lua:23:\
    \ in local 'candidate'\n\t/tmp/tmp29rtzitd.lua:54: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Use tointeger\
    \ because tonumber will give error if value is\n  -- nil or not a string.\n  return\
    \ math.round(tointeger(value))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmput6z3g1_.lua:17:\
    \ attempt to call a nil value (global 'tointeger')\nstack traceback:\n\t/tmp/tmput6z3g1_.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmput6z3g1_.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ is_equidistant(value1, value2)\n    if value1 > value2 then\n      return true\n\
    \    elseif value2 > value1 then\n      return false\n    elseif value1 == value2\
    \ then\n      return true\n    else\n      return math.floor((value1 + value2)\
    \ / 2) ~= value1\n    end\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvank70hq.lua:37: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ abs(x)\n    if x ~= nil then\n      return math.abs(x)\n    else\n      return\
    \ nil\n    end\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsp9i5lrl.lua:33: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ is_equidistant(v1, v2)\n    return math.abs(v1 - v2) <= 1\n  end\n  local function\
    \ round_away_from_zero(number)\n    if math.abs(number) <= 1 then\n      return\
    \ number\n    else\n      return math.floor(number)\n    end\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpaczup_sx.lua:36: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ find_closest_integer(value)\n    if value == nil then\n      print(\"error:\
    \ value cannot be nil\")\n      return\n    end\n    if value == \"-inf\" or value\
    \ == \"inf\" then\n      return 0\n    end\n    -- This algorithm doesn't work\
    \ well for numbers close to zero.\n    if value == 0 then\n      return 0\n  \
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpuozhi7jj.lua:38: 'end' expected (to close 'function' at line\
    \ 15) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local diff = num - math.floor(num)\n  if diff < 0 then\n\
    \    return math.floor(num)\n  else\n    return math.ceil(num)\n  end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbo1hzz3g.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbo1hzz3g.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local sign\
    \ = math.sign\n  local absvalue = math.abs(value)\n  if absvalue < 1 then\n  \
    \  return value\n  else\n    local divisor\n    if absvalue <= 10 then\n     \
    \ divisor = 10\n    else\n      divisor = 20\n    end\n    local factor\n    repeat\n\
    \      factor = divisor / 2\n      if sign(value) ~= sign(value*factor) then\n\
    \        return factor\n      else\n        divisor = factor\n      end\n    until\
    \ divisor == 0\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpf0qsje53.lua:29:\
    \ attempt to call a nil value (local 'sign')\nstack traceback:\n\t/tmp/tmpf0qsje53.lua:29:\
    \ in local 'candidate'\n\t/tmp/tmpf0qsje53.lua:41: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local x\
    \ = 0\n  local y = 0\n  local distance = 0\n  for i = 1, #value do\n    local\
    \ digit = string.byte(string, value:sub(i, i))\n    local sign = 1\n    if digit\
    \ == \"-\" then\n      digit = digit[1]\n      sign = -1\n    end\n    local digit\
    \ = tonumber(digit)\n    if digit then\n      x = x - digit*sign\n      y = y\
    \ + digit*sign\n      distance = distance + 1\n    end\n  end\n  if y == 0 then\n\
    \    x = math.max(x, math.floor(x))\n  else\n    x = math.min(x, math.ceil(x))\n\
    \  end\n  return x * sign\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8qhz_4xn.lua:19:\
    \ bad argument #1 to 'byte' (string expected, got table)\nstack traceback:\n\t\
    /tmp/tmp8qhz_4xn.lua:19: in local 'candidate'\n\t/tmp/tmp8qhz_4xn.lua:43: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local difference\
    \ = abs(value - floor(value))\n  local rounded_difference = math.floor(difference)\n\
    \  if rounded_difference == difference then\n    return value\n  end\n  return\
    \ round(value - rounded_difference)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5bqeq9nh.lua:15:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmp5bqeq9nh.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp5bqeq9nh.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor((math.abs(value)+0.5)+0.5)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp30wctuxv.lua:21:\
    \ expected: 10, actual: 11\nstack traceback:\n\t/tmp/tmp30wctuxv.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor((math.abs(value)\
    \ - math.abs(tonumber(value))) / 2) + tonumber(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5mx6fhci.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp5mx6fhci.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if value\
    \ == nil then\n        return \"nil\"\n    end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpem0om26l.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value)\
    \ + math.abs(value - math.floor(value))\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzz572mw5.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpzz572mw5.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Check\
    \ whether the value is in the table of integer values.\n  if not int_table then\n\
    \    int_table = {}\n    for i = 1, #INT_VALUES do\n      int_table[tostring(i)\
    \ = tostring(i)]:insert(INT_VALUES[i])\n    end\n  end\n  -- Check whether the\
    \ value is in the integer table.\n  if int_table[tostring(value)] then\n    --\
    \ Return the value if it is in the integer table.\n    return int_table[tostring(value)]:nth(1)\n\
    \  end\n  -- Round the value towards the closest integer.\n  return math.round(math.abs(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpa5ld25tf.lua:19: ']' expected near '='\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local difference\
    \ = math.abs(value - floor(value))\n  local closest_integer = math.floor(difference\
    \ + 0.5)\n  if value == closest_integer then\n    return closest_integer\n  elseif\
    \ closest_integer == 0 then\n    return 0\n  end\n  return closest_integer\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdwn4wcii.lua:15:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmpdwn4wcii.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpdwn4wcii.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value_as_number\
    \ = tonumber(value)\n  -- Handle integers, round away from zero\n  if value_as_number\
    \ ~= nil and value_as_number ~= false then\n    value_as_number = math.floor(value_as_number\
    \ + 0.5)\n  end\n  return value_as_number\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1j5h58hx.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1j5h58hx.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ value = tonumber(value)\n    local closest = 1\n    local closest = math.floor(value\
    \ + 0.5)\n    while closest ~= value do\n        closest = math.ceil(value + 0.5)\n\
    \    end\n    return closest\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then return nil end\n  local difference = tonumber(value) - tonumber(value)\n\
    \  if difference < 0 then\n    difference = difference * -1\n  end\n  if difference\
    \ < 0 then return nil end\n  return tonumber(value) + math.floor(difference)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcmiw2ift.lua:28:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpcmiw2ift.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor((math.abs(value\
    \ - math.ceil(value)) + 0.5))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl24f6chc.lua:21:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpl24f6chc.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return tonumber(\n\
    \    string.format(\n      \"%.*g\",\n      math.max(\n        1,\n        math.ceil(\n\
    \          (value - math.floor(value - 0.5, -1)):ld(value)\n          / math.abs(math.floor(value\
    \ - 0.5, -1) - math.floor(value - 0.5, -1))\n        )\n      )\n    )\n  )\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv9uca148.lua:21:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpv9uca148.lua:21:\
    \ in local 'candidate'\n\t/tmp/tmpv9uca148.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if type(value)\
    \ ~= 'string' then\n    local message = string.format('Given value is not a string\
    \ %s.', type(value))\n    error(message)\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp49m71nbu.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if value\
    \ == nil then return nil end\n    local sign = 1\n    if value ~= value then\n\
    \        sign = -1\n    end\n    local num\n    if value == (value % 1) then\n\
    \        num = value\n    else\n        local mult = math.floor(math.abs(value))\n\
    \        local div\n        if mult > 0 then\n            div = math.modf(value*mult)[0]\n\
    \        else\n            div = math.modf(-value*mult)[0]\n        end\n    \
    \    num = value + div + 1\n    end\n    if sign == 1 and num < 0 then\n     \
    \   num = -num\n    end\n    return num\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbu5f0p8r.lua:27:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpbu5f0p8r.lua:27:\
    \ in local 'candidate'\n\t/tmp/tmpbu5f0p8r.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ closest = 0\n    for i = 1, #value do\n        local x = tonumber(value[i])\n\
    \        if not x then\n            break\n        end\n        if x > closest\
    \ then\n            closest = x\n        end\n    end\n    return closest\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1ugjd3x5.lua:31:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmp1ugjd3x5.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ factor = 1\n    while value % factor ~= 0 do\n        factor = factor * 10\n\
    \    end\n    if factor > 99999999999 then\n        factor = factor * 100\n  \
    \  end\n    local diff = 10\n    local closest\n    local factors = factor..\n\
    \        { 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000}\n\
    \    for _, f in ipairs(factors) do\n        if diff > f then\n            closest\
    \ = f / diff\n            diff = f % diff\n        else\n            break\n \
    \       end\n    end\n    return closest + 1\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpm_dhwa7e.lua:24:\
    \ attempt to concatenate a table value\nstack traceback:\n\t/tmp/tmpm_dhwa7e.lua:24:\
    \ in local 'candidate'\n\t/tmp/tmpm_dhwa7e.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = value - math.floor(value)\n    if math.abs(difference) < 0.00000000000001\
    \ then\n        return math.floor(math.ceil(value))\n    else\n        if difference\
    \ >= 0 and difference < 0.5 then\n            return math.floor(value)\n     \
    \   elseif difference < 0 and difference > -0.5 then\n            return math.ceil(math.ceil(value))\n\
    \        else\n            return math.ceil(math.floor(value))\n        end\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbvnm0wvg.lua:33:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpbvnm0wvg.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\t-- If value\
    \ is close enough to zero to consider it an integer,\n\t-- then just return that.\n\
    \tif math.abs(value) < 1 then return value end\n\t-- Get a sequence of integers\
    \ from 1 to value, where the difference\n\t-- of each integer is exactly 1.\n\t\
    local diff = value:range(1, value - 1):map(function(x) return x - 1 end)\n\t--\
    \ Sort them and return the one with the smallest difference.\n\treturn diff[1]:min()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdvk4z05j.lua:20:\
    \ attempt to call a nil value (method 'range')\nstack traceback:\n\t/tmp/tmpdvk4z05j.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmpdvk4z05j.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ closest = tonumber(value)\n    -- We use integer division to find which side\
    \ of the interval we are\n    -- closer to than the other side.\n    for _, interval\
    \ in ipairs(integer_intervals) do\n        local diff = interval[1] -  closest\n\
    \        local min = diff * interval[0]\n        local max = diff * interval[1]\n\
    \        local mid = closest + (diff / 2)\n        if min <= mid <= max then return\
    \ mid end\n    end\n    return closest\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\nattempt to\
    \ index a nil value\nstack traceback:\n\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local closest_int\n\
    \  if value:find('-') then\n    closest_int  = closest_integer:gsub('(%d+)$',\n\
    \        function(x) return tonumber(x:gsub('-%d+$', '%d'):reverse()) end\n  \
    \  )\n    closest_int -- Ignore result so that we can use \"else\" below.\n  else\n\
    \    closest_int = tonumber(value)\n  end\n  if closest_int then\n    if closest_int\
    \ ~= value then\n      return math.floor(closest_int)\n    else\n      return\
    \ closest_int\n    end\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpxtsfnc4b.lua:21: syntax error near 'else'\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- Convert\
    \ to float and round to nearest integer\n    -- This may cause the fractional\
    \ part to be rounded up in some cases,\n    -- but that should be okay because\
    \ \"15.5\" rounds to 15 and \"16.5\"\n    -- rounds to 16. Not sure if this behaviour\
    \ is guaranteed though.\n    local num = tonumber(value)\n    local f = math.floor(num)\n\
    \    local s = num - f\n    if f == s then\n        return f + 1\n    end\n  \
    \  return f\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0v3m6ty4.lua:32:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0v3m6ty4.lua:32: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function distance(a, b)\n        local ab = abs(a - b)\n        if ab <= 0.5\
    \ then return ab end\n        return ab - (ab % 2)\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpcf6xbwfm.lua:31: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function dist(one, two)\n        return math.abs(one - two)\n    end\n    local\
    \ closest = 0\n    for i = 1, #value, 1 do\n        local candidate = tonumber(string.format(\"\
    %g\", tonumber(value)))\n        if candidate < closest then closest = candidate\
    \ end\n    end\n    return closest\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplhof05qn.lua:29:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmplhof05qn.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ result = tonumber(value)\n    if result == nil then\n        result = -value\n\
    \    end\n    local diff1 = abs(result)\n    local diff2 = abs(result - 1)\n \
    \   if diff1 <= diff2 then\n        return result\n    else\n        return result\
    \ + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpj53s5p27.lua:19:\
    \ attempt to call a nil value (global 'abs')\nstack traceback:\n\t/tmp/tmpj53s5p27.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmpj53s5p27.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local is_negative,\
    \ integer, multiplier = value:match(\"^(-)?([1-9][0-9]+)(\\.[0-9]+)?\")\n  local\
    \ sign = is_negative and -1 or 1\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdfdtfv0_.lua:15: invalid escape sequence near '\"^(-)?([1-9][0-9]+)(\\\
    .'\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local integers\
    \ = unpack(\n    stringx.Split(\",\", value)\n  )\n  local closest = integers[1]\n\
    \  for i = 2, #integers do\n    local diff = math.abs(integers[i] - closest)\n\
    \    if diff < math.abs(closest - integers[i]) then\n      closest = integers[i]\n\
    \    end\n  end\n  return closest\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpyj9mabkj.lua:16:\
    \ attempt to index a nil value (global 'stringx')\nstack traceback:\n\t/tmp/tmpyj9mabkj.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpyj9mabkj.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value\
    \ = tonumber(value)\n  if value == nil then\n    return nil\n  end\n  local min_abs\
    \ = abs(value)\n  local min_abs_index = min_abs\n  local min_index = 1\n  local\
    \ closest_index = 1\n  for i = 2, #values do\n    local abs_i = abs(values[i])\n\
    \    if abs_i > min_abs and abs_i < min_abs_index then\n      min_abs_index =\
    \ abs_i\n      min_index = i\n      closest_index = i\n    end\n  end\n  local\
    \ abs_closest\n  if value == min_abs_index then\n    abs_closest = \"0\"\n  else\n\
    \    abs_closest = \"-\" .. tostring(min_index - closest_index)\n  end\n  -- Return\
    \ the closest integer\n  return tonumber(abs_closest)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_wb6my8b.lua:19:\
    \ attempt to call a nil value (global 'abs')\nstack traceback:\n\t/tmp/tmp_wb6my8b.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmp_wb6my8b.lua:44: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    local diff = math.abs(number - math.floor(number))\n\
    \    if diff < 0.5 then\n        return math.floor(number)\n    elseif diff >\
    \ 0.5 then\n        return math.floor(number) + 1\n    else\n        return number\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1me2xxjv.lua:30:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp1me2xxjv.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    return nil\n  end\n  local number = tonumber(value)\n  if number\
    \ == nil then\n    return nil\n  end\n  if number == 0 then\n    return 0\n  end\n\
    \  local nearest_integer = number\n  local current_distance = tonumber(string.sub(number,\
    \ 2))\n  if current_distance > 0 then\n    local current_nearest_integer = tonumber(string.sub(number,\
    \ 3))\n    if current_nearest_integer == nil then\n      current_nearest_integer\
    \ = number\n    else\n      local max_distance = (\n        current_nearest_integer\
    \ - current_distance\n      ):abs()\n      if max_distance < nearest_integer then\n\
    \        nearest_integer = max_distance\n      end\n    end\n  end\n  return nearest_integer\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpc8abtn23.lua:34:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmpc8abtn23.lua:34:\
    \ in local 'candidate'\n\t/tmp/tmpc8abtn23.lua:47: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local difference\
    \ = math.abs(tonumber(value)) - tonumber(value)\n  if difference < 0 then\n  \
    \  difference = -difference\n  elseif difference == 0 then\n    return value\n\
    \  end\n  local round = math.floor\n  if tonumber(value) > tonumber(math.round(math.abs(difference)))\n\
    \  then\n    return round(tonumber(math.round(difference)))\n  else\n    return\
    \ round(tonumber(math.round(math.abs(difference))))\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9gpx33s2.lua:33:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmp9gpx33s2.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if type(value)\
    \ ~= 'string' then\n    error('Usage: closest_integer(value)')\n  end\n  -- First\
    \ we strip any leading and trailing whitespace\n  value = value:gsub('(^%s*(.-)%s*$)'):gsub('(.-)%s*(^%s*)',\
    \ '\\1\\2')\n  value = tonumber(value)\n  if value == nil then\n    return nil\n\
    \  end\n  -- Make sure the value is an integer\n  if value ~= math.floor(value)\
    \ then\n    return nil\n  end\n  -- If the number is equidistant from two integers,\
    \ round it away from zero\n  if math.fmod(value, 2) ~= 0 then\n    local mod =\
    \ math.floor(value)\n    if mod ~= value then\n      return mod\n    end\n  end\n\
    \  -- The number is equidistant from two integers so we just return the closest\n\
    \  -- integer between the two numbers.\n  return math.floor(value)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprha4d5ak.lua:19:\
    \ bad argument #2 to 'gsub' (string/function/table expected)\nstack traceback:\n\
    \t/tmp/tmprha4d5ak.lua:19: in local 'candidate'\n\t/tmp/tmprha4d5ak.lua:43: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if value\
    \ == nil then return nil end\n    local min, max = tonumber(value), tonumber(math.abs(value))\n\
    \    if min < 0 then\n        min = -min\n        max = -max\n    end\n    if\
    \ min == max then\n        return min\n    end\n    if min > max then\n      \
    \  local temp = min\n        min = max\n        max = temp\n    end\n    -- If\
    \ the value is equidistant, round it away from zero.\n    if min - max > 0.5 then\n\
    \        local temp = min\n        min = max\n        max = temp\n    end\n  \
    \  return math.round(min + (max - min) / 2)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp80t9ec9_.lua:42:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp80t9ec9_.lua:42: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value_string\
    \ = string.gsub(value, \"-\", \"\"):gsub(\"%.\", \"\")\n  if value_string:match(\"\
    %d*\") then\n    local digits = value_string:match(\"%d*\")\n    local num_digits\
    \ = tonumber(digits[1])\n    if num_digits == nil then\n      print(\"[warning]\
    \ Number conversion failed when converting string \"..\n        value_string..\"\
    \ to a number. Returning nil...\")\n      return nil\n    end\n    return tonumber(string.sub(digits,\
    \ 1, num_digits))\n  else\n    print(\"[warning] Number conversion failed when\
    \ converting string \"..\n      value_string..\" to a number. Returning nil...\"\
    )\n    return nil\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "[warning] Number conversion failed when converting string 10 to a number.\
    \ Returning nil...\nF\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa27jkaml.lua:35:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpa27jkaml.lua:35: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if value\
    \ == nil then\n        return 0\n    end\n    local num = tonumber(value)\n  \
    \  if num == nil then\n        return value\n    end\n    -- Handle the case where\
    \ num does not have a fractional component\n    local ints, fraction = math.modf(num)\n\
    \    if num == ints then\n        return ints + math.ceil(tonumber(fraction))\n\
    \    end\n    return ints + math.floor(tonumber(fraction))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx83hsugb.lua:34:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpx83hsugb.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local diff1\
    \ = math.abs(tonumber(value) - tonumber(value))\n  local diff2 = math.abs(tonumber(value)\
    \ - tonumber(math.ceil(value)))\n  local diff3 = math.abs(tonumber(value) - tonumber(math.floor(value)))\n\
    \  local min_diff = diff1 + diff2 + diff3\n  if diff1 < min_diff then\n    return\
    \ tonumber(value)\n  elseif diff2 < min_diff then\n    return tonumber(math.ceil(value))\n\
    \  else\n    return tonumber(math.floor(value))\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_kry5mh4.lua:32:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp_kry5mh4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if math.abs(value\
    \ - floor(value)) <= math.abs(value - ceil(value)) then\n    return round(value)\n\
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpw4a49f62.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value_string\
    \ = value\n  local value_number = tonumber(value)\n  local difference\n  -- If\
    \ the number is equidistant, round away from zero.\n  if value_number then\n \
    \   difference = math.abs(value_number - round(value_number))\n    value_number\
    \ = round(value_number)\n  else\n    -- If the number is not a number, just return\
    \ the number.\n    value_number = tonumber(value)\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphnvpzvax.lua:37: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if type(value)\
    \ == \"string\" then\n    local value = tonumber(value)\n  elseif type(value)\
    \ ~= \"number\" then\n    error(\"value is not a string or number\")\n  end\n\
    \  local minimum = math.min(value, math.ceil(value))\n  return math.ceil(value\
    \ - minimum)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\nattempt to\
    \ compare number with string\nstack traceback:\n\nRan 1 tests in 0.000 seconds,\
    \ 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- This\
    \ function will return the closest integer to the given value.\n    -- It works\
    \ by looking at the remainder after dividing the\n    -- input value by one more\
    \ than the largest integer that it can\n    -- divide.\n    if value == \"+inf\"\
    \ or value == \"-inf\"  then\n        return nil\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp874janzk.lua:33: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Calculate\
    \ the absolute value of the number.\n  local absolute_value = \"abs\"\n  .. table.concat({\"\
    floor\", value}, \" \")\n  .. \"*|\"\n  .. table.concat({\"ceiling\", value},\
    \ \" \")\n  .. \"*|\"\n  .. table.concat({\"round\", value}, \" \")\n  .. \"*|\"\
    \n  .. table.concat({\"round\", value}, \" ceiling\")\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfgbh9upl.lua:35: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ x = tonumber(value)\n    local y = tonumber(value + 1)\n    if x == y and x\
    \ > 0 and y > 0 then\n        return x - 1\n    else\n        return x\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpferatenx.lua:28:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpferatenx.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ closest_number(value)\n    local function is_closest(value, other)\n      return\
    \ abs(value - other) < 0.0001\n    end\n    local number = tonumber(value)\n \
    \   if number == nil then\n      return nil\n    end\n    local lower, upper =\
    \ math.floor(number), math.ceil(number)\n    if is_closest(lower, upper) then\n\
    \      return lower\n    end\n    if is_closest(number, lower) then\n      return\
    \ number\n    end\n    if is_closest(number, upper) then\n      return upper\n\
    \    end\n  end\n  return closest_number(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpd7l5pvm2.lua:17:\
    \ attempt to call a nil value (global 'abs')\nstack traceback:\n\t/tmp/tmpd7l5pvm2.lua:17:\
    \ in local 'is_closest'\n\t/tmp/tmpd7l5pvm2.lua:24: in function </tmp/tmpd7l5pvm2.lua:15>\n\
    \t(...tail calls...)\n\t/tmp/tmpd7l5pvm2.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    return nil\n  end\n  local num = tonumber(value)\n  if num\
    \ == 0 then\n    return 0\n  end\n  if num % 2 == 0 then\n    return round(num\
    \ + (num - 1) / 2)\n  else\n    return round(num)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp51hy0cr_.lua:23:\
    \ attempt to call a nil value (global 'round')\nstack traceback:\n\t/tmp/tmp51hy0cr_.lua:23:\
    \ in local 'candidate'\n\t/tmp/tmp51hy0cr_.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = math.abs(value - math.floor(math.abs(value)))\n    if difference\
    \ <= 0.5 then\n        return math.floor(math.abs(value))\n    else\n        return\
    \ math.ceil(math.abs(value))\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpywcv50nw.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpywcv50nw.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal closest\n\
    \t\n\t-- Find out where the value fits within the integer boundaries\n\tvalue\
    \ = math.ceil(value)\n\tif value == math.floor(value) then \n\t\tclosest = -value\
    \ -- The number is equidistant to both sides\n\telse\n\t\tclosest = math.floor(value)\n\
    \tend\n\t\n\t-- Round it away from zero\n\tclosest = math.ceil(closest)\n\t\n\t\
    return closest\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd57hjne4.lua:34:\
    \ expected: 10, actual: -10\nstack traceback:\n\t/tmp/tmpd57hjne4.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal diff\
    \ = value-math.floor(value)\n\tif diff > 0 then\n\t\treturn math.floor(value+0.5)\n\
    \telseif diff < 0 then\n\t\treturn math.ceil(value-0.5)\n\telse\n\t\treturn value\n\
    \tend\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdz03sm8m.lua:28:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmpdz03sm8m.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = math.abs(tonumber(value) - value)\n    if math.abs(difference)\
    \ == 0 then return value else return tonumber(value) end\n    difference = difference\n\
    \    -- if the difference is greater than or equal to one, the difference\n  \
    \  -- must be greater than or equal to zero. Conversely, if the difference\n \
    \   -- was negative, then (if the difference is negative) there must be\n    --\
    \ another integer greater than or equal to the difference and the\n    -- difference\
    \ must be less than or equal to zero.\n    if difference <= 1 then\n        if\
    \ difference > 0 then return value + 1 end\n        return value - 1 -- this also\
    \ happens to be what Python does for negative numbers\n    elseif difference >\
    \ 1 then\n        return math.ceil(value + difference - 0.5) -- round away from\
    \ zero\n    else\n        return math.floor(value + difference - 0.5) -- round\
    \ away from zero\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprhgejaw_.lua:36:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmprhgejaw_.lua:36: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function closest_integer(value)\n        local sign = math.sign(value)\n   \
    \     local power = math.pow(10, math.floor(math.log10(value)))\n        local\
    \ difference = math.abs(value - sign * math.floor(sign * value))\n        local\
    \ difference2 = math.abs(value - sign * math.floor(sign * value)) * power\n  \
    \      if difference < difference2 then\n            return sign * math.floor(sign\
    \ * value)\n        else\n            return math.floor(sign * value)\n      \
    \  end\n    end\n    return closest_integer(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpt6cl7ixh.lua:16:\
    \ attempt to call a nil value (field 'sign')\nstack traceback:\n\t/tmp/tmpt6cl7ixh.lua:16:\
    \ in function </tmp/tmpt6cl7ixh.lua:15>\n\t(...tail calls...)\n\t/tmp/tmpt6cl7ixh.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = math.abs(value - tonumber(value))\n    if difference <= 0.5 then\n\
    \        return tonumber(value)\n    end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpoiw1t5a4.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value)\
    \ + math.abs(value - math.floor(value))\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwx0adxq0.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpwx0adxq0.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ compare(x, y)\n    return x < y then\n      or x == y then\n      or y > x then\n\
    \        then 1\n        then -1\n        else None\n    end\n  end\n  assert(type(value)\
    \ == 'string')\n  value = tonumber(value)\n  local x, y = value, value\n  while\
    \ x ~= nil do\n    x, y = y, x\n  end\n  x = math.round(x)\n  if x > value then\n\
    \    return value + x - 1\n  else\n    return x\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpbfw5xfj3.lua:16: 'end' expected (to close 'function' at line\
    \ 15) near 'then'\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal closest\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpc9oxxqum.lua:27: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ diff = math.abs(value - math.floor(value))\n    if diff > 0.5 then\n       \
    \ return math.floor(value - diff + 0.5)\n    else\n        return math.floor(value\
    \ + diff)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4lw0gz13.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4lw0gz13.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value\
    \ = tonumber(value)\n  if value == nil then return nil end\n  local delta = (value\
    \ - math.floor(value))\n  if delta ~= 0 then return math.floor(value) end\n  if\
    \ value ~= math.floor(value) then return nil end\n  return math.ceil(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpct7gg2x2.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpct7gg2x2.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal value_str\
    \ = tostring(value)\n\tlocal value_int = tonumber(value_str)\n\tif value_int >\
    \ 0 and value_int < 2147483647 then\n\t\treturn value_int\n\telse\n\t\treturn\
    \ tonumber(string.format(\"%.\" .. (math.abs(value_int) - 1) .. \"f\", value_int))\n\
    \tend\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp40gnx0ms.lua:28:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp40gnx0ms.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tvalue =\
    \ tonumber(value)\n\tif not value then\n\t\terror(\"Value must be a number\")\n\
    \tend\n\tlocal rounded = math.round(value)\n\tif rounded == value then\n\t\treturn\
    \ value\n\telse\n\t\tif rounded - math.floor(value) == 0 then\n\t\t\treturn math.floor(value)\n\
    \t\telse\n\t\t\treturn math.floor(rounded)\n\t\tend\n\tend\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzc_ns_p0.lua:19:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmpzc_ns_p0.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmpzc_ns_p0.lua:34: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.round(math.abs(value\
    \ - math.floor(value)))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpy1uhwlh_.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmpy1uhwlh_.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpy1uhwlh_.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local closest_val\
    \ = value\n  local closest_d = 1\n  for _, value in pairs(value) do\n    local\
    \ value = tonumber(value)\n    local d = math.abs(value - closest_val)\n    if\
    \ d < closest_d then\n      closest_val = value\n      closest_d = d\n    end\n\
    \  end\n  return closest_val\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpyu_t1d2o.lua:17:\
    \ bad argument #1 to 'for iterator' (table expected, got string)\nstack traceback:\n\
    \t/tmp/tmpyu_t1d2o.lua:17: in local 'candidate'\n\t/tmp/tmpyu_t1d2o.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   local diff,\
    \ low, high = tonumber(value), 0, math.abs(tonumber(value))\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpd4lznndq.lua:27: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    local sign = math.floor(num)\n    if num - sign <\
    \ 0.5 then\n        return sign + 0.5\n    elseif num - sign > 0.5 then\n    \
    \    return sign - 0.5\n    else\n        return sign\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph5rtph49.lua:29:\
    \ expected: 10, actual: 10.5\nstack traceback:\n\t/tmp/tmph5rtph49.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- The\
    \ original code was designed to find the closest integer to the value\n    --\
    \ and to find the closest integer is fairly useless in many cases\n    -- (where\
    \ it returns the integer itself). Therefore we instead find\n    -- whichever\
    \ integer is closest to the value with some tolerance.\n    -- This is based on\
    \ our previous work on linear programming.\n    -- We use \"abs(value - closest_integer)\"\
    \ as a measure of tolerance.\n    -- We use \"ceil(closest_integer)\" as a way\
    \ to round up the closest\n    -- integer to make life easier when comparing integers.\n\
    \    -- We use a threshold of 5 digits just to keep things simple.\n    -- Our\
    \ threshold of 5 digits can be adjusted if it turns out that\n    -- numbers have\
    \ a much higher tolerance when compared to floats.\n    local threshold = 5 *\
    \ math.pow( 10, -5 )\n    local closest = 0\n    for _, x in ipairs( values )\
    \ do\n        if abs(x - closest) < threshold then\n            closest = x\n\
    \        else\n            -- We need to increase the closest integer by 1 so\
    \ that we\n            -- don't have to check the entire loop.\n            closest\
    \ = closest\n        end\n    end\n    -- In case there are no integers close\
    \ enough, return 0\n    if closest = 0 then\n        return 0\n    else\n    \
    \    return math.ceil(closest)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpw8m86km8.lua:38: 'then' expected near '='\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if value\
    \ == nil then return nil end\n    value = tonumber(value)\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1_jyj4f2.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local diff\
    \ = math.abs(value - closest_integer(value))\n  local is_negative = value < 0\n\
    \  if diff < .000000000000000000000000000000000001 then\n    return is_negative\
    \ and -value or value\n  elseif diff < .000000000000000000000000000000000000000001\
    \ then\n    return value\n  elseif diff < .00000000000000000000000000000000000000000000001\
    \ then\n    return math.floor(value)\n  else\n    return math.ceil(value)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphlc75bgo.lua:15:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmphlc75bgo.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmphlc75bgo.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmphlc75bgo.lua:15:\
    \ in upvalue 'closest_integer'\n\t/tmp/tmphlc75bgo.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmphlc75bgo.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmphlc75bgo.lua:15:\
    \ in upvalue 'closest_integer'\n\t/tmp/tmphlc75bgo.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmphlc75bgo.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmphlc75bgo.lua:15:\
    \ in upvalue 'closest_integer'\n\t...\n\t/tmp/tmphlc75bgo.lua:15: in local 'candidate'\n\
    \t/tmp/tmphlc75bgo.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.150\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ is_closest(num, closest)\n    if closest == 0 then\n      return num\n    end\n\
    \    if num - closest <= 0.000000001 then\n      return closest\n    end\n   \
    \ local factor\n    if closest ~= num and closest ~= closest * 2 then\n      factor\
    \ = closest - num\n    end\n    return closest + num / factor\n  end\n  local\
    \ closest\n  local closestValue = value\n  if type(closestValue) == \"number\"\
    \ then\n    closest = closestValue\n  else\n    closestValue = closestValue[1]\n\
    \    closest = closestValue[2]\n  end\n  local currentValue = value\n  local currentDiff\
    \ = closestValue - closest\n  while currentDiff > 0 do\n    closest = is_closest(currentValue,\
    \ closest)\n    currentValue = currentValue + closest\n    currentDiff = currentDiff\
    \ - closest\n  end\n  return closest\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxilmk3bs.lua:34:\
    \ attempt to index a nil value (local 'closestValue')\nstack traceback:\n\t/tmp/tmpxilmk3bs.lua:34:\
    \ in local 'candidate'\n\t/tmp/tmpxilmk3bs.lua:49: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Convert\
    \ the value to an integer, then subtract it from itself to\n  -- find the distance\
    \ between itself and value.\n  local value_as_number = tonumber(value)\n  return\
    \ value_as_number - value_as_number\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxqdmzuyg.lua:24:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpxqdmzuyg.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value)\
    \ + math.abs(value - math.floor(value))\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp193bmixx.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp193bmixx.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   local function\
    \ closest(a, b)\n      return a < b and b\n         or b < a and a\n         or\
    \ b\n         and a\n         and b\n         or a\n   end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpjp3maljd.lua:34: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- If the\
    \ value is a string, replace the leading digit with '0' and then\n  -- convert\
    \ it into an integer.\n  local is_string = type(value) == 'string'\n  if is_string\
    \ then\n    value = value:gsub('%-?%d+', '0%'):tonumber()\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp80mele0u.lua:32: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ distance(a, b) return math.abs(a - b) end\n  local i = 1\n  local last_diff\
    \ = -1000\n  while i do\n    local diff = distance(value, int_to_string(math.floor(value)))\n\
    \    if diff < last_diff then\n      return int_to_string(math.floor(value))\n\
    \    end\n    last_diff = diff\n    i = i * 10\n  end\n  return int_to_string(math.floor(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp95r0n6pk.lua:19:\
    \ attempt to call a nil value (global 'int_to_string')\nstack traceback:\n\t/tmp/tmp95r0n6pk.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmp95r0n6pk.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local factor\
    \ = 1\n  local difference = 0\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1bvfuqie.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- If the\
    \ given number is negative, return its absolute value.\n  if value then\n    if\
    \ value < 0 then\n      return abs(value)\n    end\n  else\n    -- If the given\
    \ number is positive, return zero.\n    return 0\n  end\n  -- Divide the given\
    \ number by two until it equals zero. Divide it by two until\n  -- the quotient\
    \ is even.\n  local divisor = 2\n  local quotient = 0\n  while quotient ~= 0 do\n\
    \    quotient = value / divisor\n    -- If the quotient is even, divide it by\
    \ two and return the quotient.\n    if quotient % 2 == 0 then\n      divisor =\
    \ divisor * 2\n      return quotient\n    end\n    -- If the quotient is odd,\
    \ subtract one from the divisor and divide it\n    -- by two.\n    divisor = divisor\
    \ - 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_lk8j5g6.lua:17:\
    \ attempt to compare string with number\nstack traceback:\n\t/tmp/tmp_lk8j5g6.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp_lk8j5g6.lua:44: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num_digits\
    \ = #value\n  local decimal_places = math.remainder(value, 1)\n  local rounded_away_from_zero\
    \ = math.floor(decimal_places)\n  if rounded_away_from_zero ~= decimal_places\
    \ then\n    return rounded_away_from_zero\n  end\n  -- If decimal_places is even,\
    \ we need to return decimal_places +1.\n  if decimal_places == 0 then\n    return\
    \ num_digits + 1\n  end\n  -- If decimal_places is odd, we need to return decimal_places\
    \ - 1.\n  return decimal_places - 1\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp37owe18b.lua:16:\
    \ attempt to call a nil value (field 'remainder')\nstack traceback:\n\t/tmp/tmp37owe18b.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp37owe18b.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal num\
    \ = tonumber(value)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp36d5mzdi.lua:27: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  -- Check that the given value is a number.\n  if not num\
    \ then return nil end\n  -- If value is zero, return zero.\n  if num == 0 then\
    \ return 0 end\n  -- If value is negative, return the same value.\n  if num <\
    \ 0 then return -num end\n  -- If value is close to 0, return it.\n  if num <=\
    \ 0.000001 then return num end\n  -- Create a table of numbers around the current\
    \ value.\n  local delta = {\n    [1] = num - 0.00000001, -- 1\n    [2] = num -\
    \ 0.00000002, -- 2\n    [3] = num - 0.00000004, -- 3\n    [4] = num - 0.00000008,\
    \ -- 4\n    [5] = num - 0.00000016, -- 5\n    [6] = num - 0.00000032, -- 6\n \
    \   [7] = num - 0.00000064, -- 7\n    [8] = num - 0.00000128, -- 8\n    [9] =\
    \ num - 0.0000256, -- 9\n    [10] = num - 0.000512, -- 10\n    [11] = num - 0.001280,\
    \ -- 11\n    [12] = num - 0.002560, -- 12\n    [13] = num - 0.004096, -- 13\n\
    \    [14] = num - 0.008192, -- 14\n    [15] = num - 0.016384, -- 15\n    [16]\
    \ = num - 0.032768, -- 16\n    [17] = num - 0.065536, -- 17\n    [18] = num -\
    \ 0.131072, -- 18\n    [19] = num - 0.262144, -- 19\n    [20] = num - 0.524288,\
    \ -- 20\n    [21] = num - 0.796816, -- 21\n    [22] = num - 1.073743, -- 22\n\
    \    [23] = num - 1.346939, -- 23\n    [24] = num - 1.725188, -- 24\n    [25]\
    \ = num - 2.018688, -- 25\n    [26] = num - 2.302516, -- 26\n    [27] = num -\
    \ 2.594986, -- 27\n    [28] = num - 2.897435, -- 28\n    [29] = num - 3.196875,\
    \ -- 29\n    [30] = num - 3.490666, -- 30\n    [31] = num - 3.802184, -- 31\n\
    \    [32] = num - 4.094512, -- 32\n    [33] = num - 4.410560, -- 33\n    [34]\
    \ = num - 4.713896, -- 34\n    [35] = num - 5.114510, -- 35\n    [36] = num -\
    \ 5.41764\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpef53mdpr.lua:62: '}' expected (to close '{' at line 25) near\
    \ 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal factor\n\
    \tlocal closest\n\t-- Get a number close to `value` that is factors of 10 and\
    \ larger.\n\tfactor = math.floor(math.log(abs(value)) / math.log(10))\n\t-- Get\
    \ the number that is closest to `value`.\n\tclosest = (value - factor * 10) *\
    \ 10\n\t-- Return 0 if the number close to `value` is equidistant from two\n\t\
    -- integers (i.e. the number is far away from zero).\n\tif math.abs(closest) ==\
    \ math.abs(value) then\n\t\treturn 0\n\tend\n\treturn closest\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpngyjj6pv.lua:18:\
    \ attempt to call a nil value (global 'abs')\nstack traceback:\n\t/tmp/tmpngyjj6pv.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpngyjj6pv.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   local diff1\
    \ = math.abs(value - math.floor(value))\n   local diff2 = math.abs(value - math.ceil(value))\n\
    \   if diff1 ~= diff2 then return math.floor(value) end\n   return math.ceil(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp1kppudn.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpp1kppudn.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value[0]\
    \ == '-' then\n    return math.floor(value * 100 / 2) + 100\n  end\n  return math.floor(value)\
    \ + math.ceil(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjuv1m_us.lua:24:\
    \ expected: 10, actual: 20\nstack traceback:\n\t/tmp/tmpjuv1m_us.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    return nil\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpxrcop4er.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   local closest_integer\
    \ = math.ceil(value)\n   return (value - closest_integer) or closest_integer\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5dy2zs57.lua:22:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmp5dy2zs57.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local float_value\
    \ = tonumber(value)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3lt7r9t9.lua:27: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- First,\
    \ convert value to float.\n    local value_as_number = tonumber(value)\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3erjierw.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal num\
    \ = tonumber(value)\n\tif num == nil then\n\t\treturn nil\n\tend\n\tif num < 0\
    \ then\n\t\treturn math.max(num, 0) + math.abs(num) / 2\n\telse\n\t\treturn math.max(num,\
    \ 0) - math.abs(num) / 2\n\tend\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2hjza8dv.lua:29:\
    \ expected: 10, actual: 5\nstack traceback:\n\t/tmp/tmp2hjza8dv.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local diff,\
    \ nearest_int = 0, value\n  for i = 1, 100 do\n    local _, n = value:match('(-?)(%d*)')\n\
    \    if n and tonumber(n) then\n      local n_int = tointeger(n)\n      if diff\
    \ > n_int - nearest_int then\n        nearest_int = n_int\n        diff = n_int\
    \ - nearest_int\n      end\n    end\n  end\n  return nearest_int + diff\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdc9ztnkp.lua:19:\
    \ attempt to call a nil value (global 'tointeger')\nstack traceback:\n\t/tmp/tmpdc9ztnkp.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmpdc9ztnkp.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal int_value\
    \ = tonumber(value)\n\tif int_value == nil then\n\t\treturn nil\n\tend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp83fbta1g.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- If value\
    \ is nil, return 0\n  if value == nil then\n    return 0\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_4010rxh.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = math.abs(value - closest_integer(value))\n    if difference < 1e-10\
    \ then\n        return math.round(value)\n    end\n    return math.round(value/2.0\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp598m7lu7.lua:15:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmp598m7lu7.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmp598m7lu7.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmp598m7lu7.lua:15:\
    \ in upvalue 'closest_integer'\n\t/tmp/tmp598m7lu7.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmp598m7lu7.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmp598m7lu7.lua:15:\
    \ in upvalue 'closest_integer'\n\t/tmp/tmp598m7lu7.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmp598m7lu7.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmp598m7lu7.lua:15:\
    \ in upvalue 'closest_integer'\n\t...\n\t/tmp/tmp598m7lu7.lua:15: in local 'candidate'\n\
    \t/tmp/tmp598m7lu7.lua:25: in function 'test_humaneval'\n\nRan 1 tests in 0.170\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal function\
    \ closest_integer_helper(value, low, high)\n\t\tif low > high then\n\t\t\treturn\
    \ low\n\t\tend\n\t\tif math.abs(value - low) < math.abs(value - high) then\n\t\
    \t\treturn math.floor(value)\n\t\telse\n\t\t\treturn math.ceil(value)\n\t\tend\n\
    \tend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpj9hs0lek.lua:36: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then return nil end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8z8kgtaa.lua:27: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal function\
    \ is_close(a, b, epsilon)\n\t\t-- Check if b has already been compared to a\n\t\
    \tif b > a then\n\t\t\tlocal diff = b - a\n\t\t\treturn diff <= epsilon or diff\
    \ >= -epsilon\n\t\tend\n\t\t\n\t\t-- Check if b is less than a\n\t\tlocal diff\
    \ = b - a\n\t\treturn diff <= epsilon or diff >= -epsilon\n\tend\n\t\n\t-- Check\
    \ if value is an integer, and if so,\n\t-- return the integer.\n\tif type(tostring(value))\
    \ ~= \"number\" then\n\t\treturn nil\n\tend\n\t\n\t-- Check if value is an integer.\n\
    \tlocal ok = value == math.floor(value)\n\tif not ok then\n\t\treturn nil\n\t\
    end\n\t\n\t-- Check if the given number is equidistant from two integers.\n\t\
    local closest = math.floor(value / 2.0)\n\tlocal a = value - closest\n\tlocal\
    \ b = value + closest\n\tif is_close(a, b, 1e-10) then\n\t\treturn closest\n\t\
    end\n\t\n\treturn nil\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf3lpor3x.lua:53:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpf3lpor3x.lua:53: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- If value\
    \ is an integer, just return it\n  -- Otherwise create a string representation\
    \ of it\n  if tonumber(value) == value then\n    return value\n  else\n    return\
    \ tonumber(string.format(\"%0.1f\", value))\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvxsjhvj7.lua:28:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpvxsjhvj7.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tif value:match('^-?%d+$')\
    \ then\n\t\treturn tonumber(math.floor(tonumber(value))) + 1\n\tend\n\treturn\
    \ math.floor(tonumber(value)) + 1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp82lkrkzw.lua:24:\
    \ expected: 10, actual: 11\nstack traceback:\n\t/tmp/tmp82lkrkzw.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ <= 0 then return 0 end\n  local sign = math.sign(value)\n  local base_value\
    \ = value\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmps3h497n7.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value\
    \ = tonumber(value)\n  if value == nil then return nil end\n  -- Get all possible\
    \ integers within one less than the given value.\n  -- If no integers exist, return\
    \ nil.\n  local integers = math.floor(value / 1) - 1\n  if #integers == 0 then\
    \ return nil end\n  -- Return first integer that is\n  -- the closest to zero.\n\
    \  local closest = integers[1]\n  for i = 2, #integers do\n    local difference\
    \ = integers[i] - closest\n    if difference < 0 then\n      closest = integers[i]\n\
    \    else\n      -- If difference is positive and closest\n      -- is negative,\
    \ return closest negative.\n      closest = closest + (difference > 0 and 1 or\
    \ -1)\n    end\n  end\n  return closest\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpvc8u6ori.lua:20:\
    \ attempt to get length of a number value (local 'integers')\nstack traceback:\n\
    \t/tmp/tmpvc8u6ori.lua:20: in local 'candidate'\n\t/tmp/tmpvc8u6ori.lua:40: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   local result\n\
    \   value = tonumber(value)\n   if value == nil then return nil end\n   if value\
    \ == 0 then return 0 end\n   if value < 0 and math.abs(value) < math.abs((value+1):max())\
    \ then return -value end\n   if value > 0 and math.abs(value) < math.abs((value-1):min())\
    \ then return value end\n   if math.abs(value) == 0 then\n      result = 0\n \
    \  else\n      result = tonumber(string.format(\"%.*f\", math.ceil(math.log10(value)),\
    \ value))\n   end\n   return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_10dz62o.lua:20:\
    \ attempt to index a number value\nstack traceback:\n\t/tmp/tmp_10dz62o.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmp_10dz62o.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- If the\
    \ number is equal to or less than zero, return zero.\n  return value <= 0 and\
    \ 0 or math.floor(math.abs(value));\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7jyz8wms.lua:16:\
    \ attempt to compare string with number\nstack traceback:\n\t/tmp/tmp7jyz8wms.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp7jyz8wms.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num_int\
    \ = tonumber(value)\n  local difference\n  -- If the number is less than or equal\
    \ to zero, return zero.\n  if not num_int then\n    return 0\n  end\n  -- If the\
    \ number is equidistant, return either one or the other integer\n  -- that is\
    \ closest to zero.\n  if num_int == num_int - 0.5 then\n    return num_int\n \
    \ else\n    difference = num_int - math.floor(num_int)\n    if difference > -0.5\
    \ then\n      return math.floor(num_int)\n    else\n      return math.ceil(num_int)\n\
    \    end\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6xb3_qqj.lua:39:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp6xb3_qqj.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local differences\
    \ = {}\n  for i = 1, 9 do\n    local difference = math.abs(tonumber(value) - tonumber(string.format(\"\
    %.f\", i)))\n    table.insert(differences, difference)\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp2o2rrio5.lua:31: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function find_closest(v)\n        -- This function returns two values:\n   \
    \     -- * The closest number\n        -- * The distance from 0 to the closest\
    \ number\n        local closest_num, closest_dist = -math.huge, math.huge\n  \
    \      for i = 1, #value do\n            local num = tonumber(value[i])\n    \
    \        if num < 0 then\n                num = -num\n            end\n      \
    \      local diff = closest_num + num\n            if diff < closest_dist then\n\
    \                closest_num, closest_dist = num, diff\n            end\n    \
    \    end\n        return closest_num, closest_dist\n    end\n    local value,\
    \ distance = find_closest(value)\n    if distance < 0 then\n        -- If the\
    \ number is equidistant from two integers, return the\n        -- integer that\
    \ is farthest from zero.\n        local first_num, first_dist = value[1], distance[1]\n\
    \        for i = 2, #value do\n            local second_num, second_dist = value[i],\
    \ distance[i]\n            if first_dist > second_dist then\n                return\
    \ first_num\n            elseif first_dist == second_dist then\n             \
    \   local delta = second_num - first_num\n                if delta > 0 then\n\
    \                    return first_num + delta\n                else\n        \
    \            return first_num - delta\n                end\n            end\n\
    \        end\n    end\n    return value\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7ypsf9fq.lua:22:\
    \ attempt to compare nil with number\nstack traceback:\n\t/tmp/tmp7ypsf9fq.lua:22:\
    \ in local 'find_closest'\n\t/tmp/tmp7ypsf9fq.lua:32: in local 'candidate'\n\t\
    /tmp/tmp7ypsf9fq.lua:57: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if type(value)\
    \ ~= \"string\" then\n        return nil\n    end\n    -- TODO: This won't handle\
    \ rounding down in certain cases like\n    -- 12.6 -> 13. Need to fix it by making\
    \ it 12.7 and 12.8 -> 13\n    -- by changing the first condition and the first\
    \ condition.\n    -- If value is less than 10, use 10.\n    if value < \"10\"\
    \ then\n        local v = \"10\"\n    else\n        v = value\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvyyma2fx.lua:38: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ helper(num)\n    if num == 0 then\n      error(\"Can't divide by zero\")\n \
    \   end\n    local closest_value\n    for i = 1, (#num / 2) do\n      local left\
    \ = string.sub(num, 0, i-1)\n      local right = string.sub(num, (#num), i)\n\
    \      local left_number = tonumber(left)\n      local right_number = tonumber(right)\n\
    \      if left_number and right_number then\n        if left_number < right_number\
    \ then\n          closest_value = left_number\n        else\n          closest_value\
    \ = right_number\n        end\n      else\n        if left_number then\n     \
    \     closest_value = left_number\n        else\n          closest_value = right_number\n\
    \        end\n      end\n    end\n    return closest_value\n  end\n  return helper(tostring(val))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4yfrl4e6.lua:47:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp4yfrl4e6.lua:47: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ integer_abs(n)\n    if n == nil then\n      error(\"can't call math.abs on nil\"\
    )\n    end\n    return math.abs(n)\n  end\n  local function round_to_even(n)\n\
    \    return math.floor(n / 2) * 2\n  end\n  local function round_to_zero(n)\n\
    \    if n == nil then\n      error(\"can't call math.abs on nil\")\n    end\n\
    \    if n < 0 then\n      return round_to_even(math.ceil(n))\n    else\n     \
    \ return round_to_even(math.floor(n))\n    end\n  end\n  local function divide_then_round_to_even(n,\
    \ p)\n    return round(n / p) * p\n  end\n  local function round(n) -- Round a\
    \ number to an even number\n    return round_to_even(n)\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpnk52vhuv.lua:51: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then return nil end\n  local sign = math.sign(value)\n  if sign == 0\
    \ then return 0 end\n  -- Convert string to float\n  value = tonumber(value)\n\
    \  -- Check if value is an integer\n  if value == value then\n    -- If value\
    \ is an integer with no other numbers, return the integer\n    if value == int(value)\
    \ then\n      return value\n    else\n      -- If value is an integer, return\
    \ the integer with value rounded\n      -- away from zero.\n      return math.ceil(value)\n\
    \    end\n  else\n    -- If the value is not a number, return nil\n    return\
    \ nil\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2yzgq12v.lua:16:\
    \ attempt to call a nil value (field 'sign')\nstack traceback:\n\t/tmp/tmp2yzgq12v.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp2yzgq12v.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if value\
    \ == nil then\n        return nil\n    end\n    -- Make sure value is numeric.\n\
    \    local value = tonumber(value)\n    if value == nil then\n        return value\n\
    \    end\n    -- If the value is an integer, return it.\n    if value == math.floor(value)\
    \ then\n        return value\n    end\n    -- If the value is negative, it's an\
    \ error.\n    if value >= 0 then\n        return nil\n    end\n    -- If the value\
    \ is less than -100, it's an error.\n    if value <= -100 then\n        return\
    \ nil\n    end\n    -- Get the closest integer.\n    local closest_integers =\
    \ math.ceil(value / 100) * 100\n    -- If the value is greater than (-100 ~< closest_integers\
    \ < 100), return it.\n    if value < closest_integers then\n        return closest_integers\n\
    \    end\n    -- If the value is less than -100, it's an error.\n    if value\
    \ >= -100 then\n        return nil\n    end\n    -- If the value is less than\
    \ -100, it's an error.\n    if value <= -100 then\n        return nil\n    end\n\
    \    -- Else, return it rounded towards zero.\n    return math.floor(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsj4xjbfw.lua:57:\
    \ expected: 15, actual: nil\nstack traceback:\n\t/tmp/tmpsj4xjbfw.lua:57: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ float_value = tonumber(value)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9axpae53.lua:27: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then return nil end\n  local diff, err = tonumber(value) - 1, nil\n \
    \ if diff == nil then return nil end\n  local closest, err = math.floor(diff +\
    \ 0.5), nil\n  if closest == nil then return nil end\n  local digits = math.pow(10,\
    \ math.floor(math.log10(diff + 1))) -- get number of digits after the decimal\
    \ point\n  if digits > 6 then return nil end\n  return closest\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpphkp6gbj.lua:28:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpphkp6gbj.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   -- If the\
    \ given value is a string or nil, return nil.\n   if type(value) == \"string\"\
    \ then\n      return nil\n   end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp604fjen6.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then return nil end\n  local sign = 1\n  if value ~= value then sign\
    \ = -1 end\n  local value = tonumber(value)\n  if value == nil then return nil\
    \ end\n  local lower = math.floor(value)\n  local upper = math.ceil(value)\n \
    \ -- If the number is not equidistant from two integers, return nil.\n  if lower\
    \ == value or upper == value then return nil end\n  -- If the number is equidistant\
    \ from two integers, return the largest\n  -- integer.\n  if lower < upper then\n\
    \    return math.max(lower, upper)\n  -- If the number is equidistant from two\
    \ integers, return the smallest\n  -- integer.\n  else\n    return math.min(lower,\
    \ upper)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc0m5pgii.lua:38:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpc0m5pgii.lua:38: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(\n\
    \    (abs(tonumber(value) - tonumber(value)))\n  )\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqmcynufq.lua:16:\
    \ attempt to call a nil value (global 'abs')\nstack traceback:\n\t/tmp/tmpqmcynufq.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpqmcynufq.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ closest_integer(value)\n    local digits = string.rep(\"0123456789\", math.floor(math.log10(value)))\n\
    \    local diff = digits - tonumber(string.sub(value, 1, -1))\n    return tonumber(string.rep(\"\
    0\", diff) + value) or 0\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpp3qmojy2.lua:31: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  assert(num, \"Expected a number for closest_integer\")\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6etw01g9.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if tonumber(value)\
    \ >= tonumber(0) then\n        return tonumber(value)\n    elseif tonumber(value)\
    \ >= tonumber(1) then\n        return tonumber(0)\n    elseif tonumber(value)\
    \ >= tonumber(-1) then\n        return tonumber(-1)\n    end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpjsw6_icb.lua:33: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local diff\
    \ = tonumber(value)\n  local diff1 = tonumber(value)\n  local diff2 = tonumber(value)\n\
    \  if type(value) == \"string\" then\n    value = tonumber(value)\n  end\n  diff1\
    \ = math.floor(diff1)\n  diff2 = math.floor(diff2)\n  diff = math.abs(diff1 -\
    \ diff2)\n  if diff < 1 then\n    diff, diff1 = diff1, diff\n  end\n  return diff1\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8hbmoxbc.lua:33:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmp8hbmoxbc.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    return nil\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpccn5ossr.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ closest\n    local closest_dist\n    if type(value) ~= 'number' then\n     \
    \   return nil\n    end\n    local value = tonumber(value)\n    local max_dist\
    \ = 0\n    local max_int = 0\n    for _, other in ipairs(values) do\n        if\
    \ other > 0 then\n            local other_dist = math.abs(value - other)\n   \
    \         if other_dist > max_dist then\n                max_dist = other_dist\n\
    \                closest_int = other\n            elseif other_dist == max_dist\
    \ then\n                if other_dist < max_dist then\n                    closest_int\
    \ = other\n                end\n            end\n        end\n    end\n    closest\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpiaprxo1g.lua:37: syntax error near 'end'\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    return nil\n  end\n  if value:sub(1, 1) ~= \"\" then -- Only\
    \ one character\n    local divisor, num = tonumber(value), tonumber(string.sub(value,\
    \ 2))\n    if num == nil then -- Not a valid number\n      return nil\n    end\n\
    \    return tonumber(math.ceil(num / divisor))\n  end\n  local divisor, num =\
    \ tonumber(value), tonumber(string.sub(value, 1))\n  if num == nil then -- Not\
    \ a valid number\n    return nil\n  end\n  return tonumber(math.ceil(num / divisor))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp795l8asi.lua:35:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmp795l8asi.lua:35: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ closest_integer(value)\n    -- Get a list of the digits in value as a list of\
    \ integers.\n    local digits = value:gsub(\"%d+\", function(digit)\n      return\
    \ tonumber(digit)\n    end)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpbsj0jw84.lua:31: 'end' expected (to close 'function' at line\
    \ 15) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if not num then\n        return\n    end\n    local\
    \ num = num + 0.0\n    if num < 0 then\n        num = math.floor(num)\n    else\n\
    \        num = math.ceil(num)\n    end\n    return num\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvnm8q3p8.lua:34:\
    \ expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpvnm8q3p8.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Return\
    \ the closest integer to the given value.\n  return math.round(math.floor((math.abs(value)\
    \ + 0.5)))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpexixkwzk.lua:16:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmpexixkwzk.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpexixkwzk.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if value\
    \ == nil then return nil end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpl_ihm621.lua:27: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if type(value)\
    \ ~= \"string\" then return end\n  local digits = value:gsub(\".\", \"\")\n  local\
    \ min = 0\n  local max = #digits - 1\n  while min < max do\n    local mid = (min\
    \ + max) / 2\n    local current_value = tonumber(digits[mid])\n    if current_value\
    \ == nil then return end -- Not a number\n    if min == mid then return current_value\
    \ end\n    if current_value ~= nil then\n      if current_value < value then min\
    \ = mid + 1 else max = mid end\n    else -- current_value == nil\n      if value\
    \ == 0 then return 0 end\n      min = mid\n    end\n  end\n  return tonumber(digits[min])\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuw03ciqo.lua:37:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpuw03ciqo.lua:37: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tif value\
    \ == nil then return nil end\n\tlocal sign = value == \"-\" and -1 or 1\n\tlocal\
    \ difference = tonumber(value)\n\tif difference == nil then\n\t\treturn nil\n\t\
    end\n\tlocal limit = math.max(math.abs(difference), 1e-6)\n\tlocal limit = math.ceil(limit)\
    \ -- Round to nearest\n\tif math.abs(difference) < limit then\n\t\treturn value\n\
    \tend\n\tlocal limit = math.floor(limit)\n\tif difference < 0 then\n\t\treturn\
    \ sign - limit\n\telse\n\t\treturn limit + sign\n\tend\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr2048h4e.lua:37:\
    \ expected: 10, actual: 11\nstack traceback:\n\t/tmp/tmpr2048h4e.lua:37: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local closest\n\
    \  if value == \"0\" then\n    return 0\n  end\n  closest = (math.floor(math.abs(value))\
    \ + math.floor(math.abs(value - (math.floor(math.abs(value))))) - 1)\n  if closest\
    \ < 0 then\n    closest = 0\n  end\n  return closest\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1tqnym98.lua:29:\
    \ expected: 10, actual: 9\nstack traceback:\n\t/tmp/tmp1tqnym98.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- Handle\
    \ negative numbers by finding the closest integer to the negated number\n    if\
    \ value == \"-\" then\n        value = value\n        for i=2,#args do\n     \
    \       if tonumber(args[i]) < tonumber(value) then\n                value = args[i]\n\
    \            end\n        end\n    end\n    -- Handle positive numbers by finding\
    \ the closest integer to the negated number\n    if value == \"+\" then\n    \
    \    value = value\n        for i=2,#args do\n            if tonumber(args[i])\
    \ > tonumber(value) then\n                value = args[i]\n            end\n \
    \       end\n    end\n    return tonumber(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjec8j0tm.lua:40:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpjec8j0tm.lua:40: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ is_negative = value:sub(-1, 1, 1):lt(0)\n    if is_negative then\n        value\
    \ = -value:sub(1, 1)\n    end\n    return math.floor(value)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpijpx_cwc.lua:15:\
    \ attempt to call a nil value (method 'lt')\nstack traceback:\n\t/tmp/tmpijpx_cwc.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpijpx_cwc.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local function\
    \ is_equidistant(integer1, integer2)\n    local difference = math.abs(integer1\
    \ - integer2)\n    return difference <= 1\n  end\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp19vh_gd0.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    return nil\n  end\n  if type(value) ~= 'string' then\n    return\
    \ nil\n  end\n  if value == \"\" then\n    return 0\n  end\n  local _, num, _,\
    \ _, _ = value:match(\"^([+-]?(?:(?:0x)?-?(?:0x)?[0-9a-f]+)|(?:0x)?-?[0-9]+)([.][0-9]+)?$\"\
    )\n  if num == nil then\n    return nil\n  end\n  local sign, digits, decimals\
    \ = num:match(\"^([+-])([-+]?[0-9]*)(?:(\\\\.[0-9]*))?$\")\n  if sign == nil then\n\
    \    sign = string.sub(num, 1, 1)\n    digits = string.sub(num, 2)\n    decimals\
    \ = nil\n  end\n  if decimals == nil then\n    decimals = string.sub(num, -1,\
    \ -1)\n  end\n  local factor = 1\n  local precision = 0\n  if digits == nil then\n\
    \    digits = string.sub(num, -2)\n    if decimals == nil then\n      return sign\
    \ * tonumber(digits) * factor\n    end\n  end\n  local decimals_str = string.sub(decimals,\
    \ 1, 1)\n  local decimals_strlen = string.len(decimals_str)\n  if decimals_strlen\
    \ == 2 then\n    local decimals_decimal = tonumber(decimals)\n    if decimals_decimal\
    \ ~= nil then\n      precision = decimals_decimal\n    end\n  elseif decimals_strlen\
    \ == 1 and decimals_str == \"0\" then\n    precision = 1\n  end\n  if digits ==\
    \ nil then\n    digits = string.sub(num, -2)\n  end\n  local digits_str = string.sub(digits,\
    \ 1, 1)\n  local digits_strlen = string.len(digits_str)\n  if digits_strlen ==\
    \ 2 then\n    local digits_decimal = tonumber(digits)\n    if digits_decimal ~=\
    \ nil then\n      factor = digits_decimal\n    end\n  end\n  local decimals_decimal\
    \ = tonumber(decimals)\n  if decimals_decimal ~= nil then\n    factor = decimals_decimal\
    \ * factor\n  end\n  if digits == nil then\n    digits = string.sub(num, -2)\n\
    \  end\n  if decimals == nil then\n    decimals = string.sub(num, -1, -1)\n  end\n\
    \  local digits_decimal = tonumber(digits)\n  if digits_decimal ~= nil then\n\
    \    factor = digits_decimal * factor\n  end\n  if factor == nil then\n    return\
    \ nil\n  end\n  if sign == \"-\" then\n    return math.floor(-math.abs(tonumber(digits)\
    \ * factor))\n  end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpmr_1ffbg.lua:98: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ ints = {}\n    for i = -1000, 1000 do\n        local val = tonumber(string.format(\"\
    %.2g\", value + i * 0.0001))\n        if val ~= nil then\n            table.insert(ints,\
    \ val)\n        end\n    end\n    local last = ints[1]\n    for _, v in ipairs(ints)\
    \ do\n        if v - last <= 0.000001 then\n            return last\n        end\n\
    \        last = v\n    end\n    return nil\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpttd4it9t.lua:35:\
    \ expected: 10, actual: 9.9\nstack traceback:\n\t/tmp/tmpttd4it9t.lua:35: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value\
    \ = tonumber(value)\n  if value == nil then return nil end\n  local sign = math.abs(value)\n\
    \  if sign == 0 then\n    if value < 0 then\n      return value\n    end\n   \
    \ return 0\n  end\n  local factor = 1\n  while sign * factor < sign do\n    factor\
    \ *= 10\n  end\n  -- Now we know the closest number to `value` is `value/factor`\
    \ closest\n  -- to zero.\n  if sign == -1 and value < 0 then\n    -- Value is\
    \ negative, factor is positive.\n    sign = sign * -1\n    factor = sign * factor\n\
    \  end\n  -- Value is positive, factor is negative.\n  -- So this should work\
    \ since `value/factor` is closer to zero than `value`.\n  local remainder = (value\
    \ - sign * factor) / factor\n  assert(remainder >= 0 and remainder <= 1)\n  --\
    \ Return the closest integer.\n  return sign * factor * remainder\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppfo3u0zr.lua:26: syntax error near '*'\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   -- The\
    \ idea is to find two closest numbers:\n   --   1) The first that is bigger then\
    \ the given number\n   --   2) The first that is smaller  then the given number\n\
    \   -- If these two numbers are equidistant from zero, then the number\n   --\
    \ itself is returned.\n   local function find_closest(a, b)\n      if a > b then\n\
    \         return a\n      else\n         return b\n      end\n   end\n   local\
    \ function distance(a, b)\n      if a < b then\n         return b - a\n      else\n\
    \         return b - a\n      end\n   end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpy60459q4.lua:45: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  value =\
    \ tonumber(value)\n  if value == nil then\n    return nil\n  elseif value == math.floor(value)\
    \ then\n    -- Don't allow the argument to be zero.\n    if value == 0 then\n\
    \      return nil\n    else\n      return value\n    end\n  else\n    -- Calculate\
    \ the difference between value and the next integer.\n    -- Note that this formula\
    \ doesn't take into account that value\n    -- is an integer already.\n    return\
    \ math.floor(value) + math.ceil(value) - value\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7eqoar3c.lua:37:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp7eqoar3c.lua:37: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local int_value\
    \ = value\n  local closest\n  -- If the number is not equidistant from two integers,\
    \ return it.\n  if int_value ~= tonumber(int_value) then\n    closest = (tonumber(int_value)\
    \ or 0)\n  else\n    -- Find the difference between the given value and the integer\n\
    \    -- closest to it.\n    closest, _ = math.modf(abs(tonumber(int_value) - int_value))\n\
    \  end\n  -- If we are rounding away from zero, round the closest integer.\n \
    \ if closest < 0 then\n    closest = 1\n  end\n  -- Return the closest integer.\n\
    \  return closest\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7j9_ox7i.lua:37:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp7j9_ox7i.lua:37: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ closest\n    local values = {}\n    for _, i in ipairs(string.gmatch(value,\
    \ \"%d*$\") do table.insert(values, i) end)\n    \n    local minimum = math.min(values)\n\
    \    local maximum = math.max(values)\n    if minimum == maximum then return 0\
    \ end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpyww82b1s.lua:17: ')' expected near 'do'\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local closest\n\
    \  local delta = tonumber(value) - tonumber(closest)\n  if delta < 0 then\n  \
    \  closest = \"-\"..closest\n  else\n    closest = \"+\"..closest\n  end\n  if\
    \ delta < 0.5 then\n    return tonumber(closest .. \"+0\")\n  elseif delta >=\
    \ 0.5 then\n    return tonumber(closest .. \"-0)\")\n  else\n    -- The number\
    \ is equidistant to two other numbers, round it away from zero.\n    local closest\
    \ = tonumber(closest)\n    local toAdd = 0.5\n    while tonumber(closest + toAdd)\
    \ ~= closest do\n      toAdd = toAdd + 0.5\n    end\n    return tonumber(closest\
    \ + toAdd)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpnixgoc11.lua:16:\
    \ attempt to perform arithmetic on a nil value\nstack traceback:\n\t/tmp/tmpnixgoc11.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpnixgoc11.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal int1\
    \ = tonumber(value)\n\tlocal int2 = tonumber(value)\n\tlocal diff1 = int1 - int2\n\
    \tlocal diff2 = int2 - int1\n\tlocal rounded = round(diff1 / diff2)\n\tif rounded\
    \ ~= int1 then\n\t\treturn rounded\n\telse\n\t\treturn int1\n\tend\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpuyhiwarv.lua:19:\
    \ attempt to call a nil value (global 'round')\nstack traceback:\n\t/tmp/tmpuyhiwarv.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmpuyhiwarv.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then return nil end\n  local num = tonumber(value)\n  local divisor =\
    \ 2\n  -- First try an exact match\n  if num == 0 then\n    return 0\n  end\n\
    \  -- Next try a non-exact match\n  while true do\n    local next_divisor = divisor\n\
    \    while next_divisor ~= 0 do\n      num = num / next_divisor\n      if not\
    \ num then break end\n      next_divisor = next_divisor + 1\n    end\n    -- Now\
    \ try a number divisible by two\n    if tonumber(string.format(\"%.f\", num))\
    \ % 2 == 0 then\n      num = num + 1\n      if tonumber(string.format(\"%.f\"\
    , num)) % 2 == 0 then\n        divisor = divisor + 1\n      end\n    end\n  end\n\
    \  -- Now return the integer value nearest the original value\n  return tonumber(string.format(\"\
    %.f\", num))\nend\nreturn closest_integer\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpufmsc57b.lua:42: <eof> expected near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n   local closest_val\
    \ = value\n   if closest_val == 0 then\n      return 0\n   end\n   local is_odd\
    \ = math.floor(value / 2.0) == value\n   if is_odd then\n      return math.floor(value\
    \ / 2.0)\n   else\n      local is_even = math.floor(value / 2.0) == 0\n      if\
    \ is_even then\n         return math.floor(value / 2.0)\n      else\n        \
    \ return math.ceil(value)\n      end\n   end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp42qp8u6z.lua:37:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp42qp8u6z.lua:37: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local difference\
    \ = math.abs(value - math.floor(value + 0.5))\n  local closest_integer = math.floor(value\
    \ + 0.5)\n  if difference <= 0.5 then\n    return closest_integer\n  else\n  \
    \  return closest_integer - 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3b7qpnqn.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3b7qpnqn.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- If\
    \ the value is zero or the value is below zero, return zero.\n    if value ==\
    \ 0 or value < 0 then\n        return 0\n    end\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpol394twu.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = math.abs(value - math.floor(value))\n    if value == math.floor(value)\
    \ then\n        return value -- This is the same as the closest integer.\n   \
    \ elseif difference <= .5 then\n        return math.floor(value)\n    elseif difference\
    \ >= 1 then\n        return math.ceil(value)\n    else\n        -- The number\
    \ is far from two integers, round it away from zero.\n        return math.floor(value)\
    \ + math.ceil(value) / 2\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7wq8rl8p.lua:32:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp7wq8rl8p.lua:32: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\t-- Create\
    \ a function to round to the nearest integer.\n\tlocal function round_away_from_zero(v)\n\
    \t\treturn math.floor(value + 0.5)\n\tend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_pt145q2.lua:30: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ factor\n    local max\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpmgeqkju6.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal function\
    \ distance(x, y)\n\t\treturn math.abs(x - y)\n\tend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1ttn6b9u.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local int_value\
    \ = tonumber(value)\n  local delta\n  if int_value == nil then\n    ngx.log(ngx.DEBUG,\
    \ \"No valid integer value found in value '\" ..\n      value .. \"'\")\n    return\
    \ value\n  elseif int_value < 0 then\n    delta = 1\n  else\n    delta = math.abs(int_value)\
    \ ^ 2\n  end\n  if delta == 0 then\n    ngx.log(ngx.DEBUG, \"Nearby integers are\
    \ equidistant\")\n    return int_value\n  else\n    local div = delta\n    local\
    \ rem = math.floor(int_value / div)\n    local closest_int\n    while div > 1\
    \ do\n      div = div / 2\n      rem = math.floor(rem / 2)\n      if rem == 0\
    \ then\n        closest_int = div\n        break\n      end\n    end\n    return\
    \ closest_int + rem\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnf3rpxrz.lua:48:\
    \ expected: 10, actual: 50\nstack traceback:\n\t/tmp/tmpnf3rpxrz.lua:48: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal function\
    \ closest(num, max)\n\t\tif num == nil then return nil end\n\t\tif num == max\
    \ then return num end\n\t\tif num > max then return nil end\n\t\tlocal m = math.floor(num\
    \ / max)\n\t\tif m == num then\n\t\t\treturn max\n\t\telseif m > num then\n\t\t\
    \treturn closest(max, num)\n\t\telseif m == num - 1 then\n\t\t\treturn num\n\t\
    \tend\n\t\treturn closest(m, max)\n\tend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpc1qeqe3i.lua:40: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local result\
    \ = tonumber(value)\n  if tonumber(result) then\n    if result > 0 and tonumber(result)\
    \ == result then\n      result = tonumber(result)\n    else\n      -- If the given\
    \ number is equidistant from two integers, return the\n      -- one that is farthest\
    \ from zero.\n      local difference = abs(result - tonumber(value))\n      for\
    \ i=1, #integers do\n        local current_difference = abs(tonumber(integers[i])\
    \ - result)\n        if current_difference > difference then\n          difference\
    \ = current_difference\n          result = tonumber(integers[i])\n        end\n\
    \      end\n    end\n  else\n    error(\"Unable to parse number as number.\")\n\
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsjuycb75.lua:45: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.max(math.floor(value),\
    \ math.ceil(value))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpebcik3z5.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpebcik3z5.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ difference = value - tonumber(value)\n    if difference == 0 then\n        return\
    \ tonumber(value)\n    end\n    if difference < 0 then\n        return tonumber(value)\
    \ + 1\n    end\n    return tonumber(value)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0wy6h8xk.lua:29:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp0wy6h8xk.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local diff\
    \ = value - closest_integer(math.floor(value))\n  if diff < 0 then\n    return\
    \ math.ceil(value)\n  else\n    return math.floor(value)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpr1q12efi.lua:15:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmpr1q12efi.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmpr1q12efi.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmpr1q12efi.lua:15:\
    \ in upvalue 'closest_integer'\n\t/tmp/tmpr1q12efi.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmpr1q12efi.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmpr1q12efi.lua:15:\
    \ in upvalue 'closest_integer'\n\t/tmp/tmpr1q12efi.lua:15: in upvalue 'closest_integer'\n\
    \t/tmp/tmpr1q12efi.lua:15: in upvalue 'closest_integer'\n\t/tmp/tmpr1q12efi.lua:15:\
    \ in upvalue 'closest_integer'\n\t...\n\t/tmp/tmpr1q12efi.lua:15: in local 'candidate'\n\
    \t/tmp/tmpr1q12efi.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.210\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if value\
    \ == nil then\n    return \"nil\"\n  end\n  local pos = tonumber(value)\n  if\
    \ pos ~= nil and math.abs(pos - pos) == 1 then\n    -- If the number is a float\
    \ or double, round it to an integer before\n    -- doing math.abs().\n    pos\
    \ = math.floor(pos)\n  elseif pos ~= nil then\n    -- If its an integer, return\
    \ it if it is equidistant from two integers.\n    local max_dist = #integers -\
    \ 1\n    local max_val = nil\n    for i=1,#integers do\n      if pos - integers[i]\
    \ < max_dist then\n        max_dist = -(pos - integers[i])\n        max_val =\
    \ integers[i]\n      end\n    end\n    return max_val\n  end\n  return \"nil\"\
    \nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpk4m9niuv.lua:25:\
    \ attempt to get length of a nil value (global 'integers')\nstack traceback:\n\
    \t/tmp/tmpk4m9niuv.lua:25: in local 'candidate'\n\t/tmp/tmpk4m9niuv.lua:41: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value\
    \ = tonumber(value)\n  local value_diff = value\n  local i = 1\n  local closest_integer\n\
    \  do\n    closest_integer = tonumber(string.format(\"%.1f\", value_diff))\n \
    \   value_diff = value_diff - closest_integer\n    i = i + 1\n  end\n  while value_diff\
    \ ~= 0 and i >= 2 do\n    value_diff = value_diff - closest_integer\n    i = i\
    \ - 1\n  end\n  return closest_integer\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps8_tb_7w.lua:35:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmps8_tb_7w.lua:35: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local integer\
    \ = 0\n  local is_equidistant = false\n  local diff = 1\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_z_fnj6w.lua:29: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
