name: HumanEval_22_filter_integers
language: lua
prompt: "-- Filter given list of any python values only for integers\n-- >>> filter_integers(['a',\
  \ 3.14, 5])\n-- [5]\n-- >>> filter_integers([1, 2, 3, 'abc', {}, []])\n-- [1, 2,\
  \ 3]\nlocal function filter_integers(values)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_integers\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({4, {}, {},\
  \ 23.2, 9, 'adasd'}), {4, 9})\n    lu.assertEquals(candidate({3, 'c', 3, 3, 'a',\
  \ 'b'}), {3, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  for i, v in ipairs(values) do\n    if type(v) == 'number' and math.floor(v)\
    \ == v then\n      table.insert(values, v)\n    end\n  end\n  return values\n\
    end", "  local results = {}\n  for _, value in ipairs(values) do\n    if type(value)\
    \ ~= 'number' then\n      table.insert(results, value)\n    end\n  end\n  return\
    \ results\nend", "  return values:filter(function(value)\n    if type(value) ~=\
    \ 'number' then return true end\n    return math.floor(value) == value\n  end)\n\
    end", "   if type(values) == 'table' then\n      values = terralib.newlist()\n\
    \      for _, v in pairs(values) do\n         if type(v) ~= 'number' then break\
    \ end\n         values.insert(v)\n      end\n   end\n   return values\nend", " \
    \ return function(i)\n    for i, v in ipairs(values) do\n      if not v:is_number()\
    \ then\n        return nil\n      end\n    end\n    return values\n  end\nend",
  "  for _, v in ipairs(values) do\n    if type(v) == 'number' then\n      if not\
    \ v then\n        -- empty values\n      elseif v == math.floor(v) then\n    \
    \    -- integers\n      else\n        -- floats\n      end\n    end\n  end\n \
    \ return values\nend", "  return function (value)\n    if type(value) ~= 'number'\
    \ then return value end\n    local str = tostring(value)\n    return str:gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d',\n\
    \      function (c)\n        return c:byte() >= 48 and c:byte() <= 57\n      end)\n\
    \  end\nend", "  return values:filter(function(value) return tonumber(value) end)\n\
    end", "    return values.filter(function(value) return type(value) == 'number'\
    \ end)\nend", "  local filtered = {}\n  for _, v in pairs(values) do\n    if type(v)\
    \ == 'number' and math.floor(v) == v then\n      table.insert(filtered, v)\n \
    \   end\n  end\n  return filtered\nend", "  if values then\n    local result\n\
    \    for _, value in ipairs(values) do\n      if type(value) ~= 'number' then\n\
    \        return nil\n      end\n      if math.floor(value) == value then\n   \
    \     result[#result + 1] = value\n      end\n    end\n    return result\n  else\n\
    \    return values\n  end\nend", "  if type(values) == 'table' then\n    local\
    \ count = 0\n    values = { [unpack(values)] }\n    for _, v in pairs(values)\
    \ do\n      count = count + 1\n      if type(v) == 'number' then\n        values[count]\
    \ = v\n      end\n    end\n    if count == 1 then\n      return values[1]\n  \
    \  else\n      return values\n    end\n  else\n    return values\n  end\nend",
  "  for _, v in ipairs(values) do\n    if type(v) ~= 'number' then\n      return\
    \ nil\n    end\n    if type(v) == 'number' then\n      if math.floor(v) == v then\n\
    \        values.remove(v)\n      end\n    end\n  end\n  return values\nend", " \
    \ local filter\n  if type(values) == 'table' then\n    local filtered = {}\n \
    \   for k, v in pairs(values) do\n      if type(v) == 'number' and math.floor(v)\
    \ == v then\n        table.insert(filtered, v)\n      end\n    end\n    return\
    \ filtered\n  elseif type(values) == 'string' then\n    local converted = {}\n\
    \    for v in values:gmatch('%d*') do\n      table.insert(converted, tonumber(v))\n\
    \    end\n    return converted\n  else\n    return values\n  end\nend", "  return\
    \ filter(values, type(v):_isint and v ~= nil)\nend", "    local result = {}\n\
    \    for _, value in pairs(values) do\n        if type(value) == 'number' then\n\
    \            table.insert(result, value)\n        end\n    end\n    return result\n\
    end", "  local ret = {}\n  for i, v in ipairs(values) do\n    if type(v) == 'number'\
    \ then\n      ret[#ret + 1] = v\n    end\n  end\n  return ret\nend", "  local\
    \ res = {}\n  for _, value in ipairs(values) do\n    if type(value) ~= 'number'\
    \ then\n      table.insert(res, value)\n    end\n  end\n  return res\nend", " \
    \ return filter(values, _is_integer)\nend", "  return table.filter(values, math.type.isinteger)\n\
    end", "  local result = {}\n  for _, value in pairs(values) do\n    -- Check if\
    \ value is an integer\n    if type(value) == 'number' and math.floor(value) ==\
    \ value then\n      result[#result + 1] = value\n    end\n  end\n  return result\n\
    end", "  local output = {}\n  for _, value in pairs(values) do\n    local is_int\
    \ = type(value) == \"number\" and tostring(value) == tostring(value) and value\
    \ % 1 == 0\n    if is_int then\n      table.insert(output, value)\n    end\n \
    \ end\n  return output\nend", "  values = values.filter(function(v)\n    return\
    \ type(v) == 'number'\n  end)\n  values = values.filter( function(v)\n    return\
    \ v ~= nil\n  end)\n  values = values.filter( function(v)\n    return v ~= false\n\
    \  end)\n  return values\nend", "  return function(_, i, v)\n    if not (type(v)\
    \ == 'number') then\n      return false\n    end\n    if type(v) == 'number' and\
    \ i ~= 0 then\n      return false\n    end\n    return true\n  end\nend", "  return\
    \ values.filter(function(x) return type(x) == 'number' and x >= 0 and x <= math.floor(x\
    \ * 100) end)\nend", "  if type(values) ~= 'table' then\n    return values\n \
    \ end\n  local result = {}\n  for _, value in ipairs(values) do\n    if type(value)\
    \ == 'number' then\n      result[#result + 1] = value\n    end\n  end\n  return\
    \ result\nend", "  local rv = {}\n  for _, value in pairs(values) do\n    if type(value)\
    \ == 'number' then\n      rv[#rv + 1] = value\n    end\n  end\n  return rv\nend",
  "  local function filter_function(value)\n    local is_integer, is_integer = tonumber(value),\
    \ tonumber(value)\n    if is_integer and is_integer == value\n    then\n     \
    \ local ok\n      local function is_nil_function(value)\n        return value\
    \ == nil or value == false or value == 0 or value == false\n      end", "  local\
    \ values = values:map(function(x)\n      if type(x) == 'number' then\n       \
    \ return x:floor()\n      else\n        return x\n      end\n    end)", "  return\
    \ filter(values, is_integer)\nend", "   if type(values) ~= 'table' then\n    \
    \  values = values.values\n   end\n   local newValues = {}\n   for k, v in pairs(values)\
    \ do\n      if type(v) == 'number' and math.floor(v) == v then\n         newValues[k]\
    \ = v\n      end\n   end\n   return newValues\nend", "  return map(function (value)\
    \ return tonumber(value) end, values)\nend", "  local value_list = values:map(function(value)\
    \ return type(value) ~= 'table' and tointeger(value) or value end)\n  return filter(value_list,\
    \ function(value) return value == value end)\nend", "  local result = {}\n  for\
    \ _, v in ipairs(values) do\n    if type(v) ~= 'number' then\n      result[#result+1]\
    \ = v\n    end\n  end\n  return result\nend", "  return function(value) return\
    \ tonumber(value) ~= nil end\nend", "  return filter(function(x) return x == x\
    \ and tostring(x) == 'number' end, values)\nend", "  return function (value)\n\
    \    if type(value) == 'number' and type(value) ~= 'boolean' then\n      return\
    \ value\n    end\n  end\nend\n</code>\n<|/ a dscore=4 tags=lua |>\n<| c |>\n\"\
    A local function declaration creates a new function.\" -- This is not true, see\
    \ [this answer](http://stackoverflow.com/a/14903770/445375)\n<|/ c |>\n<| a dscore=4\
    \ tags=lua |>\nLua has an ability to create closures, which is essentially what\
    \ you're talking about. The difference is that local functions are local to the\
    \ enclosing scope, so they cannot access variables in the enclosing scope. You\
    \ can also create local variables. So while you can get \"local\" function variables,\
    \ local variables can never be accessed from within the closure.\n<|/ a |>\n<|\
    \ c |>\nYou mean that `function x()` is a function that can access `x`, while\
    \ `local function x()` is a function that cannot access `x`.\n<|/ c |>\n<| c |>\n\
    That's exactly what I meant. But it wasn't clear enough; I've edited it.\n<|/\
    \ c |>\n<| a tags=lua dscore=3 |>\nLocal variables cannot be accessed from within\
    \ a closure (i.e. function) because the local variables exist only in the scope\
    \ of the local function. The only way around this would be to create an anonymous\
    \ local function that closes over your local variables. However, this does not\
    \ make sense in most cases, since anonymous functions are slow to create in Lua.\
    \ Having said this, if you are a perfectionist, you can use local variables inside\
    \ a closure:\n<code>", "    local out = terralib.newlist()\n    for i, value in\
    \ ipairs(values) do\n        if type(tostring(value)) ~= \"number\" then\n   \
    \         table.insert(out, value)\n        elseif value == tostring(value) then\n\
    \            table.insert(out, value)\n        end\n    end\n    return out\n\
    end", "  local result\n  for _, value in ipairs(values) do\n    if type(value)\
    \ ~= 'number' then\n      table.insert(result, value)\n    end\n  end\n  return\
    \ result\nend", "  for i, value in ipairs(values) do\n    if not type(value) ==\
    \ \"number\" then return false end\n    if value % 1 == 0 then return false end\n\
    \  end\n  return values\nend", "  local filtered_values = terralib.newlist()\n\
    \  for _, value in ipairs(values) do\n    if not rawget(value, \"__iter__\") then\n\
    \      filtered_values:insert(value)\n    else\n      filtered_values = filtered_values:concat(filter_integers(value))\n\
    \    end\n  end\n  return filtered_values\nend", "    if type(values) ~= 'table'\
    \ then\n        values = {values}\n    end\n    local value\n    for _, value\
    \ in ipairs(values) do\n        if type(value) ~= 'number' then\n            values[#values]\
    \ = value\n        end\n    end\n    return values\nend", "  local new = {}\n\
    \  for _, v in pairs(values) do\n    if type(v) == 'number' then\n      table.insert(new,\
    \ v)\n    end\n  end\n  return new\nend", "  local value\n  for _, value in pairs(values)\
    \ do\n    if not type(value) == \"number\" then\n      table.insert(values, value)\n\
    \    end\n  end\n  return values\nend", "  local results = {}\n  for i, v in ipairs(values)\
    \ do\n    if type(v) == 'number' then\n      table.insert(results, v)\n    end\n\
    \  end\n  return results\nend", "  local n = 1\n  local filtered = {}\n  for _,\
    \ value in pairs(values) do\n    if type(value) == \"number\" then\n      if n\
    \ == 1 then\n        table.insert(filtered, value)\n      else\n        table.insert(filtered,\n\
    \                      math.floor((n / 100) * value) + (n % 100) / 10)\n     \
    \ end\n      n = n + 1\n    end\n  end\n  return filtered\nend", "  -- Note: This\
    \ assumes lists with only integer or nil values are filtered out.\n  local filtered\
    \ = {}\n  for _, value in ipairs(values) do\n    if type(value) ~= 'number' then\
    \ return nil end\n    if value == value then filtered[#filtered + 1] = value\n\
    \    else return nil end\n  end\n  return filtered\nend", "  return function(...)\n\
    \    local _ = {...}\n    local ok = true\n    for _, value in ipairs(values)\
    \ do\n      if type(value) ~= 'number' or math.floor(value) ~= value then\n  \
    \      ok = false\n        break\n      end\n    end\n    if ok then\n      return\
    \ _\n    end\n    return nil\n  end\nend", "  local result\n  local index = -1\n\
    \  for index, value in ipairs(values) do\n    if type(value) == 'number' then\n\
    \      if value == value then\n        table.insert(result, value)\n      end\n\
    \    end\n  end\n  return result\nend", "  local ret = {}\n  for i, v in ipairs(values)\
    \ do\n    if type(v) ~= 'number' then\n      ret[#ret + 1] = v\n    end\n  end\n\
    \  return ret\nend", "  return table.filter(values, function(value)\n    local\
    \ t = type(value)\n    return t == 'number' or t == 'boolean' or t == 'string'\n\
    \  end)\nend", "  local ret = {}\n  for v in values do\n    if type(v) == 'number'\
    \ then\n      table.insert(ret, v)\n    end\n  end\n  return ret\nend", "  local\
    \ filtered = {}\n  for _, value in ipairs(values) do\n    if not value_in_integer_range(value)\
    \ then break end -- no integer\n    table.insert(filtered, value)\n  end\n  return\
    \ filtered\nend", "  local results = {}\n  for _, value in pairs(values) do\n\
    \    if type(value) == 'number' and isinteger(value) then\n      table.insert(results,\
    \ value)\n    end\n  end\n  return results\nend", "  local nvalues = #values\n\
    \  if nvalues < 1 then return nil end\n  local n\n  -- Make sure every value is\
    \ a number\n  -- Also handle single values as an integer\n  for i = 1, nvalues\
    \ do\n    local value = tonumber(values[i])\n    if not value then\n      -- Value\
    \ could not be converted to a number so filter it out\n      values.remove(values[i])\n\
    \      nvalues = nvalues - 1\n    end\n  end\n  -- Filter out any numbers that\
    \ are not integers\n  -- Convert every value to an integer to compare it to n\n\
    \  -- This is necessary for filter functions to work\n  n = nvalues\n  local i\
    \ = 0\n  while i < nvalues do\n    local value = tonumber(values[i])\n    if not\
    \ value then\n      values.remove(values[i])\n      n = nvalues - 1\n    end\n\
    \    i = i + 1\n  end\n  if nvalues > 0 then\n    -- Return the new list of filtered\
    \ values\n    return values\n  else\n    -- No values so return the original list\n\
    \    return nil\n  end\nend", "  return table.filter(values, function(value)\n\
    \    if type(value) ~= 'number' then return false end\n    return not math.isnan(value)\n\
    \  end)\nend", "  return type(values[1]) == 'table' and #values[1] == 0 and values[1]\
    \ or values\nend", "  local result = {}\n  for _, value in pairs(values) do\n\
    \    if type(value) == 'number' then\n      if math.floor(value) == value then\n\
    \        result[#result + 1] = value\n      end\n    end\n  end\n  return result\n\
    end", "  if type(values) ~= 'table' then\n    values = tolist(values)\n  end",
  "    if type(values) ~= 'table' then\n        return values or {}\n    end\n   \
    \ local filtered_values = {}\n    for key, value in pairs(values) do\n       \
    \ if type(key) == 'number' then\n            if key % 1 ~= 0 then\n          \
    \      filtered_values[key] = value\n            end\n        end\n    end\n \
    \   return filtered_values\nend", "  if type(values) ~= 'table' then return values\
    \ end\n  local new = {}\n  for _, value in pairs(values) do\n    if not type(tostring(value))\
    \ ~= 'number' then new[#new + 1] = value end\n  end\n  return new\nend", "  return\
    \ data.filter(\n    function(value) return type(value) == 'number' and isinteger(value)\
    \ end,\n    values\n  )\nend", "  local function helper(value)\n    if type(value)\
    \ ~= 'number' then return value end\n    local t = type(value)\n    return t ==\
    \ 'string' and t:match('integer') or\n      (t == 'number' and type(value) ==\
    \ t and math.floor(value) == value)\n  end\n  return table.filter(values, helper)\n\
    end", "  for _, value in ipairs(values) do\n    if type(value) == 'number' then\n\
    \      -- We don't consider non integers\n      -- >>> filter_integers([1, 'a',\
    \ 3.14, 5])\n      -- [1, 3.14]\n      -- >>> filter_integers([1, 'a', 3.14, 5],\
    \ _)\n      -- [1]\n      -- >>> filter_integers([1, 'a', 3.14, 5], 'a')\n   \
    \   -- [1, 3.14]\n      -- >>> filter_integers([1, 'a', 3.14, 5], 3.14)\n    \
    \  -- [1, 3.14]\n      -- >>> filter_integers([1, 'a', 3.14, 5], 2)\n      --\
    \ []\n      -- >>> filter_integers([2, 'a', 3.14, 5], 3.14)\n      -- [2]\n  \
    \    -- >>> filter_integers([1, 'a', 3.14, 5], [1, 'a', 3.14, 5] or {})\n    \
    \  -- [1]\n      -- >>> filter_integers([1, 'a', 3.14, 5], [1, 'a', 3.14, 5] or\
    \ {}, 1)\n      -- [1]\n      -- >>> filter_integers([1, 'a', 3.14, 5], [1, 'a',\
    \ 3.14, 5] or {}, 2)\n      -- [1]\n      if value == value then\n        -- Return\
    \ the value\n        return value\n      end\n    end\n  end\n  return nil\nend",
  "    local filtered = {}\n    for v in values do\n        if type(v) == 'number'\
    \ and v >= 0 then\n            table.insert(filtered, v)\n        end\n    end\n\
    \    return filtered\nend", "  if type(values) ~= 'table' then\n    error('Values\
    \ is not a table')\n  end\n  local filtered = {}\n  local i = 1\n  while i <=\
    \ #values do\n    local value = tonumber(values[i])\n    if type(value) == 'number'\
    \ and value ~= nil then\n      table.insert(filtered, value)\n    end\n    i =\
    \ i + 1\n  end\n  return filtered\nend", "    local function is_integer(value)\n\
    \        return type(value) == \"number\" and math.floor(value) == value\n   \
    \ end", "  local new_values = {}\n  for _, v in ipairs(values) do\n    if type(v)\
    \ == \"number\" and not v:is_float() then\n      new_values[#new_values + 1] =\
    \ v\n    end\n  end\n  return new_values\nend", "    local output = {}\n    for\
    \ _, value in ipairs(values) do\n        if type(value) == 'number' and math.isinteger(value)\
    \ then\n            table.insert(output, value)\n        end\n    end\n    return\
    \ output\nend", "  local function integer(x)\n    return type(x) == 'number' and\
    \ math.floor(x) == x\n  end\n  return values.filter(integer)\nend", "  local result\n\
    \  local value = values[0]\n  if type(value) == \"number\" then\n    if value\
    \ == math.floor(value) then\n      result = {value}\n      value = \"\"\n    else\n\
    \      result = {value}\n    end\n  elseif type(value) == \"table\" then\n   \
    \ -- If the value is a table of integers, return it\n    -- otherwise return the\
    \ original value.\n    if next(value) == nil then\n      result = {value}\n  \
    \  else\n      result = {value}\n    end\n  else\n    -- If the value is a string,\
    \ split it up on commas, then\n    -- convert to integers and return them.\n \
    \   if type(value) == \"string\" then\n      local items = {}\n      for item\
    \ in value:gmatch(\"([^,]+)\") do\n        items[#items + 1] = tointeger(item)\n\
    \      end\n      result = items\n    end\n  end\n  return result\nend", "  local\
    \ value_type = type(_G.type) -- We use _G.type to get the type from the global\
    \ environment.\n  if value_type ~= 'table' then return values end\n  -- filter\
    \ out empty table entries\n  local res = {}\n  for _,v in ipairs(values) do\n\
    \    if type(v) ~= 'table' then res[#res+1] = v; continue end\n    local count\
    \ = 0\n    for _,v2 in ipairs(v) do\n      count = count + 1\n      if type(_G.type)\
    \ ~= 'number' then res[#res+1] = v; break; end\n      if type(_G.type) == 'number'\
    \ then\n        -- The filter function should accept only integers\n        if\
    \ _G.type(v2) ~= 'number' then res[#res+1] = v; break; end\n      end\n    end\n\
    \    if count == 0 then res[#res+1] = v; end -- Skip empty table entries\n  end\n\
    \  return res\nend", "    return values:filter(function(value) return type(value)\
    \ == \"integer\" end)\nend", "  local results = {}\n  for i, v in pairs(values)\
    \ do\n    if type(v) == 'number' then\n      results[i] = v\n    end\n  end\n\
    \  return results\nend", "  local results = {}\n  for _, value in ipairs(values)\
    \ do\n    if type(value) ~= 'number' then break end -- non-numeric values cannot\
    \ be compared for equality\n    table.insert(results, value)\n  end\n  return\
    \ results\nend", "  return values.filter(function(value)\n    return type(value)\
    \ == \"number\"\n  end)\nend", "  if type(values) == 'table' then\n    local filtered_values\
    \ = {}\n    for k, v in pairs(values) do\n      if type(v) == 'number' and v ==\
    \ v then\n        table.insert(filtered_values, v)\n      else\n        -- FIXME:\
    \ this should be the error\n        -- raise AssertionError(string.format('Invalid\
    \ python value for filter %s in %s', k, v))\n      end\n    end\n    return filtered_values\n\
    \  else\n    return values\n  end\nend", "  return function(v)\n    if type(v)\
    \ == 'number' then\n      v = tonumber(v)\n    end\n    for _, item in pairs(values)\
    \ do\n      if type(item) == 'number' then\n        if v == item then\n      \
    \    return nil\n        end\n      end\n    end\n    return v\n  end\nend", " \
    \ -- Fast path: avoid conversion since we have constant or very small numbers\n\
    \  if #values <= 1 then\n    return values\n  end", "  local ok, v\n  for _, v\
    \ in ipairs(values) do\n    if type(v) ~= 'number' then\n      ok = false\n  \
    \    break\n    end\n    if v ~= v then -- NaN cannot be compared with any value\n\
    \      ok = false\n      break\n    end\n    if v <= 0 then -- Negative integers\
    \ cannot be compared without NaN check\n      ok = false\n      break\n    end\n\
    \  end\n  return ok and values or nil\nend", "    local result\n    for _, value\
    \ in pairs(values) do\n        if type(value) == 'number' then\n            table.insert(result,\
    \ value)\n        end\n    end\n    return result\nend", "  local filtered = {}\n\
    \  for _, value in ipairs(values) do\n    local is_integer = tonumber(value) ~=\
    \ nil\n    if is_integer and value ~= value then\n      error('\"integer\" argument\
    \ must be an integer value', 2)\n    end\n    if not is_integer then\n      filtered[#filtered\
    \ + 1] = value\n    end\n  end\n  return filtered\nend", "  return function()\n\
    \    for i, v in ipairs(values) do\n      if type(v) == 'number' and math.floor(v)\
    \ == v then\n        table.insert(values, i)\n      end\n    end\n    return values\n\
    \  end\nend", "  return table.filter(\n    function(value) type(value) == 'number'\
    \ and\n      math.floor(value) == value and\n      math.floor(value) == value\
    \ and\n      not math.floor(value) == value and\n      not math.floor(value) ==\
    \ value,\n    values)\nend", "  return filter(values, function(value)\n    return\
    \ type(value) == \"number\" and math.floor(value) == value\n  end)\nend", "  \
    \  local filterd = {}\n    for _, v in ipairs(values) do\n        if type(v) ~=\
    \ 'number' then\n            table.insert(filterd, v)\n        elseif math.floor(v)\
    \ == v then\n            table.insert(filterd, v)\n        end\n    end\n    return\
    \ filterd\nend", "  return filter(\n    function(value)\n      return type(value)\
    \ == \"number\" and type(value) ~= 'boolean'\n    end, values\n  )\nend", "  return\
    \ filter(function(val) return type(val) == 'number' end,\n    values)\nend", " \
    \ local results = {}\n  for _, v in pairs(values) do\n    local result = type(v)\
    \ == 'number' and math.floor(v) or v\n    if result ~= v then\n      results[#results\
    \ + 1] = result\n    end\n  end\n  return results\nend", "  return filter(function(value)\n\
    \    return type(value) == 'integer'\n  end, values)\nend", "  local results =\
    \ {}\n  for i = 1, #values do\n    local value = tonumber(values[i])\n    if value\
    \ ~= nil then\n      table.insert(results, value)\n    end\n  end\n  return results\n\
    end", "  local results = {}\n  for _, value in pairs(values) do\n    if type(value)\
    \ == 'number' and math.floor(value) == value then\n      table.insert(results,\
    \ value)\n    end\n  end\n  return results\nend", "  if type(values) ~= 'table'\
    \ then return values end\n  local new_values = {}\n  for i = 1, #values do\n \
    \   local value = tonumber(values[i])\n    if type(value) == 'number' and math.floor(value)\
    \ == value then\n      new_values[#new_values + 1] = values[i]\n    end\n  end\n\
    \  return new_values\nend", "  for _, value in pairs(values) do\n    if type(value)\
    \ ~= 'number' then break end\n    if value ~= math.floor(value) then break end\n\
    \  end\n  return values\nend", "  local newValues = {}\n  for _, value in pairs(values)\
    \ do\n    if type(value) == \"number\" then\n      table.insert(newValues, value)\n\
    \    end\n  end\n  return newValues\nend", "  local new_values = {}\n  for _,v\
    \ in ipairs(values) do\n    if type(v) == 'number' then\n      if type(v) == 'integer'\
    \ then\n        new_values[#new_values+1] = v\n      else\n        error(string.format('%s\
    \ is not integer', v))\n      end\n    end\n  end\n  return new_values\nend",
  "  local result = {}\n  for _, value in pairs(values) do\n    if type(value) ~=\
    \ 'number' then\n      table.insert(result, value)\n    end\n  end\n  return result\n\
    end", "  if type(values) == 'table' then\n    return values.select(function(value)\
    \ return type(value) == types.integer end)\n  else\n    return values\n  end\n\
    end", "  local filtered = {}\n  for _, v in ipairs(values) do\n    if type(v)\
    \ == 'number' then\n      table.insert(filtered, v)\n    end\n  end\n  return\
    \ filtered\nend", "  return table.filter(values, is_integer)\nend", "    local\
    \ results = {}\n    for _, value in ipairs(values) do\n        if type(value ~=\
    \ 'number') or value ~= tonumber(value) then break end\n        results[#results\
    \ + 1] = value\n    end\n    return results\nend", "    local newValues = {}\n\
    \    for i, v in ipairs(values) do\n        if type(v) == 'number' then\n    \
    \        table.insert(newValues, v)\n        else\n            -- don't filter\
    \ the table if any value can be coerced to nil\n            table.insert(newValues,\
    \ v)\n        end\n    end\n    return newValues\nend", "    local i = 1\n   \
    \ local value\n    while i <= #values do\n        value = tonumber(values[i -\
    \ 1])\n        if value == nil then\n            break\n        end\n        if\
    \ type(value) == 'number' and math.floor(value) == value then\n            table.insert(values,\
    \ value)\n        end\n        i = i + 1\n    end\n    return values\nend", " \
    \ return setmetatable(values, {\n    __index = function(self, key)\n      return\
    \ tonumber(key)\n    end,\n    __newindex = function(self, key, value)\n     \
    \ error(\"cannot set a numeric value in a non-numeric table\")\n    end\n  })\n\
    end", "  values = values or {}\n  for k, v in pairs(values) do\n    if type(v)\
    \ == 'number' and v >= 0 then\n      values[v] = true\n    end\n  end\n  values\
    \ = values(values())\n  return values\nend", "  local new = {}\n  for _, value\
    \ in pairs(values) do\n    if type(value) == 'number' then\n      table.insert(new,\
    \ value)\n    end\n  end\n  return new\nend", "  local result = {}\n  for _, value\
    \ in ipairs(values) do\n    if type(value) == 'number' then\n      if math.floor(value)\
    \ == value then\n        result[#result + 1] = value\n      end\n    elseif type(value)\
    \ == 'string' then\n      -- This is probably a numeric value that happens to\
    \ contain a comma\n      -- or a hyphen.  Just ignore it.\n      if ',' == value\
    \ or value == '-' then\n        result[#result + 1] = value\n      end\n    end\n\
    \  end\n  return result\nend", "    local filter = {}\n    for i, v in ipairs(values)\
    \ do\n        if type(v) == 'number' then\n            table.insert(filter, v)\n\
    \        end\n    end\n    return filter\nend", "  local results = {}\n  for _,\
    \ v in ipairs(values) do\n    if not (type(v) == 'number') and type(v) ~= 'boolean'\
    \ then\n      results[#results + 1] = v\n    end\n  end\n  return results\nend",
  "  local filtered_values = {}\n  for _, value in pairs(values) do\n    if not type(value)\
    \ == 'number' then\n      filtered_values[#filtered_values + 1] = value\n    end\n\
    \  end\n  return filtered_values\nend", "  values = values.filter(function (value)\n\
    \    return type(value) == 'number' and math.floor(value) == value\n  end)\n \
    \ return values\nend", "    local new_values = {}\n    for i, v in pairs(values)\
    \ do\n        if type(v) == 'number' and math.floor(v) == v then\n           \
    \ new_values[i] = v\n        end\n    end\n    return new_values\nend", "  return\
    \ values.filter(function(value)\n    return type(value) == 'number' and isinteger(value)\n\
    \  end)\nend", "  if type(values) ~= 'table' then return values end\n  values\
    \ = unpack(values)\n  if type(values[1]) ~= 'number' then return values end\n\
    \  return values.filterfunction(function(v)\n    if type(v) == 'number' then return\
    \ v ~= v end\n  end)\nend", "  local result = {}\n  for i, v in ipairs(values)\
    \ do\n    if type(v) ~= 'number' then -- exclude strings\n      table.insert(result,\
    \ v)\n    end\n  end\n  return result\nend", "  local integers = {}\n  local value_index\
    \ = 1\n  local integer_value", "  if type(values) == 'table' and getmetatable(values).__index\
    \ == 'table' then\n    local results = {}\n    for v in pairs(values) do\n   \
    \   local vtype = type(v)\n      if vtype == 'number' then\n        if floor(v)\
    \ == v then\n          results[#results + 1] = v\n        end\n      elseif vtype\
    \ == 'table' then\n        table.insert(results, filter_integers(v))\n      elseif\
    \ vtype == 'string' then\n        if v:match('^[%a%d]+$') then\n          table.insert(results,\
    \ v)\n        end\n      else\n        table.insert(results, v)\n      end\n \
    \   end\n    return results\n  end\n  return values\nend", "  for _, v in ipairs(values)\
    \ do\n    if type(v) == 'number' and math.floor(v) == v then\n      return v\n\
    \    end\n  end\n  return nil\nend", "  values = values or {}\n  local filtered_values\
    \ = {}\n  for k in pairs(values) do\n    if type(k) == 'number' then\n      filtered_values[#filtered_values\
    \ + 1] = k\n    end\n  end\n  return filtered_values\nend", "  local new_values\
    \ = {}\n  for _, value in pairs(values) do\n    if not type(value) ~= 'number'\
    \ then\n      new_values[#new_values + 1] = value\n    end\n  end\n  return new_values\n\
    end", "  local out = {}\n  for _, v in ipairs(values) do\n    if type(v) ~= 'number'\
    \ or v ~= math.floor(v) then\n      table.insert(out, v)\n    end\n  end\n  return\
    \ out\nend", "  if type(values) ~= 'table' then\n    return values\n  elseif next(values)\
    \ ~= nil then\n    local next_values = {}\n    for v in pairs(values) do\n   \
    \   if type(v) == 'number' then\n        if v ~= math.floor(v) then\n        \
    \  next_values[#next_values+1] = v\n        end\n      end\n    end\n    return\
    \ filter_integers(next_values)\n  end\nend", "  local list = {}\n  local v = 0",
  "  values = filter(values, is_integer)\n  assert(#values == 0, \"values must be\
    \ a list of only integers\")\n  return values\nend", "  local out = terralib.newlist()\n\
    \  for i, value in ipairs(values) do\n    if type(value) == \"number\" then\n\
    \      if value ~= math.floor(value) then\n        table.insert(out, value)\n\
    \      end\n    end\n  end\n  return out\nend", "  local value\n  local filtered\
    \ = {}\n  for value in pairs(values) do\n    local is_integer = math.floor(value)\
    \ == value\n    if is_integer then\n      table.insert(filtered, value)\n    end\n\
    \  end\n  return filtered\nend", "  local out = terralib.newlist()\n  for _, value\
    \ in ipairs(values) do\n    if type(value) ~= 'number' then\n      out:insert(value)\n\
    \    end\n  end\n  return out\nend", "  return values.filter(function(x)\n   \
    \ return type(x) == 'number' and\n         x >= math.floor(x) and\n         x\
    \ <= math.floor(x+1.0)\n  end)\nend", "  local results = {}\n  for _, value in\
    \ ipairs(values) do\n    if type(value) == 'number' then\n      table.insert(results,\
    \ value)\n    end\n  end\n  return results\nend", "    local results = {}\n  \
    \  local i = #values\n    while i do\n        if tonumber(values[i - 1]) then\n\
    \            results[#results + 1] = values[i - 1]\n        end\n        i = i\
    \ - 1\n    end\n    return results\nend", "  local ret = {}\n  for _,v in pairs(values)\
    \ do\n    if type(v) ~= 'number' then\n      return nil\n    end\n    if type(v)\
    \ ~= 'integer' then\n      return nil\n    end\n    table.insert(ret, v)\n  end\n\
    \  return ret\nend", "  local newvalues = {}\n  for _, v in pairs(values) do\n\
    \    local num = tonumber(v)\n    if num then\n      table.insert(newvalues, num)\n\
    \    end\n  end\n  return newvalues\nend", "  return table.filter(function(value)\
    \ return type(value) == 'number' end,\n    values)\nend", "  -- If there are no\
    \ integers, return an empty list\n  if not values then\n    return []\n  end",
  "  return values:map(function(x) return math.floor(x) end)\nend", "  return filter(values,\
    \ function(value) return type(value) == 'integer' end)\nend", "    local function\
    \ integers(x)\n        if type(x ~= 'number') then return nil end\n        return\
    \ x ~= x and x ~= 0 and x ~= math.floor(x) and x ~= math.ceil(x)\n    end\n  \
    \  return filter(integers, values)\nend", "  local function filter(list, int)\n\
    \    for _, v in pairs(list) do\n      if type(v) == 'number' and int == v then\n\
    \        list[_] = nil\n      end\n    end\n    return list\n  end\n  values =\
    \ filter(values, nil)\n  values = filter(values, false)\n  values = filter(values,\
    \ true)\n  return values\nend", "  local new_values = terralib.newlist()\n  for\
    \ _, v in pairs(values) do\n    if type(v) == \"number\" then\n      new_values:insert(v)\n\
    \    end\n  end\n  return new_values\nend", "  local results = {}\n  for _, value\
    \ in pairs(values) do\n    if type(value) == 'number' then\n      if math.floor(value)\
    \ == value then\n        results[#results + 1] = value\n      end\n    end\n \
    \ end\n  return results\nend", "    local output = {}\n    local idx\n    for\
    \ idx, value in ipairs(values) do\n        if type(value) ~= 'number' then return\
    \ end\n        if math.floor(value) == value then table.insert(output, value)\
    \ end\n    end\n    return output\nend", "  local value\n  for i, value in ipairs(values)\
    \ do\n    if type(value) ~= 'number' then\n      table.insert(values, value)\n\
    \    end\n  end\n  return values\nend", "    local results = {}\n    for value\
    \ in values:\n        if type(results[value]) ~= 'number' then\n            results[value]\
    \ = 0\n        end\n        results[value] = results[value] + 1\n    end\n   \
    \ return results\nend", "  if type({}) == type(values) then\n    local i = 0\n\
    \    for _, v in pairs(values) do\n      if type(v) == 'number' then\n       \
    \ values[i] = v\n        i = i + 1\n      end\n    end\n  end\n  return values\n\
    end", '  local results = {}', "  local function is_integer(value)\n    return\
    \ type(value) == 'number' and math.floor(value) == value\n  end\n  local output\
    \ = values:map(is_integer)\n  return table.concat(output) or nil\nend", "  local\
    \ result = {}\n  for _, value in ipairs(values) do\n    local num = tonumber(value)\n\
    \    if not num then\n      result[#result + 1] = value\n    else\n      result[#result\
    \ + 1] = num\n    end\n  end\n  return result\nend", "  for _, value in ipairs(values)\
    \ do\n    if type(value) ~= 'number' then return false end\n    if math.floor(value)\
    \ == value then return true end\n  end\n  return false\nend", "  local output\
    \ = {}\n  for _, value in pairs(values) do\n    if type(value) ~= 'number' then\n\
    \      output[#output + 1] = value\n    elseif value ~= math.floor(value) then\n\
    \      output[#output + 1] = value\n    end\n  end\n  return output\nend", " \
    \ local out = terralib.newlist()\n  for _, v in pairs(values) do\n    if type(v)\
    \ == \"number\" then\n      if type(v) == \"number\" then\n        if v:floor()\
    \ ~= v then\n          table.insert(out, v)\n        end\n      else\n       \
    \ table.insert(out, v)\n      end\n    end\n  end\n  return out\nend", "  local\
    \ results = {}\n  for _, value in pairs(values) do\n    if type(value) == 'number'\
    \ then\n      table.insert(results, value)\n    end\n  end\n  return results\n\
    end", "  local out = terralib.newlist()\n  for _, v in ipairs(values) do\n   \
    \ if type(v) == \"number\" then\n      if math.floor(v) == v then\n        table.insert(out,\
    \ v)\n      end\n    end\n  end\n  return out\nend", "    local results = {}\n\
    \    for _, v in ipairs(values) do\n        if type(v) == \"number\" then\n  \
    \          results[#results + 1] = v\n        end\n    end\n    return results\n\
    end", "  return unpack(values, 1, math.min(#values, 2))\nend", "  local results\
    \ = {}\n  for _, value in ipairs(values) do\n    local value_as_int = tonumber(value)\n\
    \    if value_as_int then\n      results[#results + 1] = value_as_int\n    end\n\
    \  end\n  return results\nend", "  local value\n  for _, value in pairs(values)\
    \ do\n    if type(value ~= 'number') then\n      break\n    end\n    if math.floor(value)\
    \ == value then\n      table.insert(values, value)\n    end\n  end\n  return values\n\
    end", "    if values ~= nil then\n        local results = {}\n        for _, value\
    \ in ipairs(values) do\n            if type(results[value]) ~= 'number' then\n\
    \                results[value] = true\n            else\n                results[value]\
    \ = results[value] or true\n            end\n        end\n        return unpack(results)\n\
    \    else\n        return nil\n    end\nend", "    if type(values) ~= 'table'\
    \ then\n        local value = {unpack(values)}\n        if type(unpack(values))\
    \ == 'table' then\n            return values\n        end\n    end", "  if type(values)\
    \ == \"table\" then\n    local new_values = {}\n    for k, v in pairs(values)\
    \ do\n      if type(k) == \"number\" then\n        if math.floor(k) == k then\n\
    \          new_values[k] = v\n        end\n      else\n        new_values[v] =\
    \ true\n      end\n    end\n    return new_values\n  end\n  \n  return values\n\
    end", "  return values.filter(function(value) return type(value) == type(0) end)\n\
    end", "    if values then\n        for _, v in ipairs(values) do\n           \
    \ if type(v) == 'number' then\n                values[v] = nil\n            end\n\
    \        end\n    end\n    return values\nend", "   local results = {}\n   for\
    \ _, v in pairs(values) do\n      if type(v) == 'number' and (v >= 0) and (v <=\
    \ math.floor(v)) then\n         table.insert(results, v)\n      end\n   end\n\
    \   return results\nend", "  local new_values = {}\n  for _, v in ipairs(values)\
    \ do\n    local is_integer = type(v) == 'number' and v % 1 == 0\n    new_values[is_integer]\
    \ = new_values[is_integer] and v\n  end\n  return new_values\nend", "  local value\n\
    \  for _, value in pairs(values) do\n    if type(value) == 'number' then\n   \
    \   values[value] = nil\n    end\n  end\n  return values\nend", "  local rv =\
    \ {}\n  for _, value in pairs(values) do\n    if not isinteger(value) then\n \
    \     return nil\n    end\n    rv[#rv + 1] = value\n  end\n  return rv\nend",
  "  return values:filter(function(value) return type(value) == type(1) end)\nend",
  "   local filtered_values = {}\n   for _, value in pairs(values) do\n      -- Filter\
    \ out only integers\n      if type(value) == \"number\" then\n         table.insert(filtered_values,\
    \ value)\n      end\n   end\n   return filtered_values\nend", "  if values ==\
    \ nil then\n    return nil\n  end\n  local new_values = {}\n  for _, value in\
    \ pairs(values) do\n    if type(value) == \"number\" and math.floor(value) ==\
    \ value then\n      new_values[#new_values + 1] = value\n    end\n  end\n  return\
    \ new_values\nend", "  if type(values) == 'table' then\n    local list_type =\
    \ type(value)\n    local filtered_values = {}\n    for _, value in pairs(values)\
    \ do\n      if type(value) == 'table' and list_type == type(value) and list_type\
    \ ~= 'table' then\n        filtered_values[#filtered_values + 1] = filter_integers(value)\n\
    \      elseif type(value) == 'number' then\n        filtered_values[#filtered_values\
    \ + 1] = value\n      end\n    end\n    return filtered_values\n  elseif type(values)\
    \ == 'number' then\n    return values\n  else\n    return values\n  end\nend",
  "  local ret = {}\n  local _iterator = _G.type(values).getn\n  if _iterator == nil\
    \ then return ret\n  else\n    for _,v in ipairs(values) do\n      -- Only integers?\n\
    \      if type(v) == 'number' then\n        table.insert(ret, v)\n      end\n\
    \    end\n  end\n  return ret\nend", "  return function(v)\n    -- If value is\
    \ not a number, return nil\n    if type(v) ~= 'number' then return nil end\n \
    \   -- Return value if it is integer\n    if math.floor(v) == v then return v\
    \ end\n  end\nend", "  return [values]\nend", "    if type(values) ~= 'table'\
    \ then return values end", "    if type(values) ~= \"table\" then\n        return\
    \ values\n    end\n    local value\n    for _, value in ipairs(values) do\n  \
    \      if type(tostring(value)) == 'string' and tostring(value:sub(1, 1)) == '#'\
    \ then\n            values[#values + 1] = tonumber(value)\n        end\n    end\n\
    \    return values\nend", "    local function is_integer(x)\n        return x\
    \ == x\n    end\n    return filter(values, is_integer)\nend", "  local filtered\
    \ = {}\n  for _, value in ipairs(values) do\n    if type(value) ~= 'number' then\
    \ break end -- non-numeric value encountered\n    if type(value) ~= 'integer'\
    \ then break end -- non-integer value encountered\n    table.insert(filtered,\
    \ value)\n  end\n  return filtered\nend", "    local results = {}\n    for value\
    \ in values\n        if type(value) ~= 'number' then break end\n        if math.floor(value)\
    \ == value then results[#results + 1] = value end\n    end\n    return results\n\
    end", "  return values:filter(function(value) return type(value) == NIL_TYPE end)\n\
    end", "  local out = {}\n  for _, v in ipairs(values) do\n    if type(v) ~= 'number'\
    \ then -- ignore non-numerical values\n      out = out or {}\n      table.insert(out,\
    \ v)\n    end\n  end\n  return out\nend", "  local result = {}\n  for _, value\
    \ in pairs(values) do\n    if type(value) ~= 'number' then\n      result[#result\
    \ + 1] = value\n    elseif value ~= math.floor(value) then\n      result[#result\
    \ + 1] = value\n    end\n  end\n  return result\nend", "  local value\n  for _,\
    \ value in ipairs(values) do\n    if type(value) == \"number\" then\n      table.insert(values,\
    \ value)\n    end\n  end\n  return values\nend", "  for _, v in ipairs(values)\
    \ do\n    if type(v) == 'number' and v >= 0 then\n      table.insert(values, v)\n\
    \    end\n  end\n  return values\nend", "  for _, v in ipairs(values) do\n   \
    \ if type(v) ~= 'number' then\n      return nil\n    end\n  end\n  return values\n\
    end", "  local results = {}\n  for _, value in pairs(values) do\n    local _,\
    \ numeric = value\n    if type(numeric) == \"number\" then\n      table.insert(results,\
    \ numeric)\n    end\n  end\n  return results\nend", "  local values = terralib.newlist()\n\
    \  for i, value in ipairs(values) do\n    if not rawget(value, \"__index\") then\n\
    \      values.insert(i, value)\n    end\n  end\n  return values\nend", "  -- The\
    \ algorithm below is a variation of \"Find an item in an array?\" (http://www.refactoring.com/catalog/replace-find.html).\n\
    \  -- If none of the values are integers, return an empty list.\n  local function\
    \ is_integer(value)\n    return type(value) == 'number' and math.floor(value)\
    \ == value\n  end", "  if type(values[0]) ~= 'number' then\n    return values\n\
    \  end\n  local new_values = {}\n  for i = 1, #values do\n    if type(values[i])\
    \ ~= 'number' then\n      new_values[i] = values[i]\n    else\n      new_values[i]\
    \ = math.floor(values[i])\n    end\n  end\n  return new_values\nend", "  return\
    \ values:map(function(a) type(type(a)) and isnumeric(a) and a or nil end)\nend",
  "  local results = {}\n  local i = 1\n  for v in values do\n    if type(v) ~= 'number'\
    \ then\n      results[i] = v\n      i = i + 1\n    end\n  end\n  return results\n\
    end", "  if values then\n    local values = values:map(tointeger)\n    if #values\
    \ > 0 then return values end\n  end\n  return nil\nend", "  -- Filter out integer\
    \ values only for integers\n  local result = {}\n  for _, value in ipairs(values)\
    \ do\n    -- if type(value) == \"number\" then\n      if type(value) ~= 'table'\
    \ then\n        result[#result + 1] = value\n      end\n    -- end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for _, v in ipairs(values) do\n    if\
    \ type(v) == 'number' then\n      table.insert(result, v)\n    end\n  end\n  return\
    \ result\nend", "  local ret = {}\n  for _, value in pairs(values) do\n    if\
    \ type(value) ~= 'number' then\n      ret[#ret + 1] = value\n    end\n  end\n\
    \  return ret\nend", "  values = values:map(tointeger)\n  return filter(values,\
    \ function(value)\n    return type(value) == 'number' and math.floor(value) ==\
    \ value\n  end)\nend", "    if type(values) ~= \"table\" then return values end\n\
    \    local result = {}\n    for _, value in ipairs(values) do\n        if type(value)\
    \ == \"number\" then\n            result[#result + 1] = value\n        end\n \
    \   end\n    return result\nend", "  local function helper(values, accumulator)\n\
    \    if values then\n      for _, value in ipairs(values) do\n        accumulator\
    \ = accumulator or 0\n        if type(value ~= 'number') or (accumulator ~= value)\
    \ then\n          return accumulator\n        else\n          accumulator = value\n\
    \        end\n      end\n    end\n  end\n  return helper(values)\nend", "  return\
    \ function(value)\n    if type(value) == 'table' and value[1] == 'integer' then\n\
    \      return value[2]\n    end\n    return value\n  end\nend", "  values = values:map(function(v)\n\
    \    if type(v) ~= 'number' then\n      v = v\n        or\n      error('Value\
    \ must be of integer type')\n    end\n    return v\n  end)\n  return values\n\
    end", "  local result = {}\n  for _, value in ipairs(values) do\n    local _,\
    \ err = check_integer(value)\n    if err then return nil, err end\n    if tostring(value)\
    \ ~= '' and tonumber(value) ~= nil then\n      result[#result + 1] = value\n \
    \   end\n  end\n  return result\nend", "  local _, _, index, _, _, _, _ =\n  \
    \  unpack(\n      {'values', 'len', 'i', 'j', 'k', 't', 'table', 'table_size',\
    \ 'key'}\n    )"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
