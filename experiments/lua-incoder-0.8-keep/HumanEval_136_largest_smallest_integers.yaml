name: HumanEval_136_largest_smallest_integers
language: lua
prompt: "-- Create a function that returns a tuple (a, b), where 'a' is\n-- the largest\
  \ of negative integers, and 'b' is the smallest\n-- of positive integers in a list.\n\
  -- If there is no negative or positive integers, return them as None.\n-- Examples:\n\
  -- largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n-- largest_smallest_integers([])\
  \ == (None, None)\n-- largest_smallest_integers([0]) == (None, None)\nlocal function\
  \ largest_smallest_integers(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_smallest_integers\n\
  \    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})\n    lu.assertEquals(candidate({2,\
  \ 4, 1, 3, 5, 7, 0}), {None, 1})\n    lu.assertEquals(candidate({1, 3, 2, 4, 5,\
  \ 6, -2}), {-2, 1})\n    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7,\
  \ 2})\n    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})\n    lu.assertEquals(candidate({}),\
  \ {None, None})\n    lu.assertEquals(candidate({0}), {None, None})\n    lu.assertEquals(candidate({-1,\
  \ -3, -5, -6}), {-1, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6, 0}),\
  \ {-1, None})\n    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})\n  \
  \  lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #lst == 0 then\n    return (None, None)\n  else\n    if lst[1]\
    \ < 0 then\n      local first = lst[1]\n      local second = lst[1]\n      for\
    \ i = 2, #lst do\n        local value = lst[i]\n        if value < first then\n\
    \          first = value\n        elseif value > second then\n          second\
    \ = value\n        end\n      end\n      return (first, second)\n    else\n  \
    \    local first = lst[1]\n      local second = lst[1]\n      for i = 2, #lst\
    \ do\n        local value = lst[i]\n        if value < second then\n         \
    \ second = value\n        elseif value > first then\n          first = value\n\
    \        end\n      end\n      return (first, second)\n    end\n  end\nend", " \
    \   local function is_negative(x)\n        return x < 0\n    end", "  if #lst\
    \ == 0 then\n    return (None, None)\n  end\n  if #lst == 1 then\n    return (1,\
    \ lst[1])\n  end\n  local positive = lst:map(function(x) return x end):sort()\n\
    \  local negative = lst:map(function(x) return -x end):sort()\n  return (\n  \
    \  positive[#positive - 1],\n    negative[#negative - 1]\n  )\nend", "  -- Return\
    \ empty tuples if list is empty.\n  -- Otherwise, return a tuple containing the\
    \ largest\n  -- negative integer(s) and the smallest positive integer.\n  if #lst\
    \ == 0 then\n    return (None, None)\n  end", "  assert(type(lst) == 'table')\n\
    \  if #lst < 1 then\n    return (None, None)\n  end", "    if lst == nil then\n\
    \        return (nil, nil)\n    end\n    local min_val = math.min(lst)\n    local\
    \ max_val = math.max(lst)\n    if min_val == max_val then\n        return (min_val,\
    \ min_val)\n    end\n    local negative_index\n    for index = 1, #lst do\n  \
    \      if lst[index] < min_val then\n            min_val = lst[index]\n      \
    \      negative_index = index\n        end\n    end\n    local positive_index\n\
    \    for index = #lst, 1, -1 do\n        if lst[index] > max_val then\n      \
    \      max_val = lst[index]\n            positive_index = index\n        end\n\
    \    end\n    if negative_index and positive_index then\n        return (min_val,\
    \ max_val)\n    end\n    return (None, None)\nend", "  local pairs = {} -- Maps\
    \ negative integer to positive integer\n  local max_negative = nil -- The largest\
    \ negative integer\n  local min_positive = nil -- The smallest positive integer\n\
    \  for i = 1, #lst do\n    local is_negative = not is_number(lst[i])\n    if is_negative\
    \ and max_negative == nil then\n      max_negative = i\n    else if is_positive\
    \ and not min_positive == nil then\n      min_positive = i\n    end\n    if pairs[is_negative]\
    \ == nil then\n      pairs[is_negative] = i\n    end\n  end\n  if max_negative\
    \ ~= nil and min_positive ~= nil then\n    return max_negative, min_positive\n\
    \  else\n    return nil, nil\n  end\nend", "  if #lst == 0 then\n    return nil,\
    \ 0\n  end\n  local max_value, min_value = lst[1]\n  for i = 2, #lst, 1 do\n \
    \   if lst[i] > max_value then\n      max_value = lst[i]\n    end\n    if lst[i]\
    \ < min_value then\n      min_value = lst[i]\n    end\n  end\n  return max_value,\
    \ min_value\nend", "  if not lst then\n    return (None, None)\n  end\n  local\
    \ max, min = lst -- Assume all elements are positive\n  for i = 1, #lst do\n \
    \   local elem = lst[i]\n    if elem < min then\n      min = elem\n    end\n \
    \   if elem > max then\n      max = elem\n    end\n  end\n  return (max, min)\n\
    end", "    local smallest = nil\n    local largest = nil\n    local negative =\
    \ nil\n    for _,value in ipairs(lst) do\n        if value <= 0 then\n       \
    \     largest = value\n        else\n            smallest = value\n        end\n\
    \    end\n    if smallest ~= nil and largest ~= nil then\n        if smallest\
    \ > largest then\n            largest = smallest\n        else\n            smallest\
    \ = largest\n        end\n    end\n    return smallest, largest\nend", "  if #lst\
    \ == 0 then return (None, None)\n  end", '    local smallest_negative, largest
    = nil, nil', "  local max = -math.inf\n  local min = -math.inf\n  for _, v in\
    \ ipairs(lst) do\n    if v < min then\n      min = v\n    end\n    if v > max\
    \ then\n      max = v\n    end\n  end\n  if max < math.inf then\n    return max,\
    \ math.inf\n  else\n    return min, -math.inf\n  end\nend", "  if #lst < 1 then\n\
    \    return (None, None)\n  end\n  if #lst == 1 then\n    return (lst[1], lst[1])\n\
    \  end\n  local max = lst[1]\n  local min = lst[1]\n  for i = 2, #lst do\n   \
    \ if max < lst[i] then\n      max = lst[i]\n    end\n    if min > lst[i] then\n\
    \      min = lst[i]\n    end\n  end\n  return (min,max)\nend", "  local minimum\
    \ = nil\n  local maximum = nil\n  local maximum_index = nil", "  if #lst < 2 then\n\
    \    return nil, nil\n  end\n  local positive, negative = {}, {}\n  for i = 1,\
    \ #lst do\n    if lst[i] > 0 and lst[i] < 0 then\n      table.insert(negative,\
    \ lst[i])\n    elseif lst[i] > 0 then\n      table.insert(positive, lst[i])\n\
    \    end\n  end\n  local a, b = unpack(table.sort(negative))\n  return a, b\n\
    end", "    local largest, smallest, largest2, smallest2 = math.Max{}, math.Min{},\
    \ 0, 0\n    for i,v in ipairs(lst) do\n        if v < smallest then\n        \
    \    largest2, smallest2 = smallest2, v\n            smallest, largest = smallest,\
    \ v\n        elseif v > largest then\n            largest2, smallest2 = v, largest2\n\
    \            largest, smallest = largest, v\n        else\n            largest2,\
    \ smallest2 = v, v\n        end\n    end\n    return largest, smallest\nend",
  "  local largest = nil\n  local smallest = nil\n  local i = 1", "  local min\n \
    \ local max\n  for _, num in ipairs(lst) do\n    if num then\n      if min then\n\
    \        min = math.min(min, num)\n        max = math.max(max, num)\n      else\n\
    \        min = max\n        max = num\n      end\n    end\n  end\n  if min and\
    \ max then\n    return (min, max)\n  end\n  return (min)\nend", "  if lst[#lst]\
    \ == nil then return (None, None) end\n  local max = -math.inf\n  local min =\
    \ -math.inf\n  for i = 1, #lst do\n    local x = lst[i]\n    if x > max then\n\
    \      max = x\n    end\n    if x < min then\n      min = x\n    end\n  end\n\
    \  if min > max then return (min, max) end\n  return (min, max)\nend", "    local\
    \ smallest = math.min\n    local largest = math.max", "  if #lst == 0 then\n \
    \   return (None, None)\n  end\n  if lst[1] < 0 then\n    return largest_smallest_integers(lst[2:])\n\
    \  end\n  if lst[2] > 0 then\n    return largest_smallest_integers(lst[1:end])\n\
    \  end\n  return (lst[1], lst[2])\nend", "  if #lst == 0 then\n    return None,\
    \ None\n  else\n    local n = lst[1]\n    local smallst_value = nil\n    local\
    \ largest_value = nil\n    for i = 2, #lst, 1 do\n      if n < lst[i] then\n \
    \       n = lst[i]\n        smallst_value = i\n      elseif n > lst[i] then\n\
    \        n = lst[i]\n        largest_value = i\n      end\n    end\n    if n <\
    \ 0 then\n      return largest_value, smallst_value\n    else\n      return smallst_value,\
    \ largest_value\n    end\n  end\nend", "  local biggest = nil\n  local smallest\
    \ = nil", "  local min_val, max_val = 0, math.max(#lst)\n  for i = 1, #lst do\n\
    \    if lst[i] < min_val then\n      min_val = lst[i]\n    end\n    if lst[i]\
    \ > max_val then\n      max_val = lst[i]\n    end\n  end\n  return min_val, max_val\n\
    end\n</cell>\n<text>\nWrite the function to return a list of two elements containing\
    \ the largest and smallest integer in the given list. Call the function in the\
    \ cell below.", "  local function findlargest()\n    local smallest = nil\n  \
    \  for i = 1, #lst do\n      if lst[i] > smallest then\n        smallest = lst[i]\n\
    \      end\n    end\n    if smallest then\n      return smallest, nil\n    end\n\
    \  end\n  local function findsmallest()\n    local largest = nil\n    for i =\
    \ 1, #lst do\n      if lst[i] < largest then\n        largest = lst[i]\n     \
    \ end\n    end\n    if largest then\n      return largest, nil\n    end\n  end\n\
    \  if #lst == 0 then\n    return nil, nil\n  end\n  return findlargest(), findsmallest()\n\
    end", "  local max_negative, min_positive\n  max_negative, min_positive = 1, 1\n\
    \  for _, value in ipairs(lst) do\n    if value >= 0 then\n      if value > max_negative\
    \ then max_negative = value end\n    elseif value < 0 then\n      if value < min_positive\
    \ then min_positive = value end\n    end\n  end\n  if max_negative < min_positive\
    \ then return (max_negative, min_positive) end\n  return nil, nil\nend", "  local\
    \ max_i = 1\n  local min_i = 2\n  for i = 1, #lst do\n    if lst[i] > lst[max_i]\
    \ then\n      max_i = i\n    end\n    if lst[i] < lst[min_i] then\n      min_i\
    \ = i\n    end\n  end\n  return (lst[max_i], lst[min_i])\nend", "    local result\
    \ = {}\n    local smallest = -1000000000\n    local largest = 1000000000\n   \
    \ for _, b in ipairs(lst) do\n        if b < smallest then\n            smallest\
    \ = b\n        elseif b > largest then\n            largest = b\n        else\n\
    \            result[#result + 1] = b\n        end\n    end\n    if smallest >=\
    \ -1000000000 and largest <= 1000000000 then\n        return result, smallest\n\
    \    else\n        return result, largest\n    end\nend\n</cell>\n<text>\nApart\
    \ from writing a function that takes any number of parameters, we can also write\
    \ functions that take multiple arguments. This is called a function, which is\
    \ a bit more general than a procedure. Let's look at another example. We'll first\
    \ create a function which takes a number and returns the square of that number:",
  "  if lst == nil then return (None, None) end\n  local largest = -math.inf\n  local\
    \ smallest = math.inf\n  for i, v in ipairs(lst) do\n    largest = math.max(largest,\
    \ v)\n    smallest = math.min(smallest, v)\n  end\n  return (largest, smallest)\n\
    end", "  local biggest, smallest = nil, nil -- initialize with nil\n  local i\
    \ = 1\n  for value in lst do\n    if value < 0 then\n      if biggest == nil then\
    \ -- biggest was nil, all negative values were smaller than smallest\n       \
    \ biggest, smallest = value, i\n      else\n        biggest = value -- biggest\
    \ is the biggest of negative numbers (at i)\n        smallest = i -- smallest\
    \ is the smallest negative number\n      end\n    else -- value is positive\n\
    \      if smallest == nil then -- smallest was nil, all positive values were bigger\
    \ than biggest\n        biggest, smallest = value, i\n      else\n        smallest\
    \ = value -- smallest is the smallest positive number\n        biggest = i --\
    \ biggest is the biggest positive number\n      end\n    end\n    i = i + 1\n\
    \  end\n  if smallest == nil then -- if smallest == nil, all values were positive\n\
    \    return biggest, nil\n  else -- values were negative\n    return biggest,\
    \ smallest\n  end\nend", "  -- The smallest integer is the smallest of the negative\
    \ numbers\n  local smallest_integer = math.max(lst:map(function(x) return -x end))\n\
    \  -- The largest integer is the largest of the positive numbers\n  local largest_integer\
    \ = math.min(lst:map(function(x) return x end))\n  -- If the smallest integer\
    \ is larger than the largest integer, return None\n  if smallest_integer > largest_integer\
    \ then\n    return None, None\n  end\n  return smallest_integer, largest_integer\n\
    end", "  if not lst[1] then\n    return (None, None)\n  end\n  if #lst > 1 then\n\
    \    -- find the first negative integer\n    local min_index = lst.find_index(-function\
    \ (item) return item < 0 end)\n    -- find the first non-negative integer\n  \
    \  local max_index = lst.find_index(-function (item) return item >= 0 end)\n \
    \   if min_index == nil then\n      return (None, None)\n    end\n    if max_index\
    \ == nil then\n      -- there is no non-negative integer\n      return (lst[min_index],\
    \ lst[1])\n    end\n    -- find the min and max values\n    local min_value =\
    \ lst[min_index]\n    local max_value = lst[max_index]\n    if min_value < max_value\
    \ then\n      -- negative value was in the first\n      -- positive value; check\
    \ it first\n      return (largest_smallest_integers(lst[min_index + 1, max_index\
    \ - 1]),\n        largest_smallest_integers(lst[min_index + 1, max_index]))\n\
    \    end\n    -- negative value was in the last\n    -- positive value; check\
    \ it first\n    return largest_smallest_integers(lst[min_index + 1, max_index\
    \ + 1]),\n           largest_smallest_integers(lst[min_index, max_index])\n  end\n\
    \  -- there is only one positive value\n  return largest_smallest_integers(lst[#lst])\n\
    end", "  if lst:len() == 0 then\n    return nil\n  end\n  local first_number =\
    \ lst[1]\n  for _, number in pairs(lst) do\n    if number < first_number then\n\
    \      first_number = number\n    end\n  end\n  return first_number, lst[#lst]\n\
    end", "  assert(lst)\n  local largest = nil\n  local smallest = nil\n  for i =\
    \ #lst, 1, -1 do\n    local elem = lst[i]\n    if not smallest or elem < smallest\
    \ then\n      largest = elem\n      smallest = nil\n    else\n      smallest =\
    \ elem\n    end\n  end\n  if smallest then\n    return (largest, smallest)\n \
    \ end\n  return largest, smallest\nend", "  if not lst:is(ast.typed.expr.ListExpr)\
    \ then\n    return ast.typed.expr.ListExpr{\n      expr_type = nil,\n      entries\
    \ = terralib.newlist(),\n    }\n  end\n  local expr_type = std.as_read(lst.expr_type)\n\
    \  local is_negative = expr_type == std.c.legion_index_type_t.legion_negative_index_type\n\
    \  if expr_type ~= nil then\n    return std.extract_value_type(expr_type)\n  else\n\
    \    expr_type = std.typed.expr.ListUnpack{\n      src_type = expr_type,\n   \
    \   vector_type = expr_type,\n      mode = ast.typed.expr.UnpackMode.Tertiary,\n\
    \    }\n  end\n  local index_type = expr_type.index_type\n  local zero = make_index_genexpr_constant(false)\n\
    \  local max_expr = ast.typed.expr.Binary {\n    op = ast.typed.expr.Binary {\n\
    \      op = \">\",\n      lhs = ast.typed.expr.Unary {\n        op = ast.typed.expr.UnaryOp.Negative,\n\
    \        rhs = zero,\n      },\n      rhs = ast.typed.expr.FieldAccess {\n   \
    \     value = zero,\n        field_name = \"__pad1\",\n        expr_type = index_type,\n\
    \        span = ast.trivial_span(),\n      },\n    },\n    rhs = ast.typed.expr.Binary\
    \ {\n      op = \"<\",\n      lhs = ast.typed.expr.Unary {\n        op = ast.typed.expr.UnaryOp.Positive,\n\
    \        rhs = zero,\n      },\n      rhs = ast.typed.expr.FieldAccess {\n   \
    \     value = zero,\n        field_name = \"__pad1\",\n        expr_type = index_type,\n\
    \        span = ast.trivial_span(),\n      },\n    },\n    expr_type = expr_type,\n\
    \    span = ast.trivial_span(),\n  }\n  local min_expr = ast.typed.expr.Binary\
    \ {\n    op = ast.typed.expr.Binary {\n      op = \"<\",\n      lhs = ast.typed.expr.Unary\
    \ {\n        op = ast.typed.expr.UnaryOp.Negative,\n        rhs = zero,\n    \
    \  },\n      rhs = ast.typed.expr.FieldAccess {\n        value = zero,\n     \
    \   field_name = \"__pad1\",\n        expr_type = index_type,\n        span =\
    \ ast.trivial_span(),\n      },\n    },\n    rhs = ast.typed.expr.Binary {\n \
    \     op = \">\",\n      lhs = ast.typed.expr.Unary {\n        op = ast.typed.expr.UnaryOp.Positive,\n\
    \        rhs = zero,\n      },\n      rhs = ", "  if #lst == 0 then\n    return\
    \ (None, None)\n  end\n  local max = lst[1]\n  local min = -max\n  for i = 2,\
    \ #lst do\n    if lst[i] < min then\n      min = -max\n    end\n    if lst[i]\
    \ > max then\n      max = lst[i]\n    end\n  end\n  return (max, min)\nend", " \
    \ if #lst < 1 then\n    return (None, None)\n  end\n  local max_value = lst[1]\n\
    \  local min_value = lst[1]\n  for i = 2, #lst do\n    if max_value < lst[i] then\n\
    \      max_value = lst[i]\n    end\n    if min_value > lst[i] then\n      min_value\
    \ = lst[i]\n    end\n  end\n  return (max_value, min_value)\nend", "  assert(lst:len()\
    \ > 0)\n  -- First, find the largest positive number in the list\n  -- If there\
    \ are no positive numbers in the list, return them as None.\n  local max_val =\
    \ lst[1]\n  for i = 2, lst:len() do\n    if lst[i] > max_val then\n      max_val\
    \ = lst[i]\n    end\n  end\n  -- Second, find the smallest negative number in\
    \ the list\n  local min_val = lst[1]\n  for i = 2, lst:len() do\n    if lst[i]\
    \ < min_val then\n      min_val = lst[i]\n    end\n  end\n  return (max_val, min_val)\n\
    end", "  local function max(a, b)\n    if a < b then return b else return a end\n\
    \  end\n  local function min(a, b)\n    if a > b then return b else return a end\n\
    \  end", "    if lst[1] == nil then\n        return (None, None)\n    elseif lst[1]\
    \ == 0 then\n        return (None, None)\n    elseif lst[1] <= 0 then\n      \
    \  return ( -lst[1], lst[1])\n    else\n        return ( -math.min(lst[1]), math.max(lst[1]))\n\
    \    end\nend", "  if lst[1] == nil then\n    return nil, nil\n  end", "    local\
    \ negative_integers = nil\n    local positive_integers = nil\n    local max =\
    \ nil\n    local min = nil", "  if #lst == 0 then\n    return (None, None)\n \
    \ end\n  local min, max = #lst, -1\n  local is_neg, neg_int = true, -1\n  for\
    \ _, x in ipairs(lst) do\n    if x < 0 then\n      min = max + 1\n      is_neg\
    \ = false\n    elseif x > 0 then\n      max = min - 1\n      is_neg = true\n \
    \   end\n    neg_int = neg_int * x + x\n  end\n  if is_neg then\n    local t =\
    \ neg_int\n    neg_int = -1\n    return (-t, -t)\n  else\n    local t = min\n\
    \    return (-1, t)\n  end\nend", "  if lst == nil then return (None, None) return\
    \ end\n  local max_neg_int = -lst[1]\n  local min_pos_int = lst[1]\n  for i =\
    \ 2, #lst do\n    local int_ = lst[i]\n    if int_ < min_pos_int then min_pos_int\
    \ = int_ end\n    if int_ > max_neg_int then max_neg_int = int_ end\n  end\n \
    \ if max_neg_int < min_pos_int then return (max_neg_int, min_pos_int) return end\n\
    \  return (max_neg_int, None)\nend", "  -- If the list is empty, return (None,\
    \ None)\n  if(#lst == 0) then\n    return (None, None)\n  end\n  -- Sort (descending)\
    \ by abs()\n  table.sort(lst, function(a,b) return (not a) or not b end) -- descending\n\
    \  -- Find the first negative number\n  local negative_index = 1\n  while(negative_index\
    \ < #lst and lst[negative_index] < 0) do\n    negative_index = negative_index\
    \ + 1\n  end\n  -- Return the largest of the negative and the positive numbers\n\
    \  -- Return them separately\n  if(negative_index == #lst) then\n    return (lst[1],\
    \ lst[1])\n  else\n    return (lst[negative_index], lst[1])\n  end\nend", "  local\
    \ largest, smallest = nil, nil -- Keep the return values in local variables so\
    \ that they don't need to be garbage collected when the function returns.\n  for\
    \ _, value in ipairs(lst) do\n    if value < 0 then\n      if largest == nil then\n\
    \        largest = value\n      else\n        largest = largest * 10 + value\n\
    \      end\n    elseif largest == nil then\n      smallest = value\n    else\n\
    \      if value < smallest then\n        smallest = value\n      end\n    end\n\
    \  end\n  if largest ~= nil and smallest ~= nil then\n    return (largest, smallest)\n\
    \  else\n    return nil\n  end\nend", "    local minnum = nil\n    local maxnum\
    \ = nil\n    for _, num in ipairs(lst) do\n        if num then\n            if\
    \ minnum == nil then\n                minnum = num\n                maxnum = num\n\
    \            else\n                minnum = min(minnum, num)\n               \
    \ maxnum = max(maxnum, num)\n            end\n        end\n    end\n    return\
    \ minnum, maxnum\nend", "    local largest, smallest = nil, nil\n    for i = 1,\
    \ #lst do\n        if tonumber(lst[i]) < tonumber(largest) then\n            largest\
    \ = lst[i]\n        elseif tonumber(lst[i]) > tonumber(smallest) then\n      \
    \      smallest = lst[i]\n        end\n    end\n    return largest, smallest\n\
    end", "  local function helper(x, min, max)\n    if x < min then return min, max\
    \ end\n    if x > max then return min, max end\n    if x <= max then return helper(x+1,\
    \ min, x) else return x, x end\n  end\n  return helper(0, -math.huge, math.huge)\n\
    end", "\tlocal negative_integers = nil\n\tlocal positive_integers = nil\n\tfor\
    \ i = #lst, 1, -1 do\n\t\tif lst[i] < 0 then\n\t\t\tif negative_integers ~= nil\
    \ then\n\t\t\t\tbreak end\n\t\t\telse\n\t\t\t\tnegative_integers = lst[i]\n\t\t\
    \tend\n\t\telseif lst[i] > 0 then\n\t\t\tif positive_integers ~= nil then\n\t\t\
    \t\tbreak end\n\t\t\telse\n\t\t\t\tpositive_integers = lst[i]\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn negative_integers, positive_integers\nend", "  if lst:len()\
    \ <= 0 then\n    return (None, None)\n  end\n  local negative_idx = 1\n  local\
    \ positive_idx = 1\n  local max = 0\n  local min = 9999\n  for i = 1, lst:len()\
    \ do\n    local val = lst[i]\n    if val < 0 then\n      max = val\n      negative_idx\
    \ = i\n    elseif val > 0 then\n      min = val\n      positive_idx = i\n    end\n\
    \  end\n  return (max, min) -- return a tuple (largest_idx, smallest_idx)\nend",
  "  local max_negative = nil\n  local min_positive = nil", "  local max_n = nil\n\
    \  local min_n = nil\n  for i = 1, #lst do\n    if lst[i] < 0 then\n      if not\
    \ min_n or min_n > 0 then\n        min_n = lst[i]\n      end\n    else\n     \
    \ if not max_n or max_n < 0 then\n        max_n = lst[i]\n      end\n    end\n\
    \  end\n  return max_n, min_n\nend", "  if lst:len() == 0 then\n    return None,\
    \ None\n  end\n  local max_int = -1\n  local min_int = +3\n  for _, value in ipairs(lst)\
    \ do\n    if value < 0 then\n      if max_int < min_int then\n        max_int,\
    \ min_int = min_int, max_int\n      end\n    elseif value > 0 then\n      if max_int\
    \ < min_int then\n        max_int, min_int = min_int, max_int\n      end\n   \
    \ end\n  end\n  return max_int, min_int\nend", '  local result = {}', "  if #lst\
    \ < 1 then\n    return (None, None)\n  end\n  local pos = 1\n  local neg = 1\n\
    \  local cur_max = 0\n  local cur_min = 0\n  -- Loop through the list\n  for i=1,\
    \ #lst do\n    -- If the current number is greater than the current maximum or\
    \ less than the current minimum,\n    -- then reset the max and min to the current\
    \ number.\n    if lst[i] > cur_max or lst[i] < cur_min then\n      pos = i\n \
    \     cur_max = lst[i]\n      cur_min = lst[i]\n    else\n      -- Otherwise,\
    \ if the current number is equal to the current maximum and smaller than\n   \
    \   -- the current minimum, set the minimum to that number and set the maximum\
    \ to that number.\n      if lst[i] == cur_max and lst[i] < cur_min then\n    \
    \    cur_min = lst[i]\n      else\n        -- Otherwise, set the minimum to the\
    \ current maximum and set the maximum to the current minimum.\n        cur_max\
    \ = cur_min\n        cur_min = lst[i]\n      end\n    end\n  end\n  -- If the\
    \ current number is the first or last number in the list, set the maximum to the\
    \ current number and the minimum to the current number.\n  -- This is so that\
    \ if the list is empty, there will be no min/max values.\n  if pos == 1 or i ==\
    \ #lst then cur_max = cur_min\n  return { pos = pos, max = cur_max, min = cur_min\
    \ }\nend", "    local positives, negatives = {}, {}\n    for _, value in ipairs(lst)\
    \ do\n        if value < 0 then\n            table.insert(negatives, value)\n\
    \        else\n            table.insert(positives, value)\n        end\n    end\n\
    \    if #positives > 0 and #negatives > 0 then\n        return largest(negatives),\
    \ smallest(positives)\n    end\n    return None, None\nend", "    local first_integer\
    \ = true\n    local smallest, largest = -1, -1\n    for _,v in ipairs(lst) do\n\
    \        if first_integer then\n            smallest, largest = v, _\n       \
    \     first_integer = false\n        elseif v < smallest then\n            smallest,\
    \ largest = v, _\n        end\n    end\n    return smallest, largest\nend\n</cell>\n\
    <text>\nAnd here we define our new function, and call it on our data:", "  local\
    \ largest = -math.inf - 1\n  local smallest = math.inf + 1\n  for _, num in ipairs(lst)\
    \ do\n    if num < smallest then\n      largest = num\n    elseif num > largest\
    \ then\n      smallest = num\n    end\n  end\n  if smallest > largest then\n \
    \   return (largest, smallest)\n  else\n    return (smallest, largest)\n  end\n\
    end", "  if #lst == 0 then\n    return (None, None)\n  end\n  local positive,\
    \ negative, first, last, pos, neg, last_pos = false, false, true, true, 1, 0\n\
    \  for i = 1, #lst, 1 do\n    local value = lst[i]\n    if value < 0 then\n  \
    \    negative = not negative\n      first = last_pos\n      pos = pos\n    elseif\
    \ value > 0 then\n      positive = not positive\n      last = pos\n      last_pos\
    \ = pos\n    elseif positive ~= negative then\n      if positive then\n      \
    \  pos = pos\n      else\n        neg = true\n      end\n    end\n  end\n  if\
    \ last <= first then\n    return (None, None)\n  end\n  local max = last - 1\n\
    \  local min = first + 1\n  if neg then\n    max = first + 1\n    min = -min\n\
    \  end\n  if positive then\n    return (lst[max], lst[min])\n  else\n    return\
    \ (lst.sub(1, max), lst.sub(1, min))\n  end\nend", "  if lst:is_empty() then\n\
    \    return (None, None)\n  end\n  local max = -1\n  local min = nil\n  for i\
    \ = 1, #lst do\n    if max < lst[i] then\n      max = lst[i]\n      min = i\n\
    \    end\n  end\n  if min ~= nil then\n    return (max, min)\n  else\n    return\
    \ (None, None)\n  end\nend", "  if #lst == 0 then\n    return (None, None)\n \
    \ end", "  local function largest(x)\n    if x < 0 then\n      return x\n    else\n\
    \      return -x\n    end\n  end\n  local function smallest(x)\n    if x > 0 then\n\
    \      return x\n    else\n      return -x\n    end\n  end\n  local result = {}\n\
    \  for i = #lst, 1, -1 do\n    if largest(lst[i]) < smallest(lst[i]) then\n  \
    \    table.insert(result, largest(lst[i]))\n    else\n      table.insert(result,\
    \ smallest(lst[i]))\n    end\n  end\n  if #result == 0 then\n    return nil, nil\n\
    \  else\n    return table.unpack(result)\n  end\nend", "  -- Initialize min and\
    \ max to largest and smallest possible values\n  local min_ = math.max(math.min(lst))\n\
    \  local max_ = math.min(math.max(lst))\n  local ret\n  for _, v in ipairs(lst)\
    \ do\n    if v < min_ then\n      min_ = v\n    end\n    if v > max_ then\n  \
    \    max_ = v\n    end\n  end\n  if min_ == max_ then\n    ret = (min_, min_)\n\
    \  else\n    ret = (min_, max_)\n  end\n  return ret\nend", "  local largest,\
    \ smallest = nil, nil\n  for i = 1, #lst do\n    if math.abs(lst[i]) > smallest\
    \ then\n      smallest = math.abs(lst[i])\n    end\n    if smallest ~= nil and\
    \ math.abs(lst[i]) < largest then\n      largest = math.abs(lst[i])\n    end\n\
    \  end\n  if largest == nil and smallest == nil then\n    return nil, nil\n  end\n\
    \  return largest, smallest\nend", "  local smallest, largest = nil, nil -- Start\
    \ with smallest/largest as nil\n  for i = 1, #lst do\n    local x = lst[i]\n \
    \   if x < 0 then\n      if smallest ~= nil then\n        largest = smallest --\
    \ Largest of the smallest negative integers is largest\n      end\n      smallest\
    \ = nil -- Reset the smallest to nil\n    else\n      if smallest == nil then\n\
    \        smallest = x -- Only one negative integer: use it\n      else\n     \
    \   if x < smallest then\n          largest = smallest -- Largest of the smallest\
    \ negative integers is largest\n        end\n        smallest = x -- Only one\
    \ positive integer: use it\n      end\n    end\n  end\n  if smallest ~= nil then\
    \ return (largest, smallest) end\n  return nil, nil -- No negative or positive\
    \ integers\nend", "  local largest, smallest = nil, nil\n  for i = 1, #lst do\n\
    \    if lst[i] < 0 then\n      if largest == nil then\n        largest = lst[i]\n\
    \      else\n        largest = largest\n      end\n    elseif largest then\n \
    \     if lst[i] > smallest then\n        largest = lst[i]\n      else\n      \
    \  smallest = largest\n      end\n    else\n      largest = lst[i]\n      smallest\
    \ = nil\n    end\n  end\n  if smallest then\n    return (largest, smallest)\n\
    \  end\n  return largest\nend", "  local positive, negative = true, false\n  local\
    \ max = -math.inf\n  local min = math.inf\n  local size = #lst", "   if #lst ==\
    \ 0 then\n      return (None, None)\n   end\n   local largest = lst[1]\n   local\
    \ smallest = lst[1]\n   for i = 2, #lst do\n      if lst[i] > largest then\n \
    \        largest = lst[i]\n      end\n      if lst[i] < smallest then\n      \
    \   smallest = lst[i]\n      end\n   end\n   return (largest, smallest)\nend",
  "  if #lst < 2 then return (lst[0], lst[1]) end\n  local largest = unpack(lst:sort(function(a,\
    \ b) return -a < b end))[1]\n  if largest == 0 then return (lst[1], lst[1]) end\n\
    \  local smallest = unpack(lst:sort(function(a, b) return a < b end))[1]\n  return\
    \ (largest, smallest)\nend", "   assert(type(lst) == 'table')\n   local maxval\
    \ = 0\n   local minval = sys.maxint\n   for i = 1, #lst do\n      local val =\
    \ lst[i]\n      if val > maxval then\n         maxval = val\n      elseif val\
    \ < minval then\n         minval = val\n      end\n   end\n   if minval == maxval\
    \ then\n      return (None, None)\n   else\n      return (minval, maxval)\n  \
    \ end\nend", "  if #lst == 0 then\n    return (None, None)\n  else\n    local\
    \ smallest, largest = lst[1], lst[2]\n    for i = 2, #lst do\n      if lst [i]\
    \ < smallest then\n        smallest = lst [i]\n      end\n      if lst [i] > largest\
    \ then\n        largest = lst [i]\n      end\n    end\n    return (largest, smallest)\n\
    \  end\nend", "  if lst == nil then\n    return (None, None)\n  end\n  local positive,\
    \ negative = 1, 0\n  local min = #lst\n  for i = 1, min do\n    if lst[i] > 0\
    \ then\n      positive = positive + 1\n    elseif lst[i] < 0 then\n      negative\
    \ = negative + 1\n    end\n    if positive > negative then\n      min = i\n  \
    \  end\n  end\n  if positive > negative then\n    return (lst[min], positive)\n\
    \  else\n    return (negative, lst[min])\n  end\nend", "  if #lst == 0 then\n\
    \    return (None, None)\n  end\n  local small = lst[1]\n  local large = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] > large then\n      large = lst[i]\n    end\n\
    \    if lst[i] < small then\n      small = lst[i]\n    end\n  end\n  return (large,\
    \ small)\nend", "  if lst:isnumber() then\n    local min, max = lst:min()\n  \
    \  return min or max, min and max or nil\n  else\n    if #lst < 2 then return\
    \ nil, nil end\n    local min, max = lst[1], lst[2]\n    for i = 2, #lst do\n\
    \      if lst[i] > max then max = lst[i] end\n      if lst[i] < min then min =\
    \ lst[i] end\n    end\n    return min or nil, max or nil\n  end\nend\n</cell>\n\
    <text>\nLargest Sum of All Elements\nYour task is to find the sum of the largest\
    \ elements in a list of numbers. If the list is empty, return 0.", "  local smallest,\
    \ largest = nil, nil\n  for _, x in ipairs(lst) do\n    if x < smallest then\n\
    \      smallest = x\n    elseif x > largest then\n      largest = x\n    end\n\
    \  end\n  if smallest == nil then\n    return nil, nil\n  end\n  return largest,\
    \ smallest\nend", "  -- Create an empty list to hold the largest and smallest\
    \ integers\n  local largest = nil\n  local smallest = nil\n  for _, x in ipairs(lst)\
    \ do\n    -- If the current number is greater than the smallest number,\n    --\
    \ set smallest to the current number and update largest to\n    -- hold the smallest\
    \ number\n    if x ~= smallest then\n      -- If the smallest number is still\
    \ a number, overwrite the\n      -- smallest number with the current number\n\
    \      if smallest ~= nil then\n        largest = smallest\n      end\n      smallest\
    \ = x\n    end\n    -- If the current number is smaller than the largest number,\n\
    \    -- set largest to the current number and update smallest to\n    -- hold\
    \ the smallest number\n    if x ~= largest then\n      -- If the smallest number\
    \ is still a number, overwrite the\n      -- smallest number with the current\
    \ number\n      if smallest ~= nil then\n        largest = smallest\n      end\n\
    \      largest = x\n    end\n  end\n  -- If no integers were found, return nil\
    \ for the largest and smallest\n  -- number\n  if largest == nil and smallest\
    \ == nil then\n    return nil\n  end\n  return largest, smallest\nend", "    local\
    \ max_int = nil\n    local min_int = nil", "   local pos = 0\n   local neg = 0\n\
    \   for i = 1, #lst do\n      if lst[i] < 0 then\n         pos = pos + 1\n   \
    \   else\n         neg = neg + 1\n      end\n   end\n   if neg == 0 and pos ==\
    \ 0 then\n      return (None, None)\n   end\n   if neg == 0 and pos > 0 then\n\
    \      pos = pos\n   elseif neg > 0 and pos == 0 then\n      neg = neg\n   end\n\
    \   if neg > pos then\n      return (neg, pos)\n   else\n      return (pos, neg)\n\
    \   end\nend", "  local negative_integers = {}\n  local positive_integers = {}",
  "  local small, large = #lst, 0\n  for i = #lst, 1, -1 do\n    local x = lst[i]\n\
    \    if x < 0 then\n      small, large = large, small\n    elseif x == 0 then\n\
    \      small, large = large, 1\n    end\n  end\n  return small, large\nend", " \
    \ local largest = nil\n  local smallest = nil\n  for i, v in ipairs(lst) do\n\
    \    if v > smallest then\n      smallest = v\n    elseif v < largest then\n \
    \     largest = v\n    end\n  end\n  return largest, smallest\nend", "  if #lst\
    \ == 0 then\n    return nil, nil\n  end", "  if #lst < 2 then\n    return nil,\
    \ nil\n  end", "  local max_negative = #lst\n  local max_positive = #lst\n  local\
    \ negative_indicies = {}\n  local positive_indicies = {}\n  for i = 1, #lst do\n\
    \    if lst[i] < 0 then\n      max_negative = i - 1\n      negative_indicies[i]\
    \ = true\n    elseif lst[i] > 0 then\n      max_positive = i + 1\n      positive_indicies[#positive_indicies\
    \ + 1] = true\n    end\n  end\n  if max_negative == max_positive then return (None,\
    \ None) end\n  for i = 1, #lst do\n    if not negative_indicies[i] then\n    \
    \  max_negative = i - 1\n      break\n    end\n  end\n  for i = #positive_indicies,\
    \ 1, -1 do\n    if not positive_indicies[i] then\n      max_positive = i + 1\n\
    \      break\n    end\n  end\n  if max_negative == max_positive then return (None,\
    \ None) end\n  return max_negative, max_positive\nend", "  local largest, smallest\
    \ = nil, nil -- Initialize to nil if not found.\n  for _, value in ipairs(lst)\
    \ do\n    local new_largest, new_smallest = value, value\n    if smallest < value\
    \ then smallest = value end\n    if largest < value then largest = value end\n\
    \    if smallest < new_smallest then new_smallest = smallest end\n    if largest\
    \ < new_largest then new_largest = largest end\n  end\n  return (largest, smallest)\n\
    end\n</code>\n<|/ a tags=sorting,lua,lua-table |>\n<| a dscore=2 |>\nI've been\
    \ looking for a function to do this, and found no one here that actually sorts\
    \ by a specific column. Here's my solution, with a couple tweaks to account for\
    \ missing columns and to sort by multiple columns:\n<code>", "  local max = -math.inf\n\
    \  local min = -math.inf\n  for _, v in pairs(lst) do\n    max = math.max(max,\
    \ v)\n    min = math.min(min, v)\n  end\n  if max < -math.inf and min > math.inf\
    \ then\n    return (max, min)\n  end\n  return (None, None)\nend", "    local\
    \ negative_integers, positive_integers = 0, 1\n    for i = 1, #lst do\n      \
    \  if lst[i] < 0 then\n            negative_integers = negative_integers + 1\n\
    \        else\n            positive_integers = positive_integers + 1\n       \
    \ end\n    end", "    local min = #lst\n    for i = #lst + 1, -1, -1 do\n    \
    \    if lst[i] < lst[min] then\n            min = i\n        end\n    end\n  \
    \  if min > 0 then\n        return (lst[min], min)\n    else\n        return (None,\
    \ None)\n    end\nend", "  if #lst <= 0 then\n    return nil\n  else\n    local\
    \ largest_negative = nil\n    local smallest_positive = nil\n    for i = 1, #lst\
    \ do\n      local val = lst[i]\n      if val < 0 then\n        largest_negative\
    \ = val\n      elseif val > 0 then\n        smallest_positive = val\n      else\n\
    \        return nil\n      end\n    end\n    return { largest_negative, smallest_positive\
    \ }\n  end\nend", "  -- Base case: empty list\n  if #lst == 0 then\n    return\
    \ (None, None)\n  end", "  local max = 0\n  local min = 0\n  for i, v in ipairs(lst)\
    \ do\n    if v > max then max = v end\n    if v < min then min = v end\n  end\n\
    \  if max == 0 then return nil, nil end\n  return min, max\nend", "  if #lst ==\
    \ 0 then\n    return (None, None)\n  end", "  if #lst < 1 then return (None, None)\
    \ end\n  local max = 0\n  local min = math.min(unpack(lst))\n  for i = 1, #lst\
    \ do\n    if lst[i] < min then min = lst[i] end\n    if lst[i] > max then max\
    \ = lst[i] end\n  end\n  return (min, max)\nend", "  local largest = -1\n  local\
    \ smallest = nil", "  -- No integers, return as None\n  if #lst == 0 then\n  \
    \  return (None, None)\n  end", "  if #lst == 0 then\n    return nil, nil\n  end\n\
    \  local smallest, largest = lst[1], lst[1]\n  for i = 2, #lst do\n    if smallest\
    \ * i > largest then\n      largest = smallest * i\n    end\n    if smallest <\
    \ 0 then\n      smallest = -1\n    end\n  end\n  return largest, smallest\nend",
  "  local min_val = lst.Min()\n  local max_val = lst.Max()", "  -- Return both positive\
    \ and negative integer elements\n  local max_neg_num\n  local min_pos_num\n  for\
    \ _, num in ipairs(lst) do\n    if num ~= 0 then\n      if not max_neg_num then\
    \ max_neg_num = num end\n      if num > max_neg_num then max_neg_num = num end\n\
    \    elseif max_neg_num then\n      if not min_pos_num then min_pos_num = max_neg_num\
    \ end\n      if num < min_pos_num then min_pos_num = max_neg_num end\n    end\n\
    \  end\n  -- Return None or both positive and negative numbers\n  return min_pos_num,\
    \ max_neg_num\nend", "  if #lst == 0 then\n    return (None, None)\n  end", " \
    \ local first_positive, first_negative = lst[1] < 0, lst[1] < 0\n  if first_positive\
    \ then\n    return (1, lst[2])\n  elseif first_negative then\n    return (lst[2],\
    \ 1)\n  else\n    local min_positive = lst[1]\n    local max_negative = lst[1]\n\
    \    for i, v in ipairs(lst) do\n      if v < 0 then\n        min_negative = min_negative\
    \ > v end\n      elseif v > 0 then\n        max_negative = max_negative < v end\n\
    \      else\n        min_positive = min_positive > v end\n      end\n    end\n\
    \    return (max_negative, min_positive)\n  end\nend", "    local negative_ints\
    \ = {}\n    local positive_ints = {}\n    for i = 1, #lst do\n        if lst[i]\
    \ < 0 then\n            negative_ints[#negative_ints+1] = lst[i]\n        else\n\
    \            positive_ints[#positive_ints+1] = lst[i]\n        end\n    end\n\
    \    if #negative_ints > #positive_ints then\n        return nil, #negative_ints\n\
    \    elseif #negative_ints < #positive_ints then\n        return #positive_ints,\
    \ #negative_ints\n    else\n        return negative_ints[#negative_ints], positive_ints[#positive_ints]\n\
    \    end\nend", "  local max_negative = 0\n  local max_positive = 0\n  local max_negative_or_positive\
    \ = nil\n  for i = 1, #lst do\n    local negative_or_positive = lst[i]\n    if\
    \ negative_or_positive > 0 then\n      max_negative = max_negative or negative_or_positive\n\
    \      max_negative_or_positive = negative_or_positive\n    elseif negative_or_positive\
    \ < 0 then\n      max_positive = max_positive or negative_or_positive\n    end\n\
    \  end\n  return (max_negative_or_positive, max_positive)\nend", "    if #lst\
    \ == 0 then\n        return (None, None)\n    end\n    local max_num = -math.inf\n\
    \    local min_num = math.inf\n    for i = 1, #lst do\n        if lst[i] > max_num\
    \ then\n            max_num = lst[i]\n        end\n        if lst[i] < min_num\
    \ then\n            min_num = lst[i]\n        end\n    end\n    return (max_num,\
    \ min_num)\nend\n</cell>\n<cell>", "    if lst == nil then\n        return nil,\
    \ nil\n    end\n    local max_value = -math.inf\n    local min_value = math.inf\n\
    \    local pos = 1\n    for i = 1, #lst do\n        if lst[i] > max_value then\n\
    \            max_value = lst[i]\n            pos = i\n        end\n        if\
    \ lst[i] < min_value then\n            min_value = lst[i]\n        end\n    end\n\
    \    return max_value, min_value\nend", "  if not lst then\n    return (None,\
    \ None)\n  end\n  local max = -1\n  local min = +infinity\n  for i, v in ipairs(lst)\
    \ do\n    if v < min then\n      min = v\n    end\n    if v > max then\n     \
    \ max = v\n    end\n  end\n  if min < -infinity or max > +infinity then\n    return\
    \ (None, None)\n  end\n  return min, max\nend", "  if not lst:is_list() then\n\
    \    return nil, lst\n  end\n  local max_val = nil\n  local min_val = nil\n  for\
    \ i, v in ipairs(lst) do\n    if v < 0 then\n      if max_val and min_val then\n\
    \        return max_val, min_val\n      end\n      max_val = v\n    elseif v >\
    \ 0 then\n      if max_val and min_val then\n        if max_val <= v then\n  \
    \        return max_val, min_val\n        else\n          return max_val, v\n\
    \        end\n      else\n        min_val = v\n      end\n    end\n  end\n  if\
    \ max_val and min_val then\n    return max_val, min_val\n  else\n    return nil,\
    \ nil\n  end\nend", '  local largest, smallest = nil, nil', "  local smallest,\
    \ largest = nil, nil\n  for _, integer in ipairs(lst) do\n    if integer > smallest\
    \ and integer < largest then\n      largest = integer\n    elseif integer < smallest\
    \ then\n      smallest = integer\n    end\n  end\n  if smallest and largest then\n\
    \    return (largest, smallest)\n  end\nend", "  local function helper(list)\n\
    \    local a, b\n    if next(list) == nil then\n      return 0, 0\n    elseif\
    \ list[1] < 0 then\n      a = -1\n      b = list[1]\n    else\n      a = list[1]\n\
    \      b = -1\n    end\n    for i = 2, #list do\n      if list[i] < a then\n \
    \       a = list[i]\n      elseif list[i] > b then\n        b = list[i]\n    \
    \  end\n    end\n    return b, a\n  end\n  return helper(lst)\nend", "  if lst[#lst]\
    \ > 0 then\n    return largest_smallest_integers(lst)\n  end\n  if lst[#lst] <\
    \ 0 then\n    return (-lst[#lst], -#lst)\n  end\n  return None, None\nend", " \
    \ if lst ~= nil then\n    local positive, negative\n    for _, v in pairs(lst)\
    \ do\n      if v ~= nil and v > 0 then\n        positive = v\n      elseif v ~=\
    \ nil and v < 0 then\n        negative = v\n      else\n        return nil, v\n\
    \      end\n    end\n    if positive > negative then\n      return positive, negative\n\
    \    else\n      return negative, positive\n    end\n  end\n  return nil, nil\n\
    end", "  if #lst <= 0 then return (None, None) end\n  local smallest = lst[1]\n\
    \  for i = 2, #lst do\n    smallest = smallest > lst[i] and lst[i] or smallest\n\
    \  end\n  return (smallest, lst[1])\nend", "  if lst == nil then return (None,\
    \ None) end\n  local min_val = lst.min()\n  local max_val = lst.max()\n  if min_val\
    \ == nil or max_val == nil then\n    return (None, None)\n  else\n    return (max_val,\
    \ min_val)\n  end\nend", "  local largest, smallest = nil, nil\n  for i = 1, #lst\
    \ do\n    if lst[i] > largest or largest == nil then\n      largest = lst[i]\n\
    \    end\n    if lst[i] < smallest or smallest == nil then\n      smallest = lst[i]\n\
    \    end\n  end\n  if largest ~= nil and smallest ~= nil then\n    return largest,\
    \ smallest\n  else\n    return nil, nil\n  end\nend", "    local negative, positive\
    \ = nil, nil\n    for i, v in ipairs(lst) do\n        if v < 0 then\n        \
    \    if negative == nil then\n                negative = i\n            else\n\
    \                local tmp = negative\n                negative = i\n        \
    \        positive = tmp\n            end\n        elseif v > 0 then\n        \
    \    if positive == nil then\n                positive = i\n            else\n\
    \                local tmp = positive\n                positive = i\n        \
    \        negative = tmp\n            end\n        else\n            return nil\n\
    \        end\n    end\n    return (negative, positive or 1)\nend", "  if not lst\
    \ then\n    return (None, None)\n  end", "  -- Base Cases\n  if #lst == 0 then\n\
    \    return nil, 0\n  elseif #lst == 1 then\n    return lst[0], 1\n  end\n  --\
    \ Recursive Cases\n  local m, k = nil, 0\n  for i = 1, #lst do\n    local l, s\
    \ = largest_smallest_integers(lst:sub(1, i))\n    if l then\n      if m == nil\
    \ or m > s then m, k = s, i end\n      break\n    end\n  end\n  return m or k,\
    \ k\nend", "  if lst == nil then return (None, None) end\n  local max = -math.huge\n\
    \  local min = math.huge\n  for _, v in ipairs(lst) do\n    if v > max then\n\
    \      max = v\n    end\n    if v < min then\n      min = v\n    end\n  end\n\
    \  if max >= min then\n    return (min, max)\n  else\n    return (None, None)\n\
    \  end\nend", "  if #lst == 0 then\n    return (None, None)\n  else\n    if lst[#lst]\
    \ < 0 then\n      local min = -(#lst - 1)\n      return (lst[min], min)\n    else\n\
    \      local max = 0\n      for i = #lst, 1, -1 do\n        if lst[i] > lst[max]\
    \ then\n          max = i\n        end\n      end\n      return (lst[max], max)\n\
    \    end\n  end\nend", "  local max\n  local min\n  local max_i\n  local min_i\n\
    \  for i = 1, #lst do\n    if max < lst[i] then\n      max = lst[i]\n      max_i\
    \ = i\n    end\n    if min > lst[i] then\n      min = lst[i]\n      min_i = i\n\
    \    end\n  end\n  if max == nil then return (max_i, min_i) end\n  if min == nil\
    \ then return (max_i, max_i) end\n  return (max_i, max_i)\nend", "  local max_negative\
    \ = nil\n  local min_positive = nil\n  for i = 1, #lst do\n    local value = lst[i]\n\
    \    if value < 0 then\n      if max_negative == nil then\n        max_negative\
    \ = value\n      else\n        if max_negative < value then\n          max_negative\
    \ = value\n        end\n      end\n    elseif value == 0 then\n      if min_positive\
    \ == nil then\n        min_positive = value\n      else\n        if min_positive\
    \ > value then\n          min_positive = value\n        end\n      end\n    end\n\
    \  end\n  return (max_negative, min_positive)\nend", "  if #lst == 0 then\n  \
    \  return (None, None)\n  end", "  local positive, negative = {}, {}\n  for i\
    \ = 1, #lst do\n    if lst[i] > 0 then\n      table.insert(positive, i)\n    elseif\
    \ lst[i] < 0 then\n      table.insert(negative, i)\n    end\n  end\n  if #positive\
    \ > 0 and #negative > 0 then\n    return (positive[#positive], negative[#negative])\n\
    \  elseif #positive > 0 then\n    return (positive[#positive], None)\n  elseif\
    \ #negative > 0 then\n    return (None, negative[#negative])\n  end\n  return\
    \ (None, None)\nend", "  if #lst == 0 then\n    return (None, None)\n  end", " \
    \ if #lst == 0 then\n    return (None, None)\n  end", "  -- Return the smallest\
    \ integer if there are positive integers\n  if #lst > 0 then\n    local smallest_integer\
    \ = lst[1]\n    local positive_integer_count = 0\n    for _, integer in pairs(lst)\
    \ do\n      if integer > 0 then positive_integer_count = positive_integer_count\
    \ + 1 end\n      if integer < smallest_integer then\n        smallest_integer\
    \ = integer\n      end\n    end\n    local largest_integer = nil\n    if positive_integer_count\
    \ > 0 then\n      largest_integer = smallest_integer\n      while #lst > 1 and\
    \ lst.[#lst] == largest_integer do\n        -- Remove 'largest_integer' from list\n\
    \        lst = lst:filter(function(value) return value != largest_integer end)\n\
    \        -- If there are now no positive integers left, then return None\n   \
    \     if #lst == 0 then return (largest_integer, None) end\n        -- Add 'largest_integer'\
    \ to list\n        lst = lst .. largest_integer\n        -- If the list still\
    \ has positive integers left, continue the loop\n        if #lst > 0 then continue\
    \ end\n        -- If there are no positive integers and there are no negative\
    \ integers\n        -- left, return the largest positive integer.\n        --\
    \ The list might be empty so check that first\n        -- If there is still no\
    \ positive integers, return None\n        if #lst == 0 then return (None, largest_integer)\
    \ end\n      end\n      return (largest_integer, smallest_integer)\n    end\n\
    \  end\n  -- Return the largest integer if there are no positive integers\n  if\
    \ #lst == 0 then return (None, 0) end\n  -- Return the smallest integer if there\
    \ is at least one positive integer\n  if #lst > 0 and lst.[1] > 0 then\n    local\
    \ smallest_integer = lst[1]\n    local positive_integer_count = 0\n    for _,\
    \ integer in pairs(lst) do\n      if integer > 0 then positive_integer_count =\
    \ positive_integer_count + 1 end\n      if integer < smallest_integer then\n \
    \       smallest_integer = integer\n      end\n    end\n    return (smallest_integer,\
    \ smallest_integer)\n  end\n  -- If there are no negative or positive integers,\
    \ return them all\n  return (None, None)\nend", "  local i = 1\n  local max_val\
    \ = lst[i]\n  while i < #lst do\n    local val = lst[i]\n    if val < 0 then\n\
    \      if max_val < 0 then\n        max_val = val\n      else\n        return\
    \ max_val, 1\n      end\n    elseif val > 0 then\n      if max_val > 0 then\n\
    \        max_val = val\n      else\n        return max_val, -1\n      end\n  \
    \  end\n    i = i + 1\n  end\n  if max_val > 0 then\n    return max_val, 1\n \
    \ else\n    return max_val, -1\n  end\nend", "  local smallest, largest = lst\
    \ and lst[1] or None, None\n  local function helper(index, lst)\n    if index\
    \ == #lst then\n      return (index == 1, smallest and smallest > 0 or None)\n\
    \    else\n      return (index > 1, helper(index - 1, lst) or largest < lst[index])\n\
    \    end\n  end\n  return helper(#lst, lst)\nend", "  local min = nil\n  local\
    \ max = nil\n  for i=1,#lst do\n    if lst[i] > 0 then\n      if min == nil or\
    \ min > lst[i] then\n        min = lst[i]\n      end\n      if lst[i] < 0 then\n\
    \        if max == nil or max < lst[i] then\n          max = lst[i]\n        end\n\
    \      end\n    end\n  end\n  if min ~= nil and max ~= nil then\n    return min,\
    \ max\n  end\nend", "   -- Return None if we have no integers\n   if #lst == 0\
    \ then\n      return (None, None)\n   end", "  if #lst == 0 then\n    return (None,\
    \ None)\n  end\n  local largest = nil\n  local smallest = nil\n  for i = 1, #lst\
    \ do\n    if largest~=nil then\n      if l[i] > largest then\n        largest\
    \ = l[i]\n      end\n    else\n      largest = l[i]\n    end\n    if smallest~=nil\
    \ then\n      if l[i] < smallest then\n        smallest = l[i]\n      end\n  \
    \  else\n      smallest = l[i]\n    end\n  end\n  return (largest, smallest)\n\
    end", "  if #lst == 0 then\n    return (None, None)\n  elseif #lst == 1 then\n\
    \    if lst[1] == 0 then\n      return (None, None)\n    else\n      local _,\
    \ i = math.min(lst)\n      local j, k = math.max(lst)\n      return (i, j)\n \
    \   end\n  else\n    local big, i = math.min(lst)\n    local small, j = math.max(lst)\n\
    \    if big < 0 then\n      if small > 0 then\n        return (None, None)\n \
    \     else\n        return (i, j)\n      end\n    elseif small < 0 then\n    \
    \  return (None, None)\n    else\n      local _, k = math.min(lst)\n      local\
    \ _, l = math.max(lst)\n      return (i, j)\n    end\n  end\nend", "  -- Return\
    \ smallest of negative or positive integers in 'lst'\n  if #lst == 0 then\n  \
    \  return (None, None)\n  elseif #lst == 1 then\n    if lst[1] < 0 then\n    \
    \  return (None, None)\n    else\n      return (lst[1], None)\n    end\n  else\n\
    \    -- Iterate through list, comparing each value to its \"largest\" value\n\
    \    local smallest = lst[1]\n    for idx = 2, #lst do\n      if lst[idx] > smallest\
    \ then\n        smallest = lst[idx]\n      end\n    end\n    -- Return tuple (largest,\
    \ smallest) where 'largest' is the largest\n    -- of negative integers, and 'smallest'\
    \ is the smallest of positive\n    -- integers in a list.\n    if smallest < 0\
    \ then\n      return (None, None)\n    else\n      return (smallest, largest)\n\
    \    end\n  end\nend", "  local max_so_far = -1\n  local min_so_far = nil\n  for\
    \ _, value in ipairs(lst) do\n    if value < 0 then\n      max_so_far = math.max(max_so_far,\
    \ value)\n    else\n      min_so_far = math.min(min_so_far, value)\n    end\n\
    \  end\n  if min_so_far == nil then\n    min_so_far = 0\n  elseif max_so_far ==\
    \ -1 then\n    max_so_far = 1\n  end\n  return (max_so_far, min_so_far)\nend",
  "  if #lst < 2 then\n    return (None, None)\n  end\n  local largest, smallest =\
    \ lst[1], lst[1]\n  for i = 2, #lst do\n    if lst[i] > largest then\n      largest\
    \ = lst[i]\n    end\n    if lst[i] < smallest then\n      smallest = lst[i]\n\
    \    end\n  end\n  return (largest, smallest)\nend", "  if #lst == 0 then\n  \
    \  return (None, None)\n  end\n  local positive, negative = lst[1], lst[2]\n \
    \ if positive > negative then\n    return (positive, negative)\n  else\n    return\
    \ (negative, positive)\n  end\nend", "  local negative_integers = nil\n  local\
    \ positive_integers = nil\n  for i = 1, #lst do\n    if lst[i] > 0 then\n    \
    \  positive_integers = positive_integers or {}\n      table.insert(positive_integers,\
    \ i)\n    elseif lst[i] < 0 then\n      negative_integers = negative_integers\
    \ or {}\n      table.insert(negative_integers, i)\n    end\n  end\n  if positive_integers\
    \ then\n    local a = #positive_integers\n    if a <= #negative_integers then\n\
    \      a = -#positive_integers\n      b = negative_integers[a]\n    else\n   \
    \   local b = #positive_integers\n    end\n  elseif negative_integers then\n \
    \   local a = #negative_integers\n    if a <= #positive_integers then\n      a\
    \ = -#negative_integers\n      b = positive_integers[a]\n    else\n      local\
    \ b = #negative_integers\n    end\n  else\n    return nil, nil\n  end\n  return\
    \ a, b\nend", "  local max_int = nil\n  local min_int = nil", "  local min_value\
    \ = math.min(lst)\n  local max_value = math.max(lst)\n  if min_value >= 0 and\
    \ max_value < 0 then\n    return min_value, max_value\n  end\n  return nil, min_value\n\
    end", "  local largest, smallest, positive, negative = 0, 0, false, false\n  for\
    \ _, v in pairs(lst) do\n    if v < 0 then\n      negative = true\n      largest\
    \ = v\n    elseif v > 0 then\n      largest = largest\n      smallest = v\n  \
    \  end\n    if largest == 0 then break end\n    if smallest == 0 then break end\n\
    \    positive = true\n  end\n  if positive and negative then\n    return (largest,\
    \ smallest)\n  else\n    return (largest, None)\n  end\nend", "  if lst:count()\
    \ > 0 then\n    local positive, negative = lst:sort(function(a,b) return a > b\
    \ end)\n    local min_value = negative or positive[1]\n    local max_value = positive\
    \ and positive[positive:len()-1] or min_value\n    return min_value, max_value\n\
    \  end\n  return nil, nil\nend", "  local i, max = 0, lst[1]\n  for i=2,#lst do\n\
    \    if lst[i] > max then\n      max = lst[i]\n    end\n  end\n  if #lst == 1\
    \ then\n    return (max, lst[1])\n  end\n  local min = lst[1]\n  for i=2,#lst\
    \ do\n    if lst[i] < min then\n      min = lst[i]\n    end\n  end\n  if min ==\
    \ nil then\n    return (max, nil)\n  end\n  return (max, min)\nend", "  -- Return\
    \ first element if it's negative, otherwise return last element.\n  return lst[1]\
    \ < lst[2] and lst[1] or lst[2]\nend", "  -- This will be the largest of negative\
    \ integers\n  local max_negative = nil\n  -- This will be the smallest of positive\
    \ integers\n  local min_positive = nil\n  -- This will be the smallest of negative\
    \ integers\n  local min_negative = nil\n  for i = 1, #lst do\n    local cur_neg\
    \ = lst[i]\n    if cur_neg > max_negative then\n      max_negative = cur_neg\n\
    \    end\n    local cur_pos = lst[#lst-i]\n    if cur_pos < min_positive then\n\
    \      min_positive = cur_pos\n    end\n    local cur_neg2 = lst[#lst-i-1]\n \
    \   if cur_neg2 < min_negative then\n      min_negative = cur_neg2\n    end\n\
    \  end\n  return max_negative, min_positive, min_negative\nend", "  -- Handle\
    \ empty lists gracefully.\n  if lst:len() == 0 then\n    return nil, 0\n  end",
  "  if lst == nil then return (None, None) end\n  local min_val = math.min(lst)\n\
    \  local max_val = math.max(lst)\n  if min_val < 0 then min_val = nil end\n  if\
    \ max_val < 0 then max_val = nil end\n  return (minval, maxval)\nend", "  for\
    \ i, v in ipairs(lst) do\n    if v > 0 and v < 0 then\n      return v, i\n   \
    \ end\n  end\nend", "  if #lst < 1 then\n    return (None, None)\n  end\n  local\
    \ max = -math.inf\n  local min = math.inf\n  for i = 1, #lst do\n    if lst[i]\
    \ > max then\n      max = lst[i]\n    end\n    if lst[i] < min then\n      min\
    \ = lst[i]\n    end\n  end\n  return (max, min)\nend", "  -- If the list is empty\
    \ return an empty tuple.\n  if not lst then return ({}, {}) end", "  if #lst ==\
    \ 0 then\n    return (None, None)\n  end\n  local max = lst[1]\n  local min =\
    \ lst[1]\n  for i = 2, #lst do\n    local tmp_max = max\n    local tmp_min = min\n\
    \    max = math.max(max, lst[i])\n    min = math.min(min, lst[i])\n    if max\
    \ > tmp_max then\n      max = tmp_max\n    end\n    if min < tmp_min then\n  \
    \    min = tmp_min\n    end\n  end\n  if max == lst.max and min == lst.min then\n\
    \    return (max, min)\n  end\n  return None\nend", "  local min = nil\n  local\
    \ max = nil\n  for _, v in pairs(lst) do\n    if v > 0 and v < min then\n    \
    \  min = v\n    end\n    if v < 0 and v > max then\n      max = v\n    end\n \
    \ end\n  if min == nil and max == nil then\n    return (None, None)\n  end\n \
    \ return (min, max)\nend", "  for i = 1, #lst do\n    if lst[i] < 0 then\n   \
    \   return (lst[i], i)\n    end\n  end\n  if #lst == 1 then\n    return (lst[1],\
    \ 1)\n  end\nend", "  -- TODO: Implement a more efficient algorithm for finding\
    \ the largest and smallest integer in a list\n  local n = #lst\n  local a, b =\
    \ 1, 1\n  if n <= 0 then\n    return nil, a\n  end\n  if n > 0 then\n    for i\
    \ = 1, n do\n      if lst[i] > b then\n        b = lst[i]\n      end\n      if\
    \ lst[i] < a then\n        a = lst[i]\n      end\n    end\n  end\n  return b,\
    \ a\nend", "    if lst == nil then\n        return nil, nil\n    end\n    local\
    \ largest = nil\n    local smallest = nil\n    for i = 1, #lst do\n        if\
    \ lst[i] < 0 then\n            largest = lst[i]\n        elseif largest == nil\
    \ then\n            largest = lst[i]\n        else\n            smallest = lst[i]\n\
    \        end\n    end\n    return largest, smallest\nend", "  local max_int =\
    \ nil\n  local min_int = nil\n  for _, num in ipairs(lst) do\n    -- If number\
    \ is negative, ignore it\n    if num < 0 then break end\n    -- If number is positive,\
    \ ignore it\n    if num > 0 then break end\n    -- If number is 0, ignore it\n\
    \    if num == 0 then break end", "  -- Create a map of negative to positive integers.\n\
    \  local map = terralib.newlist()\n  local pos = 1\n  for i = 1, #lst do\n   \
    \ if lst[i] < 0 then\n      pos = pos + 1\n      -- Insert into map with the negative\
    \ integer.\n      map:insert(pos, lst[i])\n    else\n      -- Return the smallest\
    \ positive integer.\n      local _, value = unpack(map)\n      return value, pos\n\
    \    end\n  end\n  return nil, pos\nend", "  for i = 1, #lst do\n    if lst[i]\
    \ > 0 then\n      return (lst[i], i)\n    end\n  end\n  return (lst[#lst], nil)\n\
    end", "   if #lst == 0 then\n      return (None, None)\n   end\n   local largest\
    \ = lst[1]\n   local smallest = lst[1]\n   for _, v in pairs(lst) do\n      largest,\
    \ smallest = v, largest\n   end\n   return (largest, smallest)\nend", "  if #lst\
    \ == 0 then\n    return (None, None)\n  elseif #lst == 1 then\n    local elt =\
    \ lst[1]\n    if elt < 0 then\n      return (elt, None)\n    else\n      return\
    \ (None, elt)\n    end\n  else\n    local max = nil\n    local min = nil\n   \
    \ for _, elt in ipairs(lst) do\n      if elt < min then\n        min = elt\n \
    \     elseif elt > max then\n        max = elt\n      end\n    end\n    return\
    \ (max, min)\n  end\nend", "  local smallest, largest = nil, nil\n  for i = 1,\
    \ #lst do\n    if lst[i] < smallest then\n      largest, smallest = smallest,\
    \ lst[i]\n    elseif lst[i] > largest then\n      largest, smallest = lst[i],\
    \ largest\n    end\n  end\n  if smallest ~= nil then\n    return (largest, smallest)\n\
    \  end\nend", "  -- Base case -- If there are no integers in the list, return\
    \ (None, None)\n  if #lst == 0 then\n    return nil, nil\n  end\n  -- Recursive\
    \ case -- If there's only 1 integer in the list, return it\n  if #lst == 1 then\n\
    \    return lst[1], lst[1]\n  end\n  -- Create a table of (min_integer, max_integer)\n\
    \  local min_max_table = {}\n  for i = 2, #lst do\n    if min_max_table[#min_max_table]\
    \ == nil then\n      min_max_table[#min_max_table] = lst[i] - lst[i - 1]\n   \
    \ end\n    min_max_table[#min_max_table] = math.max(min_max_table[#min_max_table],\
    \ lst[i] - lst[i - 1])\n  end\n  -- Sort it, so we get the largest negative and\
    \ the smallest positive\n  -- integer\n  table.sort(min_max_table)\n  -- Return\
    \ the smallest negative integer, and the\n  -- largest positive integer\n  return\
    \ min_max_table[1], min_max_table[2]\nend\n</cell>\n<text>\nLargest and Smallest\
    \ Numbers", "   if #lst == 0 then\n      return (None, None)\n   end\n   local\
    \ min, max = lst[1]\n   for i = 2, #lst do\n      local num = lst[i]\n      if\
    \ num < min then\n         min = num\n      elseif num > max then\n         max\
    \ = num\n      end\n   end\n   return (max, min)\nend", "    if lst == nil then\n\
    \        return nil, nil\n    end", "  if lst:len() == 0 then\n    return (None,\
    \ None)\n  end", "  if lst == nil then\n    return (None, None)\n  end\n  local\
    \ positive, negative = {}, {}\n  for i = 1, #lst do\n    local val = lst[i]\n\
    \    if val > 0 then\n      table.insert(positive, val)\n    elseif val < 0 then\n\
    \      table.insert(negative, -val)\n    end\n  end\n  if #positive > 0 and #negative\
    \ > 0 then\n    return table.max(positive), table.min(negative)\n  elseif #positive\
    \ > 0 then\n    return table.max(positive), None\n  elseif #negative > 0 then\n\
    \    return None, table.min(negative)\n  else\n    return (None, None)\n  end\n\
    end", "  if #lst == 0 then\n    return nil, nil\n  end\n  local smaller, bigger\
    \ = lst[1], lst[2]\n  for i = 1, #lst do\n    if lst[i] <= smaller then\n    \
    \  smaller = lst[i]\n    elseif lst[i] > bigger then\n      bigger = lst[i]\n\
    \    end\n  end\n  return bigger, smaller\nend", '  if #lst < 1 then return (None,
    None) end', "  local smallest, largest = nil, 0\n  for i, v in pairs(lst) do\n\
    \    if v > largest then largest = v end\n    if v < smallest then smallest =\
    \ v end\n  end\n  if smallest and largest then\n    return largest, smallest\n\
    \  end\n  return nil\nend", "  if #lst == 0 then return (None, None) end\n  local\
    \ min = math.max(lst[1])\n  local max = math.min(lst[-1])\n  local pairs = {}\n\
    \  local pos = 1\n  for i = 1, #lst do\n    local x = lst[i]\n    if x > min and\
    \ x < max then\n      table.insert(pairs, pos)\n    end\n    pos = pos + 1\n \
    \ end\n  return (pairs[1], pairs[#pairs])\nend", "  -- Initialize the smallest\
    \ and largest integers to None\n  local min_int, max_int = nil, nil -- nil means\
    \ there is no integer in this list\n  for i = 1, #lst do\n    -- If this integer\
    \ is negative, set it as smallest and put it into the list (we ignore positive\
    \ integers)\n    if lst[i] < 0 then\n      min_int = i\n    else\n      -- If\
    \ this integer is positive, put it into the list\n      lst[#lst + 1] = lst[i]\n\
    \    end\n    -- If this is the smallest integer so far, save it\n    if min_int\
    \ ~= nil and min_int < #lst then\n      min_int = #lst -- we ignore the positive\
    \ integers\n    end\n    -- If this is the largest integer so far, save it\n \
    \   if max_int ~= nil and max_int > #lst then\n      max_int = #lst -- we ignore\
    \ the positive integers\n    end\n  end\n  if #lst == 0 then\n    return (None,\
    \ None)\n  end\n  -- Return the result\n  return (lst .. min_int, lst .. max_int)\n\
    end", "  if #lst == 0 then\n    return (None, None)\n  end\n  local largest =\
    \ -math.max(lst)\n  local smallest = math.min(lst)\n  if largest < smallest then\n\
    \    return (largest, smallest)\n  end\n  return (None, None)\nend", "  -- For\
    \ an empty list, return an empty tuple\n  local if not lst then\n    return (None,\
    \ None)\n  end", "  if #lst == 0 then\n    return nil\n  elseif #lst == 1 then\n\
    \    return (1, lst[1])\n  else\n    local max = 0\n    local min = #lst\n   \
    \ local index = 1\n    while max < min do\n      if lst[max] < 0 then\n      \
    \  max = max + 1\n      else\n        min = min - 1\n      end\n      index =\
    \ index + 1\n    end\n    return ((#lst) - index, lst[max])\n  end\nend", "  if\
    \ #lst == 0 then\n    return (None, None)\n  end", "  local result = {}\n  for\
    \ _, value in pairs(lst) do\n    if value < 0 then\n      result[#result+1] =\
    \ nil\n    elseif value >= 0 then\n      result[#result+1] = value\n    end\n\
    \  end\n  if #result == 0 then\n    return (None, None)\n  else\n    return unpack(result)\n\
    \  end\nend", "  if #lst == 0 then return (None, None) end\n  local smallest =\
    \ math.min(lst)\n  local largest = math.max(lst)\n  return (largest, smallest)\n\
    end", "  if lst == nil then\n    return (None, None)\n  end", "  local smallest\
    \ = -math.huge\n  local largest = math.huge\n  for i = 1, #lst do\n    local val\
    \ = lst[i]\n    if val < smallest then\n      largest = val\n    end\n    if val\
    \ > largest then\n      smallest = val\n    end\n  end\n  return largest, smallest\n\
    end", "  -- Create a dictionary that stores every integer as a key, and its\n\
    \  -- associated value as the value.\n  local int_to_value = {}\n  for i = 1,\
    \ #lst do\n    int_to_value[lst[i]] = i\n  end", "  -- If the list is empty, return\
    \ it as None.\n  -- Note that this handles the empty list case and will return\n\
    \  -- (None, None) when an empty list is provided.\n  if lst:len() == 0 then\n\
    \    return (None, None)\n  end", "  local min, max = 0, 0\n  if #lst == 0 then\n\
    \    return None, None\n  end\n  for i = 1, #lst, 1 do\n    local v = lst[i]\n\
    \    if v < min then\n      min = v\n    end\n    if v > max then\n      max =\
    \ v\n    end\n  end\n  if min == max then\n    return None, None\n  end\n  return\
    \ min, max\nend", "  for _, v in pairs(lst) do\n    if v < 0 and v >= 0 then\n\
    \      return v, -1\n    end\n    if v > 0 then\n      return v, 1\n    end\n\
    \  end\n  return None, None\nend", "  local is_none = false\n  local min = math.min\n\
    \  local max = math.max\n  for i = 1, #lst do\n    if not is_none and lst[i] >\
    \ 0 then\n      if min then\n        min = min(lst[i], min)\n      else\n    \
    \    min = lst[i]\n      end\n      if max then\n        max = max(lst[i], max)\n\
    \      else\n        max = lst[i]\n      end\n    elseif is_none and lst[i] ==\
    \ nil then\n      is_none = true\n    end\n  end\n  return min, max\nend", " \
    \ if not lst then\n    return (None, None)\n  elseif #lst == 0 then\n    return\
    \ (None, None)\n  end", "  local max = -math.huge\n  local min = math.huge\n \
    \ for _, value in ipairs(lst) do\n    if value > max then\n      max = value\n\
    \    end\n    if value < min then\n      min = value\n    end\n  end\n  if max\
    \ <= 0 then\n    return nil, nil\n  elseif min >= 0 then\n    return max, min\n\
    \  else\n    return nil, min\n  end\nend", "  assert(lst)\n  if #lst == 0 then\n\
    \    return nil, nil\n  end\n  local a = lst[1]\n  local b = lst[1]\n  for i =\
    \ 2, #lst do\n    if lst[i] < a then\n      a = lst[i]\n    elseif lst[i] > b\
    \ then\n      b = lst[i]\n    end\n  end\n  return a, b\nend", "  if #lst == 0\
    \ then\n    return (None, None)\n  end\n  local a = lst[1]\n  for i=2,#lst do\n\
    \    if a > lst[i] then\n      a = lst[i]\n    end\n  end\n  return (a, lst[#lst])\n\
    end", "  if #lst < 1 then\n    return (None, None)\n  elseif #lst == 1 then\n\
    \    return (lst[1], lst[1])\n  else\n    local min_i = 1\n    local min_v = lst[1]\n\
    \    for i = 2, #lst do\n      if lst[i] < min_v then\n        min_v = lst[i]\n\
    \        min_i = i\n      end\n    end\n    return (min_v, min_i)\n  end\nend",
  "  if lst:isnumber() then\n    return (lst, lst)\n  end\n  local largest = nil\n\
    \  local smallest = nil\n  for i = 2, #lst do\n    local candidate = lst[i]\n\
    \    if largest == nil or candidate > largest then\n      largest = candidate\n\
    \    end\n    if smallest == nil or candidate < smallest then\n      smallest\
    \ = candidate\n    end\n  end\n  return (largest, smallest)\nend", "   local min\
    \ = nil\n   local max = nil\n   for i = 1, #lst do\n      local num = lst[i]\n\
    \      if num then\n         if min == nil or num < min then\n            min\
    \ = num\n         end\n         if max == nil or max < num then\n            max\
    \ = num\n         end\n      else\n         if min == nil then\n            min\
    \ = num\n         end\n         if max == nil then\n            max = num\n  \
    \       end\n      end\n   end\n   return min, max\nend", "  if #lst == 0 then\n\
    \    return nil\n  end", "  if #lst == 0 then return (None, None) end\n  local\
    \ largest = #lst - 1\n  local smallest = 1\n  local negative_integers = false\n\
    \  for i = 1, #lst do\n    local current = lst[i]\n    if current < 0 then negative_integers\
    \ = true\n    elseif current > largest then largest = current\n    elseif current\
    \ < smallest then smallest = current end\n  end\n  if negative_integers then\n\
    \    return (largest, smallest)\n  else\n    return (largest, smallest + 1)\n\
    \  end\nend", "  local smallest, largest = nil, 0\n  for _, v in ipairs(lst) do\n\
    \    if smallest then\n      if v < smallest then\n        smallest = v\n    \
    \  end\n    else\n      smallest = v\n    end\n    if v > largest then\n     \
    \ largest = v\n    end\n  end\n  if smallest == nil and largest == nil then\n\
    \    return nil\n  end\n  return largest, smallest\nend", "  if lst == nil then\n\
    \    return nil, nil\n  end\n  local max_negative = nil\n  local min_positive\
    \ = nil\n  for i = 1, #lst do\n    local elem = lst[i]\n    if elem < 0 then\n\
    \      if max_negative == nil then\n        max_negative = elem\n      else\n\
    \        if elem > max_negative then\n          max_negative = elem\n        end\n\
    \      end\n    elseif elem > 0 then\n      if min_positive == nil then\n    \
    \    min_positive = elem\n      else\n        if elem < min_positive then\n  \
    \        min_positive = elem\n        end\n      end\n    end\n  end\n  return\
    \ max_negative, min_positive\nend", "  local largest, smallest = nil, nil -- initialize\
    \ with nil values to start with\n  for _, x in pairs(lst) do\n    if x < 0 then\
    \ largest = x end\n    if x > 0 then smallest = x end\n  end\n  return largest,\
    \ smallest\nend", "  if #lst == 0 then\n    return (None, None)\n  end\n  -- Find\
    \ the minimum element\n  local minimum = lst[1]\n  for i = 2, #lst do\n    if\
    \ minimum > lst[i] then\n      minimum = lst[i]\n    end\n  end\n  -- Find the\
    \ largest element\n  local maximum = minimum\n  for i = 2, #lst do\n    if maximum\
    \ < lst[i] then\n      maximum = lst[i]\n    end\n  end\n  return (minimum, maximum)\n\
    end", "  -- Base case: We have a list with nothing in it.\n  if not lst then return\
    \ (None, None) end", "    local min_value = nil\n    local max_value = nil\n \
    \   for i = 1, #lst do\n        if lst[i] ~= nil then\n            if min_value\
    \ == nil then\n                min_value = lst[i]\n            else\n        \
    \        if lst[i] < min_value then\n                    min_value = lst[i]\n\
    \                end\n            end\n            if max_value == nil then\n\
    \                max_value = lst[i]\n            else\n                if lst[i]\
    \ > max_value then\n                    max_value = lst[i]\n                end\n\
    \            end\n        end\n    end\n    if min_value == nil and max_value\
    \ == nil then\n        return nil, nil\n    elseif min_value == nil then\n   \
    \     return max_value, nil\n    elseif max_value == nil then\n        return\
    \ nil, min_value\n    else\n        return max_value, min_value\n    end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
