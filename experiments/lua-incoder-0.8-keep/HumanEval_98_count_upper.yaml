name: HumanEval_98_count_upper
language: lua
prompt: "-- Given a string s, count the number of uppercase vowels in even indices.\n\
  -- For example:\n-- count_upper('aBCdEf') returns 1\n-- count_upper('abcdefg') returns\
  \ 0\n-- count_upper('dBBE') returns 0\nlocal function count_upper(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_upper\n\
  \    lu.assertEquals(candidate('aBCdEf'), 1)\n    lu.assertEquals(candidate('abcdefg'),\
  \ 0)\n    lu.assertEquals(candidate('dBBE'), 0)\n    lu.assertEquals(candidate('B'),\
  \ 0)\n    lu.assertEquals(candidate('U'), 1)\n    lu.assertEquals(candidate(''),\
  \ 0)\n    lu.assertEquals(candidate('EEEE'), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal n = 0\n\ts:gsub('[A-Z]', function(c) n = n + 1 end)\n\treturn\
    \ n % 2 == 0\nend", "  local count = 0\n  for i = 1, #s do\n    if s[i] == 'a'\
    \ then count = count + 1 end\n    if s[i] == 'e' then count = count + 1 end\n\
    \    if s[i] == 'i' then count = count + 1 end\n    if s[i] == 'o' then count\
    \ = count + 1 end\n    if s[i] == 'u' then count = count + 1 end\n  end\n  return\
    \ count\nend", "    local num_upper = 0\n    for i=1,#s do\n        if string.sub(s,\
    \ i, i+1) ~= 'A' and string.sub(s, i, i+1) ~= 'a' then\n            num_upper\
    \ = num_upper + 1\n        end\n    end\n    return num_upper\nend\n</code>\n\
    <|/ a |>\n<| a |>\nJust for fun, here's my attempt at the question with a different\
    \ solution.  It also includes some error checking.\n<code>", "  local n = 0\n\
    \  for i=1,#s do\n    if string.sub(s,i,i)=='a' or string.sub(s,i,i)=='A' then\n\
    \      n = n+1\n    end\n  end\n  return n\nend", "  for i, c in ipairs(s:gmatch'[%s]{2,}')\
    \ do\n    local uc, _ = c:upper():find(unicode.char(i))\n    if uc ~= nil then\n\
    \      return uc:byte() == 1\n    end\n  end\n  return false\nend", "  local num_vowels\
    \ = 0\n  for i = 1, #s do\n    if string.sub(s, i, i+1) == \"a\" then\n      num_vowels\
    \ = num_vowels + 1\n    end if string.sub(s, i, i+1) == \"e\" then\n      num_vowels\
    \ = num_vowels + 1\n    end if string.sub(s, i, i+1) == \"i\" then\n      num_vowels\
    \ = num_vowels + 1\n    end if string.sub(s, i, i+1) == \"o\" then\n      num_vowels\
    \ = num_vowels + 1\n    end if string.sub(s, i, i+1) == \"u\" then\n      num_vowels\
    \ = num_vowels + 1\n    end\n  end\n  return num_vowels\nend", "    local num_upper\
    \ = 0\n    for i = 1, #s do\n        if s[i] <= 'z' and s[i] >= 'a' then\n   \
    \         num_upper = num_upper + 1\n        end\n    end\n    return num_upper\n\
    end\n</cell>\n<text>\nProblem 7", "  local count = 1\n  s:gsub(\"^([a-z]+)%((.).*[^a-z])$\"\
    , function(_, s)\n    count = count + s:upper():match(\"[aeiou]\"):gsub(\"[aeiou]\"\
    ,\"\"):len()\n  end)\n  return count\nend", "   for i = 1,string.len(s) do\n \
    \     if string.sub(s,i,i) == 'A' then return 1+count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'E' then return 1+count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'I' then return 1+count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'O' then return 1+count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'U' then return 1+count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'a' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'b' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'c' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'd' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'e' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'f' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'g' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'h' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'i' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'j' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'k' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'l' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'm' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'n' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'o' then return count_upper(string.sub(s,i+1,i+1))\n\
    \      elseif string.sub(s,i,i) == 'p' then return count_upper(string.sub(s,i+",
  "\tlocal count=0\n\tlocal i=1\n\tfor c in s:gmatch'[AEIOU]'\n\tdo\n\t\tcount=count+1\n\
    \tend\n\treturn count\nend", "    local n = 0\n    for i, v in ipairs(string.gmatch(s,\
    \ '%u')) do\n        if v == string.upper(v) then n = n + 1 end\n    end\n   \
    \ return n\nend", "  local even = {}\n  local i = 0\n  while i < #s do\n    if\
    \ string.sub(s,i,i+1) ~= 'A' then\n      even[#even+1] = string.sub(s,i,i+1)\n\
    \      i = i + 1\n    end\n    i = i + 1\n  end\n  i = 1\n  -- For each even index,\
    \ if s is longer than it, return 0\n  -- If s isn't even longer, return #even\n\
    \  return #even > #s and i or #even\nend", "  local n = 0\n  for i in string.gmatch(s,\
    \ '%a') do\n    i = string.byte(i)\n    if i ~= 0 and ((i ~= 1) and ((i ~= 4)\
    \ and ((i ~= 7) and ((i ~= 8))))) then\n      n = n + 1\n    end\n  end\n  return\
    \ n\nend", "  -- This solution is O(n)\n  local upper = 0\n  for i = 1, #s do\n\
    \    if string.upper(s[i])==s[i] then\n      upper = upper + 1\n    end\n  end\n\
    \  return upper\nend", "  local count = 0\n  for i = 1,#s do\n    if string.sub(s,\
    \ i, i) == 'A' or string.sub(s, i, i) == 'a' then\n      count = count + 1\n \
    \   end\n  end\n  return count\nend", "  return string.gsub(s, \".\", function\
    \ (c)\n    return (string.char(c) >= \"A\" and string.char(c) <= \"Z\" and c ~=\
    \ string.upper(c)) or (c == \"D\")\n  end)\nend", "  local n = 0\n  for i = 1,\
    \ #s do\n    if string.sub(s,i,i) == 'A' then\n      n = n + 1\n    end\n  end\n\
    \  return n\nend", "  -- Initialize the count at 1.\n  local count = 0\n  for\
    \ i = 1, #s do\n    -- If the character is an upper case vowel, then add 1 to\
    \ the count.\n    if s[i] == 'A' or s[i] == 'E' or s[i] == 'I' or s[i] == 'O'\
    \ or s[i] == 'U' then\n      count = count + 1\n    end\n  end", "    local i\
    \ = 1\n    while i <= #s do\n        if string.sub(s, i, i) ~= 'A' then\n    \
    \        return i - 1\n        end\n        i = i + 1\n    end\n    return 0\n\
    end", "  if s:find('^') == nil then\n    return 0\n  end\n  local vowels = s:gsub('([aeiouAEIOU])',\
    \ function(c) \n    if c:sub(1, 1) == 'a' then\n      return 1\n    else \n  \
    \    return 0\n    end\n  end)\n  return #vowels & 1\nend", "  local counted =\
    \ {}\n  for _, ch in ipairs(s) do\n    if ch == 'a' then\n      counted[1] = counted[1]\
    \ + 1\n    else if ch == 'e' then\n      counted[2] = counted[2] + 1\n    else\
    \ if ch == 'i' then\n      counted[3] = counted[3] + 1\n    else if ch == 'o'\
    \ then\n      counted[4] = counted[4] + 1\n    else if ch == 'u' then\n      counted[5]\
    \ = counted[5] + 1\n    end\n  end\n  local result = counted[1] + (counted[2]\
    \ or 0)\n  assert(result >= 0 and result <= 5)\n  return result\nend", "  return\
    \ s:gsub('^%u', '', 1):gsub('u+$', 'u'):gsub('[^u]', '')\nend", "    local upper,\
    \ lower = {}, {}\n    for i = 1, #s do\n        if s:sub(i,i) == s:sub(i,i) then\n\
    \            upper[#upper + 1] = 'a'\n        end\n    end\n    for i = 1, #s\
    \ do\n        if s:sub(i,i) == s:sub(i,i) then\n            lower[#lower + 1]\
    \ = 'a'\n        end\n    end\n    return #upper * 2 - #lower\nend", "  -- Reverse\
    \ the string, then convert to a string. Since a string\n  -- has no indices in\
    \ an optimized implementation, the easiest way to\n  -- find all the indices is\
    \ to use a string conversion.\n  local str_reverse = str:reverse()\n  local str_conv\
    \ = str:to_string(true)\n  -- To avoid having to reverse the string twice, use\
    \ a loop.\n  -- This code will be faster than the code using string.match because\n\
    \  -- of how match works.\n  for i = 0, str:len() do\n    -- Only consider uppercase\
    \ if the index is even.\n    if i %% 2 == 0 then\n      -- Convert to lowercase\
    \ and count the characters in it.\n      local str_match = str_conv:match(str_reverse:sub(i))\n\
    \      -- The match function returns nil if there is no match.\n      if str_match\
    \ then\n        return str_match:len() + 1\n      end\n    end\n  end\n  return\
    \ 0\nend", "  local vowels = \"aieou\"\n  local n = #s\n  for i = 1, n do\n  \
    \  if string.sub(vowels, i, i + 1) ~= \"\" then\n      return i\n    end\n  end\n\
    \  return n\nend", "   local counted = {}\n   for i=1,#s do\n      if string.sub(s,\
    \ i, i) ~= string.upper(s) then\n\t table.insert(counted, 0)\n      else\n\t table.insert(counted,\
    \ 1)\n      end\n   end\n   return table.concat(counted, 0)\nend", "  local count\
    \ = 0\n  for i = 1, #s do\n    if string.sub(s,i,i) == string.sub(s,i,i) then\
    \ count = count + 1 end\n  end\n  return count\nend", "  if s == nil then return\
    \ 0 end\n  local count = 1\n  for i in string.gmatch(s, '[^aeiouAEIOU]+') do\n\
    \    count = count * 2\n    if i:sub(1, 1) == 'E' then count = count - 1 end\n\
    \  end\n  return count\nend", "   local count = 0\n   for i = 1, #s do\n     \
    \ if string.sub(s,i,i) == 'A' or string.sub(s,i,i) == 'a'\n      then\n      \
    \   count = count + 1\n      end\n   end\n   return count\nend", "  local n =\
    \ 1\n  for i = 1,#s do\n    if string.sub(s,i,i)=='a' then\n      n = n + 1 --\
    \ Counting only the 'a' character (even)\n    elseif string.sub(s,i,i)=='A' then\n\
    \      n = n + 1 -- Counting only the 'A' character (odd)\n    end\n  end\n  return\
    \ n\nend", "  local count = 0\n  for i = 1, #s do\n    if string.sub(s, i, i +\
    \ 1) ~= 'A' and string.sub(s, i, i + 1) ~= 'a'\n    then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  -- initialize count with zero\n\
    \  local count = 0\n  -- iterate through each letter\n  for i=1,#s do\n    --\
    \ if the letter is uppercase\n    if string.sub(s,i,i) == string.sub(s,i,i) then\n\
    \      -- increment count by 1\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "    local count = 0\n    for i = 1,#s do\n        if string.sub(s,i,i)\
    \ == \"a\" or string.sub(s,i,i) == \"e\" or string.sub(s,i,i) == \"i\" or string.sub(s,i,i)\
    \ == \"o\" or string.sub(s,i,i) == \"u\" then\n            count = count + 1\n\
    \        end\n    end\n    return count\nend", "  if s:sub(1,1) == \"a\" and s:sub(2,2)\
    \ == \"b\" then\n    return 1\n  end\n  if s:sub(1,1) == \"b\" and s:sub(2,2)\
    \ == \"c\" then\n    return 1\n  end\n  if s:sub(1,1) == \"c\" and s:sub(2,2)\
    \ == \"d\" then\n    return 1\n  end\n  if s:sub(1,1) == \"d\" and s:sub(2,2)\
    \ == \"e\" then\n    return 1\n  end\n  return 0\nend", "  local uppercase_count\
    \ = 0\n  local i, j = 0, 0\n  while j < #s do\n    if string.sub(s, i, j) ~= 'A'\
    \ and string.sub(s, i, j) ~= 'a' then\n      uppercase_count = uppercase_count\
    \ + 1\n    end\n    i = j + 1\n    j = i + 2\n  end\n  return uppercase_count\n\
    end", "  assert(#s >= 1, 's is empty')\n  local count = 0\n  for i=1,#s do\n \
    \   if string.sub(s, i, i+1) == 'A' then\n      count = count + 1\n    end\n \
    \ end\n  return count\nend", "  local n = 0\n  for i = 1, #s do\n    if string.sub(s,\
    \ i, i) ~= string.upper(string.sub(s, i, i)) then n = n + 1 end\n  end\n  return\
    \ n\nend", "  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local vowels_count =\
    \ 0\n  for i = 1, #s do\n    local c = s[i]\n    if c == 'A' then\n      vowels_count\
    \ = vowels_count + 1\n    else if vowels[c] then -- c is vowel\n      if c ==\
    \ 'U' then -- count all vowels\n        vowels_count = vowels_count + 1\n    \
    \  else\n        vowels_count = vowels_count + 1\n      end\n    end\n  end\n\
    \  return vowels_count\nend", "  assert(s:match('([A-Z]+)'))\n  return s:gsub('(%w+)',\
    \ function(c) return c:upper():match('(.)'):sub(1,1) end):match'(.):*$'\nend",
  "   if s:sub(1,1) ~= 'A' then return 0 end\n   for i=2,#s do\n      if s[i]:sub(1,1)\
    \ ~= 'a' then return 0 end\n   end\n   return 1\nend", "    local count = 0\n\
    \    for i, c in string.gmatch(s, \"([A-Z]+)\") do\n        if i % 2 == 0 then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  for i = 1, #s do\n    if string.sub(s, i, i) ~= 'A' or string.sub(s, i, i) ~=\
    \ 'a' then\n      return 0\n    end\n  end\n  return 1\nend", "  assert(type(s)\
    \ ~= 'string')\n  s = string.gsub(s, '[%s]', '')\n  local upper = 0\n  for i=1,\
    \ #s, 2 do\n    if string.sub(s, i, i+1) ~= 'A' then\n      return upper\n   \
    \ end\n    upper = upper + 1\n  end\n  return upper\nend", "    local even = s:match('^(.)%(([%u]+)$)')\n\
    \    local odd = s:match('^(.)%((%*)$)')\n    return #even - #odd\nend", "  local\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n  local n = 0\n  for i = 1, #s do\n    if\
    \ string.sub(vowels, i .. 1, i) ~= s[#s]:lower() then\n      n = n + 1\n    end\n\
    \  end\n  return n\nend\ncount_upper = string.gsub", '    if s == nil then return
    end', "  local vowels = \"aeiouAEIOU\"\n  local count = 1\n  for i = 1, #s do\n\
    \    if string.sub(vowels, i, i) ~= string.sub(vowels, i + 1, i + 1) then\n  \
    \    count = count + 1\n    end\n  end\n  return count\nend", "    local count\
    \ = 0\n    for i, c in pairs(s) do\n        if c:upper() == 'A' then\n       \
    \     count = count + 1\n        end\n    end\n    return count\nend\n</cell>\n\
    <text>\nExercise 2: Write a function that checks whether the string is a palindrome.\
    \ If it is, then return the string. If not, then return nil. Do not use \"==\"\
    \ or \"~=\" to compare strings but rather use a single equals sign (=) to assign\
    \ the string. For example:", "  local cnt = 0\n  for i = 1, #s do\n    if string.sub(s,\
    \ i, i) == string.upper(string.sub(s, i, i)) then\n      cnt = cnt + 1\n    end\n\
    \  end\n  return cnt\nend", "   local count = 0\n   for i = 1, #s do\n      if\
    \ string.sub(s, i, i) ~= 'A' then return 0 end\n      count = count + 1\n   end\n\
    \   return count\nend", "  local count = 0\n  for i = 1, #s do\n    if string.upper(s[i])\
    \ = 'A' then\n      count = count + 1\n    end\n  end\n  return count\nend", " \
    \ local upper = s:upper()\n  local count = 0\n  for _, c in ipairs(upper) do\n\
    \    if c == 'A' or c == 'E' or c == 'I' or c == 'O' or c == 'U' then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "    local count=0\n    for\
    \ i=1,#s do\n        if string.sub(s,i,i)=='A' and string.sub(s,i,i+1)=='a' then\n\
    \            count=count+1\n        elseif string.sub(s,i,i)=='B' and string.sub(s,i,i+1)=='b'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='C' and string.sub(s,i,i+1)=='c'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='D' and string.sub(s,i,i+1)=='d'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='E' and string.sub(s,i,i+1)=='e'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='F' and string.sub(s,i,i+1)=='f'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='G' and string.sub(s,i,i+1)=='g'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='H' and string.sub(s,i,i+1)=='h'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='I' and string.sub(s,i,i+1)=='i'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='J' and string.sub(s,i,i+1)=='j'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='K' and string.sub(s,i,i+1)=='k'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='L' and string.sub(s,i,i+1)=='l'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='M' and string.sub(s,i,i+1)=='m'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='N' and string.sub(s,i,i+1)=='n'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='O' and string.sub(s,i,i+1)=='o'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='P' and string.sub(s,i,i+1)=='p'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='Q' and string.sub(s,i,i+1)=='q'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='R' and string.sub(s,i,i+1)=='r'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='S' and string.sub(s,i,i+1)=='s'\
    \ then\n            count=count+1\n        elseif string.sub(s,i,i)=='", "  if\
    \ s ~= nil then\n    local c = 0\n    for i = 1, #s do\n      if ((s[i] >= 65)\
    \ and (s[i] <= 90)) then\n        c = c + 1\n      end\n    end\n    return c\n\
    \  end\n  return -1\nend", "  local count = 0\n  for i = 1, #s do\n    if string.sub(s,\
    \ i, i) ~= 'A' then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  local count = 0\n  for i = 1, #s do\n    if s[i] ~= 'A' then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "    local n = 0\n    for\
    \ i=1,#s do\n        if string.sub(s,i,i) ~= 'A' then\n            n = n+1\n \
    \       end\n    end\n    return n\nend", "  assert(s ~= nil)\n  local count =\
    \ 0\n  for i = 1, #s, 2 do\n    local c = tostring(s:sub(i,i))\n    if c:find('[^aeiou]')\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "  return\
    \ string.gsub(s, [[[([^]]*)]]*%[[a-z]{2,}]])\nend", "  if s:sub(1,1) == 'a' and\
    \ s:sub(2,2) == 'b' and s:sub(1,2) == 'c' then\n    return 1\n  elseif s:sub(1,1)\
    \ == 'd' and s:sub(2,2) == 'e' and s:sub(1,2) == 'f' then\n    return 0\n  else\n\
    \    return 0\n  end\nend", "  local num = 0\n  for i = 1, #s do\n    if string.sub(s,\
    \ i, i) ~= 'A' then continue end\n    num = num + 1\n  end\n  return num\nend",
  "  local count = 0\n  -- If the string ends in a vowel, then the last character\
    \ is\n  -- a vowel. Otherwise, we assume that it is an upper case letter.\n  if\
    \ s:sub(-1, 1, \"aeiou\") then count = count + 1 end\n  for i = 1, #s do -- Count\
    \ the number of uppercase vowels.\n    if i % 2 == 1 then\n      if s:sub(i, i,\
    \ \"aeiou\") then count = count + 1 end\n    end\n  end\n  return count\nend",
  "  local i, j = 0, #s\n  while i < j do\n    if s[i] == 'A' or s[i] == 'a' then\n\
    \      i = i + 1\n      j = j - 1\n    else if s[i] == 'B' or s[i] == 'b' then\n\
    \      i = i + 1\n      j = j - 1\n    else if s[i] == 'C' or s[i] == 'c' then\n\
    \      i = i + 1\n      j = j - 1\n    else if s[i] == 'D' or s[i] == 'd' then\n\
    \      i = i + 1\n      j = j - 1\n    else if s[i] == 'E' or s[i] == 'e' then\n\
    \      i = i + 1\n      j = j - 1\n    else if s[i] == 'F' or s[i] == 'f' then\n\
    \      i = i + 1\n      j = j - 1\n    else if s[i] == 'G' or s[i] == 'g' then\n\
    \      i = i + 1\n      j = j - 1\n    else\n      i = i + 1\n    end\n  end\n\
    \  return j\nend", "  local upper = {}\n  local i = 0\n  while s[i] ~= nil do\n\
    \    if s[i] == 'a' then upper[i] = 1 end\n    if s[i] == 'A' then upper[i] =\
    \ 1 end\n    if s[i] == 'e' then upper[i] = 1 end\n    if s[i] == 'E' then upper[i]\
    \ = 1 end\n    if s[i] == 'i' then upper[i] = 1 end\n    if s[i] == 'I' then upper[i]\
    \ = 1 end\n    if s[i] == 'o' then upper[i] = 1 end\n    if s[i] == 'O' then upper[i]\
    \ = 1 end\n    if s[i] == 'u' then upper[i] = 1 end\n    if s[i] == 'U' then upper[i]\
    \ = 1 end\n    i = i + 1\n  end\n  \n  local j = 1\n  while j <= #upper do\n \
    \   if upper[j] == 1 then upper[j] = j end\n    j = j + 1\n  end\n  \n  return\
    \ #upper + 1\nend", "\tlocal num_upper = 0\n\tfor _, c in string.gmatch(s, '[AEIOUaeiou]+')\
    \ do\n\t\tif c:sub(1, 1):upper() ~= c:sub(1, 1):lower() then\n\t\t\tnum_upper\
    \ = num_upper + 1\n\t\tend\n\tend\n\treturn num_upper\nend", "\tlocal n = 0\n\t\
    s:gsub('([^%z])', function(c) n = n + 1 end)\n\treturn n % 2 == 0 and n or 0\n\
    end", "    local t = 0 -- number of uppercase vowels\n    for i = 1, #s do\n \
    \       if string.sub(s, i, i) ~= 'A' and string.sub(s, i, i) ~= 'a' then\n  \
    \          -- even indices are consonants\n            -- odd indices are vowels\n\
    \            if string.sub(s, i, i) ~= 'A' and string.sub(s, i, i) ~= 'a' then\n\
    \                t = t + 1\n            end\n        end\n    end\n    return\
    \ t\nend", "    local upper = 0\n    local i, j = 0, #s\n    while i <= j do\n\
    \        if s[i] == 'A' or s[i] == 'a' then\n            upper = upper + 1\n \
    \       end\n        i = i + 1\n    end\n    return upper\nend", "  local uppercased\
    \ = 0\n  for i = 0, #s do -- iterate over all characters in s\n    if string.sub(s,i,i)\
    \ == string.sub(s,i,i) then -- if the character matches the character itself\n\
    \      if i % 2 == 0 then -- if it's even\n        uppercased = uppercased + 1\n\
    \      end\n    end\n  end\n  return uppercased\nend", "\tlocal vowels = {'A','a','E','e','I','i','O','o','U','u'}\n\
    \tlocal count = 0\n\tfor c in s:gmatch(\"[%aEIIOU]+\") do\n\t\tcount = count +\
    \ (#vowels - #c) / 2\n\tend\n\treturn count\nend", "    local i = 0\n    while\
    \ s[i] do\n        if ((i + 1) % 2 == 0) then\n            if string.sub(s, i,\
    \ i + 1) ~= 'aeiouAEIOU' then\n                return 0\n            end\n   \
    \     end\n        i = i + 1\n    end\n    return 1\nend", "    return s:sub(1,\
    \ #s)/#(s..'AEIOU'):gsub('U', 'x'):gsub('x', 'U')\nend", "  local count = 0\n\
    \  for i = 1, #s do\n    if tonumber(s[i:i + 1]) >= tonumber(string.sub(s, 'a',\
    \ i + 1)) or tonumber(s[i + 1:i + 3]) >= tonumber(string.sub(s, 'a', i + 1)) then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "\tlocal n = 0\n\
    \tfor i = 1, #s do\n\t\tn = n + (string.sub(s, i, i):upper():find(string.upper(string.sub(s,i,i)))>0)\n\
    \tend\n\treturn n\nend", "    return s:gsub('([bcdfghijklmnopqrstuvwxyz])\\1',\
    \ '%1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\\
    1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n  \
    \  :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\\
    1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n  \
    \  :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\\
    1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n  \
    \  :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\\
    1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n  \
    \  :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\\
    1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n  \
    \  :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\1$)', '\\1')\n    :gsub('(.)(?=([bcdfghijklmnopqrstuvwxyz])\\\
    1$)', '", "   for i = 1, #s do\n      if s[i] >= 'a' and s[i] <= 'z' then\n  \
    \       if s[i] == 'z' then\n            return 1\n         else\n           \
    \ -- Count the vowels in even indices (1, 3, 5)\n            if i % 2 == 0 then\n\
    \               return (s[i] - 'a' + 1) / 2\n            else\n              \
    \ return 0\n            end\n         end\n      end\n   end\nend", "    if s\
    \ then\n        local count, i = 1\n        for i = 1, #s do\n            if ((s[i]\
    \ >= 'a' and s[i] <= 'z') or (s[i] >= 'A' and s[i] <= 'Z')) then\n           \
    \     count = count + 1\n            end\n        end\n        return count\n\
    \    end\n    return 0\nend", "    local count = 0\n    for i=1,string.len(s)\
    \ do\n        if string.sub(s,i,i) == string.sub(s,i,i) then\n            if string.sub(s,i,i)=='a'\
    \ then count = count+1 end\n        end\n    end\n    return count\nend", "  local\
    \ count\n  for _, c in ipairs(s:gmatch'[%w]') do\n    if c:upper() ~= c then\n\
    \      count = count\n    end \n  end \n  return count\nend", "   local u = 0\n\
    \   for i = 1, #s, 2 do -- Iterate over string from both ends\n      if string.sub(s,\
    \ i, i+1) = 'A' or string.sub(s, i, i+1) = 'a' then -- Check for uppercase letters\n\
    \         u = u + 1\n      end\n   end\n   return u\nend", "  local c = 0\n  for\
    \ i = 1, #s do\n    if string.sub(s,i,i) == \"A\" then\n      c = c + 1\n    end\n\
    \  end\n  return c\nend", "\tlocal count=0\n\tfor i=1,#s do\n\t\tif string.sub(s,\
    \ i, i+1) ~= s:sub(i, i-1:len(s)) then\n\t\t\tcount = count+1\n\t\tend\n\tend\n\
    \treturn count\nend", "  local upper = 0\n  for i = 1, #s do\n    local c = s[i]\n\
    \    if c == 'A' or c == 'a' then\n      upper = upper + 1\n    elseif c == 'B'\
    \ or c == 'b' then\n      upper = upper + 1\n    elseif c == 'C' or c == 'c' then\n\
    \      upper = upper + 1\n    elseif c == 'D' or c == 'd' then\n      upper =\
    \ upper + 1\n    elseif c == 'E' or c == 'e' then\n      upper = upper + 1\n \
    \   elseif c == 'F' or c == 'f' then\n      upper = upper + 1\n    else\n    \
    \  upper = upper + 1\n    end\n  end\n  return upper\nend", "  local n = 0\n \
    \ for _, c in pairs(s:gmatch'[AEIOUaeiou]') do\n    if string.sub(c, 2, 2) ~=\
    \ 'x' then\n      n = n + 1\n    end\n  end\n  return n\nend", "  local count\
    \ = 0\n  for i = 1, #s do\n    if string.sub(s, i, i) == 'A' then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "    if #s <= 1 then\n  \
    \      return 0\n    end\n    -- If the first letter is uppercase, return 1.\n\
    \    if s[1] ~= tolower(s[1]) then\n        return 1\n    end\n    -- Iterate\
    \ over the string in reverse.\n    for i = #s - 1, 1, -1 do\n        if s[i] ~=\
    \ tolower(s[i]) then\n            return 0\n        end\n    end\n    return 1\n\
    end", "  local n = 0\n  for i = 1, #s do\n    if string.sub(s, i, i + 1) ~= 'A'\
    \ then\n      n = n + 1\n    end\n  end\n  return n\nend\n</cell>\n<cell>", " \
    \ local count = 0\n  for i = 1, #s do\n    count = count + is_vowel(s[i], true)\n\
    \  end\n  return count\nend", "  local upper = 0\n  for i = 1, #s do\n    if string.sub(s,i,i)\
    \ ~= 'A' and string.sub(s,i,i) ~= 'a' then\n      upper = upper + 1\n    end\n\
    \  end\n  return upper\nend", "  local count = 0\n  for i = 1, #s do\n    if string.sub(s,\
    \ i, i) == uppercase then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  local vowels = \"AEIOUaeiou\"\n  local count = 1\n  local index = 1 --\
    \ index\n  while index <= #s do\n    index = index:find(vowels, 1, index)\n  \
    \  if index == nil then\n      return count\n    end\n    index = index + 1 --\
    \ increment index\n    count = count + 1\n  end\n  return count\nend", "   local\
    \ count = 0\n   for i = 1,#s do\n      count = count + ( string.sub(s,i,i) ==\
    \ string.sub(s,i,i) ):byte()\n   end\n   return count\nend", "  if s == '' then\n\
    \    return 0\n  end", "    local n = 0\n    for i = 1, #s do\n        if string.sub(s,\
    \ i, i) ~= 'A' then\n            n = n + 1\n        end\n    end\n    return n\n\
    end", "\tlocal cap_vowels = #string.gmatch(s, '[AEIOUaeiou]')\n\tif cap_vowels\
    \ == nil then\n\t\treturn 0\n\telseif cap_vowels % 2 == 0 then\n\t\treturn cap_vowels\
    \ / 2\n\telse\n\t\treturn cap_vowels\n\tend\nend", "    local vowels = {'a', 'e',\
    \ 'i', 'o', 'u'}\n    local count = 0\n    for i = 1, #s do\n        if string.sub(s,i,i)\
    \ == string.sub(s,i,i) then\n            count = count + 1\n        end\n    end\n\
    \    count = count - #s\n    return count\nend", "    local n = 0\n    for i =\
    \ 1, #s do\n        if string.sub(s,i,i) == 'A' then\n            n = n + 1\n\
    \        end\n    end\n    return n\nend", "  local count = 0\n  for i = 1,#s\
    \ do\n    if string.sub(s,i,i) ~= nil then\n      if string.sub(s,i,i) ~= 'A'\
    \ then\n        count = count+1\n      end\n    end\n  end\n  return count\nend",
  "  return s:gsub('([%w])', function(c) return c == 'a' or c == 'A' or c == 'e' or\
    \ c == 'E' or c == 'i' or c == 'I' or c == 'o' or c == 'O' or c == 'u' or c ==\
    \ 'U' end):reverse():gsub('(.)', function(c) return string.upper(c) end):reverse():gsub('(.)',\
    \ function(c) return string.upper(c) end)\nend", "  local i = 0\n  while i < #s\
    \ do\n    if not is_vowel(s[i]) then\n      return 0\n    end\n    if s[i] ==\
    \ 'a' then\n      i = i + 1\n      if i % 2 == 0 then return 1 end\n    elseif\
    \ s[i] == 'e' then\n      i = i + 1\n      if i % 2 == 0 then return 1 end\n \
    \   elseif s[i] == 'i' then\n      i = i + 1\n      if i % 2 == 0 then return\
    \ 1 end\n    elseif s[i] == 'o' then\n      i = i + 1\n      if i % 2 == 0 then\
    \ return 1 end\n    elseif s[i] == 'u' then\n      i = i + 1\n      if i % 2 ==\
    \ 0 then return 1 end\n    else\n      i = i + 1\n    end\n  end\n  return 0\n\
    end", "  local vowels = {'a','e','i','o','u'}\n  local upper, count = {}, {}\n\
    \  for i = 1, #s do\n    if i % 2 == 0 then\n      for j = 1, #vowels do\n\tupper[vowels[j]]=upper[vowels[j]]+1\n\
    \      end\n    end\n    count[tostring(upper)] = count[tostring(upper)] + 1\n\
    \  end\n  return count\nend", "   local upper = 0\n   for i = 1, #s do\n     \
    \ if s[i] == 'A' or s[i] == 'a' then\n         upper = upper + 1\n      else\n\
    \         upper = upper\n      end\n   end\n   return upper\nend", "    if s ~=\
    \ string.gsub(s, \"[aeiouAEIOU]\", \"\")\n    then\n        return 0\n    end\n\
    \    local total = 0\n    for i = 1, string.len(s) do\n        total = total +\
    \ 1\n        if string.sub(s, i, i + 1) ~= 'A' and\n           string.sub(s, i,\
    \ i + 1) ~= 'E' and\n           string.sub(s, i, i + 1) ~= 'I'\n        then\n\
    \            total = total - 1\n        end\n    end\n    return total\nend",
  "  local cnt = 0\n  for i=1,#s do\n    if string.sub(s,i,i):sub(1,1):upper()=='A'\
    \ or string.sub(s,i,i):sub(1,1):upper()=='a' then\n      cnt = cnt + 1\n    end\n\
    \  end\n  return cnt\nend", "  if s:match('^[aeiou]*$') then\n    return s:gsub('^[aeiou]+$',\
    \ ''):gsub('[^aeiou]', ''):gsub('[^aeiou]+$', '')\n  else\n    return 0\n  end\n\
    end", "  return #s:gsub('%a',''):gsub('%d',''):gsub('%e',''):gsub('%f',''):gsub('%g',''):gsub('%h',''):gsub('%i',''):gsub('%j',''):gsub('%k',''):gsub('%l',''):gsub('%m',''):gsub('%n',''):gsub('%p',''):gsub('%q',''):gsub('%r',''):gsub('%s',''):gsub('%t',''):gsub('%u',''):gsub('%v',''):gsub('%w',''):gsub('%x',''):gsub('%y',''):gsub('%z','')\n\
    end", "  local count = 0\n  for c in s:gmatch(\"[aeiouAEIOU]+\") do count = count\
    \ + 1 end\n  return count\nend", "    local count = 0\n    for i = 1, #s do\n\
    \        local c = s[i]\n        if c:match '[aeiou]' then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "  for i = 1, #s,\
    \ 2 do\n    if string.sub(s, i, i) ~= 'A' or string.sub(s, i - 1, i) ~= 'a' then\n\
    \      return 0\n    end\n  end\n  return 1\nend", "    local uppers = { }\n \
    \   for i = 1, #s do\n        local c = toupper(s[i])\n        if (c == 'A' or\
    \ c == 'E' or c == 'I' or c == 'O' or c == 'U') then\n            uppers[#uppers+1]\
    \ = 1\n        end\n    end\n    return #uppers\nend", "  assert(type(s) == \"\
    string\", \"s should be a string\")\n  assert(s:len() > 0, \"s cannot be empty\"\
    )\n  local n = 0\n  for i = 1, s:len() do\n    if string.sub(s, i, i + 1) ~= \"\
    \" then n = n + 1 end\n  end\n  for i = 1, s:len() do\n    if string.sub(s, i,\
    \ i + 1) ~= \"_\" then n = n + 1 end\n  end\n  return n\nend", "    if s then\n\
    \        local n, i, l\n        for i = 1, #s do\n            if string.sub(s,i,i)\
    \ == 'A' then\n                n = n + 1\n            end\n        end\n     \
    \   for i = 2, #s do\n            if string.sub(s,i,i) == 'A' then\n         \
    \       n = n - 1\n            end\n        end\n        n = n - 1\n    end\n\
    \    return n\nend", "  if s == nil then return 0 end\n  local vowels = {'a','e','i','o','u'}\n\
    \  local uppers = 0\n  local i = 1 -- Index\n  for i,v in ipairs(vowels) do\n\
    \    if v == s[i] then\n      uppers = uppers + 1\n    end\n  end\n  return uppers\n\
    end", "  local count = 0\n  for i = 1, #s do\n    count = count + s.sub(i, i).upper():bytes():len()\
    \ % 2\n  end\n  return count\nend", "  local count = 0\n  for _, c in ipairs(s)\
    \ do\n    if c:lower() == \"a\" then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "  local even = false\n  local count = 0\n  for letter\
    \ in s:gmatch(\"[^A-Za-z]\") do\n    count = count + 1\n    if letter:sub(1, 1):upper()\
    \ == letter then\n      even = not even\n    end\n  end\n  return even and count\
    \ / 2 \nend", "  local count = 0\n  for i = 1, #s do\n    if string.sub(s,i,i)\
    \ == string.sub(s,i,i) then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "  local n = 0\n  for i = 1, #s do\n    if s[i] and ((s[i] >= 'a'\
    \ and s[i] <= 'z') or (s[i] >= 'A' and s[i] <= 'Z')) then\n      n = n + 1\n \
    \   end\n  end\n  return n\nend", "\tlocal cnt = 0\n\tfor i = 1, #s do\n\t\tlocal\
    \ v = string.sub(s,i,i)\n\t\tif v == \"A\" or v == \"a\" then\n\t\t\tcnt = cnt\
    \ + 1\n\t\tend\n\tend\n\treturn cnt\nend", "  local upper = 0\n  for _, c in pairs(s)\
    \ do\n    local v = tostring(c):upper()\n    if v == 'A' then upper = upper +\
    \ 1 end\n  end\n  return upper\nend", "  local num_upper = 0\n  for i = 1, #s\
    \ do\n    if string.sub(s,i,i) ~= 'A' then\n      num_upper = num_upper + 1\n\
    \    end\n  end\n  return num_upper\nend", "  -- We loop from 2 to # of characters\
    \ in s and check if\n  -- s[i] is uppercase. Since s[i] is uppercase, we increment\
    \ i by 1.\n  for i = 2, #s do\n    if string.sub(s, i, i):upper() ~= 'A' then\n\
    \      return i\n    end\n  end\n  return #s\nend", "  local count=0\n  local\
    \ i=1\n  while i<=#s do\n    if string.sub(s, i, i)==\"A\" then\n      count=count+1\n\
    \    end\n    i=i+1\n  end\n  return count\nend", "\tlocal count = true\n\tfor\
    \ i = 1, #s do\n\t\tcount = count and is_upper(s[i])\n\tend\n\treturn count\n\
    end", "    if s == '' or s ~= s:upper() then return 0 end", "  return s:gsub(\"\
    [aeiouAEIOU]\", function(c) \n    return (string.byte(c) >= 65 and string.byte(c)\
    \ <= 90) or c % 2 ~= 0 and 1 or 0\n  end)\nend", "  local n = 0\n  for i = 1,#s\
    \ do\n    if s[i] == 'A' or s[i] == 'a' then\n      n = n + 1\n    end\n  end\n\
    \  return n\nend", "  return s:gsub('([%w])', function(c) \n    return c == 'A'\
    \ or c == 'a' then 1 \n    else 0 end\n  end)\nend", "    local i = 0\n    local\
    \ n = 0", "  -- Initialize count to zero\n  local count = 0\n  -- Initialize a\
    \ boolean value to false\n  local bool = false\n  -- Loop through all the characters\
    \ in the string\n  for i=1,#s do\n    -- If the character at index i is an uppercase\
    \ letter\n    if string.sub(s, i, i):upper() ~= 'A' then\n      -- Set bool to\
    \ true\n      bool = true\n      break\n    end\n  end\n  -- If the string contains\
    \ any uppercase letters\n  if bool then\n    -- Add 1 to count\n    count = count\
    \ + 1\n  end\n  return count\nend", "  local counter = {}\n  local i, n", "  \
    \  local count = 0\n    for i = 0, #s - 1 do\n        if string.sub(s, i, i +\
    \ 1) ~= \"\" then count = count + 1 end\n    end\n    return count\nend", "  local\
    \ cnt = 0\n  for i = 1, #s do\n    cnt = cnt + tostring(s[i])\n    if i%2 == 0\
    \ then\n      cnt = cnt + 1\n    end\n  end\n  return cnt\nend\n</cell>\n<text>\n\
    Exercise 2\nUse the count_upper function you defined above to count the number\
    \ of uppercase vowels in each line of the file words.txt and print the results\
    \ out to the console. Remember to open and read the file first!", "  local count\
    \ = 0\n  -- Count the number of uppercase vowels in even indices\n  for i = 1,\
    \ #s do\n    if i % 2 == 0 then\n      if tostring(s:sub(i,i)) ~= 'a' and\n  \
    \       tostring(s:sub(i,i)) ~= 'A' then\n        count = count + 1\n      end\n\
    \    end\n  end\n  return count\nend", "\tlocal count = 0\n\tfor i = 1, #s do\n\
    \t\tlocal c = string.sub(s, i, i)\n\t\tif c == 'a' then count = count + 1 end\n\
    \t\tif c == 'e' then count = count + 1 end\n\t\tif c == 'i' then count = count\
    \ + 1 end\n\t\tif c == 'o' then count = count + 1 end\n\t\tif c == 'u' then count\
    \ = count + 1 end\n\tend\n\treturn count\nend", "  local upper = 0\n  for i =\
    \ 1, #s do\n    if s[i] == 'a' or s[i] == 'A' then\n      if i % 2 == 0 then\n\
    \        upper = upper + 1\n      end\n    end\n  end\n  return upper\nend", " \
    \ local counter = 1\n  for i = 1, #s do\n    if string.sub(s, i, i) ~= 'A' then\n\
    \      counter = counter + 1\n    end\n  end\n  return counter\nend", "  local\
    \ n = 0\n  for i = 1, #s do\n    local c = string.sub(s,i,i)\n    if c == \"A\"\
    \ or c == \"E\" or c == \"I\" or c == \"O\" or c == \"U\" then\n      n = n +\
    \ 1\n    end\n  end\n  return n\nend", "  local count = 0\n  for i=1,#s do\n \
    \   if string.sub(s, i, i+1) ~= 'A' and string.sub(s, i, i+1) ~= 'a' then\n  \
    \    count = count+1\n    end\n  end\n  return count\nend", "  local count = 0\n\
    \  for i = 1, #s do\n    local v = tonumber(s[i])\n    if v ~= nil and ((v <=\
    \ 'Z' and v ~= 'z') or (v >= 'a' and v <= 'z') or (v >= '0' and v < 'a')) then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "    local vowels\
    \ = {'a','e','i','o','u'}\n    local count = 0\n    for i = 1, #s do\n       \
    \ local c = string.sub(s,i,i)\n        if c then\n            if vowels[string.find(c,'[aeiou]')]\
    \ then\n                count = count + 1\n            end\n        end\n    end\n\
    \    return count\nend", "    if #s == 0 then\n        return 0\n    end\n   \
    \ local count = 0\n    local i = 2\n    while i <= #s do\n        if s[i] == 'A'\
    \ then\n            count = count + 1\n        end\n        i = i + 1\n    end\n\
    \    return count\nend", "  local n = 0\n  for i = 1, #s do\n    if string.sub(s,i,i)\
    \ == string.sub(s,i,i) .. 'A' then\n      n = n + 1\n    end\n  end\n  return\
    \ n\nend", "  return s:gsub('([%w_])', function(x)\n    return x:sub(1, 1):upper():sub(2)\n\
    \  end)\nend", "  local n = 0\n  for i = 1, #s, 2 do\n    local c = string.sub(s,i,i)\n\
    \    if c == \"a\" or c == \"e\" or c == \"i\" or c == \"o\" or c == \"u\" then\n\
    \      n = n + 1\n    end\n  end\n  return n\nend", "  local vowels = 'aeiou'\n\
    \  local result = 0\n  for i = 1, #s do\n    if string.sub(vowels, i, i) ~= 'A'\
    \ then\n      result = result + 1\n    end\n  end\n  return result\nend", "  \
    \  local count = 1\n    for i, letter in string.gmatch(s, \"[%u]\") do\n     \
    \   if letter:sub(1, 1) ~= 'A' then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "   local upper = string.gsub(s, '([a-z])([A-Z])')\n\
    \   return upper:len() / 2\nend", "  local count = 0\n  for i = 1, #s do\n   \
    \ count = count + (s[i] == 'A' or s[i] == 'E' or s[i] == 'I' or s[i] == 'O' or\
    \ s[i] == 'U')\n  end\n  return count\nend", "  local count\n  local i = 0\n \
    \ -- The outer loop starts from i = 1 because we need at least 1 upper case letter\
    \ to count towards our result.\n  -- The inner loop starts from i = 1 since we\
    \ don't want to count an upper case letter for its neighbor.\n  for i = 1, #s\
    \ do\n    if string.sub(s,i,i) == uppercase then\n      count = count + 1\n  \
    \  else\n      count = count + (i - 1)\n    end\n  end\n  return count\nend",
  "  if s == '' then return 0 end\n  local count = 0\n  for i = 1, #s, 1 do\n    local\
    \ c = string.sub(s,i,i)\n    if c == 'A' or c == 'a' or c == 'E' or c == 'e' or\
    \ c == 'I' or c == 'i' or c == 'O' or c == 'o' or c == 'U' or c == 'u' then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "    local vowel_count\
    \ = 0\n    local idx = 1\n    while idx <= #s do\n        if s[idx] ~= s[(idx-1)\
    \ * 2] then\n            vowel_count = vowel_count + 1\n        end\n        idx\
    \ = idx + 1\n    end\n    return vowel_count\nend", "\t-- Write your code here\n\
    \tlocal c = 0\n\tfor i = 1, #s do\n\t\tif s[i] == 'a' or s[i] == 'e' or s[i] ==\
    \ 'i' or s[i] == 'o' or s[i] == 'u' then\n\t\t\tc = c + 1 \n\t\tend\n\tend\n\t\
    return c\nend", "  for idx, letter in ipairs(s) do\n    if letter ~= 'A' and letter\
    \ ~= 'a' then\n      return idx\n    end\n  end\n  return 0\nend", "  return s:gsub('[A-Z]',\
    \ ''):gsub('%z', ''):gsub('%Z', ''):match('%z'):gsub('(.)', '\\\\1'):gsub('(.)',\
    \ '%1'):gsub('(.)', '%1')\nend", "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n\
    \    local count = 0\n    for i = 1, #s do\n        if vowels[s:sub(i,i)] ~= 'a'\
    \ then\n            count = count + 1\n        end\n    end\n    return count\n\
    end", "    local l = 0\n    for i = 1, #s do\n        if string.sub(s, i, i) ~=\
    \ 'A' and string.sub(s, i, i) ~= 'a' then\n            l = l + 1\n        end\n\
    \    end\n    return l\nend", "   local i = 0\n   while i < #s do\n      if s[i]\
    \ == \"A\" or s[i] == \"E\" or s[i] == \"I\" or s[i] == \"O\" or s[i] == \"U\"\
    \ then\n         i = i + 1 \n      else\n         return 0\n      end\n   end\n\
    \   return 1\nend", "  local num_upper = 0\n  for i = 0, #s do\n    if s[i] ==\
    \ 'A' or s[i] == 'E' or s[i] == 'I' or s[i] == 'O' or s[i] == 'U' then\n     \
    \ num_upper = num_upper + 1\n    end\n  end\n  return num_upper\nend", "   local\
    \ upper = 'a'\n   for i = 1, #s do\n      if string.sub(s,i,i) ~= upper then\n\
    \         upper = upper:byte()\n      else\n         upper = upper:byte() + 32\n\
    \      end\n   end\n   return upper\nend", "   local n = 0\n   for i = 1, #s do\n\
    \      if s[i] == 'A' or s[i] == 'E' or s[i] == 'I' or s[i] == 'O' or s[i] ==\
    \ 'U' then\n         n = n + 1\n      end\n   end\n   return n\nend", "    local\
    \ n = 0\n    for i = 1, #s do\n        -- If current character is a vowel, ignore\
    \ it and continue\n        if s[i - 1] ~= 'a' and s[i - 1] == 'A' then\n     \
    \       n = n + 1\n        else\n            -- If current character is an uppercase\
    \ vowel,\n            -- the previous character must be a vowel.\n           \
    \ if s[i - 1] ~= 'A' then\n                n = n + 1\n            end\n      \
    \  end\n    end\n    return n\nend", "    local even = string.gsub(s, '[AEiou]',\
    \ '\\0')\n    local count   = 0\n    for i, v in ipairs(string.gsub(even, '[AEiou]',\
    \ '\\0')) do\n        if string.find(string.upper(v), 'A') then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "   local count =\
    \ 0\n   for i = 1, #s do\n      if tonumber(s[i] ~= string.sub(s,i,i)) then\n\
    \         return 0\n      elseif s[i] == 'a' or s[i] == 'e' or s[i] == 'i' or\
    \ s[i] == 'o' then\n         count = count + 1\n      end\n   end\n   return count\n\
    end", "  local num_upper = 0\n  for i=1,#s do\n    if string.sub(s,i,i) == string.sub(s,i,i)\
    \ .. 'A' then\n      num_upper = num_upper + 1\n    end\n  end\n  return num_upper\n\
    end", "  local n = 0\n  for i = 1, #s do\n    if string.sub(s,i,i) ~= string.sub(s,i,i)\
    \ then n = n + 1 end\n  end\n  return n\nend", "  local num = 0\n  for i=1, #s\
    \ do\n    num = num + is_upper_case(s[i])\n  end\n  return num\nend", "  -- TODO:\
    \ Check for non-letters\n  local even_indexes = {}\n  for i = 1,#s do\n    local\
    \ c = toupper(s[i])\n    if c >= 'A' and c <= 'Z' then\n      if c:byte() % 2\
    \ == 0 then\n        even_indexes[#even_indexes + 1] = tolower(s[i])\n      end\n\
    \    end\n  end\n  return #even_indexes / 2\nend", "    local n = 0\n    for i=1,#s\
    \ do\n        if string.sub(s,i,i) ~= 'A' and string.sub(s,i,i) ~= 'a' then\n\
    \            n = n + 1\n        end\n    end\n    return n\nend", "  -- Find the\
    \ even-indexed characters.\n  local even_indexed_characters = {}\n  for i = 1,\
    \ #s do\n    if i % 2 == 0 then\n      table.insert(even_indexed_characters, s[i])\n\
    \    end\n  end", "  local count = 0\n  for i = 1,#s do\n    if string.sub(s,\
    \ i, i) == string.char(string.upper(string.sub(s,i,i))) then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  local n = 0\n  for i, c in string.gmatch(s,\
    \ '[%u..%u]+') do\n    local uv = string.byte(c, 'u')\n    if uv > 0 and uv %\
    \ 2 == 1 then\n      n = n + 1\n    end\n  end\n  return n\nend", "  local count\
    \ = nil\n  for i=1, #s do\n    local c = s[i]\n    local is_upper = ((c:byte()\
    \ >= 65) and (c:byte() <= 90))\n    if count ~= nil then\n      count = count\
    \ + ((is_upper and i%2 == 1) or is_upper)\n    else\n      count = is_upper\n\
    \    end\n  end\n  return count\nend", "  local u = 0\n  for i = 1, #s do\n  \
    \  if s[i] and s[i] ~= ' ' then\n      u = u + 1\n      if i % 2 == 0 then\n\t\
    break\n      end\n    end\n  end\n  return u\nend\n</code>\n<|/ a tags=lua,string-matching,string-count\
    \ dscore=2 |>\n<| a tags=lua,string-matching,string-count |>\nIn case you don't\
    \ mind using regular expressions, the following code counts occurrences of uppercase\
    \ vowels.\n<code>", "  local num_upper = 0\n  for i=1,#s do\n    if s[i] == 'A'\
    \ or s[i] == 'a' then\n      num_upper = num_upper + 1\n    end\n  end\n  return\
    \ num_upper\nend", "   local n = 0\n   for i = 1, #s do\n      if string.sub(s,i,i)\
    \ ~= 'A' then\n         n = n + 1\n      end\n   end\n   return n\nend", "   for\
    \ i = 1, #s do\n      if string.sub(s, i, i) ~= 'A' and string.sub(s, i, i) ~=\
    \ 'a'\n      then\n         return 0\n      end\n   end\n   return 1\nend", " \
    \ local count = 0\n  for i = 1, #s do\n    if string.sub(s, i, i) ~= 'A' or string.sub(s,\
    \ i, i) ~= 'a'\n    or string.sub(s, i, i) ~= 'E' or string.sub(s, i, i) ~= 'e'\n\
    \    or string.sub(s, i, i) ~= 'I' or string.sub(s, i, i) ~= 'i'\n    or string.sub(s,\
    \ i, i) ~= 'O' or string.sub(s, i, i) ~= 'o'\n    or string.sub(s, i, i) ~= 'U'\
    \ or string.sub(s, i, i) ~= 'u'\n    then count = count + 1\n    end\n  end\n\
    \  return count\nend", "  local n = 0\n  for i,c in pairs(s) do\n    local t =\
    \ c:byte()\n    if t ~= #s then\n      n = n + 1 -- Not an uppercase character\n\
    \    elseif t%2 ~= 0 then\n      n = n + 1 -- Not an even-indexed character\n\
    \    end\n  end\n  return n\nend", "   local count = 0\n   for i = 1, #s do\n\
    \      if string.sub(s, i, i+1) ~= 'A' then\n         count = count+1\n      end\n\
    \   end\n   return count\nend", "    return s:gsub('([%aA])',function(a)\n   \
    \     return a:upper():byte() == 1\n    end)\nend", "  local n = 1\n  for i =\
    \ 1, #s do\n    if string.sub(s, i, i) ~= 'A' then\n      return n\n    end\n\
    \    n = n + 1\n  end\n  return n\nend", "  for i = 1, #s do\n    if string.sub(s,\
    \ i, i) == string.sub(s, 'A', 1, i) then\n      return i\n    end\n  end\n  return\
    \ 0\nend", "   local counter = { }\n   for i = 1, #s do\n      if string.sub(s,\
    \ i, i) == \"a\" or string.sub(s, i, i) == \"e\" or string.sub(s, i, i) == \"\
    i\" then\n         counter[#counter+1] = 1\n      end\n   end\n   return #counter\n\
    end", "    local count = 0\n    for i = 1, #s do\n        if string.sub(s,i,i)\
    \ == string.sub(s,i,i) then count = count+1 end\n    end\n    return count\nend",
  "  local num_upper = 0\n  for i = 1, #s, 2 do\n    if string.sub(s, i, i+2) == \"\
    AEIOUaeiou\" then\n      num_upper = num_upper + 1\n    end\n  end\n  return num_upper\n\
    end", "  for i = 1,#s do\n    if string.sub(s,i,i) == 'a' or string.sub(s,i,i)\
    \ == 'e' or string.sub(s,i,i) == 'i' or string.sub(s,i,i) == 'o' or string.sub(s,i,i)\
    \ == 'u' then\n      if i ~= 1 or i ~= 2 or i ~= 4 or i ~= 6 then\n        return\
    \ i\n      end\n    end\n  end\n  return 0\nend", "  local count = 0\n  for i\
    \ = 1, #s do\n    if string.sub(s,i,i) == 'A' then\n      count = count + 1\n\
    \    end\n  end\n  return count\nend", "   local count = 0\n   for i = 1, #s do\n\
    \      if s:sub(i, i) == toupper(s:sub(i, i)) then\n\t count = count + 1\n   \
    \   end\n   end\n   return count\nend", "    local c = 0\n    for i = 1, #s, 2\
    \ do\n        local char = string.sub(s, i, i + 1)\n        if char == string.upper(char)\
    \ then\n            c = c + 1\n        end\n    end\n    return c\nend", "   \
    \ local upper = 0\n    for i = 1, #s, 2 do\n        if string.sub(s,i,i) == 'A'\
    \ and string.sub(s,i+1,i+1) ~= 'E' then\n            upper = upper + 1\n     \
    \   end\n    end\n    return upper\nend", "  local result = 0\n  for i = 0, #s\
    \ - 1 do\n    local c = tostring(s:sub(i,i))\n    if c == \"a\" or c == \"A\"\
    \ then\n      result = result + 1\n    end\n  end\n  return result\nend", "  local\
    \ uppercase_count = 0\n  for i,c in ipairs(s:gmatch\"[A-Z]+\") do\n    local is_vowel\
    \ = c:byte() ~= 64\n    if is_vowel then\n      uppercase_count = uppercase_count\
    \ + 1\n    end\n  end\n  return uppercase_count\nend", "  if s == nil then return\
    \ 0 end\n  return s:gsub('([A-Z])', function(c) return c:upper() end):gsub('%z',''):gsub('(.)%z','%1'):gsub('%z','')\n\
    end", "  local num_upper = s:sub(1, 1):upper():len()\n  local num_even = s:sub(1,\
    \ 1):upper():len()\n  while num_even > 0 do\n    local idx = s:sub(1, num_even)\n\
    \    if idx:find(\"A\") then\n      num_upper = num_upper + 1\n    end\n    num_even\
    \ = num_even - 1\n  end\n  return num_upper\nend", "  local t = ''\n  for _, c\
    \ in string.gmatch(s, '%a') do\n    t = t .. c\n  end\n  -- Count consecutive\
    \ vowels\n  local n = 0\n  for i = 1, #t do\n    local c = t[i]\n    if c == 'a'\
    \ then\n      n = n + 1 -- consecutive vowels\n    elseif c == 'e' then\n    \
    \  n = n + 1 -- consecutive vowels\n    elseif c == 'i' then\n      n = n + 1\
    \ -- consecutive vowels\n    elseif c == 'o' then\n      n = n + 1 -- consecutive\
    \ vowels\n    elseif c == 'u' then\n      n = n + 1 -- consecutive vowels\n  \
    \  end\n  end\n  -- Count consecutive vowels in odd indices\n  for i = 1, #t -\
    \ 1 do\n    local c = t[i]\n    if c == 'a' then\n      n = n + 1 -- consecutive\
    \ vowels\n    elseif c == 'e' then\n      n = n + 1 -- consecutive vowels\n  \
    \  elseif c == 'i' then\n      n = n + 1 -- consecutive vowels\n    elseif c ==\
    \ 'o' then\n      n = n + 1 -- consecutive vowels\n    elseif c == 'u' then\n\
    \      n = n + 1 -- consecutive vowels\n    end\n  end\n  return n\nend", "  for\
    \ i = 1,string.len(s) do\n    if string.sub(s,i,i) ~= 'A' or string.sub(s,i,i)\
    \ ~= 'a' then\n      return 0\n    end\n  end\n  return 1\nend", "  return s:gsub('([%a])%u',\
    \ function(c) return (string.byte(c) ~= 0 and c or nil) end)\nend", "   -- Check\
    \ whether s is nil or empty\n   if s == nil or s == \"\" then\n      return 0\n\
    \   end", "   if #s <= 1 then return 0 end\n   local even = math.floor((#s - 1)\
    \ / 2)\n   if s[even] ~= 'A' then return 0 end\n   if s[even+1] ~= 'A' then return\
    \ 0 end\n   local result = 0\n   for i = even+2, #s, 2 do\n      if s[i] ~= 'A'\
    \ then break end\n      result = result + 1\n   end\n   return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
