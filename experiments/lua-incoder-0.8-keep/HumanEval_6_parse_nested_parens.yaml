name: HumanEval_6_parse_nested_parens
language: lua
prompt: "-- Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n-- For each of the group, output the deepest\
  \ level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n-- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  -- [2, 3, 1, 3]\nlocal function parse_nested_parens(paren_string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_nested_parens\n\
  \    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})\n \
  \   lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})\n    lu.assertEquals(candidate('(()(())((())))'),\
  \ {4})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local max_depth = 0\n  local depth = 0\n  local levels = {}\n  local\
    \ stack = {}", "\tlocal depth = 0\n\tlocal nested_paren_stack = {}\n\tfor paren\
    \ in string.gmatch(paren_string, '%[(%a*)%]') do\n\t\tif not nested_paren_stack[paren]\
    \ then\n\t\t\tnested_paren_stack[paren] = depth\n\t\telse\n\t\t\tdepth = depth\
    \ + 1\n\t\tend\n\tend", "  local groups = {}\n  local last_level = 0\n  for paren\
    \ in string.gmatch(paren_string, \"%[(%a*)%]\") do\n    local level = tonumber(paren)\n\
    \    if level > 0 then\n      assert(level > last_level)\n      last_level = level\n\
    \    end\n    if level == 0 then\n      table.insert(groups, 1)\n    else\n  \
    \    table.insert(groups, level + last_level)\n    end\n  end\n  return groups\n\
    end", "  local nested_parentheses_levels = {}\n  local paren_count = 0\n  for\
    \ paren in pairs(paren_string:gmatch('%[(%a)](%a*)')) do\n    local levels = #paren\
    \ + 2\n    if nested_parentheses_levels[levels] then\n      nested_parentheses_levels[levels]\
    \ = nested_parentheses_levels[levels] + 1\n    else\n      nested_parentheses_levels[levels]\
    \ = 1\n    end\n    paren_count = paren_count + 1\n  end\n  return paren_count,\
    \ nested_parentheses_levels\nend", "    local max_level = 0\n    local paren_stack\
    \ = {}\n    local paren_levels = { }\n    for s in string.gmatch(paren_string,\
    \ '%w+') do\n        if s ~= ')' then\n            if s == '(' then\n        \
    \        paren_stack[#paren_stack + 1] = s\n                paren_levels[s] =\
    \ #paren_stack\n            end\n        end\n        if s == ')' then\n     \
    \       local level = #paren_stack\n            if level > max_level then\n  \
    \              max_level = level\n            end\n            for i = #paren_stack\
    \ + 1, level do\n                paren_stack[i] = paren_stack[i + 1]\n       \
    \     end\n            paren_stack = {}\n        end\n    end\n    return max_level\n\
    end", "    local levels = {}\n    local groups = stringx.explode(paren_string,\
    \ ' ')\n    for _, group in ipairs(groups) do\n        local group_levels = parse_nested_parens_levels(group,\
    \ levels)\n        if #group_levels > 1 then -- if this is a deepest group\n \
    \           for _, level in ipairs(group_levels) do\n                table.insert(levels,\
    \ level)\n            end\n        elseif #group_levels == 1 then -- if this is\
    \ a normal group\n            table.insert(levels, group_levels[1])\n        end\n\
    \    end\n    return table.concat(levels, ',')\nend", "  if paren_string:sub(1,\
    \ 1) == '(' then\n    return parse_nested_parens(paren_string:sub(2)):reverse()\n\
    \  end\n  local parsed_string = {}\n  for group_string in string.gmatch(paren_string,\
    \ '%[()]+') do\n    local level = parsed_string:size\n    for group_string in\
    \ string.gmatch(group_string, '%[()]+') do\n      if parsed_string:sub(1, level\
    \ + 1) == ')' and group_string == ')' then\n        level = level - 1\n      elseif\
    \ parsed_string:sub(1, level + 1) == '(' then\n        level = level + 1\n   \
    \   else\n        parsed_string:insert(level)\n      end\n    end\n  end\n  return\
    \ parsed_string\nend", "  local groups = split(paren_string, \" \")\n  local max_level\
    \ = 0\n  local max_index\n  for index, parens in ipairs(groups) do\n    local\
    \ level_of_nesting = 0\n    local paren_count\n    for index, paren in ipairs(parens)\
    \ do\n      if paren ~= \")\" then\n        paren_count = paren_count+1\n    \
    \  else\n        level_of_nesting = level_of_nesting+1\n      end\n    end\n \
    \   if level_of_nesting > max_level then\n      max_level = level_of_nesting\n\
    \      max_index = index\n    end\n  end\n  return groups[max_index]\nend", " \
    \ local brackets = {}\n  local max_level = 0\n  local current_level = nil\n  local\
    \ paren_count = 0\n  for paren_symbol in string.gmatch(paren_string, '%[(%a)]+')\
    \ do\n    local paren_level = #paren_symbol - 1\n    if paren_level > max_level\
    \ then\n      brackets[#brackets + 1] = paren_level\n      max_level = paren_level\n\
    \      current_level = paren_level + 1\n      paren_count = 1\n    elseif paren_level\
    \ == current_level then\n      paren_count = paren_count + 1\n    else\n     \
    \ local current_brackets = brackets[current_level]\n      if current_brackets\
    \ == nil then\n        brackets[current_level] = paren_count\n      else\n   \
    \     brackets[current_level] = current_brackets + paren_count\n      end\n  \
    \  end\n  end\n  return brackets\nend", "  local max_level = 0\n  local level_lengths\
    \ = {}\n  local num_levels = -1\n  local paren_levels = {}\n  local paren_levels_index\
    \ = {}\n  for i = 1, #paren_string, 1 do\n    local char = paren_string[i]\n \
    \   if char == '(' then\n      paren_levels[#paren_levels + 1] = max_level\n \
    \     paren_levels_index[#paren_levels_index + 1] = i\n      max_level = max_level\
    \ + 1\n    elseif char == ')' then\n      local level = paren_levels[#paren_levels]\n\
    \      if level ~= -1 then\n        local level_length = i - level_lengths[#level_lengths]\n\
    \        if level_length <= level then\n          max_level = max_level - 1\n\
    \        end\n      end\n      paren_levels[#paren_levels] = -1\n    end\n   \
    \ if char == ' ' then\n      local num_levels = max_level\n      max_level = 1\n\
    \      level_lengths[#level_lengths + 1] = i\n    end\n  end\n  local num_levels\
    \ = max_level\n  local level_lengths = assert(table.unpack(level_lengths))\n \
    \ local paren_levels = assert(table.unpack(paren_levels))\n  local paren_levels_index\
    \ = assert(table.unpack(paren_levels_index))\n  local current_level_length = 0\n\
    \  local current_level_parens = 0\n  local level_parens_index = {}\n  for i =\
    \ 1, #paren_string, 1 do\n    local char = paren_string[i]\n    if char == '('\
    \ then\n      current_level_length = current_level_length + 1\n      level_parens_index[current_level_length]\
    \ = i\n    elseif char == ')' then\n      current_level_length = current_level_length\
    \ - 1\n      if current_level_length <= 0 then\n        local current_level_parens\
    \ = current_level_parens - 1\n        local level_length_to_go = #level_lengths\
    \ + current_level_length\n        if level_length_to_go > 0 then\n          local\
    \ level_length = level_lengths[level_length_to_go - 1]\n          local level_parens\
    \ = paren_levels[level_length_to_go]\n          if level_parens > current_level_parens\
    \ then\n            level_parens_index[current_level_length] = level_lengths[level_length_to_go]\n\
    \          else\n            level_parens_index[current_level_length] = level_lengths[level_length_to_go\
    \ - 1]\n          end\n        else\n          level_parens_index[current_level_length]\
    \ = level_lengths[#level_lengths]\n        end\n      end\n    end\n    if char\
    \ == ' ' then\n      local num_levels = max_level\n      max_level = 1", "  --\
    \ Find all groups\n  local group_start_idx = {}\n  local groups = {}\n  for gid=1,\
    \ #paren_string do\n    local group = {}\n    local i = 1\n    local open = 1\n\
    \    for ch in paren_string[gid] do\n      if open == 0 then\n        if ch ==\
    \ '(' then\n          open = 1\n        elseif ch == ')' then\n          open\
    \ = -1\n        else\n          error('unexpected char ' .. ch .. ' at group '\
    \ .. gid)\n        end\n      else\n        if ch == ')' then\n          open\
    \ = -1\n        elseif ch == ' ' then\n          group[i] = group\n          group\
    \ = {}\n          i = i + 1\n        else\n          error('unexpected char '\
    \ .. ch .. ' at group ' .. gid)\n        end\n      end\n    end\n    table.insert(groups,\
    \ group)\n    table.insert(group_start_idx, gid)\n  end", "  local levels  = {}\n\
    \  local depth   = 1\n  local i       = 0", "  local nested_parens = []\n  local\
    \ open = 0\n  local level = 0\n  for i = 1, #paren_string, 1 do\n    if paren_string[i]\
    \ == '(' then\n      if open > 0 then\n        level = level + 1\n      else\n\
    \        open = open + 1\n      end\n    elseif paren_string[i] == ')' then\n\
    \      if open == 1 then\n        level = level - 1\n      else\n        open\
    \ = open - 1\n      end\n    end\n    if level > 0 then\n      nested_parens[#nested_parens\
    \ + 1] = level\n    end\n  end\n  return nested_parens\nend", "  local parsed_string\
    \ = {}\n  for _ in string.gmatch(paren_string, \"( [^()]*\") do\n    table.insert(parsed_string,\
    \ #parsed_string + 1)\n  end\n  return parsed_string\nend", "    local max_depth\
    \ = 0\n    local nested_depth = 0\n    for index, paren_symbol in ipairs(paren_string:gmatch(\"\
    %[(%w*)\\s(%w*)\\)%]\"))\n        -- If the string does not have any parentheses,\
    \ just continue\n        if paren_symbol == nil then\n            nested_depth\
    \ = index\n        else\n            -- Otherwise, parse each of the group until\
    \ the maximum level of nesting is reached\n            while nested_depth > 0\
    \ do\n                -- Pop the stack of nesting levels and reset the maximum\
    \ depth\n                max_depth = max_depth - 1\n                nested_depth\
    \ = nested_depth - 1\n            end\n            -- Increment the depth of the\
    \ group\n            nested_depth = nested_depth + 1\n        end\n    done\n\
    \    -- Return maximum depth of nested parentheses\n    return max_depth\nend",
  "  local paren_string = paren_string:gsub('(%S+)', '%%%1')\n  local stack = {}\n\
    \  local lengths = {}\n  local max_level = 0\n  for paren in paren_string:gmatch'%([()%)%]')\
    \ do\n    if lengths[paren] == nil then\n      lengths[paren] = 1\n    else\n\
    \      lengths[paren] = lengths[paren] + 1\n    end\n    max_level = math.max(max_level,\
    \ lengths[paren])\n    table.insert(stack, paren)\n  end\n  return max_level,\
    \ stack\nend", "  local level = 1\n  local max_level = 0", "    if type(paren_string)\
    \ ~= 'string' then\n        error('parse_nested_parens expects a string as input')\n\
    \    end\n    local num_levels = tonumber(string.match(paren_string, '()*'))\n\
    \    if num_levels == 0 then\n        error('parse_nested_parens expects an non-empty\
    \ string as input')\n    end\n    local level_of_nesting = 1\n    local num_closed_brackets\
    \ = 0 -- count the number of closed brackets.\n    local num_open_brackets = 0\
    \ -- count the number of open brackets.\n    local levels = {} -- store the parsed\
    \ groups\n    local current_group = {} -- store the parsed bracket\n    local\
    \ i = 1\n    while i < string.len(paren_string) do\n        local char = string.sub(paren_string,\
    \ i, i)\n        local is_open_bracket = (char == '(')\n        if is_open_bracket\
    \ then\n            num_open_brackets = num_open_brackets + 1\n        elseif\
    \ char == ')' then\n            num_closed_brackets = num_closed_brackets + 1\n\
    \        end\n        local new_level = level_of_nesting\n        if num_open_brackets\
    \ > 0 then\n            new_level = new_level + num_open_brackets\n        end\n\
    \        if num_closed_brackets > 0 then\n            new_level = new_level -\
    \ num_closed_brackets\n        end\n        local is_new_level_valid = new_level\
    \ > 0 and new_level < num_levels\n        if is_new_level_valid then\n       \
    \     levels[#levels + 1] = new_level\n            current_group[#current_group\
    \ + 1] = char\n        end\n        i = i + 1\n        if char == '(' then\n \
    \           num_open_brackets = num_open_brackets + 1\n        elseif char ==\
    \ ')' then\n            num_closed_brackets = num_closed_brackets + 1\n      \
    \  end\n    end\n    if num_open_brackets > 0 or num_closed_brackets > 0 then\n\
    \        error('parse_nested_parens expects an non-empty string as input')\n \
    \   end\n    return levels\nend", "  local results = {}\n  local nested_level\
    \ = 0\n  local start_index = 1", "    local level = 1\n    local max_level = 1",
  "  local function is_nested_paren(group)\n    return string.match(group, \"^%s*(%A+)[%w]*$\"\
    )\n  end\n  local function paren_level(group)\n    local level, nesting\n    if\
    \ string.match(group, \"^%s*([^()]*)(%A+)[%w]*$\") then\n      level, nesting\
    \ = 1, group\n    else\n      level, nesting = 2, group\n    end\n    for i =\
    \ nesting:len() - 1, 1, -1 do\n      local char = nesting:sub(i,i)\n      if char\
    \ == \")\" then\n        level = level - 1\n      end\n      if level == 0 then\n\
    \        return level\n      end\n    end\n  end\n  local max_level, max_nesting\
    \ = 1, paren_string:gsub(\"^%s*(%A+)[%w]*$\", \"%1\"):gsub(\"%v+\", \" \")\n \
    \ local groups = { }\n  for i = 1, max_level do\n    local level_string = max_nesting:sub(i,i)\n\
    \    local level = paren_level(level_string)\n    table.insert(groups, level)\n\
    \  end\n  return groups\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=parsing,string,lua\
    \ dscore=2 |>\nThis might help you, I tried to make it easy to understand and\
    \ to modify\n<code>", "  local paren_levels = {}\n  local paren_opens_stack =\
    \ {}\n  local paren_count = 0\n  local paren_level = 0\n  local paren_counts =\
    \ {}\n  local paren_levels = {}\n  for paren_char in string.gmatch(paren_string,\
    \ \"()()\") do\n    local paren_level = paren_level + 1\n    paren_opens_stack[paren_level]\
    \ = paren_opens_stack[paren_level] or 0\n    if paren_char == \"(\" then\n   \
    \   paren_counts[paren_level] = paren_counts[paren_level] + 1\n      if paren_counts[paren_level]\
    \ == 1 then\n        paren_count = paren_level\n        paren_levels[paren_level]\
    \ = 1\n      end\n    elseif paren_char == \")\" then\n      if paren_opens_stack[paren_level]\
    \ == 1 then\n        paren_counts[paren_level] = paren_counts[paren_level] - 1\n\
    \      end\n      if paren_counts[paren_level] == 0 then\n        paren_count\
    \ = paren_level\n        paren_levels[paren_level] = paren_count + 1\n      end\n\
    \    end\n  end\n  table.sort(paren_levels, function(a, b) return paren_levels[b]\
    \ < paren_levels[a] end)\n  return paren_levels\nend", "  local level_stack =\
    \ [1]\n  local level_max = 1\n  local open_bracket_level = 1\n  local open_bracket_levels\
    \ = [1]\n  local open_brackets = 1\n  local brackets_count = 0\n  for char in\
    \ string.gmatch(paren_string, '()()') do\n    if char == '(' or char == '{' or\
    \ char == '[' then\n      open_brackets = open_brackets * 2 + 1\n      open_bracket_levels[brackets_count]\
    \ = open_bracket_level\n      level_stack[brackets_count] = open_bracket_level\n\
    \      level_max = level_max - 1\n      brackets_count = brackets_count + 1\n\
    \    elseif char == ')' or char == '}' or char == ']' then\n      open_brackets\
    \ = open_brackets - 1\n      open_bracket_level = level_stack[brackets_count]\n\
    \      if open_brackets < 0 then\n        brackets_count = brackets_count - 1\n\
    \        open_bracket_level = level_max\n      end\n    end\n  end\n  return open_bracket_levels\n\
    end", "  local num_groups = 0\n  local max_levels = 0\n  local nested_depth =\
    \ {}\n  for paren in split(paren_string, \" \") do\n    if paren ~= \"\" then\n\
    \      local curr_levels = max_levels\n      max_levels = curr_levels\n      local\
    \ curr_groups = 0\n      local curr_parens = paren\n      while paren ~= \"\"\
    \ do\n        local par = nsplit(paren, \")\")\n        local curr_groups = curr_groups\
    \ + 1\n        if curr_groups > curr_levels then\n          curr_levels = curr_groups\
    \ + 1\n        end\n        local new_paren\n        if par[1] == \"(\" then\n\
    \          new_paren = par[2]\n        else\n          new_paren = par[1]\n  \
    \      end\n        local new_par = nsplit(new_paren, \"(\")\n        curr_parens\
    \ = par[1]\n        paren = new_par[1]\n      end\n      nested_depth[paren] =\
    \ curr_levels\n    end\n  end\n  return nested_depth\nend", "\tlocal stack = {}\n\
    \tfor i = 1, #paren_string, 1 do\n\t\tlocal paren = paren_string:sub(i, i)\n\t\
    \tif paren:match('^[\\(()]+$') then\n\t\t\tstack = stack or {}\n\t\t\tstack[#stack\
    \ + 1] = #stack\n\t\tend\n\tend\n\treturn stack\nend", "    local brackets = {}\n\
    \    local index = 1\n    while index <= #paren_string do\n        if paren_string[index]\
    \ == '(' then\n            local open_index = index + 1\n            local close_index\n\
    \            while open_index <= #paren_string  do\n                if paren_string[open_index]\
    \ == '(' and paren_string[open_index + 1] == ')' then\n                    close_index\
    \ = open_index\n                    break\n                elseif paren_string[open_index]\
    \ == '(' then\n                    open_index = open_index + 1\n             \
    \   else\n                    open_index = open_index + 1\n                end\n\
    \            end\n            brackets[#brackets + 1] = close_index - open_index\n\
    \        end\n        index = index + 1\n    end\n    return brackets\nend", "\t\
    local level = 0\n\tlocal current_level = 0\n\tlocal current_index = 1\n\tlocal\
    \ paren_groups = {}\n\tlocal depth = #paren_string\n\tlocal in_group\n\tlocal\
    \ open_paren\n\tlocal close_paren\n\twhile current_index <= depth do\n\t\tlocal\
    \ next_open_paren = string.find(paren_string, open_paren, current_index)\n\t\t\
    if next_open_paren == nil then\n\t\t\tbreak\n\t\tend", "    local nested_groups\
    \ = {}\n    local group_level = 0\n    local group_start_index = 1\n    local\
    \ open_bracket = paren_string:sub(1, 1)\n    local close_bracket = paren_string:sub(1,\
    \ 2)", "   local paren_stack = [1]\n   local paren_count = 1\n   local paren_levels\
    \ = {}\n   for paren in string.gmatch(paren_string, \"%[()()\") do\n      paren_stack[paren_count]\
    \ = paren\n      paren_count = paren_count + 1\n   end\n   for i = 1, #paren_stack\
    \ do\n      if paren_stack[i] == '(' and paren_levels[paren_stack[i + 1]] == nil\
    \ then\n         paren_levels[paren_stack[i + 1]] = paren_stack[i]\n      elseif\
    \ paren_stack[i] == ')' and paren_levels[paren_stack[i - 1]] ~= nil then\n   \
    \      paren_levels[paren_stack[i - 1]] = paren_stack[i]\n      end\n   end\n\
    \   return #paren_levels\nend", "    local paren_counts = {}\n    local max_level\
    \ = 0\n    for i, c in enumerate(paren_string)\n    do\n        local level =\
    \ paren_counts[c]\n        if level == nil then\n            paren_counts[c] =\
    \ level\n        elseif level > max_level then\n            max_level = level\n\
    \        end\n    end\n    return max_level\nend", "    local group_counter =\
    \ 1\n    local max_level = 0\n    for paren_pair in string.gmatch(paren_string,\
    \ '[()]+') do\n        local group_level = group_counter\n        local last_char\
    \ = string.sub(paren_pair, 1, 1)\n        if last_char == '(' then\n         \
    \   group_level = group_level + 1\n        end\n        if last_char == ')' then\n\
    \            group_level = group_level - 1\n        end\n        max_level = math.max(max_level,\
    \ group_level)\n    end\n    return max_level\nend", "  local parsed_strings =\
    \ {}\n  local open_count = 0\n  local closed_count = 0\n  for sub_string in string.gmatch(paren_string,\
    \ \"%S+\") do\n    if sub_string:sub(1, 1) ~= '(' then\n      parsed_strings[open_count]\
    \ = sub_string\n      open_count = open_count + 1\n    end\n    if sub_string:sub(1,\
    \ 1) == ')' then\n      closed_count = closed_count + 1\n    end\n  end\n  if\
    \ closed_count ~= open_count then\n    error(\"Mismatched parentheses\")\n  end\n\
    \  return parsed_strings\nend", "  local nested_paren_stack = [1]\n  local result\
    \ = 0\n  local levels = 0\n  local paren_count = 0\n  for i = 1, #paren_string\
    \ do\n    if paren_string:sub(i, i) == '(' and paren_count > 0 then\n      --\
    \ Increment the nesting level\n      levels = levels + 1\n      -- Add the nesting\
    \ level to the stack if it is not already in it\n      if levels > nested_paren_stack[#nested_paren_stack]\
    \ then\n        table.insert(nested_paren_stack, levels)\n      end\n      --\
    \ Increment the number of open parens\n      paren_count = paren_count + 1\n \
    \   elseif paren_string:sub(i, i) == ')' and paren_count > 0 then\n      -- Decrement\
    \ the number of open parens\n      paren_count = paren_count - 1\n      -- Check\
    \ if the number of open parens is 0\n      if paren_count == 0 then\n        --\
    \ If there are no more open parens, check if the nesting level is equal to the\
    \ number of levels in the stack\n        if levels == #nested_paren_stack[#nested_paren_stack]\
    \ then\n          -- If so, that means that (()()) has two levels of nesting while\
    \ ((())) has three\n          -- Increment the number of levels in the stack\n\
    \          table.insert(nested_paren_stack, levels + 1)\n        end\n      end\n\
    \      -- Decrement the nesting level\n      levels = levels - 1\n      if levels\
    \ < nested_paren_stack[#nested_paren_stack] then\n        -- If there are still\
    \ some levels left in the stack, it means that (()()) has two levels of nesting\
    \ while ((())) has three\n        -- Decrement the number of levels in the stack\n\
    \        table.insert(nested_paren_stack, levels)\n      end\n    end\n  end\n\
    \  return result\nend", "    local nested_parens =\n        paren_string:gsub('(%[(%)([%w_]+)\
    \ %])', function(s)\n            -- We use %w instead of [^%w] to match characters\
    \ with accents\n            -- because this seems to give the best results in\
    \ a UTF-8\n            -- encoded string with accents.\n            local paren_count\
    \ = s:match(\"^%[(%)([%w_]+)\")]\n            if paren_count == nil then\n   \
    \             assert(false, \"Failed to parse nested parens in string: \"..paren_string)\n\
    \            end\n            return paren_count\n        end)", "\tlocal groups\
    \ = paren_string:gsub('([()]+)([^()]+)', \"'\\\\1':\\2,\")\n\tlocal max_depth\
    \ = groups.count('(') - groups.count(')')", "\t-- The longest match is determined\
    \ by the length in parentheses.\n\t-- The shortest match is determined by the\
    \ parentheses themselves.\n\tlocal max_level_of_nesting = -1\n\tlocal max_level_of_parentheses\
    \ = -1\n\tlocal paren_start_pos = nil\n\tlocal paren_end_pos = nil\n\tlocal paren_opening_count\
    \ = 1\n\tlocal paren_end_pos = {}\n\tlocal in_parens = 0\n\tlocal paren_level\
    \ = 0\n\tlocal pos = 0\n\tlocal prev_pos = nil", "    local parsed_groups = {}\n\
    \    local max_groups = -1\n    local num_opening_brackets = 0\n    local num_closing_brackets\
    \ = 0\n    local brackets_nesting = 0\n    local last_bracket = -1\n    local\
    \ group_index = 1\n    for i = 1, #paren_string, 1 do\n        local char = paren_string[i]\n\
    \        local is_closing = char == ')'\n        if group_index > max_groups or\
    \ brackets_nesting > max_groups or num_closing_brackets > num_opening_brackets\
    \ then\n            max_groups = group_index\n            num_opening_brackets\
    \ = num_closing_brackets\n            num_closing_brackets = 0\n            brackets_nesting\
    \ = 1\n        end\n        if last_bracket == -1 or (is_closing and last_bracket\
    \ < i) then\n            last_bracket = i\n            parsed_groups[group_index]\
    \ = brackets_nesting\n        else\n            num_closing_brackets = num_closing_brackets\
    \ + 1\n            brackets_nesting = brackets_nesting + 1\n        end\n    \
    \    group_index = group_index + 1\n    end\n    return parsed_groups\nend", " \
    \   local groups = {}\n    local index = 1\n    local depth = 0\n    local inOpen\
    \ = 0\n    local inClose = 0\n    local openGroup = 1", "  local parse = { stack\
    \ = { open = 0, closed = {}, stack = { open = 0 } } }\n  local opening = false\n\
    \  local opening_level\n  local closed = {}\n  local close_level", "  local paren_count\
    \ = 0\n  local paren_level = 0\n  local paren_stack = {}\n  local paren_max_level\
    \ = 0\n  local paren_stack_string = ''", "   local function count_parens(level)\n\
    \      local parens = 0\n      for i = 1, level do\n         if paren_string:sub(1,\
    \ i) == '(' then\n            parens = parens + 1\n         elseif paren_string:sub(1,\
    \ i) == ')' then\n            parens = parens + 1\n         end\n      end\n \
    \     return parens\n   end\n   local function count_open_parens(level)\n    \
    \  local open_parens = 0\n      for i = 1, level do\n         if paren_string:sub(i,\
    \ i) == '(' then\n            open_parens = open_parens + 1\n         end\n  \
    \    end\n      return open_parens\n   end", "  local groups = paren_string:gsub('[^()]+',\
    \ ' '):gmatch('%[(%)]+')\n  local max_level = 0\n  for _, group in ipairs(groups)\
    \ do\n    local level_of_nesting = #group\n    if level_of_nesting > max_level\
    \ then max_level = level_of_nesting end\n  end\n  return max_level\nend", "  \
    \ local num_pars = 0\n   local max_pars = 0\n   local pars = {}\n   for paren\
    \ in string.gmatch(paren_string, \"([^()]+)(.*)\") do\n      if paren == \"()\"\
    \ then\n         if num_pars > max_pars then\n            max_pars = num_pars\n\
    \         end\n         pars[num_pars] = max_pars\n         num_pars = num_pars\
    \ + 1\n      else\n         if pars[num_pars-1] ~= pars[num_pars] then\n     \
    \       if max_pars > pars[num_pars-1] then\n               max_pars = pars[num_pars]\
    \ - 1\n            else\n               max_pars = pars[num_pars]\n          \
    \  end\n         end\n      end\n   end\n   return max_pars\nend", "   local groups\
    \ = paren_string:gsub('(%a+)(%a+)', function(_, group1, group2)\n      local levels\
    \ = group2:gsub('%+%+', ''):gsub('%()%?%+%+', ''):gsub('%()%+%?', ''):gsub('%+%?',\
    \ '') -- Remove all unnecessary spaces.\n      if levels:match('0*$') then --\
    \ If a string of 0s, there is nothing to parse.\n         return group1\n    \
    \  elseif levels:match('0*$') then -- If a string of 0s, there is nothing to parse.\n\
    \         return group1\n      else\n         return group1 .. levels:gsub('(%?)(%*)(%?)(%*)$',\
    \ '\\1\\3\\4'):gsub('(%*)(%*)(%*)(%*)$', '\\3\\4'):gsub('(%*)(%*)(%*)$', '\\4')\n\
    \      end\n   end)\n   local groups_with_parentheses = {}\n   for _, group in\
    \ ipairs(groups) do\n      groups_with_parentheses[#groups_with_parentheses +\
    \ 1] = {[group]:match('%^%*([^%^%)]*%+)%+[%^%)]')}\n   end\n   return table.concat(groups_with_parentheses)\n\
    end", "    local paren_level = 0\n    local paren_nesting = 0\n    local paren_stack\
    \ = {}\n    local paren_group = {}\n    local paren_count = 0\n    local paren_index\
    \ = 1", "   local max_level = 0\n   local paren_counts = { } -- Keep track of\
    \ how many open ( and how many close )", "    local result = {}\n    local curr_level\
    \ = 1\n    for paren in split(paren_string, \" \") do\n        if paren == \"\
    ()\" then\n            table.insert(result, curr_level)\n        else\n      \
    \      local nested_level = 1\n            local curr_paren = 0\n            for\
    \ c in paren:gmatch(\"%A\") do\n                if c == '(' and curr_paren ==\
    \ 0 then\n                    nested_level = curr_level + 1\n                elseif\
    \ c == ')' and curr_paren > 0 then\n                    nested_level = curr_level\n\
    \                end\n                curr_paren = curr_paren + 1\n          \
    \  end\n            table.insert(result, nested_level)\n        end\n    end\n\
    \    return result\nend", "  local output = {}\n  for _, paren in ipairs(paren_string:gsub('([()\\\
    \\s]+)', '\\\\1')) do\n    if paren == '(' or paren == ')' then\n      output.insert(1)\n\
    \    else\n      local level, paren_count = 0, 0\n      for char in paren do\n\
    \        level = level + 1\n        if char == '(' or char == ')' then\n     \
    \     paren_count = paren_count + 1\n        elseif paren_count == 0 then\n  \
    \        table.insert(output, level)\n        end\n      end\n    end\n  end\n\
    \  return output\nend", "   local paren_stack = { }\n   local nested_level = 0\n\
    \   local parens = 0\n   for paren_char in paren_string:gmatch('[^()]+') do\n\
    \      if paren_char == '(' and nested_level > 0 then\n         paren_stack[paren_stack]:insert(parens)\n\
    \         parens = parens + 1\n      elseif paren_char == ')' and nested_level\
    \ > 0 then\n         local inner_parens = paren_stack[paren_stack]:pop()\n   \
    \      if inner_parens == 1 then\n            nested_level = nested_level - 1\n\
    \         end\n         parens = parens - inner_parens\n      elseif paren_char\
    \ == '(' or paren_char == ')' then\n         nested_level = nested_level + 1\n\
    \      end\n   end\n   if nested_level > 0 then\n      return nil\n   end\n  \
    \ if parens == 0 then\n      return 0\n   end\n   return parens\nend", "  local\
    \ num_groups = paren_string:gsub('[^()]+'):gsub('(%w+)(%w+)(%w+)', '%1+%2+%3'):gsub('%w+/+',\
    \ '%1+'):gsub('/+%w+', '%1')\n  local groups = paren_string:gsub('[^()]+'):gsub('(%w+)(%w+)(%w+)',\
    \ '%1+%2+%3'):gsub('%w+', '%1')\n  local num_levels = 2\n  for i = 1, num_groups:len()\
    \ - 1 do\n    local level = groups:sub(i, i + 1):gsub('%w+', '%1')\n    if level:sub(1,\
    \ 1) == '(' and level:sub(-1) == ')' then\n      num_levels = num_levels + 1\n\
    \    end\n  end\n  return num_levels\nend", "  if paren_string == nil then return\
    \ nil end\n  local index = 1\n  local stack = {}\n  stack[index] = paren_string:sub(1,index)\n\
    \  index = 1\n  while paren_string:sub(index,index) == '(' and paren_string:sub(index+1,index+1:find(\"\
    )\")) == nil do\n    index = index + 1\n    stack[index] = paren_string:sub(1,index)\n\
    \  end\n  local max_depth = stack[1]\n  for i = 2, #stack do\n    if stack[i]\
    \ ~= nil then\n      max_depth = math.max(max_depth, stack[i])\n    end\n  end\n\
    \  local depth = 0\n  for i = 2, #stack do\n    if stack[i] ~= nil then\n    \
    \  depth = depth + 1\n    end\n  end\n  return max_depth\nend", "    local level_of_nesting\
    \ = 0\n    local paren_groups = {}", "  local stack = {}\n  local level = 0\n\
    \  local max_level = 1\n  for paren in string.gmatch(paren_string, '%S+') do\n\
    \    local current_level = stack[#stack + 1]\n    if string.len(paren) > 0 then\n\
    \      if paren[1] == '(' and string.len(paren) > 2 then\n        current_level\
    \ = current_level + 1\n      elseif paren[1] == ')' and string.len(paren) > 1\
    \ then\n        current_level = current_level - 1\n      elseif current_level\
    \ == 0 then\n        stack[#stack + 1] = string.len(paren) + 1\n      else\n \
    \       max_level = math.max(max_level, current_level)\n      end\n    end\n \
    \ end\n  return max_level\nend", "  local levels = {}\n  local max_level = 0\n\
    \  local counts = {}\n  for paren_group in str:gmatch('(%S+)') do\n    local max_count\
    \ = 1\n    local paren_group_count = #(paren_string:match(paren_group))\n    if\
    \ paren_group_count > 0 then\n      local paren_group_level = 1\n      for _,\
    \ paren in pairs(paren_string:gmatch(paren_group)) do\n        local count = counts[paren]\n\
    \        if count ~= 0 then\n          count = count + 1\n        else\n     \
    \     count = 1 \n        end\n        counts[paren] = count\n        if count\
    \ > max_count then\n          max_count = count\n          max_level = paren_group_level\n\
    \        end\n        paren_group_level = paren_group_level + 1\n      end\n \
    \   end\n    levels[paren_group] = max_level\n  end\n  return levels\nend", " \
    \ local parsed_parens = {}\n  local parsed_count = {}\n  for paren in string.gmatch(paren_string,\
    \ \"((%S+))\") do\n    local count = parsed_count[paren]\n    if not count then\n\
    \      parsed_parens[paren] = count\n      parsed_count[paren] = 1\n    else\n\
    \      parsed_count[paren] = count + 1\n    end\n  end\n  return parsed_parens\n\
    end", "    local parsed_groups = paren_string:gsub('( )', ' '):gsub('([^ )]*)(\
    \ )([^ ]*)', '\\2\\3')\n    parsed_groups = parsed_groups:gsub('(%[(])', '[')\n\
    \    parsed_groups = parsed_groups:gsub('(%[)]', ']')\n    parsed_groups = parsed_groups:gsub('(%{)',\
    \ '{')\n    parsed_groups = parsed_groups:gsub('(%})', '}')\n    parsed_groups\
    \ = parsed_groups:gsub('(%[)(])', '[')\n    parsed_groups = parsed_groups:gsub('(%[)]])',\
    \ ']')\n    parsed_groups = parsed_groups:gsub('(%{)(})', '{}')\n    parsed_groups\
    \ = parsed_groups:gsub('(%[)([^ ]*)( )([^ ]*)', '\\2\\3')\n    parsed_groups =\
    \ parsed_groups:gsub('(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%[)(%",
  "  local paren_stack = {}\n  local depth = 0\n  local par = 0\n  local nested =\
    \ 0\n  for par, c in enumerate(paren_string) do\n    if c == '(' then paren_stack[par]\
    \ = depth\n    else if c == ')' then -- End of an expression.\n      local curr_depth\
    \ = paren_stack[par]\n      local new_depth = depth - 1\n      if new_depth >\
    \ curr_depth then -- Paranoia\n        nested = nested + 1 -- Increment counter\
    \ if current depth is different than the last depth.\n      end\n      if paren_stack[par]\
    \ == depth then -- If current paren depth is same as last depth, end the expression.\n\
    \        paren_stack[par] = nil\n      end\n      depth = paren_stack[par]\n \
    \   else -- If non-paren, then it can belong to current expression.\n      paren_stack[par]\
    \ = depth\n      depth = paren_stack[par]\n    end\n  end\n  return nested, par,\
    \ depth\nend", "  local parsed_list = {}\n  local paren_count = 0\n  local open_count\
    \ = 0", "    if type(paren_string) ~= 'string' then\n        error('Argument must\
    \ be string')\n    end\n    local parens = {}\n    local level = 0\n    local\
    \ in_string = false\n    for char in paren_string:gmatch('[^()]+') do\n      \
    \  if char == '(' then\n            if level == 0 then\n                level\
    \ = level + 1\n            else\n                level = level - 1\n         \
    \   end\n        end\n        if char == ')' then\n            if level == 1 then\n\
    \                level = level + 1\n            else\n                level =\
    \ level - 1\n            end\n        end\n        if char == ' ' and not in_string\
    \ then\n            table.insert(parens, level)\n        end\n        in_string\
    \ = in_string or level > 0\n    end\n    table.sort(parens)\n    return parens\n\
    end", "  local result = {}\n  local stack = {}\n  local index = 1\n  local level\
    \ = 1\n  local is_open = true\n  while 1 do\n    local c = paren_string:sub(1,\
    \ index)\n    if c == '(' or c == '{' or c == '[' then\n      if is_open then\n\
    \        level = stack[#stack]\n      else\n        level = 1\n      end\n   \
    \   stack[#stack + 1] = level\n      is_open = true\n      index = 1\n    elseif\
    \ c == ')' or c == '}' or c == ']' then\n      if is_open then\n        if level\
    \ == stack[#stack] then\n          level = stack[#stack] - 1\n        else\n \
    \         index = index - 1\n        end\n        stack[#stack + 1] = level\n\
    \        is_open = false\n      else\n        index = index - 1\n      end\n \
    \   end\n    index = index + 1\n    if index >= #paren_string then\n      break\n\
    \    end\n  end\n  if #result > 0 then\n    table.sort(result)\n  end\n  return\
    \ result\nend", "    local brackets = {}\n    for _, paren_string in ipairs(paren_string:gmatch(\"\
    [^()]+\")) do\n        local bracket = brackets[paren_string] or 0\n        brackets[paren_string]\
    \ = bracket+1\n    end\n    return unpack(brackets, 1, #brackets)\nend", "  local\
    \ nested_level = 0\n  local result = 0\n  for paren_group in string.gmatch(paren_string,\
    \ \"(%S+)\") do\n    local group_level = string.find(paren_group, '[()]')\n  \
    \  if group_level == nil then\n      group_level = string.len(paren_group)\n \
    \   end\n    nested_level = nested_level + group_level - 1\n    result = result\
    \ + group_level\n  end\n  return result\nend", "    local parens = paren_string:gsub('(%w+)(%w+)',\
    \ function(w1, w2)\n        return w2 - w1 + 1\n    end):gsub('(.)(.)', function(w1,\
    \ w2)\n        return w1 * w2 + w2\n    end):gsub('(.)(%w+)', function(w1, w2)\n\
    \        return w2 * w1 + w2\n    end):gsub('(%w+)', function(w1)\n        return\
    \ 1\n    end):gsub('%w+', '')\n    local nested_levels = parens:gsub('%w+', function(a)\n\
    \        return tonumber()\n    end)\n    return table.maxn(nested_levels)\nend",
  "   -- Initialize with level set to 0 for each group\n   local groups = {}\n   for\
    \ _, paren in ipairs(paren_string) do\n      groups[#groups + 1] = paren\n   end\n\
    \   -- Scan the string and add level of parenthesis for each group\n   local max_level\
    \ = 0\n   for i = 1, #groups do\n      local level = #groups - i - 1\n      max_level\
    \ = math.max(max_level, level)\n   end\n   local result = {max_level}\n   local\
    \ num_open = 0\n   -- Iterate over groups to calculate the deepest level of parenthesis\n\
    \   for i = 1, #groups do\n      local level = groups[i]:find('()+')\n      --\
    \ Skip parentheses that are empty or are all closed\n      if level == nil then\n\
    \         num_open = num_open + 1\n         continue\n      end\n      level =\
    \ level:gsub('()+', '')\n      local num_closed = #groups[i] - 1\n      level\
    \ = level:gsub('()', '')\n      if level > result[#result] then\n         result[#result]\
    \ = level\n      end\n   end\n   return result\nend", "  local max_level = 0\n\
    \  local level = 1\n  local stack = { }\n  local group = 0\n  local group_size\
    \ = 0\n  local grouping = 0\n  local opening_level = 0\n  local closed_level =\
    \ 0\n  for i = 1, #paren_string, 1 do\n    if paren_string[i] == '(' then\n  \
    \    opening_level = level\n      stack[#stack + 1] = opening_level\n      level\
    \ = level + 1\n      grouping = grouping + 1\n      group_size = group_size +\
    \ 2\n      if grouping > max_level then\n        max_level = grouping\n      end\n\
    \    elseif paren_string[i] == ')' then\n      level = stack[#stack]\n      closed_level\
    \ = closed_level + 1\n      if closed_level >= level then\n        if level >\
    \ max_level then\n          max_level = level\n        end\n        level = level\
    \ - 1\n      end\n      opening_level = level\n      stack[#stack] = opening_level\n\
    \      grouping = grouping - 1\n      if grouping < 1 then\n        group = 1\n\
    \        group_size = 1\n      else\n        group_size = group_size - 1\n   \
    \   end\n    end\n  end\n  return max_level\nend", "    local nested_parens =\
    \ {}\n    local paren_stack = {paren_string}", "   local out = {}\n   local depth\
    \ = 0", "  local result = {}\n  for part in string.gmatch(paren_string, '%a+')\
    \ do\n    if part ~= '(' then insert(result, 0) end\n    for level = 0, #part\
    \ - 1 do\n      insert(result, level + 1)\n    end\n  end\n  return result\nend",
  "  local max_level_of_nesting = 0\n  local nested_parens = {}", "  -- Split string\
    \ into nested groups of parentheses.\n  local num_levels = #(paren_string)\n \
    \ local level_of_nesting = 0\n  local nested_strings = {}\n  for i = 1, num_levels\
    \ do\n    local current_string = paren_string:sub(1, i)\n    level_of_nesting\
    \ = level_of_nesting + 1\n    nested_strings[level_of_nesting] = current_string\n\
    \  end", "  -- Find the number of opening and closing parentheses first.\n  local\
    \ num_opening_parens = 1\n  local num_closing_parens = 1\n  for char in paren_string:gmatch('%[(%a)]')\
    \ do\n    -- If the opening paren is found, then increase the count.\n    if char\
    \ == '(' then\n      num_opening_parens = num_opening_parens + 1\n    elseif char\
    \ == ')' then\n      num_closing_parens = num_closing_parens + 1\n    end\n  end\n\
    \  local num_paren_levels = num_opening_parens + num_closing_parens\n  local nested_paren_levels\
    \ = { num_paren_levels }", "    local max_level = 0\n    local level = 1", " \
    \ local num_levels = 0\n  local levels = { num_levels = 0 }\n  local num_nested_levels\
    \ = 0\n  local nested_levels = { num_nested_levels = 0 }\n  local result\n  local\
    \ i = 1\n  local level = 0\n  local nested_level = 0\n  local parens", '  if #paren_string
    == 0 then return {0} end', "  local nested_count = 0\n  local num_levels = 0\n\
    \  local level = 0\n  for paren in string.gmatch(paren_string, \"%b()()\") do\n\
    \    if paren == \"(\" then\n      nested_count = nested_count + 1\n      if nested_count\
    \ > num_levels then\n        num_levels = nested_count\n        level = num_levels\n\
    \      end\n    elseif paren == \")\" then\n      nested_count = nested_count\
    \ - 1\n      if nested_count < level then\n        num_levels = level\n      end\n\
    \    end\n  end\n  return num_levels\nend", "  local max = 0\n  local nesting\
    \ = 0\n  for _, _, _ in string.gmatch(paren_string, \"%w+\") do\n    if nesting\
    \ > max then\n      max = nesting\n    end\n    nesting = nesting + 1\n  end\n\
    \  return max\nend", "    local levels = { }\n    local nesting_level = 1\n  \
    \  local last_char = '('\n    for char in string.gmatch(paren_string, \"%b()()()\"\
    ) do\n        levels[nesting_level] = levels[nesting_level] or nesting_level\n\
    \        if last_char == ')' then\n            nesting_level = levels[nesting_level]\
    \ - 1\n        end\n        last_char = char\n    end\n    return nesting_level\n\
    end", "  local level = 0\n  local brackets = 1\n  local brackets_stack = {}\n\
    \  local strings = paren_string:gmatch(\"[^()]+\")\n  local stack = {{strings[1]}}",
  "    local level = 1\n    local levels = [level]\n    while true do\n        local\
    \ match = paren_string:match('%[(%a+)%]')\n        if not match then break end\n\
    \        local group_count = tonumber(match[1])\n        if group_count > levels[level]\
    \ then\n            levels[level] = group_count\n        end\n        level =\
    \ level + 1\n    end\n    return levels\nend", "  local index = 1\n  local max_level\
    \ = 0\n  local current_level = 1\n  local nested_groups = {}\n  while true do\n\
    \    index = string.find(paren_string, \"(\", index)\n    if index == nil then\n\
    \      break\n    end\n    nested_groups[#nested_groups + 1] = 1\n    current_level\
    \ = current_level + 1\n    index = string.find(paren_string, \")\", index) + 1\
    \ -- skip to first non-nested parenthesis\n  end\n  local level = 0\n  for i =\
    \ 1, #nested_groups do\n    level = level + 1\n    if level > max_level then\n\
    \      max_level = level\n    end\n  end\n  return max_level\nend", "\tlocal paren_count\
    \ = { [0] = 0 }\n\tlocal paren_level = { [0] = 0 }\n\tlocal paren_stack = { [0]\
    \ = {} }", "    local max_level = 0\n    local levels = { 0 }\n    for _, group\
    \ in string.gmatch(paren_string, '%%(%x%x%x)+') do\n        local open_count =\
    \ tonumber(group) or 1\n        levels[#levels + 1] = open_count > max_level and\n\
    \            open_count or max_level\n        max_level = levels[#levels]\n  \
    \  end\n    return levels\nend", "    local groups = paren_string:gmatch('%[()]([^()]*?)[()]*?(%[()])?%[(]%[()]*?%[)]*?')\n\
    \    local results = {}\n    for _, v in pairs(groups) do\n        table.insert(results,\
    \ v:gsub('(%)([()])', '%1%2'):gsub('%([()])(%)', '%1%2%3'))\n    end\n    return\
    \ results\nend", "    local group_counts = paren_string:gsub('[^()]+', function(v)\n\
    \        return v:match('(%S+)'):match('%%(%S+)') + 1\n    end)\n    local max_group_level\
    \ = max(unpack(group_counts))\n    local max_group_count = 0\n    for i = 1, max_group_level\
    \ do\n        if group_counts[i] == max_group_count then\n            max_group_count\
    \ = max_group_count + 1\n        else\n            max_group_count = max_group_count\n\
    \        end\n    end\n    return max_group_level\nend", "    local results =\
    \ {}\n    local stack_start = 1\n    local stack_length = #paren_string\n    local\
    \ max_nesting = 0\n    while stack_length > 0 do\n        local stack_end = stack_start\
    \ + stack_length - 1\n        local opening = paren_string:sub(1, stack_end-1)\
    \ -- remove leading opening (\n        local closing = paren_string:sub(stack_end,\
    \ stack_end) -- remove closing )\n        local level = stack_end - 1\n      \
    \  local nesting = 1 -- start nesting levels at 1\n        while nesting <= level\
    \ do\n            local current_chars = opening:sub(1, nesting + 1) -- extract\
    \ all characters up until the next nested parentheses (\n            nesting =\
    \ nesting + 1\n            local current_nesting = nesting - 1\n            for\
    \ _, c in pairs(current_chars) do\n                if c == '(' or c == '[' then\n\
    \                    if current_nesting > max_nesting then\n                 \
    \       max_nesting = current_nesting\n                        results = results\n\
    \                    end\n                end\n                if c == ')' or\
    \ c == ']' then\n                    -- if the closing parenthese was already\
    \ removed, then skip this closing parenthese and increment the nesting level\n\
    \                    if nesting <= max_nesting then\n                        nesting\
    \ = nesting + 1\n                    else\n                        -- remove this\
    \ closing parenthese from the stack\n                        stack_length = stack_length\
    \ - 1\n                        stack_start = stack_start + stack_length\n    \
    \                    break\n                    end\n                end\n   \
    \         end\n        end\n        stack_start = stack_start + stack_length +\
    \ 1\n    end\n    return results\nend\n</code>\nThe example uses some simple regex\
    \ to extract strings that represent nested parentheses:\n<code>", "  local level\
    \ = 0\n  local max_level = 0", "  local paren_stack = [1]\n  local depth = 0\n\
    \  local level_stack = [1]\n  local current_depth = 0\n  local max_depth = 0\n\
    \  for paren in string.gmatch(paren_string, '()') do\n    local new_depth = paren_stack[depth\
    \ + 1] + 1\n    if new_depth > current_depth then\n      current_depth = new_depth\n\
    \    end\n    max_depth = math.max(max_depth, current_depth)\n    paren_stack[depth\
    \ + 1] = new_depth\n    local new_level_stack = level_stack[depth + 1]\n    local\
    \ next_level_stack = level_stack[depth + 1] + 1\n    for i = 0, max_depth do\n\
    \      level_stack[depth + 1] = next_level_stack\n    end\n    if paren == '('\
    \ or paren == '[' then\n      depth = depth + 1\n    elseif paren == ')' or paren\
    \ == ']' then\n      depth = depth - 1\n    end\n  end\n  for i = 0, max_depth\
    \ do\n    level_stack[depth + 1] = current_depth\n  end\n  return max_depth\n\
    end", "   local levels = {}\n   local paren_counts = {}\n   local level = 0\n\
    \   local open_brackets = 0\n   local current_paren_count = 0\n   local level_ptr\
    \ = 0\n   local cur_paren = {}\n   for i = 1, #paren_string, 1 do\n      local\
    \ char = paren_string:sub(i, i)\n      local is_open = open_brackets == 0 and\
    \ char == '('\n      if is_open then\n         open_brackets = open_brackets +\
    \ 1\n         local idx = 1\n         while idx < #current_paren_count do\n  \
    \          local current_paren = current_paren_count[idx]\n            local is_open_2\
    \ = open_brackets == 0 and current_paren == '('\n            if is_open_2 then\n\
    \               open_brackets = open_brackets + 1\n               idx = 1\n  \
    \          else\n               if current_paren > 1 then\n                  level\
    \ = level + 1\n               end\n               idx = idx + 1\n            end\n\
    \         end\n         if level == 0 then\n            level = 1\n         end\n\
    \         if level == 0 then\n            level_ptr = level_ptr + 1\n        \
    \    levels[level_ptr] = level\n            current_paren_count[level_ptr] = 1\n\
    \         else\n            level_ptr = level_ptr + 1\n            levels[level_ptr]\
    \ = level\n         end\n      else\n         local is_close = open_brackets >\
    \ 0 and char == ')'\n         if is_close then\n            open_brackets = open_brackets\
    \ - 1\n         end\n         local idx = 1\n         while idx < #current_paren_count\
    \ do\n            local current_paren = current_paren_count[idx]\n           \
    \ local is_close_2 = open_brackets == 0 and current_paren == ')'\n           \
    \ if is_close_2 then\n               open_brackets = open_brackets + 1\n     \
    \          idx = 1\n            else\n               if current_paren > 1 then\n\
    \                  level = level - 1\n                  if level == 0 then\n \
    \                    level = levels[level_ptr]\n                     level_ptr\
    \ = level_ptr + 1\n                     levels[level_ptr] = level\n          \
    \           current_paren_count[level_ptr] = 1\n                  else\n     \
    \                level = levels[level_ptr]\n                     level_ptr = level_ptr\
    \ + 1\n                     levels[level_ptr] = level\n                     current_paren_count[level_ptr]\
    \ = current_paren - 1\n                  end\n               end\n           \
    \    idx = idx + 1\n            end\n         end\n         if open_brackets ==\
    \ 0 and level > 1 then\n            level = level - 1\n         end\n        \
    \ if level == 0 then\n            level = 1\n         end", "  local parsed_list\
    \ = {}\n  for parens in string.gmatch(paren_string, '%[(%a*)%z(%a*)%z]')\n   \
    \ do\n      parsed_list[#parsed_list + 1] =\n        unpack(string.gsub(parens,\
    \ '%z+', ''))\n    end\n  return parsed_list\nend", "    local nested_levels =\
    \ {}\n    local last_open = 0\n    local last_close = 0\n    for idx, character\
    \ in ipairs(paren_string) do\n        if character == OPEN_PARENS then\n     \
    \       if last_open ~= 0 then\n                table.insert(nested_levels, last_open\
    \ - last_close + 1)\n            end\n            last_open = idx\n        elseif\
    \ character == CLOSE_PARENS then\n            if last_close ~= 0 then\n      \
    \          table.insert(nested_levels, last_open - last_close + 1)\n         \
    \   end\n            last_close = idx\n        end\n    end\n    table.insert(nested_levels,\
    \ last_open - last_close + 1)\n    return nested_levels\nend", "    -- Split by\
    \ spaces, remove duplicates\n    local nested_paren_strings = {}\n    for str\
    \ in string.gmatch(paren_string, '[^ ]+') do\n        table.insert(nested_paren_strings,\
    \ str)\n    end\n    table.sort(nested_paren_strings)", "\tlocal parsed_parens\
    \ = {} -- Each key is string of nested parentheses, value is max level of nesting\
    \ of those parentheses.\n\tfor paren in string.gmatch(paren_string, \"(%[(%w+)%*]+%)\"\
    )\n\tdo\n\t\tlocal current_paren = paren\n\t\tlocal current_level = 1\n\t\tlocal\
    \ last_paren = ''\n\t\t-- Find out if there is a parent with matching level\n\t\
    \twhile parsed_parens[current_paren] and parsed_parens[current_paren] < current_level\
    \ do\n\t\t\tcurrent_paren = parsed_parens[current_paren]\n\t\tend\n\t\t-- If there\
    \ is no paren found with same level\n\t\tif not parsed_parens[current_paren] then\n\
    \t\t\t-- If there is no paren with same level than parent with next level\n\t\t\
    \tif parsed_parens[current_paren + 1] then\n\t\t\t\t-- Update the level\n\t\t\t\
    \tcurrent_level = parsed_parens[current_paren + 1] + 1\n\t\t\t-- Else if there\
    \ is no paren with previous level than parent with previous level\n\t\t\telseif\
    \ parsed_parens[current_paren - 1] then\n\t\t\t\t-- Update the level\n\t\t\t\t\
    current_level = parsed_parens[current_paren - 1] - 1\n\t\t\t-- Else if there is\
    \ only one paren than just updates the level\n\t\t\telse\n\t\t\t\t-- Update the\
    \ level\n\t\t\t\tcurrent_level = 1\n\t\t\tend\n\t\t\t-- If there are still unmatched\
    \ parens then just update the level\n\t\t\tif not current_paren then\n\t\t\t\t\
    current_level = 1\n\t\t\tend\n\t\t\t-- Update the last paren\n\t\t\tlast_paren\
    \ = current_paren\n\t\tend\n\t\t-- Update the parens object\n\t\tparsed_parens[current_paren]\
    \ = current_level\n\t\t-- Update the last paren\n\t\tlast_paren = current_paren\n\
    \tend\n\t-- Return the max level of nesting of a paren\n\treturn parsed_parens\n\
    end", "  local parens = paren_string:gsub(\"%[(%[(%[(%[(%[(\", \"()\") .. \")]\"\
    )]\")]\")\n  local function count_level(parens, level=0)\n    local level_count\
    \ = parens:gsub(\"%[(%[(\", \"(\"):gsub(\")\")]\"):gsub(\"[()()]\", \"%s\"):gsub(\"\
    %s*\", level)\n    return level_count\n  end\n  local function get_max_level(level_count)\n\
    \    local max_level\n    for level = 1, #level_count do\n      if level_count[level]\
    \ == level_count[level - 1] then\n        max_level = level\n        break\n \
    \     end\n    end\n    return max_level\n  end\n  return count_level(parens,\
    \ get_max_level(parse_nested_parens(parens)))\nend", "  local nested_level = 1\n\
    \  local paren_stack = { 1 }\n  local paren_level = 1", "  local n = 1\n  local\
    \ max_level = 0\n  local stack = { paren_string, nil }\n  while stack:len() >\
    \ 0 do\n    local level, string = stack:pop()\n    if level > max_level then\n\
    \      max_level = level\n    end\n    for i = 0, string - 1 do\n      if paren_string[i]\
    \ == ')' then\n        level = level - 1\n      elseif paren_string[i] == '('\
    \ then\n        level = level + 1\n      else\n        stack:insert(level + 1,\
    \ string.sub(string, 1, i + 1))\n      end\n    end\n  end\n  return max_level\n\
    end", "  local parsed, max_level = pcall(function()\n    local function is_balanced(level)\n\
    \      return level ~= nil and level > 0\n    end\n    local function check_paren(paren,\
    \ level)\n      local left_paren = paren:sub(1,1)\n      local right_paren = paren:sub(level,level)\
    \ .. paren:sub(level+1,level+1)\n      return left_paren == '(' and right_paren\
    \ == ')'\n    end\n    local last_open = 0\n    local nested = 0\n    local parsed_string\
    \ = {}\n    for level,paren in pairs(paren_string:gsub('()()','').gsub('(()','\\\
    1 ')):gmatch'([^()]+)'do\n      if level > nested then\n        nested = level\n\
    \        parsed_string[level] = last_open\n      end\n      if check_paren(paren,level)\
    \ then\n        nested = level\n        parsed_string[level] = level\n      elseif\
    \ last_open > level then\n        nested = level\n        parsed_string[level]\
    \ = last_open\n      end\n      last_open = level\n    end\n    return parsed_string,\
    \ max_level\n  end)\n  if parsed then\n    return nested\n  end\nend", "  local\
    \ nested_level = 0\n  local level_count = {}\n  local stack = {}\n  local level_group\
    \ = {}\n  local group_count = 0\n  local groups = {}", "  -- Replace multiple\
    \ spaces with a single one\n  paren_string = paren_string:gsub('  +', \" \")\n\
    \  local level = 1\n  local paren_count = 0\n  local parens = nil\n  local in_parens\
    \ = false\n  local current_open = nil\n  local current_close = nil\n  local open_close\
    \ = nil\n  local open_bracket = nil\n  local close_bracket = nil\n  local open_brace\
    \ = nil\n  local close_brace = nil\n  local brace_open = false\n  local brace_close\
    \ = false", "  local nest = 0\n  local paren_count = 0\n  local stack = { 1 }\n\
    \  for c in string.gmatch(paren_string, '()()') do\n    if c == '(' or c == '{'\
    \ or c == '[' then\n      table.insert(stack, paren_count)\n      table.insert(stack,\
    \ c)\n      paren_count = 0\n    elseif c == '}' then\n      table.insert(stack,\
    \ paren_count)\n      table.insert(stack, nest)\n      nest = nest - 1\n     \
    \ paren_count = 0\n    elseif c == ')' then\n      table.insert(stack, paren_count)\n\
    \      table.insert(stack, nest)\n      paren_count = paren_count - 1\n      if\
    \ paren_count == 0 then\n        table.insert(stack, c)\n      end\n    end\n\
    \  end\n  return stack\nend", "  local output = {}\n  local stack = { { string\
    \ = paren_string, level = 0} }\n  repeat\n    local cur_level_str = stack[#stack].string\n\
    \    local cur_level_level = stack[#stack].level\n    local cur_level_length =\
    \ #cur_level_str\n    for i = 1, cur_level_length do\n      local char = cur_level_str:sub(i,\
    \ i)\n      if char == \"(\" then\n        stack[#stack + 1].level = stack[#stack].level\
    \ + 1\n      elseif char == \")\" then\n        stack[#stack].level = stack[#stack].level\
    \ - 1\n        if stack[#stack].level == 0 then\n          table.insert(output,\
    \ stack[#stack].level)\n          table.insert(output, cur_level_length)\n   \
    \     end\n      end\n    end\n  until cur_level_length == 0\n  return output\n\
    end", "\tlocal group_count = 0\n\tlocal level_stack = {}\n\tlocal max_level =\
    \ 1", "  local max_level = 1\n  local paren_levels = {}\n  for paren_group in\
    \ string.gmatch(paren_string, '%w+') do\n    local level = 0\n    local curr =\
    \ paren_group\n    local last_paren = 0\n    while curr ~= '(' do\n      level\
    \ = level + 1\n      curr = string.sub(curr, 1, string.find(curr, \"(\"))\n  \
    \  end\n    paren_levels[level] = level\n    local last_open = 0\n    while level\
    \ ~= 0 do\n      level = level - 1\n      last_open = string.find(curr, \"(\"\
    , last_open)\n      if level > max_level then\n        max_level = level\n   \
    \   end\n      if level < 1 then\n        break\n      end\n      if level ==\
    \ 1 then\n        level = max_level\n      end\n      last_open = string.find(curr,\
    \ \"(\", last_open)\n    end\n  end\n  return max_level, paren_levels\nend", " \
    \   local level_counts = {}\n    local max_level = 0\n    local max_levels = []\n\
    \    for paren in string.gmatch(paren_string, \"[^()]+\") do\n        local level\
    \ = level_counts[paren]\n        if not level then\n            level = 1\n  \
    \      end\n        if level > max_level then\n            max_level = level\n\
    \            max_levels = [paren]\n        elseif level == max_level then\n  \
    \          max_levels[#max_levels + 1] = paren\n        end\n        level_counts[paren]\
    \ = level + 1\n    end\n    return max_levels\nend", "   local nested_parens =\
    \ {}\n   for paren_group in string.gmatch(paren_string, '(%S+)') do\n      --\
    \ Initialize count to the number of parantheses in the group\n      -- Ex. (()())\
    \ has two levels of nesting while ((())) has three\n      local count = 1 -- Nesting\
    \ level for group levels starts at 1.\n      local paren_stack = {paren_group}\n\
    \      -- Iterate over each character in the group one by one and push to the\
    \ stack\n      for i, char in ipairs(paren_group) do\n         if char == '('\
    \ and count+1 > nesting_level then\n            nesting_level = count+1\n    \
    \        table.insert(nested_parens, count)\n         elseif char == ')' and nesting_level\
    \ == 1 then\n            -- Pop off the top level from the stack and update the\
    \ count\n            -- Ex. (()()) has two levels of nesting while ((())) has\
    \ three\n            local pop_count = table.unpack(table.drop(paren_stack))\n\
    \            nesting_level = pop_count + 1\n            table.insert(nested_parens,\
    \ nesting_level)\n         elseif char == '(' then\n            table.insert(paren_stack,\
    \ char)\n         elseif char == ')' then\n            -- Keep popping paren count\
    \ from the stack until we hit the right bracket\n            for j = #paren_stack,\
    \ 1, -1 do\n               -- If it's the right bracket then break, else, keep\
    \ popping.\n               if paren_stack[j] == char then\n                  table.insert(nested_parens,\
    \ j)\n                  break\n               end\n            end\n         end\n\
    \      end\n   end\n   return nested_parens\nend", "  local level = 0\n  local\
    \ index = 1\n  local groups = {}\n  while index <= #paren_string:len() do\n  \
    \  local c = paren_string:subindex(index, index)\n    index = index + 1 -- the\
    \ char '(', ')', or ' '\n    if c:byte() == ')' then\n      level = level - 1\n\
    \      if level == 0 then\n        groups[#groups + 1] = 1\n      else\n     \
    \   local depth = #groups\n        if depth <= level then\n          -- return\
    \ groups[depth]\n          print(string.format('maximum level of nesting %d found.\
    \ Current depth: %d. Total size: %d', level, depth, #groups))\n        end\n \
    \     end\n    elseif c:byte() == '(' then\n      level = level + 1\n      groups[#groups\
    \ + 1] = 0\n    end\n  end\n  return groups\nend", "    local groups = paren_string:gsub('[^(]+','')\n\
    \    local current_level = 1\n    local max_level = 0\n    for _,g in ipairs(groups)\
    \ do\n        if g == '(' and current_level ~= max_level then\n            max_level\
    \ = current_level\n        end\n        current_level = current_level + 1\n  \
    \  end\n    return max_level\nend", "  local output = {}\n  local depth = 0\n\
    \  local paren_level = 0", "   local max_level = 0\n   local level = 0\n   local\
    \ level_stack = {}\n   local groups = {}\n   local group_index = 1", "  local\
    \ nested = 0\n  local nested_levels\n  local paren_count\n  local parens\n  local\
    \ paren_levels\n  local count\n  local paren_stack\n  local paren_level\n  local\
    \ paren_level_id\n  local paren_id", "  local max = 0\n  local nested_level =\
    \ 0\n  for paren_string in string.gmatch(paren_string, \"(%S+)()\") do\n    if\
    \ paren_string.charAt(1) == \"(\" then\n      nested_level = nested_level + 1\n\
    \    elseif paren_string.charAt(1) == \")\" then\n      nested_level = nested_level\
    \ - 1\n    end\n    if nested_level > max then\n      max = nested_level\n   \
    \ end\n  end\n  return max\nend", "    local paren_count = 0\n    local paren_stack\
    \ = {0}\n    local max_level = 0", "    local level = 0\n    local paren_level\
    \ = {}\n    local paren_level_groups = parse_paren_string(paren_string)", "\t\
    local parsed_string = {}\n\tlocal max_count = 0\n\tlocal current_count = 0\n\t\
    local paren_count = 0\n\tfor paren in string.gmatch(paren_string, \"%[()]*()\"\
    ) do\n\t\tif paren ~= '()' then\n\t\t\ttable.insert(parsed_string, paren_count)\n\
    \t\t\tcurrent_count = current_count + 1\n\t\telse\n\t\t\ttable.insert(parsed_string,\
    \ current_count)\n\t\t\tcurrent_count = 1\n\t\tend\n\t\tparen_count = paren_count\
    \ + 1\n\t\tif paren_count == max_count then\n\t\t\tmax_count = paren_count\n\t\
    \tend\n\tend\n\tif current_count > 1 then\n\t\ttable.insert(parsed_string, current_count)\n\
    \tend\n\treturn parsed_string\nend", "  local result = {\n    level = 0,\n  }\n\
    \  local stack = { result }\n  local open_parens = 0\n  local close_parens = 0\n\
    \  local level\n  for s in string.gmatch(paren_string, \"(%S+)()\") do\n    if\
    \ open_parens > close_parens then\n      level = stack[#stack].level\n    end\n\
    \    close_parens = open_parens\n    open_parens = open_parens + 1\n    stack[#stack+1]\
    \ = { level = level+1, result = s }\n  end\n  return stack\nend", "    local parsed_string\
    \ = paren_string:gsub('( )', '()')\n    local nested_parens = parsed_string:gsub('(%b()%b)',\
    \ function(paren_group)\n        local paren_group_split = paren_group:split('%b()%b')\n\
    \        local max_depth = 1\n        for paren_group in paren_group_split do\n\
    \            if max_depth <= 1 then\n                -- We ignore the outermost\
    \ parentheses.\n                -- They will always be at the deepest level.\n\
    \                return paren_group\n            else\n                local levels\
    \ = paren_group:gsub('%b()%b', function(group_char)\n                    -- Count\
    \ the number of left parentheses in the current level\n                    local\
    \ left_parentheses = string.len(group_char) - string.len(group_char:gsub('()',\
    \ ''))\n                    if left_parentheses > max_depth then\n           \
    \             -- If current level is longer than the previous level,\n       \
    \                 -- then update the maximum depth.\n                        max_depth\
    \ = left_parentheses\n                    end\n                    return ''\n\
    \                end)\n                -- Update the deepest level\n         \
    \       max_depth = max_depth * tonumber(levels)\n            end\n        end\n\
    \        return ''\n    end)\n    local nested_parens_list = nested_parens:gsub('%b(%b)*%b',\
    \ function() return '' end):gsub('%b()%b', function() return '' end):gsub('%b(%b()%b)*%b',\
    \ function() return '' end):gsub('%b()%b', function() return '' end):gsub('%b(%b()%b)()%b',\
    \ function() return '' end):gsub('%b()%b', function() return '' end):gsub('%b(%b()%b)()%b',\
    \ function() return '' end):gsub('%b()%b', function() return '' end):gsub('%b(%b()%b)()%b',\
    \ function() return '' end)\n    return nested_parens_list:gsub('%b()%b', function()\
    \ return '' end):gsub('%b()%b', function() return '' end):gsub('%b()%b', function()\
    \ return '' end):gsub('%b()%b', function() return '' end):gsub('%b()%b', function()\
    \ return '' end):gsub('%b()%b', function() return '' end):gsub('%b()%b', function()\
    \ return '' end):gsub('%b()%b', function() return '' end):g", "  -- Split the\
    \ string into individual groups separated by spaces.\n  local groups = paren_string:gmatch(\"\
    ([^)%s]+)\")\n  -- Iterate through the individual groups.\n  local nested_level\
    \ = 0\n  for _, group_string in ipairs(groups) do\n    -- If the group is parenthesized,\
    \ increment the level of nesting.\n    if group_string:sub(1, 1) == \"(\" then\n\
    \      nested_level = nested_level + 1\n    -- If the group is not parenthesized,\
    \ decrement the level of nesting.\n    elseif group_string:sub(1, 1) ~= \")\"\
    \ then\n      nested_level = nested_level - 1\n    end\n  end\n  return nested_level\n\
    end", "    local paren_levels = {0}\n    local max_level = 1\n    local nested_paren_count\
    \ = 0\n    local paren_levels_string = ''\n    local paren_levels_string_position\
    \ = 0\n    for _, i in ipairs(paren_string) do\n        if paren_levels_string\
    \ ~= '' then\n            paren_levels_string = paren_levels_string .. ' '\n \
    \       end\n        if i ~= '(' then\n            paren_levels_string = paren_levels_string\
    \ .. i\n        end\n        if i == ')' then\n            if paren_levels[#paren_levels]\
    \ <= max_level then\n                paren_levels[#paren_levels] = 0\n       \
    \         nested_paren_count = nested_paren_count + 1\n            else\n    \
    \            paren_levels_string_position = paren_levels_string_position + 1\n\
    \                paren_levels[#paren_levels] = max_level\n                paren_levels_string\
    \ = paren_levels_string[paren_levels_string_position + 1]\n                local\
    \ start = #paren_string\n                for i = start, 1, -1 do\n           \
    \         if paren_string[i] ~= '(' then\n                        paren_string\
    \ = paren_string[i - 1] .. paren_string[i]\n                    else\n       \
    \                 paren_string = paren_string[i - 2]\n                       \
    \ break\n                    end\n                end\n                max_level\
    \ = paren_levels[#paren_levels]\n            end\n        end\n    end\n    return\
    \ paren_levels\nend", "   local nesting_level = 0\n   local parentheses_index\
    \ = 1\n   local open_parentheses = 1\n   while parentheses_index < #paren_string\n\
    \      do\n         local current_level = nesting_level + 1\n         local open_parentheses_count\
    \ = open_parentheses * open_parentheses\n         if open_parentheses_count ==\
    \ 0 then\n            nesting_level = current_level\n         else\n         \
    \   nesting_level = nesting_level\n         end\n         local current_groups\
    \ = string.sub(paren_string, parentheses_index, parentheses_index + open_parentheses_count)\n\
    \         parentheses_index = parentheses_index + open_parentheses_count\n   \
    \      if nesting_level > current_level then\n            if nesting_level > 1\
    \ then\n               return nil\n            end\n            if current_groups\
    \ ~= '()' then\n               return nil\n            end\n         end\n   \
    \   end\n      return nesting_level\nend", "    local num_parens = paren_string:gsub('^%[())]*$',\
    \ ''):match('%[(%[(%[^%)]+)*)*%]')\n    local paren_string = paren_string:gsub('^%[())]*$',\
    \ '')\n    local max_level_of_nesting = -1\n    local max_level_of_nested_parens\
    \ = 0", "  local max_level = 0\n  local paren_levels = {}\n  for paren_string,\
    \ paren_level in string.gmatch(paren_string, \"%w+\"):gmatch(\"%w%d+(%w%d+)\"\
    ) do\n    local paren_level = tonumber(paren_level)\n    if max_level < paren_level\
    \ then\n      max_level = paren_level\n    end\n    if paren_levels[paren_level]\
    \ == nil then\n      paren_levels[paren_level] = 1\n    else\n      paren_levels[paren_level]\
    \ = paren_levels[paren_level] + 1\n    end\n  end\n  return max_level, paren_levels\n\
    end", "  local parens = {}\n  local level = 0\n  local open_bracket, close_bracket\
    \ = 0, 0\n  local in_string = 1\n  local open_bracket, close_bracket = 1, 1\n\
    \  local open_left_par = 1, 1\n  local open_right_par = 1\n  local close_bracket\
    \ = 0\n  local level = 0\n  local open_left_par, open_right_par = 1, 1", "  local\
    \ paren_string_arr = string.Explode(paren_string, \" \")\n  local max_level =\
    \ 0\n  local level = 0\n  for i = 1, #paren_string_arr do\n    local ch = paren_string_arr[i]\n\
    \    if ch == \"(\" then\n      level = level + 1\n    elseif ch == \")\" then\n\
    \      level = level - 1\n      if level > max_level then\n        max_level =\
    \ level\n      end\n    end\n  end\n  return max_level\nend", "    local max_nested_level\
    \ = 0\n    local max_depth = 0\n    for paren in string.gmatch(paren_string, '%[(%a*)([()]*)(%a*)%]')\n\
    \    do\n        local depth = string.len(paren) - string.len(paren)\n       \
    \ if depth > max_depth then\n            max_nested_level = depth\n          \
    \  max_depth = depth\n        end\n    end\n    return max_nested_level\nend",
  "    local function count_nested(paren_str, i)\n        if i >= #paren_str then\
    \ return 0 end\n        if paren_str:sub(i, i) ~= '(' and paren_str:sub(i, i)\
    \ ~= ')' then\n            return count_nested(paren_str, i+1)\n        end\n\
    \        return 1 + count_nested(paren_str, i+1)\n    end\n    local nested_count\
    \ = count_nested(paren_string, 1)\n    local max_depth = 0\n    for i = 1, nested_count\
    \ do\n        if paren_string:sub(i, i) == '(' then\n            max_depth = max_depth\
    \ + 1\n        elseif paren_string:sub(i, i) == ')' then\n            max_depth\
    \ = max_depth - 1\n            if max_depth < 0 then\n                return nil\n\
    \            end\n        end\n    end\n    return max_depth\nend", "    local\
    \ level = tonumber(paren_string)\n    if level == 0 then\n        return 0\n \
    \   end", "    local function get_level(index, result)\n        if index == 0\
    \ then\n            for i = 1, #result do\n                result[i] = 0\n   \
    \         end\n            result[index] = index\n        elseif paren_string[index]\
    \ == '(' and paren_string[index - 1] == '(' then\n            result[index] =\
    \ result[index - 1] + 1\n        elseif paren_string[index] == '(' and paren_string[index\
    \ + 1] == ')' then\n            result[index] = result[index] + 1\n        elseif\
    \ paren_string[index] == ')' and paren_string[index + 1] == '(' then\n       \
    \     result[index] = result[index] + 1\n        elseif paren_string[index] ==\
    \ ')' and paren_string[index - 1] == ')' then\n            result[index] = result[index\
    \ - 1] - 1\n        else\n            result[index] = 0\n        end\n    end\n\
    \    local paren_string = paren_string:gsub('(%[(%[(%)]%)%])', function(match)\n\
    \        return match\n    end)\n    local levels = {}\n    local index = 1\n\
    \    local result = {{}}\n    local current_level = 0\n    get_level(index, result)\n\
    \    while current_level ~= 0 do\n        table.insert(levels, current_level)\n\
    \        local index = 1\n        get_level(index, result)\n        current_level\
    \ = current_level - 1\n    end\n    return levels\nend", "  local paren_levels\
    \ = { }\n  for _, paren in ipairs(string.gmatch(paren_string, '%[(%[%*%)]+)')\
    \ do\n    paren_levels[#paren_levels + 1] = #paren + 1 -- Preserve the order of\
    \ the input string.\n  end)\n  return paren_levels\nend", "  local nested_level\
    \ = {}\n  local current_nested_level = 1\n  local open_parentheses = 0\n  local\
    \ is_inside_group\n  local i = 1\n  local last_i = 1\n  while i <= #paren_string\
    \ do\n    -- if the parenthesis is not inside parentheses, just copy it to output\n\
    \    if paren_string[i] == '(' and not is_inside_group then\n      nested_level[current_nested_level]\
    \ = paren_string[i]\n      is_inside_group = true\n      current_nested_level\
    \ = current_nested_level + 1\n      i = i + 1\n    else\n      -- if the parenthesis\
    \ is inside parentheses\n      if paren_string[i] == '(' and open_parentheses\
    \ == 0 then\n        open_parentheses = 1\n      else\n        -- if the open\
    \ parentheses is closed\n        if paren_string[i] == ')' and open_parentheses\
    \ > 0 then\n          open_parentheses = 0\n        elseif paren_string[i] ==\
    \ ')' and open_parentheses == 0 then\n          -- if the current parentheses\
    \ level is same as the previous one, increase it\n          -- NOTE: this is done\
    \ because '(' has precedence over ')', hence we can't just increment it\n    \
    \      if current_nested_level == last_i then\n            current_nested_level\
    \ = current_nested_level + 1\n          end\n          -- otherwise, increase\
    \ the nested level\n        elseif paren_string[i] == '(' and open_parentheses\
    \ > 0 then\n          -- if the current level is not equal to the previous one,\
    \ increase it\n          if current_nested_level == last_i then\n            current_nested_level\
    \ = current_nested_level + 1\n          end\n          -- otherwise, decrease\
    \ it\n        elseif paren_string[i] == ')' and open_parentheses > 0 then\n  \
    \        -- if the current level is not equal to the previous one, decrease it\n\
    \          if current_nested_level == last_i then\n            current_nested_level\
    \ = current_nested_level - 1\n          end\n          -- otherwise, increase\
    \ it\n        elseif paren_string[i] == '(' then\n          -- if the current\
    \ level is not equal to the previous one, increase it\n          if current_nested_level\
    \ == last_i then\n            current_nested_level = current_nested_level + 1\n\
    \          end\n          -- otherwise, decrease it\n        end\n        -- if\
    \ neither the open parentheses nor the close parentheses are opened\n        --\
    \ the nested level is the previous level\n        if open_parentheses == 0 then\n\
    \          nested_level[current_nested_level] = paren_string[i]\n        elseif\
    \ open_parentheses > 0 then\n          nested_level[current_nested_level] = paren_string[i]\n\
    \        end\n        is_inside_group = false\n      end\n      i = i + 1\n  \
    \  end\n    last_i = last_i + 1\n  end\n  return nested_level\nend", "    local\
    \ parsed_string = paren_string\n    -- Parse each group of nested parentheses.\n\
    \    for _, group in ipairs(parsed_string:gmatch('%[(%?%)]+')) do\n        --\
    \ Get the deepest level of nesting.\n        local level_of_nesting = 0\n    \
    \    for i = 1, #group do\n            if group[i] == '(' and group[i - 1] ==\
    \ ')' then\n                level_of_nesting = level_of_nesting + 1\n        \
    \    end\n        end\n        -- Remove parentheses.\n        parsed_string =\
    \ parsed_string:gsub('(%[%)]+)', '', group)\n        -- Add nesting level.\n \
    \       parsed_string = parsed_string:gsub('%([()]+)', function(w)\n         \
    \   local new_w = w\n            if level_of_nesting > 0 then\n              \
    \  new_w = string.format('%([%w_%W])', w)\n            end\n            return\
    \ new_w\n        end)\n    end\n    return parsed_string:gmatch('%w+')\nend",
  "    local groups = {}\n    local count = 1\n    for paren in string.gmatch(paren_string,\
    \ \"([^() ]+)(.*[^() ]+)(\\\\(([^()]+)*\\\\))?\")\n    do\n        local paren_levels\
    \ = paren_parens[paren]\n        for i = 1, #paren_levels do\n            if paren_levels[i]\
    \ <= count then\n                groups[count] = paren_levels[i]\n           \
    \ end\n        end\n        count = count + 1\n    end\n    return groups\nend",
  "    local maxlevel = 0\n    local level = 0\n    local num_open = paren_string:gsub('%[(%a+)%((%a+)%)*]',\
    \ function(match)\n        if match:match('%a') then\n            level = level\
    \ + 1\n        end\n        if level > maxlevel then maxlevel = level end\n  \
    \      return match\n    end):gsub('%[%((%a+)%)*]', '')\n    return maxlevel,\
    \ num_open\nend", "  -- The count of opening parentheses.\n  local count_of_opening_parentheses\
    \ = { }\n  local opening_parentheses_levels = { }\n  local max_level = 0\n  local\
    \ opening_parentheses_group_count = 1", "  local num_levels_of_nesting = 0\n \
    \ local nested_parentheses = {}\n  for paren in string.gmatch(paren_string, '%[()%((%[(%[%]%)])*)]')\
    \ do\n    local level = #paren\n    if level < num_levels_of_nesting then\n  \
    \    table.insert(nested_parentheses, level)\n    end\n    table.insert(nested_parentheses,\
    \ level + 1)\n    num_levels_of_nesting = num_levels_of_nesting + level + 1\n\
    \  end\n  return num_levels_of_nesting, nested_parentheses\nend", "  local level\
    \ = 0\n  local nested_level = 0\n  local paren_count = 0", "  local nested_parens\
    \ = {}\n  local opening_parens = 1\n  local opening_char = 1\n  local next_closing\
    \ = 0\n  for char in paren_string:gmatch(\"%w+\") do\n    -- If opening parentheses\
    \ is closed, increment the count and clear the opening and closing character\n\
    \    if opening_parens == opening_char then\n      opening_char = next_closing\n\
    \      opening_parens = 0\n    elseif opening_parens ~= opening_char then\n  \
    \    opening_parens = opening_char\n    end", "    local level = 0\n    local\
    \ nestings = false\n    local levels_of_nesting = {}\n    local paren_stack =\
    \ {}", "  local num_open_brackets = 0\n  local nested_levels = {}\n  local open_brackets\
    \ = {}\n  local stack = {}\n  local bracket_pairs = {}", "  local nested_level\
    \ = 0\n  local paren_stack = {}", "  local num_open = 0\n  local num_close = 0\n\
    \  local num_open_in_string = 0\n  local depth = 0\n  local paren_level = {}\n\
    \  local stack = {{paren_string}}\n  local max_level = 0\n  while #stack > 0 do\n\
    \    local size = #stack\n    local open = stack[#stack]\n    if open == '(' then\n\
    \      num_open = num_open + 1\n      num_open_in_string = num_open_in_string\
    \ + 1\n      paren_level[#paren_level + 1] = num_open\n      depth = depth + 1\n\
    \      stack = stack[size]\n    elseif open == ')' then\n      num_open = num_open\
    \ - 1\n      num_close = num_close + 1\n      if num_open_in_string <= 1 and paren_level[#paren_level]\
    \ == 0 then\n        num_close = num_close + 1\n      else\n        depth = depth\
    \ - 1\n      end\n      paren_level[#paren_level] = num_open\n      stack = stack[size]\n\
    \    end\n    if depth >= max_level then\n      max_level = depth\n    end\n \
    \ end\n  return max_level\nend", "  local parsed = {}\n  local i = 1\n  while\
    \ i <= #paren_string do\n    local num_parens = string.format(\"%d(%s)\", #parsed\
    \ + 1, paren_string:sub(i, i))\n    if paren_string:sub(i, i) ~= '()' then\n \
    \     num_parens = num_parens .. \"(1)\"\n    end\n    parsed[i] = tonumber(num_parens)\n\
    \    i = i + 1\n  end\n  return parsed\nend", "  local current_depth = 1\n  local\
    \ current_string = ''\n  for paren_group in gmatch(paren_string, '%[(%a)]') do\n\
    \    local paren_group_split = split(paren_group, ' ')\n    if current_depth <=\
    \ 0 then\n      current_string = paren_group_split[1]\n      current_depth = paren_group_split[2]\n\
    \    elseif current_depth == paren_group_split[2] then\n      current_string =\
    \ gsub(current_string, paren_group, paren_group_split[1])\n    else\n      current_string\
    \ = gsub(current_string, paren_group, paren_group_split[1]) .. ',' .. paren_group_split[1]\n\
    \      current_depth = paren_group_split[2]\n    end\n  end\n  return current_depth\n\
    end", "    -- Initialize the stack to contain pairs of the current nesting level\
    \ and the current parenthesis.\n    local stack = {{}, paren_string}\n    -- While\
    \ there is an element in the stack\n    while #stack > 0 do\n        -- Get the\
    \ current level and current parenthesis\n        local current_level, current_parenthesis\
    \ = unpack(stack)\n        -- \"pop\" the top pair if it is of current level\n\
    \        if current_level == #stack then\n            stack[#stack] = {0, ''}\n\
    \        else\n            stack[current_level] = stack[current_level] - 1\n \
    \       end\n        -- \"pop\" the top pair if it is not of current level\n \
    \       if stack[current_level] == 0 then\n            table.remove(stack, current_level)\n\
    \        end\n        -- \"push\" the top pair to the output string if the pair\
    \ is of current level\n        if current_level == #stack then\n            table.insert(output,\
    \ current_parenthesis)\n        end\n    end\n    return output\nend", "  if paren_string\
    \ == '' then\n    return nil\n  end", "  -- To parse a nested parentheses string\
    \ we need to\n  -- first split it into groups of parentheses. E.g.\n  -- (()())\
    \ -> ((()), (()))\n  -- (((()))) -> (((()))), (()))\n  -- Since a group represents\
    \ zero or more nested parentheses\n  -- and a bracket represents exactly one nested\
    \ parentheses, it\n  -- follows that a group of parentheses always contains one\
    \ and\n  -- only one nested parentheses.\n  local groups = paren_string:gsub('(%b()()%b)',\
    \ function(s)\n    -- The group function returns captured substrings. Here we\
    \ remove parentheses and add back the parentheses that should be removed later.\n\
    \    return s.gsub('()', ' '):gsub('[]()', function(_)\n      return ''\n    end)\n\
    \  end)", "   local depth = 0\n   local paren_count = 0\n   local paren_max =\
    \ 0\n   local level = {}", "\tlocal num_parens = #paren_string\n\tlocal max_level\
    \ = 0\n\tlocal level = 0\n\tfor i = 1, num_parens do\n\t\tlocal next_char = paren_string[i]\n\
    \t\tif next_char == '(' or next_char == ')' then\n\t\t\tlevel = level + 1\n\t\t\
    \tif level > max_level then\n\t\t\t\tmax_level = level\n\t\t\tend\n\t\telseif\
    \ next_char == ')' then\n\t\t\tlevel = level - 1\n\t\tend\n\tend\n\treturn max_level\n\
    end", "  local paren_stack = { }\n  local nested_level = 0\n  local current_paren_level\
    \ = 0\n  local paren_count = 0\n  local current_paren = nil\n  for i = 1, #paren_string,\
    \ 1 do\n    local c = paren_string:sub(i, i)\n    if paren_stack[#paren_stack]\
    \ == nil then\n      paren_stack[#paren_stack + 1] = current_paren_level\n   \
    \ end\n    if c == ')' then\n      if current_paren ~= nil then\n        paren_count\
    \ = #current_paren\n      end\n      -- If this is the only opening paren left\
    \ in the paren_stack, then\n      -- we have an opening paren in the current paren\
    \ level.\n      if paren_count == #paren_stack then\n        current_paren = nil\n\
    \        current_paren_level = paren_stack[#paren_stack]\n        nested_level\
    \ = #paren_stack\n      else\n        -- Remove the last element from paren_stack\n\
    \        -- Remove the element from the nested level\n        current_paren =\
    \ nil\n        current_paren_level = paren_stack[#paren_stack + 1]\n        nested_level\
    \ = #paren_stack\n      end\n      paren_count = 0\n    else\n      -- If paren_stack\
    \ is not empty, this is an opening paren\n      if current_paren ~= nil then\n\
    \        paren_count = #current_paren\n      end\n      current_paren = { }\n\
    \      current_paren.level = current_paren_level\n      current_paren.count =\
    \ paren_count\n      current_paren_level = nested_level\n      paren_count = 0\n\
    \    end\n  end\n  return paren_stack\nend", "  local groups = {}\n  local depth\
    \ = 1\n  local stack = {groups}\n  local function add_group(group, depth)\n  \
    \  table.insert(stack, group)\n    depth = depth + 1\n  end\n  local function\
    \ remove_group(group, depth)\n    depth = depth - 1\n    if depth == 0 then\n\
    \      table.remove(stack, 1)\n    end\n  end\n  local function is_empty()\n \
    \   local result = false\n    for _, group in ipairs(stack) do\n      result =\
    \ result or #group == 0\n    end\n    return result\n  end\n  local function get_group(group)\n\
    \    local result = {group}\n    for _, group in ipairs(stack) do\n      if #group\
    \ > 0 then\n        table.insert(result, group[#group])\n      end\n    end\n\
    \    return result\n  end\n  local function get_paren_count(group)\n    local\
    \ count = 0\n    for _, group in ipairs(stack) do\n      if #group > 0 then\n\
    \        count = count + 1\n      end\n    end\n    return count\n  end\n  local\
    \ function check_paren(groups)\n    for _, group in ipairs(groups) do\n      for\
    \ i = 1, #group do\n        local open = group[i]\n        if open == '(' or open\
    \ == '[' or open == '{' then\n          add_group(group, depth)\n        elseif\
    \ open == ')' or open == ']' or open == '}' then\n          if get_paren_count(group)\
    \ == 1 then\n            remove_group(group, depth)\n          else\n        \
    \    break\n          end\n        elseif open == ',' then\n          break\n\
    \        end\n      end\n    end\n  end\n  local function check_empty(groups)\n\
    \    local open = 0\n    for _, group in ipairs(groups) do\n      if open == 0\
    \ then\n        open = group[1]\n      elseif open == group[1] then\n        open\
    \ = 0\n      end\n    end\n  end\n  local open = 1\n  local close = 0\n  for i\
    \ = 1, #paren_string do\n    if paren_string[i] == '(' or paren_string[i] == '['\
    \ or paren_string[i] == '{' then\n      open = open + 1\n    elseif paren_string[i]\
    \ == ')' or paren_string[i] == ']' or paren_string[i] == '}' then\n      close\
    \ = close + 1\n      if open > close then\n        check_paren(groups)\n     \
    \   check_empty(groups)\n      end\n      open = close + 1\n    end\n  end\n \
    \ if is_empty() then\n    add_group(groups)\n  end\n  return table.concat(groups)\n\
    end", "  local max_level = 0\n  for paren_group in string.gmatch(paren_string,\
    \ '%a+') do\n    if paren_group == '()' or paren_group == '()(' then\n      max_level\
    \ = math.max(max_level, parse_nested_parens(paren_string))\n    else\n      max_level\
    \ = math.max(max_level, paren_group:gsub('%()+', '0'))\n    end\n  end\n  return\
    \ max_level\nend", "  local parens = {}\n  local num_parens = 0", "  local stack\
    \ = []\n  local index = 1", "  local function has_left_paren(char)\n    return\
    \ char == '('\n  end", "    local index = 1\n    local max_level = 0\n    local\
    \ parens = {}\n    while true do\n        local opening_paren_index = index\n\
    \        index = string.find(paren_string, '(', index)\n        if opening_paren_index\
    \ == nil then\n            break\n        end\n        index = opening_paren_index\
    \ + 1", "  local parsed_parens = {}\n  local parsed_parens_max_nesting = 0\n \
    \ local bracket_count = 0\n  for bracket_count = 1, #paren_string, 2 do\n    local\
    \ opening_bracket_count, closing_bracket_count = unpack(\n      paren_string:sub(bracket_count,\
    \ #paren_string))\n    local opening_bracket = opening_bracket_count > 0\n   \
    \   and paren_string:sub(bracket_count - 1, opening_bracket_count - 1)\n     \
    \ or nil\n    local closing_bracket = closing_bracket_count > 0\n      and paren_string:sub(bracket_count,\
    \ closing_bracket_count - 1)\n      or nil\n    local bracket_count = opening_bracket\
    \ or closing_bracket\n    if not parsed_parens[opening_bracket] then\n      parsed_parens[opening_bracket]\
    \ = {}\n    end\n    parsed_parens_max_nesting = math.max(\n      parsed_parens_max_nesting,\
    \ #parsed_parens[opening_bracket])\n    if not parsed_parens[opening_bracket][closing_bracket]\
    \ then\n      parsed_parens[opening_bracket][closing_bracket] = bracket_count\n\
    \    end\n  end\n  return parsed_parens_max_nesting\nend", "  local stack = {}\n\
    \  local paren_level = 0\n  local in_group = 0\n  local groups = {}\n  local depth\
    \ = 0", "   local paren_levels = {}\n   for paren_symbol in string.gmatch(paren_string,\
    \ \"(%S+)\") do\n      paren_levels[paren_symbol] = paren_levels[paren_symbol]\
    \ + 1 end\n   local max_level = 0\n   local max_level_index = nil\n   local max_level_symbol\
    \ = \"\"\n   for symbol,level in pairs(paren_levels) do\n      max_level = math.max(level,\
    \ max_level)\n      if max_level > max_level_index then\n         max_level_index\
    \ = max_level\n         max_level_symbol = symbol end\n      end\n   end\n   return\
    \ max_level_index\nend", "    -- Split the string and get a list of strings of\
    \ all the groups in parentheses\n    local groups = split(paren_string, '()')\n\
    \    -- Initialize the deepest nesting level to 0\n    local max_level = 0\n \
    \   -- For each group of parentheses, parse it recursively\n    for _, group in\
    \ ipairs(groups) do\n        local group_level = get_max_level(groups)\n     \
    \   if group_level > max_level then\n            max_level = group_level\n   \
    \     end\n    end\n    return max_level\nend", "  local brackets = {}\n  local\
    \ last_pos = 1\n  local paren_level = 1", "    local nested_levels = { 0, 0 }\n\
    \    local num_parens = 0\n    for s in string.gmatch(paren_string, '()()') do\n\
    \        -- Count all open parenthesis pairs.\n        local level = 1\n     \
    \   local opening = 1\n        for c in s:gmatch('%[(%a+)()') do\n           \
    \ level = level + 1\n            if c == '(' and opening > 0 then\n          \
    \      opening = opening - 1\n            elseif c == ')' and opening > 0 then\n\
    \                opening = opening - 1\n                level = level - 1\n  \
    \          elseif c ~= ')' then\n                opening = opening + 1\n     \
    \       end\n        end\n        nested_levels[level] = max(nested_levels[level],\
    \ num_parens)\n        num_parens = opening\n    end\n    return nested_levels[num_parens]\n\
    end", "    local depth = 0\n    local open_brackets = true\n    local depths =\
    \ {}\n    local result = 0\n    for paren in string.gmatch(paren_string, \"([()]*%?%+()\"\
    )\n    do\n        if open_brackets then\n            depth = depth + 1\n    \
    \        depths[depth] = depth\n            open_brackets = false\n        else\n\
    \            depth = depth - 1\n            open_brackets = true\n        end",
  "    local parens = nil\n    local max_level = -1\n    for token in string.gmatch(paren_string,\
    \ \"%b()()\") do\n        if max_level < 1 then\n            parens = token\n\
    \            max_level = tonumber(token)\n        elseif parens ~= nil and max_level\
    \ <= tonumber(token) then\n            parens = nil\n            max_level = tonumber(token)\n\
    \        end\n    end\n    if parens == nil then\n        return 0\n    end\n\
    \    local nested_parens = tonumber(parens)\n    if max_level == -1 or nested_parens\
    \ > max_level then\n        return -1\n    end\n    return max_level\nend", " \
    \ local groups_of_paren = paren_string:gsub(\"%[(%a*)%]\", function(paren_string)\n\
    \    return paren_string:gsub(\"(%a*)\", function(paren_string)\n      return\
    \ paren_string:gsub(\"%a+)\", \"\"):gsub(\"%a\", \"\")\n    end)\n  end)\n  local\
    \ max_level\n  local levels\n  if #groups_of_paren > 0 then\n    max_level = groups_of_paren[1]:gsub(\"\
    %a+)\", \"\")\n    levels = max_level:gsub(\"%a\", \"\")\n  else\n    max_level\
    \ = 1\n    levels = \"\"\n  end\n  return max_level:gsub(\"%a\", \"\"), levels\n\
    end", "    local nested = {}\n    for i, c in pairs(paren_string) do\n       \
    \ if c == '(' and (i + 1 == #paren_string) then\n            nested[#nested +\
    \ 1] = 1\n        elseif c == ')' then\n            nested[#nested + 1] = 0\n\
    \        end\n    end\n    return nested\nend", "    local bracket_count = 0\n\
    \    local max_level = 0\n    local paren_levels = {{}}\n    local result = {}\n\
    \    for paren in string.gmatch(paren_string, '()()') do\n        if paren ~=\
    \ '()' then\n            table.insert(paren_levels, 1)\n        end\n        table.insert(paren_levels,\
    \ 1)\n    end\n    table.sort(paren_levels, function(a, b) return a < b end)\n\
    \    for paren in string.gmatch(paren_string, '()()') do\n        local level\
    \ = table.maxn(paren_levels)\n        if level > max_level then\n            max_level\
    \ = level\n        end\n        local paren_count = paren_levels[level]\n    \
    \    if paren_count == 0 then\n            if level == 0 then\n              \
    \  result[#result+1] = max_level - 1\n            else\n                result[#result+1]\
    \ = level\n            end\n        else\n            local paren_start = paren_count\n\
    \            if level == 0 then\n                paren_start = #paren_string\n\
    \            else\n                local paren_index = #paren_string\n       \
    \         while paren_index > 1 do\n                    paren_index = paren_index\
    \ - 1\n                    paren_count = paren_levels[paren_index]\n         \
    \           if paren_count > 0 then\n                        break\n         \
    \           end\n                end\n                paren_start = paren_index\
    \ + 1\n            end\n            local paren_end = #paren_string\n        \
    \    local paren_index = paren_end\n            while paren_index > 1 do\n   \
    \             paren_index = paren_index - 1\n                paren_count = paren_levels[paren_index]\n\
    \                if paren_count > 0 then\n                    paren_end = paren_index\n\
    \                    break\n                end\n            end\n           \
    \ if paren_index == 1 then\n                paren_end = #paren_string\n      \
    \      else\n                paren_end = paren_end - 1\n            end\n    \
    \        if paren_end > paren_start + 1 then\n                result[#result+1]\
    \ = max_level - paren_start + 1 -- Level minus paren count\n            end\n\
    \        end\n    end\n    return result\nend", "  local groups = {}\n  for paren\
    \ in string.gmatch(paren_string, \"%[(%a+)%]\")\n  do\n    table.insert(groups,\
    \ #groups)\n    groups[#groups] = nil\n  end, paren\n  local result = {}\n  for\
    \ i = 1, #groups do\n    local group = groups[i]\n    local count = 0\n    for\
    \ j = 1, #group do\n      if group[j] == ')' then\n        count = count - 1\n\
    \      elseif group[j] == ')' then\n        count = count + 1\n      end\n   \
    \ end\n    table.insert(result, count)\n  end\n  table.sort(result)\n  return\
    \ result\nend", "    local nested_stack = [1]\n    local max_level = 1\n    for\
    \ _, group_string in ipairs(paren_string:gmatch('(%S+)%s*(%S+)%s*')), 1 do\n \
    \       local groups = group_string:gsub('%[%s()]+', '')\n        for _, level\
    \ in ipairs(groups:gmatch('%d*%d*'))\n            do\n                table.insert(nested_stack,\
    \ level)\n                if level > max_level then\n                    max_level\
    \ = level\n                end\n            end\n        end\n    end\n    return\
    \ max_level, nested_stack\nend", "  local levels = { }\n  local paren_stack =\
    \ { }", "  local level_of_parens = 0\n  local levels_of_parens = {}\n  for levels_of_parens\
    \ = 0, #paren_string-1 do\n    if paren_string[levels_of_parens+1] ~= '('\n  \
    \  then\n      break\n    end\n    level_of_parens = levels_of_parens + 1\n  \
    \  table.insert(levels_of_parens, level_of_parens)\n  end\n  return levels_of_parens\n\
    end", "  local nest_level = 1 -- The current level of nesting.\n  local paren_stack\
    \ = {} -- A list of current level of parentheses nesting.\n  local parsed_string\
    \ = {} -- The parsed groups as a list of numbers.\n  for paren in string.gmatch(paren_string,\
    \ '()()') do\n    paren_stack[nest_level] = paren\n    parsed_string[nest_level]\
    \ = {}\n    nest_level = nest_level + 1\n  end\n  -- Pop the last level of parentheses\
    \ nesting.\n  local popped_nest_level = nest_level - 1\n  assert(popped_nest_level\
    \ >= 0)\n  -- Return the maximum number of levels of nesting.\n  return parsed_string[popped_nest_level][1]\n\
    end", "  local paren_stack = {0} -- A stack of nesting levels for parentheses.\n\
    \  local paren_levels = {0} -- A stack of nesting levels for each set of parentheses\
    \ separated by spaces.\n  local cur_paren = 0\n  local level = 0", "  local max_depth\
    \ = 0\n  local max_level = 0\n  local depth = 0\n  local level = 0\n  for paren\
    \ in string.gmatch(paren_string, \"(%S+)\") do\n    if paren == \"(\" then\n \
    \     depth = depth + 1\n    elseif paren == \")\" then\n      depth = depth -\
    \ 1\n    end\n    if depth > max_depth then\n      max_depth = depth\n      max_level\
    \ = level\n    end\n    level = level + 1\n  end\n  if max_depth > 0 then\n  \
    \  return max_level, max_depth\n  end\nend", "  local levels = { 0 }\n  local\
    \ max = 0\n  local nesting_depth = 0\n  local paren_pairs = {}\n  local paren_count\
    \ = 0\n  for token in string.gmatch(paren_string, '()()') do\n    local paren_count_after_token\
    \ = paren_count + 1\n    if paren_count_after_token > max then\n      max = paren_count_after_token\n\
    \    end\n    levels[#levels + 1] = paren_count_after_token\n  end\n  -- Iterate\
    \ over all paren_count and store the level at which it is nested for each parentheses.\n\
    \  for i = 1, #levels do\n    paren_pairs[levels[i]:sub(1, 1)] = levels[i]\n \
    \ end\n  local function paren_count(paren_count)\n    return paren_pairs[paren_count]\n\
    \  end\n  return nesting_depth\nend", "  local index = 0\n  local level = 0\n\
    \  local max_level = 0\n  local nested_parens = {}", "  local nesting_level =\
    \ 0\n  local paren_stack = {}\n  local level = 0\n  local open_brackets = 0\n\
    \  local open_brackets_count = 0\n  local closed_brackets = false\n  for paren,\
    \ paren_level in pairs(paren_string:gmatch'[^()]*+()') do\n    -- If we found\
    \ a closing parenthesis, decrement the number of open brackets.\n    if paren\
    \ == '(' then open_brackets = open_brackets - 1 end", "    local current_level\
    \ = 1\n    local levels_of_nesting = { }\n    local last_group = 0\n    local\
    \ group = 0\n    local open_brackets = 0\n    local close_brackets = 0", "   --\
    \ The algorithm is as follows:\n   -- 1) Get the index of the first parenthesis\n\
    \   -- 2) For each group of parenthesis, add one level of nesting to the index\n\
    \   -- 3) If the index reaches the end of the string, return -1\n   -- 4) Return\
    \ the last index + 1\n   return string.find(paren_string, '[%([[(]') -- finds\
    \ the index to the first parenthesis\n      and string.sub(paren_string, 1, string.find(paren_string,\
    \ '[%([[(]') + 1)\n      and string.find(paren_string, '[%([[(]'))\n      and\
    \ string.find(paren_string, '[%([[(]') >= 0\n      and string.find(paren_string,\
    \ '[%([[(]') >= 0\n      and string.find(paren_string, '[%([[(]') >= 0\n     \
    \ and string.find(paren_string, '[%([[(]') >= 0\n      and string.find(paren_string,\
    \ '[%([[(]') >= 0\n      and string.find(paren_string, '[%([[(]') >= 0\n     \
    \ and string.find(paren_string, '[%([[(]') >= 0\n      and string.find(paren_string,\
    \ '[%([[(]') >= 0\n      and string.find(paren_string, '[%([[(]') >= 0\n     \
    \ and string.find(paren_string, '[%([[(]') >= 0\n      and string.find(paren_string,\
    \ '[%([[(]') >= 0\n      and string.find(paren_string, '[%([[(]') >= 0\n     \
    \ and string.find(paren_string, '[%([[(]') >= 0\n      and string.find(paren_string,\
    \ '[%([[(]') >= 0\n      and string.find(paren_string, '[%([[(]') >= 0\n     \
    \ and string.find(paren_string, '[%([[(]') >= 0\n      and string.find(paren_string,\
    \ '[%([[(]') >= 0\n      and string.find(paren_string, '[%([[(]') >= 0\n     \
    \ and string.find(paren_string, '[%([[(]') >= 0\n      and string.find(paren_string,\
    \ '[%([[(]') >= 0\n      and string.find(paren_string, '[%([[(]') >= 0\n     \
    \ and string.find(paren_string, '[%([[(]') >= 0\n      and string.find(paren_string,\
    \ '[%([[(]') >= 0\n      and string.find(paren_string, '[%([[(]') >= 0\n     \
    \ and string.find(paren_string, '[%([[(]') >= 0\n      ", "  local stack = { 1\
    \ }\n  local result\n  local stack_count = stack[1]", "    local paren_dict =\
    \ {}\n    local paren_stack = {}\n    local opening_parens = 0\n    for idx, c\
    \ in ipairs(paren_string) do\n        local is_opening_paren = opening_parens\
    \ > 0\n        local is_closing_bracket = c ~= '('", "    local nested_levels\
    \ = { 1 }\n    for _ in string.gmatch(paren_string, '%S+') do\n        local level_of_nesting\
    \ = nested_levels[#nested_levels]\n        if level_of_nesting == nil then\n \
    \           level_of_nesting = #nested_levels\n        end\n        table.insert(nested_levels,\
    \ level_of_nesting + 1)\n    end\n    return nested_levels\nend", "  local nested_parens\
    \ = {}\n  local level = 1\n  local paren_level = false\n  local start_pos = 1\n\
    \  local depth = 0\n  local current_pos = 1\n  local paren_count = 0\n  local\
    \ prev_pos = 1\n  local char = ''", "  local nested_count = {}\n  local max_count\
    \ = 0\n  local max_level = 0", "  local num_open = 0\n  local level = 0\n  local\
    \ last_open = -1\n  local last_close = -1\n  local result = {}\n  for i, c in\
    \ ipairs(paren_string) do\n    if c == '(' or c == '{' or c == '[' then\n    \
    \  level = level + 1\n      if level > last_open then\n        result[#result+1]\
    \ = level\n      end\n      if c == ')' then\n        level = level - 1\n    \
    \  elseif c == '}' then\n        result[#result+1] = level\n      elseif c ==\
    \ ']' then\n        result[#result+1] = level\n      end\n      if level > last_open\
    \ and level < last_close then\n        result[#result+1] = level\n      end\n\
    \      if c == '(' or c == '{' or c == '[' then\n        last_open = level\n \
    \     elseif c == '}' then\n        last_close = level\n      end\n    end\n \
    \ end\n  return result\nend", "   -- We use this for parsing the input string\
    \ since it is not efficient.\n   --\n   -- Example: \"((())) () ((())()())\" =>\n\
    \   --\n   -- ['((()))', ' () ((())()())']\n   --\n   -- We first split the string\
    \ by spaces and then we use a table to track the current number of open\n   --\
    \ parentheses (number of parentheses opened in total so far).\n   --\n   -- If\
    \ we are at the last level of nesting, we use the leftovers to reconstruct the\
    \ string\n   -- with correct number of parentheses.\n   --\n   -- If we have an\
    \ opening parenthesis, we increase the corresponding count by 1. If we are\n \
    \  -- at a closing parenthesis, we decrease the corresponding count by 1.\n  \
    \ --\n   -- Finally, we return the reconstructed string.", "    local level =\
    \ 0\n    local max_level = 0\n    local output = {}\n    for token in stringx.split(paren_string,\
    \ \" \") do\n        if level == 0 then\n            if token == '(' then\n  \
    \              level = level + 1\n            elseif token == ')' then\n     \
    \           level = level - 1\n            elseif token == \")\" then\n      \
    \          if level > max_level then\n                    max_level = level\n\
    \                end\n            end\n        elseif level == 1 then\n      \
    \      if token == '(' then\n                level = level + 1\n            elseif\
    \ token == ')' then\n                level = level - 1\n            elseif token\
    \ == \")\" then\n                level = level + 1\n            end\n        elseif\
    \ level == 2 then\n            if token == '(' then\n                level = level\
    \ + 1\n            elseif token == ')' then\n                level = level - 1\n\
    \            end\n        end\n        if level == 1 then\n            if max_level\
    \ > 1 then\n                output[#output + 1] = max_level\n            end\n\
    \        elseif level > 1 then\n            output[#output + 1] = level\n    \
    \    end\n    end\n    return output\nend", "  local maxlevel = 0\n  local paren_nesting\
    \ = 0\n  local paren_nesting_level = {}", "   -- First, create a map to track\
    \ the nesting depth for each level.\n   -- We will start from level 0 (highest\
    \ nesting nesting depth) to 1 (lowest nesting depth).\n   -- The key for each\
    \ value in the map is the number of left parentheses in the substring so far.\n\
    \   -- The value for each key is the index of the opening parentheses in the string.\n\
    \   -- This map will be used to determine how many left parentheses need to be\
    \ added for each level.\n   local paren_count = { [1] = 0 } -- { depth }\n   local\
    \ nested_depth = 0 -- number of opening parentheses in each level so far", " \
    \ local parse_tree = { root = 1 }\n  local opening_stack = {}\n  local depth =\
    \ 0\n  local parens = 0\n  local max_parens = 0\n  local parens_stack = {}\n \
    \ local function is_open_parentheses(character)\n    return character == '(' or\
    \ character == '[' or character == '{'\n  end\n  local function count_parentheses(character)\n\
    \    parens = parens + 1\n    if character == ')' then\n      opening_stack[parens]\
    \ = nil\n      parens = parens - 1\n      if parens == 0 then\n        max_parens\
    \ = max_parens + 1\n      end\n    end\n  end\n  for idx, character in ipairs(paren_string)\
    \ do\n    if character == '(' or character == '[' or character == '{' then\n \
    \     opening_stack[depth] = character\n      depth = depth + 1\n    end\n   \
    \ if is_open_parentheses(character) then\n      count_parentheses(character)\n\
    \    end\n  end\n  local current_depth = 0\n  local parsed_parens = 0\n  for idx,\
    \ character in ipairs(paren_string) do\n    if is_open_parentheses(character)\
    \ then\n      parsed_parens = parsed_parens + 1\n      if parsed_parens > max_parens\
    \ then\n        parsed_parens = max_parens\n      end\n    end\n    if opening_stack[depth]\
    \ == character then\n      opening_stack[depth] = nil\n      current_depth = current_depth\
    \ + 1\n    end\n    if opening_stack[current_depth] == character then\n      opening_stack[current_depth]\
    \ = nil\n      parsed_parens = parsed_parens - 1\n      if parsed_parens == 0\
    \ then\n        depth = depth - 1\n      end\n    end\n  end\n  return depth\n\
    end", "  local level = 0\n  local depth = 0\n  local cur_paren = 0\n  local stack\
    \ = {}", "   local nesting = 0\n   local parens = {} -- Key: nesting level, val:\
    \ parens\n   local current_paren = 0\n   for paren, paren_string in pairs(paren_string:gsub(\"\
    %[(%a)]+\", function(c) \n      if c == \"(\" then nesting = nesting + 1 else\
    \ nesting = nesting - 1 end\n      if nesting > 0 and c == \"(\" then current_paren\
    \ = current_paren + 1 else current_paren = current_paren - 1 end\n      if nesting\
    \ > 0 and c == \")\" then \n         if current_paren == 1 then\n            parens[nesting]\
    \ = parens\n         else\n            parens[nesting] = parens[nesting][nesting]\n\
    \         end\n         nesting = nesting - 1\n         current_paren = 0\n  \
    \    else\n         if nesting == 0 then\n            parens[current_paren] =\
    \ paren\n         end\n      end\n   end)) do\n   end\n   return parens\nend",
  "\tlocal paren_string = paren_string:gsub(\"[^()]+\", \" \"):gsub(\"^[\\(]*\", \"\
    \"):gsub(\"[\\)]*$\", \"\")\n\tlocal max_level = 0\n\tlocal level = 0\n\tfor group\
    \ in paren_string:gmatch(\"%w+\") do\n\t\tif level > max_level then\n\t\t\tmax_level\
    \ = level\n\t\tend\n\t\tlevel = level + 1\n\tend\n\treturn max_level\nend", " \
    \  assert(type(paren_string) == 'string')\n   local levels = {}\n   local stack_count\
    \ = { }", "  local level = 1 -- Start at level 1 since parenthesis () have no\
    \ nesting.\n  local paren_count = 0 -- Increment for each open parenthesis\n \
    \ local stack = { }\n  for char in string.gmatch(paren_string, '%S+') do\n   \
    \ if char == '(' or char == ')' then\n      table.insert(stack, char)\n      paren_count\
    \ = paren_count + 1\n    elseif char == ')' and paren_count > level then\n   \
    \   level = level - 1\n    end\n  end\n  return level\nend", "  local level =\
    \ 0\n  local paren_string = paren_string:gsub('(%[(%[((%[%()%.-]))+)()]+)',\n\
    \    function(m)\n      level = level + 1 -- Increment the level count.\n    \
    \  if m[1] == \")\" then\n        level = level - 1 -- Decrement the level count.\n\
    \        return \"\" -- Append an empty string to close the paren pair.\n    \
    \  elseif m[2] == \")\" then\n        level = level - 1 -- Decrement the level\
    \ count.\n        return \"(\" -- Return the opening paren.\n      else\n    \
    \    return \"(\" -- Return a non-nested pair.\n      end\n    end)\n  local results\
    \ = {}\n  for i = 1, #paren_string, 2 do\n    results[i] = level\n  end\n  return\
    \ results\nend", "  local num_levels = 0\n  local num_open = 0\n  local depth\
    \ = 0\n  local paren_string = paren_string:gsub('[()( )]', function(c)\n    if\
    \ num_open > depth then\n      num_open = num_open:max(num_open)\n      num_levels\
    \ = num_levels + 1\n    end\n    num_open = num_open + 1\n    depth = depth +\
    \ 1\n    if depth > num_levels then\n      num_levels = depth\n    end\n    return\
    \ ''\n  end)\n  return paren_string:gsub('()', ''):gsub('(([()]))', function(c)\n\
    \    num_open = num_open - 1\n    return ''\n  end)\nend", "    local open = 0\n\
    \    local closed_parens = 0\n    local parens_level = 0\n    local nested_parens\
    \ = false\n    local results = {}\n    local stack = {}\n    local group = 1\n\
    \    local group_stack = {paren_string}\n    local in_group = 0\n    local last_paren_start\
    \ = nil\n    local last_paren_end = nil\n    local paren_count = 0\n    local\
    \ is_first_in_group = 0\n    local is_last_in_group = 0\n    local paren_count_check\
    \ = 0\n    local is_paren_count_zero = true\n    local paren_count_check_index\
    \ = 0\n    local is_in_parens = false\n    local has_open_parens = false\n   \
    \ local has_open_parens_at_beginning_of_string = true\n    local has_open_parens_at_end_of_string\
    \ = true\n    local last_open_paren_beginning_of_string = 1\n    local last_open_paren_end_of_string\
    \ = 1\n    local last_opening_paren_end = nil", "   local groups = paren_string:gmatch(\"\
    ([()]+)\")\n   assert(#groups == 1, \"Input must be valid parenthesis string\"\
    )\n   local result = {0}\n   local level = 1\n   for _, nested_parens in pairs(groups)\
    \ do\n      local parens = nested_parens:sub(1, 1)\n      if parens == \"(\" then\n\
    \         table.insert(result, level + 1)\n         level = level + 1\n      elseif\
    \ parens == \")\" then\n         level = level - 1\n         assert(level >= 0,\
    \ \"Input must be valid parenthesis string\")\n      else\n         assert(false,\
    \ \"Input must be valid parenthesis string\")\n      end\n   end\n   table.insert(result,\
    \ level + 1)\n   return result\nend", "   local max_level = 0\n   local results\
    \ = {}\n   for _, group_str in string.gmatch(paren_string, \"[^()]+\") do\n  \
    \    local group = parse_paren(group_str)\n      if max_level < group[1] then\n\
    \         max_level = group[1]\n      end\n      table.insert(results, group[1])\n\
    \   end\n   return results\nend", "   -- Empty strings result in a zero value.\n\
    \   if paren_string == '' then\n      return 0\n   end", "  local level = 0\n\
    \  local result = {}\n  for paren in string.gmatch(paren_string, \"([^()]+)\"\
    )  do\n    if paren == \"()\" then\n      level = level + 1\n    elseif level\
    \ > 0 then\n      level = level - 1\n    end\n    table.insert(result, level)\n\
    \  end\n  return result\nend", "    local max_level = 0\n    local level = 0\n\
    \    local nested_paren_string = \"\""]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
