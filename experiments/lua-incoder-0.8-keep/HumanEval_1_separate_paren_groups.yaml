name: HumanEval_1_separate_paren_groups
language: lua
prompt: "-- Input to this function is a string containing multiple groups of nested\
  \ parentheses. Your goal is to\n-- separate those group into separate strings and\
  \ return the list of those.\n-- Separate groups are balanced (each open brace is\
  \ properly closed) and not nested within each other\n-- Ignore any spaces in the\
  \ input string.\n-- >>> separate_paren_groups('( ) (( )) (( )( ))')\n-- ['()', '(())',\
  \ '(()())']\nlocal function separate_paren_groups(paren_string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = separate_paren_groups\n\
  \    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))',\
  \ '()', '((())()())'})\n    lu.assertEquals(candidate('() (()) ((())) (((())))'),\
  \ {'()', '(())', '((()))', '(((())))'})\n    lu.assertEquals(candidate('(()(())((())))'),\
  \ {'(()(())((())))'})\n    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()',\
  \ '(())', '(()())'})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local function is_open_paren(character)\n    return character:sub(1,\
    \ 1) == '('\n  end\n  local open_paren_position = 1\n  local function is_close_paren(character)\n\
    \    return character == ')' and open_paren_position > 1\n  end\n  local function\
    \ is_close_paren_at_position(position)\n    return open_paren_position > 0 and\
    \ position == open_paren_position - 1\n  end\n  local function is_close_paren_at_last_position()\n\
    \    return open_paren_position > 0 and open_paren_position > 1\n  end\n  local\
    \ function close_paren(open_paren_position)\n    open_paren_position = open_paren_position\
    \ - 1\n  end\n  local open_parens = ''\n  local open_paren_groups = {\n    open\
    \ = {\n      position = {\n        current = 1,\n        previous = 0,\n     \
    \ },\n      characters = {\n        ['('] = true,\n      },\n    },\n    close\
    \ = {\n      position = {\n        current = 1,\n        previous = 0,\n     \
    \ },\n      characters = {\n        [')'] = true,\n      },\n    },\n  }\n  local\
    \ current_paren_group\n  local open_paren_character\n  local open_paren_character_index\n\
    \  local function open_paren_position_changed(position)\n    current_paren_group:close_position({\n\
    \      current = 1,\n      previous = 0,\n    })\n    local last_position\n  \
    \  local function update_last_position()\n      last_position = position\n   \
    \ end\n    current_paren_group:add_position(position, update_last_position)\n\
    \  end\n  local function open_paren_character_changed(character)\n    open_paren_position\
    \ = open_paren_position + 1\n    open_paren_character_index = open_paren_character_index\
    \ + 1\n    if open_paren_character_index == #open_paren_characters.characters.[open_paren_character]\
    \ then\n      open_paren_character_index = nil\n    end\n    open_paren_character:characters[character]\
    \ = true\n  end\n  local function close_paren_character_changed(character)\n \
    \   open_paren_character:characters[character] = false\n  end\n  local function\
    \ is_close_paren_at_last_position()\n    return open_paren_position > 0 and open_paren_position\
    \ > 1\n  end\n  local function close_paren_at_position()\n    close_paren(open_paren_position)\n\
    \  end\n  local function close_paren_at_last_position()\n    close_paren(open_paren_position\
    \ - 1)\n  end\n  local function next_position()\n    local position = open_paren_group.position.current\n\
    \    if open_paren_character_index then\n      return position + 1, open_paren_",
  "  local function group_func(str)\n    local open = paren_string:find(str, \"()\"\
    )\n    while open do\n      str = str:gsub(\"%s+\", function (s) return s:gsub(\"\
    %[)]\", \"\") end)\n      open = paren_string:find(str, \"()\")\n    end\n   \
    \ return str:gsub(\"%[(%)]\", \"\")\n  end\n  return str:gsub(\"(%[(%)])\", group_func)\n\
    end", "  local open_braces_count = 0\n  local open_braces_count_str = ''\n  local\
    \ string_to_return = ''\n  local string_with_separator = ''\n  local string_with_separator_length\
    \ = 0\n  for index, item in pairs(paren_string) do\n    string_with_separator_length\
    \ = string_with_separator_length + #item + 1\n    if string_with_separator_length\
    \ > 0 then\n      string_with_separator = string_with_separator .. ' '\n    end\n\
    \    if item == '(' then\n      open_braces_count = open_braces_count + 1\n  \
    \    open_braces_count_str = open_braces_count_str .. '('\n    else\n      if\
    \ open_braces_count > 0 then\n        open_braces_count = open_braces_count -\
    \ 1\n        open_braces_count_str = open_braces_count_str .. ')'\n      end\n\
    \    end\n    string_to_return = string_to_return .. item\n  end\n  if open_braces_count\
    \ > 0 then\n    string_to_return = string_to_return .. ')'\n  end\n  return string_to_return\n\
    end", "  local groups = {paren_string}\n  local open_brace_count = 1\n  local\
    \ open_brace_string\n  local close_brace_string", '    local paren_groups = {}',
  "  local result = {}\n  local open_braces_count = 0\n  local closed_braces_count\
    \ = 0\n  for char in string.gmatch(paren_string, \"%S+\") do\n    if char == \"\
    (\" then\n      if open_braces_count > 0 then\n        result[#result + 1] = \"\
    (\" .. string.sub(paren_string, 1, open_braces_count - 1) .. \")\"\n      end\n\
    \      open_braces_count = open_braces_count + 1\n    elseif char == \")\" then\n\
    \      if closed_braces_count > 0 then\n        result[#result + 1] = string.sub(paren_string,\
    \ 1, closed_braces_count - 1)\n      end\n      closed_braces_count = closed_braces_count\
    \ + 1\n    elseif char == \" \" then\n      if open_braces_count > 0 then\n  \
    \      result[#result + 1] = string.sub(paren_string, 1, open_braces_count - 1)\n\
    \      end\n      open_braces_count = open_braces_count + 1\n      if closed_braces_count\
    \ > 0 then\n        result[#result + 1] = string.sub(paren_string, 1, closed_braces_count\
    \ - 1)\n      end\n      closed_braces_count = closed_braces_count + 1\n    else\n\
    \      result[#result + 1] = char\n    end\n  end\n  if open_braces_count > 0\
    \ then\n    result[#result + 1] = \"(\" .. string.sub(paren_string, 1, open_braces_count\
    \ - 1) .. \")\"\n  end\n  if closed_braces_count > 0 then\n    result[#result\
    \ + 1] = string.sub(paren_string, 1, closed_braces_count - 1)\n  end\n  return\
    \ result\nend", "    local results = {}\n    local open_braces_count = 0\n   \
    \ local paren_count = 0\n    local cur_string = ''\n    for char in paren_string:gmatch('%S+')\
    \ do\n        if char == '(' then\n            open_braces_count = open_braces_count\
    \ + 1\n        elseif char == ')' then\n            open_braces_count = open_braces_count\
    \ - 1\n        elseif open_braces_count ~= 0 then\n            cur_string = cur_string\
    \ .. char\n        elseif char == ' ' then\n            if paren_count == 0 then\n\
    \                table.insert(results, cur_string)\n                cur_string\
    \ = ''\n            else\n                paren_count = paren_count - 1\n    \
    \        end\n        else\n            paren_count = paren_count + 1\n      \
    \  end\n    end\n    table.insert(results, cur_string)\n    return results\nend",
  "    if paren_string == nil then return nil end\n    local paren_groups, open_brace_nums\
    \ = { }, 1\n    local paren_string_arr = string.gmatch(paren_string, \"%[()]+\"\
    )\n    if paren_string_arr == nil then return paren_groups end", "  -- Get rid\
    \ of any spaces before we begin\n  paren_string = paren_string:gsub('(%S+)%s*%(%S+)(%S+)%s*%(%S+)$',\
    \ '\\1\\2\\3')\n  -- Get rid of any spaces before we begin\n  paren_string = paren_string:gsub('(%S+)%s*%(%S+)(%S+)%s*%(%S+)%s*%(%S+)$',\
    \ '\\1\\2\\3\\4')\n  -- Get rid of any spaces before we begin\n  paren_string\
    \ = paren_string:gsub('(%S+)%s*%(%S+)(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)$', '\\1\\\
    2\\3\\4\\5')\n  -- Get rid of any spaces before we begin\n  paren_string = paren_string:gsub('(%S+)%s*%(%S+)(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)$',\
    \ '\\1\\2\\3\\4\\5\\6')\n  -- Get rid of any spaces before we begin\n  paren_string\
    \ = paren_string:gsub('(%S+)%s*%(%S+)(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)$',\
    \ '\\1\\2\\3\\4\\5\\6\\7')\n  -- Get rid of any spaces before we begin\n  paren_string\
    \ = paren_string:gsub('(%S+)%s*%(%S+)(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)$',\
    \ '\\1\\2\\3\\4\\5\\6\\7\\8')\n  -- Get rid of any spaces before we begin\n  paren_string\
    \ = paren_string:gsub('(%S+)%s*%(%S+)(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)%s*%(%S+)$',\
    \ '\\1\\2\\3\\4\\5\\6\\7\\8\\9')\n  -- Get rid of any spaces before we begin\n\
    \  paren_string = ", "  local paren_groups = {}\n  local open_braces = 0\n  local\
    \ escape = false\n  for char in string.gmatch(paren_string, \"%[(%w)]\") do\n\
    \    -- If the next character is a closing brace, close the current group\n  \
    \  if char == \"(\" and not escape then\n      open_braces = open_braces - 1\n\
    \    elseif char == \")\" and not escape then\n      open_braces = open_braces\
    \ + 1\n    else\n      -- Otherwise, append the character to the current group\n\
    \      paren_groups[#paren_groups + 1] = char\n    end\n    -- Make sure this\
    \ character isn't escaped\n    escape = not escape\n  end\n  return paren_groups\n\
    end\n</code>\n<|/ a tags=lua |>\n<| c |>\nThank you, this is what I ended up doing.\
    \ While this works, it isn't ideal. I would like to avoid doing string manipulation\
    \ if possible.\n<|/ c |>\n<| a |>\nThe function you are looking for is string.gmatch().\
    \  You will need to write a pattern that matches all your strings. \n<code>\n\
    \  local str = ' ()()()'\n  local arr = {}\n  -- This matches all non-space characters\
    \ and groups the characters using ( and ) \n  -- It also matches a space and groups\
    \ the characters using ( )\n  -- The parens match the characters before and after\
    \ the groups.\n  -- We need to use a loop to match the entire string\n  while\
    \ true do\n    local m, e = str:gsub('(%S+)(%S+)(%S+)', '(\\1)\\2\\3')\n    arr[#arr\
    \ + 1] =  m\n    if e == '' then\n      break -- This means there are no more\
    \ groups\n    end\n  end\n</code>\narr will contain the groups\n<code>\n[\"()\"\
    , \"()\", \"()\"]\n</code>\n<|/ a dscore=3 tags=lua |>\n<| c |>\n`local str, arr\
    \ = '()()()', {}` is more idiomatic than `local str, arr = \" ()()()\", {}`\n\
    <|/ c |>\n<| a dscore=2 tags=lua |>\nThis is another way to solve the problem:\n\
    <code>", "  -- Make sure that there is something to evaluate\n  local parsed_string\
    \ = \"()\" -- The parenthesis group that we're looking at\n  local paren_groups\
    \ = {parsed_string} -- An empty list to contain our parenthesis groups and a fake\
    \ parenthesis group", "    local open_brace_count = 0\n    local strings_to_return\
    \ = {}\n    for paren_char in string.gmatch(paren_string, \"[^(]+\") do\n    \
    \    if paren_char == '(' then\n            if open_brace_count == 0 then\n  \
    \              open_brace_count = open_brace_count + 1\n            elseif open_brace_count\
    \ > 0 then\n                open_brace_count = open_brace_count - 1\n        \
    \    end\n        elseif paren_char == ')' then\n            if open_brace_count\
    \ == 0 then\n                return strings_to_return\n            elseif open_brace_count\
    \ > 0 then\n                open_brace_count = open_brace_count - 1\n        \
    \    end\n        elseif paren_char == \" \" then\n            -- Ignore space\n\
    \        else\n            strings_to_return[#strings_to_return + 1] = '\"' ..\
    \ paren_char .. '\"'\n        end\n    end\n    return strings_to_return\nend\n\
    </code>\n<|/ a tags=lua dscore=0 |>\n<| a tags=lua dscore=0 |>\nThe question asks\
    \ for Lua, but you tagged this question with JavaScript. \nAnyway, I wanted to\
    \ share my solution without using string.gmatch and string.gsub. My solution does\
    \ not require any loops so it is quite fast and clean.\n<code>\n// Find all brackets\
    \ in string and put them into brackets array", "  local in_paren = false\n  local\
    \ groups = {()}\n  for symbol in string.gmatch(paren_string, \"%[%)]()()\") do\n\
    \    if symbol == \"(\" then\n      if in_paren then\n        groups[#groups +\
    \ 1] = symbol\n      else\n        in_paren = true\n      end\n    elseif symbol\
    \ == \")\" then\n      if not in_paren then\n        groups[#groups + 1] = symbol\n\
    \      end\n      in_paren = false\n    elseif symbol == \" \" then\n      in_paren\
    \ = not in_paren\n    end\n  end\n  return groups\nend", "  local num_open_braces\
    \ = 1\n  local open_braces = ''\n  local close_braces = ''\n  local paren_groups\
    \ = {}", "   local groups = {}\n   local depth = 1\n   local pos = 1\n   while\
    \ true do\n      local c = paren_string:sub(1, 1)\n      if c == '(' then depth\
    \ += 1; else depth = depth - 1; end\n      if depth == 0 then\n         table.insert(groups,\
    \ paren_string:sub((pos - 1), (pos - 1)))\n         pos = paren_string:len()\n\
    \      else\n         pos = pos + 1\n      end\n   end\n   return groups\nend",
  "  local function balanced_parens(open_braces, closed_braces)\n    -- Check how\
    \ many open/close braces are in parens\n    local brace_count = open_braces -\
    \ closed_braces\n    -- If there are no more open braces then return true\n  \
    \  if brace_count < 0 then\n      return true\n    end\n    -- If there are more\
    \ open braces than close braces then return false\n    if brace_count > 0 then\n\
    \      return false\n    end\n    -- Check how many open/close braces are in parens\n\
    \    local open_brace_count = closed_braces - open_braces\n    -- If there are\
    \ more open_braces than close_braces then return false\n    if open_brace_count\
    \ < 0 then\n      return false\n    end\n    -- If there are more open_braces\
    \ and same amount of close_braces then return true\n    if open_brace_count ==\
    \ 0 then\n      return true\n    end\n  end", "  local results = {}\n  local current_group\
    \ = 1\n  local brace_stack = {}\n  for index, character in pairs(paren_string)\
    \ do\n    if character == ')' and current_group == 1 then\n      local new_groups\
    \ = brace_stack[#brace_stack]\n      for _, group in ipairs(new_groups) do\n \
    \       results[#results + 1] = group\n      end\n      brace_stack[#brace_stack]\
    \ = nil\n      current_group = 1\n    elseif character == '(' and current_group\
    \ == 1 then\n      brace_stack[#brace_stack + 1] = character\n      current_group\
    \ = #brace_stack + 1\n    end\n  end\n  -- Append the final group\n  if current_group\
    \ > 1 then\n    results[#results + 1] = brace_stack[#brace_stack]\n  end\n  return\
    \ results\nend\n</code>\n<|/ a tags=recursion,functional-programming,lua,function,string\
    \ |>\n<| c |>\nThis can be improved, using tail-recursion and memoizing.\n<|/\
    \ c |>\n<| a dscore=0 |>\nYou can use a stack to determine which parens need to\
    \ be balanced. \nThis code will work in Lua 5.1 as well.\n<code>", "    local\
    \ results = {} -- A list of all the substrings we found\n    local nesting_level\
    \ = 0\n    local nesting_stack = {} -- The stack we're currently in. Used to help\
    \ us know when to pop\n    local open_parens = {} -- Keep track of which open\
    \ parens we've encountered so we don't double count them\n    local opening_curly_braces\
    \ = 0 -- Keep track of how many open curly braces we've encountered\n    local\
    \ last_char\n    for c in string.gsub(paren_string, \"( )\") do\n        if c\
    \ == \")\" then\n            nesting_level -= 1\n        end\n        if nesting_level\
    \ == 0 then\n            nesting_stack[#nesting_stack + 1] = c\n        elseif\
    \ nesting_level ~= 0 then\n            if nesting_stack[#nesting_stack] == c then\n\
    \                nesting_stack[#nesting_stack] = 0\n            else\n       \
    \         nesting_stack[#nesting_stack] = c\n            end\n        end\n  \
    \      if nesting_level == 0 and c == \"(\" then\n            open_parens[#open_parens\
    \ + 1] = c\n            opening_curly_braces = c\n        end\n        if nesting_level\
    \ == 0 and c == \")\" then\n            open_parens[#open_parens] = nesting_stack[#nesting_stack]\n\
    \            nesting_stack[#nesting_stack] = 0\n        end\n        last_char\
    \ = c\n    end", "    local paren_groups = {}\n    local string_position = 1\n\
    \    local paren_count = 1\n    while string_position < #paren_string do\n   \
    \     local open_brace_position =\n            paren_string:find(string.format('%[(%a+)%['),\
    \ string_position, false)\n        local close_paren_position =\n            paren_string:find(string.format('%]%a%['),\
    \ string_position, false)\n        if open_brace_position > 0 and close_paren_position\
    \ ~= 0 then\n            paren_groups[#paren_groups + 1] = paren_string:sub(string_position,\
    \ open_brace_position - 1)\n            paren_count = paren_count + 1\n      \
    \      paren_groups[#paren_groups + 1] = paren_string:sub(open_brace_position\
    \ + 1, close_paren_position)\n            paren_count = paren_count + 1\n    \
    \        paren_groups[#paren_groups + 1] =\n                paren_string:sub(close_paren_position\
    \ + 1, #paren_string)\n        elseif open_brace_position > 0 then\n         \
    \   paren_groups[#paren_groups + 1] = paren_string:sub(string_position, open_brace_position)\n\
    \            paren_count = paren_count + 1\n            paren_groups[#paren_groups\
    \ + 1] =\n                paren_string:sub(open_brace_position + 1, #paren_string)\n\
    \        else\n            paren_groups[#paren_groups + 1] = paren_string:sub(string_position,\
    \ close_paren_position)\n            paren_count = paren_count + 1\n        end\n\
    \        string_position = close_paren_position + 1\n    end\n    return paren_groups\n\
    end", "  local groups = {}\n  local open_paren_count = 0\n  local open_curly_count\
    \ = 0\n  for _, _ in string.gmatch(paren_string, '[^)]*') do\n    if open_paren_count\
    \ == 0 then\n      if open_curly_count == 0 then\n        groups[#groups + 1]\
    \ = '()'\n      else\n        groups[#groups + 1] = '(..)'\n        open_curly_count\
    \ = open_curly_count + 1\n      end\n    elseif open_paren_count == 1 then\n \
    \     groups[#groups + 1] = '(..)'\n      open_curly_count = open_curly_count\
    \ + 1\n    else\n      if open_curly_count > 1 then\n        groups[#groups +\
    \ 1] = groups[#groups + 1]..')'\n      else\n        groups[#groups + 1] = '()'\n\
    \      end\n      open_paren_count = open_paren_count + 1\n    end\n  end\n  return\
    \ groups\nend", "    local groups = {}\n    local last_open_brace = -1\n    local\
    \ open_brace_count = 0\n    local last_close_brace = -1\n    local close_brace_count\
    \ = 0\n    for index, c in ipairs(paren_string) do\n        if c == '(' then\n\
    \            open_brace_count = open_brace_count + 1\n        elseif c == ')'\
    \ then\n            open_brace_count = open_brace_count - 1\n            if open_brace_count\
    \ == 0 then\n                close_brace_count = close_brace_count + 1\n     \
    \       else\n                if close_brace_count == 0 then\n               \
    \     table.insert(groups, string.sub(paren_string, last_open_brace + 1, index\
    \ - 1))\n                else\n                    table.insert(groups, string.sub(paren_string,\
    \ last_open_brace, index - 1))\n                end\n                open_brace_count\
    \ = open_brace_count + 1\n                close_brace_count = close_brace_count\
    \ - 1\n            end\n        elseif open_brace_count > 0 then\n           \
    \ table.insert(groups, string.sub(paren_string, last_open_brace + 1, index))\n\
    \            last_close_brace = index\n            close_brace_count = close_brace_count\
    \ + 1\n        end\n        last_open_brace = index\n    end\n    return groups\n\
    end", "  -- Initialize our return list\n  local return_list = {}\n  -- Initialize\
    \ our stack to store which parens have been opened.\n  local stack_of_parens =\
    \ 0\n  -- Iterate over all the characters in the paren_string.\n  for i, char\
    \ in ipairs(paren_string) do\n    -- If the character is a left brace, push it\
    \ to the stack, and increment it.\n    if char == '(' then\n      stack_of_parens\
    \ = stack_of_parens + 1\n    -- If the character is a right brace, pop an item\
    \ from the stack and\n    -- decrement it if the value is not 0, indicating that\
    \ the stack is non-empty.\n    -- Otherwise, if the stack becomes empty, the character\
    \ is an end paren.\n    -- If the stack becomes non-empty, the character is an\
    \ open paren.\n    -- If the stack becomes empty, the character is an unmatched\
    \ brace.\n    else if char == ')' then\n      -- Pop the character from the stack\
    \ and\n      -- decrement it by 1 to indicate the left paren was closed.\n   \
    \   if stack_of_parens > 0 then\n        stack_of_parens = stack_of_parens - 1\n\
    \      -- If the stack is empty, the character is an end paren.\n      elseif\
    \ stack_of_parens == 0 then\n        return_list[i] = char\n      -- If the stack\
    \ is not empty, the character is an open paren.\n      else\n        stack_of_parens\
    \ = stack_of_parens + 1\n      end\n    -- If it's the start of an unclosed paren,\
    \ push it to the stack and increment it.\n    -- Otherwise, it's a space.\n  \
    \  else if char == ' ' then\n      if stack_of_parens > 0 then\n        stack_of_parens\
    \ = stack_of_parens + 1\n      -- If the stack is empty, the character is an unmatched\
    \ space.\n      else\n        return_list[i] = char\n      end\n    -- Otherwise,\
    \ it's a malformed paren, ignore it.\n    else\n      stack_of_parens = stack_of_parens\
    \ + 1\n    end\n  end\n  return return_list\nend", "  local result = {}\n  local\
    \ depth = 1\n  local current_group = 1", "  local open_parens = nil\n  local closed_parens\
    \ = nil\n  local results = {}", "  local open_brace_counter = 0\n  local paren_groups\
    \ = {}\n  for paren_string in string.gmatch(paren_string, \"%[(%[(%[([%[(%[()%)]%)%)]%)]%)]\"\
    ) do\n    if paren_string:sub(1, 1) == '(' then\n      open_brace_counter = open_brace_counter\
    \ + 1\n    elseif paren_string:sub(1, 1) == ')' then\n      open_brace_counter\
    \ = open_brace_counter - 1\n    end\n    if open_brace_counter == 1 then\n   \
    \   table.insert(paren_groups, paren_string)\n    elseif open_brace_counter >\
    \ 0 then\n      paren_groups[#paren_groups+1] = paren_string\n    end\n  end\n\
    \  return paren_groups\nend", "    local open_brackets = { }\n    local closed_brackets\
    \ = { }\n    for i = 0, #paren_string, 1 do\n        local char = paren_string[i]\n\
    \        if char == \")\" then\n            closed_brackets[#closed_brackets+1]\
    \ = char\n        elseif char == \"(\" then\n            open_brackets[#open_brackets+1]\
    \ = char\n        end\n    end\n    local groups = { }\n    for i = 1, #open_brackets,\
    \ 1 do\n        local open_char = open_brackets[i]\n        local close_char =\
    \ closed_brackets[i]\n        -- if we encounter an open parenthesis, check if\
    \ the close parenthesis matches\n        if open_char == \"(\" then\n        \
    \    if close_char == \")\" then\n                groups[#groups+1] = paren_string[(i-1):i]\n\
    \            end\n        end\n    end\n    return groups\nend", "  local groups\
    \ = {}\n  local open_count = 1\n  local closed_count = 0\n  local pos = 1", " \
    \   local groups = {}\n    local open_braces = 1\n    local open_brace_char =\
    \ '{'\n    local close_brace_char = '}'\n    local open_parentheses = 1\n    local\
    \ closed_parentheses = 0\n    local in_group\n    for char in paren_string:gmatch(\"\
    [^\" .. open_brace_char .. close_brace_char .. \"]\") do\n        if char == open_brace_char\
    \ then\n            open_braces = open_braces + 1\n        elseif char == close_brace_char\
    \ then\n            open_braces = open_braces - 1\n        elseif char == open_parentheses\
    \ then\n            open_parentheses = open_parentheses + 1\n        elseif char\
    \ == closed_parentheses then\n            closed_parentheses = closed_parentheses\
    \ - 1\n        elseif char == '(' then\n            if in_group ~= nil then\n\
    \                -- This is an open brace which isn't closed yet\n           \
    \     table.insert(groups, in_group)\n            end\n            in_group =\
    \ char\n        else\n            in_group = nil\n        end\n    end\n    if\
    \ in_group ~= nil then\n        table.insert(groups, in_group)\n    end\n    return\
    \ groups\nend", "  return paren_string:gsub('(%w+)(%w+)',\n  function(s, paren1,\
    \ paren2, paren3)\n    return paren1 .. paren2 .. paren3\n  end)\nend\n</code>\n\
    <|/ a tags=lua,lua-patterns |>\n<| c |>\nThanks for the response - I'm getting\
    \ an error on the first line saying \"expected expression, got '('\" -- any ideas?\
    \ I copy/pasted this exactly from your post.\n<|/ c |>\n<| c |>\nSorry, it should\
    \ have read `%w` instead of `%q`. I've corrected my post.\n<|/ c |>\n<| c |>\n\
    Thanks for the response! I added the code you provided to my script but it's still\
    \ giving me the same error on the first line.\n<|/ c |>\n<| c |>\nI'm running\
    \ this on RHEL 6.4 and Lua 5.3.4. I added \"#!/usr/bin/env lua\" to the top of\
    \ the script and ran it by typing \"lua filename\" in the command line.\n<|/ c\
    \ |>\n<| c |>\nI figured it out. Thanks so much!\n<|/ c |>\n<| a tags=lua,lua-patterns\
    \ dscore=2 |>\nA little more generic solution using recursive patterns:\n<code>",
  "    local paren_list = {}\n    local open_brace_count = 0\n    for ch in string.gmatch(paren_string,\
    \ \"()\") do\n        if ch == '(' then\n            open_brace_count = open_brace_count\
    \ + 1\n        elseif ch == ')' then\n            open_brace_count = open_brace_count\
    \ - 1\n            if open_brace_count <= 0 then\n                table.insert(paren_list,\
    \ table.concat(paren_list, \", \"))\n            end\n        elseif open_brace_count\
    \ > 0 then\n            table.insert(paren_list, ch)\n        end\n    end\n \
    \   return paren_list\nend", "    -- Split string into list of '()' groups\n \
    \   local paren_groups = {}\n    for char in string.gmatch(paren_string, \"()\"\
    ) do\n        table.insert(paren_groups, char)\n    end", "  if paren_string ==\
    \ '' then return nil end\n  local stack = {}\n  local in_string = 0\n  local in_group\
    \ = 0\n  local group_start = 1\n  local group_end = 1\n  local new_group = 1\n\
    \  local last_group_end = 1\n  local groups = {}", "  local balanced_paren_groups\
    \ = { }\n  local open_parens = false\n  local open_parens_idx = 0\n  local last_char\
    \ = ''\n  for idx = 1, #paren_string, 1 do\n    local char = paren_string:sub(idx,\
    \ 1)\n    local last_char_str = last_char and last_char:sub(1, 1)\n    -- Ignore\
    \ spaces in between groups\n    if char == ' ' then\n      open_parens = not open_parens\n\
    \      open_parens_idx = 0\n      last_char = ''\n      continue\n    end\n  \
    \  -- Check for open parens\n    if open_parens then\n      open_parens = not\
    \ (open_parens_idx > idx)\n      open_parens_idx = idx\n      last_char = char\n\
    \      balanced_paren_groups[open_parens_idx] = balanced_paren_groups[open_parens_idx]\
    \ .. last_char\n      continue\n    end\n    -- Check for the closing of parens\n\
    \    if not open_parens and char == '(' then\n      open_parens = true\n     \
    \ open_parens_idx = open_parens_idx + 1\n      last_char = char\n      balanced_paren_groups[open_parens_idx]\
    \ = balanced_paren_groups[open_parens_idx] .. last_char\n    end\n  end\n  return\
    \ balanced_paren_groups\nend", "  local brace_groups = {}\n  local paren_stack\
    \ = {}\n  local current_group = { open = '', close = '', nested = '', string =\
    \ '' }", "  local paren_groups = {}\n  local num_paren = 0\n  for idx, value in\
    \ ipairs(paren_string:gsub('%[%[(%[(%[(%[(%[%[%[(%[%[(%[%[(%[%[%[(%[%[%[(%[%[%[%[%[%[%[%]]]]]%)])])])])])])]]]%]',\
    \ '')) do\n    local open_brace_count\n    if value:sub(1, 1) == '(' and paren_groups[idx]\
    \ ~= '(' then\n      paren_groups[idx] = paren_groups[idx] or ''\n      num_paren\
    \ = num_paren + 1\n      open_brace_count = num_paren\n    elseif value == ')'\
    \ and num_paren > 0 then\n      num_paren = num_paren - 1\n      if open_brace_count\
    \ == 0 then\n        paren_groups[idx] = paren_groups[idx] or '()'\n      end\n\
    \    end\n  end\n  return paren_groups\nend", "    local groups = string.gsub(paren_string,\
    \ \"( +)(%a+)( +)\", function(x) \n        return x..\"()\"\n    end)\n    local\
    \ results = {}\n    for _, x in ipairs(groups) do\n        if x == '' then\n \
    \           continue\n        end\n        local open_brackets = 0\n        for\
    \ _, c in pairs(x) do\n            if c == '(' then\n                open_brackets\
    \ = open_brackets + 1\n            elseif c == ')' then\n                open_brackets\
    \ = open_brackets - 1\n                if open_brackets == 0 then\n          \
    \          table.insert(results, x)\n                end\n            end\n  \
    \      end\n    end\n    return results\nend", "    local groups = { '' }\n  \
    \  local in_group = 0\n    local paren_depth = 0\n    for symbol, _ in pairs(paren_string:gsub('^[(%)].*$',\
    \ ''):gmatch'([^()]*)(.)')\n    do\n        paren_depth = symbol:len()\n     \
    \   if symbol == '(' and in_group == 0 then\n            in_group = paren_depth\n\
    \        elseif symbol == ')' and in_group > 0 then\n            groups[#groups\
    \ + 1] = groups[#groups + 1] or ''\n            groups[#groups + 1] = groups[#groups\
    \ + 1] .. symbol:sub(1, in_group - 1)\n            groups[#groups + 1] = groups[#groups\
    \ + 1] .. symbol:sub((in_group + 1), -1)\n            in_group = paren_depth -\
    \ 1\n        elseif symbol == ')' and in_group > 0 and paren_depth > in_group\
    \ then\n            groups[#groups + 1] = groups[#groups + 1] or ''\n        \
    \    groups[#groups + 1] = groups[#groups + 1] .. symbol:sub(1, in_group - paren_depth\
    \ - 1)\n            groups[#groups + 1] = groups[#groups + 1] .. symbol:sub((in_group\
    \ + 1), -1)\n            in_group = 0\n        end\n    end\n    return groups\n\
    end", "    local output = {}\n    local open_braces, close_braces = 0, 0\n   \
    \ local parens = nil\n    local in_parens = false\n    for parens in string.gmatch(paren_string,\
    \ '%[(%[(%[(%[(%[(%[(%[([%[(%[(%[(%[(%[(%[(%[(%[(%[)%[(%[(%[(%[(%[(%[)%[(%[)]%[(%[(%[(%[)]%[)%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%",
  '    local groups = {}', "    local open_brackets_stack = {}\n    local close_brackets_stack\
    \ = {}\n    local paren_string = paren_string:gsub('%[(%[(%[%[%[%[%[%[%[%[%[',\
    \ '')\n    local open_brackets = #paren_string\n    local close_brackets = 0\n\
    \    local bracket_groups = {}\n    local open_brackets_string = nil\n    local\
    \ close_brackets_string = nil", "  local open_brackets = false\n  local groups\
    \ = {}\n  for i, c in ipairs(paren_string) do\n    if c == '(' and not open_brackets\
    \ then\n      open_brackets = true\n      groups[i] = ''\n    elseif c == ')'\
    \ then\n      open_brackets = false\n      local current_group = groups[#groups]\
    \ or ''\n      groups[#groups] = current_group\n    else\n      groups[i] = groups[i]\
    \ .. c\n    end\n  end\n  return groups\nend", "    local groups = {}\n    local\
    \ open_braces = 0\n    local close_braces = 0\n    local is_in_group\n    local\
    \ current_group", "  -- Split string into individual groups\n  local groups =\
    \ {}\n  local open_braces = 0\n  for group in string.gmatch(paren_string, \"%[(%a*)[(%a*)*]\"\
    ) do\n    -- Increase counter of open_braces if group not empty\n    if not string.len(group)\
    \ then\n      open_braces = open_braces + 1\n    end", "  local result = {}\n\
    \  local paren_count = 0\n  local paren_depth = 0\n  local in_paren = 1", "  \
    \  local open_brackets = {}\n    local close_brackets = {}\n    for char in string.gmatch(paren_string,\
    \ \"%b()()\") do\n        if open_brackets[#open_brackets + 1] == nil then\n \
    \           table.insert(open_brackets, char)\n        else\n            table.insert(close_brackets,\
    \ char)\n        end\n    end", "  paren_string = paren_string:gsub(\"[(){} ]\"\
    , \"\")\n  local paren_opens = paren_string:gsub(\"%w+\", \"()\")\n  local paren_closes\
    \ = paren_opens:gsub(\"%w+\", \"()\")\n  local open_paren_groups = paren_opens:gsub(\"\
    %w+\", \"(\"):gsub(\"%w+\", \"()\")\n  local close_paren_groups = paren_closes:gsub(\"\
    %w+\", \"(\"):gsub(\"%w+\", \"()\")\n  local close_brace_groups = close_paren_groups:gsub(\"\
    %w+\", \"()\")", "  local open_braces = { }\n  local closed_braces = { }\n  for\
    \ i, c in ipairs(paren_string) do\n    if c == '(' or c == '{' then\n      if\
    \ open_braces[#open_braces] == 0 then\n        open_braces[#open_braces] = true\n\
    \      end\n      open_braces[#open_braces] = open_braces[#open_braces] + 1\n\
    \    elseif c == ')' or c == '}' then\n      closed_braces[#closed_braces] = true\n\
    \      if open_braces[#open_braces] == 0 then\n        open_braces[#open_braces]\
    \ = true\n      end\n      open_braces[#open_braces] = open_braces[#open_braces]\
    \ - 1\n    end\n  end\n  local result = { }\n  local i = 1\n  while i <= #closed_braces\
    \ do\n    if not closed_braces[i] then\n      result[#result+1] = paren_string:sub(1,\
    \ i)\n      i = i + 1\n    end\n    i = i + 1\n  end\n  result[#result+1] = paren_string:sub(i)\n\
    \  return result\nend", "  local open_braces = { }\n  local closed_braces = {\
    \ }\n  local open_parens = { }\n  local close_parens = { }", "    local groups\
    \ = {}\n    local pos = 1\n    local open_brace_depth = 1\n    local closed_paren_open_braces\
    \ = 0\n    local open_brace_index = 1", "  -- The stack contains all the parens\
    \ to separate\n  local stack = { }\n  -- Keep track of how many open/closed parentheses\
    \ are in the stack\n  local open_brace_count = 1\n  -- Keep track of how many\
    \ open/closed parenthesis we've seen for each group\n  local open_braces\n  local\
    \ close_braces\n  -- This holds the string that we're going to return\n  local\
    \ result\n  -- The first character of the string is the starting parenthesis\n\
    \  local first_paren_pos\n  -- The last character of the string is the ending\
    \ parenthesis\n  local last_paren_pos\n  -- If the last character of the string\
    \ is a space, we are done separating the parens\n  local last_space\n  -- If there\
    \ are multiple spaces after the closing paren, we are done separating the parens\n\
    \  local after_close_brace_pos\n  -- Count the number of spaces after the closing\
    \ paren\n  local after_close_brace_count\n  -- The character before the opening\
    \ paren we're currently looking at\n  local previous_char\n  -- The characters\
    \ that are in the input string between the last character of the string and the\
    \ current character\n  local between\n  -- The character that we're looking for,\
    \ if the current character is not a space\n  local wanted_char\n  -- The character\
    \ that we're looking for, if the current character is a space\n  local wanted_space\n\
    \  -- The character to look for if it's followed by an opening paren\n  local\
    \ wanted_paren\n  -- The character to look for if it's followed by a closing paren\n\
    \  local wanted_close_brace\n  -- The string to add to result after we separate\
    \ out all the parens\n  local temp\n  -- The string that we're currently building\
    \ up\n  local temp_str\n  -- The string that we're going to add to result\n  local\
    \ temp_str2\n  -- The string that we're going to add to result if the opening\
    \ paren we're currently looking for is a space\n  local temp_str3\n  -- The index\
    \ to start searching in the string we're building up\n  local index\n  -- The\
    \ last character of the string to start searching in the string we're building\
    \ up\n  local last_char\n  -- The index of the first character of the string to\
    \ start searching in the string we're building up\n  local first_char_pos\n  --\
    \ The index of the last character of the string to start searching in the string\
    \ we're building up\n  local last_char_pos\n  -- The index of the first character\
    \ of the string to start searching in the string we're building up\n  local first_space\n\
    \  -- The index of the last character of the string to start searching in the\
    \ string we're building up\n  local ", "  -- Check for empty string\n  if paren_string:sub(1,1)\
    \ == '(' then return '' end", "    local result = {}\n    local paren_balance\
    \ = #paren_string\n    local open_brace_count = 1\n    for i=1, paren_balance\
    \ do\n        local c = paren_string[i]\n        if c == '(' and open_brace_count\
    \ > 0 then\n            open_brace_count = open_brace_count - 1\n        elseif\
    \ c == ')' and open_brace_count > 0 then\n            open_brace_count = open_brace_count\
    \ + 1\n        elseif c == ')' then\n            open_brace_count = open_brace_count\
    \ - 1\n        elseif c == ' ' then\n            if open_brace_count == 0 then\n\
    \                table.insert(result, c)\n            end\n        end\n    end\n\
    \    return result\nend", "  local paren_groups = {}\n  local paren_group = 0\n\
    \  local i = 1\n  local is_open = false\n  local open_brace_count = 0\n  local\
    \ closed_brace_count = 0\n  local open_brace_depth = 0\n  local closed_brace_depth\
    \ = 0\n  local depth = 0\n  local open_paren_groups = true", "  local result =\
    \ {}\n  local i = 1\n  while i <= #paren_string do\n    local paren_stack = {}\n\
    \    local paren_count = 0\n    while i <= #paren_string and paren_count < 2 do\n\
    \      if paren_string[i] == '(' then\n        paren_stack[#paren_stack + 1] =\
    \ paren_string[i]\n        paren_count = paren_count + 1\n      elseif paren_string[i]\
    \ == ')' then\n        paren_count = paren_count - 1\n        if paren_count ==\
    \ 0 then\n          local parent_str = table.concat(paren_stack, '').\n      \
    \      replace(\" \", \"\").\n            replace(\" \", \"\")\n          if parent_str\
    \ ~= \"\" then\n            result[#result + 1] = parent_str\n          end\n\
    \          table.clear(paren_stack)\n        end\n      elseif paren_string[i]\
    \ == '[' then\n        paren_stack[#paren_stack + 1] = paren_string[i]\n     \
    \   paren_count = paren_count + 1\n      elseif paren_string[i] == ']' then\n\
    \        paren_count = paren_count - 1\n        if paren_count == 0 then\n   \
    \       local parent_str = table.concat(paren_stack, '').\n            replace(\"\
    \ \", \"\").\n            replace(\" \", \"\")\n          if parent_str ~= \"\"\
    \ then\n            result[#result + 1] = parent_str\n          end\n        \
    \  table.clear(paren_stack)\n        end\n      end\n      i = i + 1\n    end\n\
    \  end\n  return result\nend", "    local function get_paren(group, opening_count)\n\
    \        -- group is the current group we're working on. opening_count keeps track\
    \ of how many open parens we have.\n        -- If opening_count >= 2, then we're\
    \ inside another set of parens and we skip that group and look for new groups.\n\
    \        -- If opening_count = 3, then we found an open paren outside of a group\
    \ and we know we're done.\n        -- If opening_count = 1, then we're inside\
    \ an open paren, so we can add the group to the list of groups.\n        local\
    \ paren = group:sub(1, opening_count-1)\n        local paren_group = group:sub(1,\
    \ opening_count-1)\n        local next_group = group:sub(opening_count+1)\n  \
    \      if opening_count >= 2 then\n            return paren_group, paren_group,\
    \ paren\n        elseif opening_count >= 1 then\n            return paren_group,\
    \ paren\n        else\n            return paren\n        end\n    end\n    local\
    \ paren_string_list = paren_string:gsub('(%S+)(%S+)(%S+)', function(w)\n     \
    \   -- Keep track of the current group\n        local current_group = \"\"\n \
    \       local opening_count = 0\n        -- For each character...\n        for\
    \ index, c in ipairs(w) do\n            -- If it's a paren, add it to the group\n\
    \            if c == \"(\" then\n                opening_count = opening_count\
    \ + 1\n                current_group = current_group .. c\n            else\n\
    \                -- Otherwise, if we're not inside parentheses, add the current\
    \ group to the list and reset it\n                if opening_count > 0 then\n\
    \                    current_group = current_group .. current_group\n        \
    \            opening_count = 0\n                end\n            end\n       \
    \ end\n        -- If we're inside parentheses and haven't closed the most recent\
    \ group, add the current group to the list and reset it\n        if opening_count\
    \ > 0 then\n            current_group = current_group .. current_group\n     \
    \       opening_count = 0\n        end\n        -- Return the group\n        return\
    \ current_group\n    end)\n    -- Remove the empty strings at the start and end\n\
    \    local paren_string_list = paren_string_list:gsub('^%s+', '', paren_string_list)\n\
    \    local paren_string_list = paren_string_list:gsub('%s+$', '', paren_string_list)\n\
    \    return paren_string_list\nend\n</code>\nTo use this function with any given\
    \ string, simply do this:\n<code>", "    if paren_string == nil then\n       \
    \ return nil\n    end\n    local open_chars = {}\n    local close_chars = {}\n\
    \    local groups = {}\n    for _, c in ipairs(paren_string) do\n        if c\
    \ == '(' then\n            table.insert(open_chars, c)\n        elseif c == ')'\
    \ then\n            close_chars[#close_chars] = c\n        elseif c == '{' or\
    \ c == '}' then\n            close_chars[#close_chars] = c\n        else\n   \
    \         table.insert(groups, c)\n        end\n    end\n    local group_string\
    \ = table.concat(groups, '')\n    for _, c in ipairs(close_chars) do\n       \
    \ group_string = group_string:sub(1, group_string:len()-1)\n    end\n    table.insert(groups,\
    \ group_string)\n    return groups\nend", "  local groups = {}\n  local open_brace\
    \ = 0", "  local result = {}\n  local open_braces = false\n  local level = 0\n\
    \  local paren_depth = 0\n  local current_string = ''\n  local brackets = 0\n\
    \  for c in string.gmatch(paren_string, \"()\") do\n    if c == '(' or open_braces\
    \ then\n      paren_depth = paren_depth + 1\n      open_braces = c == '(' and\
    \ (not open_braces) or open_braces\n      if open_braces then\n        level =\
    \ level + 1\n      elseif level > 0 then\n        level = level - 1\n      end\n\
    \    elseif c == ')' then\n      paren_depth = paren_depth - 1\n      open_braces\
    \ = open_braces and (not paren_depth)\n      if not open_braces then\n       \
    \ level = level - 1\n      end\n    elseif open_braces and level > 0 then\n  \
    \    open_braces = false\n      level = level - 1\n    end\n    if not open_braces\
    \ or not level then\n      current_string = current_string .. c\n    end\n   \
    \ if c == '(' and (not paren_depth) then\n      table.insert(result, current_string)\n\
    \      current_string = ''\n    end\n    brackets = brackets + 1\n  end\n  if\
    \ open_braces and level > 0 then\n    table.insert(result, current_string)\n \
    \ end\n  return result\nend", "    local groups = { }\n    local stack_count =\
    \ 0\n    for paren_char in string.gmatch(paren_string, '()') do\n        -- if\
    \ we found an opening parenthesis, increment our stack count\n        if paren_char\
    \ == '(' then\n            stack_count = stack_count + 1\n        elseif paren_char\
    \ == ')' then\n            stack_count = stack_count - 1\n        end\n      \
    \  -- if we are out of balance and have less opening parenthesis than we closed,\n\
    \        -- add this group to the groups and reset the stack count\n        if\
    \ stack_count < 0 then\n            groups[#groups + 1] = paren_char\n       \
    \     stack_count = 0\n        else\n            -- if we are out of balance and\
    \ have more closing parenthesis than we opened, ignore the closing parenthesis\n\
    \            -- if we are out of balance and have more opening parenthesis than\
    \ we closed, ignore the opening parenthesis\n            if stack_count > 0 and\
    \ stack_count < #groups + 1 then\n                groups[#groups + 1] = paren_char\n\
    \                stack_count = 0\n            end\n        end\n    end\n    return\
    \ groups\nend", "\tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\
    3')\n\tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal\
    \ paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal paren_string\
    \ = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)(\
    \ +)(%w+)', '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)',\
    \ '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\
    \tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal paren_string\
    \ = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)(\
    \ +)(%w+)', '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)',\
    \ '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\
    \tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal paren_string\
    \ = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)(\
    \ +)(%w+)', '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)',\
    \ '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\
    \tlocal paren_string = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal paren_string\
    \ = paren_string:gsub('(%w+)( +)(%w+)', '\\\\2')\n\tlocal paren_string = paren_string:gsub('(%w+)(\
    \ +)(%", "   -- Your code here!\n   print(paren_string)\nend", "   -- This regular\
    \ expression matches all the outer groups of parentheses\n   -- (i.e. '()', '(())',\
    \ '(()())', and so on)\n   local paren_group_regex = /(^|[^():^])(\\()?(\\2*)((?(3)\\\
    2*))\\2*(?!\\2)(\\3|$)/\n   local matched_paren_groups = paren_group_regex:gsub('%u',\
    \ nil)\n   if paren_group_regex.match(paren_string) then\n      -- The return\
    \ value is a table containing all matched groups\n      local result = {}\n  \
    \    -- Loop through all the groups\n      for i = 1, #matched_paren_groups do\n\
    \         -- Separate each group into its own substring and return it\n      \
    \   table.insert(result, matched_paren_groups[i]:sub(1, #matched_paren_groups[i]-1))\n\
    \      end\n      return result\n   end\nend", "    local open_braces = 0\n  \
    \  local current_string = ''\n    local paren_groups = {{ paren_string}};", " \
    \ -- First, separate the input string into individual strings using the regular\
    \ expression function\n  local in_str = string.gsub(paren_string, \"[ ]+\", \"\
    \")\n  -- Now, convert the list of individual strings into one giant string by\
    \ replacing all open and close parentheses\n  local out_str = string.gsub(in_str,\
    \ \"()\", \"__OPEN_PAREN__%1$s__%1$s\")\n  local out_str = string.gsub(out_str,\
    \ \"__OPEN_PAREN__%1$s\", \"(\")\n  local out_str = string.gsub(out_str, \"__CLOSE_PAREN__%1$s\"\
    , \")\")\n  -- Finally, return the list of strings separated into separate strings\n\
    \  return string.gmatch(out_str, \"__OPEN_PAREN__%S*__CLOSE_PAREN__\")\nend\n\
    </cell>\n<text>\nTask 2 - Write a function split_paren_string that accepts two\
    \ arguments: a string and a delimiter (an open parenthesis or close parenthesis)\
    \ and returns a list of all the substrings in the string delimited by an open\
    \ parenthesis or close parenthesis. Ignore any spaces in the input string.", " \
    \  local tokens = paren_string:gsub('%w+%s*', ''):gmatch('%[(%w+)()]+')\n   local\
    \ open_groups = {}\n   for _, token in pairs(tokens) do\n      if token == '('\
    \ or token == '[' then\n         open_groups[#open_groups + 1] = {} -- Create\
    \ new group\n         open_groups[#open_groups][token] = 1 -- Count open brackets\n\
    \      elseif token == ')' or token == ']' then\n         local open_count = open_groups[#open_groups][token]\
    \ -- Count open brackets\n         if open_count == 0 then\n            error('Unbalanced\
    \ paren group') -- Report error\n         elseif open_count > 1 then\n       \
    \     error('Unbalanced paren group') -- Report error\n         elseif open_count\
    \ == 1 then\n            open_groups[#open_groups][token] = open_count -- Keep\
    \ track of number of open brackets\n         else\n            error('Unbalanced\
    \ paren group') -- Report error\n         end\n      else\n         open_groups[#open_groups\
    \ + 1][token] = open_groups[#open_groups][token] + 1 -- Count open brackets\n\
    \      end\n   end\n   return tokens\nend", "    local open_brace = 1\n    local\
    \ groups = {}\n    local nested_paren = 0\n    for i = 1, string.len(paren_string)\
    \ do\n        if string.sub(paren_string, i, i) ~= \")\" then\n            nested_paren\
    \ = 0\n        end\n        if string.sub(paren_string, i, i) ~= \"(\" then\n\
    \            if nested_paren == 1 then\n                nested_paren = 0\n   \
    \         else\n                nested_paren = 1\n            end\n        else\n\
    \            if nested_paren == 1 then\n                nested_paren = 0\n   \
    \         else\n                nested_paren = 1\n            end\n        end\n\
    \        if open_brace > 0 and nested_paren == 1 then\n            groups[#groups+1]\
    \ = string.sub(paren_string, i, i)\n        end\n        if string.sub(paren_string,\
    \ i, i) ~= \")\" then\n            open_brace = open_brace + 1\n        else\n\
    \            open_brace = open_brace - 1\n        end\n    end\n    return groups\n\
    end", "   -- Your code here!\nend", "    if paren_string:find('()', 1, true) then\n\
    \        local last_open_brace = paren_string:find('()', 1, true)\n        local\
    \ last_closing_paren = paren_string:find('()', 1, true)\n        local open_brace_count\
    \ = 0\n        local closing_paren_count = 0\n        local output_string = '['\n\
    \        for i = 1, #paren_string, 1 do\n            local char = paren_string:sub(i,\
    \ i)\n            if char == '(' then\n                open_brace_count = open_brace_count\
    \ + 1\n                if open_brace_count > 1 then\n                    output_string\
    \ = output_string .. ')'\n                else\n                    output_string\
    \ = output_string .. '()'\n                end\n            elseif char == ')'\
    \ then\n                closing_paren_count = closing_paren_count + 1\n      \
    \          if closing_paren_count == open_brace_count then\n                 \
    \   output_string = output_string .. ')'\n                else\n             \
    \       output_string = output_string .. '()'\n                end\n         \
    \   else\n                output_string = output_string .. char\n            end\n\
    \        end\n        return output_string\n    else\n        return paren_string\n\
    \    end\nend", "  local open_braces\n  local close_braces\n  local open_brace_pos\n\
    \  local close_brace_pos\n  local open_brace_group = 1\n  local close_brace_group\
    \ = 1\n  local open_brace_group_ind\n  local close_brace_group_ind\n  local num_open_braces\n\
    \  local num_close_braces\n  local num_open_brace_groups\n  local num_close_brace_groups\n\
    \  local output = {}", "    local pos = 0\n    local groups = {}\n    local open_braces\
    \ = 1\n    local close_braces = 0\n    local brackets = { '()', '[]', '{}' }\n\
    \    local open_brackets = 1\n    local close_brackets = 0\n    local brace_count\
    \ = 0\n    local bracket_count = 0\n    local stack = {}", "  local bracket_stack\
    \ = {}\n  local bracket_count = 0\n  local groups = {}\n  local current_group\
    \ = nil\n  local i = 1\n  local len = #paren_string\n  for i=1, len do\n    if\
    \ paren_string[i] == '(' then\n      bracket_stack[#bracket_stack + 1] = paren_string[i]\n\
    \      bracket_count = #bracket_stack\n    elseif paren_string[i] == ')' then\n\
    \      local last = bracket_stack[#bracket_stack]\n      bracket_stack[#bracket_stack]\
    \ = nil\n      if last == '(' or last == nil then\n        bracket_count = #bracket_stack\
    \ - 1\n      end\n    end\n    if bracket_stack[#bracket_stack] == nil then\n\
    \      current_group = paren_string[i]\n      groups[#groups+1] = current_group\n\
    \    end\n  end\n  return groups\nend", "\tlocal groups = { }\n\tlocal last_group_start\
    \ = 0\n\tlocal group_start = 0\n\tlocal i = 0\n\tlocal parens = 0\n\tlocal start\
    \ = 0\n\tlocal depth = 0\n\tlocal instring = 0", "  -- We must first tokenize\
    \ the input string\n  local tokens_by_bracket_type = util.token_string_to_table(\"\
    [\", \")\", \",\")\n  -- The table above is indexed with strings, and contains\
    \ the tokens that make up the string - if the\n  -- string begins with an opening\
    \ paren, then it is a group of parentheses, otherwise it is an opening paren\n\
    \  local bracket_type_tokens = {}\n  for token, token_type in pairs(tokens_by_bracket_type)\
    \ do\n    if token:sub(1,1) == string.format(\"%c\", token:sub(1,1)) and token\
    \ ~= \")\" then\n      table.insert(bracket_type_tokens, token) -- The first element\
    \ of the bracket_type_tokens table is the entire token\n    end\n  end\n  -- The\
    \ next step removes any \"empty\" groups that may have appeared due to being missing\
    \ a closing paren\n  local paren_tokens = util.filter_table(table.unpack(\n  \
    \  table.sort(\n      util.filter_string_list(\n        table.sort(\n        \
    \  table.unpack(\n            util.filter_string_list(\n              util.filter_table(bracket_type_tokens,\n\
    \                function(token) -- Filter out any tokens that are not parens\n\
    \                  return token:sub(1,1) == \"(\" and token ~= \")\" and token\
    \ ~= \",\" and token ~= \".\"\n                end\n              )\n        \
    \    )\n          )\n        ),\n        function(token) -- Filter out any tokens\
    \ that do not contain parens\n          return token:sub(1,1) ~= \")\" and token\
    \ ~= \",\" and token ~= \".\"\n        end\n      )\n    )\n  ))", "\tlocal function\
    \ get_open_paren(index)\n\t\treturn string.sub(full_string, index, index - 1)\n\
    \tend", '    local groups = {}', "  local num_open_brackets = 0\n  local open_brackets\n\
    \  local num_closed_brackets = 0\n  local close_brackets\n  local open_brackets_str\
    \ = {}\n  local close_brackets_str = {}\n  local open_brackets_str_tab = {}\n\
    \  local close_brackets_str_tab = {}\n  local tmp_str = \"\"\n  local new_str\
    \ = \"\"\n  for c in string.gmatch(paren_string, \"()\") do\n    if c == \"(\"\
    \ then\n      open_brackets = open_brackets + 1\n      open_brackets_str[num_open_brackets]\
    \ = c\n      open_brackets_str_tab[num_open_brackets] = tmp_str\n    elseif c\
    \ == \")\" then\n      num_closed_brackets = num_closed_brackets + 1\n      close_brackets_str[num_closed_brackets]\
    \ = c\n      close_brackets_str_tab[num_closed_brackets] = tmp_str\n      if num_closed_brackets\
    \ == open_brackets then\n        tmp_str = tmp_str..\"()\"\n        num_closed_brackets\
    \ = 0\n      else\n        tmp_str = tmp_str..\"(\"\n        num_closed_brackets\
    \ = open_brackets - 1\n      end\n    elseif c == \" \" then\n      num_closed_brackets\
    \ = num_closed_brackets + 1\n      close_brackets_str[num_closed_brackets] = c\n\
    \      close_brackets_str_tab[num_closed_brackets] = tmp_str\n    else\n     \
    \ tmp_str = tmp_str..c\n    end\n  end\n  if open_brackets == 0 then\n    local\
    \ num_closed_brackets = 0\n    for i = 1, #open_brackets_str do\n      if open_brackets_str[i]\
    \ ~= \"(\" then\n        num_closed_brackets = num_closed_brackets + 1\n     \
    \   close_brackets_str[num_closed_brackets] = open_brackets_str[i]\n        close_brackets_str_tab[num_closed_brackets]\
    \ = open_brackets_str_tab[i]\n      elseif open_brackets_str[i] == \"(\" then\n\
    \        open_brackets_str[i] = \"\"\n      end\n    end\n  end\n  if num_closed_brackets\
    \ == 0 then\n    local num_closed_brackets = 0\n    for i = 1, #close_brackets_str\
    \ do\n      if close_brackets_str[i] ~= \")\" then\n        num_closed_brackets\
    \ = num_closed_brackets + 1\n        close_b", "  -- Create a string with only\
    \ the outer parens\n  local paren_string = paren_string:gsub(\"%[%[(%{([%{%)}]%}]%)]\"\
    , \"\")\n  -- Keep track of how many open parens we have seen so we don't include\
    \ them in the substring\n  local open_count = 1\n  -- Keep track of the number\
    \ of close parens we have seen\n  local close_count = 0\n  -- Start an index of\
    \ the string\n  local i = 1\n  -- Create a substring that we will use to return\
    \ our results\n  local result = ''\n  -- For each character in the string\n  for\
    \ c in paren_string:gmatch(\"[^%{(%)]\") do\n    -- If the character is a (\n\
    \    if c == '(' then\n      -- If we are currently inside a paren, increment\
    \ the counter\n      if open_count > 1 then\n        open_count = open_count +\
    \ 1\n      -- Otherwise, if we are currently outside a paren and close parens\
    \ match\n      elseif (open_count == 1 and close_count == 0) then\n        --\
    \ Add the character to the result string\n        result = result .. c\n     \
    \ -- Otherwise, if we are currently outside a paren and close parens don't match\n\
    \      elseif (open_count == 1 and close_count > 0) then\n        -- Add the closing\
    \ paren to the result string\n        result = result .. c\n        -- Add closing\
    \ paren to the result string\n        result = result .. '('\n        -- Decrement\
    \ the counter\n        close_count = close_count - 1\n      -- Otherwise, if we\
    \ are currently outside a paren and close parens don't match\n      elseif (open_count\
    \ > 1 and close_count > 0) then\n        -- Add the closing paren to the result\
    \ string\n        result = result .. c\n        -- Add the opening paren to the\
    \ result string\n        result = result .. '('\n        -- Decrement the counter\n\
    \        close_count = close_count - 1\n      -- Otherwise, if we are currently\
    \ outside a paren and close parens match\n      elseif (open_count == 1 and close_count\
    \ == 1) then\n        -- Increment the counter\n        open_count = open_count\
    \ + 1\n      -- Otherwise, just add the character to the result string\n     \
    \ else\n        result = result .. c\n      end\n    -- If the character is a\
    \ %\n    elseif c == '%' then\n      -- If the current index is not the same as\
    \ the index the previous character was in\n      if i ~= (i-1) then\n        --\
    \ Add the character to the result string\n        result = result .. c\n     \
    \ end\n    end\n    -- Increment the index\n    i = i + 1\n  end\n  -- Return\
    \ the result string\n  return result\nend", "  if paren_string:match('^%[(.-)(.-)]+$')\
    \ then\n    local paren_strings = {}\n    local open_brace = 1\n    local next_open_brace\
    \ = #paren_string\n    local last_comma = nil\n    local found_closing_brace =\
    \ nil\n    for i = 1, #paren_string do\n      -- Find the next opening brace\n\
    \      local c = paren_string:sub(i,i)\n      if c == '(' and open_brace > 1 then\n\
    \        -- If we've found a closing brace but haven't found any commas yet, we're\
    \ not yet done\n        if next_open_brace ~= open_brace or last_comma ~= ','\
    \ then\n          -- Keep track of the last comma\n          found_closing_brace\
    \ = i\n          -- The found closing brace will be the new open brace (unless\
    \ it also starts a nested group)\n          open_brace = next_open_brace\n   \
    \     end\n      elseif c == '(' and open_brace == 1 then\n        open_brace\
    \ = next_open_brace\n      elseif c == '[' and open_brace > 1 then\n        open_brace\
    \ = next_open_brace\n      elseif c == ']' and open_brace == 1 then\n        open_brace\
    \ = next_open_brace\n      else\n        -- If we're at a closing brace, finish\
    \ off the group\n        if found_closing_brace ~= nil then\n          -- Finish\
    \ off the current group\n          paren_strings[#paren_strings + 1] = paren_string:sub(1,found_closing_brace-1)\n\
    \          paren_strings[#paren_strings + 1] = paren_string:sub(found_closing_brace+1,\
    \ #paren_string)\n          -- Update the last comma\n          last_comma = ','\n\
    \          -- Reset the current open brace and counter\n          open_brace =\
    \ 1\n          next_open_brace = found_closing_brace\n          -- Reset the found\
    \ closing brace\n          found_closing_brace = nil\n        elseif c == '('\
    \ or c == '[' or c == '{' then\n          -- Add the current group to the list\
    \ of paren strings\n          paren_strings[#paren_strings + 1] = paren_string:sub(1,i)\n\
    \          -- Update the current open brace and counter\n          open_brace\
    \ = open_brace + 1\n          next_open_brace = i\n        end\n      end\n  \
    \  end\n    -- Finish off the last group\n    paren_strings[#paren_strings + 1]\
    \ = paren_string:sub(1,#paren_string)\n    -- Return the list of paren strings\
    \ (", "\tlocal function balanced_parens(parens, level)\n\t\tif not parens then\n\
    \t\t\treturn nil\n\t\tend", "  local opening_braces = {}\n  local closing_braces\
    \ = {}\n  local paren_string = paren_string:gsub('[(]', '')\n  paren_string =\
    \ paren_string:gsub('[()]', '')\n  local paren_parts = { paren_string:gsub('[()]{2,}?')\
    \ }\n  local opening_count = 0\n  local closing_count = 0\n  for i, paren_part\
    \ in ipairs(paren_parts) do\n    if paren_part:sub(1, 1) == '(' and opening_count\
    \ < 1 then\n      opening_count = opening_count + 1\n      opening_braces[i] =\
    \ paren_part\n    elseif paren_part:sub(1, 1) == ')' and closing_count < 1 then\n\
    \      closing_count = closing_count + 1\n      closing_braces[i] = paren_part\n\
    \    end\n  end\n  return opening_braces, closing_braces\nend", "  local in_parens\
    \ = false\n  local in_group = false\n  local paren_stack = {}\n  local paren_brackets\
    \ = 0\n  local results = {}\n  for i = 1, #paren_string, 1 do\n    local c = paren_string[i]\n\
    \    if not in_parens then\n      if c == '(' then\n        in_parens = true\n\
    \      elseif c == ')' then\n        in_parens = false\n      elseif c == '['\
    \ then\n        in_group = true\n      elseif c == ']' then\n        in_group\
    \ = false\n      else\n        local parens = paren_stack[#paren_stack + 1]\n\
    \        table.insert(parens, c)\n        if c == '{' then\n          paren_brackets\
    \ = paren_brackets + 1\n        elseif c == '}' then\n          paren_brackets\
    \ = paren_brackets - 1\n        end\n      end\n    else\n      if c == '(' then\n\
    \        table.insert(paren_stack, c)\n      elseif c == ')' then\n        local\
    \ parens = paren_stack[#paren_stack + 1]\n        if #parens > 0 then\n      \
    \    table.insert(results, table.concat(parens, ''))\n        else\n         \
    \ table.insert(results, table.concat(parens, '()'))\n        end\n        table.insert(paren_stack,\
    \ parens)\n      elseif c == '[' then\n        local parens = paren_stack[#paren_stack\
    \ + 1]\n        table.insert(paren_stack, c)\n        if paren_brackets == 0 then\n\
    \          table.insert(results, table.concat(parens, ''))\n        else\n   \
    \       table.insert(results, table.concat(parens, '()'))\n        end\n     \
    \   table.insert(paren_stack, parens)\n      elseif c == ']' then\n        local\
    \ parens = paren_stack[#paren_stack + 1]\n        table.insert(paren_stack, parens)\n\
    \        if paren_brackets == 0 then\n          table.insert(results, table.concat(parens,\
    \ '()'))\n        else\n          table.insert(results, table.concat(parens, '()'))\n\
    \        end\n        table.insert(paren_stack, parens)\n      else\n        local\
    \ parens = paren_stack[#paren_stack + 1]\n        if c == '{' then\n         \
    \ table.insert(paren_stack, c)\n          table.insert(parens, parens)\n     \
    \   elseif c == '}' then\n          table.insert(parens, c)\n          table.insert(paren_stack,\
    \ parens)\n        else\n          table.insert(parens, c)\n        end\n    \
    \  end\n    end\n  end\n  return results\nend", "    local paren_groups = {}\n\
    \    local stack = { paren_string, 0 }\n    while true do\n        local _, current_paren_group_size\
    \ = stack[#stack]\n        local current_paren_group = paren_string:sub(1, current_paren_group_size)\n\
    \        local current_group_is_closed = stack[#stack] == nil\n        if not\
    \ current_group_is_closed then\n            local _, current_group_depth = stack[#stack\
    \ + 1]\n            local current_group_is_nested = not current_group_depth\n\
    \            if current_group_is_nested then\n                table.insert(paren_groups,\
    \ current_paren_group)\n            else\n                if current_paren_group:find()\
    \ ~= nil then\n                    table.insert(paren_groups, current_paren_group)\n\
    \                else\n                    table.insert(paren_groups, current_group_depth)\n\
    \                end\n            end\n        end\n        if not current_group_is_closed\
    \ then\n            local close_paren = paren_string:sub(-current_paren_group_size\
    \ + 1, 1)\n            local open_brace_count = paren_string:find(close_paren)\n\
    \            if open_brace_count ~= nil then\n                stack[#stack + 1]\
    \ = { paren_string:sub(1, open_brace_count + 1), open_brace_count + 1 }\n    \
    \        else\n                table.insert(paren_groups, current_paren_group)\n\
    \            end\n        else\n            table.insert(paren_groups, current_paren_group)\n\
    \        end\n        if #stack > 1 then\n            local _, previous_group_depth\
    \ = stack[#stack - 1]\n            local previous_group_is_nested = not previous_group_depth\n\
    \            if previous_group_is_nested then\n                table.insert(paren_groups,\
    \ previous_group_depth)\n            else\n                if paren_string:sub(previous_group_depth\
    \ + 1, 1) ~= ')' then\n                    table.insert(paren_groups, previous_group_depth)\n\
    \                else\n                    table.insert(paren_groups, -1)\n  \
    \              end\n            end\n        end\n        if #stack == 0 then\n\
    \            break\n        end\n    end\n    return paren_groups\nend\nreturn\
    \ separate_paren_groups\nend\n</code>\n<|/ a |>\n<| c |>\nYou also can do it in\
    \ one line with one for loop `local function separate_paren_groups(paren_string)\
    \ local paren_groups = {}  for i = 1, string.len(paren_string) do local _, current_paren_group_size\
    \ = paren_string:sub(1,i-1) local current_paren_group = paren_string:sub(1,i)\
    \ local current_group_is_closed = paren_string:sub(i,i) == nil if not current_group_is_closed\
    \ then local _, current_group_depth = paren_string:sub(i,i+1) ", "    local open_braces\
    \ = { }\n    local closed_braces = { }\n    local parens_used = false", "\tlocal\
    \ function is_open_brace_pair(pair)\n\t\treturn pair:sub(1,1) == \"{\" and pair:sub(2,2)\
    \ == \"}\" and pair:len() > 1\n\tend", "  local open_brace_count = 0\n  local\
    \ close_brace_count = 0\n  local open_bracket = nil\n  local close_bracket = nil\n\
    \  local buffer = {}\n  local groups = false\n  local group_string = nil", " \
    \   local result = {}\n    local stack = {}\n    local i = 1", "    local num_open_braces\
    \ = #(paren_string)\n    local open_braces", "  local paren_groups = {}\n  local\
    \ open_brace_count = 0\n  local close_brace_count = 0\n  for paren_char in string:gmatch(\"\
    %[(%[(%[(%[(%[(\") do\n    if paren_char == \"(\" then\n      open_brace_count\
    \ = open_brace_count + 1\n    elseif paren_char == \")\" then\n      close_brace_count\
    \ = close_brace_count + 1\n    elseif open_brace_count > close_brace_count then\n\
    \      paren_groups[#paren_groups+1] = paren_char\n    end\n  end\n  return paren_groups\n\
    end", "    -- The recursive function will split off the leading open paren, leaving\
    \ the rest to be handled by the\n    -- recursive call\n    local function separate_paren_groups_helper(paren_string,\
    \ current_index, current_list, closed_group)\n        local open_brace, closed_brace\
    \ = string.match(paren_string, \"[(]\") -- Look for an open paren, close paren,\
    \ or bracket\n        if open_brace == nil then\n            return current_index,\
    \ current_list\n        end\n        local new_list = current_list\n        new_list[#new_list+1]\
    \ = open_brace\n        if closed_brace == nil then\n            -- This new group\
    \ has been closed, so insert it into the list and return it\n            new_list[#new_list]\
    \ = open_brace\n            return #new_list + 1, new_list\n        end\n    \
    \    -- This new group has not been closed, so remove it from the list\n     \
    \   new_list[current_index] = nil\n        -- Make sure that we remove the last\
    \ element of the list in case it's an open paren, otherwise the function\n   \
    \     -- will return a list with one element (a group that was opened but not\
    \ closed)\n        if closed_group == true then\n            -- This group was\
    \ closed, so remove it from the list\n            new_list[#new_list] = nil\n\
    \        end\n        return separate_paren_groups_helper(paren_string, current_index\
    \ + 1, new_list, false) -- Recursively call this function on the\n           \
    \                                                                            \
    \     -- remaining group\n    end\n    return separate_paren_groups_helper(paren_string,\
    \ 1, 1, true) -- Starting with the first open paren, start at index 1 and insert\n\
    end", "    local stack = {}\n    local groups = {}\n    local stack_size = #paren_string",
  "  local function check_for_closing_brace(chars)\n    local closed = false\n   \
    \ for _, c in pairs(chars) do\n      if c == '}' then\n        closed = true\n\
    \      end\n    end\n    if closed then\n      return true\n    end\n    return\
    \ check_for_closing_brace(chars)\n  end\n  local function get_next_chars(chars)\n\
    \    local next = true\n    while next do\n      local next = check_for_closing_brace(chars)\n\
    \      if next then\n        return chars\n      end\n      local _, c = next(chars)\n\
    \      if c ~= '(' then\n        chars = chars..c\n      end\n    end\n  end\n\
    \  local function get_next_open_paren(paren_string)\n    local next = false\n\
    \    local paren = nil\n    local open_brace_open = false\n    while next do\n\
    \      local _, _, c = next(paren_string)\n      if c == '(' and open_brace_open\
    \ then\n        open_brace_open = false\n        paren = paren .. c\n      elseif\
    \ c == '{' then\n        open_brace_open = true\n        paren = paren .. c\n\
    \      end\n    end\n    return paren\n  end\n  local function get_next_closing_brace(paren_string)\n\
    \    local next = false\n    local closing_brace = nil\n    local open_brace_open\
    \ = false\n    while next do\n      local _, _, c = next(paren_string)\n     \
    \ if c == '}' and open_brace_open then\n        open_brace_open = false\n    \
    \    closing_brace = closing_brace .. c\n      elseif c == ')' then\n        open_brace_open\
    \ = true\n        closing_brace = closing_brace .. c\n      end\n    end\n   \
    \ return closing_brace\n  end\n  local function get_next_group(chars)\n    local\
    \ next = false\n    local group_start = nil\n    local group_end = nil\n    while\
    \ next do\n      local _, _, c = next(chars)\n      if c == '{' then\n       \
    \ group_start = group_start .. c\n      elseif c == '}' then\n        group_end\
    \ = group_end .. c\n        next = check_for_closing_brace(chars)\n      else\n\
    \        group_end = group_end .. c\n      end\n    end\n    if group_start ~=\
    \ nil then\n      return group_start, group_end\n    end\n  end\n  local function\
    \ check_paren_group_balance(chars)\n    local _, _, _ = get_next_open_paren(paren_string)\n\
    \    local closing_b", "    local groups = paren_string:gsub(\"([^()]+)(\\\\()?([^()]+)(\\\
    \\))?\",\n                                    function(match, open, paren, close)\n\
    \                                          local new_paren = paren\n         \
    \                                 -- If this is a paren group, open it\n     \
    \                                     if paren then\n                        \
    \                      local group_level = paren_levels[paren]\n             \
    \                                 -- Don't increment the level if we are already\
    \ at a higher level\n                                              if group_level\
    \ > cur_level then\n                                                  group_level\
    \ = cur_level\n                                                  paren_levels[paren]\
    \ = group_level + 1\n                                                  -- Increment\
    \ the level by one\n                                                  cur_level\
    \ = group_level + 1\n                                                  new_paren\
    \ = open .. group_level .. paren .. close\n                                  \
    \            end\n                                          end\n            \
    \                              -- Return a string of the group\n             \
    \                             return new_paren\n                             \
    \       end)\n    -- Close all paren groups and remove extra space\n    groups\
    \ = groups:gsub(\"(^|[() ])([()])\")\n    -- Remove extra space\n    groups =\
    \ groups:gsub(\"[() ]+\", \" \")\n    -- Remove extra newlines at the end\n  \
    \  groups = groups:gsub(\"[\\n]+$\", \"\")\n    -- Remove extra spaces within\
    \ each group\n    groups = groups:gsub(\"(^|[() ])([() ]+)\", \"\\2\")\n    --\
    \ Remove extra newlines after each group\n    groups = groups:gsub(\"(^|[() ])([\\\
    n]+)\", \"\\1\")\n    -- Remove extra spaces within each group\n    groups = groups:gsub(\"\
    ([() ]+)([() ]+)\", \"\\1 \\2\")\n    -- Remove extra newlines after each group\n\
    \    groups = groups:gsub(\"([\\n]+)([() ]+)\", \"\\1 \\2\")\n    -- Remove extra\
    \ spaces within each group\n    groups = groups:gsub(\"([() ]+)([() ]+)\", \"\\\
    1 \\2\")\n    -- Remove extra newlines after each group\n    groups = groups:gsub(\"\
    ([\\n]+)([() ]+)\", \"\\1 \\2\")\n    -- Remove extra spaces within each group\n\
    \    groups = groups:gsub(\"([() ]+)([() ]+)\", \"\\1 \\2\")\n    -- Remove extra\
    \ newlines after each group\n    groups = groups:gsub(\"([\\n]+)([() ]+)\", \"\
    \\1 \\2\")\n    -- Remove extra spaces within each group\n    groups = groups:gsub(\"\
    ([() ]+)([() ]+)\", \"\\1 \\2\")\n    -- Remove extra newlines after each group\n\
    \    groups = groups:gsub(\"([\\n]+)([() ]+)\", \"\\1 \\2\")\n    -- Remove extra\
    \ spaces within each group\n    groups = ", "  local opening_paren_count = 1\n\
    \  local current_paren_group = ''\n  local current_paren_group_started_by = false\n\
    \  local current_paren_group_is_nested_within_another_group = false\n  local current_paren_group_is_nested_within_a_group\
    \ = false\n  local current_paren_group_is_opened = false\n  local current_paren_group_is_closed\
    \ = false\n  local current_paren_group_is_opened_or_finished = false\n  local\
    \ current_paren_group_is_closed_or_finished = false\n  local current_paren_group_is_nested_within_another_group_or_finished\
    \ = false", "  local open_braces = 0\n  local close_braces = 0\n  local open_paren\
    \ = 0", "    local open_braces = { }\n    local close_braces = { }\n    local\
    \ stack = { paren_string, '' }\n    while stack[1] ~= '' do\n        local current_char\
    \ = stack[1]\n        stack[1] = stack[2]\n        stack[2] = current_char\n \
    \       local unclosed = { }\n        for i = 1, #stack[1] do\n            if\
    \ stack[1][i] == '(' then\n                if not open_braces[#open_braces + 1]\
    \ or open_braces[#open_braces + 1][1] ~= stack[1][i] then\n                  \
    \  table.insert(unclosed, stack[1][i])\n                end\n                table.insert(close_braces,\
    \ stack[1][i])\n            elseif stack[1][i] == ')' then\n                local\
    \ close_brace_to_match = close_braces[#close_braces]\n                table.insert(open_braces,\
    \ stack[1][i])\n                local open_braces_to_match = open_braces[#open_braces]\n\
    \                if open_braces_to_match then\n                    for j = 1,\
    \ #open_braces_to_match do\n                        local open_brace_to_match\
    \ = open_braces_to_match[j]\n                        if open_brace_to_match ~=\
    \ close_brace_to_match then\n                            table.insert(unclosed,\
    \ open_brace_to_match)\n                        end\n                    end\n\
    \                end\n                table.insert(close_braces, stack[1][i])\n\
    \            else\n                table.insert(unclosed, stack[1][i])\n     \
    \       end\n        end\n        stack[1] = unclosed\n        stack[2] = '()'\n\
    \    end\n    return table.concat(open_braces)\nend", "  local paren_string =\
    \ paren_string:gsub('%s+([()]+)', function(s)\n    local open_brace_count = s:match('%[(%)].*')\
    \ -- match string beginning with a left parenthesis or a left curly brace\n  \
    \  if not open_brace_count then\n      open_brace_count = s:match('[^()]+') --\
    \ match string beginning with a letter or number\n    end\n    -- strip brackets,\
    \ count, and match remaining portion\n    return s:gsub('(%[(%)]*)', ''):gsub('(%[)]*)',\
    \ '')\n  end)\n  -- check for and remove nested parens\n  local paren_pairs =\
    \ paren_string:gsub('[(()]+([()]+)', function(s)\n    local open_brace_count =\
    \ s:match('%[(%)].*') -- match string beginning with a left parenthesis or a left\
    \ curly brace\n    if not open_brace_count then\n      open_brace_count = s:match('[^()]+')\
    \ -- match string beginning with a letter or number\n    end\n    -- strip brackets,\
    \ count, and match remaining portion\n    return s:gsub('(%[(%)]*)', ''):gsub('(%[)]*)',\
    \ '')\n  end)\n  -- remove extra paren pairs inside a string (e.g., (((())))\n\
    \  local paren_string = paren_pairs:gsub('%[)]%[()]+([(()]+([(()]+))', '[()]+')\n\
    \  return paren_string:gsub('[()]+', '()')\nend", "  local group_stack = { }\n\
    \  local group_result = { }", "  -- The first open brace will serve as a separator\n\
    \  local open_brace = 1, 1\n  -- The index where we'll store the current group\n\
    \  local group_idx = 0\n  -- The index where we'll store the last character of\
    \ the current group\n  local group_last = 0\n  local group_str = ''\n  for i,\
    \ c in ipairs(paren_string) do\n    -- If the character we're iterating over is\
    \ a closing paren, decrement our counter\n    if c == '(' and open_brace > 0 then\n\
    \      open_brace = open_brace - 1\n    elseif c == '{' then\n      -- If we've\
    \ started a new group, increment our group counter\n      if group_str == '' then\n\
    \        group_idx = group_idx + 1\n      else\n        -- Otherwise, continue\
    \ adding characters into the current group\n        group_last = group_last +\
    \ 1\n        group_str = group_str .. c\n      end\n    elseif c == '}' then\n\
    \      -- If we've finished a group, add a separator and reset our counter\n \
    \     if group_str == '' then\n        group_idx = group_idx + 1\n      else\n\
    \        group_last = group_last + 1\n        group_str = group_str .. c\n   \
    \   end\n      open_brace = open_brace + 1\n    end\n    -- Otherwise, just append\
    \ the current character\n    group_str = group_str .. c\n  end\n  -- Return our\
    \ results\n  return group_str:gsub('%a+', ''):gsub('%c+', ''):gsub('%b+', ''):gsub('%d+',\
    \ ''):gsub('%f+', '')\nend", "  -- Matches the entire string (including the parentheses)\n\
    \  local opening_group_regex = /([^()]+)\\(([^()]+)\\)*/\n  local closed_group_regex\
    \ = /\\(([^()]+)\\)$/", "    local groups = {}\n    local group\n    local open_bracket\n\
    \    local open_brackets_count = 0", "  local num_open = 0\n  local num_closed\
    \ = 0\n  local stack = {}\n  local open_brace = false", '    local paren_groups
    = { }', '    local group_stack = { }', "    local paren_groups = {}\n    local\
    \ paren_string = paren_string:gsub('(%b)(%b)*', function(group_1, group_2)\n \
    \       -- We start a new group when the first open brace is encountered\n   \
    \     paren_groups[#paren_groups + 1] = '' -- Append the new group to the list\
    \ of groups\n        paren_groups[#paren_groups]:insert(group_1) -- Append the\
    \ first open brace to our new group\n        local sub_paren_string = group_2\
    \ -- The current set of paren strings\n        while true do\n            -- We\
    \ search for the next closed paren group\n            local open_paren_group_position\
    \ = 1 -- This is the position that we are currently looking for\n            local\
    \ open_paren_group = nil -- This is the group we are currently looking at\n  \
    \          local open_paren_string = nil -- This is the string we are currently\
    \ looking at\n            for i = 1, #paren_string, 1 do\n                local\
    \ char = paren_string:sub(i,i)\n                if char == ')' then\n        \
    \            if open_paren_group == nil then\n                        open_paren_group\
    \ = paren_groups[open_paren_group_position]\n                    else\n      \
    \                  -- We found a closed paren group, let's check if it is balanced\n\
    \                        open_paren_group_position = open_paren_group_position\
    \ + 1\n                        open_paren_string = open_paren_group\n        \
    \                open_paren_group = nil\n                        if open_paren_group_position\
    \ > #paren_groups + 1 then\n                            -- We are at the end of\
    \ the current set of paren groups and there is not another open paren group\n\
    \                            local error_message = string.format(\"Expected an\
    \ open paren group for group %d. Got %q\", open_paren_group_position, open_paren_string)\n\
    \                            error(error_message)\n                        end\n\
    \                    end\n                elseif char == '(' then\n          \
    \          open_paren_string = open_paren_string .. char\n                   \
    \ open_paren_group = open_paren_string -- Reset the open_paren_group\n       \
    \         end\n            end", '    local groups = {}', "    local tokens =\
    \ {}\n    local depth = 1\n    for token in string.gmatch(paren_string, \"%[(%a+)\"\
    ) do\n        if depth > 1 then\n            table.insert(tokens, token)\n   \
    \     else\n            if token ~= \")\" then\n                table.insert(tokens,\
    \ token)\n            else\n                depth = depth - 1\n            end\n\
    \        end\n    end\n    return tokens\nend", "   local paren_string = string.gsub(paren_string,\
    \ '[()]+', function(a) return a end)\n   local groups = {}\n   local open_brace_index\
    \ = 1\n   local depth = 0\n   for paren_string, paren in string.gmatch(paren_string,\
    \ \"%[(%[(%[)%]]+)\") do\n      local open_brace_count = #paren_string", "   \
    \ local bracket_stack = {}\n    local paren_groups = {}", "  local paren_stack\
    \ = {}\n  local paren_count = 1\n  local paren_group = {}", "    local bracket_stack\
    \ = {}\n    local paren_string = paren_string:gsub('(%b)(%b)(%b)(%b)', function(str)\n\
    \        local bracket_str = str:match('^[%b()]')\n        if bracket_str then\n\
    \            table.insert(bracket_stack, string.format(brackets[bracket_str:sub(1,\
    \ 1)], bracket_str))\n        else\n            table.insert(bracket_stack, str)\n\
    \        end\n        return ''\n    end)\n    local braces_stack = {}\n    local\
    \ braces_string = paren_string:gsub('(%b)(%b)(%b)(%b)', function(str)\n      \
    \  local brace_str = str:match('^[%b{}]()')\n        if brace_str then\n     \
    \       local last_brace = str:sub(brace_str:match('^[%b{}]()') - 1)\n       \
    \     table.insert(braces_stack, brace_str)\n            table.insert(braces_stack,\
    \ last_brace)\n        else\n            table.insert(braces_stack, str)\n   \
    \     end\n        return ''\n    end)\n    if #braces_stack < 2 then\n      \
    \  return bracket_stack\n    end\n    local groups = {}\n    for i = 1, #braces_string\
    \ do\n        local brace = braces_stack[#braces_stack]\n        local paren =\
    \ braces_stack[#braces_stack + 1]\n        if brace == paren then\n          \
    \  table.insert(groups, brace)\n            table.insert(groups, paren)\n    \
    \        table.delete(braces_stack, 1)\n            table.delete(braces_stack,\
    \ 2)\n        elseif brace == paren then\n            table.insert(groups, '')\n\
    \        elseif #brace > #paren then\n            local open_brace = string.format('{%s%s%s}',\
    \ brace, braces_stack[#braces_stack], braces_stack[#braces_stack + 1])\n     \
    \       local close_brace = string.format('%s%s%s}', brace, braces_stack[#braces_stack\
    \ + 2], braces_stack[#braces_stack + 3])\n            table.insert(groups, open_brace)\n\
    \            table.insert(groups, close_brace)\n            table.delete(braces_stack,\
    \ 1)\n            table.delete(braces_stack, 2)\n        else\n            table.insert(groups,\
    \ string.format('{%s%s%s}', brace, braces_stack[#braces_stack], braces_stack[#braces_stack\
    \ + 1]))\n        end\n    end\n    return groups\nend", "   if paren_string:match('%[(%[(%[(%[(%[(%[(%[(%[(%[(%[(%[(%[%[%)]%)]%)]%)]%)]%)]%)]%)]%)%)')\
    \ then\n      -- This handles nested groups of the form ()()(), which would be\
    \ caught by\n      -- string.gsub().  We just need to strip them out when we're\
    \ done\n      paren_string = paren_string:gsub('%[(%[(%[(%[(%[(%[(%[(%[(%[%)]%)]%)]%)]%)]%)]%)]%)%)',\
    \ '')\n      -- Now we know paren_string contains balanced groups of parens.\n\
    \      local bracket_stack = { }\n      local groups = {}\n      for paren in\
    \ pairs(paren_string) do\n         -- If the current char is '(' or '[' or '{',\
    \ then we push a new stack\n         -- and append any char to groups.  If current\
    \ char is ')' or ']' or\n         -- '}', then pop stack and append the popped\
    \ char to groups.  If current\n         -- char is a space, append it to groups.\
    \  If current char is not a\n         -- space, ignore it.\n         if paren\
    \ ~= '' then\n            local bracket = paren:sub(1,1)\n            if bracket\
    \ == '(' or bracket == '[' or bracket == '{' then\n               table.insert(bracket_stack,\
    \ bracket)\n               table.insert(groups, string.sub(paren, 2))\n      \
    \      elseif bracket == ')' or bracket == ']' or bracket == '}' then\n      \
    \         groups[#groups + 1] = string.sub(paren, 2)\n               table.remove(bracket_stack)\n\
    \            elseif paren:sub(1,1) == 's' then\n               groups[#groups\
    \ + 1] = paren\n            end\n         end\n      end\n      return groups\n\
    \   else\n      -- This handles single groups like \"(( ))\"\n      return { string.sub(paren_string,\
    \ 1) }\n   end\nend", "  local open_count = { }\n  local closed_count = { }\n\
    \  local paren_string = paren_string:gsub(\"^%s*\", \"\"):gsub(\"%s*$\", \"\"\
    )\n  local paren_string_len = #paren_string\n  for i = 1, paren_string_len, 1\
    \ do\n    if paren_string[i] == \"(\" then\n      if open_count[paren_string[i]]\
    \ == nil then\n        open_count[paren_string[i]] = 1\n      else\n        open_count[paren_string[i]]\
    \ = open_count[paren_string[i]] + 1\n      end\n    elseif paren_string[i] ==\
    \ \")\" then\n      if closed_count[paren_string[i]] == nil then\n        closed_count[paren_string[i]]\
    \ = 1\n      else\n        closed_count[paren_string[i]] = closed_count[paren_string[i]]\
    \ + 1\n      end\n    end\n  end\n  local groups = { }\n  local paren_groups =\
    \ { }\n  local open_braces = { }\n  for i = 1, paren_string_len, 1 do\n    if\
    \ paren_string[i] == \"(\" then\n      if not open_braces[paren_string[i]] then\n\
    \        paren_groups[#paren_groups + 1] = \"\"\n        open_braces[paren_string[i]]\
    \ = true\n      end\n    elseif paren_string[i] == \")\" then\n      open_braces[paren_string[i]]\
    \ = nil\n      if not open_braces[paren_string[i]] then\n        paren_groups[#paren_groups\
    \ + 1] = \"\"\n      end\n    end\n    local group = paren_groups[#paren_groups\
    \ + 1]\n    if group ~= \"\" then\n      groups[#groups + 1] = group\n    end\n\
    \  end\n  return groups\nend", "\tlocal paren_groups = assert(pcall(require, 'luaparse'),\
    \ 'cannot load luaparse')\n\tlocal token_table = assert(pcall(require, 'lexer.tokens'),\
    \ 'cannot load lexer.tokens')", "  -- Matches any number of consecutive non parenthesis\
    \ characters\n  -- >>> separate_paren_groups('()()')\n  -- ['()()']\n  -- >>>\
    \ separate_paren_groups('()')\n  -- ['()']\n  -- >>> separate_paren_groups(' ()\
    \  ( ) ')\n  -- [' ()  ( ) ']\n  -- >>> separate_paren_groups('( ( ) ( ) ( ))')\n\
    \  -- ['( ( ) ( ) ( ))']\n  -- >>> separate_paren_groups('((( ( ) ( ) ) )))')\n\
    \  -- ['((( ( ) ( ) ) )))']\n  -- >>> separate_paren_groups('( ( ( ) ( ) ) ) )\
    \ ) )')\n  -- ['( ( ( ) ( ) ) ) ) ) ) ']\n  -- >>> separate_paren_groups('( )\
    \ ( ) ( ( ) ( ) ( ) )')\n  -- ['( ) ( ) ( ( ) ( ) ( ) )']\n  -- >>> separate_paren_groups('(\
    \ ( ( ( ( ( ( ( ( ( ( ) ) ( ) ) ) ) ) ) ) ) ) ) ) ) ) ')\n  -- ['( ( ( ( ( ( (\
    \ ( ( ( ( ( ) ) ( ) ) ) ) ) ) ) ) ) ) ) ) ']\n  -- >>> separate_paren_groups('(\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ) ) ) ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ')\n  -- ['( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ) ) ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ']\n  -- >>> separate_paren_groups('(\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ", "\tlocal paren_group_stack\
    \ = {}\n\tlocal paren_group_text = ''\n\tfor c in string.gmatch(paren_string,\
    \ \"%([()]*)(\\\\[\\\\])?\") do\n\t\tlocal paren_group_text = '%s%s' .. paren_group_text\
    \ .. c\n\t\tif c == '(' or c == ')' then\n\t\t\ttable.insert(paren_group_stack,\
    \ paren_group_text)\n\t\t\tparen_group_text = ''\n\t\telseif paren_group_text\
    \ ~= '' then\n\t\t\ttable.insert(paren_group_stack, '%s%s' .. paren_group_text\
    \ .. c)\n\t\t\tparen_group_text = ''\n\t\tend\n\tend\n\tif paren_group_text ~=\
    \ '' then\n\t\ttable.insert(paren_group_stack, paren_group_text)\n\tend\n\treturn\
    \ paren_group_stack\nend", "    local result = {}\n    local depth = 0\n    local\
    \ open_braces_stack = {}\n    local close_braces_stack = {}\n    local paren_stack\
    \ = {}\n    local paren_stack_inverse_map = {}\n    local i = 1\n    while i <=\
    \ #paren_string do\n        local c = paren_string:sub(i, i)\n        if paren_stack[depth]\
    \ == c then\n            paren_stack[depth] = ''\n            paren_stack_inverse_map[c]\
    \ = depth\n            depth += 1\n        elseif paren_stack[depth] == nil then\n\
    \            local brace_found = true\n            -- print('brace not found')\n\
    \            while brace_found and depth ~= #open_braces_stack do\n          \
    \      local current_depth = open_braces_stack[depth]\n                if current_depth\
    \ == c then\n                    local open_brace_depth = open_braces_stack[depth\
    \ + 1]\n                    -- print('open_brace_depth: ' .. open_brace_depth)\n\
    \                    -- print('current_depth: ' .. current_depth)\n          \
    \          if open_braces_stack[open_brace_depth] == c then\n                \
    \        open_braces_stack[open_brace_depth] = ''\n                        paren_stack[open_brace_depth]\
    \ = c\n                        paren_stack_inverse_map[c] = open_brace_depth\n\
    \                        depth = open_brace_depth\n                        brace_found\
    \ = false\n                    else\n                        -- print('closing\
    \ brace not found')\n                        brace_found = false\n           \
    \         end\n                else\n                    local open_brace_depth\
    \ = open_braces_stack[depth + 1]\n                    -- print('open_brace_depth:\
    \ ' .. open_brace_depth)\n                    -- print('current_depth: ' .. current_depth)\n\
    \                    if open_braces_stack[open_brace_depth] == c then\n      \
    \                  open_braces_stack[open_brace_depth] = ''\n                \
    \        paren_stack[open_brace_depth] = c\n                        paren_stack_inverse_map[c]\
    \ = open_brace_depth\n                        depth = open_brace_depth\n     \
    \                   brace_found = false\n                    end\n           \
    \     end\n            end\n            if brace_found then\n                --print('closing\
    \ brace found')\n                paren_stack[depth] = c\n                paren_stack_inverse_map[c]\
    \ = depth\n                depth += 1\n            else\n                -- print('closing\
    \ brace not found')\n                -- print('stack: ' .. table.concat(paren_stack))\n\
    \                --print('paren_stack_in", "   local stack = {}\n   local groups\
    \ = {}\n   local open_braces = {}\n   local depth = 0\n   local depth2 = 0\n \
    \  for idx, char, _, _ in string.gfind(paren_string, '([^()]+)(%S+)', 1, 1, 'c')\
    \ do\n      local current_depth = string.len(char)\n      if char == '(' and open_braces[current_depth]\
    \ == nil then\n         open_braces[current_depth] = true\n      elseif char ==\
    \ ')' and open_braces[current_depth] then\n         open_braces[current_depth]\
    \ = nil\n         depth = depth - 1\n         if depth > 0 then\n            depth2\
    \ = depth2 - 1\n         end\n      elseif open_braces[current_depth] == nil then\n\
    \         depth = depth + 1\n      else\n         open_braces[current_depth] =\
    \ nil\n      end\n      table.insert(groups, char)\n   end\n   return groups\n\
    end", "  return string.gmatch(paren_string, \"%[(%a)(%a)*]\") or {error = \"Malformed\
    \ input\"}\nend", "    local group_stack = {}\n    local new_paren_string = paren_string\n\
    \    while #new_paren_string > 0 do\n        if new_paren_string[1] == '(' then\n\
    \            table.insert(group_stack, new_paren_string)\n            new_paren_string\
    \ = new_paren_string[#new_paren_string]\n        else\n            local current_group\
    \ = group_stack[#group_stack]\n            table.insert(current_group, new_paren_string)\n\
    \            new_paren_string = new_paren_string[#new_paren_string]\n        end\n\
    \    end\n    return group_stack\nend", "  -- For now, assume each paren is in\
    \ its own group\n  -- This needs to be changed to account for multiple groups\
    \ within a paren. \n  local in_group = 0\n  local paren_groups = { '', '' } --\
    \ to keep track of open paren groups\n  local open_brace = 1\n  local open_curly\
    \ = 1\n  local close_brace = 1\n  local close_curly = 1\n  local brace_string\
    \ = string.gsub(paren_string, \"[{}()]|\", \"\")\n  local level = 0\n  local in_brace\
    \ = 1", "  local groups = {}\n  for s in string.gmatch(paren_string, '()([^()]*)(%s)')\
    \ do\n    if s[1] then\n      local _, closed, _ = unpack(s..3)\n      local opening_braces_count\
    \ = 0\n      for _, brace in pairs(closed) do\n        if brace == '}' then\n\
    \          opening_braces_count = opening_braces_count - 1\n        elseif braces[brace]\
    \ then\n          opening_braces_count = opening_braces_count + 1\n        end\n\
    \      end\n      if opening_braces_count == 0 then\n        groups[#groups +\
    \ 1] = s..(#closed + 1)\n      end\n    end\n  end\n  return groups\nend", " \
    \   local groups = {}\n    local open_bracket = false\n    local current_group_opening\n\
    \    local paren_count = 0\n    for index, character in ipairs(paren_string) do\n\
    \        if character == \"(\" then\n            if current_group_opening then\n\
    \                groups[#groups+1] = current_group_opening\n                current_group_opening\
    \ = nil\n                paren_count = 0\n            end\n            current_group_opening\
    \ = character\n            paren_count = paren_count + 1\n        elseif character\
    \ == \")\" then\n            if paren_count == 0 then\n                assert(current_group_opening\
    \ and current_group_opening = character)\n            end\n            assert(current_group_opening)\n\
    \            current_group_opening = nil\n            paren_count = paren_count\
    \ - 1\n        elseif paren_count > 0 then\n            current_group_opening\
    \ = nil\n            paren_count = 0\n        end\n    end\n    if current_group_opening\
    \ then\n        groups[#groups+1] = current_group_opening\n    end\n    return\
    \ groups\nend", "   local pos = 0\n   local paren_groups = {}\n   local open_braces\
    \ = false\n   local last_closing_brace = nil\n   local current_open_brace", " \
    \ local open_braces = nil\n  local close_braces = nil\n  local brace_pairs = {}",
  "  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('( )',\
    \ ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local paren_string = paren_string:gsub('( )', ')'):gsub('( )', ')'):gsub('(\
    \ )', ')')\n  local ", '    local result = {}', "    local paren_groups = {}\n\
    \    local brace_count = 0\n    for paren in string.gmatch(paren_string, \"%[(%a%[(%a)]+)\"\
    ) and paren:gsub(\"[()]\", string.char) do\n        if paren == \"(\" then\n \
    \           brace_count = brace_count + 1\n        elseif paren == \")\" then\n\
    \            if brace_count > 0 then\n                brace_count = brace_count\
    \ - 1\n            else\n                table.insert(paren_groups, paren)\n \
    \           end\n        end\n    end\n    return paren_groups\nend", "   -- Create\
    \ a table to store the result\n   local ret = {}\n   local open_brace_stack =\
    \ {}\n   local next_group_opening = false", "    local parens = { }\n    local\
    \ paren_depth = 1\n    local last_char = ''\n    local index = 1\n    while index\
    \ <= #paren_string do\n        if paren_string:sub(1, index) == '(' then\n   \
    \         paren_depth = paren_depth + 1\n        end\n        if paren_string:sub(1,\
    \ index) == ')' then\n            paren_depth = paren_depth - 1\n        end\n\
    \        if paren_depth == 0 then\n            local char = paren_string:sub(1,\
    \ index)\n            table.insert(parens, char)\n        end\n        index =\
    \ index + 1\n    end\n    return parens\nend", "    local open_brace_counts =\
    \ {\n        ['('] = 1,\n        [')'] = 1\n    }\n    local groups = {\n    \
    \    -- Keep track of the last opened paren so we can close it properly\n    \
    \    last_open_paren = nil\n    }\n    for index, letter in ipairs(paren_string)\
    \ do\n        -- If this letter was an opening brace, decrement the count\n  \
    \      if open_brace_counts[letter] ~= nil then\n            open_brace_counts[letter]\
    \ = open_brace_counts[letter] - 1\n        end\n        -- If this letter was\
    \ a closing brace, increase the count\n        if open_brace_counts[letter] ==\
    \ 0 then\n            -- If this is the first letter inside the group, create\
    \ it\n            if last_open_paren == nil then\n                last_open_paren\
    \ = letter\n            else\n                -- Otherwise, close the last group\n\
    \                groups[#groups+1] = last_open_paren\n            end\n      \
    \      -- Set the new letter as the last opened paren\n            last_open_paren\
    \ = letter\n        end\n    end\n    -- Add the last group if there is one\n\
    \    if last_open_paren ~= nil then\n        groups[#groups+1] = last_open_paren\n\
    \    end\n    return groups\nend", "    local tokens = {}\n    local stack = {paren_string}\n\
    \    local open_braces = 0\n    local closed_braces = 0\n    local depth = 0\n\
    \    while #stack > 0 do\n        local depth = #stack\n        if depth ~= #stack\
    \ then\n            for i = 1, depth do\n                if stack[i] ~= '(' then\
    \ return nil end\n                closed_braces = closed_braces + 1\n        \
    \        stack[depth] = stack[i]\n            end\n        end\n        open_braces\
    \ = open_braces + 1\n        local token_string = stack[#stack + 1]\n        if\
    \ token_string:find(')')\n        then\n            stack[#stack + 1] = token_string\n\
    \            return tokens\n        end\n        stack[#stack + 1] = token_string..'()'\n\
    \        stack[#stack + 1] = token_string..'('..')'\n        stack[#stack + 1]\
    \ = token_string..'(..)'\n        stack[#stack + 1] = token_string..'(...)'\n\
    \    end\n    return nil\nend", "    local open_braces = nil\n    local open_groups\
    \ = nil\n    local in_string = false\n    local strings = ''", "   local groups\
    \ = {}\n   for _,c in ipairs(paren_string) do\n      if c == '(' or c == '[' then\n\
    \         table.insert(groups,'(')\n         table.insert(groups, c)\n      elseif\
    \ c == ')' or c == ']' then\n         if #groups == 0 then\n            table.insert(groups,c)\n\
    \         else\n            table.insert(groups, c)\n         end\n      else\n\
    \         table.insert(groups, c)\n      end\n   end\n   return groups\nend",
  "   local parsed_paren_group = nil\n   local paren_group = {}\n   local open_paren_count\
    \ = 0\n   local close_paren_count = 0", "   local parens = { }\n   local depth\
    \ = 0\n   local paren_count = 0\n   local open_brackets = false", "    local paren_groups\
    \ = {}\n    local open_paren_count = 0\n    for paren_string in gsub('()', '()()',\
    \ paren_string) do\n        local new_open_paren_count = open_paren_count + 1\n\
    \        if paren_string == '(' then\n            paren_groups[#paren_groups+1]\
    \ = paren_string\n        elseif paren_string == ')' then\n            paren_groups[#paren_groups+1]\
    \ = '(' .. paren_groups[#paren_groups] .. ')'\n            open_paren_count =\
    \ open_paren_count - 1\n        end\n    end\n    return paren_groups\nend", " \
    \ local open_groups = {}\n  local closed_groups = {}", "    local paren_groups\
    \ = {}\n    local paren_counter = 1", "  -- Reset the starting index so we don't\
    \ iterate past the first set of parentheses.\n  local index = 1\n  -- Iterate\
    \ over the string and build up a list of the separate parenthetical groups.\n\
    \  local paren_groups = {}\n  while index <= #paren_string do\n    if paren_string[index]\
    \ == '(' then\n      -- If we've reached the end of the parentheses, add it to\
    \ the output list and remove it from the string.\n      paren_groups[#paren_groups\
    \ + 1] = paren_string[index]:sub(1, index - 1)\n      paren_string = paren_string:sub((index\
    \ + 1))\n      index = index + 1\n    elseif paren_string[index] == ')' then\n\
    \      -- Otherwise, if the closing parenthesis is at the end of the string, add\
    \ it to the output list and remove it from the string.\n      paren_groups[#paren_groups\
    \ + 1] = paren_string[index]:sub(1, index)\n      paren_string = paren_string:sub((index\
    \ + 1))\n      index = index + 1\n    end\n  end\n  return paren_groups\nend",
  "  local paren_groups = { }\n  local i = 0\n  local paren_count = 0\n  local j =\
    \ 1\n  local open_parens = 0", "    local open_parentheses = string.gsub(paren_string,\
    \ \"[(%)]\", \"\")\n    local unmatched_open_parentheses = string.gsub(open_parentheses,\
    \ \".\", \" \")\n    local open_parentheses_count = string.gsub(open_parentheses,\
    \ \"[()%]\", \"\")\n    return unmatched_open_parentheses:gsub(\"%-\", \"\")\n\
    end", "\t-- the stack stores all paren groups\n\tlocal stack = {}\n\t-- the current\
    \ paren group\n\tlocal curr = {}\n\t-- the index into our paren group list of\
    \ the current paren\n\tlocal idx = 0", "    local output_list = { }\n    local\
    \ group_stack = { }\n    local open_brace_count = { }\n    local closed_brace_count\
    \ = 0\n    local current_char", "  local open_braces = '()'\n  local closed_braces\
    \ = '()'\n  local paren_count = 0\n  local open_paren = 0\n  local open_brace_count\
    \ = 0\n  local close_brace_count = 0\n  local paren_string = paren_string:gsub(\"\
    [%(\" .. open_braces .. closed_braces .. \"):]\", \"%%s%1\")\n  local open_brace_list\
    \ = {}\n  local close_brace_list = {}\n  local paren_string = paren_string:gsub(\"\
    [%(\" .. open_braces .. closed_braces .. \")]\", \"%%s%1\")\n  for index, value\
    \ in pairs(paren_string) do\n    if open_braces:sub(1, 1) == '(' then\n      open_paren\
    \ = open_paren + 1\n      open_brace_count = open_brace_count + 1\n      open_brace_list[open_brace_count]\
    \ = value\n    elseif open_braces:sub(1, 1) == ')' then\n      close_brace_count\
    \ = close_brace_count + 1\n      close_brace_list[close_brace_count] = value\n\
    \      open_paren = open_paren - 1\n    elseif closed_braces:sub(1, 1) == '('\
    \ then\n      close_brace_count = close_brace_count + 1\n      close_brace_list[close_brace_count]\
    \ = value\n    else\n      open_brace_count = open_brace_count + 1\n      open_brace_list[open_brace_count]\
    \ = value\n    end\n  end\n  return open_brace_list, close_brace_list\nend", " \
    \ local groups = {}\n  local open_braces = false\n  local paren_count = 1\n  for\
    \ i = 1, #paren_string, 1 do\n    local c = paren_string[i]\n    if open_braces\
    \ and c == \"(\" then\n      paren_count = paren_count + 1\n    elseif c == \"\
    (\" then\n      paren_count = paren_count - 1\n      open_braces = not open_braces\n\
    \    elseif c == \")\" then\n      if paren_count == 0 then\n        groups[#groups+1]\
    \ = paren_string[i]\n      else\n        paren_count = paren_count + 1\n     \
    \ end\n      open_braces = not open_braces\n    end\n  end\n  return groups\n\
    end", "   paren_string = string.gsub(paren_string, \"{%d+}\", \"()\")\n   return\
    \ string.gsub(paren_string, \"{%w+}\")\nend", "  local results = {}\n  local open_brace\
    \ = 1\n  local closed_count = 0", "  local open_brace_count = 0\n  local open_groups\
    \ = {}\n  local current_group = {} -- Group is represented by a string\n  local\
    \ current_open_brace = 0 -- Tracks number of open braces encountered\n  local\
    \ open_brace_pair = { }\n  local open_brace_pair_length = 1 -- Tracks length of\
    \ open brace pair\n  local close_brace_pair = { }\n  local close_brace_pair_length\
    \ = 1 -- Tracks length of close brace pair", "\tlocal open_braces = { }\n\tlocal\
    \ open_parens = { }\n\tlocal close_braces = { }\n\tlocal close_parens = { }\n\t\
    local groups = { }\n\tlocal depth = 0\n\tlocal open_brace_pos = 0", "  local function\
    \ skip_whitespace(str, start)\n    while start < #str do\n      local ch = str:sub(start,\
    \ start)\n      if ch == '(' then return start end\n      if ch == ')' then return\
    \ start + 1 end\n      start = start + 1\n    end\n  end", "   local open_braces\
    \ = {}\n   local open_brace_depth = 0\n   local paren_string = paren_string:gsub('%[(%[(%[%[(%[(%[%[(%[%[%[(%[%[',\
    \ '()')\n   local index = 1\n   local cur_depth = 1\n   local start\n   local\
    \ paren_string = paren_string:gsub('[%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%]%",
  "  local bracket_count = 0\n  local output_buffer = {}\n  local open_brackets =\
    \ -1\n  local close_brackets = 0\n  for s in string.gmatch(paren_string, '%([()]*)(%[(][^)]*)+')\
    \ do\n    if open_brackets == -1 then\n      if #s > 0 then open_brackets = 1\
    \ end\n      close_brackets = 0\n    end", "    local paren_stack = {}\n    local\
    \ groups = {}\n    for paren in paren_string:gmatch(\"%[(%a)]+\") do\n       \
    \ if paren_stack[#paren_stack+1] ~= 0 then\n            table.insert(groups, paren_stack[#paren_stack])\n\
    \        end\n        table.insert(paren_stack, paren)\n    end\n    table.insert(groups,\
    \ nil)\n    return groups\nend", "    local paren_groups, paren_string = paren_string:gsub('([{}])([^{}]*)(%1)',\
    \ function(s) return ' [' .. s .. ']%2' end, 3)\n    -- Remove unnecessary paren\
    \ groups that are not at the ends\n    return paren_groups:gsub('%2$', '')\nend",
  "  -- First, split the string on spaces to get an array of strings that describe\
    \ the groups\n  -- in the parens. For example, the first group would be ['(',\
    \ ')', '(', ')']. The first\n  -- group of parens would have one extra parens\
    \ in it because it isn't closed. So we\n  -- want to remove the last paren from\
    \ the last group (the one that doesn't have a closing\n  -- paren)\n  local parens\
    \ = paren_string:gsub('([^()]+)', ' ')", "  local pos = 1\n  local groups = {}\n\
    \  local group = ''\n  while true do\n    if paren_string:sub(pos, pos) ~= '('\
    \ then\n      group = group .. paren_string:sub(pos, pos)\n      pos = pos + 1\n\
    \    else\n      groups[#groups + 1] = group\n      pos = pos + 1\n      if paren_string:sub(pos,\
    \ pos) == ')' then\n        group = group .. ')'\n        pos = pos + 1\n    \
    \  end\n      if paren_string:sub(pos, pos) == '(' then\n        group = group\
    \ .. '('\n        pos = pos + 1\n      end\n    end\n    if paren_string:sub(pos,\
    \ pos) ~= ')' then\n      group = group .. paren_string:sub(pos, pos)\n    end\n\
    \  end\n  if #groups ~= 0 then\n    groups[#groups + 1] = group\n  end\n  return\
    \ groups\nend", '    local paren_groups = { }', "  local paren_groups = {}\n \
    \ local open_braces = false\n  local inside_group = 0\n  for i, character in pairs(paren_string)\
    \ do\n    if character == open_braces then\n      inside_group = inside_group\
    \ - 1\n    elseif character == ')' then\n      if not open_braces then\n     \
    \   -- We encountered a closing brace without an opening one, so this wasn't an\
    \ actual group. Ignore it.\n      elseif not inside_group then\n        paren_groups[i]\
    \ = '()'\n      else\n        paren_groups[i] = paren_groups[i]:sub(1, i - 1)\n\
    \      end\n      paren_groups[i] = paren_groups[i]:sub(1, i)\n      open_braces\
    \ = false\n    elseif character == '(' then\n      open_braces = true\n      inside_group\
    \ = inside_group + 1\n    end\n  end\n  return paren_groups\nend", "    local\
    \ open_brace_stack = {}\n    local brace_count = 0\n    local current_group =\
    \ ''", "    local groups = {}\n    local open_braces = 1\n    local open_parentheses\
    \ = 1\n    local paren_level = 0\n    for paren in string.gmatch(paren_string,\
    \ \"%[(%w+)\")\n        do\n            if paren == \"(\" then\n             \
    \   if open_parentheses == 0 then\n                    groups[#groups+1] = paren\n\
    \                    open_parentheses = open_parentheses+1\n                else\n\
    \                    open_parentheses = open_parentheses+1\n                end\n\
    \            elseif paren == \")\" then\n                if open_braces == 0 then\n\
    \                    groups[#groups+1] = paren\n                else\n       \
    \             open_braces = open_braces-1\n                end\n            elseif\
    \ paren == \"(\" and open_braces > 0 then\n                open_braces = open_braces-1\n\
    \            elseif paren == \")\" and open_parentheses > 0 then\n           \
    \     open_parentheses = open_parentheses-1\n            end\n        end\n  \
    \  return groups\nend", "    local paren_groups = {} -- To collect all groups\
    \ that are separated in parenthesis\n    local paren_nesting = -1 -- To track\
    \ parenthesis nesting\n    local current_open_brace = 1 -- Tracks the number of\
    \ open braces found so far\n    local current_closed_brace = 0 -- Tracks the number\
    \ of closed braces found so far", "    local paren_list = {}\n    local paren_index\
    \ = 1\n    local open_braces\n    local paren_count = 0\n    local is_first_open_brace\
    \ = true\n    local is_last_open_brace = false\n    local is_last_close_brace\
    \ = false\n    local paren_string = paren_string:gsub('( )', function(str)\n \
    \       paren_count = paren_count + 1\n        if paren_count == 1 and not is_last_close_brace\
    \ then\n            open_braces = paren_string:sub(1, paren_index-1)\n       \
    \     is_first_open_brace = is_first_open_brace or open_braces:sub(1, 1) == \"\
    (\"\n            is_last_close_brace = is_last_close_brace or open_braces:sub(1,\
    \ 1) == \")\"\n            paren_index = paren_index + 1\n        end\n      \
    \  if paren_count == 1 then\n            paren_list[paren_list#] = open_braces\n\
    \        end\n        return str\n    end)\n    paren_list[paren_list#] = paren_string\n\
    \    return paren_list\nend", "  local open_braces = false\n  local open_brace_counter\
    \ = 1\n  local open_brace_stack = {}\n  local closing_paren_groups = {}\n  local\
    \ closing_paren_group_stack = {}\n  local groups_to_return = {}\n  local group_counter\
    \ = 0\n  local group_start = 1\n  local group_end = 1\n  for i = 1, #paren_string,\
    \ 1 do\n    local c = paren_string[i]\n    local paren_count = 0\n    if (c ==\
    \ '(') then\n      paren_count = paren_count + 1\n    elseif (c == '{') then\n\
    \      paren_count = paren_count + 1\n    end\n    if (paren_count == open_brace_counter)\
    \ then\n      open_brace_stack[open_braces] = c\n      open_brace_stack[open_braces]\
    \ = true\n      open_braces = open_braces + 1\n      open_brace_counter = open_brace_counter\
    \ + 1\n    elseif (open_braces > 0) then\n      if (c == '(') then\n        open_brace_counter\
    \ = open_brace_counter + 1\n      elseif (c == '{') then\n        open_brace_counter\
    \ = open_brace_counter + 1\n      elseif (c == '}') then\n        open_brace_counter\
    \ = open_brace_counter - 1\n        open_brace_stack[open_braces] = c\n      \
    \  open_brace_stack[open_braces] = false\n        open_braces = open_braces -\
    \ 1\n      end\n    end\n    if open_braces > 0 then\n      if (c == '}') then\n\
    \        closing_paren_groups[group_end - 1] = true\n        closing_paren_group_stack[group_end\
    \ - 1] = group_end - 1\n        open_brace_counter = open_brace_counter - 1\n\
    \      elseif (c == '(') then\n        closing_paren_groups[group_end - 1] = true\n\
    \        closing_paren_group_stack[group_end - 1] = group_end - 1\n      end\n\
    \    elseif (c == '}') then\n      closing_paren_groups[group_end - 1] = true\n\
    \      closing_paren_group_stack[group_end - 1] = group_end - 1\n      group_end\
    \ = group_end - 1\n      closing_paren_group_stack[group_end] = false\n    end\n\
    \    if (c == '(') then\n      groups_to_return[group_start] = true\n      group_start\
    \ = group_start + 1\n      group_end = group_end + 1\n    end\n  end\n  for i\
    \ = 1, #groups_to_return, 1 do\n    if (groups_to_", "  local group_strings =\
    \ {}\n  local i = 1\n  while true do\n    local new_group_string = paren_string:sub(1,\
    \ paren_string:len() - i)\n    i = paren_string:len() - i\n    local group_string\
    \ = paren_string:sub(1, i)\n    -- If there is a closing brace, add it to the\
    \ new group and remove it from the string\n    if group_string:find('}') then\n\
    \      new_group_string = '(' .. new_group_string .. ')'\n      paren_string =\
    \ paren_string:sub(i + 1)\n    end\n    -- Add a new group string\n    group_strings[i]\
    \ = new_group_string\n    -- If all closing braces have been added, return the\
    \ group_strings\n    if paren_string:len() == i then\n      return group_strings\n\
    \    end\n  end\nend", "    local groups = {}\n    local paren_count = 0\n   \
    \ for i = 1, #paren_string, 1 do\n        if paren_string[i] == '(' or paren_string[i]\
    \ == '{' then\n            paren_count = paren_count + 1\n        elseif paren_string[i]\
    \ == ')' or paren_string[i] == '}' then\n            paren_count = paren_count\
    \ - 1\n            if paren_count < 0 then\n                table.insert(groups,\
    \ table.concat(paren_string[1 .. i], ''))\n                table.insert(groups,\
    \ '')\n                break\n            end\n        end\n    end\n    return\
    \ groups\nend", "  local results = {}\n  for _, parens in ipairs(string.gmatch(paren_string,\
    \ \"%[(%[(%[(%[(%[(%[(%[(\")) do -- for all open parens\n    -- Split parens into\
    \ two groups, with the exception of nested parens\n    if parens:find(\"%[(%[(%[(%[(%[(%[(\"\
    ) ~= nil then\n      local open_parens = parens:gsub(\"%[(%[(%[(%[(%[(%[(\", \"\
    \")\n      local close_parens = open_parens:gsub(\"%[)]]%)%)]]%)]]%)]]%)]]%)]]%\"\
    , \")\")\n      local open_groups = open_parens:gsub(\"%{2,}\", \"\"):gsub(\"\
    %)%\", \"\"):gsub(\"%]%\", \"\")\n      if open_groups:len() > 1 then\n      \
    \  -- There is an unbalanced set of parens.\n        -- This means there will\
    \ be an extra closing paren somewhere\n        -- Add this set of parens to the\
    \ result and move on\n        results:insert(open_groups)\n      else\n      \
    \  -- There is not an unbalanced set of parens, add a closing paren\n        results:insert(close_parens)\n\
    \      end\n    else\n      results:insert(parens)\n    end\n  end", "  local\
    \ open_brace_positions = { }\n  local open_braces = { }\n  local close_braces\
    \ = { }\n  local index = 1\n  local current_paren = 0\n  local current_group\n\
    \  local open_braces\n  local close_braces\n  local group_string\n  local new_paren_group\n\
    \  local paren_string\n  local i", "  if string.find(paren_string, '%') % 1 then\n\
    \    return {}\n  end\n  local open_curlies_count = -1\n  local open_parantheses_count\
    \ = -1\n  local current_group = ''\n  local current_paranthesis_group\n  local\
    \ is_opening = true\n  local is_closing = false\n  local paren_groups = {}\n \
    \ for i = 1, #paren_string do\n    if paren_string[i] == '(' then\n      if is_opening\
    \ then\n        open_curlies_count = open_curlies_count + 1\n      else\n    \
    \    open_parantheses_count = open_parantheses_count + 1\n      end\n    elseif\
    \ paren_string[i] == ')' then\n      if is_opening then\n        if open_curlies_count\
    \ == 0 then\n          open_parantheses_count = open_parantheses_count - 1\n \
    \         paren_groups[#paren_groups+1] = current_group\n          current_group\
    \ = ''\n        else\n          open_curlies_count = open_curlies_count - 1\n\
    \        end\n      elseif open_parantheses_count == 0 then\n        open_curlies_count\
    \ = open_curlies_count - 1\n        paren_groups[#paren_groups+1] = current_group\n\
    \        current_group = ''\n      else\n        open_parantheses_count = open_parantheses_count\
    \ - 1\n      end\n    elseif paren_string[i] == '{' then\n      if is_opening\
    \ then\n        open_curlies_count = open_curlies_count + 1\n      else\n    \
    \    open_parantheses_count = open_parantheses_count + 1\n      end\n    elseif\
    \ paren_string[i] == '}' then\n      if is_opening then\n        if open_curlies_count\
    \ == 0 then\n          open_parantheses_count = open_parantheses_count - 1\n \
    \         current_paranthesis_group = current_group\n          current_group =\
    \ ''\n        else\n          open_curlies_count = open_curlies_count - 1\n  \
    \      end\n      elseif open_parantheses_count == 0 then\n        open_curlies_count\
    \ = open_curlies_count - 1\n        current_paranthesis_group = current_group\n\
    \        current_group = ''\n      else\n        open_parantheses_count = open_parantheses_count\
    \ - 1\n      end\n    elseif paren_string[i] == ' ' then\n      if is_opening\
    \ then\n        current_group = current_group .. paren_string[i]\n      else\n\
    \        current_paranthesis_group = current_paranthesis_group .. paren_string[i]\n\
    \      end\n    end\n  end\n  if open_curlies_count % 1 == 0 then\n    open_curlies_count\
    \ = open_cur", "    local open_group = 1\n    local closed_group = 1\n    local\
    \ current_group = {}\n    local groups = {}\n    local char\n    for char in (paren_string:gsub('()',\
    \ '\\\\2')):gmatch('%S+') do\n        -- If the last open brace is closed, we\
    \ open a new one\n        if opened_group == closed_group then\n            open_group\
    \ = open_group + 1\n            closed_group = open_group\n            current_group[open_group]\
    \ = char\n        else\n            -- Append the characer to the current group\n\
    \            current_group[closed_group] = char\n            -- If the last closed\
    \ brace is opened, then close it\n            if opened_group == open_group then\n\
    \                closed_group = closed_group + 1\n            else\n         \
    \       -- Otherwise, just keep the current group and add it to the list\n   \
    \             groups[#groups + 1] = current_group\n                opened_group\
    \ = open_group\n                current_group = {}\n                closed_group\
    \ = open_group\n            end\n        end\n    end\n    groups[#groups + 1]\
    \ = current_group\n    return groups\nend", "  -- Initialize a list to store all\
    \ the separated strings\n  local string_groups = {} -- Initialize a list to store\
    \ all the separated strings", "  local paren_groups = {} -- store groups of parentheses\n\
    \  local paren_string = paren_string -- make local copy to not mess with global\
    \ one\n  -- find first un-paired parenthesis\n  local paren_position = #paren_string\
    \ - 1\n  while paren_position > 0 do\n    -- check if parenthesis is balanced\n\
    \    if paren_string[paren_position] ~= '(' or paren_string[paren_position + 1]\
    \ ~= ')' then\n      paren_string = paren_string:sub(1, paren_position + 1) --\
    \ get rid of unpaired parenthesis\n      break\n    else\n      -- get rid of\
    \ un-paired parenthesis\n      paren_string = paren_string:sub(1, paren_position)\n\
    \      -- check if we found a balanced group\n      if paren_string[#paren_string]\
    \ ~= '(' then\n        -- if not, set paren group to an empty string\n       \
    \ paren_groups[#paren_groups + 1] = paren_string\n        paren_string = \"\"\n\
    \      else\n        -- if not set paren group to empty string\n        paren_groups[#paren_groups\
    \ + 1] = paren_string\n      end\n      -- get rid of un-paired parenthesis\n\
    \      paren_position = paren_position - 1\n    end\n  end\n  -- add last group\
    \ if it exists\n  if paren_string ~= \"\" then\n    paren_groups[#paren_groups]\
    \ = paren_string\n  end\n  return paren_groups\nend", "    local function split_by_whitespace(string)\n\
    \        local result = {}\n        for i = 1, #string do\n            local character\
    \ = string[i]\n            local position = string.find(paren_string, character)\n\
    \            while position ~= nil do\n                table.insert(result, string.sub(string,\
    \ 1, position))\n                string = string.sub(string, position + 1)\n \
    \               position = string.find(paren_string, character)\n            end\n\
    \        end\n        return result\n    end\n    local function count_open_braces(string)\n\
    \        local open_count = 0\n        for i = 1, #string do\n            if string[i]\
    \ == '(' and open_count == 0 then\n                open_count = open_count + 1\n\
    \            elseif string[i] == ')' and open_count > 0 then\n               \
    \ open_count = open_count - 1\n            end\n        end\n        return open_count\n\
    \    end\n    local function separate_string(string)\n        local separated_strings\
    \ = {}\n        for i = 1, #string do\n            local open_count = count_open_braces(string[i])\n\
    \            if open_count == 0 then\n                table.insert(separated_strings,\
    \ string[i])\n            elseif open_count == 1 then\n                table.insert(separated_strings,\
    \ string[i])\n                table.insert(separated_strings, string[i + 1]) --\
    \ append a second element of string[i + 1] to the current string[i]\n        \
    \    else\n                table.insert(separated_strings, string[i])\n      \
    \          table.insert(separated_strings, string[i + 1]) -- append a second element\
    \ of string[i + 1] to the current string[i]\n                table.insert(separated_strings,\
    \ string[i + 1]) -- append a second element of string[i + 1] to the current string[i]\n\
    \            end\n        end\n        return separated_strings\n    end\n   \
    \ local function close_paren(string)\n        local close_paren_count = 0\n  \
    \      for i = 1, #string do\n            if string[i] == '(' and close_paren_count\
    \ == 0 then\n                close_paren_count = close_paren_count + 1\n     \
    \       elseif string[i] == ')' and close_paren_count > 0 then\n             \
    \   close_paren_count = close_paren_count - 1\n            end\n        end\n\
    \        return close_paren_count\n    end\n    local function get_parens(string)\n\
    \        local separated_strings = separate_string(string)\n        local paren_string\
    \ = ''\n        for i = 1, #separated_strings do\n            if separated_strings[i]\
    \ == '(' then\n                table.insert(paren_string, separated_strings[i])\n\
    \            elseif separated_strings[i] == ')' then\n                table.insert(paren_string,\
    \ separated_strings[i])\n                table.insert(paren_string, separated_strings[i\
    \ + 1]) -- append a second element of string[i + 1] to the current string[i]\n\
    \            end\n        end\n        return paren_string\n    end\n    local\
    \ function ", "  local function extract_paren_groups(s)\n    local opening_braces\
    \ = { }\n    local closing_braces = { }\n    local opening_paren = 0\n    local\
    \ closing_paren = 0", "    local paren_count = 0\n    local paren_strings = {\
    \ }\n    for paren_start in string.gmatch(paren_string, '%%(%[(%[(%[(%[(%[((%[(%[(%[((%[(%[(%[(%[(%[(%[)%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%[)]%",
  "    local paren_groups = {} -- A list of each individual group\n    local paren_count\
    \ = 0 -- A running counter to keep track of how many open parens there are\n \
    \   local open_braces = 0 -- A running counter to keep track of how many braces\
    \ there are\n    for paren in string.gmatch(paren_string, \"[%z()()]+\") do\n\
    \        if paren == '(' then\n            paren_count = paren_count+1\n     \
    \   elseif paren == ')' then\n            paren_count = paren_count-1\n      \
    \  elseif paren == '{' then\n            open_braces = open_braces+1\n       \
    \ elseif paren == '}' then\n            open_braces = open_braces-1\n        elseif\
    \ paren == '{' and open_braces > 0 then\n            paren_groups[#paren_groups+1]\
    \ = paren\n            open_braces = open_braces-1\n        elseif paren == '}'\
    \ and open_braces == 0 then\n            paren_groups[#paren_groups+1] = paren\n\
    \        else\n            paren_groups[#paren_groups+1] = paren\n        end\n\
    \    end\n    return paren_groups\nend", "    local paren_groups = terralib.newlist()\n\
    \    local open_brace = -1\n    local close_brace = -1\n    for i = 1, #paren_string,\
    \ 1 do\n        if paren_string[i] ~= ' ' then\n            paren_groups:insert(paren_string[i])\n\
    \        else\n            if open_brace == -1 then\n                open_brace\
    \ = i\n            else\n                close_brace = i\n            end\n  \
    \      end\n    end", "    local groups = {}\n    local i = 0", "   local open_braces\
    \  = {}\n   local close_braces = {}\n   local strings = {}", "  -- Remove empty\
    \ groups\n  paren_string = paren_string:gsub('()', '')\n  local paren_groups =\
    \ {}\n  local open_groups = 1\n  local current_group = ''\n  local open_parens\
    \ = 1\n  for i = 1, #paren_string, 1 do\n    local char = paren_string[i]\n  \
    \  local is_open = open_parens > 0 and char == ')'\n    if is_open then\n    \
    \  open_parens = open_parens - 1\n    elseif open_parens > 0 then\n      current_group\
    \ = current_group .. char\n    elseif open_parens == 0 and char == '(' then\n\
    \      open_parens = open_parens + 1\n      if current_group ~= '' then\n    \
    \    paren_groups[#paren_groups+1] = current_group\n      end\n      current_group\
    \ = ''\n    else\n      current_group = current_group .. char\n    end\n  end\n\
    \  if current_group ~= '' then\n    paren_groups[#paren_groups+1] = current_group\n\
    \  end\n  return paren_groups\nend", "  local index = 1\n  local strings = {}\n\
    \  local open_brace_count = 0\n  while true do\n    local char = paren_string:sub(1,\
    \ index)\n    index = index + 1", "  local pattern = '%(%(%[(%{%{%([%())%([%)))%)%)]%})%)%([%([%{%{%([%)))%)%)]%})%([%[%{%{%([%)))%)%)]%})%([%{%{%[%([%)))%)%)]%})%'\n\
    \  return string.gsub(paren_string, pattern, '%1')\nend", "\tlocal result_list\
    \ = { }\n\tlocal pos = 1\n\tlocal opening_chars_count = 1\n\tlocal opening_brace_count\
    \ = 0\n\tlocal opening_paren_count = 1\n\tlocal paren_level = 0\n\tlocal opening_brace_character\
    \ = '{'\n\tlocal opening_paren_character = '('\n\tlocal opening_characters = {\n\
    \t\topening_paren_character,\n\t\topening_brace_character,\n\t}\n\tlocal closing_brace_characters\
    \ = {\n\t\topening_paren_character,\n\t\topening_brace_character,\n\t}", "   \
    \ local groups = {}\n    local in_paren = false\n    local in_group = false\n\
    \    for i, c in ipairs(paren_string) do\n        if c == '(' and not in_paren\
    \ then\n            in_paren = true\n            in_group = false\n          \
    \  table.insert(groups, c)\n        elseif c == ')' and not in_paren then\n  \
    \          if in_group then\n                table.insert(groups, string.sub(paren_string,\
    \ 1, i - 1))\n            end\n            table.insert(groups, c)\n         \
    \   in_group = true\n        elseif c == ')' and in_group then\n            in_group\
    \ = false\n        end\n    end\n    return groups\nend", "    local paren_dict\
    \ = {}\n    local brace_count = 0\n    local stack = { paren_string }\n    while\
    \ #stack > 0 do\n        local group_open = stack[1]\n        local group_close\
    \ = stack[#stack]\n        stack = stack[#stack + 1]\n        table.insert(paren_dict,\
    \ group_open)\n        table.insert(paren_dict, group_close)\n        brace_count\
    \ = brace_count + 1\n        if paren_string ~= group_open .. group_close then\n\
    \            if paren_string ~= group_close and paren_string ~= group_open then\n\
    \                paren_string = paren_string .. '()'\n            else\n     \
    \           paren_string = paren_string .. '()'\n            end\n        end\n\
    \        if paren_string == group_open .. group_close then\n            table.insert(paren_dict,\
    \ group_close)\n        end\n    end\n    return paren_dict\nend", "    local\
    \ bracket_stack = {}\n    local open_paren = 0\n    local output = {}", "    local\
    \ open_brackets = {}\n    local close_brackets = {}", "    -- The first step is\
    \ to determine how many parentheses are in paren_string and then\n    -- determine\
    \ how many parentheses are needed to capture that many groups of parentheses.\n\
    \    local paren_count = paren_string:gsub(\"^%[(%.)]+\", \"\"):gsub(\"[()]\"\
    , \"\")\n    local paren_group_count = math.ceil(paren_count / 2)\n    local capture_groups\
    \ = math.min(paren_group_count, MAX_GROUPS)\n    -- The second step is to find\
    \ all the groups of parentheses in paren_string.\n    -- Each pair of parentheses\
    \ represents one \"capture group\". The pair is split into two\n    -- pieces,\
    \ the first piece being the parenthesis group itself, while the second piece\n\
    \    -- being the captured content within that group.\n    local capture_groups_of_parens\
    \ = paren_string:gsub(\"^(%[(%.)]+)(%.)\", \"\\2\\1\")\n    -- Finally, we split\
    \ the captured content of each group of parentheses into individual strings.\n\
    \    local capture_groups_of_paren_strings = capture_groups_of_parens:gsub(\"\
    (.-)\")\n    local groups_of_parens = capture_groups_of_paren_strings:gsub(\"\
    %[()]\")\n    -- We are now left with multiple strings that represent groups of\
    \ parenthesis.\n    -- The first is parenthesis groups, the second is the content\
    \ within each group.\n    -- To do that, simply split the groups_of_parens string\
    \ into two strings, and append each\n    -- into it's proper location.\n    local\
    \ groups_of_paren_strings = groups_of_parens:gsub(\"(.-)\")\n    groups_of_paren_strings\
    \ = capture_groups_of_paren_strings:gsub(\"%[()]\")\n    -- Now we can append\
    \ the strings to a list and return it.\n    -- We are done, so just return the\
    \ capture_groups_of_paren_strings\n    return capture_groups_of_paren_strings\n\
    end", "    local paren_groups = {}\n    for paren_char in string.gmatch(paren_string,\
    \ \"%([()][()]*%\") do\n        local open_parens, close_parens = paren_char:gsub(\"\
    %([()])\",\"\"):gsub(\"%([()])\",\"\"):gsub(\"%([()])\",\"\"):gsub(\"%([()])\"\
    ,\"\")\n        if open_parens ~= close_parens then\n            paren_groups[#paren_groups\
    \ + 1] = paren_char\n        else\n            paren_groups[#paren_groups + 1]\
    \ = \"(\" .. paren_char\n        end\n    end\n    return paren_groups\nend\n\
    </code>\n<|/ a tags=parsing,lua,parsing-error |>\n<| a |>\nI believe Lua's parser\
    \ is greedy in this case.\nFor example \n<code>", '   local results = {}', " \
    \   local paren_groups = {}\n    local paren_level = 0\n    local open_brace_position\
    \ = 1\n    local last_open_brace", "  local open_braces = {}\n  local closed_paren_count\
    \ = 0", "    -- Split on the paren char\n    local paren_groups = regexp:split(paren_string,\
    \ '[()]')\n    -- Iterate over the groups and push each one to the output\n  \
    \  for i = 1, #paren_groups do\n        local paren_group_length = #(paren_groups[i])\n\
    \        if paren_group_length > 0 then\n            -- The parent was opened,\
    \ so close it\n            -- If the parent was not opened, then the number of\
    \ open parens must be equal to the number of closed parens\n            if paren_group_length\
    \ == #paren_groups[(i-1)] then\n                paren_groups[(i-1)] = paren_groups[(i-1)]\
    \ .. paren_groups[i]\n            else\n                paren_groups[(i-1)] =\
    \ paren_groups[i]\n            end\n            -- Move the group one position\
    \ back\n            paren_groups[i+1] = paren_groups[i+1] .. paren_groups[#paren_groups]\n\
    \        end\n    end\n    return paren_groups\nend", "\t-- for paren group to\
    \ find all paren groups\n\tlocal paren_groups = {}\n\t-- iter through each character\
    \ in the string\n\tfor idx, char_ in ipairs(paren_string) do\n\t\t-- increment\
    \ count of open braces\n\t\tparen_groups.counters[char_.character] = paren_groups.counters[char_.character]\
    \ + 1\n\t\tif paren_groups.counters[char_.character] == 1 then\n\t\t\t-- open\
    \ paren group\n\t\t\ttable.insert(paren_groups, '(')\n\t\telse\n\t\t\t-- close\
    \ paren group\n\t\t\ttable.insert(paren_groups, ')')\n\t\tend\n\tend\n\treturn\
    \ paren_groups\nend", "\t-- for local index, string in ipairs(paren_string) do\n\
    \t\t-- local open_brackets = string.find('[(]') -- returns -1 for \"(())\"\n\t\
    \t-- local close_brackets = string.find('[)]') -- returns -1 for \"(()())\"\n\t\
    \t-- if open_brackets == -1 or close_brackets == -1 then\n\t\t\t-- return nil\n\
    \t\t-- end\n\t-- end\n\t-- return paren_string\n\treturn paren_string:gsub('[(]([^)]*)[)]',\
    \ '\\r$1')\n\t\t-- -- use \\r for carriage return to force next line to overwrite\
    \ current one -- doesn't work on iphone\n\t\t-- \t-- this didn't work but maybe\
    \ there was a typo in the docs\n\t\t-- \t-- the following works -- don't know\
    \ why the extra escape character is required\n\t\t-- \t-- '[(]([^)]*)[)]'\n\t\t\
    -- \t-- ' [(]([^)]*)[)]'\n\t\t-- \t-- '(]([^)]*)[)]'\n\t\t-- \t-- ' [(]([^)]*)[)'\n\
    \t\t-- \t-- ' [(]([^)]*)['\n\t\t-- \t-- ' [(]([^)]*)['\n\t\t-- \t-- '[)]'\n\t\t\
    -- \t-- ' [)]'\n\t\t-- \t-- '(]([^)]*)['\n\t\t-- \t-- ' [)]'\n\t\t-- \t-- '['\n\
    \t\t-- \t-- ' ['\n\t\t-- \t-- ']'\nend", "  -- Find the first open paren\n  local\
    \ open_brace_pos = 1\n  local paren_count = 1\n  local paren_pos = 1\n  while\
    \ open_brace_pos do\n    open_brace_pos = string.find(paren_string, '(', open_brace_pos)\n\
    \  end\n  -- Find the first close paren\n  local close_brace_pos = 1\n  local\
    \ close_brace_count = -1\n  while close_brace_pos do\n    close_brace_pos = string.find(paren_string,\
    \ ')', close_brace_pos)\n    close_brace_count = close_brace_count - 1\n  end\n\
    \  local group_string = paren_string:sub(1, open_brace_pos - 1)\n  local result\
    \ = {}\n  for i = 1, open_brace_pos do\n    table.insert(result, group_string)\n\
    \    group_string = paren_string:sub(close_brace_pos + 1)\n  end\n  if close_brace_count\
    \ == 1 then\n    table.insert(result, group_string)\n  else\n    table.insert(result,\
    \ group_string)\n    for i = 1, close_brace_count - 1 do\n      table.insert(result,\
    \ ')')\n    end\n  end\n  return result\nend", "  local open_braces = { }\n  local\
    \ close_braces = { }\n  local open_brace_count = 0\n  local close_brace_count\
    \ = 0\n  local groups = { }", "    if paren_string == '' or paren_string:match('^%s+$')\
    \ then\n        return nil\n    end\n    local paren_groups = { }\n    local in_paren\
    \ = false\n    for char in paren_string:gmatch('^%s+') do\n        if char ==\
    \ '(' then\n            in_paren = true\n        elseif char == ')' then\n   \
    \         in_paren = false\n            if in_paren and string.find(char, \"%[%a]\"\
    ) then\n                table.insert(paren_groups, '^%s+')\n            else\n\
    \                table.insert(paren_groups, char)\n            end\n        end\n\
    \    end\n    if string.sub(paren_string, 1, 1) == '^' then\n        return table.concat(paren_groups)\n\
    \    end\n    return paren_groups\nend", "  local open_groups = {}\n  local open_count\
    \ = 0\n  local open_paren = 0\n  local closed_count = 0\n  local closed_paren\
    \ = 0\n  local remainder = paren_string\n  while true do\n    local start = remainder:find('(',\
    \ open_paren)\n    if not start then\n      -- If there are no more parentheses,\
    \ return the last set of open parens\n      return open_groups[open_count]\n \
    \   end", "    local stack = {}\n    local current_group = \"\"\n    local open_brace_count\
    \ = 0\n    for index, letter in ipairs(paren_string) do\n        if letter ==\
    \ \"(\" then\n            open_brace_count = open_brace_count + 1\n        elseif\
    \ letter == \")\" then\n            open_brace_count = open_brace_count - 1\n\
    \        elseif letter == \" \" then\n            if open_brace_count == 0 then\n\
    \                table.insert(stack, current_group)\n                current_group\
    \ = \"\"\n            else\n                current_group = current_group .. letter\n\
    \            end\n        else\n            current_group = current_group .. letter\n\
    \        end\n    end\n    if open_brace_count > 0 then\n        error(\"Mismatched\
    \ braces: missing \" .. tostring(open_brace_count) .. \" opening braces.\")\n\
    \    end\n    return stack\nend\n</code>\n<|/ a |>\n<| c |>\nI didn't get why\
    \ you used `letter == \"(\" and open_brace_count > 0` instead of `open_brace_count\
    \ > 0`? Can you please explain?\n<|/ c |>\n<| c |>\nYes. I initially wanted to\
    \ use `open_brace_count > 0` but then decided that if `letter == \"(\"` then `open_brace_count\
    \ > 0` was equivalent to `open_brace_count > 0`. However, now I see that `letter\
    \ == \"(\"` only occurs the first time a brace is encountered so `open_brace_count\
    \ > 0` will always be true.\n<|/ c |>\n<| a dscore=2 tags=string,lua |>\nThis\
    \ simple script will do what you ask. The script works by building a stack of\
    \ opening brackets, and then when it finds a closing bracket it reverses the stack\
    \ (puts the most recently closed bracket on the top and continues searching until\
    \ it hits the first open bracket).\n<code>", "  local result = {}\n  local open_count\
    \ = 1\n  local depth = 0\n  local current_group = 1\n  for index, character in\
    \ ipairs(paren_string) do\n    if character == \"(\" then\n      open_count =\
    \ open_count + 1\n    elseif character == \")\" then\n      open_count = open_count\
    \ - 1\n      depth = depth - 1\n      if open_count < 1 then\n        current_group\
    \ = current_group - 1\n        if current_group == 0 then\n          table.insert(result,\
    \ table.concat(table.sub(1, index-1), \" \"))\n        end\n      end\n    end\n\
    \    if character == \" \" then\n      if open_count == depth then\n        table.insert(result,\
    \ table.concat(table.sub(1, index), \" \"))\n      end\n    end\n  end\n  return\
    \ result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
