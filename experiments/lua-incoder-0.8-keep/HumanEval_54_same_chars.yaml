name: HumanEval_54_same_chars
language: lua
prompt: "-- Check if two words have the same characters.\n-- >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddeddabc')\n-- True\n-- >>> same_chars('abcd', 'dddddddabc')\n-- True\n\
  -- >>> same_chars('dddddddabc', 'abcd')\n-- True\n-- >>> same_chars('eabcd', 'dddddddabc')\n\
  -- False\n-- >>> same_chars('abcd', 'dddddddabce')\n-- False\n-- >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddddabc')\n-- False\nlocal function same_chars(s0, s1)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = same_chars\n\
  \    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)\n    lu.assertEquals(candidate('abcd',\
  \ 'dddddddabc'), true)\n    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)\n\
  \    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)\n    lu.assertEquals(candidate('abcd',\
  \ 'dddddddabcf'), false)\n    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'),\
  \ false)\n    lu.assertEquals(candidate('aabb', 'aaccc'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local len0 = #s0\n    local len1 = #s1\n    local ret\n    if len0\
    \ ~= len1 then\n        -- len(s1) is longer than len(s0), so it is obviously\
    \ not a match\n        return ret\n    end\n    for i = 1, len0 do\n        if\
    \ s0[i] ~= s1[i] then\n            -- s1 has more characters than s0, so not a\
    \ match\n            return ret\n        end\n    end\n    -- Now that they are\
    \ the same, s1 must be longer than s0, so the match must be of same length\n \
    \   return true\nend", "  return #s0 == #s1 and all(x == y or x == z or x == z+32\
    \ or y == z+32 or x == y+32 or y == y+32 or x == z+16 or y == z+16 or x == y+16\
    \ or y == y+16 or x == z+8 or y == z+8 or x == y+8 or y == y+8 or x == y+4 or\
    \ y == y+4 or x == z+2 or y == z+2 or x == y+2 or y == y+2 or x == y+1 or y ==\
    \ y+1\n  or x == z+1 or y == z+1 or x == z or y == z or x == y+1 or y == y+1 or\
    \ x == y+2 or y == y+2 or\n  x == z+3 or y == z+3 or x == y+3 or y == y+3 or x\
    \ == z+4 or y == z+4 or x == y+4 or y == y+4 or x == z+5 or\n  y == z+5 or\n \
    \ x == y+6 or\n  y == y+6 or\n  x == z+7 or\n  y == z+7 or x == y+7 or y == y+7\
    \ or x == z+8 or y == z+8 or x == y+8 or y == y+8 or\n  x == y+9 or y == y+9)\n\
    end", "    local n = #s0 and #s1 and 0\n    if n == 0 then return false end\n\
    \    for i = 1, n do\n        if s0[i] ~= s1[i] then return false end\n    end\n\
    \    return true\nend", "    local i, j = 0, 0\n    for i = 1,#s0 do\n       \
    \ if s0[i]~=s1[j] then return false end\n        i=i+1\n        j=j+1\n    end\n\
    \    return true\nend", "  if type(s0) ~= 'string' or type(s1) ~= 'string' then\
    \ return false end\n  local n0 = 0\n  local n1 = 0\n  for i = 1, #s0 do\n    if\
    \ string.sub(s0, i, i) ~= string.sub(s1, i, i) then return false end\n    n0 =\
    \ n0 + 1\n    n1 = n1 + 1\n  end\n  return n0 == n1\nend", "  for i=1, #s0 do\n\
    \    if s0[i] ~= s1[i] then return false end\n  end\n  return true\nend", "  local\
    \ s0_c = unpack(s0)\n  local s1_c = unpack(s1)\n  local c = {}\n  for i=1,#s0_c,1\
    \ do\n    if c[ s0_c[i] ] == nil then\n      c[ s0_c[i] ] = 0\n    end\n    c[\
    \ s0_c[i] ] = c[ s0_c[i] ] + 1\n  end\n  for i=1,#s1_c,1 do\n    if c[ s1_c[i]\
    \ ] == nil then\n      c[ s1_c[i] ] = 0\n    end\n    c[ s1_c[i] ] = c[ s1_c[i]\
    \ ] + 1\n  end\n  return c[ s1_c[#s1_c] ] ~= #s1_c or c[ s0_c[#s0_c] ] ~= #s0_c\n\
    end", "  if #s0 ~= #s1 then return false end\n  for i, c0 in ipairs(s0) do\n \
    \   local c1 = s1[i]\n    if c0 ~= c1 then return false end\n  end\n  return true\n\
    end", "  if s0 ~= s1 then\n    return false\n  end\n  s0 = tostring(s0)\n  s1\
    \ = tostring(s1)\n  local l0 = #s0\n  local l1 = #s1\n  local i1, i2\n  local\
    \ a\n  -- Make sure both strings are longer than one character.\n  if l0 > l1\
    \ then\n    return false\n  end\n  -- If the strings are the same length, compare\
    \ each character in turn.\n  -- If the characters are the same, return true.\n\
    \  if l0 == l1 then\n    for i1 = 1, l0 do\n      i2 = i1 + 1\n      a = string.sub(s0,\
    \ i1, i2)\n      b = string.sub(s1, i1, i2)\n      if a ~= b then\n        return\
    \ false\n      end\n    end\n    return true\n  end\n  -- If the strings are of\
    \ different length, then return false\n  return false\nend", "  local n = math.min(#s0,\
    \ #s1)\n  local l0 = string.len(s0)\n  local l1 = string.len(s1)\n  for i = 1,\
    \ n do\n    if string.sub(s0, i, i) == string.sub(s1, i, i) then return true end\n\
    \  end\n  return false\nend", "  if s0 and s1 then\n    for i=1, #s0 do\n    \
    \  if s0:sub(i, i) ~= s1:sub(i, i) then\n        return false\n      end\n   \
    \ end\n  end\n  return true\nend", "  return (s0 ~= nil and\n          s1 ~= nil\
    \ and\n          #s0 == #s1 and\n          s0:sub(1, #s0 - 1)..s0:sub(1, #s0 -\
    \ 1) == s1:sub(1, #s1 - 1))\nend", "    if #s0 ~= #s1 then\n        return 0\n\
    \    end\n    local i = -1\n    while i < #s0 do\n        if s0[i] ~= s1[i] then\n\
    \            return 0\n        end\n        i = i + 1\n    end\n    return 1\n\
    end", "  return s0:reverse() == s1:reverse() and #s0 == #s1 and s0:reverse():sub(1,\
    \ #s0 - 1) == s1:reverse():sub(1, #s1 - 1)\nend", "   if #s0 ~= #s1 then\n   \
    \   return false\n   end\n   for i = 1, #s0 do\n      if s0[i] ~= s1[i] then\n\
    \         return false\n      end\n   end\n   return true\nend", "  local diffs\
    \ = 0\n  local diff\n  for i = 1, #s0, 1 do\n    diff = string.sub(s0, i, i+1)\
    \ ~= string.sub(s1, i, i+1)\n    if diff == 0 then diffs = diffs + 1 end\n  end\n\
    \  return diffs == 0\nend", "  local n0, n1, i, j, o\n  n0 = tonumber(s0) or 0\n\
    \  n1 = tonumber(s1) or 0\n  -- Handle empty strings and string with one character\n\
    \  if not n0 and not n1 then\n    return true\n  end\n  if n0 and n1 then\n  \
    \  return n0 ~= n1\n  end\n  o = string.len(s0) or 0\n  -- Handle empty strings\
    \ and string with same characters\n  if not o then return true end\n  if o ~=\
    \ string.len(s1) then return false end\n  -- Check character-by-character\n  for\
    \ i = 1, o do\n    j = string.find(s1, string.sub(s0, 0, i), nil, true)\n    if\
    \ j == nil then return false end\n    j = j + 1\n    if j > o then return false\
    \ end\n    j = string.find(s0, string.sub(s1, 0, i), nil, true)\n    if j == nil\
    \ then return false end\n    j = j + 1\n    if j > o then return false end\n \
    \ end\n  return true\nend", "  assert(s0 and s1)\n  local is_similar = false\n\
    \  local i = 0\n  local len = #s0\n  while i < len do\n    if s0[i] ~= s1[i] then\n\
    \      is_similar = false\n      break\n    end\n    i = i + 1\n  end\n  return\
    \ is_similar\nend", "  -- if s0 and s1 are same length\n  -- then s0 and s1 have\
    \ same characters at same indexes\n  -- return true if the characters are the\
    \ same in each string\n  if #s0 ~= #s1 then return false end\n  -- else return\
    \ true when index characters are same\n  for i = 0, #s0 do\n    if s0[i] ~= s1[i]\
    \ then return false end\n  end\n  return true\nend", "   if s0 ~= nil and s1 ~=\
    \ nil then\n      for i,v1 in ipairs(s0) do\n         if s1 ~= nil then\n    \
    \        for i,v2 in ipairs(s1) do\n               if v1 ~= nil and v2 ~= nil\
    \ and v1 == v2 then\n                  return true\n               else\n    \
    \              return false\n               end\n            end\n         end\n\
    \      end\n      return false\n   else\n      return false\n   end\nend", " \
    \   if s0 == nil or s1 == nil then\n        return nil\n    end\n    local n0,\
    \ n1 = #s0, #s1\n    if n0 ~= n1 then\n        return false\n    end\n    for\
    \ i = 1, n0 do\n        if s0:sub(i, i) ~= s1:sub(i, i) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "  if #s0 ~= #s1 then return\
    \ false end\n  for i,v in ipairs(s0) do\n    if v ~= s1[i] then return false end\n\
    \  end\n  return true\nend", "  local len0 = #s0\n  local len1 = #s1\n  if len0\
    \ ~= len1 then return false end\n  local i\n  for i = 1, len0 do\n    if s0[i]\
    \ ~= s1[i] then return false end\n  end\n  return true\nend", "  local l0 = #s0\n\
    \  local l1 = #s1\n  if l0 ~= l1 then\n    return false\n  elseif l0 == 0 then\n\
    \    return true\n  else\n    local i = l1\n    while i > 0 do\n      if not s0:sub(i,i-1)\
    \ ~= s1:sub(i,i-1) then\n        return false\n      end\n      i = i - 1\n  \
    \  end\n    return true\n  end\nend", "  for i, c0 in ipairs(s0) do\n    for j,\
    \ c1 in ipairs(s1) do\n      if c0 ~= c1 then\n        return false\n      end\n\
    \    end\n  end\n  return true\nend", "  s0 = s0 or '\\0'\n  s1 = s1 or '\\0'\n\
    \  s0 = string.lower(s0)\n  s1 = string.lower(s1)\n  local c = 0\n  for _,v in\
    \ string.gmatch(s1, '([a-z])') do\n    c = c + string.len(v)\n  end\n  local i\
    \ = 0\n  for _,v in string.gmatch(s0, '([a-z])') do\n    i = i + 1\n    if c ==\
    \ string.len(v) then\n      return true\n    end\n  end\n  return false\nend",
  "    if type(s0) == 'string' and type(s1) == 'string' then\n        local len0 =\
    \ #s0\n        local len1 = #s1\n        if len0 ~= len1 then\n            return\
    \ false\n        end\n        local i = 0\n        while i < len0 do\n       \
    \     local c0 = tostring(s0[i])\n            local c1 = tostring(s1[i])\n   \
    \         if c0 == c1 then\n                i = i + 1\n            else\n    \
    \            return false\n            end\n        end\n        return i == len0\n\
    \    end\n    return false\nend", "  for i, t0 in ipairs(s0) do\n    for j, t1\
    \ in ipairs(s1) do\n      if t0 == t1 then return true end\n    end\n  end\n \
    \ return false\nend", "\tassert(s0 and s1 and #s0 ~= 0 and #s1 ~= 0)\n\tlocal\
    \ i, n = #s0, #s1\n\twhile i do -- Iterate through both strings at the same index.\n\
    \t\tif s0[i] ~= s1[i] then return false end\n\t\ti = i + 1\n\tend\n\treturn true\n\
    end", "  return string.sub(s1, 1, 1) == string.sub(s0, 1, 1) and string.sub(s1,\
    \ string.len(s0), string.len(s1)) == string.sub(s0, string.len(s1), string.len(s0))\
    \ and\n  --\n  -- Check each character in s0.\n  --\n  -- NOTE: This does not\
    \ check the entire length of the string because it's possible to have\n  -- a\
    \ substring that has a different number of characters from another substring.\n\
    \  --\n  for i = 0, string.len(s0) do\n    if string.sub(s0, i, i) ~= string.sub(s1,\
    \ i, i) then\n      return false\n    end\n  end", "  return (not s0 or s1 ~=\
    \ nil) and string.gsub(string.gsub(s0, '(..)', '\\1'), '(..)', '\\1') ~= string.gsub(s1,\
    \ '(..)', '\\1')\nend", "  -- If s0 and s1 are both nil then return true\n  if\
    \ s0 == nil or s1 == nil then\n    return true\n  end\n  -- If s0 and s1 are both\
    \ strings then compare their lengths\n  if type(s0) ~= 'string' or type(s1) ~=\
    \ 'string' then\n    return false\n  end\n  -- Check if s1 and s2 have the same\
    \ number of characters\n  if #s0 ~= #s1 then\n    return false\n  end\n  -- Iterate\
    \ through each character in s0 and s1\n  for i=1, #s0 do\n    -- Check if s0[i]\
    \ is the same as s1[i]\n    -- If they don't match then return false\n    if s0[i]\
    \ ~= s1[i] then\n      return false\n    end\n  end\n  -- If we get to here then\
    \ s0 and s1 are the same number of characters\n  return true\nend", "  s0, s1\
    \ = s0:lower(), s1:lower()\n  if #s0 ~= #s1 then return false end\n  for i, c\
    \ in pairs(s0) do\n    if c ~= s1[i] then return false end\n  end\n  return true\n\
    end", "    return table.remove(function(i0,i1) return s0:subi(i0,i1) == s1:subi(i0,i1)\
    \ end, pairs(s0:gsub(\"(.-)\", \"%1,%1\")))\nend", "  for i=1, #s0 do\n    if\
    \ s0[i] ~= s1[i] then return false end\n  end\n  return true\nend", "    if s0\
    \ ~= s1 then\n        return s0 == s1 \n    end\n    local i1 = 1\n    local i2\
    \ = 1\n    while i1 <= #s0 and i2 <= #s1 do\n        if s0[i1] != s1[i2] then\n\
    \            return false\n        end\n        i1 = i1 + 1\n        i2 = i2 +\
    \ 1\n    end\n    if i1 == #s0 or i2 == #s1 then\n        return true\n    end\n\
    end", "  local a0, a1, b0, b1 = unpack(s0, s1, #s0, #s1)\n  local len = #a0\n\
    \  for i = 1, len do\n    if a0 ~= a0[a1[i]] or a0 ~= b0[b1[i]] or b0 ~= b0[b1[i]]\
    \ then return false end\n  end\n  return true\nend", "  return string.sub(string_chars(s0),\
    \ 1, string_chars(s1)) == string.sub(string_chars(s1), 1, string_chars(s0)) and\n\
    \    string.sub(string_chars(s0), string_chars(s0), string_chars(s1)) == string.sub(string_chars(s1),\
    \ string_chars(s0), string_chars(s1));\nend", "  if len0(s0) == 0 or len0(s1)\
    \ == 0 then\n    return len0(s0) == 0 or len0(s1) == 0\n  elseif len1(s0) == 0\
    \ or len1(s1) == 0 then\n    return len1(s0) == 0 or len1(s1) == 0\n  end\n  local\
    \ len_s0 = len0(s0)\n  local len_s1 = len1(s1)\n  if len_s0 ~= len_s1 then\n \
    \   return false\n  end\n  local i1 = 0\n  while i1 < len_s0 do\n    local i2\
    \ = i1\n    while i2 < len_s1 and s0:subi1(i2, i1) == s1:subi1(i2, i1) do\n  \
    \    i2 = i2 + 1\n    end\n    if i2 == len_s1 then\n      return true\n    end\n\
    \    i1 = i1 + 1\n  end\n  return false\nend", "  local i = 0\n  local n = #s0\
    \ and #s1 and #s0 == #s1 or #s0 == 0 or #s1 == 0 or #s1 == #s0 or s0:sub(1, 1)\
    \ == s1:sub(1, 1)\n  for i = 1; i < n; i = i + 1 do\n    if s0[i - 1] ~= s1[i\
    \ - 1] then return false end\n  end\n  return true\nend", "  return s0 and s1\
    \ and string.sub(string.lower(s0), 1, string.find(string.lower(s0), string.lower(s1)))\
    \ == string.sub(string.lower(s1), 1, string.find(string.lower(s1), string.lower(s0)))\
    \ and #string.sub(string.lower(s0), 1, string.find(string.lower(s0), string.lower(s1)))\
    \ == string.sub(string.lower(s1), 1, string.find(string.lower(s1), string.lower(s0)))\
    \ + #string.lower(s0) == #string.lower(s1)\nend", "  for i = 0, #s0 - 1 do\n \
    \   if s0[i] ~= s1[i] then\n      return false\n    end\n  end\n  return true\n\
    end", "    if type(s0) ~= 'string' or type(s1) ~= 'string' then\n        error('arguments\
    \ must be strings')\n    end\n    -- We need to check for the same characters\
    \ in both strings. If\n    -- they match, then we are done. Otherwise, check if\
    \ the first string\n    -- has a suffix that matches the other string. For example:\n\
    \    -- >>> same_chars('aaab', 'aab')\n    -- True\n    -- >>> same_chars('aaab',\
    \ 'aaa')\n    -- False\n    return (0 == #s0 and 0 == #s1 and (#s1 == 0 or s0\
    \ % s1 == 0)) or (#s0 == 0 and #s1 == 0 and s0 % s1 == 0)\nend", "  if type(s0)\
    \ == 'string' then\n    return (#s0 == #s1 and s0 ~= '' and s0 ~= '\\n')\n  end\n\
    \  if type(s0) == 'table' then\n    for k, s0_k in ipairs(s0) do\n      if type(s1)\
    \ == 'table' and s1 ~= {} then\n        for k1, s1_k in ipairs(s1) do\n      \
    \    local v0, v1 = s0_k, s1_k\n          local len0 = #v0\n          local len1\
    \ = #v1\n          --[[ If the string is long enough, we can shortcut the length\
    \ comparison ]]\n          if len0 > len1 then\n            v0, v1 = v1, v0\n\
    \            len0, len1 = len1, len0\n          end\n          if #v0 ~= #v1 then\n\
    \            return false\n          end\n          --[[ Compare the characters\
    \ ]]\n          if len0 == len1 then\n            for i = 1, len0 do\n       \
    \       if v0[i] ~= v1[i] then\n                return false\n              end\n\
    \            end\n          end\n        end\n      elseif type(s1) ~= 'table'\
    \ then\n        return false\n      end\n    end\n    return true\n  end\n  return\
    \ false\nend", "  if #s0 ~= #s1 then return false end\n  for i = 1, #s0 do\n \
    \   if s0[i] ~= s1[i] then return false end\n  end\n  return true\nend", "  local\
    \ function loop(s0, s1)\n    local l0 = #s0\n    local l1 = #s1\n    for i=1,\
    \ l0 do\n      if s0:sub(i,i) == s1:sub(i,i) then\n        return true\n     \
    \ end\n    end\n    return false\n  end\n  return loop(s0, s1) or (s0 ~= s1 and\
    \ loop(s1, s0))\nend", "  return #s0 and #s1 == #s0\n    and #s0 == #s1\n    and\
    \ #s0 == #unpack(map(nil, unpack(luci.tools.code.get_letters(s0))))\n    and #s1\
    \ == #unpack(map(nil, unpack(luci.tools.code.get_letters(s1))))\n    and #unpack(map(nil,\
    \ unpack(luci.tools.code.get_letters(s0))))\n    and #unpack(map(nil, unpack(luci.tools.code.get_letters(s1))))\n\
    \    == #unpack(map(nil, unpack(luci.tools.code.get_letters(s0)))):byte()\nend",
  "  if #s0 ~= #s1 then return false end\n  for i=1, #s0 do\n    if s0[i] ~= s1[i]\
    \ then return false end\n  end\n  return true\nend", "  if type(s0) ~= 'string'\
    \ then return false end\n  if type(s1) ~= 'string' then return false end\n  local\
    \ d0 = {}\n  local d1 = {}\n  for i=1, #s0 do d0[i] = i-1 end\n  for i=1, #s1\
    \ do d1[i] = i-1 end\n  for i=1, #s0 do\n    if d0[i] ~= d1[i] then return false\
    \ end\n  end\n  return true\nend", "  -- Special cases:\n  -- >>> same_chars('',\
    \ 'abcde')\n  -- True\n  -- >>> same_chars('', 'abccde')\n  -- False\n  -- >>>\
    \ same_chars('', 'abcccde')\n  -- True\n  -- >>> same_chars('', 'abccccde')\n\
    \  -- False\n  -- >>> same_chars('', 'abccccccde')\n  -- True\n  -- >>> same_chars('',\
    \ 'abcccccccde')\n  -- False\n  -- >>> same_chars('', 'abcccccccdea')\n  -- True\n\
    \  -- >>> same_chars('', 'abcccccccdeab')\n  -- False\n  -- >>> same_chars('',\
    \ 'abcccccccdeaa')\n  -- True\n  -- >>> same_chars('abcccccccdeaa', 'abcccccccdeab')\n\
    \  -- True\n  -- >>> same_chars('abcccccccdeaa', 'abcccccccdeaba')\n  -- False\n\
    \  -- >>> same_chars('abcccccccdeaa', 'abcccccccdeabaa')\n  -- True\n  -- >>>\
    \ same_chars('abcccccccdeaa', 'abcccccccdeabab')\n  -- False\n  -- >>> same_chars('abcccccccdeaa',\
    \ 'abcccccccdeabaaa')\n  -- True\n  -- >>> same_chars('abcccccccdeaa', 'abcccccccdeabaaab')\n\
    \  -- False\n  -- >>> same_chars('abcccccccdeaa', 'abcccccccdeaaa' )\n  -- False\n\
    \  -- >>> same_chars('abcccccccdeaa', 'abcccccccdea' )\n  -- False\n  -- >>> same_chars('abcccccccdeaa',\
    \ 'abcccccccdeaaab')\n  -- False\n  -- >>> same_chars('abcccccccdeaa', 'abcccccccdeaaabb')\n\
    \  -- False\n  -- >>> same_chars('abcccccccdeaa', 'abcccccccdeaaabbb')\n  -- False\n\
    \  -- >>> same_chars('abcccccccdeaa', 'abcccccccdeaaabbbb')\n  -- False\n  --\
    \ >>> same_chars('abcccccccdeaa', 'abcccccccdeaaabbbbb')\n  -- False\n  -- >>>\
    \ same_chars('abcccccccdeaa", "  if type(s0) ~= 'string' or type(s1) ~= 'string'\
    \ then return false end\n  local c1 = {}\n  for i = 0, #s0 do c1[string.sub(tostring(s0),\
    \ i, i)] = true end\n  for i = 0, #s1 do c1[string.sub(tostring(s1), i, i)] =\
    \ true end\n  for k, v in pairs(c1) do\n    if #s0 ~= #s1 then return false end\n\
    \    local i = 0\n    while i <= #s0 and i <= #s1 and s0[i] == s1[i] do\n    \
    \  i = i + 1\n    end\n    if #s0 ~= i then return false end\n  end\n  return\
    \ true\nend", "  return s0 and s1 and #s0 == #s1 and\n         strfind(s0, s1)\
    \ ~= nil\nend", "   if s0 ~= nil then\n      if s1 ~= nil then\n         if #s0\
    \ ~= #s1 then\n            return false\n         end\n         local i = 0\n\
    \         for _ = 1, #s0 do\n            if s0[i] ~= s1[i] then\n            \
    \   return false\n            end\n            i = i + 1\n         end\n     \
    \    if i == #s0 then\n            return true\n         else\n            return\
    \ false\n         end\n      else\n         return false\n      end\n   else\n\
    \      return false\n   end\nend", "  return s0 ~= nil and s1 ~= nil and #s0 ~=\
    \ 0 and #s1 ~= 0 and s0 ~= s1 and s0[#s0] == s1[#s1]\nend", "  if s0 and s1 then\n\
    \    for i = 0, #s0 do\n      if s0[i] ~= s1[i] then\n        return false\n \
    \     end\n    end\n    return true\n  end\n  return false\nend", "    assert(type(s0)\
    \ ~= 'string' or (#s0 < 0 and #s0 < 0))\n    assert(type(s1) ~= 'string' or (#s1\
    \ < 0 and #s1 < 0))\n    for i=1, #s0, 1 do\n        if s0[i] ~= s1[i] then\n\
    \            return false\n        end\n    end\n    return true\nend", "  --\
    \ We don't even need to preallocate memory here.\n  local d = {[unpack(s0)] =\
    \ true, [unpack(s1)] = true}\n  return #d == 1 and d[unpack(s0)] and d[unpack(s1)]\n\
    end", "    return string.sub(s0, 0, -1) == string.sub(s1, 0, -1)\nend", "   if\
    \ s0 and s1 then\n      for i = 1, #s0 do\n         if s0[i] ~= s1[i] then\n \
    \           return false\n         end\n      end\n      return true\n   end\n\
    end", "  if s0 ~= nil and s1 ~= nil then\n    s0 = tostring(s0)\n    s1 = tostring(s1)",
  "    -- Check whether two strings contain same characters and ignore case\n    if\
    \ #s0 ~= #s1 then\n        local i = 0\n        while i < #s0 do\n           \
    \ local char = string.sub(s0, i, i)\n            if string.find(string.lower(s0),\
    \ string.lower(char)) then\n                return false\n            end\n  \
    \          i = i + 1\n        end\n        return true\n    else\n        return\
    \ s0 ~= s1\n    end\nend", "  if #s0 ~= #s1 then return false end\n  for i = 0,\
    \ #s0 do\n    if s0[i] ~= s1[i] then return false end\n  end\n  return true\n\
    end", "   local function ch(s)\n      local r,c = 1,{}\n      for i, x in ipairs(s)\
    \ do\n         c[x] = c[x] or i\n         r = 0 and r or i\n      end\n      return\
    \ r\n   end\n   local function ch2(c0)\n      return string.sub(c0, c0, c0)\n\
    \   end\n   local c0 = 0,0\n   local r0 = 0,0\n   for _, r1ix in ipairs(string.gmatch(s1,\
    \ '[^' .. s0 .. ']*')) do\n      local r1i = r1ix + 1\n      local c1,_1,_ = string.find(s1,\
    \ s0, r1ix, true)\n      local r1x = r1i - 1\n      if c1 and string.sub(s0, c0,\
    \ c0) ~= string.sub(s0, c0, c1) then\n         return false\n      end\n     \
    \ local n0 = ch(s0)\n      local n1 = ch2(string.sub(s1, c1, c1))\n      r0, r1\
    \ = r1, r0\n      if r0 ~= r1 then return false end\n      if n0 ~= n1 then return\
    \ false end\n      c0 = c1 + 1\n   end\n   return true\nend", "  if s0 ~= nil\
    \ and s1 ~= nil then\n    if #s0 ~= #s1 then return false end\n    for i = 1,\
    \ #s0 do\n      if s0:sub(i, i) ~= s1:sub(i, i) then return false end\n    end\n\
    \    return true\n  end\nend", "   return s0:sub(1,#s0) == s1:sub(1,#s1)\nend",
  "  s0 = s0:lower()\n  s1 = s1:lower()\n  for i = 1, #s0 do\n    if s0[i] ~= s1[i]\
    \ then return false end\n  end\n  return true\nend", "  if #s0 ~= #s1 then return\
    \ false end\n  for i = 1, #s0 do\n    if s0[i] ~= s1[i] then return false end\n\
    \  end\n  return true\nend", "   -- Check that chars in s0 are same in s1 and\
    \ in all combinations of s0+s1.\n   local n = #s0\n   for i = 1, n do\n      for\
    \ j = 1, n do\n         if i == j then -- same chars in both\n            if not\
    \ s0[i] or not s1[j] then return false end\n         else -- different chars in\
    \ both\n            if not s0[i] or s0[i] ~= s1[j] then return false end\n   \
    \      end\n      end\n   end\n   return true\nend", "  if #s0 ~= #s1 then return\
    \ false end\n  for i=1, #s1 do\n    if s0:sub(i, i) ~= s1:sub(i, i) then return\
    \ false end\n  end\n  return true\nend", "  return not (s0 == '' or s0 == nil\
    \ or s1 == nil or\n              string.sub(s0,1,#s0) == string.sub(s1,1,#s1))\n\
    end", "    local n0, n1 = #s0, #s1\n    if n0 ~= n1 then return false end\n  \
    \  for i=1,n0 do\n        if s0[i] ~= s1[i] then return false end\n    end\n \
    \   return true\nend", "    local i = #s0 - 1\n    local j = #s1 - 1\n    while\
    \ i >= 0 and j >= 0 do\n        if s0[i] == s1[j] then\n            i = i - 1\n\
    \            j = j - 1\n        else\n            i = i - 1\n            j = j\
    \ - 1\n        end\n    end\n    return i == 0 and j == 0\nend", "  if s0 == nil\
    \ or s1 == nil then\n    return false\n  end\n  if type(s0) ~= 'string' or type(s1)\
    \ ~= 'string' then\n    return false\n  end\n  return string.gsub(s0, '^%s*',\
    \ '') == string.gsub(s1, '^%s*', '') and string.gsub(s0, '%s*$', '') == string.gsub(s1,\
    \ '%s*$', '')\nend", "    local function check_chars(c0, c1)\n        if c0 ~=\
    \ c1 then return false end\n        return check_chars(c1+1, c1+2)\n    end\n\
    \    return check_chars(0, 0) and check_chars(s0, s1)\nend", "\tlocal i = #s0,\
    \ #s1\n\twhile i < 1 do\n\t\tif s0 and s1 ~= s0 then\n\t\t\treturn false\n\t\t\
    elseif s1 then\n\t\t\ts1, s0 = s0, nil\n\t\telse\n\t\t\treturn true\n\t\tend\n\
    \t\ti = i - 1\n\tend\n\treturn false\nend", "    return s0 ~= nil and s1 ~= nil\
    \ and s0 ~= s1 and #s1 == #s0\nend", "  local n0 = #s0\n  local n1 = #s1\n  if\
    \ n0 ~= n1 then return false end\n  for i = 1, n0 do\n    if s0[i] ~= s1[i] then\
    \ return false end\n  end\n  return true\nend", "    return #s0 ~= 0 and #s1 ~=\
    \ 0 and s0[#s0] == s1[#s1]\nend\n</code>\nThis solution was taken from this answer.\n\
    <|/ a tags=lua,lua-table,arrays |>\n<| a |>\nHere's a variation on Fernando's\
    \ answer that allows you to specify the minimum length of a word.\n<code>", " \
    \ if s0 ~= s1 then\n    return false\n  end\n  for i, v in ipairs(s0) do\n   \
    \ if s0[i] ~= s1[i] then\n      return false\n    end\n  end\n  return true\n\
    end", "  return not (not s0 or not s1 or s0 ~= s1)\nend", "    assert(type(s0)\
    \ == 'string')\n    assert(type(s1) == 'string')\n    local count = 0\n    for\
    \ _,c in ipairs(s0) do\n        if c ~= s1[1] then\n            return false\n\
    \        end\n        count = count+1\n    end\n    return count == #s1\nend",
  "    local i1 = 0\n    local j1 = 0\n    while i1 ~= #s0 and j1 ~= #s1 do\n    \
    \    if s0[i1] ~= s1[j1] then return false end\n        i1 = i1 + 1\n        j1\
    \ = j1 + 1\n    end\n    return i1 == #s0 and j1 == #s1\nend\n</code>\n<|/ a tags=performance,lua\
    \ dscore=2 |>\n<| c |>\nIt would be nice to get an explanation why this works.\
    \ Also, a bit of explanation on why this works, would be greatly appreciated.\n\
    <|/ c |>\n<| c |>\nI don't really understand what this code does but I'll try\
    \ my best. Lets say that the string is \"eabcdzzzz\" and the string we want to\
    \ compare it to is \"dddzzzzzzzddeddabc\". Then the algorithm goes through the\
    \ string, checks if every character in one string appears in other string. The\
    \ first 'e' in string \"eabcdzzzz\" appears in the beginning of \"dddzzzzzzzddeddabc\"\
    . So it returns true. The next 'd' does not appear in the second string, so the\
    \ algorithm returns false. Now, for the next letter 'z', it appears after the\
    \ 'z' in string \"eabcdzzzz\", but before the 'z' in string \"dddzzzzzzzddeddabc\"\
    , so again it returns false. So the algorithm works perfectly. I hope that makes\
    \ it clear.\n<|/ c |>\n<| c |>\nSo the algorithm basically goes through the string,\
    \ and checks if every character in s1 appears in s0.\n<|/ c |>\n<| c |>\nI'm sorry\
    \ but I don't understand your explanation.\n<|/ c |>\n<| c |>\nOk, I got it...\
    \ It would be nice if you could explain why it works.\n<|/ c |>\n<| a dscore=1\
    \ tags=performance,lua |>\nI created a function in lua which can help you in these\
    \ type of problems. I am posting the code which I use. Hope this helps.\n<code>",
  "  return s0 and s1 and #s0 == #s1 and s0 .. s1 == s0 .. s1\nend", "  local len\
    \ = #s0 and #s1\n  if len == 0 then\n    return false\n  end\n  local max = 0\n\
    \  if len > 0 then\n    max = max\n  elseif len < 0 then\n    max = -len\n  end\n\
    \  for i=1, len do\n    local c = string.byte(string.sub({}, i, i)):byte()\n \
    \   if c ~= string.byte(string.sub({}, i, i+1)):byte() then\n      return false\n\
    \    end\n    if c > max then\n      return false\n    end\n  end\n  return true\n\
    end", "    local is_equal = false\n    local len0, len1 = #s0, #s1\n    if len0\
    \ ~= len1 then return false end\n    for i = 1, len0 do\n        if is_equal then\
    \ return false end\n        local c0, c1 = string.byte(s0, i), string.byte(s1,\
    \ i)\n        if c0 ~= c1 then return false end\n    end\n    return true\nend",
  "\t-- https://stackoverflow.com/questions/25072767/why-do-all-strings-in-python-have-hash-equality/25072996#25072996\n\
    \treturn ( s0:sub(1,1):lower() == s1:sub(1,1):lower() ) \n\t\t-- ^ Compare characters\
    \ for equality.\n\t\t-- ^ Compare characters for equality.\nend", "    if s1 then\n\
    \        local diff = {}\n        for i = 1, #s0 do\n            if s0 ~= s1[i]\
    \ then\n                diff[i] = true\n            end\n        end\n       \
    \ return #diff ~= 0\n    end\n    return s0 ~= nil\nend", "  s0 = s0 or ''\n \
    \ s1 = s1 or ''\n  -- We are sure that both strings are non-empty.\n  assert(#s0\
    \ < #s1)\n  local i\n  local j\n  local k\n  for i = 1, #s0, 1 do\n    k = s0:sub(i,\
    \ i)\n    j = s1:sub(i, i)\n    assert(j == k)\n  end\nend", "    local function\
    \ is_char(char)\n        return (char >= 'a' and char <= 'z') or\n           \
    \    (char >= 'A' and char <= 'Z') or\n               (char >= '0' and char <=\
    \ '9') or\n               char == ' ' or\n               char == '.' or\n    \
    \           char == ',' or\n               char == '!' or\n               char\
    \ == '?' or\n               char == '-' or\n               char == '_' or\n  \
    \             char == '+' or\n               char == '=' or\n               char\
    \ == '^' or\n               char == '~' or\n               char == '.' or\n  \
    \             char == '(' or \n               char == ')' or\n               char\
    \ == '[' or\n               char == ']' or\n               char == '{' or\n  \
    \             char == '}' or\n               char == '|' or\n               char\
    \ == '\\\\' or\n               char == ';' or\n               char == ':' or\n\
    \               char == '&' or\n               char == '\\'' or\n            \
    \   char == '*' or\n               char == '?' or\n               char == '+'\
    \ or\n               char == '`' or\n               char == '~' or\n         \
    \      char == '-' or\n               char == '(' or \n               char ==\
    \ ')' or\n               char == '[' or\n               char == ']' or\n     \
    \          char == '{' or\n               char == '}' or\n               char\
    \ == '<' or\n               char == '>' or\n               char == '%' or\n  \
    \             char == '%' or\n               char == '+' or\n               char\
    \ == '.' or\n               char == '/' or\n               char == '&' or\n  \
    \             char == '!' or\n               char == '#' or\n               char\
    \ == '@' or\n               char == '&' or\n               char == '*' or\n  \
    \             char == '=' or\n               char == '+' or\n               char\
    \ == '.' or\n               char == ',' or\n               char == ':' or\n  \
    \             char == '!' or\n               char == '~'\n    end\n    local i\n\
    \    for i=1,#s0 do\n        if is_char(s0[i]) and is_char(s1[i]) then\n     \
    \       if #s0 > #s1 then\n                return false\n            elseif #s0\
    \ < #s1 then\n                return false\n            end\n        else\n  \
    \          if #s0 < #s1 then\n                return false\n            elseif\
    \ #s0 > #s", "  local n0, m0 = tonumber(s0), tonumber(s0)\n  if n0 == nil or m0\
    \ == nil then\n    return false\n  end\n  local n1, m1 = tonumber(s1), tonumber(s1)\n\
    \  if n1 == nil or m1 == nil then\n    return false\n  end\n  for i=1,m0 do\n\
    \    local char = string.sub(s0, i, i)\n    if char == string.sub(s1, i, i) then\n\
    \      continue\n    end\n    return false\n  end\n  for i=1,m1 do\n    local\
    \ char = string.sub(s1, i, i)\n    if char == string.sub(s0, i, i) then\n    \
    \  continue\n    end\n    return false\n  end\n  return true\nend", "  -- First\
    \ pass: count the chars in s0 that are in s1.\n  -- This assumes s0 and s1 are\
    \ both non-empty strings.\n  local n, m = #s0, #s1\n  if n ~= m then return false\
    \ end\n  local o0, o1 = {}, {}\n  for i=1,n do o0[string.sub(tostring(s0), i,\
    \ i)] = i end\n  for i=1,m do o1[string.sub(tostring(s1), i, i)] = i end\n  for\
    \ k,v in pairs(o0) do\n    if not (o1[v] and o0[v] % 2 == 0 and o0[v] in o1) then\
    \ return false end\n  end\n  return true\nend", "   return string.sub(s0, 1, string.len(s0))\
    \ == string.sub(s1, 1, string.len(s1))\nend", "    for i = 1, #s0, 1 do\n    \
    \    if s0[i] == s1[i] then\n            return true\n        end\n    end\n \
    \   return false\nend", "    if not s0 then\n        -- Empty string equals empty\
    \ string\n        return s0 ~= \"\" and s1 ~= \"\"\n    end\n    if #s0 ~= #s1\
    \ then\n        -- Different lengths\n        return false\n    end\n    -- If\
    \ any of the two characters are the same,\n    -- they are not equal.\n    for\
    \ i = 1, #s0 do\n        if s0[i] ~= s1[i] then\n            return false\n  \
    \      end\n    end\n    -- All the characters are equal, so they are equal.\n\
    \    return true\nend", "   return #s0 ~= #s1 and all(s0:len() == s1:len(), unpack(s0)\
    \ ~= unpack(s1))\nend", "    local i = 0\n    local i2 = 0\n    while i < #s0\
    \ and i2 < #s1 do\n        if s0[i] == s1[i2] then\n            i = i + 1\n  \
    \          i2 = i2 + 1\n        elseif s0[i] > s1[i2] then\n            return\
    \ false\n        else\n            return true\n        end\n    end\n    return\
    \ i2 == #s1\nend", "    if s0 ~= s1 then\n        return false\n    end\n    if\
    \ #s0 ~= #s1 then\n        return false\n    end\n    for i = 1, #s0 do\n    \
    \    if s0:sub(i, i) ~= s1:sub(i, i) then\n            return false\n        end\n\
    \    end\n    return true\nend", "   if #s0 ~= #s1 then return false end\n   for\
    \ i=1, #s0 do\n      if s0[i] ~= s1[i] then return false end\n   end\n   return\
    \ true\nend", "   -- This code was originally written by R. C. White at\n   --\
    \ http://www.cs.cmu.edu/afs/cs.cmu.edu/project/quake/public/code/samechars.c.",
  "  -- s0 should never be longer than s1 because s1 has been checked\n  -- already\
    \ in same_chars_strict\n  if #s0 < #s1 then\n    return false\n  elseif #s0 <\
    \ #s1 then\n    return true\n  else\n    -- Now both strings are equal length\n\
    \    if s0 < s1 then\n      s0 = s0:byte(#s0)\n      s1 = s1:byte(#s1)\n     \
    \ for i = 0, s0 - 1 do\n        if s0[i] ~= s1[i] then\n          return false\n\
    \        end\n      end\n      return true\n    else\n      s0 = s0:byte(#s1)\n\
    \      s1 = s1:byte(#s0)\n      for i = 1, s1 - 1 do\n        if s0[i] ~= s1[i]\
    \ then\n          return false\n        end\n      end\n      return true\n  \
    \  end\n  end\nend", "  if s0 ~= s1 then\n    return false\n  end\n  local len0\
    \ = string.len(s0)\n  local len1 = string.len(s1)\n  local i = 0\n  while i <\
    \ len0 and i < len1 do\n    local a0 = string.sub(tostring(s0), i, i)\n    local\
    \ a1 = string.sub(tostring(s1), i, i)\n    if a0 ~= a1 then\n      return false\n\
    \    end\n    i = i + 1\n  end\n  return len0 == len1\nend", "  for _, ch in ipairs(s0)\
    \ do\n    if not ch == s1[#s1] then\n      return false\n    end\n  end\n  return\
    \ true\nend", "   local n = #s0 - 1\n   while n >= 0 do\n      local m = (n and\
    \ s0 or s1):sub(1,n)\n      if m ~= s0 then return false end\n      n = n - 1\n\
    \   end\n   return true\nend", "  -- Return true if both arguments are strings\
    \ made of ASCII characters.\n  -- This assumes that s0 and s1 are both valid strings.\n\
    \  -- This is valid because ASCII characters occupy a contiguous range of\n  --\
    \ characters.\n  -- The algorithm is derived from the Python code at:\n  -- http://code.activestate.com/recipes/286142-test-if-two-strings-are-identical/\n\
    \  -- The Python code at that URL was written by Guido van Rossum, who has a\n\
    \  -- Python interpreter at http://code.activestate.com/recipes/286142-test-if-two-strings-are-identical/#c12\n\
    \  local len0 = #s0\n  local len1 = #s1\n  -- TODO: Reuse function from string.\n\
    \  local function charmatch(s0, s1)\n    local n = 0\n    while n < len0 and n\
    \ < len1 do\n      -- Return the first mismatched character.\n      local c0 =\
    \ string.sub(s0, n, n)\n      local c1 = string.sub(s1, n, n)\n      if c0 ~=\
    \ c1 then return c0 end\n      n = n + 1\n    end\n    return string.sub(s0, n)\n\
    \  end\n  return charmatch(s0, s1) ~= nil\nend", "  if #s0 ~= #s1 then\n    return\
    \ false\n  end\n  for i = 0, #s0 do\n    if not table.remove(s0, i) then\n   \
    \   return false\n    end\n    if not table.remove(s1, i) then\n      return false\n\
    \    end\n  end\n  return true\nend", "  -- Create a map of s0 characters.\n \
    \ -- We use sets to avoid the use of loops.\n  local s0_map = setmetatable({},\
    \ { __mode = \"k\" })\n  for i = 0, #s0 do\n    -- Keep a count of how many chars\
    \ we have seen in the s0.\n    s0_map[s0[i]] = s0_map[s0[i]] or 0\n    -- Add\
    \ the char to its count if in s1 already.\n    if s1[s0_map[s0[i]]] then\n   \
    \   s0_map[s0[i]] = s0_map[s0[i]] + 1\n    end\n  end\n  -- Test all remaining\
    \ characters in s1 against those in s0.\n  for i = #s1, 1, -1 do\n    -- Check\
    \ if this character is in s0. Return if it is.\n    if s0_map[s1[i]] ~= nil then\n\
    \      return true\n    end\n  end\n  return false\nend", "  -- if s0 == nil then\
    \ return s1 == nil end\n  -- if s1 == nil then return s0 == nil end\n  -- if s0\
    \ ~= '' and s1 ~= '' then\n  --  if #s0 < #s1 then\n  --    if #s0 < #s1 then\n\
    \  --      local s = s0, s1\n  --      s0, s1 = s1\n  --      s1, s0 = s\n  --\
    \    end\n  --  end\n  --  return s0 == s1\n  -- end\n  -- return false\n  return\
    \ s0 ~= nil and s1 ~= nil and #s0 ~= #s1 and #s0 == #s1\nend", "  -- Find common\
    \ characters between two strings\n  local common = {}\n  local common_len = 0\n\
    \  for i=1,#s0 do\n    for j=1,#s1 do\n      if string.sub(s0, i, i+1)==string.sub(s1,\
    \ j, j+1) then\n        table.insert(common, string.sub(s0, i, i+1))\n       \
    \ common_len = common_len + 1\n      end\n    end\n  end\n  -- Return true if\
    \ there are any common characters\n  return common_len>0\nend", "\ts0 = s0 or\
    \ ''\n\ts1 = s1 or ''\n\treturn #s0 < #s1 and\n\t\t#s0 == 0 or\n\t\t#s0 == #s1\
    \ and\n\t\ts0 ~= '' and s1 ~= '' and #s0 == #s1 and\n\t\tfind(s0, s1, '') == 0\n\
    end", "  local i0, i1 = 0, 0\n  while i0 < #s0 or i1 < #s1 do\n    if i0 < #s0\
    \ then\n      local c0, i0 = match(s0, r1_chars)\n      if c0 == nil then break\
    \ end\n      i0 = i0 + 1\n    end\n    if i1 < #s1 then\n      local c1, i1 =\
    \ match(s1, r1_chars)\n      if c1 == nil then break end\n      i1 = i1 + 1\n\
    \    end\n    if c0 ~= c1 then break end\n  end\n  return i0 == #s0\nend", " \
    \  for i,c in ipairs(s0) do\n      if string.sub(s1,i,i) == c then\n         return\
    \ true\n      end\n   end\n   return false\nend", "    if #s0 ~= #s1 then return\
    \ false end\n    local l0 = #s0\n    for i = 1, l0 do\n        if s0[i] ~= s1[i]\
    \ then return false end\n    end\n    return true\nend", "   for i = 1, #s0, 1\
    \ do\n      if s0[i] ~= s1[i] then\n         return false\n      end\n   end\n\
    \   return true\nend", "  assert(type(s0) == 'string')\n  assert(type(s1) == 'string')\n\
    \  local d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15,\
    \ d16, d17, d18, d19, d20, d21, d22, d23, d24, d25, d26, d27, d28, d29, d30, d31,\
    \ d32, d33, d34, d35, d36, d37, d38, d39, d40, d41, d42, d43, d44, d45, d46, d47,\
    \ d48, d49, d50, d51, d52, d53, d54, d55, d56, d57, d58, d59, d60, d61\n  = {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\
    \ {}, {}, {}, {}, {}, ", "    local sz = #s0\n    local n0 = #s1\n    if n0 ~=\
    \ sz then return false end\n    for i = 1, sz do\n        if s0[i] ~= s1[i] then\
    \ return false end\n    end\n    return true\nend", "  -- Remove whitespace and\
    \ duplicates.\n  local w0 = tostring(gsub(s0, ' ', ''))\n  local w1 = tostring(gsub(s1,\
    \ ' ', ''))\n  w0 = gsub(w0, '(.-)', '\\1')\n  w1 = gsub(w1, '(.-)', '\\1')",
  "  if #s0 ~= #s1 then return false end\n  local c = {}\n  for i = 1, #s0 do\n  \
    \  c[s0[i]] = true\n  end\n  for i = 1, #s1 do\n    if c[s1[i]] == true then return\
    \ false end\n  end\n  return true\nend", "\tlocal len0 = #s0\n\tlocal len1 = #s1\n\
    \tlocal n = len0\n\twhile n > 0 and len1 > 0 do\n\t\t-- if s0[n] == s1[0] then\n\
    \t\t--     return true\n\t\t-- end\n\t\tn = n - 1\n\t\tlen1 = len1 - 1\n\tend\n\
    \treturn len0 == len1\nend", "   for i = 0, #s0 do\n      local s0_char = string.sub(s0,\
    \ i, i)\n      local s1_char = string.sub(s1, i, i)\n      if s0_char == s1_char\
    \ then\n         return true\n      end\n   end\n   return false\nend", "  local\
    \ i = 0\n  local j = 0\n  for i=1, #s0, 1 do\n    for j=1, #s1, 1 do\n      if\
    \ s0[i] ~= s1[j] then\n        return false\n      end\n    end\n  end\n  return\
    \ true\nend", "  if #s0 ~= #s1 then return false end\n  for c, _ in pairs(s0)\
    \ do\n    if c ~= s1[#s0] then return false end\n  end\n  return true\nend", "\t\
    -- https://stackoverflow.com/questions/2527146/what-is-the-most-efficient-way-to-find-duplicate-substring-in-string\n\
    \tlocal function find_match_start_end_indices(s0, s1)\n\t\tlocal s0_len = #s0\n\
    \t\tlocal s1_len = #s1\n\t\tif s0_len > s1_len then\n\t\t\tlocal s0_start_index\
    \ = s1_len\n\t\t\tlocal s1_start_index = s1_len\n\t\telse\n\t\t\tlocal s0_start_index\
    \ = s1_len\n\t\t\tlocal s1_start_index = s0_len\n\t\tend\n\t\t-- Iterate over\
    \ the substrings, keep track of which indices are the\n\t\t-- match boundaries\n\
    \t\tlocal i = 0\n\t\tlocal match_indices = {}\n\t\tlocal j = s0_len\n\t\twhile\
    \ i <= s1_len and j <= s1_len + s0_len do\n\t\t\tlocal i0 = i - 1\n\t\t\tlocal\
    \ j0 = j - 1\n\t\t\tif s0[i] == s1[j] then\n\t\t\t\tmatch_indices[#match_indices\
    \ + 1] = {\n\t\t\t\t\tstart = i,\n\t\t\t\t\tend = j\n\t\t\t\t}\n\t\t\t\ti = i\
    \ + 1\n\t\t\t\tj = j + 1\n\t\t\telse\n\t\t\t\tif i == s0_start_index and not j\
    \ == s1_start_index then\n\t\t\t\t\t-- The first chars don't match, no match\n\
    \t\t\t\t\treturn false\n\t\t\t\telseif i == s0_start_index and j == s1_start_index\
    \ then\n\t\t\t\t\t-- The second chars match\n\t\t\t\t\t-- Keep going\n\t\t\t\t\
    elseif i == s1_start_index and not j == s1_start_index then\n\t\t\t\t\t-- The\
    \ first chars match, no match\n\t\t\t\t\treturn false\n\t\t\t\telseif i == s1_start_index\
    \ and j == s0_start_index then\n\t\t\t\t\t-- The second chars match\n\t\t\t\t\t\
    -- Keep going\n\t\t\t\telseif i == s0_start_index then\n\t\t\t\t\t-- Both chars\
    \ match\n\t\t\t\t\tlocal match_indices_length = #match_indices\n\t\t\t\t\tif match_indices_length\
    \ > 1 then\n\t\t\t\t\t\t-- There are multiple matches, return the first\n\t\t\t\
    \t\t\tlocal best_match_index = match_indices[match_indices_length - 1].end\n\t\
    \t\t\t\t\ti = best_match_index + 1\n\t\t\t\t\telse\n\t\t\t\t\t\t-- No matches\
    \ found\n\t\t\t\t\t\treturn false\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\t-- Neither\
    \ chars match\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn\
    \ true\n\tend\n\tlocal function find_match_start_end_indices(s0, s1)\n\t\tlocal\
    \ s0_len = #s0\n\t\tlocal s1_len = #s1\n\t\tif s0_len > s1_len then\n\t\t\tlocal\
    \ s0_start_index = s1_len\n\t\t\tlocal s1_start_index = s1_len\n\t\telse\n\t\t\
    \tlocal s0_start_index = s1_len\n\t\t\tlocal s1_start_index = s", "    if #s0\
    \ ~= #s1 then return false end\n    for i = 1, #s0 do\n        if s0[i] ~= s1[i]\
    \ then return false end\n    end\n    return true\nend", "  local i0 = 0\n  local\
    \ i1 = 0\n  local ilen0 = #s0\n  local ilen1 = #s1\n  while i0 < ilen0 and i1\
    \ < ilen1 do\n    if string.sub(s0, i0, i0 + 1) == string.sub(s1, i1, i1 + 1)\
    \ then\n      i0 = i0 + 1\n      i1 = i1 + 1\n    else\n      i0 = i0 + 1\n  \
    \    i1 = i1\n    end\n  end\n  return (i0 == ilen0 or i1 == ilen1)\nend", " \
    \ local i = 0\n  local j = 1\n  for _, b in ipairs(s0) do\n    if b == s1(j) then\n\
    \      i = i + 1\n      j = j + 1\n    end\n    if j == #s1 then\n      return\
    \ true\n    end\n  end\n  return false\nend", "  if s0 ~= nil and s1 ~= nil then\n\
    \    return all_chars_equal(s0, s1)\n  else\n    return false\n  end\nend", " \
    \ if s0 ~= s1 then return false end\n  if #s0 ~= #s1 then return false end\n \
    \ for i=1, #s0 do\n    if s0[i] ~= s1[i] then return false end\n  end\n  return\
    \ true\nend", "    if #s0 ~= #s1 then\n        return false\n    end\n    local\
    \ i = 0\n    local j = 0\n    while i < #s0 and j < #s1 do\n        if string.sub(s0,\
    \ i, i) ~= string.sub(s1, j, j) then\n            return false\n        end\n\
    \        i = i + 1\n        j = j + 1\n    end\n    return i == #s0 and j == #s1\n\
    end", "  local l0 = string.len(s0)\n  local l1 = string.len(s1)\n  return l0 ==\
    \ l1 and s0 ~= nil and s1 ~= nil and\n    string.find(s0, s1) ~= nil and\n   \
    \ string.find(s1, s0) ~= nil\nend", "   s0 = s0 or ''\n   s1 = s1 or ''\n   if\
    \ s0 ~= '' then s0 = s0:gsub('(.)(.)', '%%%1%%%2%%%1')\n   end\n   if s1 ~= ''\
    \ then s1 = s1:gsub('(.)(.)', '%%%1%%%2%%%1')\n   end\n   return s0 == s1\nend",
  "  if #s0 ~= #s1 then return false end\n  for i=1, #s0 do\n    if s0[i] ~= s1[i]\
    \ then return false end\n  end\n  return true\nend", "   local s0char = string.gsub(s0,\
    \ '[^'..string.char(#string.sub(s0, 1, '')..'~]+', '')\n   local s1char = string.gsub(s1,\
    \ '[^'..string.char(#string.sub(s1, 1, '')..'~]+', '')\n   if s0char == s1char\
    \ then\n      return true\n   else\n      return false\n   end\nend", "  return\
    \ #s0 == #s1 and\n     s0 ~= nil and #s1 ~= nil and #s0 == #s1 and\n     s0 ~=\
    \ nil and s1 ~= nil and #s0 == #s1 and\n     s0 ~= nil and s1 ~= nil and #s0 ==\
    \ #s1 and #s0 == #s1 and\n     s0 ~= nil and s1 ~= nil and #s0 == #s1 and #s0\
    \ == #s1 and\n     s0 ~= nil and s1 ~= nil and #s0 == #s1 and #s0 == #s1\nend",
  "  -- Make sure we are dealing with strings.\n  assert(type(s0) == 'string')\n \
    \ assert(type(s1) == 'string')\n  -- Make sure that we are comparing equal length.\n\
    \  assert(#s0 == #s1)\n  -- Loop through the characters in each string.\n  for\
    \ i = 0, #s0 do\n    -- Check if the first character is the same as the corresponding\
    \ character in the second string.\n    if s0[i] == s1[i] then\n      -- If so,\
    \ return true.\n      return true\n    end\n  end\n  -- Return false.\n  return\
    \ false\nend", "\tlocal i = 0\n\tlocal j = 0\n\tfor _, b in ipairs(s0) do\n\t\t\
    if b == s1:sub(j, i) then return true end\n\t\ti = i + 1\n\tend\n\treturn false\n\
    end", "  local s0_c = s0 and tonumber(s0) or 1\n  local s1_c = s1 and tonumber(s1)\
    \ or 1\n  return s0_c == s1_c\nend", "    local w = string_split(s0)\n    local\
    \ x = string_split(s1)\n    local n1 = #w\n    local n2 = #x\n    for i=1, n2\
    \ do\n        if w[i]~=x[i] then return false end\n    end\n    return true\n\
    end", "  local n0 = #s0\n  local n1 = #s1\n  if n0 ~= n1 then\n    return false\n\
    \  end\n  for i = 1, n0 do\n    if s0[i] ~= s1[i] then\n      return false\n \
    \   end\n  end\n  return true\nend", "  return #s0 == #s1 and #s0 == 1 or #s1\
    \ == #s0 and #s1 == 1 or (#s0 == 0 and #s1 == 0 and s0 ~= s1)\nend", "  s0 = tonumber(s0)\n\
    \  s1 = tonumber(s1)\n  if s0 ~= nil and s1 ~= nil then\n    if s0 and s1 then\n\
    \      local t0 = {}\n      local t1 = {}\n      for i = 1, #s0 do\n        if\
    \ t0[s0[i]] ~= nil then\n          t1[t0[s0[i]]] = nil\n        else\n       \
    \   t0[s0[i]] = i\n        end\n      end\n      for i = 1, #s1 do\n        if\
    \ t1[t1[i]] ~= nil then\n          return false\n        else\n          t1[t1[i]]\
    \ = i\n        end\n      end\n      return true\n    end\n    return s0 ~= nil\
    \ and s1 ~= nil\n  else\n    return s0 ~= nil and s1 ~= nil\n  end\nend", "  --\
    \ Strip leading and trailing whitespace from strings s0 and s1,\n  -- then compare\
    \ the result of the stripping.\n  s0 = string.strip(s0)\n  s1 = string.strip(s1)\n\
    \  return s0 == s1\nend", "   return s0 ~= nil and s1 ~= nil and string.sub(s0,\
    \ string.len(s0), string.len(s1)) == string.sub(s1, string.len(s0), string.len(s1))\n\
    end", "   for i = 1, #s0 do\n      if not s0[i]==s1[i] then return false end\n\
    \   end\n   return true\nend", "  local t0 = {}\n  local t1 = {}\n  for i = 1,#s0\
    \ do\n    table.insert(t0, s0, i)\n    table.insert(t1, s1, i)\n  end\n  local\
    \ l = #t0 > #t1 and #t0 or #t1 < #t0 and #t1 or #t0 < #t1 and #t0 or #t0 < #t1\
    \ and #t1 or #t0 < #t1 and #t0 or #t0 < #t1 and #t1 -- #t1 will be smaller\n \
    \ local i = 0\n  while i < l do\n    if t0[i] ~= t1[i] then\n      return false\n\
    \    end\n    i = i + 1\n  end\n  return true\nend", "    for i=1, #s0 do\n  \
    \      local l0 = tonumber(s0[i])\n        local l1 = tonumber(s1[i])\n      \
    \  if not (l0 and l1) then\n            return false\n        end\n        if\
    \ not l0 then return false end\n        if not l1 then return false end\n    \
    \    if l0 == l1 then return true end\n    end\n    return false\nend", "    return\
    \ string.sub(s0, #s0 - #s1 + 1, #s0 + #s1 - 1) == string.sub(s1, #s0 - #s1 + 1,\
    \ #s0 + #s1 - 1)\nend", "    return #s0 ~= #s1 and\n        all(c0 == c1 or c1\
    \ == c0 for c0, c1 in ipairs(s0, s1))\nend", "  if #s0 ~= #s1 then return false\
    \ end\n  for i=1,#s0 do\n    if s0[i] ~= s1[i] then return false end\n  end\n\
    \  return true\nend", "    local c0 = {\n        -- Ignore control characters\n\
    \        ['\\x00'] = true,\n        ['\\x07'] = true,\n        ['\\x08'] = true,\n\
    \        ['\\x09'] = true,\n        ['\\x0a'] = true,\n        ['\\x0b'] = true,\n\
    \        ['\\x0c'] = true,\n        ['\\x0d'] = true,\n        ['\\x0e'] = true,\n\
    \        ['\\x0f'] = true,\n        ['\\x10'] = true,\n        ['\\x11'] = true,\n\
    \        ['\\x12'] = true,\n        ['\\x13'] = true,\n        ['\\x14'] = true,\n\
    \        ['\\x15'] = true,\n        ['\\x16'] = true,\n        ['\\x17'] = true,\n\
    \        ['\\x18'] = true,\n        ['\\x19'] = true,\n        ['\\x1a'] = true,\n\
    \        ['\\x1b'] = true,\n        ['\\x1c'] = true,\n        ['\\x1d'] = true,\n\
    \        ['\\x1e'] = true,\n        ['\\x1f'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n        ['\\xff'] = true,\n        ['\\xff'] = true,\n\
    \        ['\\xff'] = true,\n", "    local num_char = #s0 -- The number of characters\
    \ in the string\n    local num_char_1 = #s1 -- The number of characters in the\
    \ string\n    local char_map = {}\n    for i = 1, num_char do\n        char_map[#char_map\
    \ +1] = s0:sub(i,i)\n    end\n    for i = 1, num_char_1 do\n        char_map[#char_map\
    \ +1] = s1:sub(i,i)\n    end\n    char_map[#char_map +1] = '\\x00'\n    return\
    \ char_map[#char_map] == char_map[#char_map +1]\nend\n</cell>\n<cell>", "  local\
    \ t0 = {}\n  local t1 = {}\n  for i = 1, #s0, 1 do\n    local char = string.sub(#s0,\
    \ i, i)\n    if t0.includes(char) then\n      t1[#t1 + 1] = char\n    elseif t1.includes(char)\
    \ then\n      t0[#t0] = char\n    else\n      return false\n    end\n  end\n \
    \ if #t0 ~= #t1 then\n    return false\n  end\n  for i = 1, #s0, 1 do\n    if\
    \ s0[i] ~= t1[i] then\n      return false\n    end\n  end\n  return true\nend",
  "   return s0 and s1 and s0:sub(1, #s0)==s1:sub(1, #s1)\nend", "    return #s0 ==\
    \ #s1 and\n           s0 ~= \"\" and\n           s1 ~= \"\" and\n           #s0\
    \ == 1 and\n           #s1 == 1 and\n           s0:sub(1, 1) == s1:sub(1, 1) and\n\
    \           s0:sub(2, 2) == s1:sub(2, 2) and\n           s0:sub(3, 3) == s1:sub(3,\
    \ 3)\nend", "  return #s0 ~= #s1 and strings:sub(s0, s1)\nend", "  return #s0\
    \ ~= 0 and #s1 ~= 0 and\n    string.sub(s0, -#s0) ~= string.sub(s1, -#s1)\nend\n\
    return same_chars", "    -- Check for string sizes\n    if #s0 ~= #s1 then return\
    \ false end\n    -- Check for same characters in same position\n    for i = 0,\
    \ #s1 do\n        if s0[i] ~= s1[i] then return false end\n    end\n    -- If\
    \ all characters are the same, check the rest\n    return true\nend", "    return\
    \ #s1 == #s0 and #s1 == #s0 and s1 ~= 's' and s1 ~= 'z' and s0 ~= 'z'\nend", " \
    \ return string.sub(s0, string.len(s0), string.len(s1)) == string.sub(s1, string.len(s0),\
    \ string.len(s1))\nend", "    local d0 = {}\n    local d1 = {}\n    local i0 =\
    \ 0\n    local i1 = 0\n    repeat\n        d0[#d0 + 1] = string.sub({}, i0, i0)\n\
    \        i0 = i0 + 1\n    until #s0 == 0\n    repeat\n        d1[#d1 + 1] = string.sub({},\
    \ i1, i1)\n        i1 = i1 + 1\n    until #s1 == 0\n    for i0 = 1, #s0 do\n \
    \       for i1 = 1, #s1 do\n            if string.sub(s0, i0, i0) ~= string.sub(s1,\
    \ i1, i1) then\n                return false\n            end\n        end\n \
    \   end\n    return true\nend", "    if #s0 ~= #s1 then\n        return false\n\
    \    end\n    for i = 1, #s0 do\n        if s0[i] ~= s1[i] then\n            return\
    \ false\n        end\n    end\n    return true\nend", "  local len1 = #s0\n  local\
    \ len2 = #s1\n  if len1 ~= len2 then return false end\n  for i = 1, len1 do\n\
    \    if string.sub(s0, i, i) ~= string.sub(s1, i, i) then return false end\n \
    \ end\n  return true\nend", "   -- Create temporary variables to save string characters.\n\
    \   local s1, s2 = s0, s1 -- copy parameters\n   local l1, l2 = #s0, #s1 -- calculate\
    \ lengths\n   -- Compare characters until one string runs out of characters.\n\
    \   if l1 == l2 then\n      return true\n   else\n      while l1 >= l2 do\n  \
    \       if s1[l1+1] ~= s2[l1+1] then\n            return false\n         end\n\
    \         l1 = l1 - 1\n         l2 = l2 - 1\n      end\n      return true\n  \
    \ end\nend", "   for i=1, #s0 do\n      if string.sub(s0, i, #s0) == string.sub(s1,\
    \ i, #s1) then return true end\n   end\n   return false\nend", "  s0 = s0 or ''\n\
    \  s1 = s1 or ''\n  -- Remove leading and trailing blanks from both strings.\n\
    \  s0 = s0 ~= '' and s0 or ''\n  s1 = s1 ~= '' and s1 or ''\n  local i\n  for\
    \ i = 1,#s0,1 do\n    if s0[i] == s1[i] then return true end\n  end\n  return\
    \ false\nend", "  -- Check length\n  local n0, n1 = string.len(s0), string.len(s1)\n\
    \  if n0 ~= n1 then return false end\n  -- Check characters in each position\n\
    \  -- For Python, Python has character count, so this is easy\n  for i = 1, n0\
    \ do\n    local v0, v1 = string.sub(\n      s0, i, i), string.sub(\n      s1,\
    \ i, i)\n    if v0 ~= v1 then return false end\n  end\n  -- Check last character\n\
    \  if string.sub(s0, n0, n0) ~= string.sub(s1, n0, n0) then\n    return false\n\
    \  end\n  return true\nend", "  local len = #s0 and #s1 and len and len\n  return\
    \ len == 0 or len == #s0 and len == #s1 and s0 ~= s1 and false\nend", "  local\
    \ s0_len = #s0\n  local s1_len = #s1\n  if s0_len == 0 or s1_len == 0 then\n \
    \   return false\n  end\n  if s0_len > s1_len then\n    return false\n  end\n\
    \  for i = 1, s0_len do\n    if s0[i] ~= s1[i] then\n      return false\n    end\n\
    \  end\n  return true\nend", "  if s0 == nil then\n    return nil\n  end\n  if\
    \ s1 == nil then\n    return true\n  end\n  local s0_len, s1_len = #s0, #s1\n\
    \  if s0_len == 0 or s1_len == 0 or s0_len < s1_len then\n    return false\n \
    \ end\n  for i = 1, s0_len do\n    if s0:sub(i, i) == s1:sub(i, i) then return\
    \ true end\n  end\n  return false\nend", "  local n0 = #s0\n  local n1 = #s1\n\
    \  local n = max(n0, n1)\n  local s = string.rep(\"\\0\", n)\n  local j = n0\n\
    \  for i = 1, n do\n    if s0 and s1 then\n      local c = s0[j]\n      local\
    \ d = s1[j]\n      if c == d then\n        j = j + 1\n      else\n        j =\
    \ j - 1\n        if j == 0 then\n          s = s .. c\n          break\n     \
    \   end\n      end\n    else\n      s = s .. \"\\0\"\n    end\n  end\n  return\
    \ s ~= \"\"\nend", "  -- Return true if s0 and s1 have the same characters.\n\
    \  -- We use sets to make the comparison cheap.\n  local s0_chars = setmetatable({},\
    \ { __index = function(t, k) return k:lower() end})\n  local s1_chars = setmetatable({},\
    \ { __index = function(t, k) return k:lower() end})\n  for _, c in ipairs(s0)\
    \ do\n    s0_chars[c] = true\n  end\n  for _, c in ipairs(s1) do\n    s1_chars[c]\
    \ = true\n  end\n  return #s0_chars == #s1_chars\nend", "  local i0 = {}\n  local\
    \ j0 = {}\n  for k, c in pairs(s0) do i0[c] = k; end\n  for k, c in pairs(s1)\
    \ do j0[c] = k; end\n  -- if length(s1) > length(s0) then s0 = s1 end\n  for i\
    \ = 1, #s0 do\n    if not i0[s0[i]] then return false end\n    if not j0[s1[i]]\
    \ then return false end\n  end\n  return true\nend", "  local n0 = #s0\n  local\
    \ n1 = #s1\n  -- Return True if two strings contain same characters.\n  if n0\
    \ ~= n1 then\n    return false\n  else\n    local i\n    for i=1, n0 do\n    \
    \  -- If same characters found then return True.\n      if string.sub(s0, i, i)\
    \ ~= string.sub(s1, i, i) then\n        return false\n      end\n    end\n   \
    \ return true\n  end\nend", "  if s0 == nil or s1 == nil then\n    return false\n\
    \  end\n  local s0_len, s1_len, s0_char = unpack(s0)\n  local s1_char, s1_len,\
    \ s1_char = unpack(s1)\n  if s0_len == 0 and s1_len == 0 then\n    return true\n\
    \  end\n  return s0_char == s1_char and s0_len == s1_len\nend", "  if s0 and s1\
    \ then\n    return string.reverse(s0) == string.reverse(s1)\n  end\nend", "  \
    \ assert(s0 and s1)\n   for i = 0, #s0 do\n      assert(s0[i] == s1[i])\n   end\n\
    \   return true\nend", "  local i0\n  local j0\n  local i1\n  local j1\n  local\
    \ i\n  local j\n  local i0i1\n  local j0j1\n  local n0\n  local n1\n  for i0=0,\
    \ #s0 do\n    i0i1 = 0\n    j0j1 = 0\n    n0 = 0\n    n1 = 0\n    for i1=1, #s1\
    \ do\n      i1j = i0 - i1 + 1\n      j1j = j0 - j1 + 1\n      if i1j > 0 then\n\
    \        i0i1 = i0i1 + 1\n        if s0[i0i1] == s1[j1j] then\n          i0i1\
    \ = i0i1 + 1\n          j0j1 = j0j1 + 1\n          n0 = n0 + 1\n        else\n\
    \          i0i1 = i0i1 + 1\n        end\n      elseif i1j < #s1 then\n       \
    \ i0i1 = i0i1 + 1\n      else\n        i0i1 = i0i1 + 1\n      end\n      if j1j\
    \ > 0 then\n        j0j1 = j0j1 + 1\n        if s0[i0i1] == s1[j1j] then\n   \
    \       j0j1 = j0j1 + 1\n          n1 = n1 + 1\n        else\n          j0j1 =\
    \ j0j1 + 1\n        end\n      elseif j1j < #s1 then\n        j0j1 = j0j1 + 1\n\
    \      else\n        j0j1 = j0j1 + 1\n      end\n    end\n    if n0 == n1 then\n\
    \      i = i0 + i0i1\n      j = j0 + j0j1\n      if i == j then\n        return\
    \ true\n      elseif i == #s0 or j == #s1 then\n        return false\n      end\n\
    \    end\n  end\n  return false\nend", "  if s0 and s1 then\n    for _, _, v01,\
    \ v02, v03, _, _, _ in string.gmatch(s0, \"([%a])([%a]+)([%a])([%a]+)(%a+)\")\
    \ do\n      for i1, v1 in string.gmatch(s1, \"([%a])([%a]+)([%a])([%a]+)(%a+)\"\
    ) do\n        if v01 ~= v1 then\n          return false\n        end\n      end\n\
    \    end\n  end\n  return true\nend", "   if #s0 ~= #s1 then\n      return false\n\
    \   end\n   for i = 0, #s0 do\n      if s0[i] ~= s1[i] then\n         return false\n\
    \      end\n   end\n   return true\nend", "  for i=1,#s0,1 do \n    if string.sub(s0,i,i)\
    \ == string.sub(s1,i,i) then return true end\n  end\n  return false\nend", " \
    \ for i = 1, #s0 do\n    if s0[i] ~= s1[i] then return false end\n  end\n  return\
    \ true\nend", "  if s1 == nil then\n    return false\n  end\n  if s0 ~= nil then\n\
    \    return string.len(s0) == string.len(s1)\n  end\n  return false\nend", " \
    \   -- Compare characters in s0, s1 pairwise\n    local ret\n    local i0 = 0\n\
    \    local i1 = 0\n    local j0 = 0\n    local j1 = 0\n    if #s0 > 0 and #s1\
    \ > 0 then\n        i0, j0, i1, j1 = unpack(s0)\n        for i = i0, i1, -1 do\n\
    \            if i0 > 0 and j0 > 0 and s0[j0] == s1[j0] then\n                j0\
    \ = j0 + 1\n                i0 = i0 + 1\n            end\n            if i1 >\
    \ 0 and j1 > 0 and s0[j1] == s1[j1] then\n                j1 = j1 + 1\n      \
    \          i1 = i1 + 1\n            end\n        end\n        ret = i0 == i1 and\
    \ j0 == j1\n    else\n        ret = (#s0 == 0 and #s1 == 0)\n    end\n    return\
    \ ret\nend", "    return s0 and s1 and\n        s0 == s1 or\n        not s0 and\
    \ not s1\nend", "    local s0_len = #s0\n    local s1_len = #s1\n    local i\n\
    \    -- if length same, compare chars\n    if s0_len == s1_len then\n        for\
    \ i=1,s0_len do\n            if s0[i] ~= s1[i] then\n                return false\n\
    \            end\n        end\n        return true\n    end\n    -- if lengths\
    \ different,\n    -- compare first char lengths\n    if s0_len < s1_len then\n\
    \        return same_chars(s0, s1..'s0')\n    elseif s0_len > s1_len then\n  \
    \      return same_chars(s1..'s0', s0)\n    end\n    -- compare first chars\n\
    \    for i=1,s0_len do\n        if s0[i] ~= s1[i] then\n            return false\n\
    \        end\n    end\n    return true\nend", "    if s0 ~= s1 then\n        for\
    \ i = 1, #s0, 1 do\n            if s0[i] ~= s1[i] then return false end\n    \
    \    end\n        for i = 1, #s1, 1 do\n            if s0[i] ~= s1[i] then return\
    \ false end\n        end\n    end\n    return true\nend", "   assert(type(s0)\
    \ == 'string')\n   assert(type(s1) == 'string')\n   assert(#s1 == #s0)\n   for\
    \ i = 1, #s1 do\n      if s0[i] ~= s1[i] then return false end\n   end\n   return\
    \ true\nend", "   assert(s0 and s1 and #s0 == #s1)\n   for i = 1, #s1 do\n   \
    \   if s0[i] ~= s1[i] then return false end\n   end\n   return true\nend", " \
    \ if #s0 ~= #s1 then\n    return false\n  end\n  local i = 1\n  for _ in pairs(s0)\
    \ do\n    if s0[i] ~= s1[i] then\n      return false\n    end\n    i = i + 1\n\
    \  end\n  return true\nend", "  if #s0 ~= #s1 then return false end\n  for i=1,\
    \ #s1 do\n    if not s0:sub(1, i) == s1:sub(1, i) then return false end\n  end\n\
    \  return true\nend", "  return #s0 >= #s1 and\n    all(s1:sub(#s0, #s1):reverse():sub(1,\
    \ #s1):reverse():sub(1, #s1):reverse() == s0)\nend", "  -- Find the indices of\
    \ s0 that aren't in s1.\n  local function unin(s0, s1)\n    local i = 1\n    while\
    \ i < #s0 do\n      if not s1[i - 1] then\n        return i\n      end\n     \
    \ i = i + 1\n    end\n    return nil\n  end\n  local i0\n  -- Compare each pair\
    \ of adjacent characters in s0 and s1.\n  while i0 or i1 do\n    -- If either\
    \ string runs out of characters to compare, we're done.\n    i0 = i0 and unin(s0,\
    \ s1) or nil\n    i1 = i1 and unin(s1, s0) or nil\n    -- Compare the first character\
    \ of each string.\n    if s0[i0] and s1[i1] then\n      -- If both strings have\
    \ the same first character, they're the\n      -- same characters.\n      if s0[i0]\
    \ == s1[i1] then\n        i0 = nil\n        i1 = nil\n      else\n        i0 =\
    \ nil\n        i1 = nil\n      end\n    else\n      -- If either string runs out\
    \ of characters to compare, we're done.\n      i0 = i0 and unin(s0, s1) or nil\n\
    \      i1 = i1 and unin(s1, s0) or nil\n    end\n  end\n  return not i0\nend",
  "  local chars1\n  if type(s1) ~= 'string' then return false end\n  chars1 = tostring(s1)\n\
    \  local chars0\n  if type(s0) ~= 'string' then return false end\n  chars0 = tostring(s0)\n\
    \  local n1 = #chars1\n  local n0 = #chars0\n  -- Only compare up to the maximum\
    \ string length\n  if n0 > n1 then return false end\n  for i = 1, #s0, 1 do\n\
    \    -- If the characters are equal, skip them\n    if chars0[i] == chars1[i]\
    \ then return false end\n    -- If the characters are different\n    if chars0[i]\
    \ ~= chars1[i] then\n      if chars0[i] < chars1[i] then\n        return false\n\
    \      else\n        return true\n      end\n    end\n  end\n  return true\nend",
  "   if #s0 ~= #s1 then return false end\n   for i = 1, #s0 do\n      if s0[i] ~=\
    \ s1[i] then return false end\n   end\n   return true\nend", "   local b0 = {}\n\
    \   for _ in s0 do table.insert(b0, _) end\n   local b1 = {}\n   for _ in s1 do\
    \ table.insert(b1, _) end\n   return #b1 == #b0 and #b0 == #s0\nend", "  -- Check\
    \ if two words have the same characters.\n  local function same_c(word, chars)\n\
    \    local found = false\n    for i = 1, #word do\n      if string.sub(s, i, i\
    \ + #chars) ~= chars then\n        return false\n      end\n    end\n    return\
    \ true\n  end\n  -- Check that all words in the string have the same characters.\n\
    \  if #s0 ~= #s1 then\n    return false\n  end\n  for _, s0_w in ipairs(s0) do\n\
    \    local s1_w = s1[_]\n    if same_c(s1_w, s0) then return true end\n  end\n\
    \  return false\nend", "   if #s0 ~= #s1 then return false end\n   local j = 0\n\
    \   for i=1, #s0 do\n      if s0[i] ~= s1[j] then return false end\n      j =\
    \ j + 1\n      if j == #s1 then return true end\n   end\n   return false\nend",
  "   local is_s0 = type(s0) == 'string'\n   local is_s1 = type(s1) == 'string'\n\
    \   if not is_s0 or not is_s1 then\n      return false\n   end\n   local n0 =\
    \ #s0\n   local n1 = #s1\n   if n0 ~= n1 then\n      return false\n   end\n  \
    \ for i = 1, n0 do\n      if s0:sub(i, i) ~= s1:sub(i, i) then\n         return\
    \ false\n      end\n   end\n   return true\nend", "   if s0 ~= nil and s1 ~= nil\
    \ and #s0 == #s1 then \n      for i=1, #s0 do\n         if s0[i] ~= s1[i] then\
    \ \n            return false\n         end\n      end\n      return true\n   end\n\
    \   return false\nend", "  -- Create table with same characters and count each\
    \ occurrence.\n  local t0 = {}\n  local cnt = 0\n  for _, c in pairs(s0) do\n\
    \    t0[c] = t0 or 0\n    t0[c] = t0[c] + 1 or 1\n  end\n  for _, c in pairs(s1)\
    \ do\n    cnt = cnt + 1 or 1\n  end\n  -- Check that each character of the string\
    \ is unique.\n  for _, _ in pairs(t0) do\n    if t0 == nil then\n      return\n\
    \    end\n    if t0[_] ~= cnt then\n      return false\n    end\n  end\n  return\
    \ true\nend", "  local is_chars, s0, s1 = pcall(function() return pcall(string.gsub,\
    \ s0, \"([\" .. s1 .. \"]+)\") end)\n  local p1, p2 = pcall(function() return\
    \ string.gsub(s1, \"([\" .. s0 .. \"]+)\", \"%1\"), string.gsub(s1, \"([\" ..\
    \ s1 .. \"]+)\", \"%1\") end)\n  return p1 == p2 and is_chars\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
