name: HumanEval_89_encrypt
language: lua
prompt: "-- Create a function encrypt that takes a string as an argument and\n-- returns\
  \ a string encrypted with the alphabet being rotated. \n-- The alphabet should be\
  \ rotated in a manner such that the letters \n-- shift down by two multiplied to\
  \ two places.\n-- For example:\n-- encrypt('hi') returns 'lm'\n-- encrypt('asdfghjkl')\
  \ returns 'ewhjklnop'\n-- encrypt('gf') returns 'kj'\n-- encrypt('et') returns 'ix'\n\
  local function encrypt(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encrypt\n\
  \    lu.assertEquals(candidate('hi'), 'lm')\n    lu.assertEquals(candidate('asdfghjkl'),\
  \ 'ewhjklnop')\n    lu.assertEquals(candidate('gf'), 'kj')\n    lu.assertEquals(candidate('et'),\
  \ 'ix')\n    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')\n    lu.assertEquals(candidate('hellomyfriend'),\
  \ 'lippsqcjvmirh')\n    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'),\
  \ 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')\n    lu.assertEquals(candidate('a'),\
  \ 'e')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- ROTATE THE ALPHABET TWICE IN THE RIGHT DIRECTION. \n\t-- The alphabet\
    \ is rotated down by 2 then multiplied by 2 and shifted \n\t-- down by 2 multiples\
    \ to produce a rotation of -2 then subtracted from \n\t-- the actual rotation.",
  "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    s = string.gsub(s,\"[^\"\
    ..alphabet..\"]\",\"\")\n    local new_alphabet = alphabet:sub(1,#alphabet)+alphabet:sub(#alphabet+1,#alphabet)\n\
    \    local new_s = {}\n    for i = 1,#s do\n        table.insert(new_s,alphabet:sub((i-1)*2+1,(i-1)*2)..new_alphabet:sub((i-1)*2+2,(i-1)*2-1))\n\
    \    end\n    return table.concat(new_s)\nend", "    local alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    local ret = ''\n    for i = #s, 1, -1 do\n        ret = ret * alpha + alpha:sub(i\
    \ + #alpha + 1, #alpha + i)\n    end\n    return ret\nend", "   local alphabet\
    \ = string.char(string.char(\"a\") + string.char(\"b\"))\n   -- shift the alphabet\
    \ down to make all letters shift by two.\n   -- ie. 'a' becomes 'b' 'c' becomes\
    \ 'd' etc \n   alphabet = alphabet:sub(1)..alphabet:sub(3)..alphabet:sub(5)\n\
    \   \n   -- rotate the string by the number of letters to shift.\n   -- ie. 'gfhkl'\
    \ becomes 'kjhew'\n   local rot = string.len(alphabet)\n   \n   -- rotate each\
    \ letter in the string by two and add it to the rotated string.\n   local rotated_alphabet\
    \ = s:gsub(\"%c\", function(x)\n      local c = string.byte(x)\n      return string.char((string.byte(x)+rot)%rot)\n\
    \   end)\n   \n   return string.char(alphabet)..rotated_alphabet\nend", "   local\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   local rotated_alphabet = \"\"\n\
    \   for i = 1, #alphabet do\n      local c = alphabet:sub(i,i)\n      if c:byte()\
    \ > #rotated_alphabet then rotated_alphabet = rotated_alphabet .. \"abc\" else\
    \ rotated_alphabet = rotated_alphabet .. c end\n   end\n   local s = s:lower()\n\
    \   for i = 1, #s do\n      local c = s:sub(i,i)\n      if c > #alphabet then\
    \ c = alphabet end\n      c = rotated_alphabet:sub(c:byte()-#rotated_alphabet,c:byte())\n\
    \      if c:byte() ~= #rotated_alphabet then c = rotated_alphabet:sub(c:byte()+#rotated_alphabet,c:byte())\
    \ end\n      s:sub(i,i) = c\n   end\n   return s:sub(1)\nend", "  local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  -- Convert all letters into ascii and shift\
    \ them left by two\n  s = s:gsub(\"%l\", function (c) return alphabet[alphabet.index(c)\
    \ + 2] end)\n  -- Pad the string with spaces.\n  s = s:gsub(\"(.)\", function(c)\
    \ return \" \" .. alphabet[alphabet.index(c) + 2] end)\n  -- Rotate the string.\n\
    \  s = s:gsub(\"(.)\", function (c) return alphabet[alphabet.index(c) + 1] end)\n\
    \  return s\nend", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  -- Create\
    \ an empty string with the size of s plus 1 since the \n  -- first letter is going\
    \ to be the alphabet \n  local encrypted = string.rep(alphabet, string.len(s)\
    \ + 1)\n  -- Iterate through the string and rotate each letter down by 2\n  --\
    \ then add the letter to the encrypted string\n  for i = 1, string.len(s) do\n\
    \    local letter = string.sub(alphabet, i, i + 1)\n    local position = #alphabet\n\
    \    alphabet = alphabet:sub(1, position - 2)\n    alphabet = alphabet:sub(1,\
    \ position - 1) + letter\n    position = position + 1\n    encrypted:sub(i, i)\
    \ = alphabet\n  end\n  return encrypted\nend", "    local encrypted = ''\n   \
    \ local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    for i = 1, #s do\n\
    \        local letter = alphabet:sub(i,i)\n        local n = string.len(s) - i\n\
    \        \n        local rotatedLetter = string.sub(alphabet, i+1, i+1)\n    \
    \    \n        if n % 2 == 1 then\n            rotatedLetter = string.sub(rotatedLetter,\
    \ #rotatedLetter, #rotatedLetter-1)\n        end\n        \n        encrypted\
    \ = string.sub(encrypted, #encrypted+1, #encrypted+1) + rotatedLetter\n    end\n\
    \    \n    return encrypted\nend", "  -- If the input string is blank, return\
    \ an empty string since nothing \n  -- needs to be encrypted.\n  -- Otherwise,\
    \ create a new string that is the same length as the input \n  -- string, but\
    \ with all uppercase letters shifted down by two multiplied by \n  -- two places.\n\
    \  local function shift_string(x)\n    local new_string = string.gsub(x, '([A-Z])',\
    \ function(c)\n      return string.char(tonumber(c) + 2)\n    end)\n    return\
    \ new_string\n  end\n  -- Return a list with each letter of the alphabet shifted\
    \ down by two\n  -- and then the list returned is appended to the alphabet list.\n\
    \  return string.gsub(shift_string(s), \"([a-z])\", function(c)\n    return string.char(tonumber(c)\
    \ - 2)\n  end .. \"[\" .. string.sub(shift_string(s), '([a-z])', 2) .. \"]\")\n\
    end", "    local alpha = {\n            ['a'] = 'b',\n            ['b'] = 'a',\n\
    \            ['c'] = 'd',\n            ['d'] = 'c',\n            ['a'] .. 'b'\
    \ .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i' .. 'j',\n            ['a']\
    \ .. 'b' .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i' .. 'j',\n          \
    \  ['a'] .. 'b' .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i' .. 'j',\n   \
    \         ['a'] .. 'b' .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i' .. 'j',\n\
    \            ['a'] .. 'b' .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i' ..\
    \ 'j'\n        }", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local encrypted\
    \ = \"\"", "  local alpha = \"abcdefghijklmnopqrstuvwxyz\"\n  local alpha_index\
    \ = string.len(alpha) - 1\n  return string.sub(alpha,alpha_index*2,alpha_index*2+2)\
    \ .. string.sub(alpha,alpha_index*2+2,alpha_index*2) .. string.sub(alpha,alpha_index*2,alpha_index*2+2)\n\
    end", "    return string.gsub(s, string.char(65), function(c)\n        -- Get\
    \ a new alphabet letter with two characters rotated\n        local c = string.sub(alphabet,\
    \ string.find(alphabet, string.lower(c)) + 1, \n                string.find(alphabet,\
    \ string.lower(c), 1, string.len(alphabet)))\n        -- Do the same with uppercase\
    \ letters\n        return string.gsub(string.upper(c), string.char(65), function(c)\n\
    \            -- Get the new alphabet letter\n            c = string.sub(alphabet,\
    \ string.find(alphabet, string.upper(c)) + 1, \n                    string.find(alphabet,\
    \ string.upper(c), 1, string.len(alphabet)))\n            return string.format(\"\
    %c%s%c\", string.char(c), string.char(string.lower(c)), string.char(c))\n    \
    \    end)\n    end)\nend", "  local t = {}\n  for i = 1, #s do\n    local c =\
    \ string.sub(s,i,i)\n    table.insert(t,string.sub(c,1,2))\n    table.insert(t,string.sub(c,3,4))\n\
    \  end\n  return table.concat(t, \"\")\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local new_alphabet = alphabet:sub(1, alphabet:len() - 1):sub(1, alphabet:len()\
    \ - 1)\n    local output = {}", "   local result = \"\"\n   for i = 1,#s do\n\
    \      local char = string.sub(s,i,i)\n      -- Rotate alphabet by two places\n\
    \      local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n      -- Shift alphabet\
    \ by two letters by two places\n      alphabet = alphabet:sub(1,1) + alphabet:sub(2,2)\n\
    \      -- Map the char to its corresponding letter in the alphabet.\n      char\
    \ = alphabet:sub(string.tolower(char))\n      -- Concatenate char and the rotated\
    \ alphabet\n      result = result .. char\n   end\n   return result\nend", " \
    \ local alpha = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', \n      'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', \n      'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', \n      'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', \n      'u', 'v', 'w', 'x', 'y', 'z'}\n \
    \ local alphaIndex = {}\n  \n  -- First loop through all the letters and collect\
    \ them in a dictionary\n  -- where the keys are the letters and the values are\
    \ the indices in the \n  -- alphabet of the letters.\n  for i = 1, #s do\n   \
    \ alphaIndex[alpha[i]] = i\n  end", "  -- The alphabet\n  local alphabet = {\n\
    \    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n\
    \    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n\
    \    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n\
    \    'y',\n    'z',\n  };\n  -- Create the new string to be encrypted\n  local\
    \ encrypted_string = '';\n  -- Loop over the string and add the corresponding\
    \ letter to the new string\n  for i = 1, #s do\n    -- Look up the letter in the\
    \ alphabet\n    local letter = alphabet[alphabet + 2];\n    -- Add the letter\
    \ to the new string\n    encrypted_string = encrypted_string .. letter;\n  end\n\
    \  return encrypted_string;\nend", "  -- Store the alphabet in a table with its\
    \ key on the right and the\n  -- value on the left. For example, the key 'c' would\
    \ be the value 'h' and\n  -- the key 'i' would be the value 'j'.\n  local alphabet\
    \ = {\n    c = 'h',\n    i = 'j',\n    g = 'f',\n    e = 'i',\n    h = 'k',\n\
    \    l = 'm',\n    n = 'n',\n    o = 'p',\n  }\n  -- Rotate the string.\n  s =\
    \ rotate(s)\n  -- Return an empty string if given an empty string.\n  if s ==\
    \ '' then return '' end\n  -- For each letter, remove it from the alphabet and\
    \ add it on the\n  -- other end of the alphabet.\n  local s = ''\n  for i = 0,\
    \ #s do\n    s = alphabet[#alphabet][alphabet[s]]\n  end\n  -- Return the string.\n\
    \  return s\nend", '  local alphabet = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.',
  "\tlocal alphabet = {\n\t\t['q'] = string.char( string.len(s) - 1 ),\n\t\t['w']\
    \ = string.char( string.len(s) - 1 ),\n\t\t['e'] = string.char( string.len(s)\
    \ - 1 ),\n\t\t['r'] = string.char( string.len(s) - 1 ),\n\t\t['t'] = string.char(\
    \ string.len(s) - 1 ),\n\t\t['y'] = string.char( string.len(s) - 1 ),\n\t\t['u']\
    \ = string.char( string.len(s) - 1 ),\n\t\t['i'] = string.char( string.len(s)\
    \ - 1 ),\n\t\t['o'] = string.char( string.len(s) - 1 ),\n\t\t['p'] = string.char(\
    \ string.len(s) - 1 ),\n\t\t['a'] = string.char( string.len(s) - 1 ),\n\t\t['s']\
    \ = string.char( string.len(s) - 1 ),\n\t\t['d'] = string.char( string.len(s)\
    \ - 1 ),\n\t\t['f'] = string.char( string.len(s) - 1 ),\n\t\t['g'] = string.char(\
    \ string.len(s) - 1 ),\n\t\t['h'] = string.char( string.len(s) - 1 ),\n\t\t['j']\
    \ = string.char( string.len(s) - 1 ),\n\t\t['k'] = string.char( string.len(s)\
    \ - 1 ),\n\t\t['l'] = string.char( string.len(s) - 1 ),\n\t\t['z'] = string.char(\
    \ string.len(s) - 1 ),\n\t\t['x'] = string.char( string.len(s) - 1 ),\n\t\t['c']\
    \ = string.char( string.len(s) - 1 ),\n\t\t['v'] = string.char( string.len(s)\
    \ - 1 ),\n\t\t['b'] = string.char( string.len(s) - 1 ),\n\t\t['n'] = string.char(\
    \ string.len(s) - 1 ),\n\t\t['m'] = string.char( string.len(s) - 1 )\n\t}\n\t\
    local c = ''\n\tfor i = 1, string.len(s) do \n\t\tc = c .. alphabet[s[string.len(s)\
    \ - i - 2]] \n\tend\n\treturn c\nend", "  local alphabet = string.gsub(string.gsub(\"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", \"1\", \"z\"\
    ), \"2\", \"2\")\n  local ret = \"\"\n  for i = 1, string.len(s) do\n    ret =\
    \ ret .. alphabet[(string.len(alphabet) * string.len(alphabet)) - string.len(alphabet)\
    \ + alphabet.find(s[i])] .. string.sub(s,i, i + 1)\n  end\n  return ret\nend",
  "   assert(type(s) == 'string')", "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local shift = 3\n    local news = \"\"\n    for i = 1, #s do\n        local\
    \ char = alphabet:sub(i,i)\n        local next = alphabet:sub(i+shift, i+shift)\n\
    \        local temp = (char:lower()+next):sub(2)\n        news = news .. temp\n\
    \    end\n    return news\nend", "\tlocal alphabet = {'z','x','y','w','v','u','t','s','r','q','p','o','n','m'}\n\
    \tlocal shift = 2\n\tlocal encrypted = {}\n\tlocal j = 0\n\tfor i = 1, #s do\n\
    \t\tlocal k = math.mod(i + shift, #alphabet)\n\t\ttable.insert(encrypted, alphabet[k])\n\
    \tend\n\treturn table.concat(encrypted)\nend", "    local alphabet = {\n     \
    \   {'a'},\n        {'b'},\n        {'c'},\n        {'d'},\n        {'e'},\n \
    \       {'f'},\n        {'g'},\n        {'h'},\n        {'i'},\n        {'j'},\n\
    \        {'k'},\n        {'l'},\n        {'m'},\n        {'n'},\n        {'o'},\n\
    \        {'p'},\n        {'q'},\n        {'r'},\n        {'s'},\n        {'t'},\n\
    \        {'u'},\n        {'v'},\n        {'w'},\n        {'x'},\n        {'y'},\n\
    \        {'z'},\n        {string.sub('z', 1, 1)},\n        {string.sub('z', 1,\
    \ 2)},\n        {string.sub('z', 1, 3)},\n        {string.sub('z', 1, 4)},\n \
    \       {string.sub('z', 1, 5)},\n        {string.sub('z', 1, 6)},\n        {string.sub('z',\
    \ 1, 7)},\n        {string.sub('z', 1, 8)},\n        {string.sub('z', 1, 9)},\n\
    \        {string.sub('z', 1, 10)},\n        {string.sub('z', 1, 11)},\n      \
    \  {string.sub('z', 1, 12)},\n        {string.sub('z', 1, 13)},\n        {string.sub('z',\
    \ 1, 14)},\n        {string.sub('z', 1, 15)},\n        {string.sub('z', 1, 16)},\n\
    \        {string.sub('z', 1, 17)},\n        {string.sub('z', 1, 18)},\n      \
    \  {string.sub('z', 1, 19)},\n        {string.sub('z', 1, 20)},\n        {string.sub('z',\
    \ 1, 21)},\n        {string.sub('z', 1, 22)},\n        {string.sub('z', 1, 23)},\n\
    \        {string.sub('z', 1, 24)},\n        {string.sub('z', 1, 25)},\n      \
    \  {string.sub('z', 1, 26)},\n        {string.sub('z', 1, 27)},\n        {string.sub('z',\
    \ 1, 28)},\n        {string.sub('z', 1, 29)},\n        {string.sub('z', 1, 30)},\n\
    \        {string.sub('z', 1, 31)},\n        {string.sub('z', 1, 32)},\n      \
    \  {string.sub('z', 1, 33)},\n        {string.sub('z', 1, 34)},\n        {string.sub('z',\
    \ 1, 35)},\n        {string.sub('z', 1, 36)},\n        {string.sub('z', 1, 37)},\n\
    \        {string.sub('z', 1, 38)},\n        {string.sub('z', 1, 39)},\n      \
    \  {string.sub('z', 1, 40)},\n        {string.sub('z', 1, 41)},\n        {string.sub('z',\
    \ 1, 42)},\n        {string.sub('z', 1, 43)},\n", "  local alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local alphabetLen = #alphabet\n  local result = ''\n  for i = 1, #s do\n  \
    \  -- To find the index of the letter we want to shift, we find the \n    -- letter\
    \ that would come after i in alphabet and subtract from i\n    -- because indices\
    \ start at 1.\n    -- For example:\n    -- The letter at index 2 in alphabet is\
    \ b. Therefore, we subtract 2 from\n    -- i to get the index of the letter b\
    \ that would come after i in alphabet.\n    -- The subtraction is 3, so we find\
    \ the letter that comes after i in the\n    -- alphabet that comes after i (i.e.\
    \ alphabet[3]).\n    local shiftIndex = alphabetLen - i - 2\n    -- Find the new\
    \ letter that comes after i in alphabet and add it to result\n    -- We add because\
    \ we want the new letter that comes after i to be the \n    -- letter that we\
    \ shift down by two so that it comes after i. For example,\n    -- If alphabet[i]\
    \ is b and alphabet[i+1] is y, then we want to find the \n    -- letter that comes\
    \ after i in alphabet (alphabet[3]) and add it after i.\n    local newLetter =\
    \ alphabet[shiftIndex]\n    result = result .. newLetter\n  end\n  return result\n\
    end", "  local alpha = 'abcdefghijklmnopqrstuvwxyz'\n  local alpha_len = #alpha\n\
    \  local result = ''\n  local idx = 0\n  while idx <= #s do\n    local char =\
    \ s:sub(1,1)\n    local index = alpha.find(char)\n    idx = idx + 1\n    if index\
    \ > -1 then\n      result = result .. alpha[alpha.len - index:index] .. alpha[alpha.len\
    \ - index:index + 2]\n    else\n      result = result .. char\n    end\n  end\n\
    \  return result\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n \
    \ local new_s = \"\"\n  for i=1,#s,2 do\n    local pos = alphabet .. alphabet:sub(i,i+2):sub(1)\n\
    \    new_s = new_s .. alphabet:sub(alphabet + pos + 1,alphabet + pos + 2) .. alphabet:sub(alphabet\
    \ + pos + 2,alphabet + pos + 3)\n  end\n  return new_s\nend", "  -- Reverse the\
    \ string\n  s = string.gsub(s, '[%z]', '')\n  -- Rotate the letters in the string\n\
    \  s = string.gsub(s, string.char(97 + 26), '%a')\n  -- Reverse the rotated string\n\
    \  s = string.gsub(s, '%a', '[%z]')\n  return s\nend", "  -- Write your code here\n\
    end", "  return s:gsub(\"[^\" .. alphabet:gsub(\"(.)\", function(c) return alphabet:sub(c,\
    \ 1, alphabet:len()-1) - 1 .. alphabet:sub(c, 1, alphabet:len()-1) end .. \"]\"\
    , \"\")\nend", "  local news = ''\n  local alph = ALPHABET\n  for i = 1, #s do\n\
    \    news = news .. alph[#alph][alph[i]]\n  end\n  return news\nend", "  local\
    \ alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  local news\
    \ = ''\n  local length\n  for i = 1, #s do\n    length = #alphabet\n    -- rotate\
    \ by 2 places so the letters shift down by 2 places\n    news = alphabet[(#alphabet)\
    \ * (i + 1)] + news \n    alphabet = alphabet:sub(1, length - 1)\n  end\n  return\
    \ news\nend", "    -- Convert the string to an array.\n    local arr = {s}\n \
    \   -- Rotate the characters so they shift down by two multiplied to\n    -- two\
    \ places.\n    for i=1, #arr do\n        arr[i] = arr[i]:sub(1,2)..arr[i]:sub(3)\n\
    \    end\n    return table.concat(arr)\nend", "  assert(type(s) == 'string', 'Argument\
    \ must be a string.')\n  local s = s:lower()\n  -- Rotate down each letter by\
    \ 2 places.\n  -- This results in a rotation of 'a' = 'aa', 'b' = 'ab',\n  --\
    \ 'c' = 'ac', etc.\n  local alphabet = {}\n  local i = 0\n  while i < #s do\n\
    \    alphabet[i] = s:sub(i, i + 1)\n    i = i + 2\n  end\n  -- The resulting string\
    \ will be the concatenation of rotated letters\n  -- with the original string\
    \ being appended to the end.\n  return alphabet[1]..alphabet[2]..alphabet[3]..alphabet[4]..alphabet[5]..alphabet[6]..alphabet[7]..alphabet[8]..alphabet[9]..alphabet[10]+alphabet[11]+alphabet[12]+alphabet[13]+alphabet[14]+alphabet[15]\n\
    end", "\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\tlocal alphabetLength\
    \ = #alphabet\n\tlocal letterToEncrypt = ''\n\tlocal i = 0\n\tlocal encrypted\
    \ = ''\n\t\n\twhile i <= #s do\n\t\tlocal currentLetter = string.sub(s,i,i)\n\t\
    \tlocal j = letterToEncrypt:find(currentLetter)\n\t\t\n\t\tif j >= 0 then\n\t\t\
    \tletterToEncrypt = letterToEncrypt .. alphabet[j + 1]\n\t\telse\n\t\t\tletterToEncrypt\
    \ = letterToEncrypt .. currentLetter\n\t\tend\n\t\ti = i + 2\n\tend\n\t\n\treturn\
    \ letterToEncrypt\nend", "   assert(type(s) == 'string', 'Argument to encrypt()\
    \ must be a string.')\n   local alphabet = {\n      -- The English alphabet\n\
    \      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', \n   \
    \   'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n      }\n\
    \   local result = ''\n   for i=1, #s, 1 do\n      result = alphabet[#alphabet]\
    \ .. alphabet[#alphabet]\n      for j = #alphabet, 2, -1 do\n         result =\
    \ alphabet[#alphabet] .. alphabet[#alphabet]\n      end\n      alphabet = alphabet\n\
    \   end\n   return result\nend", "   local alphabet = {\n      -- A single letter\
    \ that is the same as the alphabet itself,\n      -- used for testing if the first\
    \ letter should be \n      -- added or subtracted.\n      alphabet = s:sub(1,1):lower(),\n\
    \      -- A letter for every letter of the alphabet plus an extra\n      -- alphabet\
    \ item for testing if the first letter is a multiple\n      -- of the alphabet\
    \ item.\n      alphabet = alphabet:sub(1):sub(1,alphabet:sub(1):length() + 1):append(alphabet:sub(1)):append(alphabet),\n\
    \      -- A letter for every letter of the alphabet plus an extra\n      -- alphabet\
    \ item for every letter of the alphabet plus an extra\n      -- alphabet item\
    \ for every letter of the alphabet plus an extra\n      -- alphabet item for every\
    \ letter of the alphabet plus an extra\n      -- alphabet item for every letter\
    \ of the alphabet plus an extra\n      -- alphabet item for every letter of the\
    \ alphabet plus an extra\n      -- alphabet item for every letter of the alphabet\
    \ plus an extra\n      -- alphabet item for every letter of the alphabet plus\
    \ an extra\n      -- alphabet item for every letter of the alphabet plus an extra\n\
    \      -- alphabet item for every letter of the alphabet plus an extra\n     \
    \ -- alphabet item for every letter of the alphabet plus an extra\n      -- alphabet\
    \ item for every letter of the alphabet plus an extra\n      -- alphabet item\
    \ for every letter of the alphabet plus an extra\n      -- alphabet item for every\
    \ letter of the alphabet plus an extra\n      -- alphabet item for every letter\
    \ of the alphabet plus an extra\n      -- alphabet item for every letter of the\
    \ alphabet plus an extra\n      -- alphabet item for every letter of the alphabet\
    \ plus an extra\n      -- alphabet item for every letter of the alphabet plus\
    \ an extra\n      -- alphabet item for every letter of the alphabet plus an extra\n\
    \      -- alphabet item for every letter of the alphabet plus an extra\n     \
    \ -- alphabet item for every letter of the alphabet plus an extra\n      -- alphabet\
    \ item for every letter of the alphabet plus an extra\n      -- alphabet item\
    \ for every letter of the alphabet plus an extra\n      -- alphabet item for every\
    \ letter of the alphabet plus an extra\n      -- alphabet item for every letter\
    \ of the alphabet plus an extra\n      -- alphabet item for every letter of the\
    \ alphabet plus an extra\n      -- alphabet item for every letter of the alphabet\
    \ plus an extra\n      -- alphabet item for every letter of the alphabet plus\
    \ an extra\n      -- alphabet item for every letter of the alphabet plus an extra\n\
    \      ", "  s = string.rep(s,math.ceil(string.len(s)/2))\n  return s:gsub('.',function(x)\n\
    \    return string.sub(x,1,2):sub(2,3):sub(3)\n  end)\nend", "  local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  local newS = \"\"\n  for i = 1, #s do\n  \
    \  newS = newS .. alphabet:sub(i, i+2):gsub(\"(.)(.)\", \"%2\\2%1\")\n  end\n\
    \  return newS\nend", "    local r = ''\n    \n    for i = #s, 2, -1 do\n    \
    \    r = string.sub(s, i, i+1) .. r\n    end\n    \n    return string.sub(s, 1,\
    \ r) .. r\nend", "  local keys = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\
    \ 'z' }\n  local key_table = { }\n  \n  -- We want to rotate all the letters in\
    \ the string by the number of \n  -- spaces necessary for the alphabet, that is,\
    \ 2 to the power of the\n  -- length of the alphabet. \n  for i = 1, #s do\n \
    \   -- The key value will be the number of spaces in the alphabet times the\n\
    \    -- character in the string.\n    local key = 2 ^ #keys\n    \n    -- Rotate\
    \ the key by two by multiplying it by two. The resulting key will\n    -- be 2\
    \ to the power of 2 times a, b ... z. Since the key is two to the\n    -- power\
    \ of 2 times 'a', we subtract that from the key.\n    key = key - keys[key] +\
    \ keys[key]\n    \n    -- Store the key in the table.\n    table.insert(key_table,\
    \ key)\n  end\n  \n  -- Now we must rotate the alphabet by each of the key values\
    \ in the table.\n  for i = #keys, 1, -1 do\n    -- Rotate the alphabet by two.\n\
    \    s = string.gsub(s, '%c', string.char(#keys) * keys)\n    \n    -- Substitute\
    \ the rotated alphabet back into the string.\n    s = string.gsub(s, '%c%s', string.char(#keys)\
    \ * keys)\n    \n    -- Rotate the alphabet by the key value.\n    s = string.gsub(s,\
    \ '%c%s', string.char(#key_table) * key_table[i])\n    \n    -- Return the string.\n\
    \    return s\n  end\nend", "  -- Initialize our ciphertext to a random character\n\
    \  local c = math.random(#alphabet) + 1\n  -- We start by iterating over the string\
    \ one character at a time\n  -- Shifting each character by two places in the alphabet\n\
    \  for i = 1, #s do\n    -- Multiply the character by two\n    c = (c + math.random())\
    \ % #alphabet\n    -- Shift the character two places in the alphabet\n    alphabet[alphabet[c]]\
    \ = alphabet[c+1]\n    -- Shift the character one place in the alphabet\n    alphabet[alphabet[c+1]]\
    \ = alphabet[c]\n    -- Swap the characters in the alphabet to accomplish our\
    \ \n    -- encryption\n    alphabet[c], alphabet[c+1] = alphabet[c+1], alphabet[c]\n\
    \  end\n  -- Return the ciphertext string\n  return s\nend", "\tlocal rot1 = string.sub(s,\
    \ 1, 1)\n\tlocal rot2 = string.sub(s, 3, 3)\n\tlocal rot3 = string.sub(s, 1, 3)\n\
    \treturn string.char(rot1 .. rot2 .. rot3)\nend", "  assert(type(s) ~= 'string')\n\
    \  assert(type(s) ~= 'table')\n  assert(#s < 4)", "\tassert(type(s) ~= 'string',\
    \ string.format('Encrypt: Invalid argument: %s, expecting a string.', s))\n\t\
    assert(type(alphabet) === 'table', string.format('Encrypt: Invalid argument: %s,\
    \ expecting a table.', s))", "\tlocal alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\tlocal rot_alphabet = alphabet:sub(1, alphabet:len() - 1)\n\treturn (rot_alphabet:sub((alphabet:len()\
    \ - 1):len() + 1):sub(-(alphabet:len() - 1):len() + 1):sub((alphabet:len() - 1):len()\
    \ + 1):sub(-(alphabet:len() - 1):len() + 1):sub(alphabet:len() - 1):sub(1, alphabet:len()\
    \ - 1)):sub(alphabet:len() - 1):sub(-(alphabet:len() - 1):len() + 1):sub((alphabet:len()\
    \ - 1):len() + 1):sub(-(alphabet:len() - 1):len() + 1):sub(alphabet:len() - 1):sub(1,\
    \ alphabet:len(-1))):sub(alphabet:len() - 1):sub(-(alphabet:len() - 1):len() +\
    \ 1):sub((alphabet:len() - 1):len() + 1):sub(-(alphabet:len() - 1):len() + 1):sub(alphabet:len()\
    \ - 1):sub(1, alphabet:len(-1))):sub(alphabet:len() - 1):sub(-(alphabet:len()\
    \ - 1):len() + 1):sub((alphabet:len() - 1):len() + 1):sub(-(alphabet:len() - 1):len()\
    \ + 1):sub(alphabet:len() - 1):sub(1, alphabet:len(-1))))\nend", "    local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    -- Rotate the letters down\n    for i\
    \ = #alphabet, 1, -1 do\n        -- Iterate through each letter and swap it with\
    \ its neighbour\n        for j = i, #alphabet do\n            if alphabet[j] ==\
    \ alphabet[i] then\n                alphabet[i] = alphabet[j - 1]\n          \
    \  end\n        end\n    end", "  -- Note: this function must be able to accept\
    \ non-alpha strings as \n  -- input. For example, encrypt('asdfghjkl') should\
    \ return 'ewhjklnop'.\n  -- This function doesn't need to be recursive.\n  local\
    \ function rotate_letters(s)\n    -- Rotate alphabet so letters shift down\n \
    \   for i = #alphabet, 2, -1 do\n      -- Shift alphabet up by two letters\n \
    \     alphabet[i] = alphabet[i-1]\n    end\n    local output = ''\n    -- Rotate\
    \ letters in string by two\n    for i = 1, #s do\n      -- Rotate alphabet letters\
    \ down and add current letter\n      -- Note: The key here is 2 and not 2 mod\
    \ #alphabet because we \n      -- want to rotate letters down by two and not up\
    \ by one. \n      alphabet[#alphabet] = alphabet[#alphabet] .. alphabet[i]\n \
    \     -- Add letter to output string\n      output = output .. alphabet[#alphabet]\n\
    \      -- Rotate alphabet letters up\n      alphabet[i] = alphabet[i-1]\n    end\n\
    \    return output\n  end\n  return rotate_letters(s)\nend", "  -- Create a variable\
    \ that holds the length of the alphabet and\n  -- a variable that holds the alphabet\
    \ itself.\n  local l=#alphabet -- l: the length of the alphabet\n  local a=alphabet\
    \ -- a: holds the alphabet\n  -- Create an empty string that is to be encrypted\
    \ with the alphabet\n  -- being rotated so that all letters are shifted down by\
    \ two.\n  local b=\"\"\n  for i=1,#s do \n    -- Get the letter in the string\
    \ and place it in variable i. \n    -- If i is odd, place the letter in variable\
    \ i, else place it in variable (i-1)\n    -- then add that to variable b\n   \
    \ b=b..a[(i % l)+1] \n  end\n  return b \nend", "    local result = \"\"\n   \
    \ for i = 1, #s do\n        local charToRotate = (#alphabet) * (i -- shift down)\n\
    \        char = alphabet[charToRotate]\n        char = alphabet[charToRotate +\
    \ 1]\n        result = result .. char\n    end\n    return result\nend", "   \
    \ local c = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' }\n    local\
    \ n = #s\n    local c1 = c\n    c[1] = c[n]\n    c[n] = c[n-2]\n    c[n-2] = c[1]\n\
    \    c[1] = c1[c]\n    c[2] = c1[c+1]\n    c[3] = c1[c+2]\n    c[4] = c1[c+3]\n\
    \    c[5] = c1[c+4]\n    c[6] = c1[c+5]\n    c[7] = c1[c+6]\n    c[8] = c1[c+7]\n\
    \    c[9] = c1[c+8]\n    c[10] = c1[c+9]\n    c[11] = c1[c+10]\n    c[12] = c1[c+11]\n\
    \    c[13] = c1[c+12]\n    c[14] = c1[c+13]\n    c[15] = c1[c+14]\n    c[16] =\
    \ c1[c+15]\n    return c[1]..c[2]..c[3]..c[4]..c[5].. c[6]..c[7]..c[8]..c[9]..c[10]..c[11]..c[12]..c[13]..c[14]..c[15]..c[16]\n\
    end", "  -- Initialize a variable to be used as the output string \n  -- that\
    \ is returned. \n  local output = ''\n  -- Loop through every character in string\
    \ s (i.e., every letter in \n  -- string s). \n  for i=1, #s do \n    -- Get the\
    \ letter at position i in the alphabet and store it in a \n    -- variable called\
    \ letter. \n    local letter = alphabet:sub(i,i)\n    -- If the letter at position\
    \ i is 'z', rotate this letter two \n    -- places to the left (i.e., rotate 'z'\
    \ into 'a'), otherwise rotate \n    -- this letter two places to the right (i.e.,\
    \ rotate 'a' into 'z'). \n    -- This is accomplished using the mod operator (the\
    \ % operator). \n    letter = letter == 'z' ? 'a' : letter == 'a' ? 'z' : letter\n\
    \    -- Append the letter that corresponds to the rotated alphabet \n    -- letter\
    \ to the output string.\n    output = output .. letter\n  end\n  -- Return the\
    \ output string.\n  return output\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local i, n = 1, #alphabet\n  local news = \"\"\n  while i <= #s do\n    local\
    \ c = alphabet[i % n]\n    news = alphabet[(i - 1) / n] .. c .. alphabet[(i +\
    \ 1) / n] .. news \n    i = i + 2\n  end\n  return news\nend", "    assert(#s\
    \ <= 26)\n    local alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    return alphabet:sub(1, alphabet:sub(#alphabet, alphabet:len())) .. alphabet:sub((#alphabet+1),alphabet:len())\n\
    end", "   local alphabet = {\n      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k',\n      'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n\
    \      'x', 'y', 'z'\n   };\n   local result = '';\n   for i = #s , 1, -1 do\n\
    \      local c = alphabet[#alphabet];\n      alphabet[#alphabet] = alphabet[#alphabet-1];\n\
    \      alphabet[#alphabet-1] = c;\n      result = result .. alphabet[#alphabet];\n\
    \   end\n   return result;\nend", "  s = s:gsub(\"[^\"..alphabet..\"]\", \"\"\
    )\n  local n = #s\n  local key = {}\n  for i = 1, n do\n    key[#key+1] = alphabet\
    \ -- insert the alphabet at the beginning\n  end\n  table.sort(key)\n  local i\
    \ = 1\n  local c = 1\n  local alpha = {}\n  for i = 1, n do\n    alpha[c] = alphabet\n\
    \    c = c + 2\n  end\n  for i = 1, n do\n    alpha[i] = alphabet\n  end\n  for\
    \ i = 1, n do\n    alpha[i - 1] = alphabet\n  end\n  local result = ''\n  local\
    \ i = 1\n  for i = 1, n do\n    local c = 0\n    while true do\n      local j\
    \ = i % #alpha\n      if j == 0 then\n        break\n      end\n      if i < n\
    \ then\n        local x = key[j]\n        if alpha[j] == x and alphabet:sub(x,\
    \ x+1) == alpha[j+1] then\n          i = i + 1\n        else\n          local\
    \ temp = alpha[j]\n          alpha[j] = alpha[j+1]\n          alpha[j+1] = temp\n\
    \          i = i - 1\n        end\n      else\n        i = i + 1\n      end\n\
    \    end\n    local temp = ''\n    for j = 1, i do\n      temp = temp..alphabet\n\
    \    end\n    result = temp..result\n  end\n  return result\nend", "  local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  local rot = ''\n  for i = #alphabet, 1, -1\
    \ do\n    local c = alphabet[i]\n    local shift = math.floor(i / 2)\n    local\
    \ c2 = alphabet[i + shift]\n    local t = ''\n    for j = #s, 1, -1 do\n     \
    \ local a = s[j]\n      t = (t .. c2) or (t .. a) \n    end\n    rot = (rot ..\
    \ c) or (rot .. t)\n  end\n  return rot\nend", "  -- First, convert string to\
    \ lowercase and remove spaces.\n  s = string.lower(string.gsub(s, '%S', ''))\n\
    \  -- Rotate alphabet by 2 and each character by 2.\n  -- Start with upper and\
    \ lowercase alphabets rotated 180 degrees.\n  local alphabet = string.char(string.char(\"\
    A\")..string.char(\"Z\"))\n  alphabet = alphabet..string.char(string.char(\"a\"\
    )..string.char(\"z\"))\n  alphabet = alphabet..string.char(string.char(\"A\")..string.char(\"\
    Z\"))\n  alphabet = alphabet..string.char(string.char(\"a\")..string.char(\"z\"\
    ))\n  -- Add space at the end of alphabet to make it the same length as s.\n \
    \ alphabet = alphabet..string.char(string.char(\"A\")..string.char(\"Z\"))\n \
    \ alphabet = alphabet..string.char(string.char(\"a\")..string.char(\"z\"))\n \
    \ -- Convert the string to a list of characters.\n  local char_array = string.gsub(s,\
    \ '[^' .. alphabet .. ']', '')\n  -- Create a stack to reverse the alphabet.\n\
    \  local stack = setmetatable({}, {__mode=\"v\"})\n  for i = 1, #alphabet do\n\
    \    stack[alphabet[i]:byte()] = true\n  end\n  -- Repeatedly pop alphabet from\
    \ stack and push characters of s to stack.\n  -- Push characters of s to stack.\n\
    \  for i = 1, #char_array do\n    if stack[alphabet[#alphabet]:byte()] then\n\
    \      stack[alphabet[#alphabet]:byte()] = false\n      table.insert(stack, char_array[i]:byte())\n\
    \    end\n  end\n  -- Convert stack to string.\n  local result = ''\n  for i =\
    \ 1, #stack do\n    result = result..alphabet[stack[i]]\n  end\n  return result\n\
    end", "    -- Convert string to list of chars\n    -- Make sure all chars are\
    \ lower case to avoid case-sensitive rotations\n    local s_chars = s:gsub(\"\
    [%l]+\",'')\n    s_chars = s_chars:gsub(\"[%0]\",'')\n    -- Rotate characters\
    \ by 2 places, double each letter\n    -- This ensures that only 2 letters are\
    \ replaced in each rotation\n    s_chars = s_chars:gsub(\"([a-z])\",function(c)\n\
    \        -- Ignore case for now\n        if c:lower() == c then\n            return\
    \ 'x'\n        end\n        -- Rotate by 2 places\n        -- This ensures that\
    \ only 1 letter is replaced each rotation\n        local a = math.floor((c:lower()):byte()\
    \ / 26)\n        local b = math.floor((c:lower()):byte() % 26)\n        return\
    \ 'a' + (math.floor((b + 2 * a) / 2) + a)\n    end)\n    -- Convert list back\
    \ to string\n    return s_chars:gsub(\"([a-z])\",function(c)\n        -- Ignore\
    \ case for now\n        if c:lower() == c then\n            return 'x'\n     \
    \   end\n        -- Rotate by 2 places\n        -- This ensures that only 1 letter\
    \ is replaced each rotation\n        local a = math.floor((c:lower()):byte() /\
    \ 26)\n        local b = math.floor((c:lower()):byte() % 26)\n        return 'a'\
    \ + (math.floor((b + 2 * a) / 2) + a)\n    end)\nend\nencrypt = encrypt", "  \
    \  local cipher = {}\n    local count = 1\n    for i,v in string.gmatch(s, '[^'..alphabet..'a-z]')\
    \ do\n        table.insert(cipher, alphabet[math.random(#alphabet) + 1])\n   \
    \     count = count + 1\n    end\n    table.insert(cipher, alphabet[math.random(#alphabet)\
    \ + 1])\n    local i = 0\n    while i <= #cipher do\n        table.insert(cipher,\
    \ cipher[i])\n        i = i + 1\n    end\n    return table.concat(cipher, \"\"\
    )\nend", "  -- Base case\n  if s == \"hello\" then\n    return \"lm\"\n  end",
  "    local newString = ''\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n \
    \   for i = 1, #s, 2 do\n        local letter = alphabet % #alphabet\n       \
    \ alphabet = alphabet:sub(1, #alphabet-1)\n        newString = newString .. letter\n\
    \    end\n    return newString\nend", "    -- implement me\nend", "  local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  local alphabetRotated = 'fopqswedcbazhigklnrqji'\n\
    \  local alphabetLength = #alphabet\n  local alphabetLength = #alphabetRotated\n\
    \  local encrypted = ''\n  -- Shift each character one spot to the left\n  while\
    \ #s > 0 do\n    local a = s:sub(#s-1, 1)\n    local b = s:sub(#s-1, #s+1)\n \
    \   local c = s:sub(#s-1, #s-1)\n    -- Shift one character to the right to move\
    \ the character\n    -- two spaces to the right\n    local d = alphabetRotated:sub((alphabetLength\
    \ - alphabetRotated:index(a) + alphabetLength - alphabetRotated:index(b) + 1),\
    \ 1)\n    -- Concatenate all the shifted characters together\n    encrypted =\
    \ encrypted .. alphabetRotated:sub((alphabetLength - alphabetRotated:index(a)\
    \ + alphabetLength - alphabetRotated:index(b) + 1), 1) .. d\n    s = s:sub(#s-1)\n\
    \  end\n  return encrypted\nend", "   local alphabet = {} -- Alphabet is initialized\
    \ to empty table.\n   alphabet[1] = s[1]\n   alphabet[2] = s[2]\n   alphabet[3]\
    \ = s[3]\n   alphabet[4] = s[4]\n   alphabet[5] = s[5]\n   alphabet[6] = s[6]\n\
    \   alphabet[7] = s[7]\n   alphabet[8] = s[8]\n   alphabet[9] = s[9]\n   alphabet[10]\
    \ = s[10]\n   alphabet[11] = s[11]\n   alphabet[12] = s[12]\n   alphabet[13] =\
    \ s[13]\n   alphabet[14] = s[14]\n   alphabet[15] = s[15]\n   alphabet[16] = s[16]\n\
    \   alphabet[17] = s[17]\n   alphabet[18] = s[18]\n   alphabet[19] = s[19]\n \
    \  alphabet[20] = s[20]\n   alphabet[21] = s[21]\n   alphabet[22] = s[22]\n  \
    \ alphabet[23] = s[23]\n   alphabet[24] = s[24]\n   alphabet[25] = s[25]\n   alphabet[26]\
    \ = s[26]\n   alphabet[27] = s[27]\n   alphabet[28] = s[28]\n   alphabet[29] =\
    \ s[29]\n   alphabet[30] = s[30]\n   alphabet[31] = s[31]\n   alphabet[32] = s[32]\n\
    \   alphabet[33] = s[33]\n   alphabet[34] = s[34]\n   alphabet[35] = s[35]\n \
    \  alphabet[36] = s[36]\n   alphabet[37] = s[37]\n   alphabet[38] = s[38]\n  \
    \ alphabet[39] = s[39]\n   alphabet[40] = s[40]\n   alphabet[41] = s[41]\n   alphabet[42]\
    \ = s[42]\n   alphabet[43] = s[43]\n   alphabet[44] = s[44]\n   alphabet[45] =\
    \ s[45]\n   alphabet[46] = s[46]\n   alphabet[47] = s[47]\n   alphabet[48] = s[48]\n\
    \   alphabet[49] = s[49]\n   alphabet[50] = s[50]\n   alphabet[51] = s[51]\n \
    \  alphabet[52] = s[52]\n   alphabet[53] = s[53]\n   alphabet[54] = s[54]\n  \
    \ alphabet[55] = s[55]\n   alphabet[56] = s[56]\n   alphabet[57] = s[57]\n   alphabet[58]\
    \ = s[58]\n   alphabet[59] = s[59]\n   alphabet[6", '    local alphabet = {string.char(tonumber(97
    + 1), tonumber(97 + 2), tonumber(97 + 3), tonumber(97 + 4), tonumber(97 + 5),
    tonumber(97 + 6), tonumber(97 + 7), tonumber(97 + 8), tonumber(97 + 9), tonumber(97
    + 10), tonumber(97 + 11), tonumber(97 + 12), tonumber(97 + 13), tonumber(97 +
    14), tonumber(97 + 15), tonumber(97 + 16), tonumber(97 + 17), tonumber(97 + 18),
    tonumber(97 + 19), tonumber(97 + 20), tonumber(97 + 21), tonumber(97 + 22), tonumber(97
    + 23), tonumber(97 + 24), tonumber(97 + 25), tonumber(97 + 26), tonumber(97 +
    27), tonumber(97 + 28), tonumber(97 + 29), tonumber(97 + 30), tonumber(97 + 31),
    tonumber(97 + 32), tonumber(97 + 33), tonumber(97 + 34), tonumber(97 + 35), tonumber(97
    + 36), tonumber(97 + 37), tonumber(97 + 38), tonumber(97 + 39), tonumber(97 +
    40), tonumber(97 + 41), tonumber(97 + 42), tonumber(97 + 43), tonumber(97 + 44),
    tonumber(97 + 45), tonumber(97 + 46), tonumber(97 + 47), tonumber(97 + 48), tonumber(97
    + 49), tonumber(97 + 50), tonumber(97 + 51), tonumber(97 + 52), tonumber(97 +
    53), tonumber(97 + 54), tonumber(97 + 55), tonumber(97 + 56), tonumber(97 + 57),
    tonumber(97 + 58), tonumber(97 + 59), tonumber(97 + 60), tonumber(97 + 61), tonumber(97
    + 62), tonumber(97 + 63), tonumber(97 + 64), tonumber(97 + 65), tonumber(97 +
    66), tonumber(97 + 67), tonumber(97 + 68), tonumber(97 + 69), tonumber(97 + 70),
    tonumber(97 + 71), tonumber(97 + 72), tonumber(97 + 73), tonumber(', "    -- We\
    \ need to make our alphabet rotate by two letters. To do this, we just\n    --\
    \ shift down the first letter and then shift it up by two multiplied\n    -- to\
    \ two places. This gives the first letter a value of two, which we\n    -- multiply\
    \ by two and add to zero to give the first letter a value of zero.\n    -- We\
    \ repeat this process until we have rotated the alphabet by two or\n    -- greater.\n\
    \    while string.len(s) > 1 do\n        s = string.sub(s, 1, 1) .. string.sub(string.sub(s,2,2),\
    \ 1, 2) .. string.sub(string.sub(s,3,3), 1, 3) \n    end\n    return s\nend",
  "  local rotation = 'abc'\n  -- Rotate to shift the letters down by two multiplied\
    \ to two places.\n  local rotated = rotation.'zyxwvutsrqponm'\n  return rotated:sub(1,rotated:len()\
    \ - 1):sub(1, rotated:len() - 1):sub(2, rotated:len() - 1):sub(3, rotated:len()\
    \ - 1):sub(4, rotated:len() - 1):sub(5)\nend", "  -- Initialize our return variable\
    \ with the empty string.\n  local encrypted_string = ''\n  -- For each character\
    \ in the input string.\n  for i = 1, #s do\n    -- Get a character to put into\
    \ the return string.\n    local c = tolower(s[i])\n    -- Add in the character\
    \ after the alphabet rotation.\n    encrypted_string = encrypted_string .. alphabet[alphabet.index(c)\
    \ + alphabet.length] \n  end\n  -- Return the encrypted string.\n  return encrypted_string\n\
    end", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local rotated_alphabet\
    \ = alphabet:sub(1, 1)\n    local n = #rotated_alphabet\n    local result = {}\n\
    \    local i = 1\n    for letter in s:gmatch'(.)'  do\n        result[i] = alphabet:sub(#rotated_alphabet,\
    \ #alphabet) * (#letter + 2)\n        i = i + 1\n    end\n    for i = 2, n do\n\
    \        result[i] = alphabet:sub(i + 1, i + 1) * (i + 1)\n    end\n    for i\
    \ = 1, n do\n        result[i] = alphabet:sub(i + 1, i + 1) * (#rotated_alphabet)\n\
    \    end\n    for i = n:byte() do\n        result[i] = alphabet:sub(1, 1)\n  \
    \  end\n    return table.concat(result, \"\")\nend", "\tlocal alphabet = {\n\t\
    \t['A'] = {\n\t\t\t['f'] = 'a[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['b']\
    \ = {\n\t\t\t['f'] = 'b[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['c'] = {\n\
    \t\t\t['f'] = 'c[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['d'] = {\n\t\t\t\
    ['f'] = 'd[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['e'] = {\n\t\t\t['f']\
    \ = 'e[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['f'] = {\n\t\t\t['f'] = 'f['\
    \ .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['g'] = {\n\t\t\t['f'] = 'g[' ..\
    \ tostring(#alphabet) .. ']'\n\t\t},\n\t\t['h'] = {\n\t\t\t['f'] = 'h[' .. tostring(#alphabet)\
    \ .. ']'\n\t\t},\n\t\t['i'] = {\n\t\t\t['f'] = 'i[' .. tostring(#alphabet) ..\
    \ ']'\n\t\t},\n\t\t['j'] = {\n\t\t\t['f'] = 'j[' .. tostring(#alphabet) .. ']'\n\
    \t\t},\n\t\t['k'] = {\n\t\t\t['f'] = 'k[' .. tostring(#alphabet) .. ']'\n\t\t\
    },\n\t\t['l'] = {\n\t\t\t['f'] = 'l[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\
    \t['m'] = {\n\t\t\t['f'] = 'm[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['n']\
    \ = {\n\t\t\t['f'] = 'n[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['o'] = {\n\
    \t\t\t['f'] = 'o[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['p'] = {\n\t\t\t\
    ['f'] = 'p[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['q'] = {\n\t\t\t['f']\
    \ = 'q[' .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['r'] = {\n\t\t\t['f'] = 'r['\
    \ .. tostring(#alphabet) .. ']'\n\t\t},\n\t\t['s'] = {\n\t\t\t['f'] = 's[' ..\
    \ tostring(#alphabet) .. ']'\n\t\t},\n\t\t['t'] = {\n\t\t\t['f'] = 't[' .. tostring(#alphabet)\
    \ .. ']'\n\t\t},\n\t\t['u'] = {\n\t\t\t['f'] = 'u['", "    local function helper(str)\n\
    \        -- return str\n        -- first check for empty string\n        if str\
    \ == \"\" then\n            -- return empty string\n            return \"\"\n\
    \        end", "    local t = ''\n    for i = 1, #s do\n        t = t .. string.sub(alphabet,\n\
    \                               ((string.sub(s,i,i) + string.sub(alphabet,i,i+1))\
    \ / 2) -- shift one letter\n                               ,((string.sub(s,i,i)\
    \ - string.sub(alphabet,i,i+1)) / 2)) -- shift one letter\n    end\n    return\
    \ t\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local shift = 2\n  local result = \"\"\n  for i = 1,#s do\n    local ch =\
    \ alphabet:sub(i,i)\n    local x = alphabet and alphabet:sub((i+shift),(i+shift-1))\n\
    \    local y = alphabet and alphabet:sub((i+shift+1),(i+shift+2))\n    local z\
    \ = alphabet and alphabet:sub((i+shift+2),(i+shift+3))\n    \n    local c = \"\
    \"\n    if ch == x then\n      c = ch .. y\n    elseif ch == y then\n      c =\
    \ ch .. x\n    elseif ch == z then\n      c = ch .. y\n    end\n    \n    result\
    \ =  result .. c\n  end\n  return result\nend", "    -- Create a table that holds\
    \ all of the letters of the alphabet we\n    -- will be using. \n    local alphabet\
    \ = {\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ \n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n\
    \    }\n    -- Create a table that holds the shifted letters. \n    local shifted\
    \ = {\n        'd', 'h', 'j', 'n', 'o', 'p', 's', 'r', 't', 'u', 'w', 'x', 'y',\
    \ 'z', \n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ \n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n\
    \    }", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local alphabet2 =\
    \ alphabet:sub(1, alphabet:len()-1)\n  local alphabet3 = alphabet:sub(2, alphabet:len()-2)\n\
    \  local alphabet4 = alphabet:sub(3, alphabet:len()-3)\n  local alphabet5 = alphabet:sub(4,\
    \ alphabet:len()-4)", "  if s == nil then return '' end\n  local t = {}\n  for\
    \ i = #s,1,-1 do table.insert(t, #s:sub(i,i+1)-#s:sub(i-1,i+1)) end\n  t = table.concat(string.gsub(string.gsub(s,\
    \ 'a','t'), 'b','k'), '')\n  t = string.gsub(t, 'a', 'x')\n  t = string.gsub(t,\
    \ 'b', 'd')\n  t = string.gsub(t, 'c', 'w')\n  t = string.gsub(t, 'd', 'z')\n\
    \  t = string.gsub(t, 'e', 'r')\n  t = string.gsub(t, 'f', 'g')\n  t = string.gsub(t,\
    \ 'h', 'j')\n  t = string.gsub(t, 'i', 'o')\n  t = string.gsub(t, 'j', 'a')\n\
    \  t = string.gsub(t, 'k', 'b')\n  t = string.gsub(t, 'l', 'n')\n  t = string.gsub(t,\
    \ 'm', 'm')\n  t = string.gsub(t, 'n', 'z')\n  t = string.gsub(t, 'o', 'r')\n\
    \  t = string.gsub(t, 'p', 'g')\n  t = string.gsub(t, 'q', 'q')\n  t = string.gsub(t,\
    \ 'r', 'a')\n  t = string.gsub(t, 's', 's')\n  t = string.gsub(t, 't', 'x')\n\
    \  t = string.gsub(t, 'u', 'z')\n  t = string.gsub(t, 'v', 'y')\n  t = string.gsub(t,\
    \ 'w', 'x')\n  t = string.gsub(t, 'x', 'z')\n  t = string.gsub(t, 'y', 'r')\n\
    \  t = string.gsub(t, 'z', 'g')\n  t = string.gsub(t, 'A', 't')\n  t = string.gsub(t,\
    \ 'B', 'h')\n  t = string.gsub(t, 'C', 'y')\n  t = string.gsub(t, 'D', 'i')\n\
    \  t = string.gsub(t, 'E', 'o')\n  t = string.gsub(t, 'F', 'h')\n  t = string.gsub(t,\
    \ 'G', 'k')\n  t = string.gsub(t, 'H', 'x')\n  t = string.gsub(t, 'I', 'z')\n\
    \  t = string.gsub(t, 'J', 'p')\n  t = string.gsub(t, 'K', 'k')\n  t = string.gsub(t,\
    \ 'L', 'x')\n  t = string.gsub(t, 'M', 'k')\n  t = string.gsub(t, 'N', 'r')\n\
    \  t = string.gsub(t, 'O', 'o')\n  t = string.gsub(t", "    local alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    local rotated = {}\n    local i = 1\n    for i = #s, 1, -1 do\n        table.insert(rotated,\
    \ alphabet[#alphabet])\n    end\n    for i = 1, #s do\n        rotated = rotated[#rotated\
    \ + 1] + rotated\n    end\n    rotated = table.concat(rotated)\n    return rotated\n\
    end", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local rotated_alphabet\
    \ = alphabet\n  local rotated_alphabet_length = #alphabet\n  local new_alphabet\
    \ = alphabet", "  local result = \"\"\n  local count = 0\n  for i = 1, #s do\n\
    \    if string.sub(s, i, i + 2) ~= string.sub(s, i - 1, i + 1) then\n      count\
    \ = count + 1\n    end\n    \n    result = result .. string.sub(alphabet.alphabet,\
    \ count * 2, count * 2 + 1)\n  end\n  \n  return result\nend", "  local alphabet\
    \ = {}\n  for i=33,65,-1 do alphabet[i] = string.char(i, i, i) end\n  local alphabet\
    \ = alphabet\n  return s:gsub('.', function(x) alphabet[x] end)\nend", "\tlocal\
    \ alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\tlocal s\
    \ = s:upper()\n\tlocal r = ''\n\tfor i = #s, 1, -1 do\n\t\tlocal x = alphabet:sub(i\
    \ % #alphabet, i)\n\t\tr = r..x\n\tend\n\treturn r\nend", "\t-- Initialize the\
    \ key for the encryption.\n\tlocal key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\t-- Initialize\
    \ the alphabet to rotate the string around.\n\tlocal alphabet = 'FGHIJKLMNOPQRSTUVWXYZABCD'\n\
    \t-- Get the length of the string.\n\tlocal length = string.len(s)\n\t-- Get the\
    \ key length.\n\tlocal key_length = string.len(key)\n\t-- Initialize an empty\
    \ encrypted string.\n\tlocal encrypted = ''\n\t-- Encrypt each character of the\
    \ string.\n\tfor i = 1, length do\n\t\t-- Get the next character.\n\t\tlocal char\
    \ = string.sub(s,i,i)\n\t\t-- Encrypt the character with the key.\n\t\tlocal encrypted\
    \ =\n\t\t\tencrypted\n\t\t\t..string.sub(\n\t\t\t\tstring.sub(\n\t\t\t\t\tstring.sub(\n\
    \t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\t\tstring.sub(\n\
    \t\t\t\t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\t\
    \t\t\t\tstring.sub(\n\t\t\t\t\t\t\t\t\t\t\t\tencrypted,\n\t\t\t\t\t\t\t\t\t\t\t\
    \t1,\n\t\t\t\t\t\t\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\
    \t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t\t\t\t\t\t),\n\
    \t\t\t\t\t\t\t\t\t\tkey_length-1,\n\t\t\t\t\t\t\t\t\t\tkey_length\n\t\t\t\t\t\t\
    \t\t\t),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t\t\t\
    \t),\n\t\t\t\t\t\t\t\tkey_length,\n\t\t\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t\t\t\
    ),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t\t),\n\t\t\t\t\t\t\
    key_length,\n\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t),\n\t\t\t\t\tkey_length,\n\t\
    \t\t\t\tkey_length-1\n\t\t\t\t),\n\t\t\t\tkey_length,\n\t\t\t\tkey_length-1\n\t\
    \t\t),\n\t\t\tstring.sub(\n\t\t\t\tstring.sub(\n\t\t\t\t\tstring.sub(\n\t\t\t\t\
    \t\tstring.sub(\n\t\t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\t\tstring.sub(\n\t\t\t\
    \t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\t\t\t\t\
    \tencrypted,\n\t\t\t\t\t\t\t\t\t\t\tkey_length-1,\n\t\t\t\t\t\t\t\t\t\t\tlength\n\
    \t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\tkey_length-1\n\
    \t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tkey_length,\n\t\t\t\t\t\t\t\t\tkey_length-1\n\
    \t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tkey_length-1,\n\t\t\t\t\t\t\t\tkey_length\n\
    \t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tkey_length-1,\n\t\t\t\t\t\t\tkey_length\n\t\t\t\
    \t\t\t),\n\t\t\t\t\t\tkey_length,\n\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t),\n\t\t\
    \t\t\tkey_length,\n\t\t\t\t\tkey_length-1\n\t\t\t\t),\n\t\t\t\tkey_length,\n\t\
    \t\t\tkey_length-1\n\t\t\t),\n\t\t\tstring.sub(\n\t\t\t\tstring.sub(\n\t\t\t\t\
    \tstring.sub(\n\t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\
    \t\tstring.sub(\n\t\t\t\t\t\t\t\t\tstring.sub(\n\t\t\t\t\t\t\t\t\t\tstring.sub(\n\
    \t\t\t\t\t\t\t\t\t\t\tencrypted,\n\t\t\t\t\t\t\t\t\t\t\tkey_length-1,\n\t\t\t\t\
    \t\t\t\t\t\t\tlength\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\tkey_length,\n\
    \t\t\t\t\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tkey_length-1,\n\
    \t\t\t\t\t\t\t\t\tkey_length\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tkey_length,\n\
    \t\t\t\t\t\t\t\tkey_length-1\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tkey_length-1,\n\t\
    \t\t\t\t\t\t", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    return\
    \ table.concat(string.gsub(s:gsub('^(.)(.)$', '\\\\2\\\\1'), '(.)(.)', '\\\\1\\\
    \\2')\n            , alphabet, alphabet:sub(1,1):reverse():sub(1,1):reverse())\n\
    end", "    local newchars = { }\n    for i = 1, #alphabet, 1 do\n        newchars[#newchars\
    \ + 1] = alphabet[((alphabet + i)%#alphabet)]\n    end\n    newchars[#newchars\
    \ + 1] = alphabet[#alphabet+1]\n    local result = ''\n    for i = 1, #s, 1 do\n\
    \        local char = s:sub(i,i)\n        local pos = newchars[char]\n       \
    \ if pos == #newchars then\n            pos = 1\n        end\n        result =\
    \ result .. newchars[pos]\n    end\n    return result\nend", "  assert(type(s)\
    \ == 'string', 'Must be a string')\n  assert(s:len() > 0, 'Must not be empty')\n\
    \  \n  local result = ''\n  \n  -- The loop starts at 1 because the first letter\
    \ is rotated 2 places.\n  local i = 1\n  \n  -- Loop through each letter of the\
    \ string.\n  for c in s:gmatch('([a-zA-Z])') do\n    -- If the letter c is a letter\
    \ that has already been encrypted,\n    -- then skip it.\n    if string.sub(s,\
    \ i, i + 1) ~= c:lower() then\n      result = result .. string.sub(alphabet, i)\n\
    \      i = i + 1\n      -- Add the encrypted letter c to result.\n      result\
    \ = result .. c:upper()\n    end\n    -- If the letter c is a letter that hasn't\
    \ been encrypted yet,\n    -- then add it to the encryption alphabet and move\
    \ the encryption\n    -- index forward.\n    i = i + 1\n    result = result ..\
    \ string.sub(alphabet, i)\n  end\n  \n  -- Append the remaining letters that haven't\
    \ been encrypted.\n  if #s > i then\n    result = result .. string.sub(alphabet,\
    \ i)\n  end\n  \n  return result\nend", "  -- Rotate each character and add it\
    \ to the return string.\n  -- We start with the letter 'e' and shift it down by\
    \ two \n  -- and then 'h', shifting down by two again and so on.\n  -- We use\
    \ the modulo operator, %, to ensure we get to 'h'.\n  return string.sub(s, 'e',\
    \ ('e' .. 'h'):sub(2, 2):sub(1, 1) + 1)\nend", "\t-- If the length of the string\
    \ is 0, just return the empty string\n\t-- Otherwise, return a new string that\
    \ is just the last character rotated\n\treturn string.sub(s, -1) .. string.sub(s,\
    \ -2, -1)\nend", "  assert(type(s) ~= 'string')\n  assert(#s > 0)\n  \n  local\
    \ new_s = ''\n  \n  local length = #s\n  \n  -- Precompute the values of rotated\
    \ alphabet indices in rotated_alphabet\n  -- for fast lookup in each iteration\
    \ below.\n  local rotated_alphabet = {}\n  for i = 0, length do\n    rotated_alphabet[i]\
    \ = (i % 26) + 2\n  end\n  \n  for i = 1, length do\n    -- Get the rotated letter\
    \ index from the original letter index\n    local rot_index = (rotated_alphabet[s[i]]\
    \ % 26) + 2\n    -- Add the rotated index to the original index\n    s[i] = rot_index\
    \ + s[i]\n  end\n  \n  -- Now we know what letter to look for and which letters\
    \ to swap around,\n  -- we can loop through and build new string in reverse.\n\
    \  for i = length, 1, -1 do\n    local letter = s[i]\n    new_s = new_s .. rotated_alphabet[letter]\n\
    \    s[i] = letter\n  end\n  \n  return new_s\nend", "  local alphabet = {\n \
    \   [0] = ' ', [1] = 'a', 'b', [26] = 'c', 'd', [31] = 'e', [41] = 'f',\n    [51]\
    \ = 'g', [61] = 'h', [66] = 'i', [71] = 'j', [76] = 'k', \n    [81] = 'l', [80]\
    \ = 'm', [83] = 'n', [84] = 'o', [85] = 'p',\n    [87] = 'q', [89] = 'r', [92]\
    \ = 's', [97] = 't', [101] = 'u', \n    [102] = 'v', [105] = 'w', [106] = 'x',\
    \ [109] = 'y', \n    [112] = 'z', [113] = '{', [116] = '|', [119] = '~', [122]\
    \ = '@', \n    [123] = '~', [124] = '!', [127] = '~'}", "  local alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n  local alphabetLen = #alphabet\n  \n  -- Shift\
    \ each letter to the right by two places.\n  s = s:gsub(\".\", function(c) return\
    \ alphabet[alphabetLen-alphabet.index:sub(c, 1)] end)\n  -- Replace all letters\
    \ with the letters that would have been\n  -- shifted to the right.\n  s = s:gsub(\"\
    ^.\", function (c) return alphabet[alphabet.index:sub(c, 1) + (alphabetLen-alphabet.index:sub(c,\
    \ 1)) ] end)\n  return s\nend", "\tlocal alphabet = {\n\t\t['a'] = '',\n\t\t['z']\
    \ = '',\n\t\t['A'] = '',\n\t\t['Z'] = '',\n\t\t['0'] = '',\n\t\t['9'] = '',\n\t\
    \t['*'] = '',\n\t\t['+'] = '',\n\t\t['-'] = '',\n\t\t['.'] = '',\n\t\t['/'] =\
    \ '',\n\t\t[','] = '',\n\t\t[':'] = '',\n\t\t[';'] = '',\n\t\t['!'] = '',\n\t\t\
    ['&'] = '',\n\t\t['@'] = '',\n\t\t['#'] = '',\n\t\t['$'] = '',\n\t\t['%'] = '',\n\
    \t\t['^'] = '',\n\t\t['&'] = '',\n\t\t['%'] = '',\n\t\t['$'] = '',\n\t\t['/']\
    \ = '',\n\t\t['%'] = '',\n\t\t['&'] = '',\n\t\t['%'] = '',\n\t\t['#'] = '',\n\t\
    \t['-'] = '',\n\t\t['.'] = '',\n\t\t['-'] = '',\n\t\t['0'] = '',\n\t\t['@'] =\
    \ '',\n\t\t['+'] = '',\n\t\t['!'] = '',\n\t\t['-'] = '',\n\t\t['.'] = '',\n\t\t\
    ['-'] = '',\n\t\t['!'] = '',\n\t\t['&'] = '',\n\t\t['*'] = '',\n\t\t['+'] = '',\n\
    \t\t['/'] = '',\n\t\t['%'] = '',\n\t\t['^'] = '',\n\t\t[';'] = '',\n\t\t['a']\
    \ = '',\n\t\t['B'] = '',\n\t\t['C'] = '',\n\t\t['D'] = '',\n\t\t['E'] = '',\n\t\
    \t['F'] = '',\n\t\t['G'] = '',\n\t\t['H'] = '',\n\t\t['I'] = '',\n\t\t['J'] =\
    \ '',\n\t\t['K'] = '',\n\t\t['L'] = '',\n\t\t['M'] = '',\n\t\t['N'] = '',\n\t\t\
    ['O'] = '',\n\t\t['P'] = '',\n\t\t['Q'] = '',\n\t\t['R'] = '',\n\t\t['S'] = '',\n\
    \t\t['T'] = '',\n\t\t['U'] = '',\n\t\t['V'] = '',\n\t\t['W'] = '',\n\t\t['X']\
    \ = '',\n\t\t['Y'] = '',\n\t\t['Z'] = '',\n\t\t['-'] = '',\n\t\t['.'] = '',\n\t\
    \t['-'] = '',\n\t\t['&'] = '',\n\t\t['%'] = '',\n\t\t['*'] = '',\n\t\t['+'] =\
    \ '',\n\t\t['^'] = '',\n\t\t['0'] = '',\n\t\t['!'] = '',\n\t\t['('] = '',\n\t\t\
    [')'] = '',\n\t\t['='] = '',\n\t\t['['] = '',\n\t\t['#'] = '',\n\t\t['-'] = '',\n\
    \t\t['/'] = '',\n\t\t[','] = '',\n\t\t['<'] = '',\n\t\t['>'] = '',\n\t\t['A']\
    \ = '',\n\t\t['B'] = '',\n\t\t['C'] = '',\n\t\t['D'] = '',\n\t\t['E'] = '',\n\t\
    \t['F'] = '',\n\t\t['", "  -- Write your code below!\nend", "    -- first find\
    \ the index of the first character that needs to be shifted\n    -- then use that\
    \ index to rotate all characters by 2 places \n    -- i.e. 'hi' becomes 'tj' and\
    \ 'gf' becomes 'dr'\n    -- use modulo to remove the letters that shift past the\
    \ end of the alphabet\n    local alphabet = string.char(tonumber(s))\n    local\
    \ startIndex = string.find(alphabet, \"1\")\n    local alphabetShifted = string.sub(alphabet,\
    \ startIndex+1)\n    local encryptedAlphabet = string.char(string.sub(alphabet,\
    \ startIndex+1, startIndex+1)) .. \n        string.char(string.sub(alphabet, startIndex+1,\
    \ startIndex+1))", "   local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n   local rotated_alphabet = alphabet:sub(1, alphabet:len()) .. alphabet:sub(0,\
    \ alphabet:len()-1)\n   local rotated_s = rotated_alphabet:sub(alphabet:len())\
    \ .. s\n   return rotated_s\nend", "    local t = {}\n    for _, c in ipairs(s)\
    \ do \n        table.insert(t, rotate_character(c, 2))\n    end \n    return table.concat(t,\
    \ \"\")\nend", "    local alphabet = {}\n    table.insert(alphabet, 'g')\n   \
    \ table.insert(alphabet, 'f')\n    table.insert(alphabet, 'k')\n    table.insert(alphabet,\
    \ 'j')\n    table.insert(alphabet, 'l')\n    table.insert(alphabet, 'o')\n   \
    \ table.insert(alphabet, 'p')\n    table.insert(alphabet, 'd')\n    table.insert(alphabet,\
    \ 'b')\n    table.insert(alphabet, 'm')\n    table.insert(alphabet, 'n')\n   \
    \ table.insert(alphabet, 'h')\n    table.insert(alphabet, 't')\n    table.insert(alphabet,\
    \ 'v')\n    table.insert(alphabet, 'y')\n    table.insert(alphabet, 'r')\n   \
    \ table.insert(alphabet, 'q')\n    table.insert(alphabet, 'q')\n    table.insert(alphabet,\
    \ 'z')\n    table.insert(alphabet, 'a')\n    table.insert(alphabet, 's')\n   \
    \ table.insert(alphabet, 'u')\n    table.insert(alphabet, 'v')\n    table.insert(alphabet,\
    \ 'e')\n    table.insert(alphabet, 't')\n    table.insert(alphabet, 'f')\n   \
    \ table.insert(alphabet, 'x')\n    table.insert(alphabet, 'i')\n    table.insert(alphabet,\
    \ 'g')\n    table.insert(alphabet, 'h')\n    table.insert(alphabet, 'k')\n   \
    \ table.insert(alphabet, 'n')\n    table.insert(alphabet, 'o')\n    table.insert(alphabet,\
    \ 'w')\n    table.insert(alphabet, 'q')\n    table.insert(alphabet, 'p')\n   \
    \ table.insert(alphabet, 'k')\n    table.insert(alphabet, 'a')\n    table.insert(alphabet,\
    \ 'n')\n    table.insert(alphabet, 'r')\n    table.insert(alphabet, 'p')\n   \
    \ table.insert(alphabet, 'd')\n    table.insert(alphabet, 'v')\n    table.insert(alphabet,\
    \ 'h')\n    table.insert(alphabet, 'g')\n    table.insert(alphabet, 'z')\n   \
    \ table.insert(alphabet, 'e')\n    table.insert(alphabet, 't')\n    table.insert(alphabet,\
    \ 'o')\n    table.insert(alphabet, 'w')\n    table.insert(alphabet, 'm')\n   \
    \ table.insert(alphabet, 'k')\n    table.insert(alphabet, 'j')\n    table.insert(alphabet,\
    \ 'b')\n    table.insert(alphabet, 'd')\n    table.insert(alphabet, 'k')\n   \
    \ table.insert(alphabet, 'o')\n    table.insert(alphabet, 'j')\n    table.insert(alphabet,\
    \ 'f')\n    table.insert(alphabet, 's')\n    table.insert(alphabet, 'j')\n   \
    \ table.insert(alphabet, 't')\n    table.insert(alphabet, 'k')\n    table.insert(alphabet,\
    \ 'o')\n    table.insert(alphabet, 'l')\n    table.insert(alphabet, 'u", "   \
    \ local alphabet = {\n        [\"a\"] = [\"a\", \"b\"],\n        [\"c\"] = [\"\
    c\", \"d\"],\n        [\"e\"] = [\"e\", \"f\"],\n        [\"g\"] = [\"g\", \"\
    h\"],\n        [\"i\"] = [\"i\", \"j\"],\n        [\"k\"] = [\"k\", \"l\"],\n\
    \        [\"m\"] = [\"m\", \"n\"],\n        [\"o\"] = [\"o\", \"p\"],\n      \
    \  [\"q\"] = [\"q\", \"r\", \"s\"],\n        [\"t\"] = [\"t\", \"u\", \"v\"],\n\
    \        [\"w\"] = [\"w\", \"x\", \"y\"],\n        [\"z\"] = [\"z\"],\n      \
    \  [\"s\"] = [\"s\", \"t\"],\n        [\"u\"] = [\"u\", \"v\"],\n        [\"v\"\
    ] = [\"v\", \"w\"],\n        [\"w\"] = [\"w\", \"x\", \"y\"],\n        [\"x\"\
    ] = [\"x\", \"y\", \"z\"],\n        [\"y\"] = [\"y\", \"z\", \"a\"],\n       \
    \ [\"z\"] = [\"z\", \"a\", \"c\"],\n        [\"m\"] = [\"m\", \"n\", \"o\"],\n\
    \        [\"n\"] = [\"n\", \"o\", \"q\"],\n        [\"o\"] = [\"o\", \"q\", \"\
    r\"],\n        [\"p\"] = [\"p\", \"r\", \"s\"],\n        [\"r\"] = [\"r\", \"\
    s\", \"t\"],\n        [\"t\"] = [\"t\", \"u\", \"v\"],\n        [\"h\"] = [\"\
    h\", \"j\", \"i\"],\n        [\"j\"] = [\"j\", \"i\", \"k\"],\n        [\"i\"\
    ] = [\"i\", \"k\", \"m\"],\n        [\"k\"] = [\"k\", \"m\", \"l\"],\n       \
    \ [\"l\"] = [\"l\", \"m\", \"n\"],\n        [\"m\"] = [\"m\", \"n\", \"o\"],\n\
    \        [\"n\"] = [\"n\", \"o\", \"q\"],\n        [\"o\"] = [\"o\", \"q\", \"\
    r\"],\n        [\"q\"] = [\"q\", \"r\", \"s\"],\n        [\"s\"] = [\"s\", \"\
    t\", \"u\"],\n        [\"v\"] = [\"v\", \"w\", \"x\"],\n        [\"w\"] = [\"\
    w\", \"x\", \"y\"],\n        [\"x\"] = [\"x\", \"y\", \"z\"],\n        [\"y\"\
    ] = [\"y\", \"z\", \"a\"],\n        [\"z\"] = [\"z\", \"a\", \"c\"],\n       \
    \ [\"r\"] = [\"r\", \"s\", \"t\"],\n        [\"t\"] = [\"t\", \"u\", \"v\"],\n\
    \        [\"u\"] = [\"u\", \"v\", \"w\"],\n        [\"v\"] = [\"v\", \"w\", \"\
    x\"],\n        [\"w\"] = [\"w\", \"x\", \"y\"],\n        [\"x\"] = [\"x\", \"\
    y\", \"z\"],\n        [\"y\"] = [\"y\", \"z\", \"a\"],\n        [\"z\"] = [\"\
    z\", \"a\", \"c", "\t-- Your code goes here!\n\t-- This should return a string\n\
    end", "  -- Write your code here\n  return s\nend", '  local alphabet = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.',
  "   local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   local alphabet2 = \"bcdefghijklmnopqrstuvwxyz\"\
    \n   local alphabet3 = \"abcdefghijklmnopqrstuvwxyz\"", "  local alphabet = {\n\
    \    [1] = string.char(1, string.len(s)) \n    .. string.char(string.len(s), string.len(s))\
    \ .. string.char(-string.len(s))\n    .. string.char(-string.len(s) - 1, string.len(s)\
    \ - 1) .. string.char(-string.len(s) - 2, string.len(s) - 2)\n    .. string.char(-string.len(s)\
    \ - 3, string.len(s) - 3) .. string.char(-string.len(s) - 4, string.len(s) - 4)\n\
    \    .. string.char(-string.len(s) - 5, string.len(s) - 5) .. string.char(-string.len(s)\
    \ - 6, string.len(s) - 6)\n    .. string.char(-string.len(s) - 7, string.len(s)\
    \ - 7) .. string.char(-string.len(s) - 8, string.len(s) - 8)\n    .. string.char(-string.len(s)\
    \ - 9, string.len(s) - 9) .. string.char(-string.len(s) - 10, string.len(s) -\
    \ 10)\n    .. string.char(-string.len(s) - 11, string.len(s) - 11) .. string.char(-string.len(s)\
    \ - 12, string.len(s) - 12)\n  }\n  return alphabet[rotate(s, alphabet)] .. alphabet[rotate(s,\
    \ alphabet, false)]\nend", "    local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    s = string.lower(s)\n    local rotatedAlphabet = alphabet:sub(1, #alphabet)\
    \ * alphabet:sub(2, #alphabet)\n    rotatedAlphabet = rotatedAlphabet:sub(1, #rotatedAlphabet)\
    \ \n    s = s:gsub(\"%a\", alphabet)\n    s = s:gsub(\"%A\", rotatedAlphabet)\n\
    \    s = s:gsub(\"%w\", rotatedAlphabet:sub(1, #rotatedAlphabet))\n    s = s:gsub(\"\
    %W\", rotatedAlphabet:sub(2, #rotatedAlphabet))\n    s = s:gsub(\"%o\", rotatedAlphabet:sub(3,\
    \ #rotatedAlphabet))\n    s = s:gsub(\"%O\", rotatedAlphabet:sub(4, #rotatedAlphabet))\n\
    \    s = s:gsub(\"%i\", rotatedAlphabet:sub(5, #rotatedAlphabet))\n    s = s:gsub(\"\
    %I\", rotatedAlphabet:sub(6, #rotatedAlphabet))\n    s = s:gsub(\"%t\", rotatedAlphabet:sub(7,\
    \ #rotatedAlphabet))\n    s = s:gsub(\"%T\", rotatedAlphabet:sub(8, #rotatedAlphabet))\n\
    \    s = s:gsub(\"%n\", rotatedAlphabet:sub(9, #rotatedAlphabet))\n    s = s:gsub(\"\
    %N\", rotatedAlphabet:sub(10, #rotatedAlphabet))\n    s = s:gsub(\"%v\", rotatedAlphabet:sub(11,\
    \ #rotatedAlphabet))\n    s = s:gsub(\"%V\", rotatedAlphabet:sub(12, #rotatedAlphabet))\n\
    \    s = s:gsub(\"%c\", rotatedAlphabet:sub(13, #rotatedAlphabet))\n    s = s:gsub(\"\
    %C\", rotatedAlphabet:sub(14, #rotatedAlphabet))\n    s = s:gsub(\"%g\", rotatedAlphabet:sub(15,\
    \ #rotatedAlphabet))\n    s = s:gsub(\"%G\", rotatedAlphabet:sub(16, #rotatedAlphabet))\n\
    \    s = s:gsub(\"%y\", rotatedAlphabet:sub(17, #rotatedAlphabet))\n    s = s:gsub(\"\
    %Y\", rotatedAlphabet:sub(18, #rotatedAlphabet))\n    s = s:gsub(\"%f\", rotatedAlphabet:sub(19,\
    \ #rotatedAlphab", "  assert(type(s) == 'string', 'Encrypting function called\
    \ on non-string')", "  -- Your code here.\n  assert(string.len(s) == string.len(string.sub(s,1,1)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,2,2)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,3,3)))\n  assert(string.len(s) == string.len(string.sub(s,4,4)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,5,5)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,6,6)))\n  assert(string.len(s) == string.len(string.sub(s,7,7)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,8,8)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,9,9)))\n  assert(string.len(s) == string.len(string.sub(s,10,10)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,11,11)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,12,12)))\n  assert(string.len(s) == string.len(string.sub(s,13,13)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,14,14)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,15,15)))\n  assert(string.len(s) == string.len(string.sub(s,16,16)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,17,17)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,18,18)))\n  assert(string.len(s) == string.len(string.sub(s,19,19)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,20,20)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,21,21)))\n  assert(string.len(s) == string.len(string.sub(s,22,22)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,23,23)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,24,24)))\n  assert(string.len(s) == string.len(string.sub(s,25,25)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,26,26)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,27,27)))\n  assert(string.len(s) == string.len(string.sub(s,28,28)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,29,29)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,30,30)))\n  assert(string.len(s) == string.len(string.sub(s,31,31)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,32,32)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,33,33)))\n  assert(string.len(s) == string.len(string.sub(s,34,34)))\n\
    \  assert(string.len(s) == string.len(string.sub(s,35,35)))\n  assert(string.len(s)\
    \ == string.len(string.sub(s,36,36)))\n  assert(string.len(", "\t-- Create a variable\
    \ `result`\n\tlocal result = {}\n\t\n\t-- Declare an iterator variable `i`\n\t\
    local i = 0\n\t\n\t-- For each character in the string\n\twhile i < #s do\n\t\t\
    \n\t\t-- Decrement `i` by 2 after every loop\n\t\ti = i - 2\n\t\t\n\t\t-- Add\
    \ each letter from the alphabet to a new string\n\t\ttable.insert(result, alphabet[i])\n\
    \tend\n\t\n\t-- Return the encrypted string\n\treturn table.concat(result)\nend",
  "  return string.gsub(string.gsub(string.gsub(s,\"[Hh]\",\"[Mm]\"),\"[Jj]\",\"[Zz]\"\
    ),\"[Ff]\",\"[Kk]\") -- Replace every letter with its encrypted counterpart\n\
    end", "    -- Rotate the alphabet by one letter\n    local alpha = s:sub(1, #s)\
    \ + s:sub(2, #s) + 1\n    -- Encrypt the string by rotating the letters in the\
    \ alphabet by two\n    -- multiplied to two places based on their position in\
    \ the alphabet\n    -- E.g. alpha = 'abcdefghij', s = 'hi'\n    return alpha:sub(1,\
    \ #alpha) + alpha:sub(2, #alpha) * 2\nend", "    local rot = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    return table.concat(table.translate(s, rot), rot)\nend", "\tlocal alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tlocal alphabetLength = #alphabet\n\t\n\t\
    local encryptedString = \"\"\n\t\n\t-- Start at beginning of alphabet and traverse\
    \ through entire string\n\t-- Shift each letter down a 2 positions in our alphabet\
    \ string\n\t-- Add shifted letter to our encryptedString string\n\tfor i = 1,\
    \ #s do\n\t\tlocal letter = alphabet[(i + 1) % alphabetLength]\n\t\tencryptedString\
    \ = encryptedString .. letter:sub(1, letter:len())\n\tend\n\t\n\treturn encryptedString\n\
    end", "   local alphabet = {\n      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\
    \ 'z',\n      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
    \ 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n      '0',\
    \ '1', '2', '3', '4', '5', '6', '7', '8', '9',\n   };\n   local newString = '';",
  "    local alphabet = {\n        ['a'] = 'b','b'] = 'a','a'] = 'c','c'] = 'd','d']\
    \ = 'e','e'] = 'f',\n        ['f'] = 'g','g'] = 'h','h'] = 'i','i'] = 'j','j']\
    \ = 'k','k'] = 'l','l'] = 'm',\n        ['m'] = 'n','n'] = 'o','o'] = 'p','p']\
    \ = 'q','q'] = 'r','r'] = 's','s' = 't',\n        ['t'] = 'u','u'] = 'v','v']\
    \ = 'w','w'] = 'x','x'] = 'y','y'] = 'z','z' = 'a','a' = 'b',\n        ['b'] =\
    \ 'c','c'] = 'd','d'] = 'e','e'] = 'f','f'] = 'g','g'] = 'h','h'] = 'i','i'] =\
    \ 'j',\n        ['j'] = 'k','k'] = 'l','l'] = 'm','m'] = 'n','n'] = 'o','o'] =\
    \ 'p','p'] = 'q','q'] = 'r',\n        ['r'] = 's','s':'t','t'] = 'u','u'] = 'v','v']\
    \ = 'w','w'] = 'x','x'] = 'y','y'] = 'z'\n    }", "  -- ROTATE_MASK holds the\
    \ ASCII values for the rotated letters.\n  local ROTATE_MASK = (string.char(0x1f)\
    \ .. string.char(0x7e))\n  -- ROTATE holds the alphabet rotated 90 degrees.\n\
    \  local ROTATE = string.char(ROTATE_MASK)\n  -- ROTATE_LEFT rotates the string\
    \ one position left.\n  local ROTATE_LEFT = ROTATE .. string.sub(s, 1, #s+1)\n\
    \  -- ROTATE_RIGHT rotates the string one position right.\n  local ROTATE_RIGHT\
    \ = ROTATE .. string.sub(s, #s+2)\n  -- ROTATE_LEFT rotates the string one position\
    \ left.\n  local ROTATE_MASK = ROTATE_MASK .. string.sub(s, 1, #s+2)\n  return\
    \ ROTATE_MASK .. ROTATE_LEFT .. ROTATE_RIGHT\nend", "    local alphabet = {\n\
    \        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    }\n    local\
    \ alphabet2 = {\n        'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    }",
  "   local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   local alphabet2 = alphabet\n\
    \   local alphabet3 = alphabet\n   local alphabet4 = alphabet", "  -- Note: This\
    \ can only work with the alphabet of the alphabet of s\n  -- if rotated to right\
    \ two places. \n  return reverse(rotate(rotate(s, 1), 2), 2)\nend", "   -- Get\
    \ the number of characters in the string\n   local nChars = #s\n   -- Initialize\
    \ a variable to hold encrypted string\n   local encrypted = \"\"\n   -- Loop through\
    \ the string character by character\n   for i = 1,nChars do\n      -- Get the\
    \ encrypted character\n      local encryptedChar = string.sub(s, i, i+1)\n   \
    \   -- Get the letter to the left of encrypted character\n      local letter =\
    \ string.sub(s, i-1, i+1)\n      -- Rotate the letter down by two places\n   \
    \   local letter = string.sub(letter, 1, 2)\n      -- Append the encrypted character\
    \ to the end of the encrypted string\n      encrypted = string.cat(encrypted,\
    \ encryptedChar, letter)\n   end\n   -- Return the encrypted string\n   return\
    \ encrypted\nend", "  local alphabet = {\n    'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j',\n    'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u',\
    \ 'v', 'w', 'x', 'y', 'z'\n  }\n  \n  -- Set current position to first letter\n\
    \  local pos = 1\n  -- Loop through each letter in string\n  for i = 1, #s do\n\
    \    pos = alphabet.find(alphabet, s[i + 1])\n    -- Rotate position by two\n\
    \    pos = pos * 2 + 1\n    -- Replace letter in string with rotated letter\n\
    \    s = s.sub(i, 1, pos)\n  end\n  \n  return s\nend", "    -- This line is commented\
    \ out because of the indentation.\n    -- local alphabet = {'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'}\n    local alphabet = {letter, letter, letter,\
    \ letter, letter, letter, letter, letter, letter, letter, letter, letter, letter,\
    \ letter, letter, letter, letter, letter, letter, letter, letter, letter}\n  \
    \  for i = 1, #s do\n        alphabet[1] = alphabet[#alphabet] + 1\n        alphabet[#alphabet]\
    \ = alphabet[#alphabet] - 1\n    end\n    local encrypted = ''\n    for i = 1,\
    \ #s do\n        encrypted = encrypted .. alphabet[string.sub(s,i,i)]\n    end\n\
    \    return encrypted\nend", "    local cipher = ''\n    local i = 2\n    for\
    \ char in s:gmatch('.') do\n        cipher = cipher .. encrypt(char:sub(1, i):sub(i-1,\
    \ i))\n        i = i + 2\n    end\n    return cipher\nend", "  if s == nil then\
    \ return nil end\n  \n  -- Convert the string to uppercase and append an extra\
    \ space so we\n  -- can easily find the end of the string.\n  local t = s:upper():gsub(\"\
    (.)$\", \"\\1 \")\n  \n  -- Initialize our return string to an empty string.\n\
    \  local c = ''\n  \n  -- Loop over each character in the string, encrypt it if\
    \ it's in the\n  -- rotating alphabet and append the encrypted character to our\
    \ return string.\n  for i = 1, #t, 1 do\n    -- Get the ASCII code of the character\
    \ at the current index.\n    local a = tonumber(t:sub(i, i))\n    \n    -- If\
    \ the character is in the rotating alphabet append the shifted\n    -- character\
    \ to a and increase the index by two.\n    if a > #alphabet-1 then\n      a =\
    \ a * 2\n      i = i + 1\n    end\n    \n    -- Append the shifted character to\
    \ the return string.\n    c = c .. alphabet[a]\n  end\n  \n  -- Return the return\
    \ string.\n  return c\nend", "    if string.len(s) > 1 then\n        local s2\
    \ = string.sub(s,0,1)\n        local x = string.find(string.sub(s,2,string.len(s)),s2)\n\
    \        local y = string.find(string.sub(s,x,string.len(s)),s2)\n        local\
    \ z = string.find(string.sub(s,y,string.len(s)),s2)\n        if x > 0 then\n \
    \           return string.sub(s,1,string.len(s)-1) .. string.sub(s,x+1,string.len(s)-x-1)\
    \ .. string.sub(s,z,string.len(s)-z-1)\n        elseif y > 0 then\n          \
    \  return string.sub(s,1,string.len(s)-1) .. string.sub(s,y,string.len(s)-y) ..\
    \ string.sub(s,z,string.len(s)-z-1)\n        elseif z > 0 then\n            return\
    \ string.sub(s,1,string.len(s)-1) .. string.sub(s,z,string.len(s)-z) .. string.sub(s,y,string.len(s)-y)\n\
    \        end\n    end\nend", "    local r\n    for i = #alphabet, 2, -1 do\n \
    \       local c = ''\n        for j = #s do \n            c = c + alphabet[(i\
    \ + j) % #alphabet] \n        end\n        r = (r and r or '') + c\n    end\n\
    \    return r\nend", "    local alphabet = string.char(tonumber(s) >= 0 and tonumber(s)\
    \ or 26)\n    local sb, sb2, sb3 = string.byte(s), string.byte(s, 1, string.len(s)-1),\
    \ string.byte(s, 1, string.len(s)-2)\n    for i = 1, string.len(s) do\n      \
    \  local pos = string.find(alphabet, sb[i])\n        if (pos == nil) then\n  \
    \          return s\n        else\n            alphabet = alphabet[pos + 1 ..\
    \ string.len(alphabet)]\n        end\n    end\n    return alphabet\nend", "\t\
    -- Initialize a variable to be the empty string\n\tlocal str = ''", "  local alphabet\
    \ = {\n    -- Uppercase\n    ['A'] = 'Z',\n    ['a'] = 'z',\n    -- Lowercase\n\
    \    ['b'] = 'y',\n    ['c'] = 'z',\n    ['d'] = 'y',\n    ['e'] = 'z',\n    ['f']\
    \ = 'y',\n    ['g'] = 'y',\n    ['h'] = 'z',\n    ['i'] = 'y',\n    ['j'] = 'z',\n\
    \    ['k'] = 'y',\n    ['l'] = 'z',\n    ['m'] = 'y',\n    ['n'] = 'z',\n    ['o']\
    \ = 'y',\n    ['p'] = 'z',\n    ['q'] = 'y',\n    ['r'] = 'z',\n    ['s'] = 'y',\n\
    \    ['t'] = 'z',\n    ['u'] = 'y',\n    ['v'] = 'z',\n    ['w'] = 'y',\n    ['x']\
    \ = 'z',\n    ['y'] = 'z',\n    ['z'] = 'z',\n    -- Unicde\n    ['A'] = 'A',\n\
    \    ['a'] = 'a',\n    ['B'] = 'B',\n    ['b'] = 'b',\n    ['C'] = 'C',\n    ['c']\
    \ = 'c',\n    ['D'] = 'D',\n    ['d'] = 'd',\n    ['E'] = 'E',\n    ['e'] = 'e',\n\
    \    ['F'] = 'F',\n    ['f'] = 'f',\n    ['G'] = 'G',\n    ['g'] = 'g',\n    ['H']\
    \ = 'H',\n    ['h'] = 'h',\n    ['I'] = 'I',\n    ['i'] = 'i',\n    ['J'] = 'J',\n\
    \    ['j'] = 'j',\n    ['K'] = 'K',\n    ['k'] = 'k',\n    ['L'] = 'L',\n    ['l']\
    \ = 'l',\n    ['M'] = 'M',\n    ['m'] = 'm',\n    ['N'] = 'N',\n    ['n'] = 'n',\n\
    \    ['O'] = 'O',\n    ['o'] = 'o',\n    ['P'] = 'P',\n    ['p'] = 'p',\n    ['Q']\
    \ = 'Q',\n    ['q'] = 'q',\n    ['R'] = 'R',\n    ['r'] = 'r',\n    ['S'] = 'S',\n\
    \    ['s'] = 's',\n    ['T'] = 'T',\n    ['t'] = 't',\n    ['U'] = 'U',\n    ['u']\
    \ = 'u',\n    ['V'] = 'V',\n    ['v'] = 'v',\n    ['W'] = 'W',\n    ['w'] = 'w',\n\
    \    ['X'] = 'X',\n    ['x'] = 'x',\n    ['Y'] = 'Y',\n    ['y'] = 'y',\n    ['Z']\
    \ = 'Z',\n    ['z'] = 'z',\n    -- Punctuation\n    ['.'] = 'x',\n    ['!'] =\
    \ 'x',\n    ['?'] = 'x',\n    [':'] = 'x',\n    [';'] = 'x',\n    [':'] = 'x',\n\
    \    ['('] = 'x',\n    [')'] = 'x',\n    ['$'] = 'x',\n    ['+'] = 'x',\n", " \
    \ local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local new_s = ''\n  for i =\
    \ 1, #s do\n    local char = alphabet:sub(#alphabet, #alphabet + 2*i)\n    new_s\
    \ = new_s .. char:sub(1, #char + 2)\n  end\n  return new_s\nend", "  local alpha\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  local t = {}\n  repeat\n    table.insert(t,\
    \ alpha:sub(1, alpha:len()-2))\n    alpha = alpha:sub(2)\n  until alpha == ''\n\
    \  \n  return t[s:lower() .. alpha:lower()]\nend\n</code>\n<|/ a tags=string,lua\
    \ |>\n<| c |>\nThis solution was exactly what I was looking for.  I realized that\
    \ I was missing the logic that I was missing.  Thanks for pointing this out!\n\
    <|/ c |>\n<| c |>\nI'm glad it helped! Don't forget to accept the answer.\n<|/\
    \ c |>\n<| c |>\nYou need `alpha = alpha:sub(1)` before the loop to reverse the\
    \ alphabet in reverse.\n<|/ c |>\n<| a |>\nHere's a solution using string functions:\n\
    <code>", "    local result = \"\"\n    for i = #alphabet, 1, -1 do\n        local\
    \ index = (math.floor(i/2)) % #alphabet\n        result = result + alphabet[index+1]\n\
    \        result = result + alphabet[(i-index - 2)%#alphabet]\n    end\n    return\
    \ result\nend", "    if s then\n        local r=\"\"\n        for i = #s, 1, -1\
    \ do\n            local c = s:sub(i,i)\n            r=r..string.char( string.byte(\
    \ alphabet[c] ) + alphabet[c+1] )\n        end\n        return r\n    end\nend",
  "    assert(type(s) ~= 'string')\n    return ''\nend", "\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \tlocal i, j, temp, k = 0, 0, alphabet:byte(), 0\n\t-- For each letter in s, start\
    \ a new temp string\n\tfor i = 1, #s do\n\t\t-- Create a temporary variable that\
    \ shifts down two positions\n\t\t-- multiplied to two positions.\n\t\ttemp = alphabet:sub(k,\
    \ k + 2)\n\t\t-- Rotate the letter by 1 each time\n\t\t-- Shift down the letter\
    \ in the alphabet by one in the \n\t\t-- alphabet and multiply by 2\n\t\talphabet\
    \ = alphabet:sub(k + 1, k + 2)\n\t\talphabet:sub(k) = temp:sub(1)\n\t\tk = k +\
    \ 1\n\tend\n\t-- Append the new letters to the end of the alphabet string\n\t\
    for i = #alphabet, #alphabet:byte() + 2, 2 do\n\t\talphabet:sub(i) = ''\n\tend\n\
    \t-- Return s rotated to the alphabet\n\treturn s:gsub('%S', function(c) alphabet:sub((c:byte()\
    \ + k) % #alphabet) end)\nend", "   local alphabet = {\n      { [\"i\"] = \"t\"\
    , [\"j\"] = \"u\", [\"k\"] = \"o\", [\"l\"] = \"w\" },\n      { [\"m\"] = \"u\"\
    , [\"n\"] = \"r\", [\"o\"] = \"y\", [\"p\"] = \"l\" },\n      { [\"q\"] = \"o\"\
    , [\"r\"] = \"m\", [\"s\"] = \"i\", [\"t\"] = \"e\" },\n      { [\"u\"] = \"p\"\
    , [\"v\"] = \"f\", [\"w\"] = \"v\", [\"x\"] = \"l\" },\n      { [\"y\"] = \"v\"\
    , [\"z\"] = \"m\", [\"A\"] = \"I\", [\"B\"] = \"F\" },\n      { [\"C\"] = \"I\"\
    , [\"D\"] = \"S\", [\"E\"] = \"W\", [\"F\"] = \"E\" },\n      { [\"G\"] = \"E\"\
    , [\"H\"] = \"K\", [\"I\"] = \"O\", [\"J\"] = \"M\" },\n      { [\"K\"] = \"E\"\
    , [\"L\"] = \"N\", [\"M\"] = \"R\", [\"N\"] = \"Y\" },\n      { [\"O\"] = \"W\"\
    , [\"P\"] = \"L\", [\"Q\"] = \"O\", [\"R\"] = \"M\" },\n      { [\"S\"] = \"I\"\
    , [\"T\"] = \"E\", [\"U\"] = \"P\", [\"V\"] = \"F\" },\n      { [\"W\"] = \"V\"\
    , [\"X\"] = \"L\", [\"Y\"] = \"V\", [\"Z\"] = \"M\" },\n      { [\"A\"] = \"I\"\
    , [\"B\"] = \"F\", [\"C\"] = \"I\", [\"D\"] = \"S\" },\n      { [\"E\"] = \"W\"\
    , [\"F\"] = \"E\", [\"G\"] = \"E\", [\"H\"] = \"K\" },\n      { [\"I\"] = \"O\"\
    , [\"J\"] = \"M\", [\"K\"] = \"E\", [\"L\"] = \"N\" },\n      { [\"M\"] = \"R\"\
    , [\"N\"] = \"Y\", [\"O\"] = \"W\", [\"P\"] = \"L\" },\n      { [\"Q\"] = \"O\"\
    , [\"R\"] = \"M\", [\"S\"] = \"I\", [\"T\"] = \"E\" },\n      { [\"U\"] = \"P\"\
    , [\"V\"] = \"F\", [\"W\"] = \"V\", [\"X\"] = \"L\" },\n      { [\"Y\"] = \"V\"\
    , [\"Z\"] = \"M\" }\n   }\n   local key = \"k\"\n   local alphabetSize = 1\n \
    \  local encrypted = ''\n   for i = 0, #s do \n      -- Get the letter in the\
    \ input string and put it in encrypted\n      -- Also get the next character in\
    \ the alphabet\n      local letter = s[i]\n      local nextLetter = alphabet[alphabetSize][1]\n\
    \      -- Reverse the letter since it is in the opposite direction\n      encrypted:=encrypted..nextLetter..letter\n\
    \      -- Increment the alphabetSize\n      alphabetSize = alphabetSize + 1",
  "  local news = {}\n  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  \n  for\
    \ _,c in ipairs(s) do \n    news[#news+1] = c\n  end \n  \n  for _,c in ipairs(alphabet)\
    \ do\n    news[#news+1] = alphabet:sub(c:len()) + c:sub(1,c::len()-1)\n  end \n\
    \  \n  for _,c in ipairs(news) do\n    news[#news+1] = alphabet:sub(c:len()) +\
    \ c:sub(1,c::len()-1)\n  end \n  return table.concat(news)\nend", "  -- Write\
    \ your code here!\n  return s\nend", "  local function rotator(s)\n    s = s:reverse()\n\
    \    local k = ''\n    local i = 0\n    while i < #s do\n      k = k .. tostring(rotator(tostring(s[i])..tostring(s[i+1])))\n\
    \      i = i + 2\n    end\n    return k\n  end\n  return rotator(s)\nend", "\t\
    local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n\tfor\
    \ i = #alphabet, 2, -1 do\n\t\tlocal x = alphabet[#alphabet]\n\t\talphabet[#alphabet]\
    \ = alphabet[#alphabet-1]\n\t\talphabet[#alphabet-1] = x\n\tend\n\t\n\tlocal cipher\
    \ = ''\n\tfor i = 1, #s do\n\t\tcipher = cipher .. alphabet[((alphabet.indexOf(s)\
    \ + 1) % (#alphabet))+1]\n\tend\n\treturn cipher\nend", "  local alphabet = {'a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  -- The final alphabet is the\
    \ alphabet minus the first and last letters.\n  local alphabet1 = alphabet:sub(1,\
    \ #alphabet)\n  local alphabet2 = alphabet:sub((#alphabet-1), #alphabet)\n  --\
    \ The first letter of the alphabet is rotated two positions.\n  local alphabet3\
    \ = alphabet:sub(1, #alphabet)\n  -- The last letter of the alphabet is rotated\
    \ two positions.\n  local alphabet4 = alphabet:sub((#alphabet-1), #alphabet)",
  "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local alpha = {}\n  for i=1,#alphabet,1\
    \ do\n    alpha[i] = alphabet:sub(i,i)\n  end\n  local alpha_index = 1\n  for\
    \ i=1,#s,1 do\n    alpha_index = (alpha_index + #alphabet*(#alphabet+1)/2) % #alphabet\n\
    \    alpha[alpha_index] = alpha[alpha_index]:sub(1,1)\n  end\n  return alpha[alpha_index]\n\
    end", "  if #s <= 0 then\n    return ''\n  end\n  local n = #s\n  local result\
    \ = {}\n  for i = 1, #s do\n    local char = string.sub(s, i, i)\n    local next_char\
    \ = string.sub(s, i, i + 1)\n    table.insert(result, char)\n    if char > next_char\
    \ then\n      table.insert(result, char)\n      table.insert(result, next_char)\n\
    \    end\n    i = i + 1\n  end\n  return table.concat(result)\nend\nprint(encrypt('asdfghjkl'))\n\
    print(encrypt('gf'))\nprint(encrypt('et'))\nprint(encrypt('hi'))\nprint(encrypt('asdf'))\n\
    print(encrypt('qwertz'))\nprint(encrypt('asdfghjkl'))\nprint(encrypt('gf'))\n\
    print(encrypt('et'))\nprint(encrypt('hi'))\nprint(encrypt('asdf'))\nprint(encrypt('qwertz'))\n\
    print(encrypt('asdfghjkl'))\nprint(encrypt('gf'))\nprint(encrypt('et'))\nprint(encrypt('hi'))\n\
    print(encrypt('asdf'))\nprint(encrypt('qwertz'))\nprint(encrypt('asdfghjkl'))\n\
    print(encrypt('gf'))\nprint(encrypt('et'))\nprint(encrypt('hi'))\nprint(encrypt('asdf'))\n\
    print(encrypt('qwertz'))\nprint(encrypt('asdfghjkl'))\nprint(encrypt('gf'))\n\
    print(encrypt('et'))\nprint(encrypt('hi'))\nprint(encrypt('asdf'))\nprint(encrypt('qwertz'))\n\
    print(encrypt('asdfghjkl'))\nprint(encrypt('gf'))\nprint(encrypt('et'))\nprint(encrypt('hi'))\n\
    print(encrypt('asdf'))\nprint(encrypt('qwertz'))\nprint(encrypt('asdfghjkl'))\n\
    print(encrypt('gf'))\nprint(encrypt('et'))\nprint(encrypt('hi'))\nprint(encrypt('asdf'))\n\
    print(encrypt('qwertz'))\nprint(encrypt('asdfghjkl'))\nprint(encrypt('gf'))\n\
    print(encrypt('et'))\nprint(encrypt('hi'))\nprint(encrypt('asdf'))\nprint(encrypt('qwertz'))\n\
    print(encrypt('asdfghjkl'))\nprint(encrypt('gf'))\nprint(encrypt('et'))\nprint(encrypt('hi'))\n\
    print(encrypt('asdf'))\nprint(encrypt('qwertz'))\nprint(encrypt('asdfghjkl'))\n\
    print(encrypt('gf'))\nprint(encrypt('et'))\nprint(encrypt('", "    local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    local len = #alphabet", "\tassert(type(s)\
    \ == 'string', \"Argument should be a string\")\n\tlocal alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\tlocal l = string.len(s)\n\tlocal x = string.sub(alphabet, 1 , 1) -- first\
    \ char in alphabet that needs to be shifted\n\tlocal y = string.sub(alphabet,\
    \ 1 , 1) -- second char in alphabet that needs to be shifted\n\t\n\tlocal a =\
    \ {}\n\tfor i = 1, l do\n\t\tlocal c = string.sub(s, i, i)\n\t\tlocal e = string.find(alphabet,\
    \ c)\n\t\tassert(e > -1, \"Invalid letter\")\n\t\t\n\t\t-- Shift down the first\
    \ letter until it is in the right position\n\t\tif x == alphabet[e+1] then\n\t\
    \t\tx = alphabet[e]\n\t\telse\n\t\t\tx = alphabet[e+1]\n\t\tend\n\t\t\n\t\t--\
    \ Shift down the second letter until it is in the right position\n\t\tif y ==\
    \ alphabet[e+2] then\n\t\t\ty = alphabet[e]\n\t\telse\n\t\t\ty = alphabet[e+2]\n\
    \t\tend\n\t\t\n\t\ttable.insert(a, x)\n\t\ttable.insert(a, y)\n\tend\n\t\n\treturn\
    \ table.concat(a)\nend", "  if s == nil then return nil end\n  local alphabet\
    \ = {\n    ['A'] = 1, \n    ['B'] = 2, \n    ['C'] = 3, \n    ['D'] = 4, \n  \
    \  ['E'] = 5, \n    ['F'] = 6, \n    ['G'] = 7, \n    ['H'] = 8, \n    ['I'] =\
    \ 9, \n    ['J'] = 10, \n    ['K'] = 11, \n    ['L'] = 12, \n    ['M'] = 13, \n\
    \    ['N'] = 14, \n    ['O'] = 15, \n    ['P'] = 16, \n    ['Q'] = 17, \n    ['R']\
    \ = 18, \n    ['S'] = 19, \n    ['T'] = 20, \n    ['U'] = 21, \n    ['V'] = 22,\
    \ \n    ['W'] = 23, \n    ['X'] = 24, \n    ['Y'] = 25, \n    ['Z'] = 26 }", " \
    \   -- TODO - Change the code below to meet your needs.\n    -- This function\
    \ should return a string representing the encrypted \n    -- string.\n    -- Example:\n\
    \    -- if s = 'abcdefghijkl'\n    -- then encrypt('abc') returns 'efghijklmn'\n\
    \    -- if s = 'xyzabcdefghijkl'\n    -- then encrypt('abc') returns 'cdefghijklmno'\n\
    \    -- if s = 'abcdefghijklmn'\n    -- then encrypt('abc') returns 'fghijklmnopq'\n\
    \    -- if s = 'abc'\n    -- then encrypt('abc') returns 'abc'\n    -- if s =\
    \ 'zabc'\n    -- then encrypt('abc') returns 'abc'\n    -- if s = ''\n    -- then\
    \ encrypt('abc') returns ''\n    if s == nil then\n        return ''\n    end\n\
    \    \n    local newChar = ''\n    local oldChar = ''\n    \n    for i = 1, #s\
    \ do\n        oldChar = s:sub(i,i)\n        newChar = oldChar:sub(1,1) .. oldChar:sub(2,2)\n\
    \        \n        if newChar ~= oldChar then\n            return newChar\n  \
    \      end\n    end\nend", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  \n  -- Convert the string s to a list of characters. \n  local c = s:gsub('.',\
    \ function(c) \n    alphabet[#alphabet + alphabet:index(c)+1]\n  end)\n  \n  --\
    \ Append the alphabet to the end of the list c.\n  for i = 1, #alphabet, 2 do\n\
    \    c[#c + 1] = alphabet[i]\n  end\n  \n  return c\nend", "  local alphabet =\
    \ {}\n  for i = 1, 26 do\n    alphabet[i] = i\n  end\n  -- Create a string with\
    \ one character repeated 26 times. \n  -- The character is the index of each letter\
    \ plus one.\n  -- For example, 'a' would be the number 1, 'b' would be the number\
    \ 2 \n  -- and so on.\n  -- This can be accomplished with a while loop.\n  local\
    \ encrypted_string = ''\n  while #s > 0 do\n    encrypted_string = encrypted_string..alphabet[#s\
    \ + 1]\n    s = s .. alphabet[1]\n  end\n  return encrypted_string\nend", "  if\
    \ s == nil then\n    return nil\n  end\n  local cipher = ''\n  for i=1,#s do\n\
    \    local ch = string.sub(s, i, i+1)\n    cipher = cipher..string.sub(alphabet,\
    \ #alphabet, #alphabet+2)..ch\n  end\n  return cipher\nend", "\tlocal alphabet\
    \ = {\n\t\ta='mnopqrstuvwxy',\n\t\tb='ABCDEFGHIJKLM',\n\t\tc='NOPQRSTUVWXY',\n\
    \t\td='ABCDEFGHIJKLM',\n\t\te='MNOPQRSTUVWXY',\n\t\tf='ABCDEFGHIJKLM',\n\t\tg='NOPQRSTUVWXY',\n\
    \t\th='ABCDEFGHIJKLM',\n\t\ti='MNOPQRSTUVWXY',\n\t\tj='NOPQRSTUVWXY',\n\t\tk='ABCDEFGHIJKLM',\n\
    \t\tl='NOPQRSTUVWXY',\n\t\tm='MNOPQRSTUVWXY',\n\t\tn='NOPQRSTUVWXY',\n\t\to='ABCDEFGHIJKLM',\n\
    \t\tp='NOPQRSTUVWXY',\n\t\tq='ABCDEFGHIJKLM',\n\t\tr='NOPQRSTUVWXY',\n\t\ts='MNOPQRSTUVWXY',\n\
    \t\tt='NOPQRSTUVWXY',\n\t\tu='ABCDEFGHIJKLM',\n\t\tv='NOPQRSTUVWXY',\n\t\tw='ABCDEFGHIJKLM',\n\
    \t\tx='NOPQRSTUVWXY',\n\t\ty='ABCDEFGHIJKLM',\n\t\tz='NOPQRSTUVWXY',\n\t}\n\t\
    local result = ''\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i,i)\n\t\tresult =\
    \ result .. alphabet[math.floor((#alphabet+1)*c-1)]\n\tend\n\treturn result\n\
    end", "    return s:gsub(\"^(.)\", function(c) return string.char((string.len(c)+2)^2)\
    \ end)\nend", "\tlocal ret = ''\n\tlocal key = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \tfor i = 1, #s do\n\t\tret = ret .. key:sub(i*2, i*2+2) -- Rotate left 2 letters\
    \ by 2\n\tend\n\treturn ret\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~!@#$%^&*()_+-={}[];',./\"\
    \n  local ss = {}\n  for _,x in ipairs(s) do\n    table.insert(ss, alphabet:sub(x,x+2))\n\
    \  end\n  table.insert(ss, alphabet:sub(1,1))\n  return table.concat(ss, \"\"\
    )\nend", "  local a = {}\n  for i = 1, 26 do\n    a[i] = string.sub(alphabet,\
    \ (i-1) * 2, (i-1) * 2 + 2)\n  end", "\tlocal result = ''", "  local alphabet\
    \ = {\n    ['a'] = 'b' .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n   \
    \ ['b'] = 'a' .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['c'] = 'a'\
    \ .. 'b' .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['d'] = 'a' ..\
    \ 'b' .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['e'] = 'a' .. 'b'\
    \ .. 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['f'] = 'a' .. 'b' ..\
    \ 'c' .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['g'] = 'a' .. 'b' .. 'c'\
    \ .. 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['h'] = 'a' .. 'b' .. 'c' ..\
    \ 'd' .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['i'] = 'a' .. 'b' .. 'c' .. 'd'\
    \ .. 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['j'] = 'a' .. 'b' .. 'c' .. 'd' ..\
    \ 'e' .. 'f' .. 'g' .. 'h' .. 'i',\n    ['k'] = 'a' .. 'b' .. 'c' .. 'd' .. 'e'\
    \ .. 'f' .. 'g' .. 'h' .. 'i',\n    ['l'] = 'a' .. 'b' .. 'c' .. 'd' .. 'e' ..\
    \ 'f' .. 'g' .. 'h' .. 'i',\n    ['m'] = 'a' .. 'b' .. 'c' .. 'd' .. 'e' .. 'f'\
    \ .. 'g' .. 'h' .. 'i',\n    ['n'] = 'a' .. 'b' .. 'c' .. 'd' .. 'e' .. 'f' ..\
    \ 'g' .. 'h' .. ", "    local alphabet = {\n        string.char(tonumber(string.sub(s,1,1)))..string.char(string.char(string.sub(s,2,2)))..string.char(tonumber(string.sub(s,3,3)))..string.char(string.char(string.sub(s,4,4)))..string.char(tonumber(string.sub(s,5,5)))..string.char(string.char(string.sub(s,6,6)))..string.char(tonumber(string.sub(s,7,7)))..string.char(string.char(string.sub(s,8,8)))..string.char(tonumber(string.sub(s,9,9)))\n\
    \    }\n    local result = string.char(string.char(string.sub(s,1,1))..string.char(string.sub(s,2,2))..string.char(string.sub(s,3,3))..string.char(string.sub(s,4,4))..string.char(string.sub(s,5,5))..string.char(string.sub(s,6,6))..string.char(string.sub(s,7,7))..string.char(string.sub(s,8,8))..string.char(string.sub(s,9,9))..string.char(string.sub(s,10,10))..string.char(string.sub(s,11,11))..string.char(string.sub(s,12,12)))\n\
    \    return alphabet[string.sub(result,1,2)] .. alphabet[string.sub(result,3,4)]\
    \ .. alphabet[string.sub(result,5,6)] .. alphabet[string.sub(result,7,8)] .. alphabet[string.sub(result,9,10)]\
    \ .. alphabet[string.sub(result,11,12)] .. alphabet[string.sub(result,13,14)]\n\
    end", "\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\tlocal news = {}\n\t\
    for i, c in pairs(s) do\n\t\tlocal c1 = alphabet:sub(i, i + 1)\n\t\tlocal c2 =\
    \ alphabet:sub(i + 1, i + 2)\n\t\tlocal c3 = alphabet:sub(i + 2, i + 3)\n\t\t\
    local c4 = alphabet:sub(i + 3, i + 4)\n\t\tlocal c5 = alphabet:sub(i + 4, i +\
    \ 5)\n\t\tlocal c6 = alphabet:sub(i + 5, i + 6)\n\t\tlocal c7 = alphabet:sub(i\
    \ + 6, i + 7)\n\t\tlocal c8 = alphabet:sub(i + 7, i + 8)\n\t\tlocal c9 = alphabet:sub(i\
    \ + 8, i + 9)\n\t\tlocal c10 = alphabet:sub(i + 9, i + 10)\n\t\t\n\t\tlocal e1\
    \ = c2..c3..c4..c5..c6..c7..c8..c9..c10\n\t\tlocal e2 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\
    \t\tlocal e3 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\t\tlocal e4 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\
    \t\tlocal e5 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\t\tlocal e6 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\
    \t\tlocal e7 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\t\tlocal e8 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\
    \t\tlocal e9 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\t\tlocal e10 = c1..c2..c3..c4..c5..c6..c7..c8..c9..c10\n\
    \t\t\n\t\tnews[i] = e1\n\t\tnews[i + 1] = e2\n\t\tnews[i + 2] = e3\n\t\tnews[i\
    \ + 3] = e4\n\t\tnews[i + 4] = e5\n\t\tnews[i + 5] = e6\n\t\tnews[i + 6] = e7\n\
    \t\tnews[i + 7] = e8\n\t\tnews[i + 8] = e9\n\t\tnews[i + 9] = e10\n\tend\n\t\n\
    \treturn table.concat(news, '')\nend", "  local alphabet = s:gsub('([a-z])([a-z])',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])$',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet\
    \ = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet\
    \ = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet\
    \ = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet\
    \ = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet\
    \ = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet\
    \ = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$',\
    \ '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet\
    \ = alphabet:gsub('([a-z])([a-z])$', '$1 $2')\n  alphabet = alphabet:gsub('([a-z])([a-z])$',\
    \ '$1 $2')\n  alphabet", "   local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \   -- The code below is not cryptic.\n   local result = ''\n   for i = 1, #s\
    \ do\n      result = result .. alphabet[(alphabet .. alphabet)[i]:byte() .. alphabet]\n\
    \   end\n   return result\nend", "  -- Start by shifting letters down by twice\
    \ the frequency of \n  -- letters shifted down.\n  local map = {}\n  for i = string.len(s)\
    \ - 1; i >= 0; i-- do\n    local letter = string.sub(s, i, i)\n    map[letter]\
    \ = map[letter] + 2 \n  end", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  local alphabetLength = #alphabet\n  local i, sLen = #s, 1", "  -- Initialize\
    \ variables.\n  local letters = \"abcdefghijklmnopqrstuvwxyz\"\n  local result\
    \ = \"\"\n  -- Add two to the letter index by two, starting at the first\n  --\
    \ character.\n  for i = 0, #letters do\n    local index = letters[i]\n    local\
    \ char = letters[i+1]\n    result = (char)..(char)..(char)..(char)\n    -- If\
    \ the letter index is less than the original string length,\n    -- add the letter\
    \ from the original string. Otherwise, add the \n    -- character in the rotated\
    \ alphabet and add one to the letter\n    -- index.\n    if index < #s then\n\
    \      result = result..(letters[index])..(char)\n    else\n      result = result..(char)..(letters[index])\n\
    \    end\n  end\n  return result\nend", "    -- Create a string of length 26 based\
    \ on the characters in s.\n    -- This will be used to shift the characters down.\n\
    \    local alphabet = string.rep(string.letters, 26)\n    \n    -- Define a function\
    \ that shifts each letter down two places.\n    -- This will be used with the\
    \ string.gsub() function\n    local shift = function(a,b) return string.char(((a-1)..b)\
    \ end\n    \n    -- Perform the encryption using a for loop and string.gsub()\n\
    \    -- A for loop is used instead of an iterator because it's simpler.\n    --\
    \ This for loop will run through the string, starting at the\n    -- second character,\
    \ and stop when it reaches the end of the\n    -- string.\n    -- string.gsub()\
    \ replaces the character at the given position\n    -- and then repeats the process\
    \ until the string is complete.\n    for i = 2, #s do\n        s = string.gsub(s,alphabet,shift(alphabet,2))\n\
    \    end\n    \n    -- Return the encrypted string\n    return s\nend", "    local\
    \ result = ''\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for i =\
    \ #s, 1, -1 do\n        local char = alphabet[#alphabet]\n        alphabet = alphabet[1:#alphabet]\n\
    \        alphabet = alphabet[2 + #alphabet]\n        result = result .. char\n\
    \    end\n    return result\nend", "  -- Initialize an empty string to return\n\
    \  local encrypted = ''", "\tlocal alph = string.gsub(string.gsub(alphabet, \"\
    (.)\", function (c) c * 2 end), \"(.)\", function (c) string.sub(alphabet, string.len(alphabet)\
    \ - string.len(c) - 1, string.len(alphabet)) end)\n\treturn table.concat(string.gmatch(s,\
    \ '([^' .. alph .. ']+)'), alph)\nend", "\tlocal alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\tlocal alphabetLength = #alphabet\n\tlocal result = ''", "\tlocal alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tlocal result = \"{\"\n\t\n\t-- Iterate over\
    \ each letter in the string\n\tfor i = 1, #s do\n\t\t-- For every letter that\
    \ is not the last\n\t\t-- letter of the string, add the string to the \n\t\t--\
    \ result string \n\t\tif i != #s - 1 then\n\t\t\t-- Take the current letter and\
    \ add it to the \n\t\t\t-- result string\n\t\t\tresult = result .. alphabet[alphabet.indexOf(s[i]):(alphabet.indexOf(s[i+1]))]\n\
    \t\t\n\t\t\t-- If the current letter we are looking at is the \n\t\t\t-- last\
    \ letter of the string, add the \"}\" to the\n\t\t\t-- result string.\n\t\t\t\
    else\n\t\t\t\tresult = result .. \"}\"\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn\
    \ result\nend", "    local alphabet = {\n        alpha  = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\
    \        alpha2 = 'bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n   \
    \     alpha3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n     \
    \   alpha4 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\
    \        alpha5 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\
    \    }\n    local alphabet2 = {\n        alpha  = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\
    \        alpha2 = 'bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n   \
    \     alpha3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n     \
    \   alpha4 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\
    \        alpha5 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\
    \    }\n    local alphabet3 = {\n        alpha  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\
    \        alpha2 = 'bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n   \
    \     alpha3 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n     \
    \   alpha4 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\
    \        alpha5 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\
    \    }\n    local alphabet4 = {\n        alpha  = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  "  local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  local\
    \ alphabetRev = alphabet:reverse()\n  local alphabetRot = alphabet:rotate(2)\n\
    \  local alphabetRotRev = alphabetRot:reverse()\n  local alphabetRotRevRev = alphabetRotRev:reverse()\n\
    \  local result = ''\n  for i = 1, #s do\n    local char = s[i]\n    local charRotate\
    \ = char:rotate(2)\n    local charRotRev = charRotate:reverse()\n    local charRotRevRev\
    \ = charRotRev:reverse()\n    local charRotRevRevRev = charRotRevRev:reverse()\n\
    \    local charRevRot = charRot:reverse()\n    local charRevRotRev = charRevRot:reverse()\n\
    \    local charRevRotRevRev = charRevRotRev:reverse()\n    local charRevRotRevRevRev\
    \ = charRevRotRevRev:reverse()\n    local charRotRevRevRotRev = charRotRevRevRev:rotate(2)\n\
    \    local charRotRevRevRotRevRev = charRotRevRevRotRev:reverse()\n    local charRotRevRevRevRotRevRev\
    \ = charRotRevRevRevRotRev:reverse()\n    local charRevRotRotRevRevRevRev = charRevRotRotRevRevRev:reverse()\n\
    \    local charRevRotRevRevRevRotRevRev = charRevRotRevRevRevRotRev:reverse()\n\
    \    local charRevRotRevRevRotRevRotRevRevRev = charRevRotRevRevRevRotRevRotRev:reverse()\n\
    \    local charRotRevRevRevRotRevRotRevRotRevRevRev = charRotRevRevRevRotRevRotRevRotRevRev:reverse()\n\
    \    local charRevRotRevRevRevRotRevRotRevRotRevRevRevRev = charRotRevRevRevRotRevRotRevRotRevRotRevRotRevRev:reverse()\n\
    \    local charRotRe", "  -- Get the length of the string and divide by two.\n\
    \  local len = #s\n  local n = len / 2", "   assert(type(s) == 'string', 'The\
    \ string must be of type: string')\n   assert(type(alphabet) == 'table', 'The\
    \ alphabet must be a table')", "  local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  -- The first character in the alphabet shifts to the left by two, \n  -- and\
    \ the second character shifts to the left by one to the right \n  -- of what it\
    \ was shifting right before.\n  -- For example, if the string is 'hi', then\n\
    \  -- abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ \n  -- becomes the\
    \ string 'klmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZab'\n  -- before being rotated\
    \ to the left.\n  local shifted_alphabet = alphabet..alphabet\n  -- The first\
    \ two characters in the alphabet shifts to the right\n  -- by one, the second\
    \ two characters to the right by two, etc. \n  -- For example, if the string is\
    \ 'hi', then\n  -- abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n  --\
    \ becomes the string 'abklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  -- before\
    \ being rotated to the right.\n  local rotated_alphabet = shifted_alphabet..shifted_alphabet\n\
    \  -- Rotate the string in the alphabet to the left by a number of \n  -- characters,\
    \ where each character in the alphabet is multiplied\n  -- to the number of shifts\
    \ being performed.\n  -- For example, if 'hi' is rotated 3 times to the left by\
    \ 1, then\n  -- abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ becomes\n\
    \  -- abcklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n\
    \  return string.gsub(s, \"(.)(.)\",\n    function(c)\n      return string.sub(rotated_alphabet,\
    \ string.len(rotated_alphabet)-#c+1, \n        string.len(rotated_alphabet)-#c+#c+1,\
    \ \n        string.len(rotated_alphabet)-#c+#c+#c+1, \n        string.len(rotated_alphabet))..c\n\
    \    end\n  )\nend", "    local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'}\n    local alphabet2 = alphabet:sub(1, alphabet:len()-2):reverse()\n\
    \    local alphabet3 = alphabet:sub(1, alphabet:len()-1):reverse()\n    \n   \
    \ -- Create and return a function that returns a string encrypted\n    -- with\
    \ the alphabet being rotated. The alphabet should be rotated\n    -- in a manner\
    \ such that the letters shift down by two multiplied to \n    -- two places.\n\
    \    return function() return alphabet2[s:byte():byte() * 2 % alphabet:len()]:reverse():sub(1,\
    \ 1):reverse() end\nend", "  -- Your code here\nend", "  s = string.lower(s)\n\
    \  local alphabet = string.gsub(string.gsub(\"abcdefghijklmnopqrstuvwxyz\",\n\
    \                                            \"c\", \"z\"), \"a\", \"d\")\n  local\
    \ newS = ''\n  for i = 1, #s, 1 do\n    local newLetter = alphabet[#alphabet]\n\
    \    newS = newS..newLetter\n  end\n  return newS..s[#s-1]\nend", "  -- Your code\
    \ goes here!\n  return s\nend", "\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \t-- Calculate the new letter to substitute to the first letter\n\tlocal alphaNew\
    \ = alphabet + alphabet\n\tlocal alphaNewLength = #alphaNew\n\tlocal alphaNewLength\
    \ = alphaNewLength + 2\n\tlocal alphaNew = string.char(string.sub(alphaNew, 1,\
    \ alphaNewLength))\n\t-- Convert the string to a list of single characters, one\
    \ \n\t-- for each letter of the alphabet.\n\tlocal alphaList = {}\n\tfor i = 1,\
    \ alphaNewLength do\n\t\talphaList[i] = string.sub(alphaNew, i, i)\n\tend\n\t\
    -- Append a new letter after the first letter, if the new letter\n\t-- is shifted\
    \ over two letters, then it is inserted after the\n\t-- second letter.\n\tlocal\
    \ alphaListLength = #alphaList\n\tlocal alphaListLength2 = alphaListLength + 2\n\
    \tlocal newLetter = string.char(string.sub(alphaNew, 1, alphaListLength))\n\t\
    local newLetter2 = string.char(string.sub(alphaNew, 1, alphaListLength2))\n\t\
    -- Insert a new letter after the second letter, if the new letter is\n\t-- shifted\
    \ over two letters, then it is inserted after the third letter.\n\tlocal alphaListLength3\
    \ = alphaListLength2 + 2\n\tlocal newLetter3 = string.char(string.sub(alphaNew,\
    \ 1, alphaListLength2))\n\t-- If the new letter is shifted over two letters, then\
    \ it will\n\t-- be inserted after the third letter and the letter is appended\n\
    \t-- before the fourth letter.\n\tlocal alphaListLength4 = alphaListLength3 +\
    \ 2\n\tlocal newLetter4 = string.char(string.sub(alphaNew, 1, alphaListLength3))\n\
    \t-- If the new letter is shifted over two letters, then it will\n\t-- be inserted\
    \ after the fifth letter and the letter is appended\n\t-- before the sixth letter.\n\
    \tlocal alphaListLength5 = alphaListLength4 + 2\n\tlocal newLetter5 = string.char(string.sub(alphaNew,\
    \ 1, alphaListLength4))\n\t-- If the new letter is shifted over two letters, then\
    \ it will\n\t-- be inserted after the seventh letter and the letter is appended\n\
    \t-- before the eighth letter.\n\tlocal alphaListLength6 = alphaListLength5 +\
    \ 2\n\tlocal newLetter6 = string.char(string.sub(alphaNew, 1, alphaListLength5))\n\
    \t-- If the new letter is shifted over two letters, then it will\n\t-- be inserted\
    \ after the ninth letter and the letter is appended\n\t-- before the tenth letter.\n\
    \tlocal ", "    local alphabet_size = 26\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local encrypted_string = 'z'\n    for i=1,#s do\n        local current_char\
    \ = s:sub(i,i)\n        encrypted_string = encrypted_string .. alphabet:sub(#alphabet\
    \ - alphabet_size - alphabet_size + alphabet:find(current_char) + 2, #alphabet)\n\
    \    end\n    return encrypted_string\nend", "  local alph = string.gsub(string.char(27:32),\
    \ '[%z\\1-\\127]+', string.char(27))\n  local str = ''\n  local pos = 0\n  for\
    \ i = 1, #s do\n    local c = string.sub(s, i, i)\n    local n = alph:index(string.lower(c))\n\
    \    n = ((n+2)%26) + 1\n    str = str .. string.sub({string.char(27), string.char(n),\
    \ string.char(n+2)}, 1, 2)\n  end\n  return str\nend", "  -- Convert string to\
    \ ASCII table.\n  s = s:gsub('\\r\\n','\\n')\n  s = s:gsub('\\r','\\n')\n  s =\
    \ s:gsub('\\015','\\n')\n  s = s:gsub('\\012','\\n')\n  s = s:gsub('\\011','\\\
    n')\n  s = s:gsub('\\010','\\n')\n  s = s:gsub('\\013','\\n')\n  s = s:gsub('\\\
    014','\\n')\n  s = s:gsub('\\015','\\n')\n  s = s:gsub('\\016','\\n')\n  s = s:gsub('\\\
    017','\\n')\n  s = s:gsub('\\018','\\n')\n  s = s:gsub('\\019','\\n')\n  s = s:gsub('\\\
    020','\\n')\n  s = s:gsub('\\021','\\n')\n  s = s:gsub('\\022','\\n')\n  s = s:gsub('\\\
    023','\\n')\n  s = s:gsub('\\024','\\n')\n  s = s:gsub('\\025','\\n')\n  s = s:gsub('\\\
    026','\\n')\n  s = s:gsub('\\027','\\n')\n  s = s:gsub('\\028','\\n')\n  s = s:gsub('\\\
    029','\\n')\n  s = s:gsub('\\030','\\n')\n  s = s:gsub('\\031','\\n')\n  s = s:gsub('\\\
    032','\\n')\n  s = s:gsub('\\033','\\n')\n  s = s:gsub('\\034','\\n')\n  s = s:gsub('\\\
    035','\\n')\n  s = s:gsub('\\036','\\n')\n  s = s:gsub('\\037','\\n')\n  s = s:gsub('\\\
    040','\\n')\n  s = s:gsub('\\041','\\n')\n  s = s:gsub('\\042','\\n')\n  s = s:gsub('\\\
    043','\\n')\n  s = s:gsub('\\044','\\n')\n  s = s:gsub('\\045','\\n')\n  s = s:gsub('\\\
    046','\\n')\n  s = s:gsub('\\047','\\n')\n  s = s:gsub('\\048','\\n')\n  s = s:gsub('\\\
    049','\\n')\n  s = s:gsub('\\050','\\n')\n  s = s:gsub('\\051','\\n')\n  s = s:gsub('\\\
    052','\\n')\n  s = s:gsub('\\053','\\n')\n  s = s:gsub('\\054", "\tlocal alphabet\
    \ = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.",
  "\t-- Define a function that shifts letters down by two, and\n\t-- then multiplies\
    \ by two to shift the letters down by four\n\treturn string.gsub(string.gsub(s,\
    \ '(.)', '\\1'..'\\2'), \n\t\t'(.)', '\\1'..'\\4'..'\\3')\nend", "  assert(type(s)\
    \ ~= 'string', 'Expected a string')\n  assert(#s ~= 0, 'Empty string')\n  -- The\
    \ alphabet is rotated in a manner such that the letters\n  -- shift down by two\
    \ multiplied to two places.\n  -- For example:\n  -- encrypt('hi') returns 'lm'\n\
    \  -- encrypt('asdfghjkl') returns 'ewhjklnop'\n  -- encrypt('gf') returns 'kj'\n\
    \  -- encrypt('et') returns 'ix'\n  local rot = 'ghijklmnopqrstuvwxyz'\n  return\
    \ string.reverse(string.gsub(s, '[a-z]', function()\n    -- The alphabet is rotated\
    \ in a manner such that the letters\n    -- shift down by two multiplied to two\
    \ places.\n    local shift = rot:sub(1, 1) + rot:sub(2, 2)\n    return string.sub(rot,\
    \ 1, rot:find(shift)-1)\n  end)..string.sub(rot, rot:find(shift)))\nend", "\t\
    assert(type(s) == 'string')\n\tlocal alphabet = string.gsub(string.gsub(s, '(.)',\
    \ function(c) \n\t\treturn string.char(((string.len(c) - 1) * 2) + string.char(c))\n\
    \tend), '(.)', function(c) return string.char((string.len(c) - 1) * 2 - 1) end)\n\
    \talphabet = string.gsub(alphabet, '(.)', function(c) return string.char((string.len(alphabet)\
    \ - 1) * 2 - 1) end)\n\talphabet = string.gsub(alphabet, '(.)', function(c) return\
    \ string.char((string.len(alphabet) - 1) * 2 + 1) end)\n\talphabet = string.gsub(alphabet,\
    \ '(.)', function(c) return string.char((string.len(alphabet) - 1) * 2 + 2) end)\n\
    \talphabet = string.gsub(alphabet, '(.)', function(c) return string.char((string.len(alphabet)\
    \ - 1) * 2 + 3) end)\n\talphabet = string.gsub(alphabet, '(.)', function(c) return\
    \ string.char((string.len(alphabet) - 1) * 2 + 4) end)\n\talphabet = string.gsub(alphabet,\
    \ '(.)', function(c) return string.char((string.len(alphabet) - 1) * 2 + 5) end)\n\
    \talphabet = string.gsub(alphabet, '(.)', function(c) return string.char((string.len(alphabet)\
    \ - 1) * 2 + 6) end)\n\talphabet = string.gsub(alphabet, '(.)', function(c) return\
    \ string.char((string.len(alphabet) - 1) * 2 + 7) end)\n\talphabet = string.gsub(alphabet,\
    \ '(.)', function(c) return string.char((string.len(alphabet) - 1) * 2 + 8) end)\n\
    \talphabet = string.gsub(alphabet, '(.)', function(c) return string.char((string.len(alphabet)\
    \ - 1) * 2 + 9) end)\n\talphabet = string.gsub(alphabet, '(.)', function(c) return\
    \ string.char((string.len(alphabet) - 1) * 2 + 10) end)\n\talphabet = string.gsub(alphabet,\
    \ '(.)', function(c) return string.char((string.len(alphabet) - 1) * 2 + 11) end)\n\
    \talphabet = string.gsub(alphabet, '(.)', function(c) return string.char((string.len(alphabet)\
    \ - 1) * 2 + 12) end)\n\talphabet = string.gsub(alphabet, '(.)', function(c) return\
    \ string.char((string.len(alphabet) - 1) * 2 + 13) end)\n\talphabet = string.gsub(alphabet,\
    \ '(.)', function(c) return string.char((string.len(alphabet) - 1) * 2 + 14) end)\n\
    \talphabet = string.gsub(alphabet, '(.)', function(c) return string.char((string.len(alphabet)\
    \ - 1) * 2 + 15) end)\n\talphabet = string.gsub(alphabet, '(.)', function(c) return\
    \ string.char((string.len(alphabet) - 1) * 2 + 16) end)\n\talphabet = string.gsub(alphabet,\
    \ '(.)', function(c) return string.char((string.len(alphabet) - ", "    -- Encode\
    \ the string into an array of characters, then apply the \n    -- shift operation\n\
    \    local result = {}\n    for i,c in ipairs(s) do\n        result[((i:byte()\
    \ + 2)/2):byte()] = c\n    end\n    return table.concat(result, '') -- Rotate\
    \ the string\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  local\
    \ n = {}\n  for _, c in pairs(s) do\n    n[c] = alphabet .. alphabet:sub(_ + 1,\
    \ _ + 2)\n  end\n  return table.concat(n, '')\nend", "  local alphabet = {'a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  \n  local result = \"\"\n  for\
    \ i=1,#s do\n    local ch = s:sub(i,i)\n    local n = alphabet:find(ch)\n    if\
    \ n ~= nil then\n      n = n - alphabet:len()\n      local alpha = alphabet:sub(n,n+1)\n\
    \      result = result .. alpha\n      n = n - alphabet:len()\n      local alpha\
    \ = alphabet:sub(n,n+1)\n      result = result .. alpha\n    else\n      result\
    \ = result .. ch\n    end\n  end\n  return result\nend", "  s = string.lower(s)\n\
    \  s = string.gsub(s, '[azy]', '[azy]' .. '[azy]') -- change all a's and y's\n\
    \  return s\nend", "  s = s:upper()\n  local key = {}\n  for i=1, #s, 2 do\n \
    \   table.insert(key, s[i])\n    table.insert(key, s[#key])\n  end\n  return table.concat(key,\
    \ '')\nend", "  assert(type(s) == \"string\", 'Expected a string input')\n  assert(#s\
    \ ~= 0, 'Expected non-empty string')\n  \n  -- Create a table with a single letter,\
    \ rotated to the left by one\n  local rotation = { [#rotation+1] = 'a' }\n  \n\
    \  -- Append the encrypted letter to the beginning of our original string\n  local\
    \ encrypted_s = s .. rotation.[#rotation]\n  \n  -- Return the encrypted string\n\
    \  return encrypted_s\nend", "  -- Write your code here\n  local str = ''\n  local\
    \ i = 0\n  while true do\n    local c = string.sub(s, i, i+1)\n    i = i + 1\n\
    \    if c ~= '' then\n      str = str .. string.char(tonumber(c) + 2)\n    else\n\
    \      break\n    end\n  end\n  return str\nend", "  -- Encode the string.\n \
    \ local letters = {}\n  for i, letter in ipairs(alphabet) do\n    table.insert(letters,\
    \ string.sub(s,1,i+1):lower())\n  end\n  \n  -- Rotate the letters.\n  local new_letters\
    \ = {}\n  for i, letter in ipairs(letters) do\n    table.insert(new_letters, alphabet[#letters\
    \ - i - 1])\n  end\n  \n  -- Decode the string.\n  return string.char(tonumber(new_letters))\n\
    end", "  -- Your code here\n  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \  local alpha = {}\n  for i=1,26 do alpha[i] = alphabet[i] end\n  local alpha\
    \ = alpha\n  local alpha = alphabet\n  for i=1,26 do alpha[alphabet.len()+i] =\
    \ alphabet[i] end\n  local alpha = alpha\n  local alpha = alphabet\n  return alpha\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe code `return alpha` is unnecessary, `alpha`\
    \ variable is already an indexed array (in this case of 26 elements). Also it's\
    \ better to just use letters variable name than alphabet, so the code would be\
    \ just `local alphabet = \"abcdefghijklmnopqrstuvwxyz\"`, then `return alphabet`.\n\
    <|/ c |>\n<| a |>\nI implemented the solution by KevinS. \n<code>", "\tlocal newS\
    \ = \"\";\n\t\n\tfor i,v in ipairs(s) do\n\t\tnewS = newS .. tostring(v + 2)\n\
    \tend", "   assert(type(s) == 'string', 'invalid string input')\n   assert(type(a)\
    \ == 'table', 'invalid alphabet table')", "   if s == nil then\n      return ''\n\
    \   end\n   local alphabet = string.char(97, 102, 105, 109, 112, 98, 101, 114)\
    \ \n   return alphabet:sub(1, alphabet:len()-s):gsub(s, alphabet:sub(alphabet:len()-s))\n\
    end", "    local alphabet = {\n        'a',  'b',  'c', 'd',  'e',  'f',  'g',\
    \  'h',  'i',  'j',\n        'k',  'l',  'm',  'n',  'o',  'p',  'q',  'r',  's',\
    \  't',\n        'u',  'v',  'w',  'x',  'y',  'z',  'a', 'b', 'c', 'd', 'e',\n\
    \        'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\n       \
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    }"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
