name: HumanEval_25_factorize
language: lua
prompt: "-- Return list of prime factors of given integer in the order from smallest\
  \ to largest.\n-- Each of the factors should be listed number of times corresponding\
  \ to how many times it appeares in factorization.\n-- Input number should be equal\
  \ to the product of all factors\n-- >>> factorize(8)\n-- [2, 2, 2]\n-- >>> factorize(25)\n\
  -- [5, 5]\n-- >>> factorize(70)\n-- [2, 5, 7]\nlocal function factorize(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = factorize\n\
  \    lu.assertEquals(candidate(2), {2})\n    lu.assertEquals(candidate(4), {2, 2})\n\
  \    lu.assertEquals(candidate(8), {2, 2, 2})\n    lu.assertEquals(candidate(57),\
  \ {3, 19})\n    lu.assertEquals(candidate(3249), {3, 3, 19, 19})\n    lu.assertEquals(candidate(185193),\
  \ {3, 3, 3, 19, 19, 19})\n    lu.assertEquals(candidate(20577), {3, 19, 19, 19})\n\
  \    lu.assertEquals(candidate(18), {2, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Initialize array where factors will be stored\n  local factors\
    \ = {}\n  -- Compute prime factors\n  for i=2,math.sqrt(n) do\n    -- If i is\
    \ prime.\n    if n%d == 0 then\n      -- Store factor of i in array\n      factors[i]\
    \ = 1\n      -- Divide n by i\n      n = n / i\n      -- While n isn't 1\n   \
    \   while n ~= 1 do\n        -- Multiply current value of n by every factor in\
    \ array\n        for _, v in ipairs(factors) do\n          n = n * v\n       \
    \ end\n      end\n    end\n  end\n  return factors\nend", "    -- Sieve of Eratosthenes\n\
    \    n = math.floor(n)\n    local limit = (math.sqrt(math.pow(n, 0.5)) + 1)\n\
    \    local d = 2 * math.floor(math.log(limit, 2)) - 1\n    local primes = {n ^\
    \ 2 - 1}\n    while d do\n        local m = n % primes[d]\n        if m == 0 then\n\
    \            primes[d] = primes[d] + 1\n        else\n            primes[d] =\
    \ m\n        end\n        local c = d\n        while n % primes[c] == 0 do\n \
    \           primes[c] = primes[c] + 1\n            c = c + 1\n        end\n  \
    \      d = d - 1\n    end\n    local factors = {}\n    for i = 2, primes[#primes]\
    \ do\n        table.insert(factors, i)\n    end\n    table.sort(factors)\n   \
    \ return factors\nend", "    if n <= 1 then\n        return {n}\n    end", '  if
    n < 2 then return end', "    local factors = {}\n    local is_prime, p, factor\n\
    \    for i = 2, n do\n        factor = 1\n        is_prime = 1\n        for j\
    \ = 2, n do\n            if n % j == 0 then\n                is_prime = 0\n  \
    \              factors = factors .. j .. factor\n                factor = factor\
    \ + 1\n            else\n                break\n            end\n        end\n\
    \        if is_prime then\n            factors = factors .. factor\n         \
    \   factor = factor + 1\n        end\n    end\n    return factors\nend", "  local\
    \ factors = {}\n  local factors_count = 0\n  for i = 2, n do\n    factors[n -\
    \ i] = i\n    factors_count = factors_count + 1\n  end", "    local factors =\
    \ {}\n    for i = 2, n do\n        while n % i == 0 then\n            n = n /\
    \ i\n            table.insert(factors, i)\n        end\n    end\n    return factors\n\
    end", "  -- Get prime factorization of n\n  local factorization = {}\n  local\
    \ primes = {}\n  for i = 2, n do\n    primes[#primes + 1] = 2\n  end\n  for i\
    \ = 2, #primes do\n    while n % primes[i] == 0 do\n      factorization[#factorization\
    \ + 1] = primes[i]\n      n = n / primes[i]\n    end\n  end\n  return factorization\n\
    end", "    local factors = {}\n    local x = 1\n    local i = 1\n    while n >\
    \ 1 do\n        if n % i == 0 then\n            n = n / i\n            factors[i]\
    \ = x\n            i = i + 1\n            x = x+1\n        end\n    end\n    if\
    \ x > 1 then\n        factors[i] = x\n    end\n    return factors\nend", "   \
    \ local factors = {} -- store the factors\n    local i = 2\n    while i <= n do\n\
    \        if n % i == 0 then\n            n = n / i\n            table.insert(factors,\
    \ i, n)\n        end\n        i = i + 1\n    end\n    return factors\nend", " \
    \ -- Make list of all prime factors of n\n  -- Return list with numbers of their\
    \ appearance in factorization\n  -- In case of n being prime - then it has no\
    \ factors\n  -- So the function returns empty list\n  if n == 1 then\n    return\
    \ {}\n  end", "    -- We return an empty list instead of nil in order to save\
    \ memory.\n    local factors = {}\n    local factor = 1\n    while factor <= n\
    \ do\n        if n % factor == 0 then\n            -- Remove factor from n\n \
    \           n = n / factor\n            -- Increment count for factor\n      \
    \      factors[#factors+1] = factor\n        end\n        factor = factor + 1\n\
    \    end\n    return factors\nend", "  if n < 2 then return [1] end\n  local factors\
    \ = {}\n  local i = 2\n  while i <= math.sqrt(n) do\n    if not factors[i] then\n\
    \      factors[i] = 1\n      i = 3\n      while i * i <= n do\n        if not\
    \ factors[i * i] then\n          factors[i * i] = i\n          i = i + i\n   \
    \     else\n          i = i + i\n        end\n      end\n    end\n    i = i +\
    \ 1\n  end\n  return factors\nend", "  -- base case\n  if n == 1 then return [2]\
    \ end", "  n = n % 6 == 1 -- check if n is prime\n  if n == 0 then\n    return\
    \ {2, 1}\n  end\n  local a = {2, 3}\n  local i = 1\n  while a[i] < n do\n    i\
    \ = i + 1\n  end\n  local p = i\n  local q = i\n  while p * p <= n do\n    p =\
    \ p * 2\n    while p * p <= n do\n      q = q * 2\n      if n > q then\n     \
    \   break\n      end\n      if n % p == 0 then\n        n = (n / p) + 1 -- reminder\
    \ for n/p is 1 as long as n is not divisible by p\n      end\n    end\n    if\
    \ p * p > n then\n      p = q\n    end\n  end\n  a[i] = n\n  local factors = {}\n\
    \  for i = 1, p do\n    local c = 0\n    while n ~= 1 do\n      if n % i == 0\
    \ then\n        n /= i\n        c = c + 1 -- counting factor in factors\n    \
    \  elseif i == p then\n        n = n / i\n      end\n    end\n    factors[#factors\
    \ + c] = i\n  end\n  return factors\nend", "  local factors = {} -- List for storing\
    \ factors\n  for i = 2, math.floor(n) do -- Get list of factors\n    local p =\
    \ n / i\n    if p and math.floor(p) == p then -- If p is prime number\n      if\
    \ i ~= n then -- Check if it's already in the factorization\n        for j = 1,\
    \ i do\n          if p * i == j then\n            factors[#factors+1] = i\n  \
    \        end\n        end\n      end\n    end\n  end\n  factors = {n} -- the last\
    \ number in the list is the number itself\n  return factors\nend", "    local\
    \ factors = {}\n    local i = 1\n    \n    while i <= math.sqrt(n) do\n      \
    \  if n % i == 0 then\n            n = n / i\n            table.insert(factors,\
    \ i)\n        end\n        i = i + 1\n    end\n    \n    if n ~= 1 then\n    \
    \    table.insert(factors, n)\n    end\n    \n    return factors\nend", '    local
    factors = {}', "  -- Find prime factors and its multiples\n  local factors = {}\n\
    \  local mult = {}\n  for i = 2, n do\n    local factor = 1\n    for j = 2, i\
    \ do\n      if n % i == 0 then\n        factor = factor * j\n      end\n    end\n\
    \    if factor > 1 then\n      factors[#factors + 1] = factor\n      mult[factor]\
    \ = mult[factor] + 1 or 1\n    end\n  end\n  -- Sort factors and multiples\n \
    \ table.sort(factors)\n  table.sort(mult)\n  -- Create output table\n  local output\
    \ = {}\n  for i = 2, n do\n    table.insert(output, 1)\n    if mult[i] ~= 1 then\n\
    \      output[#output + 1] = mult[i]\n    end\n  end\n  return output\nend", " \
    \   local factors = {}\n    local factorization = {}\n    for i = 2, n do\n  \
    \      if n % i == 0 then\n            local tmp = {}\n            for j = 2,\
    \ n / i do\n                if n % i == 0 then\n                    table.insert(tmp,\
    \ i)\n                    n = n / i\n                else\n                  \
    \  n = n / i\n                    table.insert(tmp, i)\n                    break\n\
    \                end\n            end\n            table.insert(factorization,\
    \ table.remove(tmp))\n            table.insert(factors, i)\n        end\n    end\n\
    \    return factors, factorization\nend", "    local factors = {}\n    local div\
    \ = 2\n    local factor = 1", "  if n < 2 then return nil end\n  local f = {}\n\
    \  for i = 1, n do\n    local t = i * i\n    if t <= n then f[t] = f[t] or i end\n\
    \  end\n  return f\nend", "    local factors = {}\n    for i = 1, n do\n     \
    \   for j = 1, i do\n            if n % j == 1 then\n                table.insert(factors,\
    \ j)\n                n = n / j\n                break\n            end\n    \
    \    end\n    end", "  local f = {}\n  local primes = {}\n  local is_prime = true\n\
    \  local i = 1\n  local j = 1\n  while i <= n do\n    local p, q = math.divmod(i,\
    \ n)\n    if not f then\n      f = {}\n      primes = {}\n      is_prime = true\n\
    \    end\n    if not primes[p] then\n      primes[p] = true\n      f[p] = f[p]\
    \ or {}\n      is_prime = false\n    end\n    if not f[p][q] then\n      f[p][q]\
    \ = i\n      j = j + 1\n      if j > n and n ~= 2 * i then\n        break -- Exit\
    \ loop when all factors are added to list of factors.\n      end\n    end\n  \
    \  i = p + 1\n  end\n  if is_prime then\n    return primes\n  end\n  i = 2\n \
    \ while i <= n do\n    if f[i] then\n      f[i] = {}\n    end\n    i = i + 1\n\
    \  end\n  table.sort(primes)\n  local lp = primes[1]\n  local lpf = f[lp]\n  local\
    \ i = 1\n  while i <= n do\n    if not lpf[i] then\n      lpf[i] = f[i]\n    end\n\
    \    i = i + 1\n  end\n  return primes\nend", "    local factors = {}\n    for\
    \ i = 2, math.floor(n/2) do\n        if n % i == 0 then\n            local factor\
    \ = i\n            repeat\n                if n % i == 0 then\n              \
    \      n = n / i\n                    factor = i\n                else\n     \
    \               n = n / i\n                end\n            until n >= 1\n   \
    \         if n ~= 1 then\n                table.insert(factors, factor)\n    \
    \        end\n        end\n    end\n    return factors\nend", "  -- Prime factors\
    \ of n\n  local factors = {}\n  -- Compute prime factorization of n\n  for i =\
    \ 2, n do\n    if n % i == 0 then\n      factors[i] = i\n      n = n / i\n   \
    \ end\n  end\n  return factors\nend", "    local factors = {}\n    for i = 2,\
    \ n do\n        local c = n/i\n        if c > 1 then\n            factors[#factors\
    \ + 1] = i\n            factorize(c)\n        end\n    end\n    return factors\n\
    end", "    local factor = {}\n    local div = math.floor -- math.floor - rounds\
    \ down\n    for i = 1, n do\n        while n % i == 0 do\n            factor[i]\
    \ = 1\n            n = div(n, i)\n        end\n    end\n    return factor\nend",
  "  -- If given number is already factorized then just return its factors\n  if factorizes[n]\
    \ then\n    return factorizes[n]\n  end\n  -- If number is 1 or 0 then return\
    \ [1]\n  if n == 1 or n == 0 then\n    return [1]\n  end\n  -- Find largest factor\
    \ greater than or equal to given number\n  -- Ex: 70 > 2 * 5 so return [2] instead\
    \ of [5, 7]\n  local m = math.floor(n/2)\n  -- Find factors less than the given\
    \ number\n  -- Ex: 25 < 2 * 5 so return [5] instead of [5, 5, 5, 5]\n  local f\
    \ = factorizes[m]\n  if f == nil then\n    local i, j, k = 1, n, m\n    while\
    \ i <= j do\n      if n % i == 0 then\n        j = i - 1\n        k = i\n    \
    \  else\n        j = math.floor(math.sqrt(n/i))\n        k = k * i\n      end\n\
    \    end\n    -- If a number is divisible by all the factors then it can't be\
    \ factorized so return nil\n    if m == k then\n      factorizes[n] = nil\n  \
    \    return nil\n    end\n    -- Otherwise, find the smallest factor that is greater\
    \ than or equal to the given number and divide n by it\n    -- Ex: 70 > 2 * 5\
    \ so return 2 instead of 5\n    local x = math.ceil(math.sqrt(k/m))\n    factorizes[n]\
    \ = x\n    -- Find factors greater than or equal to given number and divide n\
    \ by it\n    -- Ex: 25 > 2 * 5 so return 5 instead of 7\n    local z = n/x\n \
    \   f, k = factorizes[z]\n    if k ~= nil and k ~= m then\n      factorizes[z]\
    \ = nil\n    end\n    -- If there was no factor larger than the given number then\
    \ return nil\n    if f == nil then\n      factorizes[n] = nil\n      return nil\n\
    \    end\n    -- If there was a factor larger than the given number then return\
    \ the given factor\n    if f ~= nil then\n      factorizes[n] = f\n      return\
    \ f\n    end\n    -- If all factors were less than the given number then return\
    \ nil\n    if n == 1 or n == m then\n      factorizes[n] = nil\n      return nil\n\
    \    end\n  end\n  -- Return the list of factors\n  return factorizes[m]\nend",
  "  n = n + 1\n  local factors = {}", "\tassert(n > 1)\n\tlocal factors = {}\n\t\
    local factor = 1\n\trepeat\n\t\tif n % factor == 0 then\n\t\t\ttable.insert(factors,\
    \ factor)\n\t\t\tn = n / factor\n\t\telse\n\t\t\ttable.insert(factors, factor)\n\
    \t\t\tbreak\n\t\tend\n\t\tfactor = factor + 1\n\tuntil not n or n % factor ==\
    \ 0\n\treturn factors\nend", "    local factors = {}\n    local f = math.floor(math.sqrt(n))\n\
    \    for i = 1, f do\n        if n % i == 0 then\n            table.insert(factors,\
    \ i)\n            n = n / i\n        end\n    end\n    table.insert(factors, n)\n\
    \    return factors\nend", "    local factors = {}\n    local p = 2\n    while\
    \ p * p <= n do\n        local d = n % p\n        if d then\n            factors[d]\
    \ = factors[d] + 1 or 1\n        end\n        p = p * 2\n    end\n    return factors\n\
    end", "    local factors = {}\n    local factor = 1\n    while factor <= n do\n\
    \        factors[factor] = factors[factor] + 1 or 1\n        factor = factor +\
    \ factors[factor]\n    end\n    return factors\nend", "  -- Use Euclidian algorithm\
    \ to find the prime factors\n  local factors = {}\n  while n ~= 1 do\n    factors\
    \ = {}\n    factors[2] = 1\n    local i = 2\n    while i <= sqrt(n) do\n     \
    \ if n % i == 0 then\n        factors[i] = 1\n        n = n / i\n      else\n\
    \        i = i + 1\n      end\n    end\n    -- Now n = 1\n  end\n  return factors\n\
    end", "\tif n < 2 then\n\t\treturn {}\n\telseif n == 1 then\n\t\treturn {n}\n\t\
    elseif n % 2 == 1 then\n\t\treturn {n} + factorize(math.floor(n / 2))\n\telse\n\
    \t\tlocal factors = {}\n\t\tlocal p = math.floor(math.sqrt(n))\n\t\tlocal m =\
    \ 1\n\t\tfor i = 2, p do\n\t\t\tlocal ni = math.floor((n - 1) / i)\n\t\t\tif ni\
    \ * i == n then\n\t\t\t\tbreak\n\t\t\telse\n\t\t\t\tm = m + 1\n\t\t\t\tfactors[#factors\
    \ + 1] = {i, ni}\n\t\t\tend\n\t\tend\n\t\treturn factors\n\tend\nend", "  assert(n\
    \ > 0, 'Input should be a positive integer')\n  assert(n, 'Input number should\
    \ be equal to the product of all factors')\n  local factors = {}\n  local i =\
    \ 1\n  while i <= n do\n    local p = math.sqrt(i * i + 1)\n    if p > 2 then\n\
    \      local t = 1\n      while i*t <= p do\n        local k = (p * t - 1) / (i\
    \ * i)\n        if k ~= i then\n          factors[#factors+1] = k\n        end\n\
    \        t = t + 1\n      end\n    end\n    i = i + 1\n  end\n  return factors\n\
    end", "\t-- Base case\n\t-- If n is prime then return 1 as it's factor\n\tif n\
    \ == 1 then return [1], 1 end", "\tlocal ret = {}\n\tfor i = 2, n do\n\t\tlocal\
    \ cnt = 0\n\t\tfor j = 2, i do\n\t\t\tif i % j == 0 then\n\t\t\t\tcnt = cnt +\
    \ 1\n\t\t\tend\n\t\tend\n\t\tif cnt > 0 then\n\t\t\tret[#ret + 1] = i\n\t\tend\n\
    \tend\n\treturn ret\nend", "  local factors = {}\n  for i = 1, n do\n    local\
    \ f = math.floor(n / i)\n    for j = 1, f do\n      table.insert(factors, i)\n\
    \    end\n  end\n  return table.concat(factors, \", \")\nend", "  n = math.floor(n)\
    \ -- Find factors first\n  local factors = {}\n  while n > 1 do\n    local p =\
    \ math.floor((n-1) / 2) -- Find next prime and it's divisor\n    if p > 1 then\n\
    \      factors[p] = factors[p] + 1\n    end\n    n = p\n  end\n  return factors\n\
    end", "    local factors = {}\n    local f = 1\n    for i = 1, n do\n        while\
    \ n % f == 0 do\n            table.insert(factors, f)\n            n = n / f\n\
    \        end\n        f = f + 1\n    end\n    if n > 1 then\n        table.insert(factors,\
    \ n)\n    end\n    return factors\nend", "   local primes={}\n   local count=1\n\
    \   while n%2==0 do\n      if primes[count]==0 then\n         primes[count]=2\n\
    \      else\n         primes[count]=primes[count]*2\n      end\n      n=n/2\n\
    \   end\n   if n>1 then\n      primes[#primes+1]=n\n   end\n   return primes\n\
    end", "    if n < 2 then\n        return nil\n    end", "    local results = {}\n\
    \    for i = 2, math.floor(math.sqrt(n)) + 1 do\n        if n % i == 0 then\n\
    \            table.insert(results, i)\n            results[i] = results[i] + 1\n\
    \        end\n    end\n    return results\nend", "    local factors = {}\n   \
    \ if n < 2 then return factors end\n    local div = 2\n    while div <= n do\n\
    \        local tmp = n % div\n        if tmp == 0 then\n            table.insert(factors,\
    \ div)\n            n = div\n        else\n            div = div * 2\n       \
    \ end\n    end\n    return factors\nend", "\tlocal factors = {}\n\tfor i = 2,\
    \ n do\n\t\tlocal factor = 1\n\t\twhile n % i == 0 do\n\t\t\tfactor = factor *\
    \ i\n\t\t\tn = n / i\n\t\tend\n\t\ttable.insert(factors, factor)\n\tend\n\treturn\
    \ factors\nend", "  n = tonumber(n)\n  assert(n and n > 0, 'n should be integer\
    \ and positive number')\n  if n % 2 == 0 then return [2] end\n  local factors\
    \ = {}\n  for d = 2, n do\n    local p = 1\n    while n % d == 0 do\n      p =\
    \ p * d\n      d = d + 1\n    end\n    factors[#factors + 1] = p\n  end\n  return\
    \ factors\nend", "  assert(type(n) == \"number\", \"n should be a number\")\n\
    \  local factors = {}\n  for i = 2, n do\n    local divisor = 1\n    while n %\
    \ i do\n      divisor = divisor * i\n    end\n    factors[i] = divisor\n    n\
    \ = n / divisor\n  end\n  return factors\nend", "  local factors = {}\n  repeat\n\
    \    local m = math.floor((math.sqrt(n) + 1) / 2)\n    if not factors[m] then\n\
    \      table.insert(factors, m)\n      if n % m == 0 then\n        factors[m]\
    \ = factors[m] + 1\n        n = n / m\n      else\n        factors[m] = 1\n  \
    \      n = n / m\n      end\n    end\n  until n == 1\n  return factors\nend",
  "  -- TODO: Use Sieve of Eratosthenes here\n  -- return factorization\nend", "\t\
    -- Prime factorization of the number n -- The list of prime factors -- should\
    \ contain numbers equal to number of times it appeared in factorization.\n\t--\
    \ Prime factorization of the number n is defined as the product of all prime factors.\n\
    \t-- Prime factorization of the number n can be done in 2 ways:\n\t-- 1. Generate\
    \ all the prime factors -- This is called Pollard's Rho and is quite commonly\
    \ used in algorithms of factorization.\n\t-- 2. Sieve of Eratosthenes -- This\
    \ method is not commonly used but a very effective method (which does not use\
    \ Pollard's Rho) and is also used in prime factorization.\n\t-- References:\n\t\
    --\t\t1. Pollard's Rho\n\t\t--\t\t2. E. D. Villegas, The sieve of Eratosthenes\n\
    \t-- References:\n\t--\t\t1. Pollard's Rho\n\t\t--\t\t2. E. D. Villegas, The sieve\
    \ of Eratosthenes\n\t--\t\t3. https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n\
    \t--\t\t4. https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\tlocal function\
    \ factorization_sieve(number)\n\t\t-- Sieve of Eratosthenes algorithm\n\t\tlocal\
    \ prime_factors = { }\n\t\tfor i = 2, math.sqrt(number) do\n\t\t\tif number %\
    \ i == 0 then\n\t\t\t\t-- We divide by i, so it is prime (a factor of a prime)\n\
    \t\t\t\tlocal is_prime = true\n\t\t\t\tfor k = 1, i do\n\t\t\t\t\tif number %\
    \ k == 0 then\n\t\t\t\t\t\t-- We divide by k, so it is prime (a factor of a prime)\n\
    \t\t\t\t\t\tis_prime = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend",
  "    -- Find number of factors\n    local factors = 0\n    repeat\n        -- Divide\
    \ by 2 until there are no more factors\n        if n <= 1 then break end\n   \
    \     local factor = 2\n        -- Repeat while there are still factors\n    \
    \    while n % factor == 0 do\n            factor = factor + 1\n        end\n\
    \        -- If no factors were found yet\n        if factors == 0 then\n     \
    \       factors = factors\n        else\n            factors = factors * factor\n\
    \        end\n        -- Divide by current factor\n        -- n /= factor\n  \
    \      -- n = n / factor\n        n = n / factor\n    until n == 2\n    -- Return\
    \ list of factors\n    local factors = {}\n    for i = 1, factors + 1 do\n   \
    \     table.insert(factors, i)\n    end\n    return factors\nend", "  -- Initialize\
    \ list of factors.\n  local factors = {}", "    local result = {n}\n    local\
    \ factors = {}\n    local is_prime = {}\n    local function factor(n, factor)\n\
    \        if factor == 0 then\n            result[#result + 1] = factor\n     \
    \   else\n            factors[factor] = factors[factor] or 0\n            factors[factor]\
    \ = factors[factor] + 1\n            for k = factors[factor] - 1 do\n        \
    \        if n % k == 0 then\n                    n = n / k\n                 \
    \   factors[factor] = k + 1\n                    break\n                end\n\
    \            end\n        end\n    end\n    factor(2, 1)\n    if n > 1 then\n\
    \        for i = 3, n + 1, 2 do\n            factor(i, i)\n        end\n    end\n\
    \    if n > 1 then\n        for i = n, 2, -1 do\n            factor(i, i)\n  \
    \      end\n    end\n    for i = 2, #factors do\n        local factor = factors[i]\n\
    \        if factor > 1 then\n            for k = 1, factor do\n              \
    \  factor(k, i)\n            end\n        end\n    end\n    return table.toarray(result)\n\
    end", "  n = n or 1\n  local factors = {}\n  for i = 1, math.sqrt(n) do\n    local\
    \ j = 1\n    while n % i == 0 do\n      j = j + 1\n      n = n / i\n    end\n\
    \    table.insert(factors, j)\n  end\n  table.sort(factors)\n  local j = 1\n \
    \ local p = 1\n  while j <= math.max(table.concat(factors)) do\n    p = p * j\n\
    \    j = j + 1\n  end\n  return factors\nend", "\tassert(n >= 2, 'Only prime numbers\
    \ can be factored out')\n\tlocal factors = {}\n\tlocal i = 2\n\twhile i <= n do\n\
    \t\tlocal f = math.floor(n/i)\n\t\tif f ~= 0 then\n\t\t\tfactors[i] = f\n\t\t\t\
    n = f * i\n\t\telse\n\t\t\ti = i + 1\n\t\tend\n\tend\n\tif n == 1 then\n\t\treturn\
    \ [1]\n\tend\n\treturn factors\nend", "\t-- Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n\t-- Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \t-- Input number should be equal to the product of all factors\n\t-- >>> factorize(8)\n\
    \t-- [2, 2, 2]\n\t-- >>> factorize(25)\n\t-- [5, 5]\n\t-- >>> factorize(70)\n\t\
    -- [2, 5, 7]\n\tif n < 1 then\n\t\treturn nil\n\telse\n\t\tlocal factors = {}\n\
    \t\tfor i = 2, n do\n\t\t\t-- Prime factorization is done by checking all possible\
    \ prime factorization for given number\n\t\t\tlocal j = 1\n\t\t\twhile i * j <=\
    \ n do\n\t\t\t\tlocal ii = i - 1\n\t\t\t\twhile i * j < n and n % i * j == 0 do\n\
    \t\t\t\t\tj = (j + 1) % i\n\t\t\t\tend\n\t\t\t\tif i * j == n then\n\t\t\t\t\t\
    table.insert(factors, i * j)\n\t\t\t\t\tbreak\n\t\t\t\telse\n\t\t\t\t\ti = (ii\
    \ + j) / 2\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn factors\n\tend\nend",
  "    local factors = {}\n    for i = 2, math.ceil(n) do\n        local remain =\
    \ n\n        for j = 1, i do\n            if remain % i == 0 then\n          \
    \      remain = math.floor(remain/div)\n                factors[j] = factors[j]\
    \ or 1\n                factors[j] = factors[j] + 1\n                break\n \
    \           else\n                remain = remain / i\n            end\n     \
    \   end\n    end\n    return factors\nend", "  local factor = {}\n  local i =\
    \ 1\n  while i * i <= n do\n    if n % i == 0 then\n      factor[#factor+1] =\
    \ i\n    end\n    i = i + 2\n  end\n  return factor\nend", "  if n == 0 then\n\
    \    return {}\n  end", "  local factors = {}\n  local f = math.floor(n)\n  local\
    \ i = f", '  local factors = {}', "  assert(n ~= 0 and n ~= 1)\n  -- Base Case\n\
    \  if n == 1 then\n    return [1]\n  else\n    -- If prime number or 0 is passed,\
    \ then we return 1\n    -- We add 1 to return list of factors because we will\
    \ return factorized number after removing 1\n    local factors = factorize(n-1)\n\
    \    local factor = factors[1]\n    if factor == 0 then\n      return [1]\n  \
    \  else\n      -- If factor is prime number, then we add factor to the list of\
    \ factors returned from recursive call.\n      -- We remove 1 from factors because\
    \ we will return factorized number after removing factor.\n      table.insert(factors,\
    \ factor)\n      return factors\n    end\n  end\nend", "  if n<1 then return nil\
    \ end\n  local result={1};\n  for i=2,n do\n    local p=1\n    for i=1,i do\n\
    \      p=p*i\n    end\n    result=result+{p}\n  end\n  return result\nend", "\t\
    local factors = {}\n\twhile n do\n\t\tlocal f = 1\n\t\twhile n % f == 0 do\n\t\
    \t\tf = f + 1\n\t\tend\n\t\tif f > 1 then\n\t\t\tfactors[#factors+1] = f \n\t\t\
    \tn = n / f\n\t\tend\n\tend\n\ttable.sort(factors)\n\treturn factors\nend", " \
    \ n = tonumber(n)\n  local factors = {}\n  repeat\n    local t = n % 2\n    factors[t]\
    \ = factors[t] or 1\n    local p = n / 2\n    n = p\n  until n > 1\n  \n  -- Return\
    \ the reverse order to get factors in the order from largest to smallest.\n  return\
    \ table.unpack(table.concat(factors, \", \"))\nend", "    local factors = {}\n\
    \    for i=1,math.floor(math.sqrt(n)+1) do\n        local fact = n % i\n     \
    \   if fact == 0 then\n            factors[i] = fact\n        elseif fact ~= 0\
    \ then\n            local f2 = fact / i\n            table.insert(factors, f2)\n\
    \            table.insert(factors, i)\n        end\n    end\n    if n < 0 then\n\
    \        table.insert(factors, -n)\n    end\n    return factors\nend", "  if n\
    \ == 2 or n == 3 then\n    return [2]\n  end\n  local result = {}\n  local p =\
    \ math.floor((n + 1) / 2)\n  for i = 2, p * 2 do\n    while n % i == 0 do\n  \
    \    table.insert(result, i)\n      n = n / i\n    end\n  end\n  if n ~= 1 then\n\
    \    table.insert(result, n)\n  end\n  return result\nend", "   n = n or 1\n \
    \  local factors = {}\n   if n == 1 then\n      factors[1] = 1\n      return factors\n\
    \   end\n   local i = 1\n   for j = 2, n do\n      if n % j == 0 then\n      \
    \   i = i + 1\n         factors[i] = j\n      end\n   end\n   if n ~= 1 then\n\
    \      factors[#factors+1] = n\n   end\n   return factors\nend", "    local i\
    \ = 1\n    local factors = {}\n    repeat\n        factors[i] = n % i\n      \
    \  factor = factors[i]\n        if factor > 1 then\n            n = n / factor\n\
    \        else\n            break\n        end\n        i = i + 1\n    until n\
    \ == 1\n    return factors\nend", "  if n < 2 then return end\n  if n == 1 then\n\
    \    return [1]\n  end\n  local ret = {}\n  local f = factorize(n/2)\n  for i=1,#f\
    \ do\n    if f[i] == n then break end\n    ret[#ret+1] = f[i]\n  end\n  return\
    \ ret\nend", "   -- Factor is a set of numbers in the form of factors of given\
    \ number\n   local factor = {}\n   if n==1 then\n      return {1}\n   end\n  \
    \ -- Divide by every even number to determine factors\n   for i=1, n, 2 do\n \
    \     local t = n/i\n      -- If there are any factors\n      if factor[t] ~=\
    \ nil then\n         for _, v in pairs(factor[t]) do\n            factor[t] =\
    \ nil\n            break\n         end\n      end\n   end\n   -- Add prime numbers\
    \ as factors\n   for i=2 to n do\n      if n % i == 0 then\n         factor[i]\
    \ = nil\n      end\n   end\n   return factor\nend", "    local factors = {}\n\
    \    local primes = {}\n    local i\n    local product\n    for i = 2, n do\n\
    \        product = i * i\n        -- Check already found factors\n        if product*i\
    \ == n then\n            table.insert(primes, i)\n            table.insert(factors,\
    \ product)\n        end\n    end\n    local n = n\n    while n > 1 do\n      \
    \  n = n/2\n        for i = 2, n do\n            if n % i == 0 then\n        \
    \        -- We have found an even factor of n\n                product = i * i\n\
    \                if product*i == n then\n                    table.insert(primes,\
    \ i)\n                    table.insert(factors, product)\n                end\n\
    \            end\n        end\n    end\n    return primes, factors\nend", "  if\
    \ n == 1 then\n    return [2]\n  elseif n % 2 == 0 then\n    local factors = factorize(n\
    \ / 2)\n    local factor\n    for factor = factors[1], 1, -1 do\n      if n %\
    \ factor = 0 then\n        factors[#factors + 1] = factor\n        factors[1]\
    \ = factor - 1\n        break\n      end\n    end\n    return factors\n  else\n\
    \    local factors = factorize(n / 2)\n    local factor\n    for factor = factors[#factors\
    \ + 1], 1, -1 do\n      if n % factor = 0 then\n        factors[#factors + 1]\
    \ = factor\n        factors[#factors + 1] = (factor - 1) / 2\n        break\n\
    \      end\n    end\n    return factors\n  end\nend", "  local factors = {}\n\
    \  local max = math.sqrt(n)\n  local i = 2\n  repeat\n    if n % i == 0 then\n\
    \      factors[i] = factors[i] or 1\n      factors[i] = factors[i] * math.floor(n/i)\n\
    \    end\n    i = i + 1\n  until i > max\n  return factors\nend", "\t-- if n is\
    \ prime then return its prime factors\n\t-- if not then return its prime factors\
    \ and its exponent\n\t-- If exponent is 0 then n is a prime number else it is\
    \ a composite number with exponent n.\n\t-- Example : Factorize(8) = [2, 2, 2],\
    \ Factorize(9) = [1]\n\t-- The main idea is that the smallest prime factors are\
    \ larger than their multiplicative factors.\n\t-- So we should first compute multiplicative\
    \ factors (except 1 which is already 1) of the given number.\n\t-- Then we sort\
    \ them and get first n factors.\n\t-- When we get number n, we subtract multiplicative\
    \ factors until we get non-prime number.\n\t-- For example, if multiplicative\
    \ factors are:\n\t--\tp1 = 2 and p2 = 5\n\t--\tn = 7\n\t-- Then:\n\t--\t2*2*2*5*5\
    \ = 7\n\t--\t2*2*2*1 = 7\n\t--\t2*5*5 = 7\n\t--\t2*1 = 7\n\t-- If 7 is not prime\
    \ then it's exponent is 3.\n\t-- If n is prime then exponent is 0.\n\t-- So n\
    \ = 7 is equal to 7 = 3 * (3 + 1) = 13\n\t-- We can check that 13 is prime by\
    \ dividing it by 3.\n\t-- We get 1 as an exponent because 7 is even.\n\t-- We\
    \ can check that 13 is not prime by multiplying it by 3 and then dividing it by\
    \ 3.\n\t-- We get 3 as exponent because 13 is odd.\n\t-- We can check that 7 is\
    \ not prime by multiplying it by 3 and then dividing it by 3.\n\t-- We get 3 as\
    \ exponent because 7 is odd.\n\t-- So we get 7 = 3 * (3 + 1) = 13\n\tlocal factors\
    \ = {}\n\tlocal p = math.floor(n)\n\tif p == n then\n\t\treturn {[p], 0}\n\tend\n\
    \tfor i = 2, p do\n\t\t-- if n is prime then it's exponent is 0\n\t\tif p == 1\
    \ then\n\t\t\tbreak\n\t\tend\n\t\tif n % i == 0 then\n\t\t\t-- if i is prime then\
    \ it's exponent is p-1\n\t\t\tfactors[p] = factors[p]\n\t\t\tfactors[p] = factors[p]\
    \ + 1\n\t\t\tn = n / i\n\t\t\tp = p + 1\n\t\tend\n\tend\n\tif n >= 2 then\n\t\t\
    -- if n is not prime then it's exponent is p\n\t\tfactors[p] = factors[p] + 1\n\
    \tend\n\t-- Here we get factorized number\n\t-- So we need to decrement the exponent\
    \ of prime numbers.\n\t-- If exponent is 0 then it is prime ", '  if n < 2 then
    return nil end', "\t-- First check if number is an integer\n\tif n % 1 ~= 0 then\n\
    \t\terror(string.format(\"%s is not a multiple of 1\", n))\n\tend", "\tassert(n\
    \ > 1)\n\tlocal factors = {}\n\tlocal factor = 1\n\t\n\tfor i = 1, n do\n\t\t\
    factor = factor * i\n\t\t\n\t\tif factor ~= n then\n\t\t\ttable.insert(factors,\
    \ factor)\n\t\t\tfactor = nil\n\t\tend\n\tend\n\t\n\tif factor ~= n then\n\t\t\
    table.insert(factors, factor)\n\tend\n\t\n\treturn factors\nend", '    local factors
    = {}', "    local factors = {}\n    for i = 2, n do\n        if n % i == 0 then\n\
    \            factors[#factors + 1] = i\n            n = n / i\n        end\n \
    \   end\n    return factors\nend", "    local factors = {}\n    for i = 2, n do\n\
    \        if n % i == 0 then\n            n = n / i\n            factors[i] = 1\n\
    \            -- Update factor count of remaining number\n            -- If remainder\
    \ is 0, we increment only factor count of number\n            -- to its left and\
    \ decrement factor count of number to its right\n            if n % i == 0 then\n\
    \                if i == 2 then\n                    factors[i - 1] = factors[i\
    \ - 1] + 1\n                else\n                    factors[i - 1] = factors[i\
    \ - 1] + factors[i]\n                end\n                n = n / i\n        \
    \    end\n        end\n    end\n    return factors\nend", "  n = math.floor(n)\n\
    \  if n == 1 then return [1] end\n  local factors = {}\n  for i = 2, n do\n  \
    \  local count = 0\n    for j = 1, n do\n      if n % i == 0 then\n        count\
    \ = count + 1\n        if count > 1 then\n          factors[#factors + 1] = i\n\
    \          break\n        end\n      end\n    end\n  end\n  return factors\nend",
  "\t-- base case\n\tif n < 2 then return nil, [] end\n\t-- calculate primes up to\
    \ sqrt(n)\n\tlocal factors = {}\n\tfor i = 1, math.sqrt(n), 2 do\n\t\tlocal rd\
    \ = round(n/i)\n\t\tif rd > 1 then\n\t\t\t-- skip this number if it's not prime\n\
    \t\t\tif not factors[rd] then break end\n\t\tend\n\t\ttable.insert(factors, i)\n\
    \tend\n\t-- find out which factors appear the most\n\tlocal maxCount = -1\n\t\
    for i, v in ipairs(factors) do\n\t\tlocal count = #factors - i + 1\n\t\tif count\
    \ > maxCount then\n\t\t\tmaxCount = count\n\t\t\t-- store which factors appear\
    \ the most\n\t\t\ttable.insert(factors, i)\n\t\tend\n\tend\n\treturn factors,\
    \ maxCount\nend", "  if n < 2 then return nil end\n  if n == 1 then\n    return\
    \ {n}\n  end\n  local primes = {}\n  for i = 1, n do\n    local prime = true\n\
    \    for _, factorNumber in pairs(factorization(n) ) do\n      if n % factorNumber\
    \ ~= 0 then prime = false end\n    end\n    if prime then\n      table.insert(primes,\
    \ n)\n    end\n  end\n  return primes\nend", "   local fact = math.factorial(n)\
    \ -- Multiply factorial of n by n!\n   if n == 1 or n == 2 then return n end\n\
    \   if fact == 0 then return n end\n   local res = {}\n   if fact > 2000000000000\
    \ then\n      for i = 2, fact/2 do\n         if fact % i == 0 then res[#res+1]\
    \ = i end\n      end\n   else\n      for i = 2, fact do\n         if fact % i\
    \ == 0 then res[#res+1] = i end\n      end\n   end\n   return res\nend", '   if
    n == 1 or n == 0 then return end', "    local factors = {}\n    for i = 1, n do\n\
    \        local factor = 1\n        for j = 2, n do\n            if n % j == 0\
    \ then\n                factor = factor + 1\n            end\n        end\n  \
    \      if factor > 1 then\n            table.insert(factors, factor)\n       \
    \ end\n    end\n    table.sort(factors, function(a, b) return a > b end)\n   \
    \ return factors\nend", '  local factors = {}', "\t-- Find prime factors\n\tlocal\
    \ pfactors = {}\n\tlocal i = 1\n\twhile i * i <= n do\n\t\tif n % i == 0 then\n\
    \t\t\tlocal f = math.floor(n/i) + 1\n\t\t\t-- Check for prime factors\n\t\t\t\
    for i = 1, f do\n\t\t\t\tif n % i == 0 then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\
    \tend\n\t\t\tif f > 1 then\n\t\t\t\t-- Increment count for prime factors\n\t\t\
    \t\tpfactors[f] = pfactors[f] or 1\n\t\t\t\tpfactors[f] = pfactors[f] + 1\n\t\t\
    \tend\n\t\t\t-- Remove factor if product of factors is greater than square root\n\
    \t\t\tif f > 2 then\n\t\t\t\tn = n / i\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\t\
    end\n\treturn pfactors\nend", "  -- Calculate all prime factors\n  local factors\
    \ = { n-- Factorization starts with 1\n  }\n  factors[#factors] = 2\n  repeat\n\
    \    -- Remove 2 from the list of factors\n    factors[#factors+1] = factors[#factors]\
    \ / 2\n    -- Iterate over all prime factors\n    for i = 2, #factors do\n   \
    \   -- If number is not a factor of current factorization\n      if factors[#factors]\
    \ % i == 0 then\n        -- Iterate over all multiples of current factor\n   \
    \     for j = i * i, #factors do\n          -- If number is not a factor of current\
    \ factorization\n          if factors[#factors] % j == 0 then\n            --\
    \ Reconstruct factorization and add current factor\n            factors[#factors]\
    \ = i / j\n            factors[#factors+1] = factors[#factors]\n            break\n\
    \          end\n        end\n        break\n      end\n    end\n  until false\n\
    \  -- Return factorization\n  return factors\nend", "  assert(n % 2 == 0, 'Invalid\
    \ argument. Number should be divisible by two.')\n  local function recursive_factorize(number)\n\
    \    local prime_number = 2\n    local factorization = {}\n    for i=3,n,2 do\n\
    \      local new_number = number\n      if new_number % prime_number == 0 then\n\
    \        factorization[prime_number] = factorization[prime_number] + 1\n     \
    \ else\n        prime_number = prime_number + 1\n        factorization[prime_number]\
    \ = 1\n      end\n      new_number = new_number / prime_number\n    end\n    return\
    \ factorization\n  end\n  local prime_number = 2\n  local factorization = {}\n\
    \  for i=3,n,2 do\n    local new_number = number\n    if new_number % prime_number\
    \ == 0 then\n      factorization[prime_number] = factorization[prime_number] +\
    \ 1\n    else\n      prime_number = prime_number + 1\n      factorization[prime_number]\
    \ = 1\n    end\n    new_number = new_number / prime_number\n  end\n  return factorization\n\
    end", "  -- Calculate LCM of all factors\n  local lcm, i = math.modf(n)\n  if\
    \ i == 0 then\n    return [1]\n  end\n  if lcm*i == n then\n    return [i]\n \
    \ end\n  -- Calculate GCD and factorize LCM again\n  local gcd, i = math.modf(math.gcd(lcm,\
    \ i))\n  return factorize(gcd) * [i]\nend", "\tlocal factors = {}\n\tlocal isOdd\
    \ = 1", "    -- This code was adapted from code by John P. Bovet on Stack Overflow:\
    \ \n    -- https://stackoverflow.com/questions/1149882/most-elegant-way-to-find-the-factors-of-a-number",
  "    local factors = {}\n    for i = 2, math.floor(n/2) do\n        local isPrime\
    \ = true\n        for j = 1, n do\n            if n % i == 0 then\n          \
    \      isPrime = false\n                break\n            end\n        end\n\
    \        if isPrime then\n            table.insert(factors, i)\n        end\n\
    \    end\n    return factors\nend", "\tlocal factors = { }\n\tlocal i = 1\n\t\
    repeat\n\t\ttable.insert(factors, i)\n\t\ti = i ^ 2\n\tuntil (n % i == 0)\n\t\
    table.sort(factors)\n\tlocal n = math.ceil(math.log(n, 2))\n\tlocal p = math.pow(10,\
    \ n)\n\twhile n > 0 do\n\t\tif factors[n] == nil then\n\t\t\tfactors[n] = p\n\t\
    \telse\n\t\t\tp = p * factors[n]\n\t\tend\n\t\tn = n - 1\n\tend\n\treturn factors\n\
    end", "  local factors = {}\n  local factor = 1\n  for i = 2, n do\n    factor\
    \ = math.floor(n/i)\n    if factor > 1 then\n      factors[factor] = nil\n   \
    \ end\n  end\n  return factors\nend", "  -- Initialize prime factors table\n \
    \ local factors = {}", "  -- Check argument if positive\n  if not n then\n   \
    \ error(n)\n  end\n  -- Return empty list if n is prime\n  if is_prime(n) then\n\
    \    return []\n  else\n    -- Split n into list of factors and number of times\
    \ each factor appears\n    local factors, freq = factor(n), {}\n    -- Split n\
    \ into lists of all prime factors and number of times each appears\n    local\
    \ prime_factors, prime_freq = {}, {}\n    for i = 2, n do\n      if n % i == 0\
    \ then\n        local p_i, f_i = i, n / i\n        -- Add prime factor and number\
    \ of times its appearance to frequency list\n        if p_i not in prime_freq\
    \ then\n          prime_freq[p_i] = 1, p_i\n        else\n          prime_freq[p_i]\
    \ = prime_freq[p_i] + 1, f_i\n        end\n        -- Add prime factor and number\
    \ of times its appearance to factor list\n        if p_i ~= n then\n         \
    \ factors[#factors + 1] = p_i, p_i\n        else\n          -- If prime factor\
    \ appears less than n times then it cannot be a factor\n          -- Add it only\
    \ if its appearance is equal to number of times it appears in frequency list\n\
    \          -- This is to handle cases like 3^2 = 5, when prime factors are [3,3]\n\
    \          factors[#factors + 1] = f_i, p_i\n        end\n      end\n    end\n\
    \    -- Add prime factors and number of times they appear to prime frequency list\n\
    \    for p_i, f_i in pairs(prime_freq) do\n      prime_freq[p_i] = prime_freq[p_i]\
    \ + f_i\n    end\n    -- Return list of factors with their frequencies\n    return\
    \ factors, prime_freq\n  end\nend", "\tlocal factors = {}\n\tlocal remainder =\
    \ n -- n is any positive integer not equal to 1, and n > 1.\n\twhile remainder\
    \ > 1 do\n\t\t-- Search for all factors of n, and add them to the factors table.\n\
    \t\t-- The search is done using binary search algorithm.\n\t\tlocal low_idx =\
    \ math.floor(remainder / 2)\n\t\tlocal high_idx = low_idx + 1\n\t\tlocal div =\
    \ 0\n\t\twhile high_idx <= high_idx do\n\t\t\tif remainder % low_idx == 0 then\n\
    \t\t\t\tfactors[div] = low_idx\n\t\t\t\tremainder = remainder - low_idx * low_idx\n\
    \t\t\t\tdiv = div + 1\n\t\t\telse\n\t\t\t\thigh_idx = high_idx + 1\n\t\t\tend\n\
    \t\tend", "  local factors = {}\n  for i = 1, n do\n    local factor = 1\n   \
    \ for j = 2, n do\n      if n % j == 0 then\n        factor = factor * j\n   \
    \   end\n    end\n    factors[#factors + 1] = factor\n  end\n  return factors\n\
    end", "  local factors = {}\n  local m = math.floor(math.sqrt(n)) -- Calculate\
    \ sqrt of n\n  local count = 1\n  local i = 2\n  while i <= m do\n    if n % i\
    \ == 0 then\n      count = count + 1\n      i = i + 1\n    else\n      i = i +\
    \ 1\n    end\n  end\n  if count > 1 then\n    factors[#factors+1] = count\n  end\n\
    \  i = 2\n  while i <= m do\n    local p = i\n    while i * p <= n do\n      p\
    \ = p * 2\n    end\n    if n % p == 0 then\n      count = count + 1\n      i =\
    \ i + 1\n    else\n      i = i + 1\n    end\n  end\n  if count > 1 then\n    factors[#factors+1]\
    \ = count\n  end\n  return factors\nend", "    if n <= 1 then\n        return\
    \ n\n    end\n    local f = {}\n    for i = 2, n do\n        if n % i == 0 then\n\
    \            table.insert(f, i)\n            n = n / i\n        end\n    end\n\
    \    if n > 1 then\n        table.insert(f, n)\n    end\n    return f\nend", "\t\
    local factors = {}\n\tlocal i = 2\n\twhile i <= n do\n\t\tif n % i == 0 then\n\
    \t\t\tfactors[#factors + 1] = i\n\t\t\tn = n / i\n\t\tend\n\t\ti = i + 1\n\tend\n\
    \treturn factors\nend", "  -- Sieve of Eratosthenes for finding all prime factors\
    \ of n\n  local sieve = {}\n  local prime, factor\n  for prime = 3, math.ceil(n/3)\
    \ * 3, 2 do\n    sieve[prime] = true\n  end\n  -- Find the prime factors of the\
    \ number\n  for i = 2, n do\n    prime, factor = i, nil\n    for j = 2..math.sqrt(i)\
    \ do\n      if sieve[j] then\n        if prime and factor and prime ~= factor\
    \ then\n          break -- Found two factors\n        else\n          prime, factor\
    \ = j, i\n        end\n      end\n    end\n    sieve[prime] = nil\n    if factor\
    \ and prime then\n      sieve[factor] = nil\n      sieve[i] = nil\n      sieve[prime]\
    \ = nil\n      sieve[factor] = nil\n    end\n  end\n  -- Convert to array and\
    \ filter out duplicates\n  -- First sort by prime factors\n  local factors = {}\n\
    \  for prime, factor in pairs(sieve) do\n    if not factor then\n      factors[prime]\
    \ = true\n    end\n  end\n  table.sort(factors, function(a, b) return a < b end)\n\
    \  -- Now, sort by number\n  table.sort(factors)\n  return factors\nend", "  --\
    \ If number is a perfect square - return it\n  if math.sqrt(n) == math.floor(n)\
    \ then\n    return n\n  end\n  -- Get list of factors of the given number\n  local\
    \ factors = {}\n  local factor = 1\n  -- While there are factors\n  while factor\
    \ ~= 1 do\n    -- Get factor\n    factor = math.modf(math.sqrt(n)*factor)/math.gcd(math.sqrt(n),\
    \ factor)\n    -- If factor already exists in the list\n    if factors[factor]\
    \ == nil then\n      -- Add it to the list\n      factors[factor] = 1\n    else\n\
    \      -- Increment its counter\n      factors[factor] = factors[factor] + 1\n\
    \    end\n  end\n  -- Return list of factors\n  return factors\nend", '    local
    factors = {}', "    local factors = { }\n    local p = primes(n)\n    local i\
    \ = 2\n    while i <= n do\n        local q = math.floor((n / i) + 0.5)\n    \
    \    local t = false\n        for j = 1, #p do\n            if p[j] == i then\n\
    \                t = true\n                factors[#factors + 1] = i\n       \
    \         n = n - i * p[j]\n                break\n            end\n        end\n\
    \        if not t then\n            factors[#factors + 1] = i\n        end\n \
    \       i = i + 1\n    end\n    return factors\nend", "  -- This code takes O(n)\
    \ time and O(n) space\n  local factors = {}\n  local i = 2\n  while i <= math.sqrt(n)\
    \ do\n    -- Check if number is factor of current number\n    if n % i == 0 then\n\
    \      -- If number is factor of current number then\n      -- Increment number\
    \ of times it appeared in factorization\n      table.insert(factors, i)\n    \
    \  n = n / i\n      -- If number is not factor of current number then\n      --\
    \ Increment number of times it appeared in factorization\n      table.insert(factors,\
    \ n)\n    end\n    i = i + 1\n  end\n  -- Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n  -- Each of the factors should\
    \ be listed number of times corresponding to how many times it appeared in factorization.\n\
    \  return factors\nend", "    -- if n is prime, return its prime factors\n   \
    \ if p == 1 then return nil end\n    -- If n is divisible by p then n/p = 1\n\
    \    if p == n then return n end\n    -- if n is not divisible by p, then n is\
    \ a prime factor\n    -- if n is not divisible by p then n is a prime factor\n\
    \    -- if n is not divisible by p then n is a prime factor\n    -- if n is not\
    \ divisible by p then n is a prime factor\n    -- if n is not divisible by p then\
    \ n is a prime factor\n    -- if n is not divisible by p then n is a prime factor\n\
    \    -- if n is not divisible by p then n is a prime factor\n    -- if n is not\
    \ divisible by p then n is a prime factor\n    -- if n is not divisible by p then\
    \ n is a prime factor\n    -- if n is not divisible by p then n is a prime factor\n\
    \    -- if n is not divisible by p then n is a prime factor\n    -- if n is not\
    \ divisible by p then n is a prime factor\n    -- if n is not divisible by p then\
    \ n is a prime factor\n    -- if n is not divisible by p then n is a prime factor\n\
    \    -- if n is not divisible by p then n is a prime factor\n    -- if n is not\
    \ divisible by p then n is a prime factor\n    -- if n is not divisible by p then\
    \ n is a prime factor\n    -- if n is not divisible by p then n is a prime factor\n\
    \    -- if n is not divisible by p then n is a prime factor\n    -- if n is not\
    \ divisible by p then n is a prime factor\n    -- if n is not divisible by p then\
    \ n is a prime factor\n    -- if n is not divisible by p then n is a prime factor\n\
    \    -- if n is not divisible by p then n is a prime factor\n    -- if n is not\
    \ divisible by p then n is a prime factor\n    -- if n is not divisible by p then\
    \ n is a prime factor\n    -- if n is not divisible by p then n is a prime factor\n\
    \    -- if n is not divisible by p then n is a prime factor\n    -- if n is not\
    \ divisible by p then n is a prime factor\n    -- if n is not divisible by p then\
    \ n is a prime factor\n    -- if n is not divisible by p then n is a prime factor\n\
    \    -- if n is not divisible by p then n is a prime factor\n    -- if n is not\
    \ divisible by p then n is a prime factor\n    -- if n is not divisible by p then\
    \ n is a prime factor\n    -- if n is not divisible ", "  -- If n is 0, then its\
    \ prime factorization is 1\n  if n==0 then\n    return [1]\n  end\n  -- If n is\
    \ not a natural number or negative, then throw an error\n  if n ~= n or n <= 0\
    \ then\n    print(\"Function argument: \" .. n .. \" is not valid. Value should\
    \ be positive natural number or zero\")\n    return nil\n  end\n  -- If the number\
    \ has 1 as factor, then return it\n  if n==1 then\n    return [1]\n  end\n  --\
    \ Find factors of n\n  local factors = math.floor(n/2)\n  -- If n is even, then\
    \ return the list of factors of odd number\n  if n % 2 == 0 then\n    factors\
    \ = factors + 1\n  end\n  -- If n is odd, then return list of factors of even\
    \ number\n  local factors = factors + 1\n  -- Return factors\n  return factors\n\
    end", "  n = math.floor(n)\n  local factors = {}\n  repeat\n    table.insert(factors,\
    \ n)\n    local p = 1\n    for i = 2, n do\n      if n % i == 0 then\n       \
    \ p = i * p\n        n = n / i\n      else\n        break\n      end\n    end\n\
    \    if n ~= 1 then n = n / p; end\n  until n ~= 1\n  table.sort(factors)\n  return\
    \ factors\nend", "   local factors = {}\n   if n == 1 then\n      return factors\n\
    \   end\n   \n   if n > 0 then\n      while n ~= 1 do\n         local f = math.floor((n\
    \ - 1) / 2)\n         if factors[f] ~= nil then\n            factors[f] = factors[f]\
    \ + 1\n         else\n            factors[f] = 1\n         end\n         n = math.floor((n\
    \ - 1) / 2)\n      end\n   end\n   return factors\nend", "   local factors = {}\
    \ -- List of factors\n   local result = {} -- Result of factorization\n   if n\
    \ < 2 then return n end", "    if n < 2 then\n        return nil\n    end", " \
    \ if n < 1 then return nil end\n  local prime_table = {}\n  local i = 1\n  while\
    \ i <= math.sqrt(n) do\n    local prime = true\n    for _, v in ipairs(prime_table)\
    \ do\n      prime = (v * 2) <= n\n    end\n    if prime then\n      prime_table[i]\
    \ = 1\n      i = i + 1\n    end\n  end\n  local factors = {}\n  for i, v in ipairs(prime_table)\
    \ do\n    if v > 1 then\n      factors[#factors + 1] = v\n    end\n  end\n  return\
    \ factors\nend", "    if n < 2 then\n        return nil\n    end\n    local res\
    \ = {}\n    local i = 1\n    repeat\n        res[i] = n % i\n        i = i / 2\n\
    \    until i > 1 and n % i == 0\n    return table.concat(res) or 1\nend\n</cell>\n\
    <cell>", "    local factors = {}\n    local i = 0\n    while i < math.floor(sqrt(n))\
    \ do\n        local k = 0\n        while n % i == 0 do\n            k = k + 1\n\
    \            n = n / i\n        end\n        factors[#factors + 1] = i\n     \
    \   i = i + 1\n    end\n    factors[#factors + 1] = n\n    return factors\nend",
  "  assert(n > 0)\n  local f = {}\n  for i = 1, n do\n    local divisor = 1\n   \
    \ while n % divisor == 0 do\n      divisor = divisor * i\n    end\n    table.insert(f,\
    \ divisor)\n  end\n  return f\nend", "  -- Find number of factors by dividing\
    \ into prime factors\n  local factors = { }\n  -- Divide into primes until only\
    \ primes are left\n  local limit = math.sqrt(n)\n  local p = 2\n  while p <= limit\
    \ do\n    -- If p is a prime, divide by it until only primes are left\n    while\
    \ n % p == 0 do\n      -- Divide n by p\n      local q = math.floor(n/p)\n   \
    \   factors[#factors + 1] = q\n      n = q\n    end\n    -- Divide p into primes\
    \ until only primes are left\n    p = p * 2\n  end\n  -- Append factors to return\
    \ list\n  factors[#factors + 1] = n\n  return factors\nend", "   if n < 2 then\n\
    \      return nil, 0\n   end\n   local factorization = {}\n   local max_factorization\
    \ = 1\n   if n % 2 == 0 then\n      local factor = n / 2\n      factorization[factor]\
    \ = factorization[factor] + 1 or 1\n      while factor > 1 do\n         factor\
    \ = factor / 2\n         factorization[factor] = factorization[factor] + 1 or\
    \ 1\n      end\n   else\n      local factor = 2\n      factorization[factor] =\
    \ factorization[factor] + 1 or 1\n      while factor <= n do\n         if n %\
    \ factor == 0 then\n            max_factorization = max_factorization * factor\
    \ + 1 -- To keep track of largest factor\n            factorization[factor] =\
    \ factorization[factor] + 1 or 1\n         end\n         factor = factor / 2\n\
    \         factorization[factor] = factorization[factor] + 1 or 1\n      end\n\
    \   end\n   factorization[1], factorization[2] = max_factorization, 2\n   return\
    \ factorization, max_factorization\nend", "  local factors = {}\n  local primes\
    \ = {}\n  local f = 1\n  local p = 1\n  local q = 1", "    local p = 1\n    local\
    \ factors = {}\n    for i = 2, math.sqrt(n) do\n        if n % i == 0 then\n \
    \           p = p * i\n            factors[#factors + 1] = p\n        end\n  \
    \  end\n    return factors\nend", "    local factors = {}\n    local i = 1\n \
    \   \n    while i < n do\n        local k = math.floor((n - i) / 2)\n        \n\
    \        if factors[k] == nil then\n            factors[k] = i\n        end\n\
    \        \n        i = i + 1\n    end\n    \n    return factors\nend", "   --\
    \ Base case\n   if n<=1 then return nil end\n   -- Get prime factors up to n\n\
    \   local factors = {}\n   local div = 2\n   while div <= n do\n      if n%div==0\
    \ then\n         table.insert(factors,div)\n      end\n      div = div + div\n\
    \   end\n   return factors\nend", "\tif n == 1 then return nil end\n\tlocal x\
    \ = 1\n\tlocal factors = {}\n\trepeat\n\t\tlocal _, x = div(n, x)\n\t\ttable.insert(factors,\
    \ x)\n\tuntil n == 1 or x == 1\n\treturn factors\nend", "   -- Initialize list\
    \ of factors\n   local factors = {}\n   -- Initialize flag\n   local flag = false\n\
    \   -- Iterate through integer from smallest to largest\n   -- Check for factors\
    \ in factorization\n   for i = 2, n do\n      if n % i == 0 then\n         --\
    \ Add factor to list\n         table.insert(factors, i)\n         -- Mark flag\n\
    \         flag = true\n      end\n   end\n   -- If flag was not set then there\
    \ is no factors\n   if not flag then\n      -- Add 1 to list because it was prime\
    \ by definition\n      table.insert(factors, 1)\n   end\n   -- Return the factors\n\
    \   return factors\nend", "    local factors = {}\n    local p = 1\n    while\
    \ n ~= 1 do\n        if n % p == 0 then\n            n = n / p\n            factors[p]\
    \ = factors[p] + 1 or 1\n        end\n        p = 3 * p + 1\n    end\n    return\
    \ factors\nend", "\tlocal factors = {}\n\tlocal i = 2\n\t\n\trepeat\n\t\tlocal\
    \ divisor = math.sqrt(math.abs(n - i))\n\t\tfactors[i] = divisor\n\t\ti = i +\
    \ 1\n\tuntil i <= n", "    local factors = {}\n    for i = 1, n do\n        for\
    \ k, v in ipairs(factorization(n)) do\n            if v == i then\n          \
    \      table.insert(factors, k)\n            end\n        end\n    end\n    return\
    \ factors\nend", "  assert(n % 2 == 0 and n > 1)\n  if n == 1 then return [1]\
    \ end\n  local factors = {}\n  for i = 2, n do\n    local j = 1\n    while i *\
    \ j <= n do\n      if n % i == 0 then\n        if not factors[i] then factors[i]\
    \ = 1 end\n        factors[i] = factors[i] + factors[j]\n        j = j + 1\n \
    \     else\n        break\n      end\n    end\n    if j ~= 1 then factors[n] =\
    \ j + 1 end\n  end\n  return factors\nend", "  if n == 1 then return [2] end\n\
    \  local primes, pow, factors = {}, {}, 1\n  local i = 2\n  repeat\n    pow =\
    \ n / i\n    primes[pow] = i -- Save the prime factors\n    factors = { i * j\
    \ for i,j in pairs(primes) } -- Build a new list with all factors\n    n = n %\
    \ i\n  until n == 1\n  return primes, factors\nend", "    local result = {}\n\
    \    local p = math.floor(math.sqrt(n))\n    while p > 0 do\n        if n % p\
    \ == 0 then\n            n = n / p\n        else\n            table.insert(result,\
    \ p)\n        end\n        p = math.floor(math.sqrt(n))\n    end\n    return result\n\
    end", "  -- Base case: n is divisible by 1 so we return only 1 and n.\n  if n\
    \ % 2 == 0 then\n    local factors = {n}\n    -- If the number is not divisible\
    \ by 2, then the number can only have 1 factor and we return only 1 factor too.\n\
    \    if n % 4 == 0 then\n      factors = {1, n}\n    end\n    -- Return factors\
    \ in decreasing order of frequency\n    return table.unpack(table.sort(factors,\
    \ function(a,b) return a > b end))\n  end\n  -- If n is not a multiple of 2, then\
    \ it can only have 1 factor so return 1 factor.\n  local factors = {1, n}\n  --\
    \ Find all prime factors of n in factorization.\n  for i = 2, n do\n    -- If\
    \ number is divisible by i, then it is a prime number so add it to factorization.\n\
    \    if n % i == 0 then\n      table.insert(factors, i)\n    end\n  end\n  --\
    \ Return factors in decreasing order of frequency\n  return table.unpack(table.sort(factors,\
    \ function(a,b) return a > b end))\nend", "    -- If number is prime then return\
    \ its prime factors\n    if isPrime(n) then\n        local factors = {}\n    \
    \    -- if n is prime then return its prime factors\n        for i = 2, n do\n\
    \            if n % i == 0 then\n                table.insert(factors, i)\n  \
    \          end\n        end\n        return factors\n    end", "  local factors\
    \ = {}\n  local p = 1\n  while n != 1 do\n    if n % p == 0 then\n      factors[#factors+1]\
    \ = p\n      n = n / p\n    else\n      p = p * primes[n]\n      n = n + 1\n \
    \   end\n  end\n  if n ~= 1 then\n    factors[#factors+1] = n\n  end\n  return\
    \ factors\nend", "  -- Create a table of factors\n  local factors = {}\n  for\
    \ i = 1, n do\n    factors[i] = 1\n  end\n  -- Perform Euclidean algorithm for\
    \ finding prime factors\n  for i = 2, n do\n    -- If current number is already\
    \ a factor, increment its count\n    if factors[i] == 1 then\n      factors[i]\
    \ = factors[i] + 1\n      -- Otherwise, if current number is already a factor\
    \ of another, increment that factor's count\n    elseif factors[i ^ 1] == 1 then\n\
    \      factors[i ^ 1] = factors[i ^ 1] + 1\n    end\n  end\n  return factors\n\
    end", "   local f = {}\n   for i = 2,n do\n      if not n%i then\n         table.insert(f,\
    \ i)\n         for j = 1,i do\n            if n%i==0 then\n               table.insert(f,\
    \ n/i)\n               break\n            end\n         end\n      end\n   end\n\
    \   return f\nend", "  local result = {}\n  if n <= 1 then return result end\n\
    \  n = math.floor(n)\n  local p = 2\n  while p <= n do\n    if n % p == 0 then\n\
    \      p*=p\n      n = n/p\n    else\n      local m = math.floor((n-p)/p)\n  \
    \    for i = 1, m do\n        result[#result+1] = p\n        p = p*p\n      end\n\
    \      n = n-p\n    end\n  end\n  return result\nend", "  if n <= 1 then return\
    \ end\n  local m = math.floor(sqrt(n))\n  local factors = terralib.newlist()\n\
    \  local d = 2\n  repeat\n    local r = n % d\n    if r == 0 then\n      factors:insert(d)\n\
    \      n = n / d\n    else\n      d = d + r\n    end\n  until n > 1\n  return\
    \ factors\nend", "\tlocal factors = {}\n\tlocal i = 0\n\twhile i <= math.sqrt(n)\
    \ do\n\t\tif n % i == 0 then\n\t\t\tif i == 1 then\n\t\t\t\tfactors[#factors+1]\
    \ = i\n\t\t\telse\n\t\t\t\tfor k = i^1; k < n; k = k * i do\n\t\t\t\t\tfactors[#factors+1]\
    \ = k\n\t\t\t\tend\n\t\t\tend\n\t\t\tn = n / i\n\t\t\ti = i + 1\n\t\telse\n\t\t\
    \ti = i + 1\n\t\tend\n\tend\n\tfactors[#factors+1] = n\n\treturn factors\nend",
  "    local factors = {}\n    local i = 1\n    while i <= n do\n        if n % i\
    \ == 0 then\n            factors[#factors + 1] = i\n        end\n        i = i\
    \ + 1\n    end\n    return factors\nend", "    local factors = {} -- Dictionary\
    \ of factors\n    local factor = 1\n    local i = 1\n    while i <= n do\n   \
    \     -- Increment factor as long as it doesn't exist yet in factors\n       \
    \ while factor ~= i do\n            factor = factor + 1\n        end\n       \
    \ -- If the factor exists in factors, increment its count\n        if factors[i]\
    \ ~= nil then\n            factors[i] = factors[i] + 1\n        else\n       \
    \     -- Otherwise add it to the factors\n            factors[i] = 1\n       \
    \ end\n        i = i + 1\n    end\n    -- Return the factors\n    return factors\n\
    end", "  if n == 1 then return { [1] } end\n  local d = 2\n  local factors = {}\n\
    \  repeat\n    local m = n / d\n    n, d = d, n * d\n    table.insert(factors,\
    \ m)\n  until n % d == 0\n  return factors\nend", "    local factors = {}\n  \
    \  for i = 2, math.floor(n/m) do\n        local prime = n - (i*(m-1))\n      \
    \  for j, f in pairs(factors) do\n            if f == prime then\n           \
    \     factors[j] = factors[j] + 1\n                return factors\n          \
    \  end\n        end\n        table.insert(factors, prime)\n    end\n    return\
    \ factors\nend", "    local factors = {}\n    local f = primeFactorization(n)\n\
    \    for i = 1, #f do\n        for j = 1, f[i] do\n            table.insert(factors,\
    \ i)\n        end\n    end\n    return factors\nend", "    if n < 2 then\n   \
    \     error('Bad input')\n    end\n    local primes = {1, 2, 3, 5, 7}\n    local\
    \ factors = {}\n    for i = 2, n do\n        if n % i == 0 then\n            local\
    \ fact = 1\n            for j = 2, i do\n                if i % j == 0 then\n\
    \                    fact = fact * j\n                end\n            end\n \
    \           factors[#factors + 1] = fact\n        end\n    end\n    local factorization\
    \ = {}\n    for i = 2, #primes do\n        factorization[primes[i]] = factors[i\
    \ - 1]\n    end\n    return factorization\nend", "  -- Make copy of original number\n\
    \  local c = math.mod(n,1)\n  -- Loop until one factor is found\n  while c ~=\
    \ 1 do\n    -- Add factor to result list\n    table.insert(factors,c)\n    --\
    \ Divide number by factor\n    n = n/c\n    -- Make copy of copy of number\n \
    \   c = math.mod(n,1)\n  end\n  -- Return list of factors\n  return factors\n\
    end", "\tif n == 1 then\n\t\treturn {n}\n\telseif n < 2 then\n\t\terror (\"factorize:\
    \ invalid argument: n=\"..tostring(n)..\". n should be greater than 1\")\n\tend",
  "    local factors = {}\n    \n    local function factor(divider)\n        if divider\
    \ == 0 then\n            factors[divider] = 1\n        else\n            for i=1,divider\
    \ do\n                local divisor = divider\n                \n            \
    \    while divisor > 1 do\n                    divisor = divisor / 2\n       \
    \         end\n                \n                factors[divisor] = factors[divisor]\
    \ or 1\n            end\n        end\n    end\n    \n    factor(n)\n    \n   \
    \ table.sort(factors, function(a,b)\n        if a > b then\n            return\
    \ -1\n        elseif b > a then\n            return 1\n        else\n        \
    \    return nil\n        end\n    end)\n    \n    return factors\nend", "    local\
    \ factorization = {}\n    local maxFactor = 2", "\tassert(type(n) == 'number')\n\
    \tassert(n % 1 == 0 or n % 1 == 1)", "  -- Start with number\n  -- If number is\
    \ prime, no factorization will be done\n  if n < 2 then\n    return nil\n  end",
  "    local factors = [1]\n    local cur = 1\n    for i = 2, n do\n        while\
    \ n % i == 0 do\n            factors[#factors+1] = i\n            n = n / i\n\
    \        end\n        cur = cur * i\n    end\n    if n > 1 then\n        factors[#factors+1]\
    \ = n\n    end\n    return factors\nend", "  assert(n >= 2, 'Input number should\
    \ be greater than 2.')\n  -- List of prime factors\n  local factors = {}", " \
    \ if n < 2 then return nil end\n  local factors = { 1 }\n  repeat\n    local p\
    \ = tonumber(string.format(\"%d^.\", n))\n    if p and n % p == 0 then\n     \
    \ if p * 2 > n then break end\n      factors[#factors + 1] = p -- increment number\
    \ of the factor which was found and add it to the list of factors\n    end\n \
    \ until n == 2^30\n  return factors\nend", "    local factors = {}\n    for i\
    \ = 2, n do\n        if n % i == 0 then\n            local p = i\n           \
    \ while n / p > 1 do\n                p = p * i\n            end\n           \
    \ table.insert(factors, p)\n        end\n    end\n    return factors\nend", " \
    \   -- Check if number is prime\n    if n == 1 then\n        return [1]\n    else\n\
    \        -- Remove one from number because we already tested it\n        n = n\
    \ - 1", "   assert(n > 0)\n   local f = 2\n   local l = 1\n   while f < n do\n\
    \      if n % f == 0 then\n         if n > 1 then\n            n = n / f\n   \
    \      else\n            return f -- factorization failed\n         end\n    \
    \  elseif f % 2 == 1 then\n         l = l * f\n      else\n         f = f * 2\n\
    \      end\n   end\n   return l\nend", "\tlocal factors = {}\n\twhile n ~= 1 do\n\
    \t\tlocal factor = 1\n\t\tfor i = 2, n do\n\t\t\tif n % i == 0 then\n\t\t\t\t\
    factor = factor * i\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif factor > 1 then\n\
    \t\t\ttable.insert(factors, factor)\n\t\t\tn = n / factor\n\t\tend\n\tend\n\t\
    return factors\nend", "  -- Prime factors\n  local primes = {}\n  -- Prime factorization\
    \ of input number\n  local prime_factorization = {}\n  for i = 2, n do primes[i]\
    \ = 1 end\n  for i=2, n do\n    local j = 1\n    local factor = 1\n    while j\
    \ * i < n do\n      if n % i == 0 then\n        prime_factorization[factor] =\
    \ i -- Add to prime factorization\n        primes[j*i] = 1\n      end\n      j\
    \ = j * i\n      factor = factor * i\n    end\n  end\n  -- Create list of factors\n\
    \  for i = 1, n do\n    if prime_factorization[i] == 1 then\n      primes[primes[i]\
    \ + 1] = primes[i]\n    end\n  end\n  return primes\nend", "  local results =\
    \ {}\n  local i = 0\n  while i <= math.sqrt(n) do\n    if n % i == 0 then\n  \
    \    n = n / i\n      table.insert(results, i)\n    end\n    i = i + 1\n  end\n\
    \  if n ~= 1 then\n    table.insert(results, n)\n  end\n  return results\nend",
  "\t-- Check whether n is positive integer\n\tif n % 1 = 0 then\n\t\tprint(\n\t\t\
    \t\"Error: factorize requires integer argument\"\n\t\t)\n\t\treturn nil\n\tend",
  "    local factors = {}\n    for i = 1, n do\n        for j = 2, i do\n        \
    \    if n % j == 0 then\n                table.insert(factors, j)\n          \
    \      n = n / j\n                break\n            end\n        end\n    end\n\
    \    return factors\nend", '    local factors = {}', "  assert(n > 1)\n  -- Use\
    \ cached factorization if exists\n  if self.factorization[n] ~= nil then return\
    \ self.factorization[n] end\n  local factorization = {}\n  -- Find the primes\n\
    \  local p = 1\n  -- Find the prime factors\n  for i = 2, n do\n    while self.isPrime(p)\
    \ do\n      local pFactor = p\n      p = p * pFactor\n      factorization[pFactor]\
    \ = factorization[pFactor] or 1\n    end\n    factorization[p] = factorization[p]\
    \ or 1\n  end\n  -- Sort and return\n  table.sort(factorization)\n  self.factorization[n]\
    \ = factorization\n  return factorization\nend", "  local factors = {}\n  local\
    \ primes, primes_count = prime_factorization(n)\n  local num_times = math.ceil(primes_count/2)\n\
    \  for i = 1, num_times do\n    local factor = primes[i]\n    if factors[factor]\
    \ == nil then\n      factors[factor] = 0\n    end\n    factors[factor] = factors[factor]\
    \ + 1\n  end\n  return factors\nend", "    local factors = {}\n    local m = 1\n\
    \    while m <= n do\n        if n % m == 0 then\n            factors[#factors+1]\
    \ = m\n            m = m + 1\n        end\n    end\n    return factors\nend",
  "  -- Initialize all variables and factors\n  local factors = {}\n  local factor\
    \ = 1", "  if n % 2 == 0 then\n    return factorize(n/2)\n  end\n  local factors\
    \ = {}\n  repeat\n    local i = 3\n    while i <= math.floor(n/2) do\n      if\
    \ n % i == 0 then\n        factors[#factors+1] = i\n        n = n / i\n      else\n\
    \        i = i + 2\n      end\n    end\n  until n == 1\n  return factors\nend",
  "  -- Generate list of prime factors of integer n\n  -- Each factor should be listed\
    \ number of times corresponding to how many times it appeares in factorization\n\
    \  -- e.g. factorize(25)\n  --   3^2 * 5^2 * 7^2\n  --   5^2 * 7^2\n  --   7^2\n\
    \  local function factorize(number)\n    -- Check if number is not prime number\
    \ (it is either 1 or it)\n    local function isPrime(n)\n      if n > 1 then\n\
    \        for i=1, math.sqrt(n) do\n          -- Check if n is prime number or\
    \ not by counting factors up to sqrt(n)\n          if n % i == 0 then\n      \
    \      -- Count number of factors up to sqrt(n) that is equal to i\n         \
    \   return i * math.floor(n/i)\n          end\n        end\n      end\n      --\
    \ Check if given number is prime number or not\n      return math.floor(n/2)*math.floor(n/3)*math.floor(n/5)*math.floor(n/7)\n\
    \    end", "    if n == 1 then\n        return {1}\n    end\n    local factors\
    \ = {}\n    local primes = {}\n    local x = 1\n    for i = 2, n do\n        while\
    \ n % i == 0 do\n            primes[#primes + 1] = {i = i}\n            n = n\
    \ / i\n        end\n    end\n    for _, v in ipairs(primes) do\n        for i\
    \ = 1, #primes do\n            if primes[i].i == v.i then\n                x =\
    \ x * primes[i].i\n                table.insert(factors, x)\n                primes[i]\
    \ = nil\n                break\n            end\n        end\n    end\n    return\
    \ factors\nend", "  local factors = {}\n  local num_factors = 0\n  repeat\n  \
    \  local prime = math.floor(math.sqrt(n)) -- Get prime factor of n\n    factors[num_factors]\
    \ = prime -- Create new factor with value \"prime\"\n    num_factors = num_factors\
    \ + 1 -- Increment number of factors\n    factor = factor * prime -- Multiply\
    \ factor with its prime factor\n    n = n / prime -- Divide n by prime factor\n\
    \  until n > 1 -- If no more prime factors exist, n must be 1 (this only happens\
    \ if no factor exists)\n  return factors\nend", "    local primes = {2}\n    while\
    \ #primes < math.ceil(math.sqrt(n)) do\n        local i = 2\n        while i *\
    \ i <= n and n ~= 1 do\n            i = i + 2\n        end\n        if i ~= n\
    \ then primes[i] = i end\n    end", "    local result = {}\n    local factors\
    \ = {}", "  assert(n ~= 0)\n  local m = 1\n  local factorization = {}\n  local\
    \ i = 1\n  while i <= n do\n    while m <= n and n % m == 0 do\n      m = m *\
    \ i\n    end\n    if m > n then\n      break\n    end\n    i = i + 1\n    factorization[i]\
    \ = m\n    m = m / i\n  end\n  return factorization\nend", "    local factorization\
    \ = {}\n    for i = 1, n do\n        local x = 1\n        for j = 1, n do\n  \
    \          if j % i == 0 then\n                x = x * j\n            end\n  \
    \      end\n        table.insert(factorization, x)\n    end\n    return factorization\n\
    end", "  assert(n and n % 1 == 0, \"Number to factorize should be positive integer\"\
    )\n  local result = {}\n  local factors = primefactorization(n)\n  for i = 1,\
    \ #factors do\n    table.insert(result, factors[i])\n  end\n  return result\n\
    end", "    local factors = {}\n    for i = 2, n do\n        if n % i == 0 then\n\
    \            for j = 2, i do\n                n = n / i\n                table.insert(factors,\
    \ n)\n            end\n        end\n    end\n    return factors\nend", "\tlocal\
    \ factorization = {}\n\tfor i = 2, n do -- Start from 2 to ensure first iteration\
    \ have prime factors\n\t\t-- Check if current number is prime or not\n\t\tif not\
    \ math.mod(n, i) then\n\t\t\t-- If current number is not prime, check if it can\
    \ be split into prime factors\n\t\t\tlocal count = 1\n\t\t\tlocal factors = {}\n\
    \t\t\tlocal m = math.min(n, i)\n\t\t\twhile m % i ~= 0 do\n\t\t\t\t-- If current\
    \ number is not prime factor, move it to factors list\n\t\t\t\tfactors[#factors\
    \ + 1] = i\n\t\t\t\tcount = count + 1\n\t\t\t\ti = i/2\n\t\t\tend\n\t\t\tif count\
    \ == 1 then\n\t\t\t\t-- If current number is prime factor of given number, add\
    \ its prime factors\n\t\t\t\tfactorization[#factorization + 1] = factors\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn factorization\nend", "  if n <= 1 then return\
    \ end\n  local factors = {}\n  local prime_numbers = prime_number(n)\n  local\
    \ n_prime_numbers = #prime_numbers\n  for i = 1, n_prime_numbers do\n    local\
    \ fact = 1\n    for j = 1, i do\n      fact = fact * prime_numbers[j]\n    end\n\
    \    if fact > n then break end\n    factors[fact] = factors[fact] + 1 or 1\n\
    \  end\n  return factors\nend", "   if n < 2 then\n      return { n = 1 }\n  \
    \ end\n   local res = {}\n   for i = 1, n do\n      local i = 1\n      repeat\n\
    \         if n % i == 0 then\n            res.[n] = i\n            n = n / i\n\
    \         end\n         i = i + 1\n      until n >= 2\n      if n == 1 then\n\
    \         res.[n] = 1\n      else\n         res.[n] = i\n      end\n   end\n \
    \  return res\nend", "  -- First check if integer is prime\n  if math.sqrt(n)\
    \ == math.floor(n) then return prime_factors(n) end\n  -- Find out if given number\
    \ is divisible by any prime\n  if divisors(n, 2) ~= nil then return nil end\n\
    \  -- Find out if given number is divisible by any non-prime number\n  if divisors(n,\
    \ 2) ~= nil then return nil end\n  -- Find out if given number is divisible by\
    \ any number in given range (2 to n-1)\n  local factors = { }\n  for i=2,n do\
    \ if divisors(n, i) ~= nil then table.insert(factors, i) end end\n  return factors\n\
    end", "  if n < 2 then\n    return nil\n  end", "    local factors = {}\n    local\
    \ p = math.floor(n)\n    local f = 1\n    local i = 1\n    while n >= f do\n \
    \       n = n / f\n        factors[#factors + 1] = f -- to keep track of order\n\
    \        i = i + 1\n        f = math.floor(n)\n    end\n    factors[#factors +\
    \ 1] = n -- to keep track of order\n    return factors\nend", "    local factors\
    \ = {}\n    for i = 2, math.sqrt(n) do\n        local tmp = 1\n        for j =\
    \ 1, i do\n            if n % i == 0 then\n                tmp *= j\n        \
    \    end\n        end\n        if n ~= tmp then\n            table.insert(factors,\
    \ tmp)\n        end\n    end\n    if n > 1 then\n        table.insert(factors,\
    \ n)\n    end\n    return factors\nend", "\tassert(n >= 1)\n\tlocal ret = {}\n\
    \tlocal primeFactorization, isPrime = factorizationTable(n)\n\tif not isPrime\
    \ then\n\t\terror(\"Not a prime\")\n\tend\n\tfor i = 1, n do\n\t\tlocal p = primeFactorization[i]\n\
    \t\tlocal factor = 1\n\t\twhile n > 1 do\n\t\t\tif n % p == 0 then\n\t\t\t\tn\
    \ = n / p\n\t\t\t\tfactor = p\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\
    \t\ttable.insert(ret, factor)\n\tend\n\treturn ret\nend", "    local factors =\
    \ {} -- List of factors\n    local i = 1\n    \n    -- Remove all even factors\
    \ and then try all even numbers (2,3,...,n/2)\n    repeat\n        if n % 2 ==\
    \ 0 then break end\n        factors[i] = 2\n        factors[i + 1] = 2\n     \
    \   i = i + 1\n    until n >= 2\n    \n    -- Check odd numbers up to the nearest\
    \ even number which is less than or equal to n\n    for i = 2, n / 2 + 1 do\n\
    \        if n % i == 0 then\n            factors[i] = n / i\n        end\n   \
    \ end\n    return factors\nend", "\tn = tonumber(n)\n\tif not n then\n\t\terror(\"\
    Non number given in factorize\")\n\tend\n\tif n == 1 then\n\t\treturn {}\n\tend\n\
    \tlocal factors = {}\n\tlocal prime_factors = {}\n\tlocal prime_factors_count\
    \ = 0\n\tlocal prime_factors_count_max = 1\n\tlocal p\n\t-- Checking all odd numbers\n\
    \tfor i = 2, math.sqrt(n) + 1, 2 do\n\t\t-- Finding if its prime or composite\n\
    \t\t-- If its not prime then check all even numbers until it finds the prime\n\
    \t\tif not prime_factors_count then\n\t\t\tfor f = 1, i do\n\t\t\t\t-- Checking\
    \ if its prime or composite number\n\t\t\t\t-- If prime then add to the list\n\
    \t\t\t\tif n % i == 0 then\n\t\t\t\t\tprime_factors_count = i\n\t\t\t\t\tprime_factors[prime_factors_count]\
    \ = i\n\t\t\t\t\tprime_factors_count_max = prime_factors_count - 1\n\t\t\t\t\t\
    break\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- Checking if its prime or composite number\n\
    \t\t\tif prime_factors_count then\n\t\t\t\tprime_factors[prime_factors_count]\
    \ = i\n\t\t\t\tprime_factors_count = prime_factors_count - 1\n\t\t\t\tprime_factors_count_max\
    \ = prime_factors_count - 1\n\t\t\t\t-- Prime number found\n\t\t\tend\n\t\telse\n\
    \t\t\t-- Prime number found\n\t\t\tprime_factors[prime_factors_count] = i\n\t\t\
    \tprime_factors_count = prime_factors_count - 1\n\t\t\tprime_factors_count_max\
    \ = prime_factors_count - 1\n\t\tend\n\tend\n\t-- Getting prime factors of given\
    \ number\n\tfor i = 1, prime_factors_count_max do\n\t\t-- Finding first number\
    \ that appear in the factorization and divide it by the given number\n\t\tp =\
    \ prime_factors[i]\n\t\tif p then\n\t\t\tfactors[p] = factors[p] or 1\n\t\t\t\
    factors[p] = factors[p] * n / p\n\t\t\t-- If its even number then divide it to\
    \ next higher power\n\t\t\tif p % 2 == 1 then\n\t\t\t\tfactors[p] = factors[p]\
    \ / 2\n\t\t\t\tfactors[p] = factors[p] * n\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ factors\nend", "   if n==0 then\n      return nil\n   end", "  if n < 2 then\n\
    \    return {}\n  end\n  local factors = {}\n  repeat\n    table.insert(factors,\
    \ 2)\n    table.insert(factors, n / 2)\n    local i = 3\n    while i * i < n do\n\
    \      if n % i == 0 then\n        table.insert(factors, i)\n        n /= i\n\
    \      else\n        table.insert(factors, i - 1)\n        break\n      end\n\
    \      i = i + 1\n    end\n  until n >= 1\n  return factors\nend", "    local\
    \ factors = {}\n    for i = 2, n do\n        if n % i == 0 then\n            n\
    \ = n / i\n            table.insert(factors, i)\n            -- print(i)\n   \
    \     end\n    end\n    return factors\nend", "    local f = math.floor(math.sqrt(n))\
    \ -- Find factors factors\n    local a = math.floor(n/f) -- Get factor of n\n\
    \    local c = math.floor(math.sqrt(n)) -- Find square root of n\n    local b\n\
    \    if a > c then -- if c is not prime, find prime factors\n        local i,\
    \ p\n        for i = 1, f do\n            p = math.floor(n/i)\n            n =\
    \ p - a\n            if n == 0 then break end\n        end\n        -- if n is\
    \ not zero, n is prime and p is the product of factors of n\n        -- The order\
    \ of factorization is from largest to smallest according to this definition.\n\
    \        local res = {a = a, b = b, c = c, n = n}\n        if n ~= 1 then -- If\
    \ n is prime, add its prime factors to res\n            for i = 1, n do\n    \
    \            local p = math.floor(n/i)\n                n = p - a\n          \
    \      if n == 0 then break end\n            end\n            -- If n is prime,\
    \ add its prime factors to res\n            table.insert(res, {a = a, b = b, c\
    \ = c, n = n})\n        end\n        return res -- Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    end\n    local\
    \ p\n    local i, j, k\n    for i = 1, f do\n        p = math.floor(n/i)\n   \
    \     n = p - a\n        if n == 0 then break end\n        k = math.floor(c/n)\n\
    \        -- if n is divisible by any of {a,b} or {c,d}, then n is prime and k\
    \ is the product of factors of n\n        table.insert(res, {a = a, b = b, c =\
    \ c, d = d, n = n})\n        if k ~= 1 then break\n        end\n    end\n    if\
    \ k ~= 1 then -- If n is divisible by any of {a,b} or {c,d}, then n is prime and\
    \ k is the product of factors of n\n        table.insert(res, {a = a, b = b, c\
    \ = c, d = d, n = n})\n    end\n    return res -- Return list of prime factors\
    \ of given integer in the order from smallest to largest.\nend", "  n = n and\
    \ n or 0\n  local factors = {}\n  local i = 1\n  for d = 2, math.floor(n) do\n\
    \    if n % d == 0 then\n      factors[#factors + 1] = d * i\n      i = i + 1\n\
    \    end\n  end\n  if i ~= math.floor(n) then\n    factors[#factors + 1] = d *\
    \ i\n  end\n  return factors\nend", "    local factors = {}\n    local primes\
    \ = primeFactorization(n)\n    for i = 2, #primes do\n        table.insert(factors,\
    \ primes[i])\n    end\n    return factors\nend", "    local factors = {}\n   \
    \ local i = 2\n    repeat\n        -- find out factors\n        while i * i <=\
    \ n do\n            if n % i == 0 then\n                table.insert(factors,\
    \ i)\n                n = n / i\n                break\n            end\n    \
    \        i = i + 1\n        end\n    until n >= 1\n    return factors\nend", " \
    \ -- Initialization\n  local factors = {}\n  \n  -- Main loop\n  for i = 2, n\
    \ do\n    local div = 1\n    while div * i <= n do\n      div = div * i\n    end\n\
    \    factors[div] = factors[div] + 1 or 1\n  end\n  \n  -- Return results\n  return\
    \ factors\nend", "  assert(type(number) ~= 'table')\n  assert(n >= 1)\n  local\
    \ l = {n = 1}\n  local q = {n}\n  while #q > 0 do\n    local s = 1\n    for i\
    \ = #q, 1, -1 do\n      s = s * q[i]\n    end\n    if s == n then break\n    end\n\
    \    table.insert(l, s)\n    local c = 2\n    while c <= n and n % c == 0 do\n\
    \      c = c * 2\n    end\n    table.insert(q, c)\n  end\n  table.sort(l)\n  return\
    \ l\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
