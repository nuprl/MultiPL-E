name: HumanEval_6_parse_nested_parens
language: rs
prompt: "/// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n/// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((()))\
  \ () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
  \ String) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
  (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
  () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
  (()(())((())))\")), vec![4]);\n}\n"
completions: ["    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            let mut depth = 0;\n            let mut max_depth = 0;\n    \
    \        for ch in group.chars() {\n                if ch == '(' {\n         \
    \           depth += 1;\n                } else if ch == ')' {\n             \
    \       depth -= 1;\n                }\n                if depth > max_depth {\n\
    \                    max_depth = depth;\n                }\n            }\n  \
    \          max_depth\n        })\n        .collect()", "    let mut res = Vec::new();\n\
    \    let mut stack = Vec::new();\n    let mut deepest_level = 0;\n    for c in\
    \ paren_string.chars() {\n        if c == ' ' {\n            res.push(deepest_level);\n\
    \            stack.clear();\n            deepest_level = 0;\n        } else if\
    \ c == '(' {\n            stack.push(c);\n            deepest_level = stack.len()\
    \ as isize;\n        } else if c == ')' {\n            stack.pop();\n        }\n\
    \    }\n    res.push(deepest_level);\n    res", "    // TODO: implement this function\n\
    \    let mut deepest_level = Vec::new();\n    let mut current_level = 0;\n   \
    \ let mut paren_string = paren_string.chars();\n    loop {\n        match paren_string.next()\
    \ {\n            Some('(') => {\n                current_level += 1;\n       \
    \     }\n            Some(')') => {\n                current_level -= 1;\n   \
    \         }\n            Some(' ') => {\n                deepest_level.push(current_level);\n\
    \                current_level = 0;\n            }\n            None => {\n  \
    \              break;\n            }\n            _ => {}\n        }\n    }\n\
    \    deepest_level", "    let mut max_nesting = 0;\n    let mut curr_nesting =\
    \ 0;\n    let mut parsed_parens = Vec::new();\n    for character in paren_string.chars()\
    \ {\n        match character {\n            '(' => {\n                curr_nesting\
    \ += 1;\n                if curr_nesting > max_nesting {\n                   \
    \ max_nesting = curr_nesting;\n                }\n            }\n            ')'\
    \ => {\n                curr_nesting -= 1;\n            }\n            ' ' =>\
    \ {\n                parsed_parens.push(max_nesting);\n                max_nesting\
    \ = 0;\n                curr_nesting = 0;\n            }\n            _ => (),\n\
    \        }\n    }\n    parsed_parens.push(max_nesting);\n    parsed_parens", " \
    \   let mut max_pars = vec![];\n    let mut depth = 0;\n    let mut max_depth\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   depth += 1;\n            if depth > max_depth {\n                max_depth\
    \ = depth;\n            }\n        } else if c == ')' {\n            depth -=\
    \ 1;\n        } else if c == ' ' {\n            max_pars.push(max_depth);\n  \
    \          max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_pars.push(max_depth);\n\
    \    max_pars", "    // TODO: implement me\n    let paren_groups: Vec<&str> =\
    \ paren_string.split_whitespace().collect();\n    // iterate through each group\
    \ of parens\n    let mut deep_parens: Vec<isize> = Vec::new();\n    for &group\
    \ in paren_groups.iter() {\n        // count number of open parens\n        let\
    \ mut open_parens: isize = 0;\n        let mut max_open_parens: isize = 0;\n \
    \       for character in group.chars() {\n            if character == '(' {\n\
    \                open_parens += 1;\n                if open_parens > max_open_parens\
    \ {\n                    max_open_parens = open_parens;\n                }\n \
    \           } else if character == ')' {\n                open_parens -= 1;\n\
    \            }\n        }\n        deep_parens.push(max_open_parens);\n    }\n\
    \    deep_parens", "    let mut count = 0;\n    let mut max_count = 0;\n    let\
    \ mut counts = Vec::new();\n    let mut max_counts = Vec::new();\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            count += 1;\n   \
    \         if count > max_count {\n                max_count = count;\n       \
    \     }\n        } else if c == ')' {\n            count -= 1;\n        } else\
    \ if c == ' ' {\n            counts.push(count);\n            max_counts.push(max_count);\n\
    \            count = 0;\n            max_count = 0;\n        }\n    }\n    max_counts",
  "    let mut nested_parens = vec![];\n    let mut paren_count = 0;\n    let mut\
    \ max_nesting = 0;\n    for ch in paren_string.chars() {\n        if ch == '('\
    \ {\n            paren_count += 1;\n            if paren_count > max_nesting {\n\
    \                max_nesting = paren_count;\n            }\n        } else if\
    \ ch == ')' {\n            paren_count -= 1;\n        } else if ch == ' ' {\n\
    \            nested_parens.push(max_nesting);\n            max_nesting = 0;\n\
    \            paren_count = 0;\n        }\n    }\n    nested_parens.push(max_nesting);\n\
    \    nested_parens", "    let mut paren_levels = Vec::new();\n    let mut paren_count\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '('\
    \ => paren_count += 1,\n            ')' => paren_count -= 1,\n            ' '\
    \ => paren_levels.push(paren_count),\n            _ => (),\n        }\n    }\n\
    \    paren_levels", "    // keep track of the depth of the current group\n   \
    \ let mut current_depth = 0;\n    // keep track of the maximum depth of any group\n\
    \    let mut max_depth = 0;\n    // parse each character of the given string one\
    \ by one\n    paren_string.chars().fold(vec![], |mut acc, c| {\n        // if\
    \ character is '(' then increment current depth\n        if c == '(' {\n     \
    \       current_depth += 1;\n            // update max depth if current depth\
    \ is greater than max\n            if current_depth > max_depth {\n          \
    \      max_depth = current_depth;\n            }\n        }\n        // if character\
    \ is ')' then decrement current depth\n        else if c == ')' {\n          \
    \  current_depth -= 1;\n        }\n        // if character is space then push\
    \ the maximum depth of current group to the result vec\n        else if c == '\
    \ ' {\n            acc.push(max_depth);\n            // reset max depth to 0 to\
    \ start counting new group\n            max_depth = 0;\n        }\n        acc\n\
    \    })", "    let mut stack: Vec<char> = Vec::new();\n    let mut max_level:\
    \ isize = 0;\n    let mut levels: Vec<isize> = Vec::new();\n    for token in paren_string.chars()\
    \ {\n        match token {\n            '(' => {\n                stack.push(token);\n\
    \                max_level += 1;\n            }\n            ')' => {\n      \
    \          stack.pop();\n                levels.push(max_level);\n           \
    \     max_level -= 1;\n            }\n            ' ' => {\n                levels.push(max_level);\n\
    \            }\n            _ => panic!(\"Input string needs to contain only parentheses\
    \ and spaces.\"),\n        }\n    }\n    levels", "    // TODO: Implement this\
    \ function\n    vec![]", "    paren_string\n        .split_whitespace()\n    \
    \    .map(|paren_group| {\n            let mut max_nesting = 0;\n            let\
    \ mut curr_nesting = 0;\n            for paren in paren_group.chars() {\n    \
    \            if paren == '(' {\n                    curr_nesting += 1;\n     \
    \           } else if paren == ')' {\n                    curr_nesting -= 1;\n\
    \                }\n                if curr_nesting > max_nesting {\n        \
    \            max_nesting = curr_nesting;\n                }\n            }\n \
    \           max_nesting\n        })\n        .collect()", "    let mut result:\
    \ Vec<isize> = Vec::new();\n    let mut count: isize = 0;\n    let mut max_count:\
    \ isize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n   \
    \         count += 1;\n            if count > max_count {\n                max_count\
    \ = count;\n            }\n        } else if c == ')' {\n            count -=\
    \ 1;\n        } else if c == ' ' {\n            result.push(max_count);\n    \
    \        max_count = 0;\n            count = 0;\n        }\n    }\n    result.push(max_count);\n\
    \    result", "    let mut result = Vec::new();\n    for elem in paren_string.split_whitespace()\
    \ {\n        let mut paren_vec = Vec::new();\n        let mut running_max = 0;\n\
    \        let mut curr_max = 0;\n        for paren in elem.chars() {\n        \
    \    match paren {\n                '(' => {\n                    curr_max +=\
    \ 1;\n                    running_max = std::cmp::max(running_max, curr_max);\n\
    \                    paren_vec.push(paren);\n                }\n             \
    \   ')' => {\n                    curr_max -= 1;\n                    paren_vec.push(paren);\n\
    \                }\n                _ => {\n                    paren_vec.push(paren);\n\
    \                }\n            }\n        }\n        result.push(running_max);\n\
    \    }\n    result", "    let split_parens = paren_string.split_whitespace();\n\
    \    let mut output: Vec<isize> = Vec::new();\n    for paren in split_parens {\n\
    \        let mut num_open = 0;\n        let mut max_open = 0;\n        for char\
    \ in paren.chars() {\n            match char {\n                '(' => {\n   \
    \                 num_open += 1;\n                    if num_open > max_open {\n\
    \                        max_open = num_open;\n                    }\n       \
    \         }\n                ')' => {\n                    num_open -= 1;\n  \
    \              }\n                _ => (),\n            }\n        }\n       \
    \ if num_open == 0 {\n            output.push(max_open);\n        } else {\n \
    \           output.push(-1);\n        }\n    }\n    output", "    let mut levels\
    \ = Vec::new();\n    for paren_group in paren_string.split_whitespace() {\n  \
    \      let mut stack = vec![];\n        let mut max_count = 0;\n        for symbol\
    \ in paren_group.chars() {\n            match symbol {\n                '(' =>\
    \ {\n                    stack.push(symbol);\n                    max_count =\
    \ max_count.max(stack.len() as isize);\n                }\n                ')'\
    \ => {\n                    stack.pop();\n                }\n                _\
    \ => panic!(\"Unrecognized character\"),\n            }\n        }\n        levels.push(max_count);\n\
    \    }\n    levels", "    let mut max_nesting = 0;\n    let mut curr_nesting =\
    \ 0;\n    let mut output: Vec<isize> = Vec::new();\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            curr_nesting += 1;\n            if curr_nesting\
    \ > max_nesting {\n                max_nesting = curr_nesting;\n            }\n\
    \        } else if c == ')' {\n            if i < paren_string.len() - 1 && paren_string.chars().nth(i\
    \ + 1).unwrap() == ' ' {\n                output.push(max_nesting);\n        \
    \        max_nesting = 0;\n                curr_nesting = 0;\n            } else\
    \ {\n                curr_nesting -= 1;\n            }\n        }\n    }\n   \
    \ output", "    let mut paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut out_vec: Vec<isize> = Vec::new();\n    for s in paren_groups {\n\
    \        let mut count: isize = 0;\n        let mut max_count: isize = 0;\n  \
    \      for c in s.chars() {\n            match c {\n                '(' => count\
    \ += 1,\n                ')' => count -= 1,\n                _ => (),\n      \
    \      }\n            if count > max_count {\n                max_count = count;\n\
    \            }\n        }\n        out_vec.push(max_count);\n    }\n    out_vec",
  "    let paren_groups: Vec<&str> = paren_string.split(\" \").collect();\n    paren_groups\n\
    \        .iter()\n        .map(|group| {\n            let mut max_count = 0;\n\
    \            let mut current_count = 0;\n            for c in group.chars() {\n\
    \                if c == '(' {\n                    current_count += 1;\n    \
    \            } else if c == ')' {\n                    if current_count > max_count\
    \ {\n                        max_count = current_count;\n                    }\n\
    \                    current_count -= 1;\n                }\n            }\n \
    \           max_count\n        })\n        .collect()"]
stop_tokens:
- "\n}"
