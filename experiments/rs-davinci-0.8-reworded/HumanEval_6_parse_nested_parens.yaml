name: HumanEval_6_parse_nested_parens
language: rs
prompt: "/// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n/// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((()))\
  \ () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
  \ String) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
  (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
  () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
  (()(())((())))\")), vec![4]);\n}\n"
completions: ["    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            let mut depth = 0;\n            let mut max_depth = 0;\n    \
    \        for ch in group.chars() {\n                if ch == '(' {\n         \
    \           depth += 1;\n                } else if ch == ')' {\n             \
    \       depth -= 1;\n                }\n                if depth > max_depth {\n\
    \                    max_depth = depth;\n                }\n            }\n  \
    \          max_depth\n        })\n        .collect()", "    let mut res = Vec::new();\n\
    \    let mut stack = Vec::new();\n    let mut deepest_level = 0;\n    for c in\
    \ paren_string.chars() {\n        if c == ' ' {\n            res.push(deepest_level);\n\
    \            stack.clear();\n            deepest_level = 0;\n        } else if\
    \ c == '(' {\n            stack.push(c);\n            deepest_level = stack.len()\
    \ as isize;\n        } else if c == ')' {\n            stack.pop();\n        }\n\
    \    }\n    res.push(deepest_level);\n    res", "    // TODO: implement this function\n\
    \    let mut deepest_level = Vec::new();\n    let mut current_level = 0;\n   \
    \ let mut paren_string = paren_string.chars();\n    loop {\n        match paren_string.next()\
    \ {\n            Some('(') => {\n                current_level += 1;\n       \
    \     }\n            Some(')') => {\n                current_level -= 1;\n   \
    \         }\n            Some(' ') => {\n                deepest_level.push(current_level);\n\
    \                current_level = 0;\n            }\n            None => {\n  \
    \              break;\n            }\n            _ => {}\n        }\n    }\n\
    \    deepest_level", "    let mut max_nesting = 0;\n    let mut curr_nesting =\
    \ 0;\n    let mut parsed_parens = Vec::new();\n    for character in paren_string.chars()\
    \ {\n        match character {\n            '(' => {\n                curr_nesting\
    \ += 1;\n                if curr_nesting > max_nesting {\n                   \
    \ max_nesting = curr_nesting;\n                }\n            }\n            ')'\
    \ => {\n                curr_nesting -= 1;\n            }\n            ' ' =>\
    \ {\n                parsed_parens.push(max_nesting);\n                max_nesting\
    \ = 0;\n                curr_nesting = 0;\n            }\n            _ => (),\n\
    \        }\n    }\n    parsed_parens.push(max_nesting);\n    parsed_parens", " \
    \   let mut max_pars = vec![];\n    let mut depth = 0;\n    let mut max_depth\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   depth += 1;\n            if depth > max_depth {\n                max_depth\
    \ = depth;\n            }\n        } else if c == ')' {\n            depth -=\
    \ 1;\n        } else if c == ' ' {\n            max_pars.push(max_depth);\n  \
    \          max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_pars.push(max_depth);\n\
    \    max_pars", "    // TODO: implement me\n    let paren_groups: Vec<&str> =\
    \ paren_string.split_whitespace().collect();\n    // iterate through each group\
    \ of parens\n    let mut deep_parens: Vec<isize> = Vec::new();\n    for &group\
    \ in paren_groups.iter() {\n        // count number of open parens\n        let\
    \ mut open_parens: isize = 0;\n        let mut max_open_parens: isize = 0;\n \
    \       for character in group.chars() {\n            if character == '(' {\n\
    \                open_parens += 1;\n                if open_parens > max_open_parens\
    \ {\n                    max_open_parens = open_parens;\n                }\n \
    \           } else if character == ')' {\n                open_parens -= 1;\n\
    \            }\n        }\n        deep_parens.push(max_open_parens);\n    }\n\
    \    deep_parens", "    let mut count = 0;\n    let mut max_count = 0;\n    let\
    \ mut counts = Vec::new();\n    let mut max_counts = Vec::new();\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            count += 1;\n   \
    \         if count > max_count {\n                max_count = count;\n       \
    \     }\n        } else if c == ')' {\n            count -= 1;\n        } else\
    \ if c == ' ' {\n            counts.push(count);\n            max_counts.push(max_count);\n\
    \            count = 0;\n            max_count = 0;\n        }\n    }\n    max_counts",
  "    let mut nested_parens = vec![];\n    let mut paren_count = 0;\n    let mut\
    \ max_nesting = 0;\n    for ch in paren_string.chars() {\n        if ch == '('\
    \ {\n            paren_count += 1;\n            if paren_count > max_nesting {\n\
    \                max_nesting = paren_count;\n            }\n        } else if\
    \ ch == ')' {\n            paren_count -= 1;\n        } else if ch == ' ' {\n\
    \            nested_parens.push(max_nesting);\n            max_nesting = 0;\n\
    \            paren_count = 0;\n        }\n    }\n    nested_parens.push(max_nesting);\n\
    \    nested_parens", "    let mut paren_levels = Vec::new();\n    let mut paren_count\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '('\
    \ => paren_count += 1,\n            ')' => paren_count -= 1,\n            ' '\
    \ => paren_levels.push(paren_count),\n            _ => (),\n        }\n    }\n\
    \    paren_levels", "    // keep track of the depth of the current group\n   \
    \ let mut current_depth = 0;\n    // keep track of the maximum depth of any group\n\
    \    let mut max_depth = 0;\n    // parse each character of the given string one\
    \ by one\n    paren_string.chars().fold(vec![], |mut acc, c| {\n        // if\
    \ character is '(' then increment current depth\n        if c == '(' {\n     \
    \       current_depth += 1;\n            // update max depth if current depth\
    \ is greater than max\n            if current_depth > max_depth {\n          \
    \      max_depth = current_depth;\n            }\n        }\n        // if character\
    \ is ')' then decrement current depth\n        else if c == ')' {\n          \
    \  current_depth -= 1;\n        }\n        // if character is space then push\
    \ the maximum depth of current group to the result vec\n        else if c == '\
    \ ' {\n            acc.push(max_depth);\n            // reset max depth to 0 to\
    \ start counting new group\n            max_depth = 0;\n        }\n        acc\n\
    \    })", "    let mut stack: Vec<char> = Vec::new();\n    let mut max_level:\
    \ isize = 0;\n    let mut levels: Vec<isize> = Vec::new();\n    for token in paren_string.chars()\
    \ {\n        match token {\n            '(' => {\n                stack.push(token);\n\
    \                max_level += 1;\n            }\n            ')' => {\n      \
    \          stack.pop();\n                levels.push(max_level);\n           \
    \     max_level -= 1;\n            }\n            ' ' => {\n                levels.push(max_level);\n\
    \            }\n            _ => panic!(\"Input string needs to contain only parentheses\
    \ and spaces.\"),\n        }\n    }\n    levels", "    // TODO: Implement this\
    \ function\n    vec![]", "    paren_string\n        .split_whitespace()\n    \
    \    .map(|paren_group| {\n            let mut max_nesting = 0;\n            let\
    \ mut curr_nesting = 0;\n            for paren in paren_group.chars() {\n    \
    \            if paren == '(' {\n                    curr_nesting += 1;\n     \
    \           } else if paren == ')' {\n                    curr_nesting -= 1;\n\
    \                }\n                if curr_nesting > max_nesting {\n        \
    \            max_nesting = curr_nesting;\n                }\n            }\n \
    \           max_nesting\n        })\n        .collect()", "    let mut result:\
    \ Vec<isize> = Vec::new();\n    let mut count: isize = 0;\n    let mut max_count:\
    \ isize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n   \
    \         count += 1;\n            if count > max_count {\n                max_count\
    \ = count;\n            }\n        } else if c == ')' {\n            count -=\
    \ 1;\n        } else if c == ' ' {\n            result.push(max_count);\n    \
    \        max_count = 0;\n            count = 0;\n        }\n    }\n    result.push(max_count);\n\
    \    result", "    let mut result = Vec::new();\n    for elem in paren_string.split_whitespace()\
    \ {\n        let mut paren_vec = Vec::new();\n        let mut running_max = 0;\n\
    \        let mut curr_max = 0;\n        for paren in elem.chars() {\n        \
    \    match paren {\n                '(' => {\n                    curr_max +=\
    \ 1;\n                    running_max = std::cmp::max(running_max, curr_max);\n\
    \                    paren_vec.push(paren);\n                }\n             \
    \   ')' => {\n                    curr_max -= 1;\n                    paren_vec.push(paren);\n\
    \                }\n                _ => {\n                    paren_vec.push(paren);\n\
    \                }\n            }\n        }\n        result.push(running_max);\n\
    \    }\n    result", "    let split_parens = paren_string.split_whitespace();\n\
    \    let mut output: Vec<isize> = Vec::new();\n    for paren in split_parens {\n\
    \        let mut num_open = 0;\n        let mut max_open = 0;\n        for char\
    \ in paren.chars() {\n            match char {\n                '(' => {\n   \
    \                 num_open += 1;\n                    if num_open > max_open {\n\
    \                        max_open = num_open;\n                    }\n       \
    \         }\n                ')' => {\n                    num_open -= 1;\n  \
    \              }\n                _ => (),\n            }\n        }\n       \
    \ if num_open == 0 {\n            output.push(max_open);\n        } else {\n \
    \           output.push(-1);\n        }\n    }\n    output", "    let mut levels\
    \ = Vec::new();\n    for paren_group in paren_string.split_whitespace() {\n  \
    \      let mut stack = vec![];\n        let mut max_count = 0;\n        for symbol\
    \ in paren_group.chars() {\n            match symbol {\n                '(' =>\
    \ {\n                    stack.push(symbol);\n                    max_count =\
    \ max_count.max(stack.len() as isize);\n                }\n                ')'\
    \ => {\n                    stack.pop();\n                }\n                _\
    \ => panic!(\"Unrecognized character\"),\n            }\n        }\n        levels.push(max_count);\n\
    \    }\n    levels", "    let mut max_nesting = 0;\n    let mut curr_nesting =\
    \ 0;\n    let mut output: Vec<isize> = Vec::new();\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            curr_nesting += 1;\n            if curr_nesting\
    \ > max_nesting {\n                max_nesting = curr_nesting;\n            }\n\
    \        } else if c == ')' {\n            if i < paren_string.len() - 1 && paren_string.chars().nth(i\
    \ + 1).unwrap() == ' ' {\n                output.push(max_nesting);\n        \
    \        max_nesting = 0;\n                curr_nesting = 0;\n            } else\
    \ {\n                curr_nesting -= 1;\n            }\n        }\n    }\n   \
    \ output", "    let mut paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut out_vec: Vec<isize> = Vec::new();\n    for s in paren_groups {\n\
    \        let mut count: isize = 0;\n        let mut max_count: isize = 0;\n  \
    \      for c in s.chars() {\n            match c {\n                '(' => count\
    \ += 1,\n                ')' => count -= 1,\n                _ => (),\n      \
    \      }\n            if count > max_count {\n                max_count = count;\n\
    \            }\n        }\n        out_vec.push(max_count);\n    }\n    out_vec",
  "    let paren_groups: Vec<&str> = paren_string.split(\" \").collect();\n    paren_groups\n\
    \        .iter()\n        .map(|group| {\n            let mut max_count = 0;\n\
    \            let mut current_count = 0;\n            for c in group.chars() {\n\
    \                if c == '(' {\n                    current_count += 1;\n    \
    \            } else if c == ')' {\n                    if current_count > max_count\
    \ {\n                        max_count = current_count;\n                    }\n\
    \                    current_count -= 1;\n                }\n            }\n \
    \           max_count\n        })\n        .collect()", "    let mut results =\
    \ Vec::new();\n    let mut depth = 0;\n    let mut max_depth = 0;\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            depth += 1;\n   \
    \         if depth > max_depth {\n                max_depth = depth;\n       \
    \     }\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            results.push(max_depth);\n            max_depth =\
    \ 0;\n            depth = 0;\n        }\n    }\n    results.push(max_depth);\n\
    \    results", "    // Write your code here\n    let mut depths = Vec::new();\n\
    \    let mut max_depth = 0;\n    let mut current_depth = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            depths.push(max_depth);\n            max_depth =\
    \ 0;\n            current_depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths", "    paren_string\n        .split_whitespace()\n        .map(|parens|\
    \ {\n            let mut max_level = 0;\n            let mut level = 0;\n    \
    \        for c in parens.chars() {\n                if c == '(' {\n          \
    \          level += 1;\n                } else if c == ')' {\n               \
    \     level -= 1;\n                }\n                if level > max_level {\n\
    \                    max_level = level;\n                }\n            }\n  \
    \          max_level\n        })\n        .collect()", "    let groups: Vec<String>\
    \ = paren_string.split_whitespace().map(|s| s.to_string()).collect();\n    let\
    \ mut results: Vec<isize> = Vec::new();\n    for group in groups {\n        let\
    \ mut max_level = 0;\n        let mut curr_level = 0;\n        for char in group.chars()\
    \ {\n            if char == '(' {\n                curr_level += 1;\n        \
    \    } else if char == ')' {\n                curr_level -= 1;\n            }\n\
    \            if curr_level > max_level {\n                max_level = curr_level;\n\
    \            }\n        }\n        results.push(max_level);\n    }\n    results",
  "    let mut max_nesting = 0;\n    let mut curr_nesting = 0;\n    let mut list_nesting\
    \ = Vec::new();\n    for paren in paren_string.chars() {\n        if paren ==\
    \ '(' {\n            curr_nesting += 1;\n            if curr_nesting > max_nesting\
    \ {\n                max_nesting = curr_nesting;\n            }\n        } else\
    \ if paren == ')' {\n            curr_nesting -= 1;\n        } else if paren ==\
    \ ' ' {\n            list_nesting.push(max_nesting);\n            max_nesting\
    \ = 0;\n            curr_nesting = 0;\n        }\n    }\n    list_nesting.push(max_nesting);\n\
    \    list_nesting", "    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ {\n            let mut open_count = 0;\n            let mut max_count = 0;\n\
    \            for c in paren_group.chars() {\n                if c == '(' {\n \
    \                   open_count += 1;\n                    if open_count > max_count\
    \ {\n                        max_count = open_count;\n                    }\n\
    \                } else if c == ')' {\n                    open_count -= 1;\n\
    \                }\n            }\n            if open_count != 0 {\n        \
    \        panic!(\"unbalanced parenthesis\");\n            }\n            max_count\n\
    \        })\n        .collect()", "    paren_string\n        .split(\" \")\n \
    \       .map(|s| {\n            let mut max_nesting = 0;\n            let mut\
    \ nesting = 0;\n            for ch in s.chars() {\n                if ch == '('\
    \ {\n                    nesting += 1;\n                } else if ch == ')' {\n\
    \                    nesting -= 1;\n                }\n                if nesting\
    \ > max_nesting {\n                    max_nesting = nesting;\n              \
    \  }\n            }\n            max_nesting\n        })\n        .collect()",
  "    let mut nested_vec = Vec::new();\n    for paren_group in paren_string.split_whitespace()\
    \ {\n        nested_vec.push(parse_single_paren_group(paren_group));\n    }\n\
    \    nested_vec", "    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ {\n            let mut current_depth = 0;\n            let mut deepest_depth\
    \ = 0;\n            for paren in paren_group.chars() {\n                match\
    \ paren {\n                    '(' => {\n                        current_depth\
    \ += 1;\n                        if current_depth > deepest_depth {\n        \
    \                    deepest_depth = current_depth;\n                        }\n\
    \                    }\n                    ')' => {\n                       \
    \ current_depth -= 1;\n                    }\n                    _ => {}\n  \
    \              }\n            }\n            deepest_depth\n        })\n     \
    \   .collect()", "    let mut max_level = 0;\n    let mut current_level = 0;\n\
    \    let mut groups: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             groups.push(max_level);\n                max_level = 0;\n      \
    \          current_level = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    groups.push(max_level);\n    groups", "    let mut paren_stack: Vec<(char,\
    \ isize)> = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut paren_depth:\
    \ Vec<isize> = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                if max_depth > 0 {\n            \
    \        paren_stack.push(('(', max_depth));\n                }\n            \
    \    max_depth += 1;\n            }\n            ')' => {\n                paren_depth.push(max_depth);\n\
    \                if paren_stack.is_empty() {\n                    max_depth =\
    \ 0;\n                } else {\n                    let stack_top = paren_stack.pop().unwrap();\n\
    \                    max_depth = stack_top.1;\n                }\n           \
    \ }\n            _ => continue,\n        }\n    }\n    paren_depth", "    let\
    \ mut output: Vec<isize> = Vec::new();\n    let mut paren_stack: Vec<char> = Vec::new();\n\
    \    let mut paren_max: isize = 0;\n    let mut paren_level: isize = 0;\n    for\
    \ c in paren_string.chars() {\n        if c == ' ' {\n            if paren_stack.len()\
    \ > 0 {\n                output.push(paren_max);\n                paren_stack.clear();\n\
    \                paren_max = 0;\n                paren_level = 0;\n          \
    \  }\n        } else if c == '(' {\n            paren_stack.push(c);\n       \
    \     paren_level += 1;\n            if paren_level > paren_max {\n          \
    \      paren_max = paren_level;\n            }\n        } else if c == ')' {\n\
    \            if paren_stack.len() > 0 {\n                paren_stack.pop();\n\
    \                paren_level -= 1;\n            }\n        }\n    }\n    if paren_stack.len()\
    \ > 0 {\n        output.push(paren_max);\n    }\n    output", "    let mut result\
    \ = Vec::new();\n    let mut group_stack = Vec::new();\n    let mut max_nesting\
    \ = 0;\n    for paren in paren_string.chars() {\n        if paren == '(' {\n \
    \           group_stack.push(paren);\n            max_nesting += 1;\n        }\
    \ else if paren == ')' {\n            group_stack.pop();\n            if group_stack.is_empty()\
    \ {\n                result.push(max_nesting);\n                max_nesting =\
    \ 0;\n            }\n        }\n    }\n    result", "    paren_string\n      \
    \  .split_whitespace()\n        .map(|group| {\n            group\n          \
    \      .chars()\n                .fold((0, 0), |(level, max_level), c| match c\
    \ {\n                    '(' => (level + 1, cmp::max(level + 1, max_level)),\n\
    \                    ')' => (level - 1, cmp::max(level - 1, max_level)),\n   \
    \                 _ => (level, max_level),\n                })\n             \
    \   .1\n        })\n        .collect()", "    paren_string\n        .split_whitespace()\n\
    \        .map(|parens| {\n            let mut deepest_count = 0;\n           \
    \ let mut curr_count = 0;\n            let mut char_iter = parens.chars();\n \
    \           while let Some(ch) = char_iter.next() {\n                if ch ==\
    \ '(' {\n                    curr_count += 1;\n                    if curr_count\
    \ > deepest_count {\n                        deepest_count = curr_count;\n   \
    \                 }\n                } else if ch == ')' {\n                 \
    \   curr_count -= 1;\n                }\n            }\n            deepest_count\n\
    \        })\n        .collect()", "    let mut result: Vec<isize> = Vec::new();\n\
    \    let mut paren_stack: Vec<char> = Vec::new();\n    let mut current_depth:\
    \ isize = 0;\n    let mut max_depth: isize = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            paren_stack.push(paren);\n       \
    \     current_depth += 1;\n            if current_depth > max_depth {\n      \
    \          max_depth = current_depth;\n            }\n        } else if paren\
    \ == ')' {\n            if paren_stack.pop() != Some('(') {\n                return\
    \ Vec::new();\n            }\n            current_depth -= 1;\n        } else\
    \ if paren == ' ' {\n            result.push(max_depth);\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut max_depth: isize = 0;\n    let mut depth: isize = 0;\n\
    \    let mut paren_group: String = String::new();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == ' ' {\n\
    \            if depth > max_depth {\n                max_depth = depth;\n    \
    \        }\n            depth = 0;\n            result.push(max_depth);\n    \
    \        max_depth = 0;\n            paren_group.clear();\n        } else {\n\
    \            paren_group.push(c);\n            if c == '(' {\n               \
    \ depth += 1;\n            } else if c == ')' {\n                depth -= 1;\n\
    \            }\n        }\n    }\n    result", "    // create a vec of tuples\
    \ representing groups of parens and the number of parens\n    let paren_vec: Vec<&str>\
    \ = paren_string.split(\" \").collect();\n    let paren_vec: Vec<(&str, usize)>\
    \ = paren_vec.iter().map(|s| (s, s.len())).collect();\n\n    // create a vec of\
    \ pairs in which the index is the paren level, and the value is the number of\
    \ parens at that level\n    // the index is initialized to 0\n    let mut levels:\
    \ Vec<(usize, usize)> = vec![(0, 0)];\n\n    // this method will iterate through\
    \ the vec of tuples from the split string\n    // and create a new vector of tuples\
    \ where the first value is the level of the paren\n    // and the second value\
    \ is the number of parens at that level\n    // levels is a mutable reference\
    \ to this new vector\n    paren_vec.iter().for_each(|pair| {\n        let parens\
    \ = pair.1;\n        let mut level = 0;\n        let mut count = 0;\n\n      \
    \  // loop through the first string in each pair in the vec\n        // and create\
    \ a new pair with the index as the level and the value as the number of parens\n\
    \        for c in pair.0.chars() {\n            match c {\n                '('\
    \ => {\n                    level += 1;\n                    count += 1;\n   \
    \             }\n                ')' => {\n                    level -= 1;\n \
    \                   count += 1;\n                }\n                _ => (),\n\
    \            }\n        }\n\n        // the loop through the vec of pairs and\
    \ check if the level index is the same\n        // if it is, increment the paren\
    \ count at that level by the number of parens in the pair\n        // if not,\
    \ add the tuple to the end of the vec\n        let mut found = false;\n      \
    \  for i in 0..levels.len() {\n            if levels[i].0 == level {\n       \
    \         levels[i].1 += parens;\n                found = true;\n            }\n\
    \        }\n        if !found {\n            levels.push((level, count));\n  \
    \      }\n    });", "    let mut paren_stack: Vec<isize> = Vec::new();\n    let\
    \ mut depth_stack: Vec<isize> = Vec::new();\n    let mut result: Vec<isize> =\
    \ Vec::new();\n    for paren in paren_string.chars() {\n        match paren {\n\
    \            '(' => {\n                let mut count = 1;\n                paren_stack.push(paren.into());\n\
    \                if let Some(depth) = depth_stack.last_mut() {\n             \
    \       *depth += 1;\n                } else {\n                    depth_stack.push(count);\n\
    \                }\n            }\n            ')' => {\n                if paren_stack.pop().is_none()\
    \ {\n                    panic!(\"Unbalanced right parentheses\");\n         \
    \       }\n                if let Some(depth) = depth_stack.pop() {\n        \
    \            result.push(depth);\n                }\n            }\n         \
    \   _ => continue,\n        }\n    }\n    if !paren_stack.is_empty() {\n     \
    \   panic!(\"Unbalanced left parentheses\");\n    }\n    result", "    paren_string\n\
    \        .split_whitespace()\n        .map(|group| {\n            let mut level\
    \ = 0;\n            let mut max_level = 0;\n            for c in group.chars()\
    \ {\n                match c {\n                    '(' => level += 1,\n     \
    \               ')' => level -= 1,\n                    _ => (),\n           \
    \     }\n                max_level = max_level.max(level);\n            }\n  \
    \          max_level\n        })\n        .collect()", "    let mut stack: Vec<(char,\
    \ isize)> = Vec::new();\n    let mut output = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if let Some((_, depth)) = stack.last()\
    \ {\n                stack.push((c, depth + 1));\n            } else {\n     \
    \           stack.push((c, 1));\n            }\n        } else if c == ')' {\n\
    \            if let Some((last_char, depth)) = stack.pop() {\n               \
    \ if last_char == '(' {\n                    output.push(*depth);\n          \
    \      } else {\n                    output.push(0);\n                }\n    \
    \        } else {\n                output.push(0);\n            }\n        }\n\
    \    }\n    output", "    let mut paren_vec: Vec<isize> = Vec::new();\n    let\
    \ paren_vec_vec: Vec<Vec<char>> = paren_string\n        .split_whitespace()\n\
    \        .map(|s| s.chars().collect())\n        .collect();\n    for item in paren_vec_vec\
    \ {\n        let mut num_left_paren = 0;\n        let mut curr_max = 0;\n    \
    \    for paren in item {\n            if paren == '(' {\n                num_left_paren\
    \ += 1;\n                if num_left_paren > curr_max {\n                    curr_max\
    \ = num_left_paren;\n                }\n            } else {\n               \
    \ num_left_paren -= 1;\n            }\n        }\n        paren_vec.push(curr_max);\n\
    \    }\n    paren_vec", "    let mut paren_depth = 0;\n    let mut paren_max_depth\
    \ = 0;\n    let mut paren_nesting = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_depth += 1;\n\
    \                if paren_depth > paren_max_depth {\n                    paren_max_depth\
    \ = paren_depth;\n                }\n            }\n            ')' => {\n   \
    \             paren_depth -= 1;\n            }\n            ' ' => {\n       \
    \         paren_nesting.push(paren_max_depth);\n                paren_depth =\
    \ 0;\n                paren_max_depth = 0;\n            }\n            _ => {}\n\
    \        }\n    }\n    paren_nesting.push(paren_max_depth);\n    paren_nesting",
  "    let mut max_level = 0;\n    let mut curr_level = 0;\n    let mut result = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                curr_level += 1;\n                if curr_level > max_level {\n\
    \                    max_level = curr_level;\n                }\n            }\n\
    \            ')' => {\n                if curr_level > 0 {\n                 \
    \   curr_level -= 1;\n                }\n            }\n            ' ' => {\n\
    \                result.push(max_level);\n                max_level = 0;\n   \
    \             curr_level = 0;\n            }\n            _ => (),\n        }\n\
    \    }\n    if curr_level > 0 {\n        result.push(max_level);\n    }\n    result",
  "    return paren_string\n        .split_whitespace()\n        .map(|s| {\n    \
    \        let mut max_nesting_level = 0;\n            let mut current_nesting_level\
    \ = 0;\n            for c in s.chars() {\n                if c == '(' {\n    \
    \                current_nesting_level += 1;\n                    if current_nesting_level\
    \ > max_nesting_level {\n                        max_nesting_level = current_nesting_level;\n\
    \                    }\n                } else if c == ')' {\n               \
    \     current_nesting_level -= 1;\n                }\n            }\n        \
    \    max_nesting_level\n        })\n        .collect();", "    let mut group_max\
    \ = Vec::new();\n    let mut max = 0;\n    let mut current = 0;\n    for paren\
    \ in paren_string.chars() {\n        match paren {\n            '(' => {\n   \
    \             current += 1;\n                if current > max {\n            \
    \        max = current;\n                }\n            }\n            ')' =>\
    \ {\n                current -= 1;\n            }\n            ' ' => {\n    \
    \            group_max.push(max);\n                max = 0;\n                current\
    \ = 0;\n            }\n            _ => continue,\n        }\n    }\n    group_max.push(max);\n\
    \    group_max", "    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut max_depth = 0;\n            let mut curr_depth = 0;\n\
    \            for c in s.chars() {\n                if c == '(' {\n           \
    \         curr_depth += 1;\n                    if curr_depth > max_depth {\n\
    \                        max_depth = curr_depth;\n                    }\n    \
    \            } else if c == ')' {\n                    curr_depth -= 1;\n    \
    \            }\n            }\n            max_depth\n        })\n        .collect()",
  "    let mut ret = Vec::new();\n    let mut level = 0;\n    let mut max_level =\
    \ 0;\n    for ch in paren_string.chars() {\n        if ch == '(' {\n         \
    \   level += 1;\n            max_level = std::cmp::max(max_level, level);\n  \
    \      } else if ch == ')' {\n            level -= 1;\n        } else if ch ==\
    \ ' ' {\n            ret.push(max_level);\n            max_level = 0;\n      \
    \      level = 0;\n        }\n    }\n    if max_level > 0 {\n        ret.push(max_level);\n\
    \    }\n    ret", "    let mut stack: Vec<char> = Vec::new();\n    let mut result:\
    \ Vec<isize> = Vec::new();\n    let mut highest_count: isize = 0;\n    let mut\
    \ current_count: isize = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            current_count += 1;\n            if current_count > highest_count\
    \ {\n                highest_count = current_count;\n            }\n         \
    \   stack.push(c);\n        } else if c == ')' {\n            current_count -=\
    \ 1;\n            if current_count < 0 {\n                result.push(-1);\n \
    \               highest_count = 0;\n                current_count = 0;\n     \
    \           stack.clear();\n            } else {\n                stack.pop();\n\
    \                if stack.is_empty() {\n                    result.push(highest_count);\n\
    \                    highest_count = 0;\n                    current_count = 0;\n\
    \                }\n            }\n        } else if c == ' ' {\n            if\
    \ stack.is_empty() {\n                highest_count = 0;\n                current_count\
    \ = 0;\n            }\n        }\n    }\n    if !stack.is_empty() {\n        result.push(-1);\n\
    \    }\n    result", "    let mut current_level = 0;\n    let mut max_level =\
    \ 0;\n    let mut max_levels = Vec::new();\n    let mut chars = paren_string.chars();\n\
    \    while let Some(c) = chars.next() {\n        match c {\n            '(' =>\
    \ {\n                current_level += 1;\n                if current_level > max_level\
    \ {\n                    max_level = current_level;\n                }\n     \
    \       }\n            ')' => {\n                current_level -= 1;\n       \
    \     }\n            ' ' => {\n                max_levels.push(max_level);\n \
    \               max_level = 0;\n                current_level = 0;\n         \
    \   }\n            _ => panic!(\"Unexpected char {}\", c),\n        }\n    }\n\
    \    max_levels.push(max_level);\n    max_levels", "    paren_string\n       \
    \ .split_whitespace()\n        .map(|paren_group| {\n            let mut max_depth\
    \ = 0;\n            let mut current_depth = 0;\n            for ch in paren_group.chars()\
    \ {\n                match ch {\n                    '(' => {\n              \
    \          current_depth += 1;\n                        if current_depth > max_depth\
    \ {\n                            max_depth = current_depth;\n                \
    \        }\n                    }\n                    ')' => {\n            \
    \            current_depth -= 1;\n                    }\n                    _\
    \ => (),\n                }\n            }\n            max_depth\n        })\n\
    \        .collect()", "    let mut max_level: isize = 0;\n    let mut current_level:\
    \ isize = 0;\n    let mut results: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             results.push(max_level);\n                max_level = 0;\n     \
    \           current_level = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    results.push(max_level);\n    results", "    let mut results = Vec::new();\n\
    \    for grp in paren_string.split_whitespace() {\n        results.push(parse_nested_parens_helper(grp));\n\
    \    }\n    results", "    let mut output: Vec<isize> = Vec::new();\n    for paren\
    \ in paren_string.split_whitespace() {\n        let mut paren_iter = paren.chars();\n\
    \        let mut max_nesting = 0;\n        let mut nesting = 0;\n        let mut\
    \ prev_c = ' ';\n        while let Some(c) = paren_iter.next() {\n           \
    \ if c == '(' {\n                nesting += 1;\n            } else if c == ')'\
    \ {\n                nesting -= 1;\n            }\n            if prev_c == '('\
    \ && c == ')' {\n                max_nesting = std::cmp::max(max_nesting, nesting);\n\
    \            }\n            prev_c = c;\n        }\n        output.push(max_nesting);\n\
    \    }\n    output", "    return paren_string\n        .split_whitespace()\n \
    \       .map(|g| {\n            let mut paren_level = 0;\n            let mut\
    \ deepest_level = 0;\n            for c in g.chars() {\n                if c ==\
    \ '(' {\n                    paren_level += 1;\n                    if paren_level\
    \ > deepest_level {\n                        deepest_level = paren_level;\n  \
    \                  }\n                } else if c == ')' {\n                 \
    \   paren_level -= 1;\n                }\n            }\n            return deepest_level;\n\
    \        })\n        .collect();", "    let mut level_idx = 0;\n    let mut max_levels\
    \ = Vec::new();\n    for ch in paren_string.chars() {\n        match ch {\n  \
    \          '(' => level_idx += 1,\n            ')' => level_idx -= 1,\n      \
    \      ' ' => {\n                max_levels.push(level_idx);\n               \
    \ level_idx = 0;\n            }\n            _ => panic!(\"Invalid character found\
    \ in string!\"),\n        }\n    }\n    max_levels", "    let mut max_nesting\
    \ = vec![];\n    let mut open_count = 0;\n    let mut max_open_count = 0;\n  \
    \  for c in paren_string.chars() {\n        if c == '(' {\n            open_count\
    \ += 1;\n            if open_count > max_open_count {\n                max_open_count\
    \ = open_count;\n            }\n        } else if c == ')' {\n            open_count\
    \ -= 1;\n        } else if c == ' ' {\n            max_nesting.push(max_open_count);\n\
    \            max_open_count = 0;\n            open_count = 0;\n        }\n   \
    \ }\n    max_nesting.push(max_open_count);\n    max_nesting", "    let mut res\
    \ = Vec::new();\n    let mut stack = Vec::new();\n    let mut count = 0;\n   \
    \ for ch in paren_string.chars() {\n        if ch == '(' {\n            stack.push(ch);\n\
    \            count += 1;\n        } else if ch == ')' {\n            stack.pop();\n\
    \            count -= 1;\n        } else if ch == ' ' {\n            res.push(count);\n\
    \            count = 0;\n        }\n    }\n    res.push(count);\n    res", " \
    \   let mut paren_vec: Vec<char> = Vec::new();\n    let mut res: Vec<isize> =\
    \ Vec::new();\n    for c in paren_string.chars() {\n        if c == '(' {\n  \
    \          paren_vec.push(c);\n        } else if c == ')' {\n            if paren_vec.pop()\
    \ == Some('(') {\n                res.push(paren_vec.len() as isize);\n      \
    \      }\n        }\n    }\n    res", "    // let mut paren_stack: Vec<char> =\
    \ Vec::new();\n    // let mut paren_stack_idx: Vec<usize> = Vec::new();\n    //\
    \ let mut max_depth: isize = 0;\n    // let mut curr_depth: isize = 0;\n    //\
    \ let mut num_groups: usize = 0;\n    // let mut group_max_depth: Vec<isize> =\
    \ Vec::new();\n    // for (i, c) in paren_string.chars().enumerate() {\n    //\
    \     match c {\n    //         '(' => {\n    //             paren_stack.push(c);\n\
    \    //             paren_stack_idx.push(i);\n    //             curr_depth +=\
    \ 1;\n    //             if curr_depth > max_depth {\n    //                 max_depth\
    \ = curr_depth;\n    //             }\n    //         }\n    //         ')' =>\
    \ {\n    //             paren_stack.pop();\n    //             paren_stack_idx.pop();\n\
    \    //             curr_depth -= 1;\n    //         }\n    //         ' ' =>\
    \ {\n    //             if !paren_stack.is_empty() {\n    //                 panic!(\"\
    Error in parsing parentheses {} at index {}\", paren_string, i);\n    //     \
    \        }\n    //             group_max_depth.push(max_depth);\n    //      \
    \       max_depth = 0;\n    //             curr_depth = 0;\n    //           \
    \  num_groups += 1;\n    //         }\n    //         _ => {}\n    //     }\n\
    \    // }\n    // if !paren_stack.is_empty() {\n    //     panic!(\"Error in parsing\
    \ parentheses {} at index {}\", paren_string, paren_string.len() - 1);\n    //\
    \ }\n    // if num_groups != paren_string.split(' ').count() {\n    //     panic!(\"\
    Num groups {} is not equal to len {}\", num_groups, paren_string.split(' ').count());\n\
    \    // }\n    // group_max_depth.push(max_depth);\n    //", "    let groups:\
    \ Vec<&str> = paren_string.split_whitespace().collect();\n    groups.iter().map(|g|\
    \ {\n        let mut num_left_parens = 0;\n        let mut max_depth = 0;\n  \
    \      let mut chars = g.chars();\n        while let Some(c) = chars.next() {\n\
    \            match c {\n                '(' => {\n                    num_left_parens\
    \ += 1;\n                    max_depth = num_left_parens.max(max_depth);\n   \
    \             }\n                ')' => {\n                    num_left_parens\
    \ -= 1;\n                }\n                _ => unreachable!(),\n           \
    \ }\n        }\n        max_depth\n    }).collect()", "    let mut res = Vec::new();\n\
    \    for paren_substring in paren_string.split(\" \") {\n        let mut max_depth\
    \ = 0;\n        let mut curr_depth = 0;\n        for paren in paren_substring.chars()\
    \ {\n            if paren == '(' {\n                curr_depth += 1;\n       \
    \         max_depth = max(max_depth, curr_depth);\n            } else if paren\
    \ == ')' {\n                curr_depth -= 1;\n            }\n        }\n     \
    \   res.push(max_depth);\n    }\n    res", "    let mut max_nesting = 0;\n   \
    \ let mut paren_stack = Vec::new();\n    let mut parse_vec = Vec::new();\n   \
    \ for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \            max_nesting += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            max_nesting -= 1;\n        } else if c == ' ' {\n            parse_vec.push(max_nesting);\n\
    \            max_nesting = 0;\n        }\n    }\n    parse_vec", "    paren_string\n\
    \        .split_whitespace()\n        .map(|s| {\n            s.chars()\n    \
    \            .fold(0isize, |max_depth, c| match c {\n                    '(' =>\
    \ max_depth + 1,\n                    ')' => max_depth - 1,\n                \
    \    _ => max_depth,\n                })\n        })\n        .collect()", " \
    \   let mut paren_levels = Vec::new();\n    let mut current_level = 0;\n    let\
    \ mut max_level = 0;\n    for ch in paren_string.chars() {\n        match ch {\n\
    \            '(' => {\n                current_level += 1;\n                if\
    \ current_level > max_level {\n                    max_level = current_level;\n\
    \                }\n            }\n            ')' => {\n                current_level\
    \ -= 1;\n            }\n            ' ' => {\n                paren_levels.push(max_level);\n\
    \                max_level = 0;\n                current_level = 0;\n        \
    \    }\n            _ => (),\n        }\n    }\n    if current_level > 0 {\n \
    \       paren_levels.push(max_level);\n    }\n    paren_levels", "    let mut\
    \ max_level = 0;\n    let mut levels = Vec::new();\n    let mut current_level\
    \ = 0;\n    for character in paren_string.chars() {\n        match character {\n\
    \            '(' => {\n                current_level += 1;\n                if\
    \ current_level > max_level {\n                    max_level = current_level;\n\
    \                }\n            }\n            ')' => {\n                levels.push(current_level);\n\
    \                current_level -= 1;\n            }\n            _ => {}\n   \
    \     }\n    }\n    levels", "    let mut maximum_nesting = 0;\n    let mut paren_vec:\
    \ Vec<isize> = Vec::new();\n    for ch in paren_string.chars() {\n        match\
    \ ch {\n            '(' => {\n                maximum_nesting += 1;\n        \
    \        paren_vec.push(1);\n            }\n            ')' => {\n           \
    \     paren_vec.push(-1);\n                if paren_vec.iter().sum::<isize>()\
    \ == 0 {\n                    paren_vec.push(maximum_nesting);\n             \
    \       maximum_nesting = 0;\n                }\n            }\n            _\
    \ => continue,\n        }\n    }\n    paren_vec", "    paren_string\n        .split_whitespace()\n\
    \        .map(|group| {\n            let mut max_nesting = 0;\n            let\
    \ mut current_nesting = 0;\n            let mut chars = group.chars();\n     \
    \       while let Some(paren) = chars.next() {\n                match paren {\n\
    \                    '(' => {\n                        current_nesting += 1;\n\
    \                        if current_nesting > max_nesting {\n                \
    \            max_nesting = current_nesting;\n                        }\n     \
    \               }\n                    ')' => {\n                        current_nesting\
    \ -= 1;\n                    }\n                    _ => panic!(\"Unexpected character\
    \ in paren string\"),\n                }\n            }\n            max_nesting\n\
    \        })\n        .collect()", "    let mut counter = 0;\n    let mut max_counter\
    \ = 0;\n    let mut max_parens = Vec::new();\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            counter += 1;\n        } else if ch ==\
    \ ')' {\n            counter -= 1;\n        } else if ch == ' ' {\n          \
    \  max_parens.push(max_counter);\n            max_counter = 0;\n        } else\
    \ {\n            panic!(\"Unknown char: {}\", ch);\n        }\n        if counter\
    \ > max_counter {\n            max_counter = counter;\n        }\n    }\n    max_parens.push(max_counter);\n\
    \    max_parens", "    paren_string\n        .split_whitespace()\n        .map(|p|\
    \ {\n            let mut max_depths = Vec::new();\n            let mut depth =\
    \ 0;\n            for c in p.chars() {\n                match c {\n          \
    \          '(' => depth += 1,\n                    ')' => depth -= 1,\n      \
    \              _ => {\n                        println!(\"Unexpected character\
    \ {:?}\", c);\n                        panic!();\n                    }\n    \
    \            }\n                max_depths.push(depth);\n            }\n     \
    \       if *max_depths.iter().max().unwrap() != 0 {\n                println!(\"\
    No matching parentheses in string {:?}\", p);\n                panic!();\n   \
    \         }\n            max_depths.into_iter().max().unwrap()\n        })\n \
    \       .collect()", "    let paren_strings: Vec<&str> = paren_string.split(\"\
    \ \").collect();\n    paren_strings\n        .iter()\n        .map(|paren_str|\
    \ {\n            let mut paren_level = 0;\n            let mut max_level = 0;\n\
    \            for char in paren_str.chars() {\n                if char == '(' {\n\
    \                    paren_level += 1;\n                } else if char == ')'\
    \ {\n                    paren_level -= 1;\n                }\n              \
    \  if paren_level > max_level {\n                    max_level = paren_level;\n\
    \                }\n            }\n            max_level\n        })\n       \
    \ .collect()", "    let mut result = Vec::new();\n    let mut max_nesting = 0;\n\
    \    let mut current_nesting = 0;\n    let mut paren_iter = paren_string.chars();\n\
    \    for c in paren_iter {\n        match c {\n            '(' => {\n        \
    \        current_nesting += 1;\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                current_nesting -= 1;\n \
    \           }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                current_nesting = 0;\n    \
    \        }\n            _ => (),\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut result: Vec<isize> = Vec::new();\n    let mut chars\
    \ = paren_string.chars();\n    let mut max_level = 0;\n    let mut curr_level\
    \ = 0;\n    loop {\n        match chars.next() {\n            Some('(') => {\n\
    \                curr_level += 1;\n                if curr_level > max_level {\n\
    \                    max_level = curr_level;\n                }\n            }\n\
    \            Some(')') => {\n                curr_level -= 1;\n            }\n\
    \            Some(' ') => {\n                result.push(max_level);\n       \
    \         max_level = 0;\n                curr_level = 0;\n            }\n   \
    \         None => {\n                result.push(max_level);\n               \
    \ break;\n            }\n            _ => {}\n        }\n    }\n    result", " \
    \   paren_string\n        .split_whitespace()\n        .map(|paren_grp| {\n  \
    \          let mut nest_level = 0;\n            let mut max_nest_level = 0;\n\
    \            for c in paren_grp.chars() {\n                if c == '(' {\n   \
    \                 nest_level += 1;\n                } else if c == ')' {\n   \
    \                 nest_level -= 1;\n                }\n                if nest_level\
    \ > max_nest_level {\n                    max_nest_level = nest_level;\n     \
    \           }\n            }\n            max_nest_level\n        })\n       \
    \ .collect()", "    let mut results = Vec::new();\n    let mut string_iter = paren_string.split_whitespace();\n\
    \    while let Some(curr_str) = string_iter.next() {\n        let mut curr_max\
    \ = 0;\n        let mut max_so_far = 0;\n        for ch in curr_str.chars() {\n\
    \            if ch == '(' {\n                curr_max += 1;\n            } else\
    \ if ch == ')' {\n                curr_max -= 1;\n            }\n            if\
    \ curr_max > max_so_far {\n                max_so_far = curr_max;\n          \
    \  }\n        }\n        results.push(max_so_far);\n    }\n    results", "   \
    \ let mut result: Vec<isize> = Vec::new();\n    let mut curr_depth: isize = 0;\n\
    \    let mut max_depth: isize = 0;\n    for ch in paren_string.chars() {\n   \
    \     if ch == '(' {\n            curr_depth += 1;\n            if curr_depth\
    \ > max_depth {\n                max_depth = curr_depth;\n            }\n    \
    \    } else if ch == ')' {\n            curr_depth -= 1;\n        } else if ch\
    \ == ' ' {\n            result.push(max_depth);\n            curr_depth = 0;\n\
    \            max_depth = 0;\n        }\n    }\n    result.push(max_depth);\n \
    \   result", "    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut max_depth = 0;\n            let mut current_depth = 0;\n\
    \            for c in s.chars() {\n                if c == '(' {\n           \
    \         current_depth += 1;\n                    if current_depth > max_depth\
    \ {\n                        max_depth = current_depth;\n                    }\n\
    \                } else if c == ')' {\n                    current_depth -= 1;\n\
    \                }\n            }\n            max_depth\n        })\n       \
    \ .collect()", "    let mut nested_parens: Vec<isize> = Vec::new();\n    let mut\
    \ max_nesting = 0;\n    let mut curr_nesting = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            curr_nesting += 1;\n            if curr_nesting\
    \ > max_nesting {\n                max_nesting = curr_nesting;\n            }\n\
    \        } else if c == ')' {\n            if curr_nesting > 0 {\n           \
    \     curr_nesting -= 1;\n            }\n        } else if c == ' ' {\n      \
    \      nested_parens.push(max_nesting);\n            max_nesting = 0;\n      \
    \      curr_nesting = 0;\n        }\n    }\n    // For last group,\n    if max_nesting\
    \ > 0 {\n        nested_parens.push(max_nesting);\n    }\n    nested_parens",
  "    let mut v: Vec<isize> = Vec::new();\n    let mut max: isize = 0;\n    let mut\
    \ curr: isize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            curr += 1;\n            if curr > max {\n                max = curr;\n\
    \            }\n        } else if c == ')' {\n            curr -= 1;\n       \
    \ } else if c == ' ' {\n            v.push(max);\n            max = 0;\n     \
    \       curr = 0;\n        }\n    }\n    v.push(max);\n    v", "    let mut result:\
    \ Vec<isize> = Vec::new();\n    let mut paren_iter = paren_string.split_whitespace();\n\
    \    while let Some(paren) = paren_iter.next() {\n        let mut paren_stack:\
    \ Vec<char> = Vec::new();\n        let mut current_max = 0;\n        let mut current_level\
    \ = 0;\n        for ch in paren.chars() {\n            if ch == '(' {\n      \
    \          paren_stack.push(ch);\n                current_level += 1;\n      \
    \          if current_level > current_max {\n                    current_max =\
    \ current_level;\n                }\n            } else if ch == ')' {\n     \
    \           if paren_stack.len() > 0 {\n                    paren_stack.pop();\n\
    \                    current_level -= 1;\n                }\n            }\n \
    \       }\n        result.push(current_max);\n    }\n    result", "    let paren_string\
    \ = paren_string.trim();\n    let mut paren_groups = Vec::new();\n    let mut\
    \ paren_count = 0;\n    let mut max_nested_level = Vec::new();\n    for paren\
    \ in paren_string.chars() {\n        if paren == '(' {\n            paren_count\
    \ += 1;\n        } else if paren == ')' {\n            paren_count -= 1;\n   \
    \     }\n        if paren == ' ' || paren == ')' {\n            paren_groups.push(paren_count);\n\
    \        }\n    }\n    let mut lowest_level = 0;\n    for paren_group in paren_groups\
    \ {\n        if paren_group < lowest_level {\n            lowest_level = paren_group;\n\
    \        }\n        max_nested_level.push(paren_group - lowest_level);\n    }\n\
    \    max_nested_level", "    paren_string\n        .split(\" \")\n        .map(|s|\
    \ {\n            let mut open_parens = 0;\n            let mut max_level = 0;\n\
    \            for c in s.chars() {\n                if c == '(' {\n           \
    \         open_parens += 1;\n                    if open_parens > max_level {\n\
    \                        max_level = open_parens;\n                    }\n   \
    \             } else if c == ')' {\n                    open_parens -= 1;\n  \
    \              }\n            }\n            max_level\n        })\n        .collect()",
  "    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n    let mut\
    \ start_indices: Vec<usize> = Vec::new();\n    let mut end_indices: Vec<usize>\
    \ = Vec::new();\n    let mut group_level_vec: Vec<isize> = Vec::new();\n    let\
    \ mut group_level: isize = 0;\n    let mut group_start_index: usize = 0;\n   \
    \ let mut group_end_index: usize = 0;\n    for (i, paren) in paren_vec.iter().enumerate()\
    \ {\n        match paren {\n            '(' => {\n                if group_level\
    \ == 0 {\n                    group_start_index = i;\n                }\n    \
    \            group_level += 1;\n            }\n            ')' => {\n        \
    \        group_level -= 1;\n                if group_level == 0 {\n          \
    \          group_end_index = i;\n                    start_indices.push(group_start_index);\n\
    \                    end_indices.push(group_end_index);\n                }\n \
    \           }\n            _ => {}\n        }\n    }\n    for (i, j) in start_indices.iter().zip(end_indices.iter())\
    \ {\n        group_level_vec.push(parse_nested_parens_helper(&paren_vec[i + 1..j]));\n\
    \    }\n    group_level_vec", "    let mut max_nesting = Vec::new();\n    let\
    \ mut nested_parens = Vec::new();\n    for char in paren_string.chars() {\n  \
    \      match char {\n            '(' => {\n                nested_parens.push(char);\n\
    \            }\n            ')' => {\n                match nested_parens.pop()\
    \ {\n                    Some('(') => max_nesting.push(nested_parens.len() as\
    \ isize),\n                    Some(_) => panic!(\"Found stray ')'\"),\n     \
    \               None => panic!(\"Found stray ')'\"),\n                }\n    \
    \        }\n            _ => panic!(\"Found stray character\"),\n        }\n \
    \   }\n    if !nested_parens.is_empty() {\n        panic!(\"Unmatched parens\"\
    );\n    }\n    max_nesting", "    let mut max_nesting = 0;\n    let mut depth\
    \ = 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                depth += 1;\n      \
    \          if depth > max_nesting {\n                    max_nesting = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                depth = 0;\n            }\n\
    \            _ => (),\n        }\n    }\n    result.push(max_nesting);\n    result",
  "    paren_string\n        .split_whitespace()\n        .map(|paren_group| {\n \
    \           paren_group\n                .chars()\n                .map(|c| match\
    \ c {\n                    '(' => 1,\n                    ')' => -1,\n       \
    \             _ => 0,\n                })\n                .scan(0, |acc, x| {\n\
    \                    *acc = *acc + x;\n                    Some(*acc)\n      \
    \          })\n                .max()\n                .unwrap()\n        })\n\
    \        .collect()", "    paren_string\n        .split_whitespace()\n       \
    \ .map(|group| count_deepest_nesting(group))\n        .collect()", "    let mut\
    \ nest_count: isize = 0;\n    let mut deepest_nest_count: isize = 0;\n    let\
    \ mut result: Vec<isize> = Vec::new();\n\n    for i in paren_string.chars() {\n\
    \        if i == '(' {\n            nest_count += 1;\n            if nest_count\
    \ > deepest_nest_count {\n                deepest_nest_count = nest_count;\n \
    \           }\n        } else if i == ')' {\n            nest_count -= 1;\n  \
    \      } else if i == ' ' {\n            result.push(deepest_nest_count);\n  \
    \          deepest_nest_count = 0;\n            nest_count = 0;\n        }\n \
    \   }\n    result.push(deepest_nest_count);\n    result", "    let mut paren_groups:\
    \ Vec<isize> = Vec::new();\n    let paren_strings: Vec<&str> = paren_string.split(\"\
    \ \").collect();\n    for paren_str in paren_strings {\n        let mut num_nested_parens\
    \ = 0;\n        let mut max_nested_parens = 0;\n        for c in paren_str.chars()\
    \ {\n            if c == '(' {\n                num_nested_parens += 1;\n    \
    \        } else if c == ')' {\n                num_nested_parens -= 1;\n     \
    \       }\n            if num_nested_parens > max_nested_parens {\n          \
    \      max_nested_parens = num_nested_parens;\n            }\n        }\n    \
    \    paren_groups.push(max_nested_parens);\n    }\n    paren_groups", "    let\
    \ mut vec = Vec::new();\n    let mut first_paren_pos = 0;\n    let mut end_paren_pos\
    \ = 0;\n    let mut i = 0;\n    while i < paren_string.len() {\n        let mut\
    \ group_parens = 0;\n        let mut inner_parens = 0;\n        if &paren_string[i..i\
    \ + 1] == \"(\" {\n            group_parens += 1;\n            inner_parens +=\
    \ 1;\n            first_paren_pos = i;\n            i += 1;\n            while\
    \ i < paren_string.len() && group_parens > 0 {\n                if &paren_string[i..i\
    \ + 1] == \"(\" {\n                    group_parens += 1;\n                  \
    \  inner_parens += 1;\n                } else if &paren_string[i..i + 1] == \"\
    )\" {\n                    group_parens -= 1;\n                }\n           \
    \     i += 1;\n            }\n            end_paren_pos = i;\n            let\
    \ substring = &paren_string[first_paren_pos..end_paren_pos];\n            if substring.contains(\"\
    (\") {\n                let inner_parse = parse_nested_parens(substring.to_string());\n\
    \                vec.push(inner_parse.iter().max().unwrap().clone());\n      \
    \      } else {\n                vec.push(inner_parens);\n            }\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    vec", "    let mut max_levels\
    \ = Vec::new();\n    let paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    for parens in paren_groups {\n        let mut nest_counter = 0;\n       \
    \ let mut max_nest = 0;\n        for paren in parens.chars() {\n            if\
    \ paren == '(' {\n                nest_counter += 1;\n            } else if paren\
    \ == ')' {\n                nest_counter -= 1;\n            }\n            if\
    \ nest_counter > max_nest {\n                max_nest = nest_counter;\n      \
    \      }\n        }\n        max_levels.push(max_nest);\n    }\n    max_levels",
  "    let mut max_nesting_depth = 0;\n    let mut depth = 0;\n    let mut vec = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_nesting_depth {\n\
    \                    max_nesting_depth = depth;\n                }\n         \
    \   }\n            ')' => {\n                depth -= 1;\n            }\n    \
    \        ' ' => {\n                vec.push(max_nesting_depth);\n            \
    \    max_nesting_depth = 0;\n                depth = 0;\n            }\n     \
    \       _ => {}\n        }\n    }\n    vec.push(max_nesting_depth);\n    vec",
  "    // Write code here\n    let mut depth: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    let mut paren_string: Vec<char> = paren_string.chars().collect();\n\
    \    while !paren_string.is_empty() {\n        let current_level: isize = 0;\n\
    \        while !paren_string.is_empty() && *paren_string.first().unwrap() != '\
    \ ' {\n            let c = paren_string.remove(0);\n            if c == '(' {\n\
    \                depth += 1;\n            } else if c == ')' {\n             \
    \   depth -= 1;\n            }\n        }\n        if paren_string.is_empty()\
    \ {\n            result.push(depth);\n        } else {\n            paren_string.remove(0);\n\
    \            result.push(depth);\n        }\n    }\n    result", "    paren_string\n\
    \        .split_whitespace()\n        .map(|group| {\n            let mut stack\
    \ = Vec::new();\n            let mut max_level = 0;\n            let mut level\
    \ = 0;\n            for paren in group.chars() {\n                match paren\
    \ {\n                    '(' => {\n                        level += 1;\n     \
    \                   max_level = cmp::max(max_level, level);\n                \
    \        stack.push(level);\n                    }\n                    ')' =>\
    \ {\n                        level = stack.pop().unwrap();\n                 \
    \   }\n                    _ => (),\n                }\n            }\n      \
    \      max_level\n        })\n        .collect()", "    let mut max_depth = 0;\n\
    \    let mut max_depth_stack = Vec::new();\n    let mut result = Vec::new();\n\
    \    paren_string.chars().for_each(|ch| {\n        if ch == '(' {\n          \
    \  max_depth += 1;\n            max_depth_stack.push(max_depth);\n        } else\
    \ if ch == ')' {\n            let depth = max_depth_stack.pop().unwrap();\n  \
    \          result.push(depth);\n            max_depth -= 1;\n        }\n    });\n\
    \    result", "    paren_string\n        .split(\" \")\n        .map(|x| parse_nested_parens_helper(x.to_string()))\n\
    \        .collect()", "    let mut max_depths = Vec::new();\n    let mut current_depth\
    \ = 0;\n    let mut current_max_depth = 0;\n    for char in paren_string.chars()\
    \ {\n        match char {\n            '(' => {\n                current_depth\
    \ += 1;\n                if current_depth > current_max_depth {\n            \
    \        current_max_depth = current_depth;\n                }\n            }\n\
    \            ')' => {\n                current_depth -= 1;\n            }\n  \
    \          ' ' => {\n                max_depths.push(current_max_depth);\n   \
    \             current_depth = 0;\n                current_max_depth = 0;\n   \
    \         }\n            _ => {}\n        }\n    }\n    max_depths", "    let\
    \ mut result = Vec::new();\n    for s in paren_string.split(\" \") {\n       \
    \ let mut max_nesting = 0;\n        let mut current_nesting = 0;\n        for\
    \ c in s.chars() {\n            if c == '(' {\n                current_nesting\
    \ += 1;\n            } else if c == ')' {\n                if current_nesting\
    \ > max_nesting {\n                    max_nesting = current_nesting;\n      \
    \          }\n                current_nesting -= 1;\n            }\n        }\n\
    \        result.push(max_nesting);\n    }\n    result", "    let mut max_level\
    \ = 0;\n    let mut current_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        match paren {\n            '('\
    \ => {\n                current_level += 1;\n                if current_level\
    \ > max_level {\n                    max_level = current_level;\n            \
    \    }\n            }\n            ')' => {\n                current_level -=\
    \ 1;\n            }\n            ' ' => {\n                paren_levels.push(max_level);\n\
    \                max_level = 0;\n                current_level = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    paren_levels.push(max_level);\n\
    \    paren_levels", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut results = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                results.push(max_depth);\n        \
    \        max_depth = 0;\n                depth = 0;\n            }\n         \
    \   _ => panic!(\"Unexpected input!\"),\n        }\n    }\n    results.push(max_depth);\n\
    \    results", "    let mut count_vec = Vec::new();\n    let mut tmp_count = 0;\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => tmp_count\
    \ += 1,\n            ')' => tmp_count -= 1,\n            ' ' => {\n          \
    \      count_vec.push(tmp_count);\n                tmp_count = 0;\n          \
    \  }\n            _ => {}\n        }\n    }\n    count_vec", "    let paren_split\
    \ = paren_string.split(\" \");\n    let mut nested_levels: Vec<isize> = Vec::new();\n\
    \    for paren in paren_split {\n        let mut max_nested = 0;\n        let\
    \ mut current_nested = 0;\n        for c in paren.chars() {\n            if c\
    \ == '(' {\n                current_nested += 1;\n            } else if c == ')'\
    \ {\n                current_nested -= 1;\n            }\n            if current_nested\
    \ > max_nested {\n                max_nested = current_nested;\n            }\n\
    \        }\n        nested_levels.push(max_nested);\n    }\n    nested_levels",
  "    paren_string\n        .split_whitespace()\n        .map(|x| check_nested_parens(x.to_string()))\n\
    \        .collect()", "    paren_string\n        .split(\" \")\n        .map(|paren_group|\
    \ {\n            let mut count = 0;\n            let mut max_nesting = 0;\n  \
    \          for c in paren_group.chars() {\n                if c == '(' {\n   \
    \                 count += 1;\n                    if count > max_nesting {\n\
    \                        max_nesting = count;\n                    }\n       \
    \         } else if c == ')' {\n                    count -= 1;\n            \
    \    }\n            }\n            max_nesting\n        })\n        .collect()",
  "    // iterate through all the groups\n    paren_string\n        .split(\" \")\n\
    \        .map(|s| {\n            // iterate through each char in the group string\n\
    \            s.chars()\n                .fold((0, 0), |(current_max, current_count),\
    \ c| {\n                    // for each opening paren, increment the current depth\n\
    \                    // for each closing paren, decrement the current depth\n\
    \                    // if current depth is 0, we've reached the end of a single\
    \ group\n                    // so set current_count to zero\n               \
    \     // otherwise compare the current max depth with the current count\n    \
    \                // and update current_max accordingly\n                    match\
    \ c {\n                        '(' => (current_max.max(current_count + 1), current_count\
    \ + 1),\n                        ')' => (current_max.max(current_count), current_count\
    \ - 1),\n                        _ => (current_max, current_count),\n        \
    \            }\n                })\n                .0\n        })\n        .collect()",
  "    let mut result = Vec::new();\n    let mut paren_stack = Vec::new();\n    let\
    \ mut count = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            paren_stack.push(c);\n            count += 1;\n        } else if\
    \ c == ')' {\n            paren_stack.pop();\n            count -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(count);\n            count =\
    \ 0;\n        }\n    }\n    if !paren_stack.is_empty() {\n        panic!(\"Error\
    \ parsing nested parentheses string\");\n    }\n    result", "    let mut paren_stack:\
    \ Vec<char> = Vec::new();\n    let mut count: Vec<isize> = Vec::new();\n    let\
    \ mut max: isize = 0;\n    let paren_string = paren_string.as_str();\n    let\
    \ mut i: usize = 0;\n    while i < paren_string.len() {\n        if paren_string.chars().nth(i).unwrap()\
    \ == '(' {\n            paren_stack.push(paren_string.chars().nth(i).unwrap());\n\
    \            max += 1;\n        } else if paren_string.chars().nth(i).unwrap()\
    \ == ')' {\n            paren_stack.pop();\n            max -= 1;\n        } else\
    \ if paren_string.chars().nth(i).unwrap() == ' ' {\n            count.push(max);\n\
    \            max = 0;\n        }\n        i += 1;\n    }\n    count.push(max);\n\
    \    return count;", "    let mut output: Vec<isize> = Vec::new();\n    let mut\
    \ open_par_count: isize = 0;\n    let mut max_open_par_count: isize = 0;\n   \
    \ for c in paren_string.chars() {\n        if c == '(' {\n            open_par_count\
    \ += 1;\n            if open_par_count > max_open_par_count {\n              \
    \  max_open_par_count = open_par_count;\n            }\n        } else if c ==\
    \ ')' {\n            open_par_count -= 1;\n        } else if c == ' ' {\n    \
    \        output.push(max_open_par_count);\n            max_open_par_count = 0;\n\
    \            open_par_count = 0;\n        }\n    }\n    output.push(max_open_par_count);\n\
    \    output", "    let mut group_max_nesting = Vec::new();\n    for paren_group\
    \ in paren_string.split(\" \") {\n        let mut nesting_level = 0;\n       \
    \ let mut max_nesting = 0;\n        for paren in paren_group.chars() {\n     \
    \       if paren == '(' {\n                nesting_level += 1;\n            }\
    \ else if paren == ')' {\n                nesting_level -= 1;\n            }\n\
    \            if nesting_level > max_nesting {\n                max_nesting = nesting_level;\n\
    \            }\n        }\n        group_max_nesting.push(max_nesting);\n    }\n\
    \    group_max_nesting", "    let tokens: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut nest_levels: Vec<isize> = Vec::new();\n    for group in tokens {\n\
    \        let mut nest_level = 0;\n        let mut max_nest_level = 0;\n      \
    \  for ch in group.chars() {\n            if ch == '(' {\n                nest_level\
    \ += 1;\n            } else if ch == ')' {\n                nest_level -= 1;\n\
    \            }\n            if nest_level > max_nest_level {\n               \
    \ max_nest_level = nest_level;\n            }\n        }\n        nest_levels.push(max_nest_level);\n\
    \    }\n    nest_levels", "    let mut answers: Vec<isize> = Vec::new();\n   \
    \ let mut max_depth: isize = 0;\n    let mut depth: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n        } else if c ==\
    \ ')' {\n            depth -= 1;\n        } else if c == ' ' {\n            answers.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    answers.push(max_depth);\n\
    \    answers", "    let mut max_level: isize = 0;\n    let mut level: isize =\
    \ 0;\n    let mut paren_vec: Vec<isize> = Vec::new();\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            level += 1;\n            if level > max_level\
    \ {\n                max_level = level;\n            }\n        } else if ch ==\
    \ ')' {\n            level -= 1;\n        } else if ch == ' ' {\n            paren_vec.push(max_level);\n\
    \            max_level = 0;\n            level = 0;\n        }\n    }\n    paren_vec.push(max_level);\n\
    \    paren_vec", "    let mut result = Vec::new();\n    for paren_group in paren_string.split_whitespace()\
    \ {\n        let mut paren_stack = Vec::new();\n        let mut max_nested_depth\
    \ = 0;\n        for ch in paren_group.chars() {\n            match ch {\n    \
    \            '(' => {\n                    paren_stack.push(ch);\n           \
    \         max_nested_depth = max_nested_depth.max(paren_stack.len() as isize);\n\
    \                }\n                ')' => {\n                    if paren_stack.pop()\
    \ != Some('(') {\n                        panic!(\"Paren group is not balanced!\"\
    );\n                    }\n                }\n                _ => panic!(\"Invalid\
    \ parenthesis!\"),\n            }\n        }\n        if !paren_stack.is_empty()\
    \ {\n            panic!(\"Paren group is not balanced!\");\n        }\n      \
    \  result.push(max_nested_depth);\n    }\n    result", "    // Split the string\
    \ and then extract the deepest level of nesting for each group.\n    paren_string\n\
    \        .split_whitespace()\n        .map(|group| {\n            // Store the\
    \ maximum depth of nesting and the current depth as we traverse.\n           \
    \ let mut max_depth = 0;\n            let mut curr_depth = 0;\n\n            //\
    \ Keep track of the last symbol, which is a paren, and the current position in\
    \ the group.\n            let mut last_symbol = None;\n            let mut curr_pos\
    \ = 0;\n\n            while curr_pos < group.len() {\n                let c =\
    \ group.chars().nth(curr_pos).unwrap();\n\n                if c == '(' {\n   \
    \                 curr_depth += 1;\n                    if curr_depth > max_depth\
    \ {\n                        max_depth = curr_depth;\n                    }\n\
    \                } else if c == ')' {\n                    curr_depth -= 1;\n\
    \                }\n\n                curr_pos += 1;\n                last_symbol\
    \ = Some(c);\n            }\n\n            if last_symbol == Some('(') {\n   \
    \             // If last_symbol is a left paren, then we've encountered an unfinished\
    \ paren pair.\n                max_depth = -1;\n            }\n\n            max_depth\n\
    \        })\n        .collect()", "    paren_string\n        .split(\" \")\n \
    \       .map(|s| {\n            let mut count = 0;\n            let mut max_count\
    \ = 0;\n            for c in s.chars() {\n                if c == '(' {\n    \
    \                count += 1;\n                } else if c == ')' {\n         \
    \           count -= 1;\n                }\n                if count > max_count\
    \ {\n                    max_count = count;\n                }\n            }\n\
    \            max_count\n        })\n        .collect()", "    let mut result =\
    \ Vec::new();\n    let mut curr_level = 0;\n    let mut max_level = 0;\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            curr_level +=\
    \ 1;\n            if curr_level > max_level {\n                max_level = curr_level;\n\
    \            }\n        } else if c == ')' {\n            curr_level -= 1;\n \
    \       } else if c == ' ' {\n            result.push(max_level);\n          \
    \  curr_level = 0;\n            max_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result", "    let mut result = Vec::new();\n    for paren_set in paren_string.split_whitespace()\
    \ {\n        let mut max_count = 0;\n        let mut curr_count = 0;\n       \
    \ for c in paren_set.chars() {\n            if c == '(' {\n                curr_count\
    \ += 1;\n                if curr_count > max_count {\n                    max_count\
    \ = curr_count;\n                }\n            } else if c == ')' {\n       \
    \         curr_count -= 1;\n            }\n        }\n        result.push(max_count);\n\
    \    }\n    result", "    // let string = \"(()()) ((())) () ((())()())\";\n \
    \   let mut paren_groups: Vec<isize> = Vec::new();\n    for paren_group in paren_string.split(\"\
    \ \") {\n        let mut max_level = 0;\n        let mut paren_count = 0;\n  \
    \      for paren in paren_group.chars() {\n            if paren == '(' {\n   \
    \             paren_count += 1;\n                if paren_count > max_level {\n\
    \                    max_level = paren_count;\n                }\n           \
    \ } else if paren == ')' {\n                paren_count -= 1;\n            }\n\
    \        }\n        paren_groups.push(max_level);\n    }\n    paren_groups", " \
    \   let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        match paren {\n            '('\
    \ => {\n                depth += 1;\n                if depth > max_depth {\n\
    \                    max_depth = depth;\n                }\n            }\n  \
    \          ')' => {\n                depth -= 1;\n            }\n            '\
    \ ' => {\n                if max_depth > 0 {\n                    depths.push(max_depth);\n\
    \                    max_depth = 0;\n                }\n            }\n      \
    \      _ => {}\n        }\n    }\n    depths", "    // use a hashmap to keep track\
    \ of nested parens\n    let mut counts: HashMap<isize, isize> = HashMap::new();\n\
    \    let mut depths: Vec<isize> = Vec::new();\n    let mut depth = 0;\n    let\
    \ mut max_depth = 0;\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                // increase\
    \ count of current depth\n                *counts.entry(depth).or_insert(0) +=\
    \ 1;\n                if depth > max_depth {\n                    max_depth =\
    \ depth;\n                }\n            }\n            ')' => {\n           \
    \     // decrease count of current depth\n                *counts.entry(depth).or_insert(0)\
    \ -= 1;\n                depth -= 1;\n            }\n            _ => continue,\n\
    \        }\n    }\n    for depth in 1..=max_depth {\n        let count = *counts.get(&depth).unwrap();\n\
    \        // check if the counts at each depth are equal\n        if count == 0\
    \ {\n            depths.push(depth);\n        }\n    }\n    depths", "    let\
    \ mut group_starts = paren_string.split(\" \");\n    let mut nested_levels = Vec::new();\n\
    \    for start in group_starts {\n        let mut open_parens = 0;\n        let\
    \ mut max_open_parens = 0;\n        for paren in start.chars() {\n           \
    \ if paren == '(' {\n                open_parens += 1;\n                if open_parens\
    \ > max_open_parens {\n                    max_open_parens = open_parens;\n  \
    \              }\n            } else if paren == ')' {\n                open_parens\
    \ -= 1;\n            }\n        }\n        nested_levels.push(max_open_parens);\n\
    \    }\n    nested_levels", "    let mut result: Vec<isize> = Vec::new();\n  \
    \  let mut nested_parens: isize = 0;\n    let mut max_nested_parens: isize = 0;\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            nested_parens\
    \ += 1;\n            if nested_parens > max_nested_parens {\n                max_nested_parens\
    \ = nested_parens;\n            }\n        } else if c == ')' {\n            nested_parens\
    \ -= 1;\n        } else if c == ' ' {\n            result.push(max_nested_parens);\n\
    \            max_nested_parens = 0;\n            nested_parens = 0;\n        }\n\
    \    }\n    result.push(max_nested_parens);\n    result", "    let groups: Vec<&str>\
    \ = paren_string.split(\" \").collect();\n    groups.iter().map(|g| {\n      \
    \  let (nest_count, _) = count_nested_parens(g);\n        nest_count\n    }).collect()",
  "    let mut stack = Vec::new();\n    let mut max_nesting = 0;\n    let mut nested_parens\
    \ = Vec::new();\n    let mut paren_list = paren_string.split(\" \");\n    while\
    \ let Some(paren_string) = paren_list.next() {\n        let mut len = paren_string.len();\n\
    \        max_nesting = 0;\n        stack.clear();\n        for paren in paren_string.chars()\
    \ {\n            len -= 1;\n            match paren {\n                '(' =>\
    \ {\n                    max_nesting += 1;\n                    stack.push(paren);\n\
    \                }\n                ')' => {\n                    if len >= 1\
    \ && stack.pop().is_none() {\n                        max_nesting = 0;\n     \
    \                   break;\n                    }\n                }\n       \
    \         _ => continue,\n            }\n        }\n        nested_parens.push(max_nesting);\n\
    \    }\n    nested_parens", "    paren_string\n        .split(\" \")\n       \
    \ .map(|paren_group| {\n            let mut curr_nesting_level = 0;\n        \
    \    let mut max_nesting_level = 0;\n            for paren in paren_group.chars()\
    \ {\n                match paren {\n                    '(' => {\n           \
    \             curr_nesting_level += 1;\n                        if curr_nesting_level\
    \ > max_nesting_level {\n                            max_nesting_level = curr_nesting_level;\n\
    \                        }\n                    }\n                    ')' =>\
    \ {\n                        curr_nesting_level -= 1;\n                    }\n\
    \                    _ => panic!(\"Non paren character detected!\"),\n       \
    \         }\n            }\n            max_nesting_level\n        })\n      \
    \  .collect()", "    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ s.as_bytes())\n        .map(|s| {\n            let mut level = 0;\n        \
    \    let mut max_level = 0;\n            for c in s {\n                match c\
    \ {\n                    b'(' => level += 1,\n                    b')' => level\
    \ -= 1,\n                    _ => {}\n                }\n                max_level\
    \ = std::cmp::max(max_level, level);\n            }\n            max_level\n \
    \       })\n        .collect()", "    let mut result = Vec::new();\n    let mut\
    \ paren_string = paren_string.trim().to_string();\n    while !paren_string.is_empty()\
    \ {\n        let group = paren_string.split(' ').next().unwrap();\n        let\
    \ mut paren_count = 0;\n        let mut max_nesting = 0;\n        for c in group.chars()\
    \ {\n            if c == '(' {\n                paren_count += 1;\n          \
    \      if paren_count > max_nesting {\n                    max_nesting = paren_count;\n\
    \                }\n            } else if c == ')' {\n                paren_count\
    \ -= 1;\n            }\n        }\n        result.push(max_nesting);\n       \
    \ paren_string = paren_string.replacen(group, \"\", 1);\n        paren_string\
    \ = paren_string.trim().to_string();\n    }\n    result", "    let mut paren_stack:\
    \ Vec<isize> = Vec::new();\n    let mut res: Vec<isize> = Vec::new();\n    for\
    \ c in paren_string.chars() {\n        match c {\n            '(' => {\n     \
    \           paren_stack.push(0);\n            }\n            ')' => {\n      \
    \          let max_level = match paren_stack.last() {\n                    Some(x)\
    \ => x + 1,\n                    None => 1,\n                };\n            \
    \    res.push(max_level);\n                paren_stack.pop();\n              \
    \  paren_stack.push(max_level);\n            }\n            ' ' => {\n       \
    \         paren_stack.clear();\n            }\n            _ => continue,\n  \
    \      }\n    }\n    res", "    paren_string\n        .split_whitespace()\n  \
    \      .map(|paren_group| {\n            let mut depth = 0;\n            let mut\
    \ max_depth = 0;\n            for paren in paren_group.chars() {\n           \
    \     match paren {\n                    '(' => depth += 1,\n                \
    \    ')' => depth -= 1,\n                    _ => (),\n                }\n   \
    \             max_depth = max_depth.max(depth);\n            }\n            max_depth\n\
    \        })\n        .collect()", "    paren_string\n        .split_whitespace()\n\
    \        .map(|s| {\n            s.chars()\n                .fold(0, |max_nesting,\
    \ c| {\n                    match c {\n                        '(' => max_nesting\
    \ + 1,\n                        ')' => max_nesting - 1,\n                    \
    \    _ => max_nesting,\n                    }\n                })\n        })\n\
    \        .collect()", "    let mut paren_stack: Vec<isize> = Vec::new();\n   \
    \ let mut total_stack: Vec<isize> = Vec::new();\n    let mut nesting_level: isize\
    \ = 0;\n    let mut max_nesting_level: isize = 0;\n    let mut current_group:\
    \ String = String::new();\n    let mut current_group_completed: bool = false;\n\
    \    let mut current_group_started: bool = false;\n    let mut index: usize =\
    \ 0;\n    let mut error_message: String = String::new();\n    let mut results:\
    \ Vec<isize> = Vec::new();\n\n    while index < paren_string.len() {\n       \
    \ if paren_string.chars().nth(index).unwrap() == '(' {\n            paren_stack.push(paren_string.chars().nth(index).unwrap());\n\
    \            nesting_level += 1;\n            current_group.push(paren_string.chars().nth(index).unwrap());\n\
    \            current_group_started = true;\n        } else if paren_string.chars().nth(index).unwrap()\
    \ == ')' {\n            match paren_stack.pop() {\n                Some(_) =>\
    \ {\n                    nesting_level -= 1;\n                    current_group.push(paren_string.chars().nth(index).unwrap());\n\
    \                }\n                None => {\n                    error_message\
    \ = format!(\"Error: Found ')' without corresponding '(' at position {}\", index);\n\
    \                    break;\n                }\n            }\n        } else\
    \ if paren_string.chars().nth(index).unwrap() == ' ' {\n            if current_group_started\
    \ && current_group.len() == 0 {\n                error_message = format!(\"Error:\
    \ Empty group at position {}\", index);\n                break;\n            }\
    \ else if paren_stack.len() == 0 {\n                total_stack.push(paren_string.chars().nth(index).unwrap());\n\
    \                current_group_completed = true;\n            } else {\n     \
    \           error_message = format!(\"Error: One of the parenthesis group is not\
    \ closed. Position: {}\",", "    paren_string\n        .split_whitespace()\n \
    \       .map(|parens| {\n            let mut depth = 0;\n            let mut max_depth\
    \ = 0;\n            for c in parens.chars() {\n                if c == '(' {\n\
    \                    depth += 1;\n                } else if c == ')' {\n     \
    \               depth -= 1;\n                }\n                if depth > max_depth\
    \ {\n                    max_depth = depth;\n                }\n            }\n\
    \            max_depth\n        })\n        .collect()", "    let mut max_nesting\
    \ = 0;\n    let mut max_nesting_stack = vec![];\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' => {\n                max_nesting\
    \ += 1;\n                max_nesting_stack.push(max_nesting);\n            }\n\
    \            ')' => {\n                max_nesting_stack.push(max_nesting);\n\
    \                max_nesting -= 1;\n            }\n            _ => (),\n    \
    \    }\n    }\n    max_nesting_stack", "    let mut nested_parens: Vec<isize>\
    \ = Vec::new();\n    let mut start_pos: isize = 0;\n    let mut open_count: isize\
    \ = 0;\n    let mut max_open_count: isize = 0;\n    for i in 0..paren_string.len()\
    \ {\n        if paren_string.chars().nth(i).unwrap() == '(' {\n            open_count\
    \ += 1;\n            if open_count > max_open_count {\n                max_open_count\
    \ = open_count;\n            }\n        } else if paren_string.chars().nth(i).unwrap()\
    \ == ')' {\n            open_count -= 1;\n        }\n        if paren_string.chars().nth(i).unwrap()\
    \ == ' ' || i == paren_string.len() - 1 {\n            // A space indicates that\
    \ a group has ended\n            if open_count != 0 {\n                panic!(\"\
    ERROR: Mismatched parenthesis group found\");\n            }\n            nested_parens.push(max_open_count);\n\
    \            max_open_count = 0;\n            start_pos = i + 1;\n        }\n\
    \    }\n    return nested_parens;", "    let mut paren_vec: Vec<isize> = Vec::new();\n\
    \    let mut depth = 0;\n    let mut max_depth = 0;\n    let mut last_char: char\
    \ = '(';\n    for c in paren_string.chars() {\n        match c {\n           \
    \ '(' => {\n                depth += 1;\n                max_depth = cmp::max(max_depth,\
    \ depth);\n            }\n            ')' => {\n                depth -= 1;\n\
    \            }\n            ' ' => {\n                paren_vec.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => (),\n        }\n        last_char = c;\n    }\n    paren_vec.push(max_depth);\n\
    \    paren_vec", "    let mut stack = vec![];\n    let mut result = vec![];\n\
    \    let mut max_depth = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            stack.push(1);\n            max_depth += 1;\n        }\
    \ else if c == ')' {\n            max_depth -= 1;\n            stack.pop();\n\
    \        } else if c == ' ' {\n            result.push(max_depth);\n         \
    \   max_depth = 0;\n        }\n    }\n    result.push(max_depth);\n    result",
  "    let mut levels = Vec::new();\n    let mut stack = Vec::new();\n    let mut\
    \ open_count = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                stack.push(c);\n\
    \                open_count += 1;\n                max_level = if open_count >\
    \ max_level {\n                    open_count\n                } else {\n    \
    \                max_level\n                };\n            }\n            ')'\
    \ => {\n                let mut tmp_open_count = 0;\n                while let\
    \ Some(x) = stack.pop() {\n                    if x == '(' {\n               \
    \         break;\n                    } else {\n                        tmp_open_count\
    \ += 1;\n                    }\n                }\n                open_count\
    \ -= tmp_open_count + 1;\n            }\n            ' ' => {\n              \
    \  levels.push(max_level);\n                max_level = 0;\n            }\n  \
    \          _ => {}\n        }\n    }\n    levels", "    // count number of parens\
    \ and match\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut paren_count\
    \ = 0;\n    let mut depths = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                depth += 1;\n      \
    \          paren_count += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n                paren_count += 1;\n\
    \            }\n            ' ' => {\n                if paren_count > 0 {\n \
    \                   // encountered a new group\n                    depths.push(max_depth);\n\
    \                    max_depth = 0;\n                    depth = 0;\n        \
    \            paren_count = 0;\n                }\n            }\n            _\
    \ => {\n                panic!(\"unexpected character in paren string {}\", c);\n\
    \            }\n        }\n    }\n    depths.push(max_depth);\n    depths", " \
    \   paren_string\n        .split(\" \")\n        .map(|paren_group| {\n      \
    \      let mut nesting_level = 0;\n            let mut max_nesting_level = 0;\n\
    \            for paren in paren_group.chars() {\n                if paren == '('\
    \ {\n                    nesting_level += 1;\n                } else if paren\
    \ == ')' {\n                    nesting_level -= 1;\n                }\n     \
    \           if nesting_level > max_nesting_level {\n                    max_nesting_level\
    \ = nesting_level;\n                }\n            }\n            max_nesting_level\n\
    \        })\n        .collect()", "    let mut count = 0;\n    let mut max_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let paren_string =\
    \ paren_string.as_str();\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                count += 1;\n                if count\
    \ > max_nesting_level {\n                    max_nesting_level = count;\n    \
    \            }\n            }\n            ')' => {\n                count -=\
    \ 1;\n            }\n            ' ' => {\n                paren_nesting_levels.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                count = 0;\n        \
    \    }\n            _ => continue,\n        }\n    }\n    paren_nesting_levels.push(max_nesting_level);\n\
    \    paren_nesting_levels", "    paren_string\n        .split_whitespace()\n \
    \       .map(|s| {\n            let mut current_depth = 0;\n            let mut\
    \ max_depth = 0;\n            for c in s.chars() {\n                match c {\n\
    \                    '(' => {\n                        current_depth += 1;\n \
    \                       if current_depth > max_depth {\n                     \
    \       max_depth = current_depth;\n                        }\n              \
    \      }\n                    ')' => {\n                        current_depth\
    \ -= 1;\n                    }\n                    _ => unreachable!(),\n   \
    \             }\n            }\n            max_depth\n        })\n        .collect()",
  "    let mut paren_stack: Vec<isize> = Vec::new();\n    let mut max_level: Vec<isize>\
    \ = Vec::new();\n    let mut level: isize = 0;\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    for ch in chars {\n        if ch == '(' {\n            level += 1;\n    \
    \        paren_stack.push(level);\n        } else if ch == ')' {\n           \
    \ let top_of_stack = paren_stack.pop().unwrap();\n            level = top_of_stack\
    \ - 1;\n        } else if ch == ' ' {\n            max_level.push(*paren_stack.iter().max().unwrap());\n\
    \        }\n    }\n    return max_level;", "    // Keep count of open/close parens.\n\
    \    let mut open_parens = 0;\n    let mut max_nested_levels = 0;\n    let mut\
    \ output = Vec::new();\n\n    for character in paren_string.chars() {\n      \
    \  match character {\n            '(' => {\n                open_parens += 1;\n\
    \                if open_parens > max_nested_levels {\n                    max_nested_levels\
    \ = open_parens;\n                }\n            }\n            ')' => {\n   \
    \             open_parens -= 1;\n            }\n            ' ' => {\n       \
    \         // Space found, store results and reset open_parens and max_nested_levels.\n\
    \                output.push(max_nested_levels);\n                open_parens\
    \ = 0;\n                max_nested_levels = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    output", "    let mut paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut depths: Vec<isize> = Vec::new();\n    let mut depth: isize = 0;\n\
    \    let mut max_depth: isize = 0;\n    for group in paren_groups {\n        for\
    \ char in group.chars() {\n            match char {\n                '(' => depth\
    \ += 1,\n                ')' => depth -= 1,\n                _ => (),\n      \
    \      }\n            if depth > max_depth {\n                max_depth = depth;\n\
    \            }\n        }\n        depths.push(max_depth);\n        depth = 0;\n\
    \        max_depth = 0;\n    }\n    depths", "    let mut max_depth: isize = 0;\n\
    \    let mut depth: isize = 0;\n    let mut result: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                if depth == 0 {\n                    result.push(max_depth);\n\
    \                    max_depth = 0;\n                }\n            }\n      \
    \      _ => (),\n        }\n    }\n    result.push(max_depth);\n    result", " \
    \   let mut paren_vec: Vec<char> = Vec::new();\n    let mut count: isize = 0;\n\
    \    let mut max_depth: isize = 0;\n    let mut depth_vec: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == ' ' {\n            depth_vec.push(max_depth);\n\
    \            max_depth = 0;\n            count = 0;\n            continue;\n \
    \       }\n        paren_vec.push(c);\n        if c == '(' {\n            count\
    \ += 1;\n            if count > max_depth {\n                max_depth = count;\n\
    \            }\n        } else if c == ')' {\n            count -= 1;\n      \
    \  }\n    }\n    depth_vec.push(max_depth);\n    depth_vec", "    let mut lv =\
    \ Vec::new();\n    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_nesting += 1;\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                current_nesting -= 1;\n \
    \           }\n            ' ' => {\n                lv.push(max_nesting);\n \
    \               max_nesting = 0;\n                current_nesting = 0;\n     \
    \       }\n            _ => {}\n        }\n    }\n    lv.push(max_nesting);\n\
    \    lv", "    paren_string\n        .split(\" \")\n        .map(|i| find_max_depth(i.to_string()))\n\
    \        .collect()", "    let mut output = Vec::new();\n    for paren_group in\
    \ paren_string.split(\" \") {\n        let mut max_level = 0;\n        let mut\
    \ curr_level = 0;\n        for char in paren_group.chars() {\n            if char\
    \ == '(' {\n                curr_level += 1;\n            } else if char == ')'\
    \ {\n                curr_level -= 1;\n            }\n            if curr_level\
    \ > max_level {\n                max_level = curr_level;\n            }\n    \
    \    }\n        output.push(max_level);\n    }\n    output", "    paren_string\n\
    \        .split_whitespace()\n        .map(|g| count_deepest_nested_parens(g))\n\
    \        .collect()", "    let mut paren_string = paren_string;\n    let mut paren_vector:\
    \ Vec<isize> = Vec::new();\n    while !paren_string.is_empty() {\n        let\
    \ space_ind = paren_string.find(' ').unwrap_or(paren_string.len());\n        let\
    \ paren_group = paren_string.get(0..space_ind).unwrap();\n        let paren_group_len\
    \ = paren_group.len();\n        let mut paren_count = 0;\n        let mut paren_max\
    \ = 0;\n        for paren in paren_group.chars() {\n            if paren == '('\
    \ {\n                paren_count += 1;\n            } else if paren == ')' {\n\
    \                paren_count -= 1;\n            }\n            if paren_count\
    \ > paren_max {\n                paren_max = paren_count;\n            }\n   \
    \     }\n        paren_vector.push(paren_max);\n        if space_ind < paren_group_len\
    \ {\n            paren_string = paren_string.get(space_ind + 1..).unwrap().to_string();\n\
    \        } else {\n            paren_string = String::new();\n        }\n    }\n\
    \    paren_vector", "    let mut output: Vec<isize> = Vec::new();\n    let mut\
    \ current_level: isize = 0;\n    let mut max_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             output.push(max_level);\n                max_level = 0;\n      \
    \          current_level = 0;\n            }\n            _ => continue,\n   \
    \     }\n    }\n    output.push(max_level);\n    output", "    let mut result\
    \ = Vec::new();\n    let mut paren_balancer = 0;\n    let mut inner_paren_balancer\
    \ = 0;\n    let mut max_balancer = 0;\n    let mut max_inner_balancer = 0;\n \
    \   for c in paren_string.chars() {\n        if c == '(' {\n            paren_balancer\
    \ += 1;\n            inner_paren_balancer += 1;\n            if max_balancer <\
    \ paren_balancer {\n                max_balancer = paren_balancer;\n         \
    \   }\n            if max_inner_balancer < inner_paren_balancer {\n          \
    \      max_inner_balancer = inner_paren_balancer;\n            }\n        } else\
    \ if c == ')' {\n            paren_balancer -= 1;\n            inner_paren_balancer\
    \ -= 1;\n        } else if c == ' ' {\n            result.push(max_inner_balancer);\n\
    \            max_inner_balancer = 0;\n            inner_paren_balancer = 0;\n\
    \        }\n    }\n    if max_inner_balancer > 0 {\n        result.push(max_inner_balancer);\n\
    \    }\n    result", "    let mut max_nesting_levels = Vec::new();\n    let mut\
    \ nesting_level = 0;\n    let mut max_seen = 0;\n    let mut iter = paren_string.chars();\n\
    \    while let Some(c) = iter.next() {\n        match c {\n            '(' =>\
    \ {\n                nesting_level += 1;\n                if nesting_level > max_seen\
    \ {\n                    max_seen = nesting_level;\n                }\n      \
    \      }\n            ')' => {\n                nesting_level -= 1;\n        \
    \    }\n            ' ' => {\n                if nesting_level == 0 {\n      \
    \              max_nesting_levels.push(max_seen);\n                    max_seen\
    \ = 0;\n                }\n            }\n            _ => {}\n        }\n   \
    \ }\n    max_nesting_levels.push(max_seen);\n    max_nesting_levels", "    let\
    \ mut level = 0;\n    let mut result = Vec::new();\n    let mut max_level = 0;\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            level\
    \ += 1;\n            max_level = if level > max_level { level } else { max_level\
    \ };\n        } else if c == ')' {\n            level -= 1;\n        } else if\
    \ c == ' ' {\n            result.push(max_level);\n            max_level = 0;\n\
    \            level = 0;\n        }\n    }\n    if level == 0 {\n        result.push(max_level);\n\
    \    }\n    result", "    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ count_parens(s.to_string()))\n        .collect()", "    let mut paren_stack:\
    \ Vec<(char, isize)> = Vec::new();\n    let mut group_nesting: Vec<isize> = Vec::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_stack.push((c, paren_count));\n            paren_count\
    \ += 1;\n        } else if c == ')' {\n            let (_, level) = paren_stack.pop().unwrap();\n\
    \            group_nesting.push(paren_count - level);\n        }\n    }\n    group_nesting",
  "    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut max_level: isize =\
    \ 0;\n    let mut curr_level: isize = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            curr_level += 1;\n            if curr_level\
    \ > max_level {\n                max_level = curr_level;\n            }\n    \
    \    } else if c == ')' {\n            curr_level -= 1;\n        } else if c ==\
    \ ' ' {\n            paren_vec.push(max_level);\n            max_level = 0;\n\
    \            curr_level = 0;\n        }\n    }\n    paren_vec.push(max_level);\n\
    \    paren_vec", "    let mut max_level = 0;\n    let mut levels = vec![];\n \
    \   let mut level = 0;\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                level += 1;\n                if level >\
    \ max_level {\n                    max_level = level;\n                }\n   \
    \         }\n            ')' => {\n                level -= 1;\n            }\n\
    \            ' ' => {\n                levels.push(max_level);\n             \
    \   max_level = 0;\n                level = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    levels.push(max_level);\n    levels", "    paren_string\n\
    \        .split_whitespace()\n        .map(|s| {\n            // (()()) - 2\n\
    \            // ((())) - 3\n            // (()(()())) - 4\n            let mut\
    \ max_nesting = 0;\n            let mut curr_nesting = 0;\n            for ch\
    \ in s.chars() {\n                match ch {\n                    '(' => {\n \
    \                       curr_nesting += 1;\n                        if curr_nesting\
    \ > max_nesting {\n                            max_nesting = curr_nesting;\n \
    \                       }\n                    }\n                    ')' => {\n\
    \                        curr_nesting -= 1;\n                    }\n         \
    \           _ => {\n                        return None;\n                   \
    \ }\n                }\n            }\n            Some(max_nesting)\n       \
    \ })\n        .filter_map(|option| option)\n        .collect()", "    let mut\
    \ max_nested = 0;\n    let mut curr_nested = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    let mut open_parens = 0;\n    let mut close_parens = 0;\n\
    \    let mut level_one_open = 0;\n    let mut level_one_close = 0;\n    for c\
    \ in paren_string.chars() {\n        match c {\n            '(' => {\n       \
    \         open_parens += 1;\n                curr_nested += 1;\n             \
    \   if curr_nested > max_nested {\n                    max_nested = curr_nested;\n\
    \                }\n                if level_one_open == 0 {\n               \
    \     level_one_open = curr_nested;\n                }\n            }\n      \
    \      ')' => {\n                close_parens += 1;\n                curr_nested\
    \ -= 1;\n                if curr_nested == 0 {\n                    result.push(max_nested);\n\
    \                    level_one_close = 0;\n                    level_one_open\
    \ = 0;\n                    max_nested = 0;\n                }\n            }\n\
    \            ' ' => {\n                // End of line\n                if curr_nested\
    \ != 0 {\n                    result.push(max_nested);\n                    level_one_close\
    \ = 0;\n                    level_one_open = 0;\n                    max_nested\
    \ = 0;\n                }\n                open_parens = 0;\n                close_parens\
    \ = 0;\n            }\n            _ => {\n                // Nothing should be\
    \ here\n            }\n        }\n    }\n    // Last line\n    if curr_nested\
    \ != 0 {\n        result.push(max_nested);\n    }\n    if open_parens != close_parens\
    \ {\n        result.push(0);\n    }\n    result", "    // split string into groups\n\
    \    let paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    // count the maximum nesting level for each group\n    let mut res = Vec::new();\n\
    \    for paren_group in paren_groups {\n        let mut nest_level = 0;\n    \
    \    let mut max_nest_level = 0;\n        for paren in paren_group.chars() {\n\
    \            match paren {\n                '(' => nest_level += 1,\n        \
    \        ')' => nest_level -= 1,\n                _ => (),\n            }\n  \
    \          if nest_level > max_nest_level {\n                max_nest_level =\
    \ nest_level;\n            }\n        }\n        res.push(max_nest_level);\n \
    \   }\n    res", "    let mut result: Vec<isize> = Vec::new();\n    let mut curr_max:\
    \ isize = 0;\n    let mut curr_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            curr_level += 1;\n            if curr_level\
    \ > curr_max {\n                curr_max = curr_level;\n            }\n      \
    \  } else if c == ')' {\n            curr_level -= 1;\n        } else if c ==\
    \ ' ' {\n            result.push(curr_max);\n            curr_max = 0;\n     \
    \       curr_level = 0;\n        }\n    }\n    result.push(curr_max);\n    result",
  "    let mut vec: Vec<isize> = Vec::new();\n    for paren_group in paren_string.split_whitespace()\
    \ {\n        vec.push(parse_single_paren_group(paren_group));\n    }\n    vec",
  "    let mut results = Vec::new();\n    for group in paren_string.split(\" \") {\n\
    \        let mut count = 0;\n        let mut max_count = 0;\n        for ch in\
    \ group.chars() {\n            if ch == '(' {\n                count += 1;\n \
    \           } else if ch == ')' {\n                count -= 1;\n            }\n\
    \            if count > max_count {\n                max_count = count;\n    \
    \        }\n        }\n        results.push(max_count);\n    }\n    results",
  "    let mut result = Vec::new();\n    for group in paren_string.split(\" \") {\n\
    \        let mut curr_max = 0;\n        let mut curr_level = 0;\n        for paren\
    \ in group.chars() {\n            match paren {\n                '(' => curr_level\
    \ += 1,\n                ')' => curr_level -= 1,\n                _ => (),\n \
    \           }\n            if curr_level > curr_max {\n                curr_max\
    \ = curr_level;\n            }\n        }\n        result.push(curr_max);\n  \
    \  }\n    result", "    let mut outer_max = 0;\n    let mut depth = 0;\n    let\
    \ mut res = Vec::new();\n    let chars = paren_string.chars();\n    for ch in\
    \ chars {\n        if ch == '(' {\n            depth += 1;\n            if depth\
    \ > outer_max {\n                outer_max = depth;\n            }\n        }\
    \ else if ch == ')' {\n            depth -= 1;\n        } else if ch == ' ' {\n\
    \            if depth > 0 {\n                println!(\"ERROR: input string is\
    \ not valid\");\n                return Vec::new();\n            }\n         \
    \   res.push(outer_max);\n            outer_max = 0;\n        }\n    }\n    //\
    \ Add the last group.\n    res.push(outer_max);\n    res", "    let groups: Vec<&str>\
    \ = paren_string.split(\" \").collect();\n    let mut deepest_nestings: Vec<isize>\
    \ = Vec::new();\n    for group in groups {\n        // Special case for just empty\
    \ parentheses ()\n        if group.len() == 2 {\n            deepest_nestings.push(1);\n\
    \            continue;\n        }\n        let mut current_nesting: isize = 0;\n\
    \        let mut max_nesting: isize = 0;\n        for char in group.chars() {\n\
    \            if char == '(' {\n                current_nesting += 1;\n       \
    \     } else if char == ')' {\n                current_nesting -= 1;\n       \
    \     }\n            if current_nesting > max_nesting {\n                max_nesting\
    \ = current_nesting;\n            }\n        }\n        deepest_nestings.push(max_nesting);\n\
    \    }\n    deepest_nestings", "    let mut paren_vec: Vec<isize> = Vec::new();\n\
    \    let mut split_iter = paren_string.split(\" \");\n    loop {\n        match\
    \ split_iter.next() {\n            Some(substring) => {\n                let mut\
    \ depth: isize = 0;\n                let mut max_depth: isize = 0;\n         \
    \       for c in substring.chars() {\n                    if c == '(' {\n    \
    \                    depth += 1;\n                    } else if c == ')' {\n \
    \                       depth -= 1;\n                    }\n                 \
    \   if depth > max_depth {\n                        max_depth = depth;\n     \
    \               }\n                }\n                paren_vec.push(max_depth);\n\
    \            }\n            None => break,\n        }\n    }\n    paren_vec",
  "    let mut results = Vec::new();\n    let mut open_parens = 0;\n    let mut max_nesting\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   open_parens += 1;\n            max_nesting = max(max_nesting, open_parens);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n        } else if\
    \ c == ' ' {\n            results.push(max_nesting);\n            max_nesting\
    \ = 0;\n            open_parens = 0;\n        }\n    }\n    results.push(max_nesting);\n\
    \    results", "    let mut paren_levels = Vec::new();\n    let mut count: isize\
    \ = 0;\n    let mut max_count: isize = 0;\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                count += 1;\n      \
    \          if count > max_count {\n                    max_count = count;\n  \
    \              }\n            }\n            ')' => {\n                count -=\
    \ 1;\n            }\n            ' ' => {\n                paren_levels.push(max_count);\n\
    \                max_count = 0;\n                count = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    paren_levels.push(max_count);\n   \
    \ paren_levels", "    let mut result = Vec::new();\n    let mut paren_vec: Vec<char>\
    \ = paren_string.chars().collect();\n    let mut paren_stack: Vec<char> = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut paren_level_max = 0;\n    let mut paren_end\
    \ = false;\n    for paren in paren_vec {\n        if paren_end {\n           \
    \ paren_level_max = cmp::max(paren_level_max, paren_level);\n            result.push(paren_level_max);\n\
    \            paren_level = 0;\n            paren_level_max = 0;\n            paren_end\
    \ = false;\n        }\n        if paren == '(' {\n            paren_stack.push(paren);\n\
    \            paren_level += 1;\n        } else if paren == ')' {\n           \
    \ if paren_stack.len() > 0 {\n                paren_stack.pop();\n           \
    \     paren_level -= 1;\n            } else {\n                // issue: found\
    \ ) without open (\n                println!(\"(()()) parse error!\");\n     \
    \       }\n        } else if paren == ' ' {\n            if paren_stack.len()\
    \ == 0 {\n                paren_end = true;\n            }\n        }\n    }\n\
    \    if paren_end == false {\n        paren_level_max = cmp::max(paren_level_max,\
    \ paren_level);\n        result.push(paren_level_max);\n    }\n    println!(\"\
    paren_level_max: {:?}\", result);\n    result", "    let mut paren_count: isize\
    \ = 0;\n    let mut max_count: isize = 0;\n    let mut paren_counts: Vec<isize>\
    \ = Vec::new();\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            paren_count += 1;\n            if paren_count > max_count {\n   \
    \             max_count = paren_count;\n            }\n        } else if c ==\
    \ ')' {\n            paren_count -= 1;\n        } else if c == ' ' {\n       \
    \     paren_counts.push(max_count);\n            max_count = 0;\n            paren_count\
    \ = 0;\n        }\n    }\n    paren_counts.push(max_count);\n    paren_counts",
  "    let mut v = Vec::new();\n    let mut stack = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut deepest_level = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            current_level += 1;\n            stack.push(c);\n\
    \        } else if c == ')' {\n            current_level -= 1;\n            stack.pop();\n\
    \        } else if c == ' ' {\n            if current_level > deepest_level {\n\
    \                deepest_level = current_level;\n            }\n            v.push(deepest_level);\n\
    \            current_level = 0;\n            deepest_level = 0;\n        }\n \
    \   }\n    v", "    let mut stack: Vec<isize> = Vec::new();\n    let mut max_depth:\
    \ Vec<isize> = Vec::new();\n    let mut max_so_far: isize = 0;\n    let mut current_depth:\
    \ isize = 0;\n    let paren_string = paren_string.replace(\" \", \"\");\n\n  \
    \  for c in paren_string.chars() {\n        if c == '(' {\n            current_depth\
    \ += 1;\n            max_so_far = max(max_so_far, current_depth);\n          \
    \  stack.push(current_depth);\n        } else if c == ')' {\n            if stack.pop().is_some()\
    \ {\n                current_depth -= 1;\n            }\n        }\n    }\n\n\
    \    for depth in stack {\n        max_depth.push(max_so_far);\n    }\n\n    return\
    \ max_depth;", "    let mut res: Vec<isize> = Vec::new();\n    let mut nested_count:\
    \ isize = 0;\n    let mut max_count: isize = 0;\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            nested_count += 1;\n            if nested_count\
    \ > max_count {\n                max_count = nested_count;\n            }\n  \
    \      } else if ch == ')' {\n            nested_count -= 1;\n        } else if\
    \ ch == ' ' {\n            res.push(max_count);\n            max_count = 0;\n\
    \            nested_count = 0;\n        }\n    }\n    res.push(max_count);\n \
    \   res", "    let mut paren_group = paren_string.split_whitespace();\n    let\
    \ mut output: Vec<isize> = Vec::new();\n    while let Some(ref group) = paren_group.next()\
    \ {\n        output.push(find_max_nesting_in_group(group.to_string()));\n    }\n\
    \    output", "    let mut vec: Vec<isize> = Vec::new();\n    let mut max_level:\
    \ isize = 0;\n    let mut current_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            vec.push(max_level);\n            max_level = 0;\n\
    \            current_level = 0;\n        }\n    }\n    if max_level > 0 {\n  \
    \      vec.push(max_level);\n    }\n    vec", "    paren_string\n        .split_whitespace()\n\
    \        .map(|s| count_nested_parens(s))\n        .collect()", "    let mut parser\
    \ = Parser::new();\n    let parsed_parens = paren_string.split(\" \").map(|p|\
    \ p.trim()).collect::<Vec<&str>>();\n    let mut res = Vec::new();\n    for paren\
    \ in parsed_parens {\n        res.push(parser.parse_parens(paren));\n    }\n \
    \   res", "    let mut stack: Vec<isize> = Vec::new();\n    let mut max_level:\
    \ isize = 0;\n    let mut paren_levels: Vec<isize> = Vec::new();\n    for ch in\
    \ paren_string.chars() {\n        if ch == '(' {\n            stack.push(max_level);\n\
    \            max_level += 1;\n        } else if ch == ')' {\n            let top\
    \ = stack.pop().unwrap();\n            if max_level > top + 1 {\n            \
    \    paren_levels.push(max_level - 1);\n            }\n            max_level =\
    \ top;\n        }\n    }\n    paren_levels", "    paren_string\n        .split_whitespace()\n\
    \        .map(|s| {\n            let mut depth = 0;\n            let mut max_depth\
    \ = 0;\n            for c in s.chars() {\n                if c == '(' {\n    \
    \                depth += 1;\n                } else if c == ')' {\n         \
    \           depth -= 1;\n                } else {\n                    panic!(\"\
    Unexpected character!\");\n                }\n                max_depth = std::cmp::max(max_depth,\
    \ depth);\n            }\n            max_depth\n        })\n        .collect()",
  "    // let paren_string = String::from(\"(()()) ((())) () ((())()())\");\n    let\
    \ mut answer: Vec<isize> = Vec::new();\n    let mut stack: Vec<char> = Vec::new();\n\
    \    let mut curr_max = 0;\n    let mut seen_space = false;\n    let mut seen_one_paren\
    \ = false;\n    for c in paren_string.chars() {\n        if c == ' ' {\n     \
    \       // Found a space - new token.\n            // Check if the stack is empty\
    \ to handle case like \" () () \".\n            if !stack.is_empty() {\n     \
    \           answer.push(curr_max);\n                curr_max = 0;\n          \
    \  }\n            seen_space = true;\n            seen_one_paren = false;\n  \
    \      } else if c == '(' {\n            // Found an opening paren.\n        \
    \    // If we already saw a space before this, we have a new token.\n        \
    \    if seen_space {\n                answer.push(curr_max);\n               \
    \ curr_max = 0;\n            }\n            stack.push(c);\n            curr_max\
    \ += 1;\n            seen_space = false;\n            seen_one_paren = true;\n\
    \        } else if c == ')' {\n            // Found a closing paren.\n       \
    \     // First remove the previous \"(\" from the stack.\n            if stack.is_empty()\
    \ {\n                // println!(\"Malformed input, returning...\");\n       \
    \         return Vec::new();\n            }\n            stack.pop();\n      \
    \      seen_space = false;\n            seen_one_paren = true;\n        } else\
    \ {\n            // Found a non-paren character.\n            // println!(\"Found\
    \ non-paren character, returning...\");\n            return Vec::new();\n    \
    \    }\n    }\n    // If we saw a closing paren, there's a case where we want\
    \ to update the answer.\n    if seen_one_paren {\n        answer.push(curr_max);\n\
    \    }\n    answer", "    let mut result: Vec<isize> = Vec::new();\n    let mut\
    \ max_level: isize = 0;\n    let mut current_level: isize = 0;\n    for (i, c)\
    \ in paren_string.chars().enumerate() {\n        match c {\n            '(' =>\
    \ {\n                current_level += 1;\n                if current_level > max_level\
    \ {\n                    max_level = current_level;\n                }\n     \
    \       }\n            ')' => {\n                current_level -= 1;\n       \
    \     }\n            ' ' => {\n                if i == paren_string.len() - 1\
    \ {\n                    result.push(max_level);\n                } else {\n \
    \                   result.push(max_level);\n                    max_level = 0;\n\
    \                    current_level = 0;\n                }\n            }\n  \
    \          _ => panic!(\"Unexpected character: {}\", c),\n        }\n    }\n \
    \   result", "    let mut result = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        let mut max_nested_level = 0;\n        let mut curr_nested_level\
    \ = 0;\n        for c in group.chars() {\n            if c == '(' {\n        \
    \        curr_nested_level += 1;\n            } else if c == ')' {\n         \
    \       curr_nested_level -= 1;\n            }\n            if curr_nested_level\
    \ > max_nested_level {\n                max_nested_level = curr_nested_level;\n\
    \            }\n        }\n        result.push(max_nested_level);\n    }\n   \
    \ result", "    paren_string\n        .split_whitespace()\n        .map(|s| {\n\
    \            let mut open_count = 0;\n            let mut max_open_count = 0;\n\
    \            for paren in s.chars() {\n                match paren {\n       \
    \             '(' => {\n                        open_count += 1;\n           \
    \             if open_count > max_open_count {\n                            max_open_count\
    \ = open_count;\n                        }\n                    }\n          \
    \          ')' => {\n                        open_count -= 1;\n              \
    \      }\n                    _ => {}\n                }\n            }\n    \
    \        max_open_count\n        })\n        .collect()", "    let mut res: Vec<isize>\
    \ = Vec::new();\n    for s in paren_string.split_whitespace() {\n        let mut\
    \ count = 0;\n        let mut cur_max = 0;\n        for c in s.chars() {\n   \
    \         if c == '(' {\n                count += 1;\n            } else if c\
    \ == ')' {\n                count -= 1;\n            }\n            cur_max =\
    \ cur_max.max(count);\n        }\n        res.push(cur_max);\n    }\n    res",
  "    let mut paren_stack: Vec<char> = Vec::new();\n    let mut max_nesting: isize\
    \ = 0;\n    let mut levels: Vec<isize> = Vec::new();\n    for paren in paren_string.chars()\
    \ {\n        if paren == ' ' {\n            levels.push(max_nesting);\n      \
    \      max_nesting = 0;\n            paren_stack.clear();\n        } else if paren\
    \ == '(' {\n            paren_stack.push(paren);\n            if paren_stack.len()\
    \ as isize > max_nesting {\n                max_nesting = paren_stack.len() as\
    \ isize;\n            }\n        } else if paren == ')' {\n            paren_stack.pop();\n\
    \        }\n    }\n    levels.push(max_nesting);\n    levels", "    paren_string\n\
    \        .split_whitespace()\n        .map(|s| {\n            let mut cnt = 0;\n\
    \            let mut max_cnt = 0;\n            for c in s.chars() {\n        \
    \        if c == '(' {\n                    cnt += 1;\n                } else\
    \ if c == ')' {\n                    cnt -= 1;\n                }\n          \
    \      max_cnt = isize::max(max_cnt, cnt);\n            }\n            max_cnt\n\
    \        })\n        .collect()", "    paren_string\n        .split_whitespace()\n\
    \        .map(|s| {\n            s.chars()\n                .fold(0, |acc, c|\
    \ match c {\n                    '(' => acc + 1,\n                    ')' => acc\
    \ - 1,\n                    _ => acc,\n                })\n        })\n      \
    \  .collect()", "    paren_string\n        .split_whitespace()\n        .map(|p|\
    \ {\n            let mut max_nesting = 0;\n            let mut curr_nesting =\
    \ 0;\n            for c in p.chars() {\n                if c == '(' {\n      \
    \              curr_nesting += 1;\n                    if curr_nesting > max_nesting\
    \ {\n                        max_nesting = curr_nesting;\n                   \
    \ }\n                } else if c == ')' {\n                    curr_nesting -=\
    \ 1;\n                }\n            }\n            max_nesting\n        })\n\
    \        .collect()", "    let paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut result = Vec::new();\n    for group in paren_groups {\n        let\
    \ mut curr_level = 0;\n        let mut max_level = 0;\n        for paren in group.chars()\
    \ {\n            if paren == '(' {\n                curr_level += 1;\n       \
    \     } else if paren == ')' {\n                curr_level -= 1;\n           \
    \ }\n            if curr_level > max_level {\n                max_level = curr_level;\n\
    \            }\n        }\n        result.push(max_level);\n    }\n    result",
  "    paren_string\n        .split_whitespace()\n        .map(|s| get_max_nested_level(s.chars()))\n\
    \        .collect()", "    // parse from string to vectors:\n    let paren_groups\
    \ = parse_paren_groups(paren_string);\n    // for each group, count its maximum\
    \ nesting:\n    paren_groups.iter().map(count_max_nesting).collect()", "    //vec![1,\
    \ 2, 3, 4]\n    let mut max_levels = Vec::new();\n    let mut level = 0;\n   \
    \ let mut max_level = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' {\n            level += 1;\n            if level > max_level {\n       \
    \         max_level = level;\n            }\n        } else if c == ')' {\n  \
    \          level -= 1;\n        } else if c == ' ' {\n            max_levels.push(max_level);\n\
    \            max_level = 0;\n            level = 0;\n        }\n    }\n    max_levels.push(max_level);\n\
    \    max_levels", "    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            let mut is_open_paren = false;\n            let mut max_depth\
    \ = 0;\n            let mut current_depth = 0;\n            for ch in group.chars()\
    \ {\n                match ch {\n                    '(' => {\n              \
    \          if is_open_paren {\n                            current_depth += 1;\n\
    \                        }\n                        is_open_paren = true;\n  \
    \                  }\n                    ')' => {\n                        is_open_paren\
    \ = false;\n                        if current_depth > max_depth {\n         \
    \                   max_depth = current_depth;\n                        }\n  \
    \                      current_depth -= 1;\n                    }\n          \
    \          _ => (),\n                }\n            }\n            max_depth\n\
    \        })\n        .collect()", "    let mut results = Vec::new();\n    let\
    \ groups: Vec<&str> = paren_string.split(\" \").collect();\n    for group in groups\
    \ {\n        let mut current_count = 0;\n        let mut max_count = 0;\n    \
    \    for c in group.chars() {\n            if c == '(' {\n                current_count\
    \ += 1;\n            } else if c == ')' {\n                current_count -= 1;\n\
    \            }\n            if current_count > max_count {\n                max_count\
    \ = current_count;\n            }\n        }\n        results.push(max_count);\n\
    \    }\n    results", "    let mut result = Vec::new();\n    let mut paren_stack\
    \ = Vec::new();\n    for (i, ch) in paren_string.chars().enumerate() {\n     \
    \   match ch {\n            '(' => {\n                if paren_stack.is_empty()\
    \ {\n                    paren_stack.push(0);\n                } else {\n    \
    \                paren_stack.push(paren_stack.last().unwrap() + 1);\n        \
    \        }\n            }\n            ')' => {\n                if i + 1 == paren_string.len()\
    \ || paren_string.chars().nth(i + 1).unwrap() == ' ' {\n                    let\
    \ depth = paren_stack.pop().unwrap();\n                    result.push(depth);\n\
    \                } else {\n                    let depth = paren_stack.pop().unwrap();\n\
    \                    paren_stack.push(depth - 1);\n                }\n       \
    \     }\n            _ => continue,\n        }\n    }\n    result", "    // TODO:\
    \ parse the string and return a vector of integers showing deepest level\n   \
    \ // of nesting of parentheses\n    let mut result: Vec<isize> = Vec::new();\n\
    \    let mut temp: Vec<char> = Vec::new();\n    let mut max: isize = 0;\n    let\
    \ mut count: isize = 0;\n    for ch in paren_string.chars() {\n        match ch\
    \ {\n            '(' => {\n                count += 1;\n                temp.push(ch);\n\
    \            }\n            ')' => {\n                temp.push(ch);\n       \
    \         count -= 1;\n            }\n            ' ' => {\n                result.push(max);\n\
    \                max = 0;\n                count = 0;\n                temp.clear();\n\
    \            }\n            _ => (),\n        }\n        if count > max {\n  \
    \          max = count;\n        }\n    }\n    result.push(max);\n    result",
  "    // This is another case of using stack.\n    // If we see an open parenthesis,\
    \ push it on the stack.\n    // If we see a close parenthesis, pop an element\
    \ from the stack and\n    // update `max_depth` if required.\n    // After the\
    \ string is parsed, we can just return `max_depth`.\n    // The tricky part is\
    \ to find the right place to update `max_depth`.\n    // It is straightforward\
    \ to update `max_depth` when we parse a close parenthesis.\n    // However, we\
    \ can't do this. This is because an open parenthesis can be a part of a group\n\
    \    // which has deepest level of nesting. For example, in `(()())`, first open\
    \ parenthesis\n    // has the deepest level of nesting in the first group.\n \
    \   //\n    // So, the approach here is to count the number of elements in the\
    \ stack and update `max_depth`\n    // for each element we pop.\n    // In the\
    \ above example, we start with an empty stack. We push an element on the stack\n\
    \    // when we see an open parenthesis. Now, when we parse the close parenthesis,\
    \ we pop an element\n    // from the stack and count the number of elements in\
    \ the stack. This is the level of nesting.\n    // We push the element back on\
    \ the stack and repeat this process until the stack is empty.\n    //\n    //\
    \ For the second group, we start with an empty stack. Again, when we see an open\
    \ parenthesis,\n    // we push an element on the stack. When we see the first\
    \ close parenthesis, we pop an element\n    // from the stack. Now, the stack\
    \ is empty. This is because the stack should be empty after\n    // the group\
    \ has been parsed. So, we see that this group has a nesting level of 1.\n    //\
    \ We push the element back on the stack and parse the second close parenthesis.\n\
    \    // Now, the stack has 1 element. This is the level of nesting.\n    // We\
    \ push the element back on the stack and repeat this process until the stack is\
    \ empty.\n    // We now have the second group has a nesting level of 3.\n    //\n\
    \    // We now parse the third group. It is of length 1.\n    // And finally we\
    \ parse the fourth group. This has a nesting"]
stop_tokens:
- "\n}"
