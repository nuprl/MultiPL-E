name: HumanEval_18_how_many_times
language: rs
prompt: "/// Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"\
  a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n\
  /// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n///\
  \ 3\nfn how_many_times(string: String, substring: String) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
  \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
  ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
  ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
  ), String::from(\"john\")), 1);\n}\n"
completions: ["    let string_vec: Vec<char> = string.chars().collect();\n    let\
    \ substring_vec: Vec<char> = substring.chars().collect();\n    let mut counter\
    \ = 0;\n    for i in 0..(string_vec.len() - substring_vec.len() + 1) {\n     \
    \   let mut flag = false;\n        for j in 0..substring_vec.len() {\n       \
    \     if string_vec[i + j] != substring_vec[j] {\n                flag = true;\n\
    \                break;\n            }\n        }\n        if !flag {\n      \
    \      counter += 1;\n        }\n    }\n    counter", '    isize::from(string.matches(&substring).count())',
  "    let f = string.len() - substring.len();\n    if f < 0 {\n        return 0;\n\
    \    }\n\n    let mut slice_array = Vec::with_capacity(f);\n    for i in 0..f\
    \ {\n        slice_array.push(string.get(i..i + substring.len()).unwrap());\n\
    \    }\n\n    slice_array.iter().filter(|&x| x == substring.as_str()).count()\
    \ as isize", "    let mut t = 0;\n    for i in 0..string.len() {\n        let\
    \ mut idx = i;\n        let mut sub_idx = 0;\n        while idx < string.len()\
    \ && sub_idx < substring.len() {\n            if string.chars().nth(idx).unwrap()\
    \ == substring.chars().nth(sub_idx).unwrap() {\n                sub_idx += 1;\n\
    \            } else {\n                break;\n            }\n            idx\
    \ += 1;\n        }\n        if sub_idx == substring.len() {\n            t +=\
    \ 1;\n        }\n    }\n    t", "    let mut counter = 0;\n    let mut index =\
    \ 0;\n    loop {\n        let found = match string[index..].find(&substring) {\n\
    \            Some(i) => i,\n            None => break,\n        };\n        counter\
    \ += 1;\n        index += found + 1;\n    }\n    counter", "    if string.len()\
    \ == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut start_index = 0;\n    loop {\n        let found_index = string.find(&substring);\n\
    \        match found_index {\n            Some(index) => {\n                count\
    \ += 1;\n                start_index = index + 1;\n            }\n           \
    \ None => break,\n        }\n    }\n    count", "    let mut n = 0;\n    let mut\
    \ start = 0;\n    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    loop {\n        if start == string_len {\n            break;\n        }\n\
    \        if let Some(i) = string[start..].find(&substring) {\n            n +=\
    \ 1;\n            start += i + substring_len;\n        } else {\n            break;\n\
    \        }\n    }\n    n", "    let mut count = 0;\n    let string_bytes = string.as_bytes();\n\
    \    let substring_bytes = substring.as_bytes();\n    for start in 0..(string_bytes.len()\
    \ - substring_bytes.len() + 1) {\n        if &string_bytes[start..(start + substring_bytes.len())]\
    \ == substring_bytes {\n            count += 1;\n        }\n    }\n    count",
  "    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let mut count = 0;\n    let mut string_index = 0;\n    let mut substring_index\
    \ = 0;\n    while string_index < string_len {\n        if string[string_index..string_index\
    \ + 1] == substring[substring_index..substring_index + 1] {\n            count\
    \ += 1;\n            substring_index += 1;\n            if substring_index ==\
    \ substring_len {\n                substring_index = 0;\n            }\n     \
    \   } else {\n            substring_index = 0;\n        }\n        string_index\
    \ += 1;\n    }\n    count", "    // This is a naive implementation of the problem\n\
    \    if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < string.len() - substring.len()\
    \ + 1 {\n        if &string[i..i + substring.len()] == substring {\n         \
    \   count += 1;\n            i += substring.len();\n        } else {\n       \
    \     i += 1;\n        }\n    }\n    count", '    unimplemented!();', "    let\
    \ mut count = 0;\n    let string = string.into_bytes();\n    let substring = substring.into_bytes();\n\
    \    for i in 0..string.len() - substring.len() + 1 {\n        let mut is_substring\
    \ = true;\n        for j in 0..substring.len() {\n            if string[i + j]\
    \ != substring[j] {\n                is_substring = false;\n                break;\n\
    \            }\n        }\n        if is_substring {\n            count += 1;\n\
    \        }\n    }\n    count", "    let s = string.as_str();\n    let sub = substring.as_str();\n\
    \    let mut i = 0;\n    let mut n = 0;\n    while i + sub.len() <= s.len() {\n\
    \        if s[i..i + sub.len()] == sub {\n            n += 1;\n            i +=\
    \ sub.len();\n        } else {\n            i += 1;\n        }\n    }\n    n",
  "    let mut times: isize = 0;\n    let mut string_length = string.len();\n    let\
    \ substring_length = substring.len();\n    for i in 0..(string_length - substring_length\
    \ + 1) {\n        if string[i..(i + substring_length)] == substring {\n      \
    \      times += 1;\n        }\n    }\n    times", "    let s = string.as_str();\n\
    \    let sub = substring.as_str();\n    let mut i = 0;\n    let mut sum = 0;\n\
    \    while i < s.len() {\n        let range = &s[i..];\n        if range.starts_with(sub)\
    \ {\n            sum += 1;\n            i += sub.len();\n        } else {\n  \
    \          i += 1;\n        }\n    }\n    sum", "    if substring.len() == 0 {\n\
    \        return 0;\n    }\n    let mut count = 0;\n    let mut index = 0;\n  \
    \  while index < string.len() {\n        let mut index_end = index + substring.len();\n\
    \        if index_end > string.len() {\n            index_end = string.len();\n\
    \        }\n        let string_slice = &string[index..index_end];\n        if\
    \ string_slice == substring {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count", "  \
    \  let mut start = 0;\n    let mut count = 0;\n    while start + substring.len()\
    \ <= string.len() {\n        if &string[start..start + substring.len()] == substring\
    \ {\n            count += 1;\n            start += substring.len();\n        }\
    \ else {\n            start += 1;\n        }\n    }\n    count", "    let mut\
    \ cnt = 0;\n    let mut first_index = 0;\n    let mut index = 0;\n    let string_array:\
    \ Vec<char> = string.chars().collect();\n    let substring_array: Vec<char> =\
    \ substring.chars().collect();\n    for ch in string_array {\n        if index\
    \ >= substring_array.len() {\n            if ch == substring_array[first_index]\
    \ {\n                first_index += 1;\n            } else {\n               \
    \ first_index = 0;\n            }\n        }\n        if ch == substring_array[index]\
    \ {\n            index += 1;\n        } else {\n            index = 0;\n     \
    \   }\n        if index == substring_array.len() {\n            cnt += 1;\n  \
    \          index = first_index;\n        }\n    }\n    cnt", "    //let mut result\
    \ = 0;\n    //let mut idx = 0;\n    //let max_idx = string.len()-substring.len();\n\
    \    //while idx < max_idx {\n    //    if string[idx..].starts_with(&substring)\
    \ {\n    //        result += 1;\n    //        idx += substring.len();\n    //\
    \    } else {\n    //        idx += 1;\n    //    }\n    //}\n    //result\n \
    \   string.matches(&substring).count() as isize", "    if substring.len() > string.len()\
    \ {\n        return 0;\n    }\n    let mut count = 0;\n    let mut idx = 0;\n\
    \    for _ in 0..string.len() {\n        let (a, b) = string.split_at(idx);\n\
    \        if a.contains(&substring) {\n            count += 1;\n            idx\
    \ += substring.len();\n        } else {\n            idx += 1;\n        }\n  \
    \  }\n    count"]
stop_tokens:
- "\n}"
