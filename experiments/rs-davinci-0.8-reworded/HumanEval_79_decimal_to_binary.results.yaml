language: rs
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // TODO\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpjns821ya.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary: String =\
    \ String::from(\"db\");\n    if decimal == 0 {\n        binary.push('0');\n  \
    \  } else {\n        let mut dec = decimal;\n        let base = 2;\n        while\
    \ dec > 0 {\n            binary.push_str(&format!(\"{}\", dec % base));\n    \
    \        dec /= base;\n        }\n    }\n    binary.push('d');\n    binary.push('b');\n\
    \    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmphkqba5ps.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    fn helper(decimal: isize,\
    \ result: &mut String) {\n        if decimal < 2 {\n            result.push_str(&format!(\"\
    {}\", decimal));\n            return;\n        }\n        helper(decimal / 2,\
    \ result);\n        result.push_str(&format!(\"{}\", decimal % 2));\n    }\n \
    \   let mut result = String::from(\"db\");\n    helper(decimal, &mut result);\n\
    \    result.push_str(\"db\");\n    result\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpson665s_.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut res = String::from(\"\
    db\");\n    let mut tmp = decimal;\n    while tmp > 0 {\n        let rem = tmp\
    \ % 2;\n        tmp = tmp / 2;\n        res.push_str(&rem.to_string());\n    }\n\
    \    res.push_str(\"db\");\n    res\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmplsgzm3yn.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut rest = decimal;\n    while rest > 0 {\n        binary.push(match\
    \ rest % 2 {\n            0 => '0',\n            1 => '1',\n            _ => '?',\n\
    \        });\n        rest /= 2;\n    }\n    let mut length = binary.len();\n\
    \    if length < 2 {\n        binary.push('0');\n        length += 1;\n    }\n\
    \    binary.push_str(&String::from(\"db\"));\n    length += 2;\n    let mut binary\
    \ = binary.chars().collect::<Vec<char>>();\n    for _ in 0..length / 2 {\n   \
    \     let front = binary.pop().unwrap();\n        let back = binary.remove(0);\n\
    \        binary.insert(0, front);\n        binary.push(back);\n    }\n    binary.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmplsc5os8r.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut str: String = String::from(\"\
    db\");\n    let mut num = decimal;\n    while num > 0 {\n        if num % 2 ==\
    \ 0 {\n            str.push('0');\n        } else {\n            str.push('1');\n\
    \        }\n        num /= 2;\n    }\n    str.push_str(\"db\");\n    str.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpu9ksv9q3.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // add the 'db' part at\
    \ the beginning\n    let mut binary = String::from(\"db\");\n    // you can use\
    \ .push_str() to add characters to a string one at a time\n    // for each number\
    \ in the binary string we'll check if the current number is 1 or 0\n    // at\
    \ each iteration we'll remove the last digit of the decimal and add a 1 or 0 to\
    \ the binary string\n    while decimal > 0 {\n        if decimal % 2 == 0 {\n\
    \            binary.push_str(\"0\");\n        } else {\n            binary.push_str(\"\
    1\");\n        }\n        decimal /= 2;\n    }\n    // add the 'db' part at the\
    \ end\n    binary.push_str(\"db\");\n    binary\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmpr52gl5rv.rs:23:9\n\
    \   |\n11 | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n23 |         decimal /= 2;\n   |         ^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut decimal = decimal;\n    while decimal > 0 {\n        result.push_str(&format!(\"\
    {}\", decimal % 2));\n        decimal /= 2;\n    }\n    result.push_str(\"db\"\
    );\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n   \
    \ assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp3tufv49n.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut decimal = decimal;\n\
    \    let mut binary = String::from(\"db\");\n    while decimal > 0 {\n       \
    \ let remainder = decimal % 2;\n        decimal = decimal / 2;\n        binary.push_str(&remainder.to_string());\n\
    \    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpg9efnf4m.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut dec = decimal;\n    while dec > 0 {\n        let bin = dec\
    \ % 2;\n        result.push_str(&bin.to_string());\n        dec /= 2;\n    }\n\
    \    result.push_str(\"db\");\n    result\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpts07l7cy.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut number = decimal;\n    let mut result = String::new();\n \
    \   loop {\n        if number == 0 {\n            break;\n        }\n        result.push_str(&(number\
    \ % 2).to_string());\n        number /= 2;\n    }\n    result.chars().rev().for_each(|x|\
    \ binary.push(x));\n    binary.push('d');\n    binary.push('b');\n    binary\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmppbpihj73.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:08b}db\",\
    \ decimal)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db00000000db\"`,\n right: `\"db0db\"`', /tmp/tmpnvfk9tw5.rs:17:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // There is an extra couple\
    \ of characters ('db') at the beginning and at the end of the string.\n    //\
    \ The extra characters are there to help with the format.\n    let mut binary\
    \ = String::from(\"db\");\n    let mut number = decimal;\n    loop {\n       \
    \ if number == 0 {\n            break;\n        }\n        binary.push_str(&(number\
    \ % 2).to_string());\n        number /= 2;\n    }\n    binary.push_str(\"db\"\
    );\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp4n4li0eq.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut res = String::from(\"\
    db\");\n    let mut decimal = decimal;\n    while decimal != 0 {\n        let\
    \ remainder = decimal % 2;\n        res.push_str(&remainder.to_string());\n  \
    \      decimal /= 2;\n    }\n    res.push_str(\"db\");\n    res\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpp8jnhuvo.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::new();\n\
    \    binary.push_str(\"db\");\n    let mut original_decimal = decimal;\n    let\
    \ mut loop_bool = true;\n    while loop_bool {\n        if original_decimal %\
    \ 2 == 0 {\n            binary.push_str(\"0\");\n        } else {\n          \
    \  binary.push_str(\"1\");\n        }\n        original_decimal = original_decimal\
    \ / 2;\n        if original_decimal == 0 {\n            loop_bool = false;\n \
    \       }\n    }\n    binary.push_str(\"db\");\n    binary\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db000001db\"`,\n right: `\"db100000db\"`', /tmp/tmp2dzxhpjv.rs:34:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = format!(\"\
    db{:b}db\", decimal);\n    let mut index = 4;\n    while binary.len() > 7 {\n\
    \        binary.insert(index, ' ');\n        index += 5;\n    }\n    binary\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: self.is_char_boundary(idx)'',
    /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/string.rs:1521:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    match decimal {\n      \
    \  0 => String::from(\"db0db\"),\n        _ => format!(\"db{}db\", decimal.to_string(2))\n\
    \    }\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpd3ue04vx.rs:14:40\n     |\n14   |         _ => format!(\"db{}db\"\
    , decimal.to_string(2))\n     |                                        ^^^^^^^^^\
    \ - supplied 1 argument\n     |                                        |\n   \
    \  |                                        expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut num = decimal;\n    while num > 0 {\n        binary.push_str(&format!(\"\
    {}\", num % 2));\n        num /= 2;\n    }\n    binary.push_str(\"db\");\n   \
    \ binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp8pl_2zna.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut digit = 1;\n    let mut i = decimal;\n    while i > 0 {\n\
    \        result.push_str(&(i % 2).to_string());\n        i /= 2;\n    }\n    result.push_str(\"\
    db\");\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp9aaqqm7n.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!(\"Write a\
    \ function that converts an integer to binary like: db{}db\", decimal)\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Write a function that converts
    an integer to binary like: db0db'', /tmp/tmpq3op2wgk.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut number = decimal;\n    while number > 0 {\n        let digit\
    \ = number % 2;\n        number = number / 2;\n        binary.push_str(&digit.to_string());\n\
    \    }\n    binary.push_str(\"db\");\n    binary\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpq93f2l1r.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // TODO: Test.\n    let\
    \ mut binary = String::from(\"db\");\n    let mut working_decimal = decimal;\n\
    \    loop {\n        if working_decimal == 0 {\n            binary.push_str(\"\
    0\");\n            break;\n        }\n        let remainder = working_decimal\
    \ % 2;\n        binary.push_str(&remainder.to_string());\n        working_decimal\
    \ = working_decimal / 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpuden10xu.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpnay40a5r.rs:12:33\n     |\n12   |     \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n     |                                 ^^^^^^^^^ - supplied 1 argument\n\
    \     |                                 |\n     |                            \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut num = decimal;\n    while num > 0 {\n        if num % 2 ==\
    \ 0 {\n            binary.push('0');\n        } else {\n            binary.push('1');\n\
    \        }\n        num /= 2;\n    }\n    let mut bin = String::from(binary.chars().rev().collect::<String>());\n\
    \    bin.push_str(\"db\");\n    bin\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bddb\"`,\n right: `\"db0db\"`', /tmp/tmpoh1nukh_.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut string = String::from(\"\
    db\");\n    let mut num = decimal;\n    let mut vec = Vec::new();\n    while num\
    \ != 0 {\n        vec.push(num % 2);\n        num /= 2;\n    }\n    for i in vec.iter().rev()\
    \ {\n        if *i == 1 {\n            string.push('1');\n        } else {\n \
    \           string.push('0');\n        }\n    }\n    string.push('d');\n    string.push('b');\n\
    \    string\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmprbyk3q0c.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut output = String::from(\"\
    db\");\n    let mut input = decimal;\n    let mut result = 0;\n    let mut rem\
    \ = 0;\n    while input > 0 {\n        rem = input % 2;\n        result = result\
    \ * 10 + rem;\n        input /= 2;\n    }\n    while result > 0 {\n        let\
    \ _rem = result % 10;\n        output.push_str(_rem.to_string().as_str());\n \
    \       result /= 10;\n    }\n    output.push_str(\"db\");\n    output\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpk7yirf_z.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::new();\n\
    \    binary.push_str(\"db\");\n    if decimal == 0 {\n        binary.push('0');\n\
    \    } else {\n        let mut n = decimal;\n        while n > 0 {\n         \
    \   binary.push_str(&((n % 2).to_string()));\n            n /= 2;\n        }\n\
    \    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpfymj52qg.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = \"db\"\
    .to_string();\n    let mut dec = decimal;\n    while dec > 0 {\n        let rem\
    \ = dec % 2;\n        if rem == 0 {\n            binary.push('0');\n        }\
    \ else {\n            binary.push('1');\n        }\n        dec /= 2;\n    }\n\
    \    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp0jheauk2.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    String::from(\"db\") + &format!(\"\
    {:b}\", decimal) + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    \"db\".to_string() + &format!(\"\
    {:b}\", decimal) + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut x = decimal.clone();\n\
    \    let mut n = String::from(\"db\");\n    while x > 0 {\n        n.push_str(&((x\
    \ % 2).to_string()));\n        x = x / 2;\n    }\n    n.push_str(\"db\");\n  \
    \  n.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp0qdo4rxb.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let start_str = \"db\";\n\
    \    let end_str = \"db\";\n    let mut result_str = String::from(start_str);\n\
    \    let mut num = decimal;\n    while num != 0 {\n        let reminder = num\
    \ % 2;\n        result_str.push_str(&reminder.to_string());\n        num = num\
    \ / 2;\n    }\n    result_str.push_str(end_str);\n    result_str.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmppff2_tea.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut rest = decimal;\n    while rest > 0 {\n        binary.push_str(&rest.rem_euclid(2).to_string());\n\
    \        rest = rest / 2;\n    }\n    let mut chars: Vec<char> = binary.chars().collect();\n\
    \    chars.reverse();\n    chars.into_iter().collect::<String>() + \"db\"\n}\n\
    \nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bddb\"`,\n right: `\"db0db\"`', /tmp/tmp8fo3aqaw.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut res = String::from(\"\
    db\");\n    let mut r = decimal;\n    while r > 0 {\n        let k = r % 2;\n\
    \        res.push_str(&k.to_string());\n        r = r / 2;\n    }\n    res.push_str(\"\
    db\");\n    res\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n  \
    \  assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpw4rqhz2s.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // TODO\n    \"db0db\".to_string()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0db\"`,\n right: `\"db100000db\"`', /tmp/tmp7_dnwxco.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut string = String::from(\"\
    db\");\n    if decimal == 0 {\n        string.push('0');\n    } else {\n     \
    \   let mut num = decimal;\n        while num > 0 {\n            let rem = num\
    \ % 2;\n            let rem_char = char::from(rem as u8 + 48);\n            string.push(rem_char);\n\
    \            num /= 2;\n        }\n    }\n    string.push('d');\n    string.push('b');\n\
    \    string.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpd_m0czqb.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut x = decimal;\n    while x > 0 {\n        let y = x % 2;\n\
    \        x = x / 2;\n        binary.push_str(&y.to_string());\n    }\n    binary.push_str(\"\
    db\");\n    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpt256auuh.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut decimal = decimal;\n\
    \    let mut binary = \"db\".to_string();\n    while decimal != 0 {\n        let\
    \ binary_digit = decimal % 2;\n        decimal = decimal / 2;\n        binary.push_str(&binary_digit.to_string());\n\
    \    }\n    binary.push_str(\"db\");\n    binary\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpteprhkyz.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut output = String::from(\"\
    db\");\n    let mut dec = decimal;\n    while dec > 0 {\n        output.push(char::from((dec\
    \ % 2) + 48));\n        dec /= 2;\n    }\n    let mut output = output.chars().rev().collect::<String>();\n\
    \    output.push_str(\"db\");\n    output\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `char: From<isize>` is not satisfied\n  -->\
    \ /tmp/tmpnwitk3mb.rs:15:21\n   |\n15 |         output.push(char::from((dec %\
    \ 2) + 48));\n   |                     ^^^^^^^^^^ the trait `From<isize>` is not\
    \ implemented for `char`\n   |\n   = help: the trait `From<u8>` is implemented\
    \ for `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    fn calculate_binary(binary:\
    \ isize, decimal: isize) -> isize {\n        match decimal {\n            1 =>\
    \ binary * 10 + 1,\n            0 => binary * 10,\n            _ => calculate_binary(binary\
    \ * 10 + decimal % 2, decimal / 2),\n        }\n    }\n\n    let binary = calculate_binary(0,\
    \ decimal);\n    format!(\"db{}db\", binary)\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db1db\"`,\n right: `\"db100000db\"`', /tmp/tmp282l25w5.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut is_negative = false;\n\
    \    let mut str_out = String::from(\"db\");\n    if decimal < 0 {\n        is_negative\
    \ = true;\n        str_out.push_str(&decimal_to_binary(-decimal));\n    } else\
    \ {\n        let mut num = decimal;\n        while num > 0 {\n            str_out.push_str(&format!(\"\
    {}\", num % 2));\n            num /= 2;\n        }\n    }\n    if is_negative\
    \ {\n        str_out.push_str(\"1\");\n    } else {\n        str_out.push_str(\"\
    0\");\n    }\n    str_out.push_str(\"db\");\n    str_out.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpf69rtp6h.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut n = decimal;\n    while n > 0 {\n        result.push_str(&n.rem_euclid(2).to_string());\n\
    \        n /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpdknele5v.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    String::from(\"db\") + &decimal.to_string(2)\
    \ + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp_2bmig43.rs:12:35\n     |\n12   |     String::from(\"db\") +\
    \ &decimal.to_string(2) + \"db\"\n     |                                   ^^^^^^^^^\
    \ - supplied 1 argument\n     |                                   |\n     |  \
    \                                 expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut num = decimal;\n    while num > 0 {\n        let rem = num\
    \ % 2;\n        binary.push_str(&rem.to_string());\n        num /= 2;\n    }\n\
    \    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp9_evymty.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut decimal = decimal;\n    while decimal > 0 {\n        result.push(if\
    \ decimal % 2 == 0 { '0' } else { '1' });\n        decimal /= 2;\n    }\n    result.push('d');\n\
    \    result.push('b');\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpevko_e_e.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = \"db\"\
    .to_string();\n    let mut number = decimal;\n    let mut remainder;\n    while\
    \ number > 0 {\n        remainder = number % 2;\n        number = number / 2;\n\
    \        binary.push_str(&remainder.to_string());\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpg863bjqr.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut remaining = decimal;\n    while remaining > 0 {\n        binary.push(if\
    \ remaining % 2 == 0 { '0' } else { '1' });\n        remaining /= 2;\n    }\n\
    \    binary.push('d');\n    binary.push('b');\n    binary\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpmlbreyi1.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut string = \"db\"\
    .to_string();\n    let mut number = decimal;\n    let mut count = 0;\n    if number\
    \ < 0 {\n        number = number.abs();\n        string.push('-');\n    }\n  \
    \  while number != 0 {\n        let tmp = number % 2;\n        string.push_str(&tmp.to_string());\n\
    \        number /= 2;\n        count += 1;\n    }\n    if count % 8 != 0 {\n \
    \       while count % 8 != 0 {\n            string.push('0');\n            count\
    \ += 1;\n        }\n    }\n    string.push_str(\"db\");\n    string.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpe1f7v2yp.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // insert code here\n  \
    \  String::from(\"unimplemented\")\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"unimplemented\"`,\n right: `\"db0db\"`', /tmp/tmpgyt808j9.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // Write the code here\n\
    \    String::from(\"db100000db\")\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db100000db\"`,\n right: `\"db0db\"`', /tmp/tmpn53hzw6c.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpson665s_.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let result = format!(\"\
    {:b}\", decimal);\n    format!(\"db{}db\", result)\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    return String::from(\"db\"\
    ) + &format!(\"{:b}\", decimal) + \"db\";\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!(\"convert\
    \ {} to binary\", decimal)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: convert 0 to binary'', /tmp/tmpbiuk8occ.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    use std::fmt::Write;\n \
    \   let mut s = String::new();\n    let mut decimal = decimal;\n    write!(&mut\
    \ s, \"db\").unwrap();\n    while decimal > 0 {\n        let remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        if remainder == 0 {\n            s.push('0');\n\
    \        } else {\n            s.push('1');\n        }\n    }\n    s.push_str(\"\
    db\");\n    s\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpuyr5agwh.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut decimal = decimal;\n\
    \    let mut binary = String::from(\"db\");\n    while decimal > 0 {\n       \
    \ binary.push(if decimal % 2 == 0 { '0' } else { '1' });\n        decimal /= 2;\n\
    \    }\n    binary.push('d');\n    binary.push('b');\n    return binary;\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpvvcxe2u2.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary: Vec<char>\
    \ = Vec::new();\n    let mut decimal = decimal;\n    let mut remainder: isize;\n\
    \n    binary.push('d');\n    binary.push('b');\n\n    loop {\n        remainder\
    \ = decimal % 2;\n        decimal = decimal / 2;\n\n        if remainder == 0\
    \ {\n            binary.push('0');\n        } else {\n            binary.push('1');\n\
    \        }\n\n        if decimal == 0 {\n            break;\n        }\n    }\n\
    \n    binary.push('d');\n    binary.push('b');\n\n    binary.iter().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmph2gzb0k3.rs:42:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary: String =\
    \ String::from(\"db\");\n    let mut value = decimal;\n    while value != 0 {\n\
    \        binary.push_str(&(value % 2).to_string());\n        value /= 2;\n   \
    \ }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\nfn\
    \ main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmprynhxl3l.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let binary = format!(\"\
    {:b}\", decimal);\n    format!(\"db{}db\", binary)\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut remainder = decimal;\n    while remainder > 0 {\n        let\
    \ q = remainder / 2;\n        let r = remainder % 2;\n        remainder = q;\n\
    \        binary.push_str(&r.to_string());\n    }\n    binary.push_str(\"db\");\n\
    \    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpob3b1vbt.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpson665s_.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // replace the function\
    \ body to pass the tests\n    if decimal == 0 {\n        \"db0db\".to_string()\n\
    \    } else {\n        let mut bin = String::new();\n        bin.push_str(\"db\"\
    );\n        let mut d = decimal;\n        while d > 0 {\n            bin.push_str(&(d\
    \ % 2).to_string());\n            d /= 2;\n        }\n        bin.push_str(\"\
    db\");\n        bin.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd100000bd\"`,\n right: `\"db100000db\"`', /tmp/tmp986ml5l0.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!(\"Convert\
    \ {} to binary\", decimal)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Convert 0 to binary'', /tmp/tmpm02nm5wk.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut remainder = decimal;\n    let mut dividend = decimal;\n  \
    \  loop {\n        remainder = dividend % 2;\n        dividend = dividend / 2;\n\
    \        binary.push_str(&remainder.to_string());\n        if dividend == 0 {\n\
    \            break;\n        }\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpt_dw4ptl.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut ret = String::from(\"\
    db\");\n    let mut temp = decimal;\n    loop {\n        let rem = temp % 2;\n\
    \        temp = temp / 2;\n        ret.push_str(&rem.to_string());\n        if\
    \ temp == 0 {\n            break;\n        }\n    }\n    ret.push_str(\"db\");\n\
    \    ret.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpebunp0wf.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = format!(\"\
    db{:b}db\", decimal);\n    let mut new_binary = \"\".to_string();\n    let len\
    \ = binary.len();\n    let mut count = 0;\n    let digits = len / 4;\n    let\
    \ mut count_digits = 0;\n    while count < len {\n        count_digits += 1;\n\
    \        if count_digits % digits == 0 {\n            if count_digits % 10 ==\
    \ 0 {\n                new_binary.push_str(&binary[count..count + 1]);\n     \
    \           new_binary.push_str(\" \");\n            } else {\n              \
    \  new_binary.push_str(&binary[count..count + 1]);\n            }\n        } else\
    \ {\n            new_binary.push_str(&binary[count..count + 1]);\n        }\n\
    \        count += 1;\n    }\n    new_binary\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db100000db \"`,\n right: `\"db100000db\"`', /tmp/tmpl2_4t__0.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    return format!(\"db{}db\"\
    , format!(\"{:b}\", decimal));\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = \"db\"\
    .to_string();\n    let mut mutable_decimal = decimal;\n    while mutable_decimal\
    \ > 0 {\n        let remainder = mutable_decimal % 2;\n        mutable_decimal\
    \ = mutable_decimal / 2;\n        if remainder == 0 {\n            result = \"\
    0\".to_string() + &result;\n        } else {\n            result = \"1\".to_string()\
    \ + &result;\n        }\n    }\n    if result.len() < 2 {\n        result = \"\
    0\".to_string() + &result;\n    }\n    let result = result + \"db\";\n    result\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpodmd1fxd.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    if decimal == 0 {\n    \
    \    return String::from(\"db0db\");\n    }\n    let mut string = String::from(\"\
    db\");\n    let mut decimal = decimal;\n    while decimal > 0 {\n        string.push_str(&(decimal\
    \ % 2).to_string());\n        decimal /= 2;\n    }\n    string.push_str(\"db\"\
    );\n    string.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd100000bd\"`,\n right: `\"db100000db\"`', /tmp/tmpp0lsfxl4.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    \"db\".to_string() + &format!(\"\
    {:b}\", decimal) + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::new();\n\
    \    binary.push_str(\"db\");\n    let mut number = decimal;\n    while number\
    \ > 0 {\n        binary.push_str(&(number % 2).to_string());\n        number /=\
    \ 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp6l2q0320.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = \"db\"\
    .to_string();\n    let mut n = decimal;\n    let mut binary_count = 1;\n    let\
    \ mut binary_sum = 0;\n    while n != 0 {\n        let a = n % 2;\n        n =\
    \ n / 2;\n        binary_sum += a * binary_count;\n        binary_count *= 10;\n\
    \    }\n    binary.push_str(&binary_sum.to_string());\n    binary.push_str(\"\
    db\");\n    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut bin = format!(\"\
    db{:b}db\", decimal);\n    let mut res = String::from(\"\");\n    while !bin.is_empty()\
    \ {\n        let c = bin.pop().unwrap();\n        res.push(c);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpkfn5whjv.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = format!(\"\
    db{:b}db\", decimal);\n    let mut zeros = 0;\n    for c in binary.chars().rev()\
    \ {\n        if c == '0' {\n            zeros += 1;\n        } else {\n      \
    \      break;\n        }\n    }\n    binary.pop();\n    for _ in 0..zeros {\n\
    \        binary.pop();\n    }\n    binary\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0d\"`,\n right: `\"db0db\"`', /tmp/tmp2nvmdkzc.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut d = decimal;\n    while d > 0 {\n        result.push(std::char::from_digit((d\
    \ % 2) as u32, 10).unwrap());\n        d /= 2;\n    }\n    let len = result.len();\n\
    \    result.push_str(&result[2..len].chars().rev().collect::<String>());\n   \
    \ result.push_str(\"db\");\n    result\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpst77o6w4.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut remaining = decimal;\n    while remaining > 0 {\n        if\
    \ remaining % 2 == 0 {\n            binary.push('0');\n        } else {\n    \
    \        binary.push('1');\n        }\n        remaining /= 2;\n    }\n    binary.push_str(\"\
    db\");\n    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmptqe8qshi.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // You can assume that decimal\
    \ is greater than or equal to 0.\n    String::from(\"dbdb\")\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpapv5s3_j.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    \"db\".to_string() + &format!(\"\
    {:b}\", decimal) + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut decimal = decimal;\n\
    \    let mut result = String::from(\"db\");\n    if decimal == 0 {\n        result.push('0');\n\
    \    } else {\n        while decimal > 0 {\n            result.push_str(&(decimal\
    \ % 2).to_string());\n            decimal /= 2;\n        }\n    }\n    result.push('d');\n\
    \    result.push('b');\n    result.chars().rev().collect()\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpuwed36yf.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    String::from(\"db\") + &decimal.to_string(2)\
    \ + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp_2bmig43.rs:12:35\n     |\n12   |     String::from(\"db\") +\
    \ &decimal.to_string(2) + \"db\"\n     |                                   ^^^^^^^^^\
    \ - supplied 1 argument\n     |                                   |\n     |  \
    \                                 expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!(\"Convert\
    \ a decimal number {} to a binary number as a string\", decimal)\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Convert a decimal number
    0 to a binary number as a string'', /tmp/tmp3_rjxflu.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut bin = String::from(\"\
    db\");\n    let mut num = decimal;\n    while num > 0 {\n        let r = num %\
    \ 2;\n        num = num / 2;\n        bin.push_str(&r.to_string());\n    }\n \
    \   bin.push_str(\"db\");\n    bin.chars().rev().collect()\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpemwlz_3p.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary: String =\
    \ \"db\".to_string();\n    let mut rem = decimal;\n    while rem > 0 {\n     \
    \   let bin = rem % 2;\n        binary.push_str(&bin.to_string());\n        rem\
    \ = rem / 2;\n    }\n    binary.push_str(\"db\");\n    let mut reversed = binary.chars().rev().collect::<String>();\n\
    \    reversed\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpbmtaylai.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    \"db\".to_string() + &format!(\"\
    {:b}\", decimal) + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut num = decimal;\n    while num > 0 {\n        let temp = num\
    \ % 2;\n        num = num / 2;\n        result.push_str(&temp.to_string());\n\
    \    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp45d2vf0r.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::new();\n\
    \    binary.push_str(\"db\");\n    let mut rest = decimal;\n    let mut result\
    \ = String::new();\n    while rest > 0 {\n        result.push_str(&(rest % 2).to_string());\n\
    \        rest = rest / 2;\n    }\n    result.chars().rev().for_each(|c| binary.push(c));\n\
    \    binary.push_str(\"db\");\n    binary\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpj2acplp6.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut cur = decimal;\n    while cur > 0 {\n        if cur % 2 ==\
    \ 0 {\n            result = String::from(\"0\") + &result;\n        } else {\n\
    \            result = String::from(\"1\") + &result;\n        }\n        cur /=\
    \ 2;\n    }\n    result + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpp8ywztht.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    String::from(\"db\") + &format!(\"\
    {:b}\", decimal) + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary: String =\
    \ \"db\".to_string();\n    let mut n = decimal;\n    loop {\n        if n == 0\
    \ {\n            break;\n        }\n        binary.push(match n % 2 {\n      \
    \      0 => '0',\n            _ => '1',\n        });\n        n /= 2;\n    }\n\
    \    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpx1j3bmit.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // TODO\n    let dec: isize\
    \ = decimal;\n    let mut bin = String::from(\"db\");\n    let mut i = dec;\n\
    \    loop {\n        bin.push_str(&i.rem_euclid(2).to_string());\n        i =\
    \ i / 2;\n        if i == 0 {\n            break;\n        }\n    }\n    bin.push_str(\"\
    db\");\n    let mut res = String::new();\n    for c in bin.chars().rev() {\n \
    \       res.push(c);\n    }\n    res\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmp_pvw__ii.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    String::from(\"\")\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpu_3p1upq.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = \"db\"\
    .to_string();\n    for _ in 0..8 {\n        binary.push_str(&((decimal % 2).to_string()));\n\
    \        decimal /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmp56_260oh.rs:15:9\n\
    \   |\n11 | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n15 |         decimal /= 2;\n   |         ^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut n = decimal;\n    while n > 0 {\n        binary.push_str(&(n\
    \ % 2).to_string());\n        n /= 2;\n    }\n    binary.push_str(\"db\");\n \
    \   binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp30khmzw2.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    String::from(\"db\") + &decimal.to_string(2)\
    \ + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp_2bmig43.rs:12:35\n     |\n12   |     String::from(\"db\") +\
    \ &decimal.to_string(2) + \"db\"\n     |                                   ^^^^^^^^^\
    \ - supplied 1 argument\n     |                                   |\n     |  \
    \                                 expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut res = String::from(\"\
    db\");\n    let mut dec = decimal;\n    let mut remainder = 0;\n    while dec\
    \ > 0 {\n        remainder = dec % 2;\n        dec = dec / 2;\n        res.push_str(&remainder.to_string());\n\
    \    }\n    res.push_str(\"db\");\n    res\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpuf_s0c9a.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut dec = decimal;\n    let mut rem = 0;\n    loop {\n       \
    \ rem = dec % 2;\n        dec = dec / 2;\n        binary.push_str(&rem.to_string());\n\
    \        if dec == 0 {\n            break;\n        }\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpolp34a1q.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let binary_string = format!(\"\
    {:b}\", decimal);\n    let mut result = String::from(\"db\");\n    for char in\
    \ binary_string.chars() {\n        result.push(char);\n    }\n    result.push_str(\"\
    db\");\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // TODO!\n    \"db0db\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0db\"`,\n right: `\"db100000db\"`', /tmp/tmpy0qqs1ez.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut s = String::new();\n\
    \    s.push_str(\"db\");\n    let mut binary: Vec<char> = Vec::new();\n    let\
    \ mut number = decimal;\n    while number > 0 {\n        binary.push(if number\
    \ % 2 == 0 { '0' } else { '1' });\n        number /= 2;\n    }\n    binary.iter().rev().for_each(|x|\
    \ s.push(*x));\n    s.push_str(\"db\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpaus0ds3j.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut bin_digit = 1;\n    let mut rem = decimal;\n    let mut i\
    \ = 0;\n    while i < 32 {\n        if rem == 0 {\n            binary.push('0');\n\
    \        } else {\n            let digit = rem % 2;\n            if digit == 1\
    \ {\n                binary.push('1');\n            } else {\n               \
    \ binary.push('0');\n            }\n            rem = rem / 2;\n        }\n  \
    \      bin_digit *= 2;\n        i += 1;\n    }\n    binary.push('db');\n    binary\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpi0jkubtw.rs:31:17\n\
    \   |\n31 |     binary.push('db');\n   |                 ^^^^\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n31 |     binary.push(\"\
    db\");\n   |                 ~~~~\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    String::from(\"db1111db\"\
    )\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db1111db\"`,\n right: `\"db0db\"`', /tmp/tmpvxe2frim.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::new();\n\
    \    if decimal > 0 {\n        let mut number = decimal;\n        let mut binary_part\
    \ = String::new();\n        while number > 0 {\n            let reminder = number\
    \ % 2;\n            binary_part.push_str(&reminder.to_string());\n           \
    \ number = number / 2;\n        }\n        binary.push_str(\"db\");\n        binary.push_str(&binary_part.chars().rev().collect::<String>());\n\
    \        binary.push_str(\"db\");\n    } else {\n        let mut number = decimal.abs();\n\
    \        let mut binary_part = String::new();\n        while number > 0 {\n  \
    \          let reminder = number % 2;\n            binary_part.push_str(&reminder.to_string());\n\
    \            number = number / 2;\n        }\n        binary.push_str(\"db-\"\
    );\n        binary.push_str(&binary_part.chars().rev().collect::<String>());\n\
    \        binary.push_str(\"db\");\n    }\n    binary\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db-db\"`,\n right: `\"db0db\"`', /tmp/tmpmeyok0en.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut res = String::from(\"\
    db\");\n    let mut n = decimal;\n    while n > 0 {\n        res.push(char::from(b'0'\
    \ + (n % 2) as u8));\n        n /= 2;\n    }\n    res.push('d');\n    res.push('b');\n\
    \    res\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp0t3cef9l.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut rem = decimal;\n    while rem > 0 {\n        binary.push_str(&format!(\"\
    {}\", rem % 2));\n        rem /= 2;\n    }\n    binary.push_str(\"db\");\n   \
    \ binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpmnb3l37l.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut num = decimal;\n\
    \    let mut binary_result = String::from(\"db\");\n    let mut stack = Stack::new();\n\
    \    loop {\n        if num == 0 {\n            break;\n        }\n        stack.push(num\
    \ % 2);\n        num /= 2;\n    }\n    while !stack.is_empty() {\n        binary_result.push_str(&format!(\"\
    {}\", stack.pop().unwrap()));\n    }\n    binary_result.push_str(\"db\");\n  \
    \  binary_result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n \
    \   assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpxc09cfyo.rs:14:21\n   |\n14 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpnay40a5r.rs:12:33\n     |\n12   |     \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n     |                                 ^^^^^^^^^ - supplied 1 argument\n\
    \     |                                 |\n     |                            \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    if decimal == 0 {\n    \
    \    return String::from(\"db0db\");\n    }\n    let mut result = String::from(\"\
    db\");\n    let mut decimal = decimal;\n    while decimal > 0 {\n        let c\
    \ = match decimal % 2 {\n            0 => '0',\n            1 => '1',\n      \
    \      _ => panic!(\"I will not run, as decimal % 2 is either 0 or 1\"),\n   \
    \     };\n        result.push(c);\n        decimal /= 2;\n    }\n    result.push_str(\"\
    db\");\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd100000bd\"`,\n right: `\"db100000db\"`', /tmp/tmpo59_ejq6.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut left = decimal;\n    while left != 0 {\n        result.push_str(&(left\
    \ % 2).to_string());\n        left /= 2;\n    }\n    result.push_str(\"db\");\n\
    \    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpzxulftb5.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = \"db\"\
    .to_string();\n    let mut temp = decimal;\n    while temp != 0 {\n        binary.push_str(&(temp\
    \ % 2).to_string());\n        temp /= 2;\n    }\n    binary.push_str(\"db\");\n\
    \    return binary;\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp7ze9p4td.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut remainder = decimal;\n    while remainder > 0 {\n        result.push_str(&format!(\"\
    {}\", remainder % 2));\n        remainder /= 2;\n    }\n    result.push_str(\"\
    db\");\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmptqcktw23.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut decimal_clone =\
    \ decimal;\n    let mut binary_string = String::from(\"db\");\n    while decimal_clone\
    \ > 0 {\n        let binary_digit = decimal_clone % 2;\n        binary_string.push_str(&binary_digit.to_string());\n\
    \        decimal_clone /= 2;\n    }\n    binary_string.push_str(\"db\");\n   \
    \ binary_string\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n  \
    \  assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpe4_rsa_5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpnay40a5r.rs:12:33\n     |\n12   |     \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n     |                                 ^^^^^^^^^ - supplied 1 argument\n\
    \     |                                 |\n     |                            \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut n = decimal;\n    while n > 0 {\n        binary.push_str(&((n\
    \ % 2).to_string()));\n        n /= 2;\n    }\n    binary.push_str(\"db\");\n\
    \    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpo2y39_jp.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    String::from(\"db\") + &format!(\"\
    {:b}\", decimal) + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut output = \"db\"\
    .to_string();\n    let mut num = decimal;\n    while num != 0 {\n        output.push_str(&((num\
    \ % 2).to_string()));\n        num /= 2;\n    }\n    output.push_str(\"db\");\n\
    \    output.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpsgxizdig.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary: String =\
    \ String::from(\"db\");\n    let mut current_val = decimal;\n    let mut remainder\
    \ = 0;\n    let mut current_digit = 0;\n\n    if decimal <= 0 {\n        return\
    \ binary + \"0db\";\n    }\n\n    while current_val != 0 {\n        remainder\
    \ = current_val % 2;\n        current_val = current_val / 2;\n        binary =\
    \ binary + &remainder.to_string();\n    }\n\n    binary = binary + \"db\";\n \
    \   binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd100000bd\"`,\n right: `\"db100000db\"`', /tmp/tmpxdi27fko.rs:34:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!(\"decimal\
    \ to binary string converter\")\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: decimal to binary string
    converter'', /tmp/tmplfnmippp.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut out = String::new();\n\
    \    if decimal == 0 {\n        out.push_str(\"db0db\");\n    } else {\n     \
    \   out.push_str(\"db\");\n        let mut i = decimal;\n        while i > 0 {\n\
    \            out.push_str(&(i % 2).to_string());\n            i /= 2;\n      \
    \  }\n        out.push_str(\"db\");\n    }\n    out.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmph69docz5.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut current = decimal;\n    while current != 0 {\n        binary\
    \ = format!(\"{}{}\", binary, current % 2);\n        current /= 2;\n    }\n  \
    \  binary.push_str(\"db\");\n    binary\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpxwwyp4xt.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut decimal_to_binary_str\
    \ = String::from(\"db\");\n    let mut decimal_remainder = decimal;\n    while\
    \ decimal_remainder > 0 {\n        let current_digit = decimal_remainder % 2;\n\
    \        decimal_to_binary_str.push_str(&current_digit.to_string());\n       \
    \ decimal_remainder = decimal_remainder / 2;\n    }\n    decimal_to_binary_str.push_str(\"\
    db\");\n    decimal_to_binary_str\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp5kzk1wpl.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut power_of_two = 0;\n    let mut difference = decimal;\n   \
    \ while 2_i64.pow(power_of_two) <= difference as i64 {\n        power_of_two +=\
    \ 1;\n    }\n    power_of_two -= 1;\n    while power_of_two >= 0 {\n        if\
    \ difference >= 2_i64.pow(power_of_two) as isize {\n            result.push('1');\n\
    \            difference -= 2_i64.pow(power_of_two) as isize;\n        } else {\n\
    \            result.push('0');\n        }\n        power_of_two -= 1;\n    }\n\
    \    result.push_str(\"db\");\n    result\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpbn7jajb7.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpnay40a5r.rs:12:33\n     |\n12   |     \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n     |                                 ^^^^^^^^^ - supplied 1 argument\n\
    \     |                                 |\n     |                            \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut input = decimal;\n    while input > 0 {\n        result.push_str(&if\
    \ input % 2 == 0 { \"0\" } else { \"1\" });\n        input /= 2;\n    }\n    result.push_str(\"\
    db\");\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpe9au0jsb.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut bin = format!(\"\
    db{:b}db\", decimal);\n    while bin.len() != 8 {\n        bin = format!(\"0{}\"\
    , bin);\n    }\n    return bin;\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"000db0db\"`,\n right: `\"db0db\"`', /tmp/tmprgg19utw.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binee = String::from(\"\
    db\");\n    let mut deci = decimal;\n    let mut count = 0;\n    while deci >\
    \ 0 {\n        binee.push_str(&((deci % 2).to_string()));\n        deci = deci\
    \ / 2;\n        count += 1;\n    }\n    for _ in count..7 {\n        binee.push_str(\"\
    0\");\n    }\n    binee.push_str(\"db\");\n    binee\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0000000db\"`,\n right: `\"db0db\"`', /tmp/tmp3s_hz6xs.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!(\"Create\
    \ a string of binary number in decimal form: {:?}\", decimal)\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Create a string of binary
    number in decimal form: 0'', /tmp/tmpz7uowbbt.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpiz9zr07u.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::new();\n\
    \    let mut temp = decimal;\n    let mut remainder;\n    binary.push_str(\"db\"\
    );\n    while temp > 0 {\n        remainder = temp % 2;\n        temp = temp /\
    \ 2;\n        binary.push_str(&remainder.to_string());\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpflvb8z3j.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    use std::fmt::Write;\n \
    \   let mut result = String::from(\"db\");\n    for i in (0..8).rev() {\n    \
    \    if decimal >= 2_i32.pow(i) {\n            result.push('1');\n           \
    \ decimal -= 2_i32.pow(i);\n        } else {\n            result.push('0');\n\
    \        }\n    }\n    result.push('d');\n    result.push('b');\n    result\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::fmt::Write`\n  --> /tmp/tmpq08xcjqr.rs:12:9\n\
    \   |\n12 |     use std::fmt::Write;\n   |         ^^^^^^^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpq08xcjqr.rs:15:23\n   |\n15 |         if decimal >= 2_i32.pow(i)\
    \ {\n   |                       ^^^^^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |         if decimal >= 2_i32.pow(i).try_into().unwrap()\
    \ {\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq08xcjqr.rs:17:24\n   |\n17 |             decimal\
    \ -= 2_i32.pow(i);\n   |                        ^^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n\nerror[E0277]: cannot subtract-assign `i32` from `isize`\n  -->\
    \ /tmp/tmpq08xcjqr.rs:17:21\n   |\n17 |             decimal -= 2_i32.pow(i);\n\
    \   |                     ^^ no implementation for `isize -= i32`\n   |\n   =\
    \ help: the trait `SubAssign<i32>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `SubAssign<Rhs>`:\n             <f32\
    \ as SubAssign<&f32>>\n             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n\
    \             <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n  \
    \           <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n     \
    \        <i16 as SubAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut temp = decimal;\n    while temp != 0 {\n        result.push_str(&(temp\
    \ % 2).to_string());\n        temp /= 2;\n    }\n    result.push_str(\"db\");\n\
    \    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpjadmhuhq.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut input = decimal;\n    while input != 0 {\n        if input\
    \ % 2 == 0 {\n            binary.push('0');\n        } else {\n            binary.push('1');\n\
    \        }\n        input /= 2;\n    }\n    binary.push_str(\"db\");\n    binary\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpj1rc_u03.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut string = String::from(\"\
    db\");\n    let mut decimal = decimal;\n    loop {\n        string.push_str(&(decimal\
    \ % 2).to_string());\n        decimal /= 2;\n        if decimal == 0 {\n     \
    \       break;\n        }\n    }\n    string.push_str(\"db\");\n    string.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpbs6elv12.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut bin = String::from(\"\
    db\");\n    let mut decimal = decimal;\n    let mut num = 0;\n    while decimal\
    \ > 0 {\n        let remainder = decimal % 2;\n        num = remainder + num *\
    \ 10;\n        decimal = decimal / 2;\n    }\n    bin.push_str(&num.to_string());\n\
    \    bin.push_str(\"db\");\n    bin\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db1db\"`,\n right: `\"db100000db\"`', /tmp/tmpvot_s63b.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    assert!(decimal > 0);\n\
    \    let mut binary = String::from(\"db\");\n    let mut decimal = decimal;\n\
    \    while decimal > 0 {\n        binary.push(if decimal % 2 == 0 { '0' } else\
    \ { '1' });\n        decimal /= 2;\n    }\n    binary.push('d');\n    binary.push('b');\n\
    \    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: decimal > 0'', /tmp/tmpcoyi_t5e.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    // Collects binary string\n\
    \    let mut bin_str = String::from(\"db\");\n    // Constant to compare against\n\
    \    let mut compare = decimal;\n    // Iterate until compare reaches 0\n    while\
    \ compare != 0 {\n        // If compare is odd, add 1 to the start of the string,\
    \ else add 0\n        if compare % 2 == 1 {\n            bin_str.insert(2, '1');\n\
    \        } else {\n            bin_str.insert(2, '0');\n        }\n        //\
    \ Divide compare by 2\n        compare /= 2;\n    }\n    // Add ending character\n\
    \    bin_str.push_str(\"db\");\n    // Return bin_str\n    bin_str\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpdszsdve8.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = \"db\"\
    .to_string();\n    let mut number = decimal;\n    while number > 0 {\n       \
    \ binary.push_str(&(number % 2).to_string());\n        number /= 2;\n    }\n \
    \   binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpksb6pqhr.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = \"db\"\
    .to_string();\n    let mut x = decimal;\n    while x > 0 {\n        binary.push(std::char::from_digit((x\
    \ % 2) as u32, 10).unwrap());\n        x /= 2;\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpu2yz9iew.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    //Start typing your code\
    \ here.\n    let mut res = String::from(\"db\");\n    let mut tmp = decimal;\n\
    \    while tmp > 0 {\n        res.push_str(&format!(\"{}\", tmp % 2));\n     \
    \   tmp /= 2;\n    }\n    res.push_str(\"db\");\n    res.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpk405xmzv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::from(\"\
    db\");\n    let mut divisor = decimal;\n    while divisor > 0 {\n        if divisor\
    \ % 2 == 0 {\n            binary.push_str(\"0\");\n        } else {\n        \
    \    binary.push_str(\"1\");\n        }\n        divisor /= 2;\n    }\n    binary.push_str(\"\
    db\");\n    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpk0fy963a.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    format!(\"db{:b}db\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823180
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    return format!(\"db{}db\"\
    , format!(\"{:b}\", decimal));\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"\
    db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\n\
    fn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::from(\"\
    db\");\n    let mut number = decimal;\n    let mut remainder;\n    while number\
    \ > 0 {\n        remainder = number % 2;\n        number = number / 2;\n     \
    \   result.push_str(&remainder.to_string());\n    }\n    result.push_str(\"db\"\
    );\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpa8l_emlf.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
