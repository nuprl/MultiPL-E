language: rs
name: HumanEval_149_sorted_list_sum
results:
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp11t9fdif.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().collect();\n\
    \    lst.sort_by(|a, b| {\n        match a.len().cmp(&b.len()) {\n           \
    \ Ordering::Equal => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        }\n    });\n   \
    \ lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpzgdx40k4.rs:20:13\n   |\n20 |             Ordering::Equal => a.cmp(b),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpzgdx40k4.rs:21:13\n\
    \   |\n21 |             Ordering::Less => Ordering::Less,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpzgdx40k4.rs:21:31\n   |\n21 |    \
    \         Ordering::Less => Ordering::Less,\n   |                            \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpzgdx40k4.rs:22:13\n   |\n22\
    \ |             Ordering::Greater => Ordering::Greater,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpzgdx40k4.rs:22:34\n   |\n22 |    \
    \         Ordering::Greater => Ordering::Greater,\n   |                      \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp4iqetzpb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst.dedup();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp75oz0xhc.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    for i in lst\
    \ {\n        if i.len() % 2 == 0 {\n            result.push(i);\n        }\n \
    \   }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpspusn5en.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    fn sorted_list_sum_rec(lst: Vec<String>, acc: Vec<String>)\
    \ -> Vec<String> {\n        match lst.len() {\n            0 => acc,\n       \
    \     1 => {\n                if lst[0].len() % 2 == 0 {\n                   \
    \ let mut tmp = acc;\n                    tmp.push(lst[0].clone());\n        \
    \            return tmp;\n                }\n                acc\n           \
    \ }\n            _ => {\n                let (fst, rest) = lst.split_at(1);\n\
    \                if fst[0].len() % 2 == 0 {\n                    let mut tmp =\
    \ acc;\n                    tmp.push(fst[0].clone());\n                    sorted_list_sum_rec(rest.to_vec(),\
    \ tmp)\n                } else {\n                    sorted_list_sum_rec(rest.to_vec(),\
    \ acc)\n                }\n            }\n        }\n    }\n    sorted_list_sum_rec(lst,\
    \ vec![])\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp074tdlyy.rs:46:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let lst_len = lst.len();\n    let mut new_lst: Vec<String>\
    \ = Vec::new();\n    for i in 0..lst_len {\n        let s = lst[i].clone();\n\
    \        if s.len() % 2 == 0 {\n            new_lst.push(s);\n        }\n    }\n\
    \    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp0pnd6cqu.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|v| v.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpyixxpbf0.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpyixxpbf0.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut dict = HashMap::new();\n\
    \    for val in lst {\n        let len = val.len();\n        if !dict.contains_key(&len)\
    \ {\n            dict.insert(len, Vec::new());\n        }\n        let mut lst\
    \ = dict.get_mut(&len).unwrap();\n        lst.push(val);\n    }\n    let mut sorted_keys:\
    \ Vec<usize> = dict.keys().cloned().collect();\n    sorted_keys.sort();\n    for\
    \ key in sorted_keys {\n        let mut lst = dict.get_mut(&key).unwrap();\n \
    \       lst.sort();\n        result.append(lst);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpab0mp1lx.rs:18:20\n   |\n18 |     let mut dict = HashMap::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let result: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|s| s.len() % 2 == 0)\n        .collect();\n    result\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpfvhxbi74.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = Vec::new();\n    for i\
    \ in lst {\n        if is_even_length(&i) {\n            new_lst.push(i);\n  \
    \      }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_even_length` in this scope\n  -->\
    \ /tmp/tmp1ttpd97e.rs:19:12\n   |\n19 |         if is_even_length(&i) {\n   |\
    \            ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    for s in\
    \ lst {\n        if s.len() % 2 == 0 {\n            result.push(s);\n        }\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpprs0q8lh.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_mut = lst;\n    let mut lst_even = Vec::new();\n\
    \    let mut lst_odd = Vec::new();\n    for each in lst_mut.iter() {\n       \
    \ if each.len() % 2 == 0 {\n            lst_even.push(each.clone());\n       \
    \ } else {\n            lst_odd.push(each.clone());\n        }\n    }\n    for\
    \ each in lst_odd.iter() {\n        for (index, c) in lst_mut.iter().enumerate()\
    \ {\n            if c == each {\n                lst_mut.remove(index);\n    \
    \            break;\n            }\n        }\n    }\n    lst_mut.sort();\n  \
    \  lst_mut\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpe7sc7g8a.rs:47:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    lst.sort_by(|a, b| a.cmp(&b));\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpr1mfc8ek.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpq2o5_6dh.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpq2o5_6dh.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = vec![];\n    for item in\
    \ lst {\n        if item.len() % 2 == 0 {\n            new_lst.push(item);\n \
    \       }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpe7h_tmpz.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ let len_a = a.len();\n        let len_b = b.len();\n        if len_a == len_b\
    \ {\n            a.cmp(b)\n        } else {\n            len_a.cmp(&len_b)\n \
    \       }\n    });\n    let mut output: Vec<String> = Vec::new();\n    for item\
    \ in lst {\n        if item.len() % 2 == 0 {\n            output.push(item);\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst.sort_by(|a, b| a.cmp(&b));\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmps789kvso.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut res = Vec::new();\n    for s in lst {\n        if s.len() % 2 ==\
    \ 0 {\n            res.push(s);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpx62bwsbz.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut odd_len_lst = Vec::new();\n    let mut even_len_lst = Vec::new();\n\
    \    for string in lst {\n        if string.len() % 2 == 0 {\n            even_len_lst.push(string);\n\
    \        } else {\n            odd_len_lst.push(string);\n        }\n    }\n \
    \   lst.sort_by(|a, b| a.cmp(b));\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpzsautstb.rs:28:5\n\
    \    |\n17  |     let mut lst = lst;\n    |         ------- move occurs because\
    \ `lst` has type `Vec<String>`, which does not implement the `Copy` trait\n...\n\
    21  |     for string in lst {\n    |                   ---\n    |            \
    \       |\n    |                   `lst` moved due to this implicit call to `.into_iter()`\n\
    \    |                   help: consider borrowing to avoid moving into the for\
    \ loop: `&lst`\n...\n28  |     lst.sort_by(|a, b| a.cmp(b));\n    |     ^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822393
