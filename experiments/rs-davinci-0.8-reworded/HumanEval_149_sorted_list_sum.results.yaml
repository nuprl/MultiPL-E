language: rs
name: HumanEval_149_sorted_list_sum
results:
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp11t9fdif.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().collect();\n\
    \    lst.sort_by(|a, b| {\n        match a.len().cmp(&b.len()) {\n           \
    \ Ordering::Equal => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        }\n    });\n   \
    \ lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpzgdx40k4.rs:20:13\n   |\n20 |             Ordering::Equal => a.cmp(b),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpzgdx40k4.rs:21:13\n\
    \   |\n21 |             Ordering::Less => Ordering::Less,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpzgdx40k4.rs:21:31\n   |\n21 |    \
    \         Ordering::Less => Ordering::Less,\n   |                            \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpzgdx40k4.rs:22:13\n   |\n22\
    \ |             Ordering::Greater => Ordering::Greater,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpzgdx40k4.rs:22:34\n   |\n22 |    \
    \         Ordering::Greater => Ordering::Greater,\n   |                      \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp4iqetzpb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst.dedup();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp75oz0xhc.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    for i in lst\
    \ {\n        if i.len() % 2 == 0 {\n            result.push(i);\n        }\n \
    \   }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpspusn5en.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    fn sorted_list_sum_rec(lst: Vec<String>, acc: Vec<String>)\
    \ -> Vec<String> {\n        match lst.len() {\n            0 => acc,\n       \
    \     1 => {\n                if lst[0].len() % 2 == 0 {\n                   \
    \ let mut tmp = acc;\n                    tmp.push(lst[0].clone());\n        \
    \            return tmp;\n                }\n                acc\n           \
    \ }\n            _ => {\n                let (fst, rest) = lst.split_at(1);\n\
    \                if fst[0].len() % 2 == 0 {\n                    let mut tmp =\
    \ acc;\n                    tmp.push(fst[0].clone());\n                    sorted_list_sum_rec(rest.to_vec(),\
    \ tmp)\n                } else {\n                    sorted_list_sum_rec(rest.to_vec(),\
    \ acc)\n                }\n            }\n        }\n    }\n    sorted_list_sum_rec(lst,\
    \ vec![])\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp074tdlyy.rs:46:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let lst_len = lst.len();\n    let mut new_lst: Vec<String>\
    \ = Vec::new();\n    for i in 0..lst_len {\n        let s = lst[i].clone();\n\
    \        if s.len() % 2 == 0 {\n            new_lst.push(s);\n        }\n    }\n\
    \    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp0pnd6cqu.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|v| v.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpyixxpbf0.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpyixxpbf0.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut dict = HashMap::new();\n\
    \    for val in lst {\n        let len = val.len();\n        if !dict.contains_key(&len)\
    \ {\n            dict.insert(len, Vec::new());\n        }\n        let mut lst\
    \ = dict.get_mut(&len).unwrap();\n        lst.push(val);\n    }\n    let mut sorted_keys:\
    \ Vec<usize> = dict.keys().cloned().collect();\n    sorted_keys.sort();\n    for\
    \ key in sorted_keys {\n        let mut lst = dict.get_mut(&key).unwrap();\n \
    \       lst.sort();\n        result.append(lst);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpab0mp1lx.rs:18:20\n   |\n18 |     let mut dict = HashMap::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let result: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|s| s.len() % 2 == 0)\n        .collect();\n    result\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpfvhxbi74.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = Vec::new();\n    for i\
    \ in lst {\n        if is_even_length(&i) {\n            new_lst.push(i);\n  \
    \      }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_even_length` in this scope\n  -->\
    \ /tmp/tmp1ttpd97e.rs:19:12\n   |\n19 |         if is_even_length(&i) {\n   |\
    \            ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    for s in\
    \ lst {\n        if s.len() % 2 == 0 {\n            result.push(s);\n        }\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpprs0q8lh.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_mut = lst;\n    let mut lst_even = Vec::new();\n\
    \    let mut lst_odd = Vec::new();\n    for each in lst_mut.iter() {\n       \
    \ if each.len() % 2 == 0 {\n            lst_even.push(each.clone());\n       \
    \ } else {\n            lst_odd.push(each.clone());\n        }\n    }\n    for\
    \ each in lst_odd.iter() {\n        for (index, c) in lst_mut.iter().enumerate()\
    \ {\n            if c == each {\n                lst_mut.remove(index);\n    \
    \            break;\n            }\n        }\n    }\n    lst_mut.sort();\n  \
    \  lst_mut\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpe7sc7g8a.rs:47:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    lst.sort_by(|a, b| a.cmp(&b));\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpr1mfc8ek.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpq2o5_6dh.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpq2o5_6dh.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = vec![];\n    for item in\
    \ lst {\n        if item.len() % 2 == 0 {\n            new_lst.push(item);\n \
    \       }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpe7h_tmpz.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ let len_a = a.len();\n        let len_b = b.len();\n        if len_a == len_b\
    \ {\n            a.cmp(b)\n        } else {\n            len_a.cmp(&len_b)\n \
    \       }\n    });\n    let mut output: Vec<String> = Vec::new();\n    for item\
    \ in lst {\n        if item.len() % 2 == 0 {\n            output.push(item);\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst.sort_by(|a, b| a.cmp(&b));\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmps789kvso.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut res = Vec::new();\n    for s in lst {\n        if s.len() % 2 ==\
    \ 0 {\n            res.push(s);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpx62bwsbz.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut odd_len_lst = Vec::new();\n    let mut even_len_lst = Vec::new();\n\
    \    for string in lst {\n        if string.len() % 2 == 0 {\n            even_len_lst.push(string);\n\
    \        } else {\n            odd_len_lst.push(string);\n        }\n    }\n \
    \   lst.sort_by(|a, b| a.cmp(b));\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpzsautstb.rs:28:5\n\
    \    |\n17  |     let mut lst = lst;\n    |         ------- move occurs because\
    \ `lst` has type `Vec<String>`, which does not implement the `Copy` trait\n...\n\
    21  |     for string in lst {\n    |                   ---\n    |            \
    \       |\n    |                   `lst` moved due to this implicit call to `.into_iter()`\n\
    \    |                   help: consider borrowing to avoid moving into the for\
    \ loop: `&lst`\n...\n28  |     lst.sort_by(|a, b| a.cmp(b));\n    |     ^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut ret = lst.iter().cloned().filter(|s| s.len() %\
    \ 2 == 0).collect::<Vec<String>>();\n    ret.sort();\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmppjcnso22.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = vec![];\n    for x in lst\
    \ {\n        if x.len() % 2 == 0 {\n            new_lst.push(x)\n        }\n \
    \   }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpuryr2dbh.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut temp_list = lst.clone();\n    temp_list.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    temp_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpc8v5go6g.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted = lst.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    let mut prev =\
    \ 0;\n    let mut i = 0;\n    let mut result = Vec::new();\n    for item in sorted\
    \ {\n        if item.len() == prev {\n            i += 1;\n        } else {\n\
    \            if i % 2 == 0 {\n                result.push(item);\n           \
    \ }\n            prev = item.len();\n            i = 1;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `item`\n  --> /tmp/tmp1sa41m90.rs:35:20\n\
    \   |\n28 |     for item in sorted {\n   |         ----\n   |         |\n   |\
    \         this reinitialization might get skipped\n   |         move occurs because\
    \ `item` has type `String`, which does not implement the `Copy` trait\n...\n33\
    \ |                 result.push(item);\n   |                             ----\
    \ value moved here\n34 |             }\n35 |             prev = item.len();\n\
    \   |                    ^^^^^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut it = lst.into_iter().filter(|s| s.len() % 2 ==\
    \ 0);\n    let mut vec: Vec<String> = it.collect();\n    vec.sort();\n    vec\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp4mqzh8p6.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec: Vec<String> = Vec::new();\n    for x in lst\
    \ {\n        if x.len() % 2 == 0 {\n            vec.push(x);\n        }\n    }\n\
    \    vec.sort();\n    vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpluno6owp.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|s1, s2| {\n            let l1 = s1.len();\n            let\
    \ l2 = s2.len();\n            match l1.cmp(&l2) {\n                Ordering::Equal\
    \ => s1.cmp(s2),\n                otherwise => otherwise,\n            }\n   \
    \     })\n        .collect()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpyi83l68n.rs:23:17\n   |\n23 |                 Ordering::Equal => s1.cmp(s2),\n\
    \   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]:\
    \ no method named `sorted_by` found for struct `Filter` in the current scope\n\
    \  --> /tmp/tmpyi83l68n.rs:19:10\n   |\n19 |         .sorted_by(|s1, s2| {\n \
    \  |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmpyi83l68n.rs:18:17: 18:37]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    for word in\
    \ lst {\n        if word.len() % 2 == 0 {\n            res.push(word);\n     \
    \   }\n    }\n    res.sort();\n    res\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpgx73qikh.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp4iqetzpb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut filter: Vec<String> = Vec::new();\n    for idx in 0..lst.len() {\n\
    \        if idx % 2 == 0 {\n            filter.push(lst[idx].clone());\n     \
    \   }\n    }\n    filter\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpgnvtlc8k.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|word| word.len() % 2\
    \ == 0)\n        .sorted_by(|a, b| {\n            // sort by length first\n  \
    \          a.len().cmp(&b.len())\n                // then sort by alphabetical\
    \ order\n                .then(a.cmp(b))\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp4caak016.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmp4caak016.rs:18:17: 18:43]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut odd_len_words: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|x| x.len() % 2 == 0)\n        .collect();\n    odd_len_words.sort();\n\
    \    odd_len_words\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n \
    \   assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpghp3pjmf.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|s1, s2| {\n            s1.len()\n                .cmp(&s2.len())\n\
    \                .then_with(|| s1.cmp(&s2))\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp34kv1ymz.rs:19:10\n   |\n19 |         .sorted_by(|s1,\
    \ s2| {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmp34kv1ymz.rs:18:17: 18:37]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut nlst: Vec<String> = Vec::new();\n    lst.iter().for_each(|word|\
    \ {\n        if word.len() % 2 == 0 {\n            nlst.push(word.clone());\n\
    \        }\n    });\n    nlst.sort_by(|a, b| {\n        let length_a = a.len();\n\
    \        let length_b = b.len();\n        if length_a == length_b {\n        \
    \    a.cmp(b)\n        } else {\n            length_a.cmp(&length_b)\n       \
    \ }\n    });\n    nlst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = Vec::new();\n    for word\
    \ in lst {\n        if word.len() % 2 == 0 {\n            new_lst.push(word);\n\
    \        }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp7vjsc_1v.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|string| string.len()\
    \ % 2 == 0)\n        .sorted_by(|a, b| {\n            if a.len() != b.len() {\n\
    \                a.len().cmp(&b.len())\n            } else {\n               \
    \ a.cmp(b)\n            }\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp97r0u196.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmp97r0u196.rs:18:17: 18:47]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    if lst.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let len = lst[0].len();\n    let mut cpy = lst.clone();\n    let mut sum\
    \ = vec![];\n\n    cpy.sort();\n\n    while !cpy.is_empty() {\n        if len\
    \ == cpy[0].len() {\n            sum.push(cpy.remove(0));\n        } else {\n\
    \            break;\n        }\n    }\n\n    return sum;\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"aa\"]`', /tmp/tmpa83f62c7.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // TODO Write this function\n    lst\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpcbq5j7jo.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // TODO: Implement this function and remove this line.\n\
    \    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpuwgyl8cd.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ a.len().cmp(&b.len())\n            .then_with(|| a.as_str().cmp(b.as_str()))\n\
    \    });\n    let mut new_lst = Vec::new();\n    let mut last_str = \"\".to_string();\n\
    \    for word in lst {\n        if word.len() != last_str.len() {\n          \
    \  new_lst.push(word);\n        }\n        last_str = word;\n    }\n    new_lst\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `word`\n  --> /tmp/tmp_qod3cqw.rs:28:20\n\
    \   |\n24 |     for word in lst {\n   |         ----\n   |         |\n   |   \
    \      this reinitialization might get skipped\n   |         move occurs because\
    \ `word` has type `String`, which does not implement the `Copy` trait\n25 |  \
    \       if word.len() != last_str.len() {\n26 |             new_lst.push(word);\n\
    \   |                          ---- value moved here\n27 |         }\n28 |   \
    \      last_str = word;\n   |                    ^^^^ value used here after move\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // let mut lst = lst;\n    // lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    // let mut it = lst.iter();\n    // let mut odd_len = false;\n    // loop\
    \ {\n    //     match it.next() {\n    //         Some(e) => {\n    //       \
    \      if e.len() % 2 == 1 {\n    //                 odd_len = true;\n    // \
    \                break;\n    //             }\n    //         }\n    //      \
    \   None => break,\n    //     }\n    // }\n    // let odd_len_lst = lst.into_iter().filter(|e|\
    \ e.len() % 2 == 1).collect();\n    // if odd_len {\n    //     odd_len_lst\n\
    \    // } else {\n    //     lst\n    // }\n    lst.into_iter()\n        .filter(|e|\
    \ e.len() % 2 == 1)\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n   \
    \ let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpzmv3aasn.rs:45:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_iter = lst.iter();\n    let mut result = vec![];\n\
    \    if let Some(s) = lst_iter.next() {\n        let len = s.len();\n        let\
    \ mut lst_to_sum = vec![s.clone()];\n        while let Some(s) = lst_iter.next()\
    \ {\n            if s.len() == len {\n                lst_to_sum.push(s.clone());\n\
    \            } else {\n                result.push(sum_strings(&lst_to_sum));\n\
    \                lst_to_sum = vec![s.clone()];\n                len = s.len();\n\
    \            }\n        }\n        result.push(sum_strings(&lst_to_sum));\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum_strings` in this scope\n  --> /tmp/tmpw_9huxcc.rs:26:29\n\
    \   |\n26 |                 result.push(sum_strings(&lst_to_sum));\n   |     \
    \                        ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `sum_strings` in this scope\n  --> /tmp/tmpw_9huxcc.rs:31:21\n\
    \   |\n31 |         result.push(sum_strings(&lst_to_sum));\n   |             \
    \        ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Iterate from the end of the vec and remove strings\
    \ with odd length\n    for i in (0..lst.len()).rev() {\n        if lst[i].len()\
    \ % 2 != 0 {\n            lst.remove(i);\n        }\n    }\n    // Sort the vector\
    \ with the following rules\n    lst.sort_by(|a, b| {\n        // Sort by length\n\
    \        let length_cmp = a.len().cmp(&b.len());\n        if length_cmp == std::cmp::Ordering::Equal\
    \ {\n            // If two words have the same length, sort the vector alphabetically\n\
    \            a.cmp(&b)\n        } else {\n            length_cmp\n        }\n\
    \    });\n    // Return the sorted vector\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8dxo1jk3.rs:20:13\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n...\n20 |             lst.remove(i);\n   |  \
    \           ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `lst` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8dxo1jk3.rs:24:5\n\
    \   |\n16 |   fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    \
    \                  --- help: consider changing this to be mutable: `mut lst`\n\
    ...\n24 | /     lst.sort_by(|a, b| {\n25 | |         // Sort by length\n26 | |\
    \         let length_cmp = a.len().cmp(&b.len());\n27 | |         if length_cmp\
    \ == std::cmp::Ordering::Equal {\n...  |\n32 | |         }\n33 | |     });\n \
    \  | |______^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut lst: Vec<String>\
    \ = lst.into_iter().filter(|s| (s.len() % 2) == 0).collect();\n    lst.sort();\n\
    \    result.append(&mut lst);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpb_bfqlue.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let even = lst.into_iter().filter(|s| s.len() % 2 == 0).collect::<Vec<String>>();\n\
    \    let mut odd = lst.into_iter().filter(|s| s.len() % 2 != 0).collect::<Vec<String>>();\n\
    \    odd.sort();\n    even.into_iter().chain(odd.into_iter()).collect()\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmph02pvw9e.rs:18:19\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n17  |     let even = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect::<Vec<String>>();\n    |                    -----------\
    \ `lst` moved due to this method call\n18  |     let mut odd = lst.into_iter().filter(|s|\
    \ s.len() % 2 != 0).collect::<Vec<String>>();\n    |                   ^^^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `lst`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Note: `drain` is not working on `lst` because it is\
    \ a `Vec<String>` and not a `Vec<&str>`\n    //       This is because we cannot\
    \ use a `String` in a case where the compiler expects `&str`\n    let mut lst\
    \ = lst;\n    lst.retain(|s| s.len() % 2 == 0);\n\n    lst.sort_by(|a, b| {\n\
    \        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n   \
    \         a.len().cmp(&b.len())\n        }\n    });\n\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979893
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ let a_len = a.len();\n        let b_len = b.len();\n        if a_len < b_len\
    \ {\n            std::cmp::Ordering::Less\n        } else if a_len > b_len {\n\
    \            std::cmp::Ordering::Greater\n        } else {\n            a.cmp(b)\n\
    \        }\n    });\n    let mut i = 0;\n    while i < lst.len() {\n        if\
    \ lst[i].len() % 2 == 1 {\n            lst.remove(i);\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979893
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ a.len().cmp(&b.len())\n            .then_with(|| a.cmp(&b))\n    });\n    lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979893
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort_by(|a, b| {\n        if a.len() ==\
    \ b.len() {\n            return a.cmp(b);\n        } else {\n            return\
    \ a.len().cmp(&b.len());\n        }\n    });\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| if a.len() == b.len() {\n            a.cmp(b)\n   \
    \     } else {\n            a.len().cmp(&b.len())\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp8c51ukyx.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| if a.len() == b.len() {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmp8c51ukyx.rs:18:17: 18:37]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp4iqetzpb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut iter = lst.into_iter().filter(|x| x.len() % 2\
    \ == 0);\n    iter.collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpnz30ko3q.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<_> = lst.into_iter().map(|x| (x.len(),\
    \ x)).collect();\n    lst.sort();\n    lst.into_iter().map(|x| x.1).collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpfbbjt2y9.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_odd: Vec<String> = Vec::new();\n    for s\
    \ in lst {\n        if s.len() % 2 == 1 {\n            lst_odd.push(s);\n    \
    \    }\n    }\n    lst_odd.sort();\n    lst_odd\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpxk7lbo7f.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let even_len_words: Vec<&str> = lst\n        .iter()\n\
    \        .map(|s| s.as_str())\n        .filter(|s| (s.len() % 2) == 0)\n     \
    \   .collect();\n    let mut sorted_words: Vec<&str> = even_len_words.iter().collect();\n\
    \    sorted_words.sort_by(|a, b| (a.len()).cmp(&b.len()));\n    let mut result:\
    \ Vec<String> = sorted_words.iter().map(|s| s.to_string()).collect();\n    result.sort();\n\
    \    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `&&str`\n    --> /tmp/tmpxwtafsmx.rs:22:61\n     |\n22\
    \   |     let mut sorted_words: Vec<&str> = even_len_words.iter().collect();\n\
    \     |                                                             ^^^^^^^ value\
    \ of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=&&str>`\n\
    \     |\n     = help: the trait `FromIterator<&&str>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let lst = lst.into_iter().filter(|s| s.len() % 2 == 0).collect::<Vec<String>>();\n\
    \    lst.sort_by(|a, b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n\
    \        } else {\n            a.len().cmp(&b.len())\n        }\n    });\n   \
    \ lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpl_kek6kx.rs:18:5\n   |\n17 |       let lst = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect::<Vec<String>>();\n   |           --- help: consider\
    \ changing this to be mutable: `mut lst`\n18 | /     lst.sort_by(|a, b| {\n19\
    \ | |         if a.len() == b.len() {\n20 | |             a.cmp(b)\n21 | |   \
    \      } else {\n22 | |             a.len().cmp(&b.len())\n23 | |         }\n\
    24 | |     });\n   | |______^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = lst.clone();\n    sorted_list.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpj5pojyca.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sum = Vec::new();\n    for i in lst {\n      \
    \  if i.len() % 2 == 0 {\n            sum.push(i);\n        }\n    }\n    sum.sort();\n\
    \    sum\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmptpr5hpbi.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| match a.len().cmp(&b.len()) {\n            Ordering::Equal\
    \ => a.cmp(b),\n            other => other,\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp_1ui5kqk.rs:20:13\n   |\n20 |             Ordering::Equal => a.cmp(b),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]:\
    \ no method named `sorted_by` found for struct `Filter` in the current scope\n\
    \  --> /tmp/tmp_1ui5kqk.rs:19:10\n   |\n19 |         .sorted_by(|a, b| match a.len().cmp(&b.len())\
    \ {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmp_1ui5kqk.rs:18:17: 18:37]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n    for item in lst {\n\
    \        if item.len() % 2 == 0 {\n            sorted_lst.push(item);\n      \
    \  }\n    }\n    sorted_lst.sort();\n    sorted_lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmplu4k6fyq.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut v = lst;\n    v.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut result = Vec::new();\n    let mut i = 0;\n    while i < v.len() {\n\
    \        let mut j = i + 1;\n        while j < v.len() && v[i].len() == v[j].len()\
    \ {\n            j += 1;\n        }\n        if (j - i) % 2 == 0 {\n         \
    \   result.push(v[i].clone());\n        }\n        i = j;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"aa\"]`', /tmp/tmpsj5la1wk.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| {\n            if a.len() == b.len() {\n          \
    \      a.cmp(b)\n            } else {\n                a.len().cmp(&b.len())\n\
    \            }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp7thidpel.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmp7thidpel.rs:18:17: 18:37]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ if a.len() != b.len() {\n            a.len().cmp(&b.len())\n        } else {\n\
    \            a.cmp(&b)\n        }\n    });\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp9b53kwl9.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst.dedup();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp75oz0xhc.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|s| s.len() % 2 == 0)\n        .collect();\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmptomte5_9.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp4iqetzpb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp2eodsziq.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmp2eodsziq.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut odd_lst: Vec<String> = Vec::new();\n    let mut\
    \ even_lst: Vec<String> = Vec::new();\n    let mut sorted_lst: Vec<String> = Vec::new();\n\
    \    for num in lst {\n        if num.len() % 2 == 0 {\n            even_lst.push(num);\n\
    \        } else {\n            odd_lst.push(num);\n        }\n    }\n    odd_lst.sort();\n\
    \    odd_lst.reverse();\n    even_lst.sort();\n    for num in even_lst {\n   \
    \     sorted_lst.push(num);\n    }\n    for num in odd_lst {\n        sorted_lst.push(num);\n\
    \    }\n    sorted_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"aaa\", \"a\"]`,\n right: `[\"aa\"]`', /tmp/tmpjhyqsfxh.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst.dedup();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp75oz0xhc.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted = lst.clone();\n    sorted.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    let mut final_vec = Vec::new();\n    let mut\
    \ sum = 0;\n    for i in sorted {\n        final_vec.push(i);\n        sum +=\
    \ i.len();\n    }\n    println!(\"sum = {}\", sum);\n    final_vec\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `i`\n  --> /tmp/tmp449onipd.rs:23:16\n\
    \   |\n21 |     for i in sorted {\n   |         - move occurs because `i` has\
    \ type `String`, which does not implement the `Copy` trait\n22 |         final_vec.push(i);\n\
    \   |                        - value moved here\n23 |         sum += i.len();\n\
    \   |                ^^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    //let answer = lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let answer = lst\n        .into_iter()\n        .filter(|s| s.len() % 2 ==\
    \ 0)\n        .collect::<Vec<String>>();\n    let answer = answer\n        .iter()\n\
    \        .map(|s| s.to_string())\n        .collect::<Vec<String>>();\n    answer\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp80cr0dxu.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut odd_list = Vec::new();\n\
    \    let mut even_list = Vec::new();\n    let mut alpha_list = Vec::new();\n \
    \   for el in lst {\n        if el.len() % 2 == 0 {\n            even_list.push(el);\n\
    \        } else {\n            odd_list.push(el);\n        }\n    }\n    for mut\
    \ el in even_list {\n        for _ in 0..odd_list.len() {\n            let mut\
    \ alpha_even_list = Vec::new();\n            for i in odd_list.clone() {\n   \
    \             alpha_even_list.push(i);\n            }\n            for j in odd_list.clone()\
    \ {\n                if j.len() > el.len() {\n                    alpha_even_list.push(el);\n\
    \                    el = String::from(\"\");\n                }\n           \
    \ }\n            if el != \"\" {\n                alpha_even_list.push(el);\n\
    \            }\n            odd_list = alpha_even_list;\n        }\n    }\n  \
    \  for el in odd_list {\n        alpha_list.push(el);\n    }\n    alpha_list.sort();\n\
    \    for el in alpha_list {\n        result.push(el);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `el`\n  --> /tmp/tmp3mpdlq6s.rs:35:30\n\
    \   |\n28 |     for mut el in even_list {\n   |         ------ move occurs because\
    \ `el` has type `String`, which does not implement the `Copy` trait\n...\n35 |\
    \                 if j.len() > el.len() {\n   |                              ^^^^^^^^\
    \ value borrowed here after move\n...\n41 |                 alpha_even_list.push(el);\n\
    \   |                                      -- value moved here, in previous iteration\
    \ of loop\n   |\nnote: these 2 reinitializations might get skipped\n  --> /tmp/tmp3mpdlq6s.rs:28:9\n\
    \   |\n28 |     for mut el in even_list {\n   |         ^^^^^^\n...\n37 |    \
    \                 el = String::from(\"\");\n   |                     ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|word| word.len() % 2 == 0)\n        .collect();\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpjec6u9oy.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpa9j4dq_2.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|word| word.len() % 2 == 0)\n        .collect();\n    lst.sort_by(|a,\
    \ b| {\n        let ord_by_length = a.len().cmp(&b.len());\n        if ord_by_length\
    \ == Ordering::Equal {\n            a.cmp(b)\n        } else {\n            ord_by_length\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpzb8nx45n.rs:23:29\n   |\n23 |         if ord_by_length == Ordering::Equal\
    \ {\n   |                             ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Accept a vector and return a sorted vector\n    if\
    \ lst.len() == 0 {\n        vec![]\n    } else {\n        let mut tmp_lst = lst.clone();\n\
    \        tmp_lst.sort_by(|a, b| {\n            let a_len = a.len();\n        \
    \    let b_len = b.len();\n            if a_len % 2 == 0 && b_len % 2 == 0 {\n\
    \                a_len.cmp(&b_len)\n            } else if a_len % 2 == 0 && b_len\
    \ % 2 != 0 {\n                Ordering::Less\n            } else if a_len % 2\
    \ != 0 && b_len % 2 == 0 {\n                Ordering::Greater\n            } else\
    \ {\n                Ordering::Equal\n            }\n        });\n        tmp_lst\n\
    \    }\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpqbbbf2sx.rs:28:17\n   |\n28 |                 Ordering::Less\n   | \
    \                ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpqbbbf2sx.rs:30:17\n\
    \   |\n30 |                 Ordering::Greater\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpqbbbf2sx.rs:32:17\n   |\n32 |               \
    \  Ordering::Equal\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|x, y| x.len().cmp(&y.len()).then(x.cmp(y)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp9eqnmhek.rs:19:10\n   |\n19 |         .sorted_by(|x,\
    \ y| x.len().cmp(&y.len()).then(x.cmp(y)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmp9eqnmhek.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| {\n            if a.len() == b.len() {\n          \
    \      a.cmp(b)\n            } else {\n                a.len().cmp(&b.len())\n\
    \            }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp8q93aruz.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmp8q93aruz.rs:18:17: 18:37]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // your code here\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppn2az04w.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut x = lst.clone();\n    for i in x.iter_mut() {\n\
    \        let mut x = Vec::new();\n        for j in i.chars() {\n            if\
    \ j.is_ascii_alphabetic() {\n                x.push(j);\n            }\n     \
    \   }\n        x.sort();\n        i.clear();\n        for j in x {\n         \
    \   i.push(j);\n        }\n    }\n    x.sort();\n    let mut y = Vec::new();\n\
    \    for i in x {\n        if i.len() % 2 == 0 {\n            y.push(i);\n   \
    \     }\n    }\n    y\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"AI\", \"adfs\", \"chloos\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpt4qwt9e9.rs:44:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let odd_lst: Vec<String> = lst.into_iter().filter(|s|\
    \ is_odd_length(&s)).collect();\n    let mut sorter = odd_lst.clone();\n    sorter.sort();\n\
    \    sorter\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_odd_length` in this scope\n  -->\
    \ /tmp/tmp8wo1l2gf.rs:17:59\n   |\n17 |     let odd_lst: Vec<String> = lst.into_iter().filter(|s|\
    \ is_odd_length(&s)).collect();\n   |                                        \
    \                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sum = vec![];\n    for word in lst {\n       \
    \ if word.len() % 2 == 0 {\n            sum.push(word);\n        }\n    }\n  \
    \  sum.sort();\n    sum\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpmms6v5_m.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpmb4kiofa.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ let lena = a.len();\n        let lenb = b.len();\n        if lena != lenb {\n\
    \            lena.cmp(&lenb)\n        } else {\n            a.cmp(b)\n       \
    \ }\n    });\n    let mut index = 0;\n    let mut len = lst.len();\n    while\
    \ index < len {\n        if index + 1 < len && lst[index].len() == lst[index +\
    \ 1].len() {\n            lst.remove(index);\n            len -= 1;\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    lst\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp6nf2rg5s.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    for i in\
    \ lst {\n        if i.len() % 2 == 0 {\n            result.push(i);\n        }\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpekc2qzrr.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut even_lst: Vec<String> = vec![];\n    let mut odd_lst:\
    \ Vec<String> = vec![];\n    for i in lst {\n        if i.len() % 2 == 0 {\n \
    \           even_lst.push(i);\n        } else {\n            odd_lst.push(i);\n\
    \        }\n    }\n    even_lst.sort();\n    odd_lst.sort();\n    odd_lst.append(&mut\
    \ even_lst);\n    odd_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\", \"aa\"]`,\n right: `[\"aa\"]`', /tmp/tmp7d8ncd5r.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().collect();\n\
    \    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpf6u7hs2e.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| (a.len(), a).cmp(&(b.len(), b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpbe2d7_13.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| (a.len(), a).cmp(&(b.len(), b)))\n   |          ^^^^^^^^^ method not found\
    \ in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpbe2d7_13.rs:18:17: 18:37]>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_copy = lst.clone();\n    lst_copy.sort_by(|a,\
    \ b| b.len().cmp(&a.len()));\n    let mut sorted_lst = Vec::new();\n    for item\
    \ in lst_copy {\n        if item.len() % 2 == 0 {\n            sorted_lst.push(item);\n\
    \        }\n    }\n    sorted_lst.sort_by(|a, b| a.len().cmp(&b.len()));\n   \
    \ sorted_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmptbxns_e0.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec = Vec::new();\n    for item in lst {\n   \
    \     if item.len() % 2 == 0 {\n            vec.push(item);\n        }\n    }\n\
    \    vec.sort();\n    vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpr2rbg708.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sort_list = Vec::new();\n    let mut even_list\
    \ = Vec::new();\n    let mut odd_list = Vec::new();\n    let mut sorted_list =\
    \ Vec::new();\n    for s in lst {\n        if s.len() % 2 == 0 {\n           \
    \ even_list.push(s);\n        } else {\n            odd_list.push(s);\n      \
    \  }\n    }\n    even_list.sort();\n    odd_list.sort();\n    sorted_list.append(&mut\
    \ even_list);\n    sorted_list.append(&mut odd_list);\n    for i in sorted_list\
    \ {\n        if i.len() % 2 == 0 {\n            sort_list.push(i);\n        }\n\
    \    }\n    sort_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmptpvitua6.rs:48:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ temp: Vec<String> = Vec::new();\n    let mut temp_list: Vec<String> = Vec::new();\n\
    \    let mut current_length = 0;\n    for item in lst {\n        if item.len()\
    \ % 2 == 0 {\n            result.push(item);\n        }\n    }\n    // Sort the\
    \ vector by length of the string\n    result.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    // Now sort the vector by alphabetically\n    for item in result {\n    \
    \    temp_list.push(item);\n        if item.len() > current_length {\n       \
    \     temp_list.sort();\n            for sorted_item in temp_list {\n        \
    \        temp.push(sorted_item);\n            }\n            temp_list.clear();\n\
    \            current_length = item.len();\n        }\n    }\n    temp\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `temp_list`\n   --> /tmp/tmpdfk7ki_h.rs:30:9\n\
    \    |\n19  |     let mut temp_list: Vec<String> = Vec::new();\n    |        \
    \ ------------- move occurs because `temp_list` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n30  |         temp_list.push(item);\n\
    \    |         ^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n...\n33  |\
    \             for sorted_item in temp_list {\n    |                          \
    \      --------- `temp_list` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `temp_list`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n33  |             for sorted_item in &temp_list {\n    |             \
    \                   +\n\nerror[E0382]: borrow of moved value: `item`\n  --> /tmp/tmpdfk7ki_h.rs:31:12\n\
    \   |\n29 |     for item in result {\n   |         ---- move occurs because `item`\
    \ has type `String`, which does not implement the `Copy` trait\n30 |         temp_list.push(item);\n\
    \   |                        ---- value moved here\n31 |         if item.len()\
    \ > current_length {\n   |            ^^^^^^^^^^ value borrowed here after move\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp11t9fdif.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822393
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut v: Vec<String> = lst\n        .into_iter()\n \
    \       .filter(|x| x.len() % 2 == 0)\n        .collect();\n    v.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    v\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vector: Vec<String> = Vec::new();\n    let mut\
    \ even_strings: Vec<String> = Vec::new();\n    for string in lst {\n        if\
    \ (string.len() % 2) == 0 {\n            even_strings.push(string);\n        }\n\
    \    }\n    even_strings.sort();\n    vector.append(&mut even_strings);\n    vector\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp93fsgocw.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut len_sorted_lst: Vec<String> = lst.clone();\n \
    \   len_sorted_lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    len_sorted_lst\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpmo5wuo2l.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    let mut str_vec:\
    \ Vec<&str> = Vec::new();\n    for word in lst {\n        if word.len() % 2 ==\
    \ 0 {\n            str_vec.push(&word);\n        }\n    }\n    str_vec.sort();\n\
    \    for word in str_vec {\n        res.push(String::from(word));\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `word` does not live long enough\n  --> /tmp/tmpvw519c1y.rs:21:26\n\
    \   |\n21 |             str_vec.push(&word);\n   |                          ^^^^^\
    \ borrowed value does not live long enough\n22 |         }\n23 |     }\n   | \
    \    - `word` dropped here while still borrowed\n24 |     str_vec.sort();\n  \
    \ |     -------------- borrow later used here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0597`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpmb4kiofa.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpa9j4dq_2.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Write a function that accepts a vector of strings as\
    \ a parameter,\n    // deletes the strings that have odd lengths from it,\n  \
    \  // and returns the resulted vector with a sorted order,\n    // The vector\
    \ is always a vector of strings and never a vector of numbers,\n    // and it\
    \ may contain duplicates.\n    // The order of the vector should be ascending\
    \ by length of each word, and you\n    // should return the vector sorted by that\
    \ rule.\n    // If two words have the same length, sort the vector alphabetically.\n\
    \    // The function should return a vector of strings in sorted order.\n    //\
    \ You may assume that all words will have the same length.\n    // For example:\n\
    \    // >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")])\n    // vec![String::from(\"aa\")]\n    // >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n  \
    \  // vec![String::from(\"ab\"), String::from(\"cd\")]\n    let mut lst = lst;\n\
    \    let mut ret: Vec<String> = Vec::new();\n    loop {\n        let mut min =\
    \ std::usize::MAX;\n        let mut min_str = String::new();\n        let mut\
    \ min_str_idx = std::usize::MAX;\n        let mut min_str_inserted = false;\n\
    \        let mut idx = 0;\n        for i in &lst {\n            if i.len() ==\
    \ min {\n                if min_str.cmp(&i) == std::cmp::Ordering::Greater {\n\
    \                    min_str = i.clone();\n                    min_str_idx = idx;\n\
    \                    min_str_inserted = false;\n                }\n          \
    \  } else if i.len() < min {\n                min = i.len();\n               \
    \ min_str = i.clone();\n                min_str_idx = idx;\n                min_str_inserted\
    \ = false;\n            }\n            idx += 1;\n        }\n        if min_str_idx\
    \ != std::usize::MAX && !min_str_\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpj4peqzyo.rs:67:3\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n34\
    \ |     loop {\n   |          - this delimiter might not be properly closed...\n\
    ...\n56 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    67 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpj4peqzyo.rs:56:1\n\
    \   |\n55 |         if min_str_idx != std::usize::MAX && !min_str_\n   |     \
    \    -- this `if` expression has a condition, but no block\n56 | }\n   | ^ expected\
    \ `{`\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut sum = 0;\n    for x in &lst {\n        sum += x.len();\n    }\n \
    \   vec![lst.iter().map(|x| x.clone()).collect(), sum.to_string()]\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaaaa\", \"6\"]`,\n right: `[\"aa\"]`', /tmp/tmptautqjgv.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    for word in lst\
    \ {\n        if word.len() % 2 == 0 {\n            sorted_list.push(word)\n  \
    \      }\n    }\n    sorted_list.sort();\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpup05dw4_.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut s = lst.iter().cloned().collect::<Vec<String>>();\n\
    \    s.sort_by(|a, b| {\n        if a.len() != b.len() {\n            a.len().cmp(&b.len())\n\
    \        } else {\n            a.cmp(&b)\n        }\n    });\n    s\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp671ewdnq.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    //     let mut sorted_lst = Vec::new();\n    //     for\
    \ element in lst {\n    //         if element.len() % 2 == 0 {\n    //       \
    \      sorted_lst.push(element);\n    //         }\n    //     }\n    //     sorted_lst.sort();\n\
    \    //     sorted_lst\n    lst.into_iter()\n        .filter(|x| x.len() % 2 ==\
    \ 0)\n        .collect::<Vec<String>>()\n        .sort();\n    vec![]\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"aa\"]`', /tmp/tmp6eelokzl.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpkgzb66qr.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut even_list: Vec<String> = Vec::new();\n    let\
    \ mut odd_list: Vec<String> = Vec::new();\n    let mut final_list: Vec<String>\
    \ = Vec::new();\n    for s in lst {\n        if (s.len() % 2) == 0 {\n       \
    \     even_list.push(s);\n        } else {\n            odd_list.push(s);\n  \
    \      }\n    }\n    even_list.sort();\n    odd_list.sort();\n    for s in even_list\
    \ {\n        final_list.push(s);\n    }\n    for s in odd_list {\n        final_list.push(s);\n\
    \    }\n    final_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpbpqxsqhe.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = vec![];\n    for elem in\
    \ lst {\n        if elem.len() % 2 == 0 {\n            new_lst.push(elem);\n \
    \       }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpw8ymiz3b.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_res = lst.clone();\n    lst_res.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    let len = lst_res.len();\n    let mut lst_even\
    \ = Vec::new();\n    for i in 0..len {\n        if i % 2 == 0 {\n            lst_even.push(lst_res[i].clone());\n\
    \        }\n    }\n    return lst_even;\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpjl24432o.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|word| word.len() % 2 == 0)\n        .collect();\n    lst.sort_by(|a,\
    \ b| b.len().cmp(&a.len()));\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"asdf\", \"AI\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp99ottdol.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|n| n.len() % 2 == 0)\n        .collect();\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpj7okof4o.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    let mut res = Vec::new();\n  \
    \  let mut odd = false;\n    let mut even = false;\n    for x in lst.iter() {\n\
    \        if x.len() % 2 == 0 {\n            even = true;\n        } else {\n \
    \           odd = true;\n        }\n    }\n    if odd && even {\n        lst.retain(|x|\
    \ x.len() % 2 == 0);\n    }\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    for x in lst.iter() {\n        if x.len() % 2 == 0 {\n            res.push(x.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmphyfn7k3v.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut new_lst = vec![];\n    let mut l = 0;\n    while l < lst.len() {\n\
    \        if lst[l].len() % 2 == 0 {\n            new_lst.push(lst[l].clone());\n\
    \        }\n        l += 1;\n    }\n    new_lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmp4qmar3bv.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // iterate through the lst\n    // if the length is even\
    \ add to a new vector\n    // then sort the vector alphabetically\n\n    let mut\
    \ even_vector: Vec<String> = Vec::new();\n\n    for str in lst {\n        if str.len()\
    \ % 2 == 0 {\n            even_vector.push(str);\n        }\n    }\n\n    even_vector.sort();\n\
    \n    even_vector\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n  \
    \  assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpe523fzis.rs:42:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|string| string.len()\
    \ % 2 == 0)\n        .sorted_by(|a, b| a.len().cmp(&b.len()))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpw7orafc2.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()))\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmpw7orafc2.rs:18:17: 18:47]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|w| w.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp8x75mah0.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Note: this function is not allowed to use the sort()\
    \ method.\n    let mut lst = lst;\n    let mut sorted_list = Vec::new();\n   \
    \ while !lst.is_empty() {\n        // Find the minimum element.\n        let min_idx\
    \ = lst.iter().enumerate().min_by_key(|x| x.1).unwrap().0;\n        sorted_list.push(lst.remove(min_idx));\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp2vyvlrot.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sum: Vec<String> = Vec::new();\n    let mut sorted_list:\
    \ Vec<String> = lst;\n    sorted_list.sort();\n    let mut i = 0;\n    while i\
    \ < sorted_list.len() {\n        let mut j = i + 1;\n        while j < sorted_list.len()\
    \ {\n            if sorted_list[i].len() == sorted_list[j].len() {\n         \
    \       j += 1;\n            } else {\n                break;\n            }\n\
    \        }\n        let mut sum_num = String::new();\n        for k in i..j {\n\
    \            sum_num.push_str(&sorted_list[k]);\n        }\n        sum.push(sum_num);\n\
    \        i = j;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmppndr6y6n.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut odd_lengths = Vec::new();\n    let mut even_lengths\
    \ = Vec::new();\n    let mut result = Vec::new();\n\n    for (i, word) in lst.iter().enumerate()\
    \ {\n        if word.len() % 2 == 0 {\n            even_lengths.push(lst[i].clone());\n\
    \        } else {\n            odd_lengths.push(lst[i].clone());\n        }\n\
    \    }\n\n    even_lengths.sort();\n    odd_lengths.sort();\n\n    for (i, word)\
    \ in even_lengths.iter().enumerate() {\n        result.push(even_lengths[i].clone());\n\
    \    }\n\n    for (i, word) in odd_lengths.iter().enumerate() {\n        result.push(odd_lengths[i].clone());\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmph9o4sfv4.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    fn list_sort(lst: Vec<String>) -> Vec<String> {\n    \
    \    let mut lst = lst;\n        lst.sort_by(|a, b| {\n            let alen =\
    \ a.len();\n            let blen = b.len();\n            if alen > blen {\n  \
    \              Ordering::Greater\n            } else if alen < blen {\n      \
    \          Ordering::Less\n            } else {\n                a.cmp(b)\n  \
    \          }\n        });\n        lst\n    }\n    list_sort(lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect())\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmprxe_yqoo.rs:23:17\n   |\n23 |                 Ordering::Greater\n  \
    \ |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmprxe_yqoo.rs:25:17\n\
    \   |\n25 |                 Ordering::Less\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    for i in lst\
    \ {\n        if i.len() % 2 == 0 {\n            res.push(i);\n        }\n    }\n\
    \    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmppdpnwj5e.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut list = lst.clone();\n    list.sort_by(|a, b| {\n\
    \        let a_len = a.len();\n        let b_len = b.len();\n        a_len.cmp(&b_len).then(a.cmp(b))\n\
    \    });\n    list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n \
    \   assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp02g0qxxd.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let res = lst.into_iter().filter(|s| is_even_len(s)).collect::<Vec<String>>();\n\
    \    res.sort_by(|a, b| a.len().cmp(&b.len()));\n    res\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_even_len` in this scope\n  --> /tmp/tmpy_nwnrq1.rs:17:42\n\
    \   |\n17 |     let res = lst.into_iter().filter(|s| is_even_len(s)).collect::<Vec<String>>();\n\
    \   |                                          ^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    // Sort the vector\n    lst.sort();\n\
    \    // Reverse the order of elements\n    lst.reverse();\n    // Remove all elements\
    \ with an odd length\n    let lst = lst.into_iter().filter(|s| s.len() % 2 ==\
    \ 0).collect();\n    // Sort the vector\n    lst.sort();\n    // Return the vector\n\
    \    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpxwcuu6hu.rs:25:5\n\
    \   |\n23 |     let lst = lst.into_iter().filter(|s| s.len() % 2 == 0).collect();\n\
    \   |         --- consider giving `lst` a type\n24 |     // Sort the vector\n\
    25 |     lst.sort();\n   |     ^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    //let mut new_lst: Vec<&str> = Vec::new();\n    let mut\
    \ new_lst: Vec<String> = Vec::new();\n    for x in lst {\n        let new_len\
    \ = x.len();\n        //new_lst.push(&x[0..new_len]);\n        new_lst.push(x);\n\
    \    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpkoqcewrw.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut len = lst[0].len();\n    let mut start = 0;\n    for (index, item)\
    \ in lst.iter().enumerate() {\n        if item.len() != len {\n            lst[start..index].sort();\n\
    \            start = index;\n            len = item.len();\n        }\n    }\n\
    \    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `lst` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpwjyc6ga6.rs:23:13\n   |\n21 |     for (index, item)\
    \ in lst.iter().enumerate() {\n   |                          ----------------------\n\
    \   |                          |\n   |                          immutable borrow\
    \ occurs here\n   |                          immutable borrow later used here\n\
    22 |         if item.len() != len {\n23 |             lst[start..index].sort();\n\
    \   |             ^^^ mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ match a.len().cmp(&b.len()) {\n            Ordering::Equal => a.cmp(b),\n  \
    \          other => other,\n        }\n    });\n    let mut sum = Vec::new();\n\
    \    let mut current_len = 0;\n    for word in lst {\n        if word.len() %\
    \ 2 == 0 {\n            continue;\n        } else if word.len() == current_len\
    \ {\n            sum.push(word);\n        } else {\n            current_len =\
    \ word.len();\n            sum = vec![word];\n        }\n    }\n    sum\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpeyyvcl3e.rs:20:13\n   |\n20 |             Ordering::Equal => a.cmp(b),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut new_lst = Vec::new();\n    for word in lst {\n        if word.len()\
    \ % 2 == 0 {\n            new_lst.push(word)\n        }\n    }\n    new_lst\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpxbao8n7n.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    lst.iter().for_each(|w|\
    \ {\n        if w.len() % 2 == 0 {\n            res.push(w.clone());\n       \
    \ }\n    });\n    res.sort_by(|a, b| {\n        match a.len().cmp(&b.len()) {\n\
    \            Ordering::Equal => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        }\n    });\n   \
    \ res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpxtendctl.rs:25:13\n   |\n25 |             Ordering::Equal => a.cmp(b),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpxtendctl.rs:26:13\n\
    \   |\n26 |             Ordering::Less => Ordering::Less,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpxtendctl.rs:26:31\n   |\n26 |    \
    \         Ordering::Less => Ordering::Less,\n   |                            \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpxtendctl.rs:27:13\n   |\n27\
    \ |             Ordering::Greater => Ordering::Greater,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpxtendctl.rs:27:34\n   |\n27 |    \
    \         Ordering::Greater => Ordering::Greater,\n   |                      \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut list = lst.to_vec();\n    list.sort_by(|a, b|\
    \ {\n        let len_a = a.len();\n        let len_b = b.len();\n        if len_a\
    \ % 2 == 0 && len_b % 2 == 0 {\n            len_a.cmp(&len_b)\n        } else\
    \ if len_a % 2 == 0 {\n            std::cmp::Ordering::Less\n        } else if\
    \ len_b % 2 == 0 {\n            std::cmp::Ordering::Greater\n        } else {\n\
    \            std::cmp::Ordering::Equal\n        }\n    });\n    list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpbu2pbied.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp4iqetzpb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    if lst.len() == 0 {\n        return vec![];\n    }\n \
    \   let (sum, max_sum) = lst.iter().fold((0, 0), |(sum, max_sum), v| {\n     \
    \   let value = v.parse::<i32>().unwrap();\n        if value > max_sum {\n   \
    \         (sum + value, value)\n        } else {\n            (sum + value, max_sum)\n\
    \        }\n    });\n    vec![\n        String::from(\"sum:\"),\n        String::from(sum.to_string()),\n\
    \        String::from(\"max-sum:\"),\n        String::from(max_sum.to_string()),\n\
    \    ]\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmp7n6dkskc.rs:21:38

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp2eodsziq.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmp2eodsziq.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Count and group by length\n    let mut counts = HashMap::new();\n\
    \    for s in lst {\n        let len = s.len();\n        counts.entry(len).or_insert(Vec::new()).push(s);\n\
    \    }\n\n    // Sort by length of key, alphabetically by value\n    let mut sorted:\
    \ Vec<usize> = counts.keys().map(|&x| x).collect();\n    sorted.sort();\n    let\
    \ mut result = Vec::new();\n    for len in sorted {\n        let mut v = counts.get(&len).unwrap().clone();\n\
    \        v.sort();\n        result.extend(v);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp0mujnnmf.rs:18:22\n   |\n18 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    if lst.len() == 0 {\n        return lst;\n    }\n    let\
    \ word_size = lst[0].len();\n    lst.into_iter()\n        .filter(|x| x.len()\
    \ % 2 == 0)\n        .filter(|x| x.len() == word_size)\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`', /tmp/tmpou2324z3.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpq2o5_6dh.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpq2o5_6dh.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .sorted_by(|x, y| match x.len().cmp(&y.len()) {\n            Ordering::Equal\
    \ => x.cmp(y),\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        })\n        .collect()\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpublt2f56.rs:20:13\n   |\n20 |             Ordering::Equal => x.cmp(y),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpublt2f56.rs:21:13\n\
    \   |\n21 |             Ordering::Less => Ordering::Less,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpublt2f56.rs:21:31\n   |\n21 |    \
    \         Ordering::Less => Ordering::Less,\n   |                            \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpublt2f56.rs:22:13\n   |\n22\
    \ |             Ordering::Greater => Ordering::Greater,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpublt2f56.rs:22:34\n   |\n22 |    \
    \         Ordering::Greater => Ordering::Greater,\n   |                      \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]: no method\
    \ named `sorted_by` found for struct `Filter` in the current scope\n  --> /tmp/tmpublt2f56.rs:19:10\n\
    \   |\n19 |         .sorted_by(|x, y| match x.len().cmp(&y.len()) {\n   |    \
    \      ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpublt2f56.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut pass = false;\n\
    \    let mut pass_count = 0;\n    for (i, _el) in lst.iter().enumerate() {\n \
    \       if lst[i].len() % 2 == 0 {\n            result.push(lst[i].clone());\n\
    \        } else {\n            pass = true;\n            pass_count += 1;\n  \
    \      }\n    }\n    if pass {\n        let mut count = 0;\n        for (i, _el)\
    \ in lst.iter().enumerate() {\n            if lst[i].len() % 2 != 0 {\n      \
    \          if count < pass_count {\n                    result.push(lst[i].clone());\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    let mut sorted = true;\n    while sorted {\n        sorted = false;\n\
    \        for i in 0..result.len() - 1 {\n            if result[i].len() > result[i\
    \ + 1].len() {\n                let temp = result[i].clone();\n              \
    \  result[i] = result[i + 1].clone();\n                result[i + 1] = temp;\n\
    \                sorted = true;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp0swo7hod.rs:56:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpq2o5_6dh.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpq2o5_6dh.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    // let mut even_sorted_list: Vec<String>\
    \ = Vec::new();\n    let mut odd_sorted_list: Vec<String> = Vec::new();\n    lst.sort_by(|a,\
    \ b| {\n        let l1 = a.len();\n        let l2 = b.len();\n        if l1 ==\
    \ l2 {\n            a.cmp(b)\n        } else {\n            l1.cmp(&l2)\n    \
    \    }\n    });\n    for i in lst {\n        if i.len() % 2 == 0 {\n         \
    \   odd_sorted_list.push(i);\n        }\n    }\n    odd_sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let new_vec: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|x| x.len() % 2 == 0)\n        .collect();\n    new_vec.sort();\n\
    \    new_vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `new_vec` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmp3h2rc8rf.rs:21:5\n   |\n17 |     let new_vec: Vec<String>\
    \ = lst\n   |         ------- help: consider changing this to be mutable: `mut\
    \ new_vec`\n...\n21 |     new_vec.sort();\n   |     ^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst.dedup();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp75oz0xhc.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for i in lst {\n  \
    \      if i.len() % 2 == 0 {\n            sorted_list.push(i);\n        }\n  \
    \  }\n    sorted_list.sort();\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpql5k_all.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut odd = Vec::new();\n\
    \    for s in lst {\n        if s.len() % 2 == 0 {\n            result.push(s);\n\
    \        } else {\n            odd.push(s);\n        }\n    }\n    result.sort();\n\
    \    result.reverse();\n    result.append(&mut odd);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpjlkze59_.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut current_len = 0;\n    let mut res = Vec::new();\n    for i in lst\
    \ {\n        if i.len() != current_len {\n            current_len = i.len();\n\
    \            res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpndwq01it.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    fn sort_fn(a: &String, b: &String) -> std::cmp::Ordering\
    \ {\n        a.len().cmp(&b.len())\n    }\n    let mut lst: Vec<String> = lst\n\
    \        .into_iter()\n        .filter(|x| x.len() % 2 == 0)\n        .collect();\n\
    \    lst.sort_by(sort_fn);\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmppa_v4ob9.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    for s in lst\
    \ {\n        if s.len() % 2 == 0 {\n            res.push(s);\n        }\n    }\n\
    \    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpi4m2i5yd.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().collect();\n\
    \    let len = lst.len();\n    lst.drain_filter(|s| s.len() % 2 == 1);\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    for i in 1..len {\n        if lst[i].len() ==\
    \ lst[i - 1].len() {\n            lst.sort_by(|a, b| a.cmp(b));\n        }\n \
    \   }\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'drain_filter': recently\
    \ added\n  --> /tmp/tmpayrobkpq.rs:19:9\n   |\n19 |     lst.drain_filter(|s| s.len()\
    \ % 2 == 1);\n   |         ^^^^^^^^^^^^\n   |\n   = note: see issue #43244 <https://github.com/rust-lang/rust/issues/43244>\
    \ for more information\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut v: Vec<String> = lst.clone();\n    v.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    v.into_iter().filter(|s| s.len() % 2 == 0).collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpg_7jvts2.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|word| word.len() % 2\
    \ == 0)\n        .sorted_by(|a, b| {\n            if a.len() == b.len() {\n  \
    \              a.cmp(b)\n            } else {\n                a.len().cmp(&b.len())\n\
    \            }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmprkqqfhx9.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmprkqqfhx9.rs:18:17: 18:43]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut odd_strings: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|word| word.len() % 2 == 0)\n        .collect();\n    odd_strings.sort();\n\
    \    odd_strings\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpq4c3vkt1.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.iter().cloned().collect();\n\
    \    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    let mut result: Vec<String>\
    \ = Vec::new();\n    let mut curr_len = 0;\n    for (i, word) in lst.iter().enumerate()\
    \ {\n        if word.len() % 2 == 0 {\n            if word.len() == curr_len {\n\
    \                result.push(word.clone());\n            } else {\n          \
    \      curr_len = word.len();\n                result = vec![word.clone()];\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`', /tmp/tmp6c6znn3w.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ a.len().cmp(&b.len())\n            .then_with(|| a.to_lowercase().cmp(&b.to_lowercase()))\n\
    \    });\n    let sum = lst.into_iter().fold(vec![], |mut acc, el| {\n       \
    \ if acc.is_empty() || acc.last().unwrap().len() != el.len() {\n            acc.push(el);\n\
    \        }\n        acc\n    });\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp1_xel7kb.rs:22:45\n\
    \   |\n22 |     let sum = lst.into_iter().fold(vec![], |mut acc, el| {\n   | \
    \                                            ^^^^^^^ consider giving this closure\
    \ parameter the explicit type `Vec<T>`, where the type parameter `T` is specified\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec = lst.clone();\n    vec.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    vec.dedup();\n    let mut new_vec = vec![];\n    for i in vec {\n       \
    \ if i.len() % 2 == 0 {\n            new_vec.push(i);\n        }\n    }\n    new_vec\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpllh4pxjh.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut odd_lst: Vec<String> = Vec::new();\n    let mut\
    \ even_lst: Vec<String> = Vec::new();\n    for element in lst {\n        if element.len()\
    \ % 2 == 0 {\n            even_lst.push(element);\n        } else {\n        \
    \    odd_lst.push(element);\n        }\n    }\n    even_lst.sort();\n    odd_lst.sort();\n\
    \    even_lst.extend(odd_lst);\n    even_lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpafj2d3j5.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let l = lst.len();\n    if l < 2 {\n        return lst;\n\
    \    }\n\n    let mid = l / 2;\n    let left = sorted_list_sum(lst[..mid].to_vec());\n\
    \    let right = sorted_list_sum(lst[mid..].to_vec());\n\n    return sorted_list_sum_helper(left,\
    \ right);\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sum_helper` in this scope\n\
    \  --> /tmp/tmp98pj84ks.rs:26:12\n   |\n26 |     return sorted_list_sum_helper(left,\
    \ right);\n   |            ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = lst.clone();\n    sorted_list.sort_by(|a,\
    \ b| {\n        let alen = a.len();\n        let blen = b.len();\n        match\
    \ (alen - blen).cmp(&0) {\n            std::cmp::Ordering::Equal => a.cmp(b),\n\
    \            x => x,\n        }\n    });\n    let mut total_list = Vec::new();\n\
    \    let mut set: HashSet<u32> = HashSet::new();\n    for x in sorted_list {\n\
    \        if x.len() % 2 == 0 {\n            total_list.push(x);\n            set.insert(x.len()\
    \ as u32);\n        }\n    }\n    total_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpyd058s7l.rs:27:18\n\
    \   |\n27 |     let mut set: HashSet<u32> = HashSet::new();\n   |            \
    \      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpyd058s7l.rs:27:33\n   |\n27\
    \ |     let mut set: HashSet<u32> = HashSet::new();\n   |                    \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = Vec::new();\n    for v\
    \ in lst {\n        if v.len() % 2 == 0 {\n            new_lst.push(v);\n    \
    \    }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmppxm52v6n.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().collect();\n\
    \    let mut ret: Vec<String> = Vec::new();\n    loop {\n        if lst.len()\
    \ == 0 {\n            break;\n        }\n        let shortest = shortest_str(&lst);\n\
    \        lst.retain(|x| x != shortest);\n        ret.push(shortest.to_string());\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shortest_str` in this scope\n  -->\
    \ /tmp/tmplzqcbulx.rs:23:24\n   |\n23 |         let shortest = shortest_str(&lst);\n\
    \   |                        ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ j = 0;\n    for i in 0..lst.len() {\n        if lst[i].len() % 2 == 0 {\n  \
    \          result.push(lst[i].clone());\n            j += 1;\n        }\n    }\n\
    \    result.sort();\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpvilhfgpw.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_num: Vec<String> = Vec::new();\n    let mut\
    \ lst_alpha: Vec<String> = Vec::new();\n    let mut result: Vec<String> = Vec::new();\n\
    \    for elem in lst {\n        if elem.len() % 2 == 0 {\n            lst_num.push(elem);\n\
    \        } else {\n            lst_alpha.push(elem);\n        }\n    }\n    lst_num.sort();\n\
    \    lst_alpha.sort();\n    for elem in lst_num {\n        result.push(elem);\n\
    \    }\n    for elem in lst_alpha {\n        result.push(elem);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpb2quswbc.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // TODO\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"aa\"]`', /tmp/tmpo87r_2b3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|x| x.len() % 2 == 0)\n        .collect();\n    lst.sort_by(|a,\
    \ b| {\n        a.len()\n            .cmp(&b.len())\n            .then_with(||\
    \ a.cmp(&b))\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979894
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst\n        .into_iter()\n\
    \        .filter(|i| i.len() % 2 == 0)\n        .collect();\n    lst.sort_by(|x,\
    \ y| {\n        if x.len() == y.len() {\n            x.cmp(y)\n        } else\
    \ {\n            x.len().cmp(&y.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = Vec::new();\n    let mut\
    \ lst_even: Vec<String> = Vec::new();\n    let mut lst_odd: Vec<String> = Vec::new();\n\
    \    for word in lst {\n        if word.len() % 2 == 0 {\n            lst_even.push(word);\n\
    \        } else {\n            lst_odd.push(word);\n        }\n    }\n    new_lst.append(&mut\
    \ lst_even);\n    new_lst.append(&mut lst_odd);\n    new_lst\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpj8xcmykn.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    //let mut lst = lst;\n    let mut new_lst: Vec<String>\
    \ = Vec::new();\n    for item in lst {\n        if item.len() % 2 == 0 {\n   \
    \         new_lst.push(item);\n        }\n    }\n    return new_lst;\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp2c4u1gez.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut v = Vec::new();\n    for x in lst {\n        if\
    \ x.len() % 2 == 0 {\n            v.push(x);\n        }\n    }\n    v.sort();\n\
    \    v\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpdu6n05jr.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ odd_strings: Vec<String> = Vec::new();\n    let mut even_strings: Vec<String>\
    \ = Vec::new();\n    let mut string_map: HashMap<String, u32> = HashMap::new();\n\
    \    for a_string in lst {\n        let mut length: u32 = 0;\n        if !string_map.contains_key(&a_string)\
    \ {\n            string_map.insert(a_string.clone(), 1);\n        } else {\n \
    \           length = *string_map.get(&a_string).unwrap();\n            string_map.insert(a_string.clone(),\
    \ length + 1);\n        }\n    }\n    for (k, v) in string_map {\n        if k.len()\
    \ % 2 == 0 {\n            for _i in 0..v {\n                even_strings.push(k.clone());\n\
    \            }\n        } else {\n            for _i in 0..v {\n             \
    \   odd_strings.push(k.clone());\n            }\n        }\n    }\n    even_strings.sort();\n\
    \    odd_strings.sort();\n    for a_string in odd_strings {\n        result.push(a_string);\n\
    \    }\n    for a_string in even_strings {\n        result.push(a_string);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n  \
    \  assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpyfwdji8o.rs:20:25\n\
    \   |\n20 |     let mut string_map: HashMap<String, u32> = HashMap::new();\n \
    \  |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpyfwdji8o.rs:20:48\n\
    \   |\n20 |     let mut string_map: HashMap<String, u32> = HashMap::new();\n \
    \  |                                                ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut words = lst.clone();\n    words.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    words\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpazvyxeel.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    let mut lst_iter\
    \ = lst.iter();\n    let mut prev_len = 0;\n    while let Some(x) = lst_iter.next()\
    \ {\n        let x_len = x.len();\n        if x_len == prev_len {\n          \
    \  res.push(x.to_string());\n        } else if x_len > prev_len {\n          \
    \  prev_len = x_len;\n            res.clear();\n            res.push(x.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpppp4gnx0.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut odd_lst: Vec<String> = Vec::new();\n    let mut\
    \ even_lst: Vec<String> = Vec::new();\n    let mut new_lst: Vec<String> = Vec::new();\n\
    \    for word in lst {\n        if word.len() % 2 == 0 {\n            even_lst.push(word);\n\
    \        } else {\n            odd_lst.push(word);\n        }\n    }\n    even_lst.sort();\n\
    \    new_lst.append(&mut even_lst);\n    odd_lst.sort();\n    new_lst.append(&mut\
    \ odd_lst);\n    new_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp7etoa_dk.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // TODO: Implement me!\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6wn3vrhd.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    lst.dedup();\n    let even = lst.iter().filter(|x| x.len() % 2 == 0).map(|x|\
    \ x.to_string()).collect();\n    let mut even = even;\n    even.sort();\n    even\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmph_6iqqgo.rs:22:5\n\
    \   |\n20 |     let even = lst.iter().filter(|x| x.len() % 2 == 0).map(|x| x.to_string()).collect();\n\
    \   |         ---- consider giving `even` a type\n21 |     let mut even = even;\n\
    22 |     even.sort();\n   |     ^^^^ cannot infer type\n   |\n   = note: type\
    \ must be known at this point\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let result: Vec<String> = lst\n        .iter()\n     \
    \   .filter(|str| str.len() % 2 == 0)\n        .map(|str| str.to_string())\n \
    \       .collect();\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpquxmukt2.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut v = Vec::new();\n    for s in lst {\n        if\
    \ s.len() % 2 == 0 {\n            v.push(s);\n        }\n    }\n    v.sort();\n\
    \    v\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpnap3np2w.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut ret_vec: Vec<String> = Vec::new();\n    let mut\
    \ lst_copy = lst.clone();\n    lst_copy.sort();\n    let first_word_len = lst_copy[0].len();\n\
    \    ret_vec.push(lst_copy[0].clone());\n    for word in lst_copy.iter().skip(1)\
    \ {\n        if word.len() == first_word_len {\n            ret_vec.push(word.clone());\n\
    \        }\n    }\n    ret_vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\"]`,\n right: `[\"aa\"]`', /tmp/tmpseta1r4p.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    for v in lst {\n      \
    \  if v.len() % 2 == 0 {\n            res.push(v);\n        }\n    }\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp323b6_bf.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort_by(|a, b| {\n        if a.len() ==\
    \ b.len() {\n            a.cmp(b)\n        } else {\n            a.len().cmp(&b.len())\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979895
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|a| a.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpck9fkd64.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst: Vec<_> = lst.into_iter().filter(|x| x.len()\
    \ % 2 == 0).collect();\n    lst.sort_by(|a, b| {\n        let a_len = a.len();\n\
    \        let b_len = b.len();\n        if a_len == b_len {\n            a.cmp(b)\n\
    \        } else {\n            a_len.cmp(&b_len)\n        }\n    });\n    lst\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut v = lst;\n    v.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    let mut out: Vec<String> = Vec::new();\n    for i in 0..v.len() {\n     \
    \   let e = v[i].len();\n        if e % 2 == 0 {\n            out.push(v[i].clone());\n\
    \        }\n    }\n    out.sort_by(|a, b| a.len().cmp(&b.len()));\n    out\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpopylia8v.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // The order of the vector should be ascending by length\
    \ of each word, and you\n    // should return the vector sorted by that rule.\n\
    \    // If two words have the same length, sort the vector alphabetically.\n \
    \   let mut new_lst: Vec<String> = Vec::new();\n    //    for i in lst {\n   \
    \ //        if i.len() % 2 == 0 {\n    //            new_lst.push(i);\n    //\
    \        }\n    //    }\n    new_lst = lst\n        .into_iter()\n        .filter(|i|\
    \ i.len() % 2 == 0)\n        .collect::<Vec<String>>();\n    new_lst.sort_by(|a,\
    \ b| {\n        match a.len().cmp(&b.len()) {\n            Ordering::Equal =>\
    \ a.cmp(b),\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        }\n    });\n    new_lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpam49u5_n.rs:32:13\n   |\n32 |             Ordering::Equal => a.cmp(b),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpam49u5_n.rs:33:13\n\
    \   |\n33 |             Ordering::Less => Ordering::Less,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpam49u5_n.rs:33:31\n   |\n33 |    \
    \         Ordering::Less => Ordering::Less,\n   |                            \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpam49u5_n.rs:34:13\n   |\n34\
    \ |             Ordering::Greater => Ordering::Greater,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpam49u5_n.rs:34:34\n   |\n34 |    \
    \         Ordering::Greater => Ordering::Greater,\n   |                      \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut xs = lst.clone();\n    xs.sort_by(|a, b| {\n \
    \       if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n    \
    \        a.len().cmp(&b.len())\n        }\n    });\n    xs\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpf4_gw_97.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|item| item.len() % 2\
    \ == 0)\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpvxen6u8h.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp11t9fdif.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp4iqetzpb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut v: Vec<String> = Vec::new();\n    for n in lst\
    \ {\n        if n.len() % 2 == 0 {\n            v.push(n);\n        }\n    }\n\
    \    v.sort();\n    v\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpj_erctru.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979895
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec: Vec<String> = Vec::new();\n    for s in lst\
    \ {\n        if s.len() % 2 == 0 {\n            vec.push(s);\n        }\n    }\n\
    \    vec.sort();\n    vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpzr9g0n6m.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979895
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = lst.clone();\n    sorted_list.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpj5pojyca.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|x| x.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| (a.len(), a).cmp(&(b.len(), b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpbe2d7_13.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| (a.len(), a).cmp(&(b.len(), b)))\n   |          ^^^^^^^^^ method not found\
    \ in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmpbe2d7_13.rs:18:17: 18:37]>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_lst: Vec<String> = Vec::new();\n    let mut\
    \ words_len_map: HashMap<usize, Vec<String>> = HashMap::new();\n    let mut lengths_ordered:\
    \ Vec<usize> = Vec::new();\n\n    for word in lst {\n        let len = word.len();\n\
    \        lengths_ordered.push(len);\n        if let Some(value) = words_len_map.get_mut(&len)\
    \ {\n            value.push(word);\n        } else {\n            words_len_map.insert(len,\
    \ vec![word]);\n        }\n    }\n\n    // remove duplicates\n    let mut unique_lens:\
    \ HashSet<usize> = HashSet::new();\n    for len in lengths_ordered {\n       \
    \ unique_lens.insert(len);\n    }\n\n    let mut sorted_lengths: Vec<usize> =\
    \ unique_lens.iter().cloned().collect();\n    sorted_lengths.sort();\n\n    for\
    \ len in sorted_lengths {\n        let mut words = words_len_map.get(&len).unwrap().clone();\n\
    \        words.sort();\n        new_lst.append(&mut words);\n    }\n\n    new_lst\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpaolwulg5.rs:18:28\n\
    \   |\n18 |     let mut words_len_map: HashMap<usize, Vec<String>> = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpaolwulg5.rs:18:58\n   |\n18 |     let mut words_len_map: HashMap<usize,\
    \ Vec<String>> = HashMap::new();\n   |                                       \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n  --> /tmp/tmpaolwulg5.rs:32:26\n\
    \   |\n32 |     let mut unique_lens: HashSet<usize> = HashSet::new();\n   |  \
    \                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpaolwulg5.rs:32:43\n\
    \   |\n32 |     let mut unique_lens: HashSet<usize> = HashSet::new();\n   |  \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let filtered_lst: Vec<String> = lst.into_iter().filter(|word|\
    \ word.len() % 2 == 0).collect();\n    filtered_lst.sort();\n    filtered_lst\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `filtered_lst` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmp9kmmxli0.rs:18:5\n   |\n17 |     let filtered_lst:\
    \ Vec<String> = lst.into_iter().filter(|word| word.len() % 2 == 0).collect();\n\
    \   |         ------------ help: consider changing this to be mutable: `mut filtered_lst`\n\
    18 |     filtered_lst.sort();\n   |     ^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut re = lst.clone();\n    re.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    re.dedup();\n    re\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp9xippzj1.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979895
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n\
    \        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp2eodsziq.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| a.len().cmp(&b.len()).then(a.cmp(b)))\n   |          ^^^^^^^^^ method not\
    \ found in `Filter<std::vec::IntoIter<String>, [closure@/tmp/tmp2eodsziq.rs:18:17:\
    \ 18:37]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let lst = remove_odd_length(lst);\n    let mut lst = sorted_list_length(lst);\n\
    \    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `remove_odd_length` in this scope\n\
    \  --> /tmp/tmpl8rhb6be.rs:17:15\n   |\n17 |     let lst = remove_odd_length(lst);\n\
    \   |               ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `sorted_list_length` in this scope\n  --> /tmp/tmpl8rhb6be.rs:18:19\n\
    \   |\n18 |     let mut lst = sorted_list_length(lst);\n   |                 \
    \  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut v = lst;\n    v.sort_by(|x, y| y.len().cmp(&x.len()));\n\
    \    v.dedup();\n    v.sort_by(|x, y| x.len().cmp(&y.len()));\n    v\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp6v13z9g5.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979895
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.into_iter()\n        .filter(|s| (s.len() % 2) ==\
    \ 0)\n        .sorted_by(|a, b| {\n            let a_len = a.len();\n        \
    \    let b_len = b.len();\n            if a_len == b_len {\n                return\
    \ a.cmp(b);\n            }\n            return a_len.cmp(&b_len);\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpocaodxmb.rs:19:10\n   |\n19 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmpocaodxmb.rs:18:17: 18:39]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659979894
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    fn odd_length(s: &String) -> bool {\n        s.len() %\
    \ 2 == 1\n    }\n    lst.into_iter().filter(|i| !odd_length(i)).collect()\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmppzmzajzy.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979895
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n       \
    \ if a.len() == b.len() {\n            return a.cmp(b);\n        }\n        return\
    \ a.len().cmp(&b.len());\n    });\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpn4tslfwe.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979895
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_new = Vec::new();\n    for s in lst {\n  \
    \      if s.len() % 2 == 0 {\n            lst_new.push(s);\n        }\n    }\n\
    \    lst_new.sort();\n    lst_new\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpwenssx2b.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979895
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    return lst.into_iter().filter(|x| x.len() % 2 == 0).collect();\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"school\", \"AI\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmp40uiww5m.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659979895
