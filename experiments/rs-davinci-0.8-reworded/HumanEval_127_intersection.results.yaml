name: HumanEval_127_intersection
language: rs
results:
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let (_, end1) = interval1;\n    let (start2, _) = interval2;\n\
    \    let result = if end1 < start2 {\n        0\n    } else {\n        end1 -\
    \ start2 + 1\n    };\n    let is_prime = is_prime(result);\n    if is_prime {\n\
    \        String::from(\"YES\")\n    } else {\n        String::from(\"NO\")\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjnaq6reh.rs:28:20\n\
    \   |\n28 |     let is_prime = is_prime(result);\n   |                    ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n\
    \        return String::from(\"NO\");\n    }\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if end <= start {\n        return\
    \ String::from(\"NO\");\n    }\n    let n = end - start + 1;\n    for i in 2..(n\
    \ as f64).sqrt() as isize + 1 {\n        if n % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpf7ol4p3k.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let (a1, b1) = interval1;\n    let (a2, b2) = interval2;\n\
    \    if b1 < a2 || b2 < a1 {\n        return String::from(\"NO\");\n    }\n  \
    \  let (i1, i2) = (max(a1, a2), min(b1, b2));\n    if is_prime(i2 - i1 + 1) {\n\
    \        return String::from(\"YES\");\n    }\n    String::from(\"NO\")\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpix394zth.rs:26:21\n\
    \   |\n26 |     let (i1, i2) = (max(a1, a2), min(b1, b2));\n   |             \
    \        ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min`\
    \ in this scope\n  --> /tmp/tmpix394zth.rs:26:34\n   |\n26 |     let (i1, i2)\
    \ = (max(a1, a2), min(b1, b2));\n   |                                  ^^^\n...\n\
    33 | fn main() {\n   | --------- similarly named function `main` defined here\n\
    \   |\nhelp: a function with a similar name exists\n   |\n26 |     let (i1, i2)\
    \ = (max(a1, a2), main(b1, b2));\n   |                                  ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpix394zth.rs:27:8\n\
    \   |\n27 |     if is_prime(i2 - i1 + 1) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let intersection = match (interval1, interval2) {\n       \
    \ ((a, b), (c, d)) if b < c || d < a => None,\n        ((a, b), (c, d)) => Some((a.max(c),\
    \ b.min(d))),\n    };\n    match intersection {\n        None => String::from(\"\
    NO\"),\n        Some((start, end)) => {\n            if end < start {\n      \
    \          String::from(\"NO\")\n            } else {\n                let length\
    \ = end - start + 1;\n                if is_prime(length) {\n                \
    \    String::from(\"YES\")\n                } else {\n                    String::from(\"\
    NO\")\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpufeg34e3.rs:32:20\n\
    \   |\n32 |                 if is_prime(length) {\n   |                    ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n\
    \        return String::from(\"NO\");\n    }\n    let inter = (\n        cmp::max(interval1.0,\
    \ interval2.0),\n        cmp::min(interval1.1, interval2.1),\n    );\n    if is_prime(inter.1\
    \ - inter.0 + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpiqgct70c.rs:25:9\n   |\n25 |         cmp::max(interval1.0, interval2.0),\n\
    \   |         ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpiqgct70c.rs:26:9\n\
    \   |\n26 |         cmp::min(interval1.1, interval2.1),\n   |         ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror[E0425]: cannot find function `is_prime`\
    \ in this scope\n  --> /tmp/tmpiqgct70c.rs:28:8\n   |\n28 |     if is_prime(inter.1\
    \ - inter.0 + 1) {\n   |        ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut res = (0, 0);\n    if interval1.0 <= interval2.0 &&\
    \ interval2.0 <= interval1.1 {\n        res.0 = interval2.0;\n    } else if interval2.0\
    \ <= interval1.0 && interval1.0 <= interval2.1 {\n        res.0 = interval1.0;\n\
    \    }\n    if interval1.0 <= interval2.1 && interval2.1 <= interval1.1 {\n  \
    \      res.1 = interval2.1;\n    } else if interval2.0 <= interval1.1 && interval1.1\
    \ <= interval2.1 {\n        res.1 = interval1.1;\n    }\n    if res.0 == 0 &&\
    \ res.1 == 0 {\n        String::from(\"NO\")\n    } else {\n        if is_prime(res.1\
    \ - res.0) {\n            String::from(\"YES\")\n        } else {\n          \
    \  String::from(\"NO\")\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmph77u7kcn.rs:35:12\n\
    \   |\n35 |         if is_prime(res.1 - res.0) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let it_min = interval1.0.max(interval2.0);\n    let it_max\
    \ = interval1.1.min(interval2.1);\n    if it_min > it_max {\n        return String::from(\"\
    NO\");\n    }\n    let mut it_len = (it_max - it_min) + 1;\n    if it_len == 1\
    \ {\n        return String::from(\"YES\");\n    }\n    let mut i = 2;\n    loop\
    \ {\n        if i * i > it_len {\n            return String::from(\"YES\");\n\
    \        }\n        if it_len % i == 0 {\n            return String::from(\"NO\"\
    );\n        }\n        i += 1;\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2oh95zha.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n\
    \        return String::from(\"NO\");\n    }\n    let low = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let high = std::cmp::min(interval1.1, interval2.1);\n   \
    \ match (low..=high).count() {\n        x if x <= 2 => String::from(\"NO\"),\n\
    \        x => {\n            for i in 2..(x-1) {\n                if x % i ==\
    \ 0 {\n                    return String::from(\"NO\");\n                }\n \
    \           }\n            String::from(\"YES\")\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    // Check if the intervals intersect\n    if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n        return String::from(\"NO\");\n    }\n\
    \    // intersection starts at the maximum of the two intervals' minimums\n  \
    \  let start = std::cmp::max(interval1.0, interval2.0);\n    // intersection ends\
    \ at the minimum of the two intervals' maximums\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    // find the length of the intersection\n    let length =\
    \ end - start + 1;\n    // check if the length is prime\n    if length < 2 {\n\
    \        return String::from(\"NO\");\n    }\n    let mut factor = 2;\n    while\
    \ factor * factor <= length {\n        if length % factor == 0 {\n           \
    \ return String::from(\"NO\");\n        }\n        factor += 1;\n    }\n    String::from(\"\
    YES\")\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8olt4owj.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut sorted = [interval1, interval2];\n    sorted.sort_by(|&(a,\
    \ b), &(c, d)| a.cmp(&c));\n    let &(a, b) = sorted.get(0).unwrap();\n    let\
    \ &(c, d) = sorted.get(1).unwrap();\n    if a > d || b < c {\n        return String::from(\"\
    NO\");\n    }\n    let i = (c, d).cmp(&(a, b));\n    let k = match i {\n     \
    \   Ordering::Equal => (a, b),\n        Ordering::Less => (c, b),\n        Ordering::Greater\
    \ => (a, d),\n    };\n    let g = k.1 - k.0;\n    let mut is_prime = true;\n \
    \   for j in 2..g {\n        if g % j == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime && g > 1 {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpc7n49jrs.rs:30:9\n   |\n30 |         Ordering::Equal => (a, b),\n  \
    \ |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpc7n49jrs.rs:31:9\n\
    \   |\n31 |         Ordering::Less => (c, b),\n   |         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpc7n49jrs.rs:32:9\n   |\n32 |         Ordering::Greater => (a, d),\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let (interval1_start, interval1_end) = interval1;\n    let\
    \ (interval2_start, interval2_end) = interval2;\n    if interval1_start >= interval2_end\
    \ || interval2_start >= interval1_end {\n        String::from(\"NO\")\n    } else\
    \ {\n        let intersection_start = if interval1_start > interval2_start {\n\
    \            interval1_start\n        } else {\n            interval2_start\n\
    \        };\n        let intersection_end = if interval1_end < interval2_end {\n\
    \            interval1_end\n        } else {\n            interval2_end\n    \
    \    };\n        if is_prime(intersection_end - intersection_start) {\n      \
    \      String::from(\"YES\")\n        } else {\n            String::from(\"NO\"\
    )\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp48m5urow.rs:36:12\n\
    \   |\n36 |         if is_prime(intersection_end - intersection_start) {\n   |\
    \            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut start = interval1.0;\n    let mut end = interval1.1;\n\
    \    if interval2.0 > start {\n        start = interval2.0;\n    }\n    if interval2.1\
    \ < end {\n        end = interval2.1;\n    }\n    if start >= end {\n        return\
    \ String::from(\"NO\");\n    }\n    let mut counter = 0;\n    for i in start..end\
    \ {\n        if i == 1 {\n            continue;\n        }\n        let mut is_prime\
    \ = true;\n        for j in 2..i {\n            if i % j == 0 {\n            \
    \    is_prime = false;\n                break;\n            }\n        }\n   \
    \     if is_prime {\n            counter += 1;\n        }\n    }\n    return if\
    \ counter == 0 {\n        String::from(\"NO\")\n    } else {\n        String::from(\"\
    YES\")\n    };\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1o80awo3.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let (mut start, mut end) = (0, 0);\n    if interval1.0 > interval2.0\
    \ {\n        start = interval1.0;\n    } else {\n        start = interval2.0;\n\
    \    }\n    if interval1.1 < interval2.1 {\n        end = interval1.1;\n    }\
    \ else {\n        end = interval2.1;\n    }\n    let len = end - start;\n    if\
    \ start > end {\n        return String::from(\"NO\");\n    }\n    if is_prime(len)\
    \ {\n        return String::from(\"YES\");\n    }\n    String::from(\"NO\")\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpsa3v5dp8.rs:36:8\n\
    \   |\n36 |     if is_prime(len) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.0 < interval2.0 {\n        if interval1.1 < interval2.0\
    \ {\n            return String::from(\"NO\");\n        }\n        if interval1.1\
    \ < interval2.1 {\n            return is_prime(interval1.1 - interval2.0 + 1);\n\
    \        }\n        return is_prime(interval2.1 - interval2.0 + 1);\n    } else\
    \ if interval1.0 == interval2.0 {\n        if interval1.1 < interval2.1 {\n  \
    \          return is_prime(interval1.1 - interval1.0 + 1);\n        }\n      \
    \  return is_prime(interval2.1 - interval2.0 + 1);\n    } else {\n        if interval2.1\
    \ < interval1.0 {\n            return String::from(\"NO\");\n        }\n     \
    \   if interval2.1 < interval1.1 {\n            return is_prime(interval2.1 -\
    \ interval1.0 + 1);\n        }\n        return is_prime(interval1.1 - interval1.0\
    \ + 1);\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4464b028.rs:26:20\n\
    \   |\n26 |             return is_prime(interval1.1 - interval2.0 + 1);\n   |\
    \                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_prime` in this scope\n  --> /tmp/tmp4464b028.rs:28:16\n  \
    \ |\n28 |         return is_prime(interval2.1 - interval2.0 + 1);\n   |      \
    \          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_prime` in this scope\n  --> /tmp/tmp4464b028.rs:31:20\n   |\n31 |      \
    \       return is_prime(interval1.1 - interval1.0 + 1);\n   |                \
    \    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_prime`\
    \ in this scope\n  --> /tmp/tmp4464b028.rs:33:16\n   |\n33 |         return is_prime(interval2.1\
    \ - interval2.0 + 1);\n   |                ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4464b028.rs:39:20\n\
    \   |\n39 |             return is_prime(interval2.1 - interval1.0 + 1);\n   |\
    \                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_prime` in this scope\n  --> /tmp/tmp4464b028.rs:41:16\n  \
    \ |\n41 |         return is_prime(interval1.1 - interval1.0 + 1);\n   |      \
    \          ^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let inter = (interval1.0..interval1.1).intersection(&(interval2.0..interval2.1));\n\
    \    match inter {\n        None => String::from(\"NO\"),\n        Some(s) =>\
    \ {\n            let mut is_prime = true;\n            for i in 2..(s.len() -\
    \ 1) {\n                if s.len() % i == 0 {\n                    is_prime =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       if is_prime {\n                String::from(\"YES\")\n            } else\
    \ {\n                String::from(\"NO\")\n            }\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `intersection` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmpti_64b9a.rs:21:44\n   |\n21 |     let inter\
    \ = (interval1.0..interval1.1).intersection(&(interval2.0..interval2.1));\n  \
    \ |                                            ^^^^^^^^^^^^ method not found in\
    \ `std::ops::Range<isize>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n\
    \        return String::from(\"NO\");\n    }\n    let mut min = interval1.0;\n\
    \    let mut max = interval1.1;\n    if interval2.0 > min {\n        min = interval2.0;\n\
    \    }\n    if interval2.1 < max {\n        max = interval2.1;\n    }\n    let\
    \ length = (max - min + 1) as usize;\n    let primes = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    if primes.contains(&length) {\n        return String::from(\"YES\");\n  \
    \  }\n    String::from(\"NO\")\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpfxai7iai.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let int1_min = interval1.0.min(interval1.1);\n    let int1_max\
    \ = interval1.0.max(interval1.1);\n    let int2_min = interval2.0.min(interval2.1);\n\
    \    let int2_max = interval2.0.max(interval2.1);\n    let int1_range = int1_max\
    \ - int1_min;\n    let int2_range = int2_max - int2_min;\n    if int1_range ==\
    \ 0 || int2_range == 0 {\n        return String::from(\"NO\");\n    }\n    if\
    \ int1_max < int2_min || int2_max < int1_min {\n        return String::from(\"\
    NO\");\n    }\n    let int_start = int1_min.max(int2_min);\n    let int_end =\
    \ int1_max.min(int2_max);\n    let int_range = int_end - int_start;\n    let mut\
    \ is_prime = true;\n    for i in 2..(int_range - 1) {\n        if int_range %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpo7cm7tqk.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let start = if interval1.0 > interval2.0 { interval1.0 } else\
    \ { interval2.0 };\n    let end = if interval1.1 < interval2.1 { interval1.1 }\
    \ else { interval2.1 };\n    if start > end {\n        return String::from(\"\
    NO\");\n    }\n    let length = end - start + 1;\n    match length {\n       \
    \ 1 => String::from(\"NO\"),\n        2 => String::from(\"YES\"),\n        3 =>\
    \ String::from(\"YES\"),\n        5 => String::from(\"YES\"),\n        7 => String::from(\"\
    YES\"),\n        _ => {\n            if length % 2 == 0 || length % 3 == 0 ||\
    \ length % 5 == 0 || length % 7 == 0 {\n                String::from(\"NO\")\n\
    \            } else {\n                String::from(\"YES\")\n            }\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpioawbv0g.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let s1 = interval1.0;\n    let e1 = interval1.1;\n    let s2\
    \ = interval2.0;\n    let e2 = interval2.1;\n    let mut start = std::cmp::max(s1,\
    \ s2);\n    let mut end = std::cmp::min(e1, e2);\n    // no intersection\n   \
    \ if end < start {\n        return String::from(\"NO\");\n    }\n    let mut res\
    \ = true;\n    while start <= end {\n        if start < 2 {\n            start\
    \ += 1;\n            continue;\n        }\n        res = true;\n        for i\
    \ in 2..start {\n            if start % i == 0 {\n                res = false;\n\
    \                break;\n            }\n        }\n        if res {\n        \
    \    break;\n        }\n        start += 1;\n    }\n    if res {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmprpnw1p8v.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let (mut l, mut r) = (interval1.0, interval1.1);\n    l = l.max(interval2.0);\n\
    \    r = r.min(interval2.1);\n    if l > r {\n        return String::from(\"NO\"\
    );\n    }\n    match (l - r) as usize {\n        0 | 1 => String::from(\"NO\"\
    ),\n        n => {\n            if is_prime(n) {\n                String::from(\"\
    YES\")\n            } else {\n                String::from(\"NO\")\n         \
    \   }\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4so8_436.rs:30:16\n\
    \   |\n30 |             if is_prime(n) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
