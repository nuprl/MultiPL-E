name: HumanEval_161_solve
language: rs
prompt: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the\
  \ string contains no letters, reverse the string.\n/// The function should return\
  \ the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n///\
  \ String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
  AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
  \ String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
  AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
  )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
  AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
  ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
  ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
  \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
  \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"
completions: ["    let mut s = s.as_bytes().to_vec();\n    for i in 0..s.len() {\n\
    \        if s[i] > 64 && s[i] < 91 {\n            s[i] += 32;\n        } else\
    \ if s[i] > 96 && s[i] < 123 {\n            s[i] -= 32;\n        }\n    }\n  \
    \  String::from_utf8(s).unwrap()", "    // for c in s.chars() {\n    //     if\
    \ c.is_ascii_uppercase() {\n    //         //\n    //     }\n    // }\n    unimplemented!()",
  "    let mut reversed_string = String::new();\n    let mut is_letter_exists = false;\n\
    \    for ch in s.chars() {\n        if ch.is_alphabetic() {\n            is_letter_exists\
    \ = true;\n            if ch.is_lowercase() {\n                reversed_string.push(ch.to_uppercase().next().unwrap());\n\
    \            } else {\n                reversed_string.push(ch.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            reversed_string.push(ch);\n    \
    \    }\n    }\n    if is_letter_exists {\n        reversed_string\n    } else\
    \ {\n        reversed_string.chars().rev().collect()\n    }", "\tlet mut v = s.chars().collect::<Vec<char>>();\n\
    \tv.reverse();\n\tlet s: String = v.into_iter().map(|x| {\n\t\tmatch x {\n\t\t\
    \t'a'..='z' => x.to_ascii_uppercase(),\n\t\t\t'A'..='Z' => x.to_ascii_lowercase(),\n\
    \t\t\t_ => x,\n\t\t}\n\t}).collect();\n\tif s.chars().any(|x| x.is_alphabetic())\
    \ {\n\t\ts\n\t} else {\n\t\tlet mut v = s.chars().collect::<Vec<char>>();\n\t\t\
    v.reverse();\n\t\tv.into_iter().collect()\n\t}", "    s.chars().rev().map(|c|\
    \ match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n        'A'..='Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", "    let mut s:\
    \ Vec<char> = s.chars().collect();\n    let mut contains_letter = false;\n   \
    \ let mut counter = 0;\n    while counter < s.len() {\n        if s[counter].is_alphabetic()\
    \ {\n            contains_letter = true;\n            if s[counter].is_lowercase()\
    \ {\n                s[counter] = s[counter].to_uppercase().next().unwrap();\n\
    \            } else {\n                s[counter] = s[counter].to_lowercase().next().unwrap();\n\
    \            }\n        }\n        counter += 1;\n    }\n    if !contains_letter\
    \ {\n        s.reverse();\n    }\n    s.into_iter().collect()", "    let mut res\
    \ = String::new();\n    let mut found = false;\n    for c in s.chars() {\n   \
    \     if c.is_alphabetic() {\n            found = true;\n            if c.is_lowercase()\
    \ {\n                res.push(c.to_uppercase().to_string().pop().unwrap());\n\
    \            } else {\n                res.push(c.to_lowercase().to_string().pop().unwrap());\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    if !found {\n        res.chars().rev().collect()\n    } else {\n        res\n\
    \    }", "    s.chars().rev().map(|c| \n        if c.is_alphabetic() {\n     \
    \       if c.is_lowercase() { c.to_uppercase().to_string() }\n            else\
    \ { c.to_lowercase().to_string() }\n        } else { c.to_string() }\n    ).collect()",
  "    let mut chars = s.chars();\n    let mut s = String::new();\n    let mut found\
    \ = false;\n    while let Some(c) = chars.next() {\n        if c.is_ascii_alphabetic()\
    \ {\n            found = true;\n            s.push(c.swap_case());\n        }\
    \ else {\n            s.push(c);\n        }\n    }\n    if !found {\n        s.chars().rev().collect()\n\
    \    } else {\n        s\n    }", "    let mut v: Vec<char> = s.chars().collect();\n\
    \    let mut b: bool = false;\n    for i in 0..v.len() {\n        if v[i].is_alphabetic()\
    \ {\n            b = true;\n            v[i] = v[i].to_ascii_lowercase();\n  \
    \      }\n    }\n    if b {\n        v.reverse();\n        for i in 0..v.len()\
    \ {\n            if v[i].is_alphabetic() {\n                v[i] = v[i].to_ascii_uppercase();\n\
    \            }\n        }\n    } else {\n        v.reverse();\n    }\n    return\
    \ v.into_iter().collect();", '    s.chars().rev().collect()', '    unimplemented!()',
  "\tString::from(\"Not implemented yet.\")", "    let mut buffer = String::new();\n\
    \    let mut has_letter = false;\n    for ch in s.chars() {\n        if ch.is_alphabetic()\
    \ {\n            buffer.push(ch.swap_case());\n            has_letter = true;\n\
    \        } else {\n            buffer.push(ch);\n        }\n    }\n    if !has_letter\
    \ {\n        buffer.chars().rev().collect()\n    } else {\n        buffer\n  \
    \  }", "    let mut res = s.chars().rev().collect::<String>();\n    for (i, c)\
    \ in res.chars().enumerate() {\n        if c.is_alphabetic() {\n            res.replace_range(i..i+1,\
    \ &c.to_string().to_uppercase());\n        }\n    }\n    res", '    unimplemented!();',
  "    let mut result = String::new();\n    for c in s.chars() {\n        match c\
    \ {\n            'A'...'Z' => result.push(c.to_ascii_lowercase()),\n         \
    \   'a'...'z' => result.push(c.to_ascii_uppercase()),\n            _ => result.push(c),\n\
    \        }\n    }\n    if result.chars().any(|c| c.is_alphabetic()) {\n      \
    \  result\n    } else {\n        result.chars().rev().collect()\n    }", "   \
    \ let mut letters = Vec::new();\n    for ch in s.chars() {\n        if ch.is_ascii_alphabetic()\
    \ {\n            letters.push(ch.to_ascii_lowercase());\n        }\n    }\n  \
    \  if letters.is_empty() {\n        return s.chars().rev().collect();\n    }\n\
    \n    let mut result = String::new();\n    for ch in s.chars() {\n        if ch.is_ascii_alphabetic()\
    \ {\n            result.push(letters.pop().unwrap().to_ascii_uppercase());\n \
    \       } else {\n            result.push(ch);\n        }\n    }\n    result",
  "    let mut new_string = String::new();\n    for ch in s.chars() {\n        match\
    \ ch {\n            'a' => new_string.push('A'),\n            'b' => new_string.push('B'),\n\
    \            'c' => new_string.push('C'),\n            'd' => new_string.push('D'),\n\
    \            'e' => new_string.push('E'),\n            'f' => new_string.push('F'),\n\
    \            'g' => new_string.push('G'),\n            'h' => new_string.push('H'),\n\
    \            'i' => new_string.push('I'),\n            'j' => new_string.push('J'),\n\
    \            'k' => new_string.push('K'),\n            'l' => new_string.push('L'),\n\
    \            'm' => new_string.push('M'),\n            'n' => new_string.push('N'),\n\
    \            'o' => new_string.push('O'),\n            'p' => new_string.push('P'),\n\
    \            'q' => new_string.push('Q'),\n            'r' => new_string.push('R'),\n\
    \            's' => new_string.push('S'),\n            't' => new_string.push('T'),\n\
    \            'u' => new_string.push('U'),\n            'v' => new_string.push('V'),\n\
    \            'w' => new_string.push('W'),\n            'x' => new_string.push('X'),\n\
    \            'y' => new_string.push('Y'),\n            'z' => new_string.push('Z'),\n\
    \            'A' => new_string.push('a'),\n            'B' => new_string.push('b'),\n\
    \            'C' => new_string.push('c'),\n            'D' => new_string.push('d'),\n\
    \            'E' => new_string.push('e'),\n            'F' => new_string.push('f'),\n\
    \            'G' => new_string.push('g'),\n            'H' => new_string.push('h'),\n\
    \            'I' => new_", "    s.chars().rev().map(|c| {\n        match c {\n\
    \            'a' => 'A',\n            'b' => 'B',\n            'c' => 'C',\n \
    \           'd' => 'D',\n            'e' => 'E',\n            'f' => 'F',\n  \
    \          'g' => 'G',\n            'h' => 'H',\n            'i' => 'I',\n   \
    \         'j' => 'J',\n            'k' => 'K',\n            'l' => 'L',\n    \
    \        'm' => 'M',\n            'n' => 'N',\n            'o' => 'O',\n     \
    \       'p' => 'P',\n            'q' => 'Q',\n            'r' => 'R',\n      \
    \      's' => 'S',\n            't' => 'T',\n            'u' => 'U',\n       \
    \     'v' => 'V',\n            'w' => 'W',\n            'x' => 'X',\n        \
    \    'y' => 'Y',\n            'z' => 'Z',\n            'A' => 'a',\n         \
    \   'B' => 'b',\n            'C' => 'c',\n            'D' => 'd',\n          \
    \  'E' => 'e',\n            'F' => 'f',\n            'G' => 'g',\n           \
    \ 'H' => 'h',\n            'I' => 'i',\n            'J' => 'j',\n            'K'\
    \ => 'k',\n            'L' => 'l',\n            'M' => 'm',\n            'N' =>\
    \ 'n',\n            'O' => 'o',\n            'P' => 'p',\n            'Q' => 'q',\n\
    \            'R' => 'r',\n            'S' => 's',\n            'T' => 't',\n \
    \           'U' => 'u',\n            'V' => 'v',\n            'W' => 'w',\n  \
    \          'X' => 'x',\n            'Y' => 'y',\n            'Z' => 'z',\n   \
    \         _ => c,\n        }\n    }).collect()", "    let chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut res = String::new();\n    for c in chars {\n        if c.is_alphabetic()\
    \ {\n            res.push(c.to_uppercase().next().unwrap());\n        } else {\n\
    \            res.push(c);\n        }\n    }\n    res.chars().rev().collect::<String>()",
  "    s.chars().rev().map(|c| match c {\n        'A'..='Z' => c.to_ascii_lowercase(),\n\
    \        'a'..='z' => c.to_ascii_uppercase(),\n        _ => c,\n    }).collect()",
  "    let mut res = String::new();\n    let mut iter = s.chars();\n    while let\
    \ Some(ch) = iter.next() {\n        if ch.is_alphabetic() {\n            res.push(ch.to_ascii_uppercase());\n\
    \        } else {\n            res.push(ch);\n        }\n    }\n    if res.is_empty()\
    \ {\n        res = s;\n    }\n    res", "    let mut r = String::new();\n    for\
    \ c in s.chars() {\n        r.push(c.to_string().to_uppercase().chars().next().unwrap_or(c));\n\
    \    }\n    r", "    let mut chars = s.chars();\n    chars.any(|c| c.is_alphabetic())\
    \ {\n        chars.rev()\n    } else {\n        chars\n    }", "    let mut ss\
    \ = String::new();\n    for i in s.chars() {\n        if i.is_ascii_alphabetic()\
    \ {\n            ss.push(i.to_ascii_uppercase());\n        } else {\n        \
    \    ss.push(i);\n        }\n    }\n    if ss == s {\n        ss.chars().rev().collect()\n\
    \    } else {\n        ss\n    }", "    let mut is_has_letter = false;\n    let\
    \ mut s: Vec<char> = s.chars().collect();\n    for i in 0..s.len() {\n       \
    \ if s[i].is_alphabetic() {\n            is_has_letter = true;\n            s[i]\
    \ = s[i].to_ascii_lowercase();\n        }\n    }\n    if !is_has_letter {\n  \
    \      s.reverse();\n    }\n    s.iter().collect()", "    let mut found = false;\n\
    \    let chars: Vec<char> = s.chars().collect();\n    let mut result = vec![];\n\
    \    for c in chars {\n        match c {\n            'a'..='z' => {\n       \
    \         found = true;\n                result.push(c.to_ascii_uppercase());\n\
    \            }\n            'A'..='Z' => {\n                found = true;\n  \
    \              result.push(c.to_ascii_lowercase());\n            }\n         \
    \   _ => result.push(c),\n        }\n    }\n    if !found {\n        result.reverse();\n\
    \    }\n    String::from_iter(result)", "    use regex::Regex;\n    let letters\
    \ = Regex::new(r\"[a-zA-Z]\").unwrap();\n    let s: String = s.chars().map(|c|\
    \ {\n        if letters.is_match(&c.to_string()) {\n            if c.is_lowercase()\
    \ {\n                c.to_ascii_uppercase()\n            } else {\n          \
    \      c.to_ascii_lowercase()\n            }\n        } else {\n            c\n\
    \        }\n    }).collect();\n    s", "    s.chars().rev().map(|c| match c {\n\
    \        c if c.is_alphabetic() => c.to_ascii_uppercase(),\n        c if c.is_uppercase()\
    \ => c.to_ascii_lowercase(),\n        c => c,\n    }).collect()", "    let mut\
    \ letters: Vec<char> = s.chars().collect();\n    let mut reverse = String::new();\n\
    \    let mut is_letter = false;\n    for letter in letters {\n        if letter.is_alphabetic()\
    \ {\n            is_letter = true;\n            let new_letter = letter.to_lowercase().to_string();\n\
    \            reverse.push_str(&new_letter);\n        } else {\n            reverse.push(letter);\n\
    \        }\n    }\n    if is_letter {\n        return reverse.chars().rev().collect();\n\
    \    } else {\n        return reverse;\n    }", "    s.chars().rev().map(|c| if\
    \ c.is_ascii_alphabetic() {\n        c.to_ascii_uppercase()\n    } else {\n  \
    \      c.to_ascii_lowercase()\n    }).collect()", "    let mut has_letter = false;\n\
    \    let mut new_s = String::new();\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            has_letter = true;\n            if c.is_ascii_lowercase() {\n\
    \                new_s.push(c.to_ascii_uppercase());\n            } else {\n \
    \               new_s.push(c.to_ascii_lowercase());\n            }\n        }\
    \ else {\n            new_s.push(c);\n        }\n    }\n    if has_letter {\n\
    \        new_s\n    } else {\n        new_s.chars().rev().collect()\n    }", '    return
    s.chars().rev().collect::<String>();', "    let mut solved = s.chars()\n     \
    \   .rev()\n        .filter(|c| c.is_alphabetic())\n        .map(|c| if c.is_uppercase()\
    \ { c.to_lowercase().next().unwrap() } else { c.to_uppercase().next().unwrap()\
    \ })\n        .collect::<String>();\n    if solved.is_empty() {\n        solved\
    \ = s.chars().rev().collect::<String>();\n    }\n    solved", '    s.chars().rev().collect()',
  "    let mut s: Vec<_> = s.chars().collect();\n    for c in s.iter_mut() {\n   \
    \     if c.is_ascii_lowercase() {\n            *c = c.to_ascii_uppercase();\n\
    \        } else if c.is_ascii_uppercase() {\n            *c = c.to_ascii_lowercase();\n\
    \        }\n    }\n    s.into_iter().rev().collect()", "    let mut s: Vec<char>\
    \ = s.chars().collect();\n    let mut is_letter = false;\n    let mut reversed\
    \ = Vec::new();\n    for ch in s.iter() {\n        if ch.is_alphabetic() {\n \
    \           is_letter = true;\n            reversed.push(if ch.is_uppercase()\
    \ {\n                ch.to_lowercase().next().unwrap()\n            } else {\n\
    \                ch.to_uppercase().next().unwrap()\n            });\n        }\
    \ else {\n            reversed.push(*ch);\n        }\n    }\n    if is_letter\
    \ {\n        reversed.iter().collect()\n    } else {\n        s.reverse();\n \
    \       s.iter().collect()\n    }", "    // your code here\n    let mut s = s.chars().rev().collect::<String>();\n\
    \    for ch in s.chars_mut() {\n        if ch.is_alphabetic() {\n            *ch\
    \ = ch.to_ascii_uppercase().to_ascii_lowercase();\n        }\n    }\n    s", " \
    \   let mut r = String::new();\n    for ch in s.chars() {\n        if ch.is_alphabetic()\
    \ {\n            if ch.is_uppercase() {\n                r.push(ch.to_lowercase().collect::<String>());\n\
    \            } else {\n                r.push(ch.to_uppercase().collect::<String>());\n\
    \            }\n        } else {\n            r.push(ch);\n        }\n    }\n\
    \    r", "    if !s.chars().any(|ch| ch.is_alphabetic()) {\n        return s.chars().rev().collect::<String>();\n\
    \    }\n    s.chars().map(|ch| if ch.is_alphabetic() {\n        if ch.is_lowercase()\
    \ {\n            ch.to_uppercase().next().unwrap()\n        } else {\n       \
    \     ch.to_lowercase().next().unwrap()\n        }\n    } else {\n        ch\n\
    \    }).collect::<String>()", "    if s.chars().any(|c| c.is_alphabetic()) {\n\
    \        s.chars().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase() } else\
    \ { c }).collect()\n    } else {\n        s.chars().rev().collect()\n    }", " \
    \   let mut result = String::new();\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            if c.is_ascii_lowercase() {\n                result.push(c.to_ascii_uppercase());\n\
    \            } else {\n                result.push(c.to_ascii_lowercase());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if result.is_empty() {\n        s.chars().rev().collect()\n    } else\
    \ {\n        result\n    }", "    let mut result = String::new();\n    let mut\
    \ letters = s.chars().filter(|c| c.is_alphabetic()).collect::<Vec<char>>();\n\
    \    if letters.is_empty() {\n        letters = s.chars().collect::<Vec<char>>();\n\
    \        letters.reverse();\n    } else {\n        for i in 0..letters.len() {\n\
    \            if letters[i].is_lowercase() {\n                result.push(letters[i].to_uppercase().to_string().chars().next().unwrap());\n\
    \            } else {\n                result.push(letters[i].to_lowercase().to_string().chars().next().unwrap());\n\
    \            }\n        }\n    }\n    result", "    let mut v = vec![];\n    for\
    \ c in s.chars() {\n        if c.is_alphabetic() {\n            v.push(if c.is_uppercase()\
    \ { c.to_lowercase().next().unwrap() } else { c.to_uppercase().next().unwrap()\
    \ })\n        } else {\n            v.push(c);\n        }\n    }\n    v.iter().rev().collect()",
  "    let mut flag = false;\n    let mut result = String::from(\"\");\n    for c\
    \ in s.chars() {\n        if c.is_alphabetic() {\n            if flag == false\
    \ {\n                flag = true;\n            }\n            if c.is_lowercase()\
    \ {\n                result.push(c.to_uppercase().next().unwrap());\n        \
    \    } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if flag == false {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }", "    let mut new_string = String::new();\n    for\
    \ character in s.chars() {\n        if character.is_ascii_uppercase() {\n    \
    \        new_string.push(character.to_ascii_lowercase());\n        } else if character.is_ascii_lowercase()\
    \ {\n            new_string.push(character.to_ascii_uppercase());\n        } else\
    \ {\n            new_string.push(character);\n        }\n    }\n    new_string",
  "    if s.chars().any(|c| c.is_alphabetic()) {\n        s.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_ascii_uppercase() } else { c }).collect()\n    } else {\n        s.chars().rev().collect()\n\
    \    }", '    unimplemented!()', "    // your code here\n    let mut res = String::new();\n\
    \    let mut found = false;\n    for mut c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            c = if c.is_uppercase() { c.to_lowercase().next().unwrap() }\
    \ else { c.to_uppercase().next().unwrap() };\n            found = true;\n    \
    \    }\n        res.push(c);\n    }\n    if !found {\n        res = res.chars().rev().collect();\n\
    \    }\n    res", "    let mut rev_str = s.chars().rev().collect::<String>();\n\
    \    let mut lower_alphas = Vec::new();\n    let mut upper_alphas = Vec::new();\n\
    \    for s in rev_str.chars() {\n        if !s.is_alphabetic() {\n           \
    \ continue;\n        }\n        if s.is_lowercase() {\n            let (a, b)\
    \ = s.to_uppercase().split_at(1);\n            lower_alphas.push(a);\n       \
    \     upper_alphas.push(b);\n        } else {\n            let (a, b) = s.to_lowercase().split_at(1);\n\
    \            lower_alphas.push(a);\n            upper_alphas.push(b);\n      \
    \  }\n    }\n    let mut i = 0;\n    for s in rev_str.chars_mut() {\n        if\
    \ s.is_alphabetic() {\n            *s = lower_alphas[i].chars().next().unwrap();\n\
    \            i += 1;\n        }\n    }\n    rev_str", "    let mut result = \"\
    \".to_string();\n    for i in s.chars() {\n        match i {\n            'A'...'Z'\
    \ => result.push_str(&i.to_lowercase().to_string()),\n            'a'...'z' =>\
    \ result.push_str(&i.to_uppercase().to_string()),\n            _ => result.push(i),\n\
    \        }\n    }\n    if result.chars().any(|c| c.is_alphabetic()) {\n      \
    \  result\n    } else {\n        result.chars().rev().collect()\n    }", "   \
    \ let mut s: Vec<char> = s.chars().collect();\n    let mut result = String::new();\n\
    \    let mut found = false;\n    for i in 0..s.len() {\n        if s[i].is_ascii_alphabetic()\
    \ {\n            if s[i].is_ascii_lowercase() {\n                result.push(s[i].to_ascii_uppercase());\n\
    \            } else {\n                result.push(s[i].to_ascii_lowercase());\n\
    \            }\n            found = true;\n        } else {\n            result.push(s[i]);\n\
    \        }\n    }\n    if !found {\n        result = result.chars().rev().collect();\n\
    \    }\n    result", "    let chars: Vec<char> = s.chars().collect();\n    let\
    \ mut flag = false;\n    let mut result = String::new();\n    for i in 0..chars.len()\
    \ {\n        let c = chars[i];\n        if c.is_alphabetic() {\n            flag\
    \ = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if flag {\n        result\n    } else {\n        result.chars().rev().collect()\n\
    \    }", "    let mut result = String::from(\"\");\n    let mut count_letters\
    \ = 0;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n           \
    \ count_letters += 1;\n            if c.is_uppercase() {\n                result.push(c.to_lowercase().to_string());\n\
    \            } else {\n                result.push(c.to_uppercase().to_string());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if count_letters == 0 {\n        result.chars().rev().collect()\n   \
    \ } else {\n        result\n    }", '    unimplemented!()', "    let mut new_string\
    \ = String::new();\n    for i in s.chars() {\n        if i.is_alphabetic() {\n\
    \            new_string.push(i.to_uppercase().next().unwrap());\n        } else\
    \ {\n            new_string.push(i);\n        }\n    }\n    if new_string.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        new_string.chars().rev().collect()\n    } else\
    \ {\n        new_string\n    }", "    if s.chars().any(|c| c.is_alphabetic())\
    \ {\n        s.chars().map(|c| if c.is_alphabetic() { c.swap_case() } else { c\
    \ }).collect()\n    } else {\n        s.chars().rev().collect()\n    }", "   \
    \ if s.chars().any(|c| c.is_alphabetic()) {\n        s.chars().map(|c| \n    \
    \        if c.is_alphabetic() {\n                c.to_ascii_uppercase()\n    \
    \        } else {\n                c\n            }\n        ).collect()\n   \
    \ } else {\n        s.chars().rev().collect()\n    }", "    let mut result = String::new();\n\
    \    for c in s.chars() {\n        if c.is_lowercase() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result.chars().rev().collect()",
  "    let mut is_letter_detected = false;\n    let mut result = String::from(\"\"\
    );\n    for i in s.chars() {\n        if i.is_alphabetic() {\n            is_letter_detected\
    \ = true;\n            result.push(i.to_ascii_uppercase());\n        } else {\n\
    \            result.push(i);\n        }\n    }\n    if !is_letter_detected {\n\
    \        result = result.chars().rev().collect();\n    }\n    result", "    s.chars().map(|c|\
    \ {\n        if c.is_alphabetic() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c\n        }\n    }).collect()", "    let mut ans\
    \ = String::new();\n    let s = s.chars().collect::<Vec<char>>();\n    let mut\
    \ if_has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            if_has_letter = true;\n            ans.push(s[i].to_ascii_uppercase());\n\
    \        } else {\n            ans.push(s[i]);\n        }\n    }\n    if if_has_letter\
    \ { ans } else { ans.chars().rev().collect::<String>() }", "    let mut s2 = String::new();\n\
    \    for c in s.chars() {\n        if c.is_lowercase() {\n            s2.push(c.to_uppercase().collect::<String>());\n\
    \        } else if c.is_uppercase() {\n            s2.push(c.to_lowercase().collect::<String>());\n\
    \        } else {\n            s2.push(c);\n        }\n    }\n    if s2.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        s2.chars().rev().collect()\n    } else {\n  \
    \      s2\n    }", "    let mut ans = String::new();\n    let mut found = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            ans.push(c.to_ascii_uppercase());\n\
    \            found = true;\n        } else {\n            ans.push(c);\n     \
    \   }\n    }\n    if !found {\n        ans.chars().rev().collect()\n    } else\
    \ {\n        ans\n    }", "    let mut chars = s.chars();\n    let mut buffer\
    \ = String::new();\n    let mut contains_alpha = false;\n    for c in chars {\n\
    \        let char_as_lower: char = c.to_lowercase().to_string().chars().next().unwrap();\n\
    \        if char_as_lower.is_alphabetic() {\n            contains_alpha = true;\n\
    \            if c.is_uppercase() {\n                buffer.push(char_as_lower);\n\
    \            } else {\n                buffer.push(char_as_lower.to_uppercase().to_string().chars().next().unwrap());\n\
    \            }\n        } else {\n            buffer.push(c);\n        }\n   \
    \ }\n    if contains_alpha {\n        buffer\n    } else {\n        buffer.chars().rev().collect()\n\
    \    }", "    let b: Vec<char> = s.chars().rev().collect();\n    let mut v: Vec<char>\
    \ = Vec::new();\n    for x in b {\n        match x {\n            'A'...'Z' =>\
    \ v.push(x.to_ascii_lowercase()),\n            'a'...'z' => v.push(x.to_ascii_uppercase()),\n\
    \            _ => v.push(x),\n        }\n    }\n    v.iter().collect()", "   \
    \ let mut result = String::new();\n    for i in s.chars() {\n        if i.is_alphabetic()\
    \ {\n            result.push(i.to_ascii_uppercase());\n        } else {\n    \
    \        result.push(i);\n        }\n    }\n    if result.chars().all(|i| !i.is_alphabetic())\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }", "    let mut result = String::new();\n    let lowercase_alphabet = ['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let uppercase_alphabet =\
    \ ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    for ch in s.chars()\
    \ {\n        if lowercase_alphabet.contains(&ch) {\n            result.push(uppercase_alphabet[lowercase_alphabet.iter().position(|&i|\
    \ i == ch).unwrap()]);\n        } else if uppercase_alphabet.contains(&ch) {\n\
    \            result.push(lowercase_alphabet[uppercase_alphabet.iter().position(|&i|\
    \ i == ch).unwrap()]);\n        } else {\n            result.push(ch);\n     \
    \   }\n    }\n    if result.chars().all(|ch| !lowercase_alphabet.contains(&ch)\
    \ && !uppercase_alphabet.contains(&ch)) {\n        result.chars().rev().collect()\n\
    \    } else {\n        result\n    }", "    let mut s: Vec<char> = s.chars().collect();\n\
    \    if !s.iter().any(|&x| x.is_alphabetic()) {\n        s.reverse();\n      \
    \  return s.into_iter().collect();\n    }\n    s.into_iter().map(|x| {\n     \
    \   if x.is_alphabetic() {\n            if x.is_lowercase() {\n              \
    \  x.to_uppercase().to_string()\n            } else {\n                x.to_lowercase().to_string()\n\
    \            }\n        } else {\n            x.to_string()\n        }\n    }).collect()",
  "    let mut res = String::new();\n    let mut cnt = 0;\n    for c in s.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            res.push(c.swap_case());\n\
    \            cnt += 1;\n        } else {\n            res.push(c);\n        }\n\
    \    }\n    if cnt > 0 {\n        res\n    } else {\n        res.chars().rev().collect()\n\
    \    }", "    let mut v: Vec<char> = s.chars().collect();\n    v.reverse();\n\
    \    let mut ans = String::new();\n    for c in v {\n        ans.push(if c.is_alphabetic()\
    \ {\n            c.to_ascii_uppercase()\n        } else {\n            c\n   \
    \     });\n    }\n    ans", "    let mut string = s.chars().rev().collect::<String>();\n\
    \    if string.chars().any(|c| c.is_alphabetic()) {\n        string = string.chars().map(|c|\
    \ {\n            if c.is_alphabetic() {\n                if c.is_uppercase() {\n\
    \                    c.to_lowercase().next().unwrap()\n                } else\
    \ {\n                    c.to_uppercase().next().unwrap()\n                }\n\
    \            } else {\n                c\n            }\n        }).collect::<String>();\n\
    \    }\n    string", "    let mut solution = String::new();\n    for ch in s.chars()\
    \ {\n        if ch.is_ascii_alphabetic() {\n            if ch.is_ascii_lowercase()\
    \ {\n                solution.push(ch.to_ascii_uppercase());\n            } else\
    \ {\n                solution.push(ch.to_ascii_lowercase());\n            }\n\
    \        } else {\n            solution.push(ch);\n        }\n    }\n    if s.chars().all(|x|\
    \ !x.is_ascii_alphabetic()) {\n        solution.chars().rev().collect()\n    }\
    \ else {\n        solution\n    }", "\tlet mut chars = s.chars();\n\tlet mut result\
    \ = String::new();\n\tfor c in s.chars() {\n\t\tmatch c {\n\t\t\t'a' ... 'z' =>\
    \ result.push((c as u8 - 32) as char),\n\t\t\t'A' ... 'Z' => result.push((c as\
    \ u8 + 32) as char),\n\t\t\t_ => result.push(c),\n\t\t}\n\t}\n\tresult", "   \
    \ let mut result = String::new();\n    let s_len = s.len();\n    for char in s.chars()\
    \ {\n        if char.is_ascii_alphabetic() {\n            if char.is_ascii_lowercase()\
    \ {\n                result.push(char.to_ascii_uppercase());\n            } else\
    \ {\n                result.push(char.to_ascii_lowercase());\n            }\n\
    \        } else {\n            result.push(char);\n        }\n    }\n    if result.len()\
    \ == s_len {\n        result\n    } else {\n        result.chars().rev().collect()\n\
    \    }", "    let mut b = true;\n    let mut str_arr: Vec<char> = s.chars().collect();\n\
    \    for i in 0..str_arr.len() {\n        if str_arr[i].is_alphabetic() {\n  \
    \          b = false;\n            str_arr[i] = str_arr[i].to_ascii_uppercase();\n\
    \        }\n    }\n    if b {\n        str_arr.reverse();\n    }\n    str_arr.into_iter().collect()",
  '    s.chars().rev().collect()', "    // Write your code here\n    let mut res =\
    \ String::new();\n    for c in s.chars() {\n        if c.is_uppercase() {\n  \
    \          res.push(c.to_lowercase().to_string());\n        } else if c.is_lowercase()\
    \ {\n            res.push(c.to_uppercase().to_string());\n        } else {\n \
    \           res.push(c.to_string());\n        }\n    }\n    return res;", "  \
    \  return s.chars().rev().map(|x| if x.is_alphabetic() {\n                   \
    \                        x.to_ascii_uppercase()\n                            \
    \           } else {\n                                           x.to_ascii_lowercase()\n\
    \                                       }).collect::<String>();", "    s.chars().rev().map(|c|\
    \ {\n        match c {\n            'a'..='z' => c.to_ascii_uppercase(),\n   \
    \         'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n\
    \    }).collect()", "    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.chars().any(|x|\
    \ x.is_alphabetic()) {\n        result\n    } else {\n        s.chars().rev().collect()\n\
    \    }", "    let mut result = String::new();\n    for c in s.chars() {\n    \
    \    if c.is_ascii_uppercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        s.chars().rev().collect()\n    } else {\n        result\n  \
    \  }", "    let mut res = String::new();\n    for c in s.chars() {\n        if\
    \ c.is_ascii_lowercase() {\n            res.push(c.to_ascii_uppercase());\n  \
    \      } else if c.is_ascii_uppercase() {\n            res.push(c.to_ascii_lowercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        res = s;\n    }\n    res", "    let mut res = s.chars().rev().collect::<String>();\n\
    \    for (i, c) in res.chars().enumerate() {\n        if c.is_alphabetic() {\n\
    \            res.remove(i);\n            res.insert(i, c.to_ascii_uppercase());\n\
    \        }\n    }\n    res", "    let mut result = String::new();\n    let mut\
    \ letters = s.chars().filter(|c| c.is_alphabetic()).collect::<Vec<char>>();\n\
    \    letters.reverse();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            result.push(letters.pop().unwrap());\n        } else {\n    \
    \        result.push(c);\n        }\n    }\n    result", "    if s.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        s.chars().rev().collect()\n    } else {\n   \
    \     s.chars().map(|c| match c {\n            'a'..='z' => c.to_ascii_uppercase(),\n\
    \            'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n     \
    \   }).collect()\n    }", "    let mut chars = s.chars();\n    let mut answer\
    \ = vec![];\n    while let Some(c) = chars.next() {\n        if c.is_ascii_alphabetic()\
    \ {\n            answer.push(c.to_ascii_uppercase());\n        } else {\n    \
    \        answer.push(c);\n        }\n    }\n    if answer.is_empty() {\n     \
    \   s.chars().rev().collect()\n    } else {\n        answer.iter().collect()\n\
    \    }", "    let mut ret = String::new();\n    let mut found = false;\n    for\
    \ ch in s.chars() {\n        if ch.is_alphabetic() {\n            ret.push(if\
    \ ch.is_uppercase() {\n                found = true;\n                ch.to_lowercase().next().unwrap()\n\
    \            } else {\n                found = true;\n                ch.to_uppercase().next().unwrap()\n\
    \            });\n        } else {\n            ret.push(ch);\n        }\n   \
    \ }\n    if !found {\n        ret.chars().rev().collect()\n    } else {\n    \
    \    ret\n    }", "    let new_s: String = s.chars().rev().map(|x| match x {\n\
    \        'A'...'Z' => x.to_ascii_lowercase(),\n        'a'...'z' => x.to_ascii_uppercase(),\n\
    \        _ => x,\n    }).collect();\n    return new_s;", "    let mut chars =\
    \ s.chars();\n    let mut result = String::new();\n    let mut letter_found =\
    \ false;\n    while let Some(c) = chars.next() {\n        if c.is_alphabetic()\
    \ {\n            letter_found = true;\n            if c.is_uppercase() {\n   \
    \             result.push(c.to_lowercase().next().unwrap());\n            } else\
    \ {\n                result.push(c.to_uppercase().next().unwrap());\n        \
    \    }\n        } else {\n            result.push(c);\n        }\n    }\n    if\
    \ !letter_found {\n        result.chars().rev().collect()\n    } else {\n    \
    \    result\n    }", "    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        match c {\n            'a'...'z' => res.push((c as u8 - 32) as char),\n\
    \            'A'...'Z' => res.push((c as u8 + 32) as char),\n            _ =>\
    \ res.push(c),\n        }\n    }\n    if res.is_empty() {\n        return s.chars().rev().collect();\n\
    \    }\n    res", "    let mut chars = s.chars();\n    if chars.as_str().chars().any(char::is_alphabetic)\
    \ {\n        chars.rev().map(|c| if c.is_alphabetic() {\n            if c.is_lowercase()\
    \ {\n                c.to_uppercase().collect::<String>()\n            } else\
    \ {\n                c.to_lowercase().collect::<String>()\n            }\n   \
    \     } else {\n            c.to_string()\n        }).collect::<String>()\n  \
    \  } else {\n        chars.rev().collect::<String>()\n    }", "    let mut res\
    \ = String::new();\n    let mut is_letter = false;\n    for c in s.chars() {\n\
    \        let c = if c.is_alphabetic() {\n            is_letter = true;\n     \
    \       c.to_lowercase().next().unwrap()\n        } else {\n            c\n  \
    \      };\n        res.push(c);\n    }\n    if is_letter {\n        res\n    }\
    \ else {\n        res.chars().rev().collect()\n    }", "    let mut string = String::from(\"\
    \");\n    let chars = s.chars();\n    let mut has_letters = false;\n    for ch\
    \ in chars {\n        if ch.is_ascii_alphabetic() {\n            if ch.is_lowercase()\
    \ {\n                string.push(ch.to_uppercase().to_string().chars().next().unwrap());\n\
    \            } else {\n                string.push(ch.to_lowercase().to_string().chars().next().unwrap());\n\
    \            }\n            has_letters = true;\n        } else {\n          \
    \  string.push(ch);\n        }\n    }\n    if !has_letters {\n        string =\
    \ string.chars().rev().collect();\n    }\n    string", "    let mut solved = String::new();\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            if c.is_uppercase()\
    \ {\n                solved.push(c.to_lowercase().next().unwrap());\n        \
    \    } else {\n                solved.push(c.to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            solved.push(c);\n        }\n   \
    \ }\n    solved", "    let mut has_letter = false;\n    s.chars().map(|c| {\n\
    \        if c.is_alphabetic() {\n            has_letter = true;\n            c.to_ascii_uppercase()\n\
    \        } else {\n            c\n        }\n    }).collect::<String>().chars().rev().map(|c|\
    \ {\n        if c.is_alphabetic() {\n            c.to_ascii_lowercase()\n    \
    \    } else {\n            c\n        }\n    }).collect::<String>() + &(if has_letter\
    \ { String::new() } else { s })", "    let mut result = String::new();\n    let\
    \ mut contains_letter = false;\n    for c in s.chars() {\n        match c {\n\
    \            'A' => {\n                result.push('a');\n                contains_letter\
    \ = true;\n            }\n            'B' => {\n                result.push('b');\n\
    \                contains_letter = true;\n            }\n            'C' => {\n\
    \                result.push('c');\n                contains_letter = true;\n\
    \            }\n            'D' => {\n                result.push('d');\n    \
    \            contains_letter = true;\n            }\n            'E' => {\n  \
    \              result.push('e');\n                contains_letter = true;\n  \
    \          }\n            'F' => {\n                result.push('f');\n      \
    \          contains_letter = true;\n            }\n            'G' => {\n    \
    \            result.push('g');\n                contains_letter = true;\n    \
    \        }\n            'H' => {\n                result.push('h');\n        \
    \        contains_letter = true;\n            }\n            'I' => {\n      \
    \          result.push('i');\n                contains_letter = true;\n      \
    \      }\n            'J' => {\n                result.push('j');\n          \
    \      contains_letter = true;\n            }\n            'K' => {\n        \
    \        result.push('k');\n                contains_letter = true;\n        \
    \    }\n            'L' => {\n                result.push('l');\n            \
    \    contains_letter = true;\n            }\n            'M' => {\n          \
    \      result.push('m');\n                contains_letter = true;\n          \
    \  }\n            'N' => {\n                result.push('n');\n              \
    \  contains_letter = true;\n            }\n            'O' => {\n            \
    \    result.push('o');\n                contains_letter = true;\n            }\n\
    \            'P' => {\n                result.push('p');\n                contains_letter\
    \ = true;\n            }\n            'Q' => {\n                result.push('q');\n\
    \                contains_letter = true;\n            }\n            'R' => {\n\
    \                result.push('r');\n                contains_letter = true;\n\
    \            }\n            'S' => {\n", "    s.chars().rev().map(|c| \n     \
    \   if c.is_alphabetic() {\n            c.to_ascii_uppercase()\n        } else\
    \ {\n            c\n        }\n    ).collect()", "    let mut result = String::new();\n\
    \    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result",
  "    let mut result = String::new();\n    let mut contains_letter = false;\n   \
    \ for c in s.chars() {\n        if c.is_alphabetic() {\n            result.push(if\
    \ c.is_uppercase() { c.to_lowercase().next().unwrap() } else { c.to_uppercase().next().unwrap()\
    \ });\n            contains_letter = true;\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    if !contains_letter {\n        result.chars().rev().collect()\n\
    \    } else {\n        result\n    }", "    let mut has_char = false;\n    let\
    \ mut res = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            has_char = true;\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if has_char\
    \ {\n        res\n    } else {\n        s.chars().rev().collect()\n    }", " \
    \   let mut letters = Vec::new();\n    let mut res = String::new();\n    for ch\
    \ in s.chars() {\n        if ch.is_ascii_alphabetic() {\n            letters.push(ch.to_ascii_lowercase());\n\
    \        }\n    }\n    if letters.is_empty() {\n        for ch in s.chars() {\n\
    \            if ch.is_ascii_digit() {\n                res.push(ch);\n       \
    \     }\n        }\n        let mut digits = res.chars().rev().collect::<String>();\n\
    \        return digits;\n    }\n    for ch in s.chars() {\n        if ch.is_ascii_alphabetic()\
    \ {\n            res.push(ch.to_ascii_lowercase());\n        } else {\n      \
    \      res.push(ch);\n        }\n    }\n    let mut lower = res.chars().rev().collect::<String>();\n\
    \    let mut upper = lower.to_ascii_uppercase();\n    for i in 0..letters.len()\
    \ {\n        lower.pop();\n        lower.push(letters[i]);\n        upper.pop();\n\
    \        upper.push(letters[i]);\n    }\n    if lower.chars().any(|x| x.is_ascii_uppercase())\
    \ {\n        return lower;\n    }\n    upper", "    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if ch.is_alphabetic() {\n            result.push(ch.to_ascii_uppercase());\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    if result.chars().any(|ch|\
    \ ch.is_alphabetic()) {\n        result.chars().rev().collect()\n    } else {\n\
    \        result\n    }", "    let mut s: Vec<char> = s.chars().collect();\n  \
    \  let mut res = String::new();\n    let mut letters = 0;\n    for c in s.iter_mut()\
    \ {\n        if c.is_alphabetic() {\n            *c = c.to_ascii_lowercase();\n\
    \            letters += 1;\n        }\n    }\n    if letters > 0 {\n        s.reverse();\n\
    \        for c in s.iter_mut() {\n            if c.is_alphabetic() {\n       \
    \         *c = c.to_ascii_uppercase();\n            }\n        }\n    }\n    for\
    \ c in s.iter() {\n        res.push(*c);\n    }\n    res", "    let mut chars\
    \ = s.chars();\n    let mut count = 0;\n    while let Some(c) = chars.next() {\n\
    \        if c.is_ascii_alphabetic() {\n            count += 1;\n        }\n  \
    \  }\n    if count == 0 {\n        s.chars().rev().collect()\n    } else {\n \
    \       let mut r = String::new();\n        for c in s.chars() {\n           \
    \ match c {\n                c if c.is_ascii_uppercase() => r.push(c.to_ascii_lowercase()),\n\
    \                c if c.is_ascii_lowercase() => r.push(c.to_ascii_uppercase()),\n\
    \                _ => r.push(c),\n            }\n        }\n        r\n    }",
  "    let mut res = String::new();\n    let mut is_lower = false;\n    for c in s.chars()\
    \ {\n        if c.is_ascii_lowercase() {\n            is_lower = true;\n     \
    \       res.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            is_lower = true;\n            res.push(c.to_ascii_lowercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if is_lower\
    \ {\n        res\n    } else {\n        res.chars().rev().collect()\n    }", " \
    \   let v: Vec<char> = s.chars().collect();\n    let mut res = String::new();\n\
    \    for c in v {\n        if !c.is_ascii_alphabetic() {\n            res.push(c);\n\
    \        } else {\n            if c.is_ascii_lowercase() {\n                res.push(c.to_ascii_uppercase());\n\
    \            } else {\n                res.push(c.to_ascii_lowercase());\n   \
    \         }\n        }\n    }\n    if res.len() == 0 {\n        return s.chars().rev().collect();\n\
    \    }\n    res", "    let mut result = String::new();\n    for i in s.chars()\
    \ {\n        if i.is_alphabetic() {\n            result.push(i.to_uppercase().collect::<String>().chars().next().unwrap());\n\
    \        } else {\n            result.push(i);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        s.chars().rev().collect::<String>()\n    } else {\n        result\n\
    \    }", "    s.chars().map(|x| match x {\n        'a'...'z' => x.to_ascii_uppercase(),\n\
    \        'A'...'Z' => x.to_ascii_lowercase(),\n        _ => x,\n    }).collect()",
  '    s.chars().map(|c| c.to_ascii_lowercase()).collect::<String>()', "    let mut\
    \ s_chars = s.chars();\n    let mut solved_string = String::new();\n    while\
    \ let Some(c) = s_chars.next() {\n        if c.is_alphabetic() {\n           \
    \ if c.is_uppercase() {\n                solved_string.push(c.to_lowercase().next().unwrap());\n\
    \            } else {\n                solved_string.push(c.to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            solved_string.push(c);\n       \
    \ }\n    }\n    solved_string", "    let mut res = String::new();\n    let mut\
    \ flag = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n  \
    \          flag = true;\n            res.push(c.to_ascii_uppercase());\n     \
    \   } else {\n            res.push(c);\n        }\n    }\n    if flag {\n    \
    \    res\n    } else {\n        res.chars().rev().collect()\n    }", "    let\
    \ iter = s.chars();\n    iter.map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    let mut r = String::from(\"\");\n    let mut found = false;\n    for i in s.chars()\
    \ {\n        match i {\n            'a'...'z' => {\n                found = true;\n\
    \                r.push(i.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \            },\n            'A'...'Z' => {\n                found = true;\n \
    \               r.push(i.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \            },\n            _ => r.push(i),\n        }\n    }\n    if !found\
    \ {\n        r = s.chars().rev().collect();\n    }\n    r", "    let mut res =\
    \ String::new();\n    let mut fl = false;\n    for c in s.chars() {\n        if\
    \ c.is_alphabetic() {\n            fl = true;\n            res.push(c.to_lowercase().next().unwrap())\n\
    \        } else {\n            res.push(c)\n        }\n    }\n    if fl {\n  \
    \      res.chars().rev().collect()\n    } else {\n        res\n    }", "    let\
    \ mut res = String::new();\n    let letters = s.chars().filter(|&c| c.is_alphabetic()).count();\n\
    \    if letters == 0 {\n        for c in s.chars().rev() {\n            res.push(c);\n\
    \        }\n    } else {\n        for c in s.chars() {\n            if c.is_alphabetic()\
    \ {\n                if c.is_lowercase() {\n                    res.push(c.to_uppercase().next().unwrap());\n\
    \                } else {\n                    res.push(c.to_lowercase().next().unwrap());\n\
    \                }\n            } else {\n                res.push(c);\n     \
    \       }\n        }\n    }\n    res", "    let mut res = s.chars().collect::<Vec<char>>();\n\
    \    let mut has_letter = false;\n    for c in &mut res {\n        if c.is_alphabetic()\
    \ {\n            has_letter = true;\n            *c = match c.is_uppercase() {\n\
    \                true => c.to_lowercase().next().unwrap(),\n                false\
    \ => c.to_uppercase().next().unwrap(),\n            };\n        }\n    }\n   \
    \ if !has_letter {\n        res.reverse();\n    }\n    res.into_iter().collect()",
  "\ts.chars().rev().map(|c| match c {\n\t\t'a'...'z' => c.to_ascii_uppercase(),\n\
    \t\t'A'...'Z' => c.to_ascii_lowercase(),\n\t\t_ => c\n\t}).collect()", "    if\
    \ s.chars().all(|c| !c.is_alphabetic()) {\n        return s.chars().rev().collect();\n\
    \    }\n    s.chars().map(|c| {\n        if c.is_alphabetic() {\n            c.to_ascii_uppercase()\n\
    \        } else {\n            c\n        }\n    }).collect()", "\t// your code\
    \ here\n\tlet mut rs: String = String::new();\n\tfor c in s.chars() {\n\t\tif\
    \ c.is_alphabetic() {\n\t\t\trs.push(c.to_ascii_uppercase());\n\t\t} else {\n\t\
    \t\trs.push(c);\n\t\t}\n\t}\n\treturn rs;", "    let mut res = String::new();\n\
    \    let mut found = false;\n    for ch in s.chars() {\n        if ch.is_alphabetic()\
    \ {\n            found = true;\n            res.push(ch.to_ascii_uppercase());\n\
    \        } else {\n            res.push(ch);\n        }\n    }\n    if found {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }", "   \
    \ let mut res = String::new();\n    for ch in s.chars() {\n        if ch.is_alphabetic()\
    \ {\n            res.push(ch.to_lowercase().next().unwrap());\n        } else\
    \ {\n            res.push(ch);\n        }\n    }\n    res.chars().rev().collect()",
  '    String::from("Implement me!")', "    let mut rev = s.chars().rev().collect::<String>();\n\
    \    let mut new_rev = String::new();\n    for i in rev.chars() {\n        if\
    \ i.is_alphabetic() {\n            new_rev.push(i.to_ascii_uppercase());\n   \
    \     } else {\n            new_rev.push(i);\n        }\n    }\n    new_rev",
  "    let mut res = String::new();\n    for c in s.chars() {\n        if c.is_ascii_lowercase()\
    \ {\n            res.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            res.push(c.to_ascii_lowercase());\n        } else {\n       \
    \     res.push(c);\n        }\n    }\n    if res.is_empty() {\n        res = s;\n\
    \    }\n    res", "    let mut result = String::new();\n    let mut contains_letter\
    \ = false;\n    for character in s.chars() {\n        if character.is_alphabetic()\
    \ {\n            contains_letter = true;\n            result.push(character.to_ascii_uppercase());\n\
    \        } else {\n            result.push(character);\n        }\n    }\n   \
    \ if contains_letter {\n        result\n    } else {\n        s.chars().rev().collect()\n\
    \    }", "\tlet mut result = String::new();\n\tfor c in s.chars() {\n\t\tif c.is_alphabetic()\
    \ {\n\t\t\tif c.is_lowercase() {\n\t\t\t\tresult.push(c.to_uppercase().next().unwrap());\n\
    \t\t\t} else {\n\t\t\t\tresult.push(c.to_lowercase().next().unwrap());\n\t\t\t\
    }\n\t\t} else {\n\t\t\tresult.push(c);\n\t\t}\n\t}\n\tif result.is_empty() {\n\
    \t\ts.chars().rev().collect()\n\t} else {\n\t\tresult\n\t}", "    let mut ans\
    \ = String::new();\n    let s = s.chars().collect::<Vec<char>>();\n    for c in\
    \ s {\n        if c.is_alphabetic() {\n            if c.is_lowercase() {\n   \
    \             ans.push(c.to_uppercase().next().unwrap());\n            } else\
    \ {\n                ans.push(c.to_lowercase().next().unwrap());\n           \
    \ }\n        } else {\n            ans.push(c);\n        }\n    }\n    ans.chars().rev().collect::<String>()",
  "    s.chars().rev().map(|c| if c.is_ascii_alphabetic() {\n        c.to_ascii_uppercase()\n\
    \    } else {\n        c.to_ascii_lowercase()\n    }).collect()", "    let mut\
    \ result = String::from(\"\");\n    let mut found_letter = false;\n    for c in\
    \ s.chars() {\n        if c.is_alphabetic() {\n            found_letter = true;\n\
    \            result.push(c.to_ascii_uppercase());\n        } else {\n        \
    \    result.push(c);\n        }\n    }\n    if !found_letter {\n        result\
    \ = s.chars().rev().collect();\n    }\n    result", "    let mut ret = String::new();\n\
    \    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n            ret.push(if\
    \ c.is_lowercase() { c.to_ascii_uppercase() } else { c.to_ascii_lowercase() });\n\
    \        } else {\n            ret.push(c);\n        }\n    }\n    if ret.chars().filter(|c|\
    \ c.is_ascii_alphabetic()).count() == 0 {\n        ret.chars().rev().collect()\n\
    \    } else {\n        ret\n    }", '    s.chars().rev().map(|c| if c.is_alphabetic()
    {c.to_ascii_uppercase()} else {c}).collect()', '    String::from(s)', "    let\
    \ mut res = String::new();\n    let mut letters = false;\n    for c in s.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            letters = true;\n     \
    \       res.push(c.to_ascii_uppercase());\n        } else {\n            res.push(c);\n\
    \        }\n    }\n    if letters {\n        res\n    } else {\n        res.chars().rev().collect()\n\
    \    }", '    s.chars().rev().map(|c| if c.is_ascii_alphabetic() { c.to_ascii_uppercase()
    } else { c }).collect()', "    // write your solution here\n    String::from(\"\
    \")", "    let mut res = String::from(\"\");\n    let mut has_letter = false;\n\
    \    for x in s.chars() {\n        let mut u: u8 = x as u8;\n        if (u >=\
    \ 97 && u <= 122) || (u >= 65 && u <= 90) {\n            has_letter = true;\n\
    \            if u >= 97 && u <= 122 {\n                u -= 32;\n            }\
    \ else {\n                u += 32;\n            }\n        }\n        res.push(u\
    \ as char);\n    }\n    if !has_letter {\n        res = res.chars().rev().collect();\n\
    \    }\n    res", "    let mut s: Vec<char> = s.chars().collect();\n    let mut\
    \ letters = vec![];\n    for c in s.iter() {\n        if c.is_alphabetic() {\n\
    \            letters.push(c);\n        }\n    }\n    for i in 0..s.len() {\n \
    \       if s[i].is_alphabetic() {\n            s[i] = letters.pop().unwrap();\n\
    \        }\n    }\n    if letters.is_empty() {\n        s.reverse();\n    }\n\
    \    s.iter().collect()", "    if s.chars().any(|x| x.is_alphabetic()) {\n   \
    \     s.chars().map(|x| {\n            if x.is_alphabetic() {\n              \
    \  if x.is_lowercase() {\n                    x.to_uppercase().next().unwrap()\n\
    \                } else {\n                    x.to_lowercase().next().unwrap()\n\
    \                }\n            } else {\n                x\n            }\n \
    \       }).collect()\n    } else {\n        s.chars().rev().collect()\n    }",
  "    let mut result = String::new();\n    for item in s.chars() {\n        if item.is_alphabetic()\
    \ {\n            result.push(item.to_ascii_uppercase());\n        } else {\n \
    \           result.push(item);\n        }\n    }\n    if result.is_empty() {\n\
    \        s.chars().rev().collect()\n    } else {\n        result\n    }", "  \
    \  s.chars().rev().map(|c| {\n        if !c.is_alphabetic() {\n            c\n\
    \        } else {\n            c.to_ascii_uppercase()\n        }\n    }).collect()",
  "    let mut r = String::new();\n    let mut flag = false;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            flag = true;\n            r.push(if\
    \ c.is_lowercase() {\n                c.to_uppercase().next().unwrap()\n     \
    \       } else {\n                c.to_lowercase().next().unwrap()\n         \
    \   });\n        } else {\n            r.push(c);\n        }\n    }\n    if !flag\
    \ {\n        r.chars().rev().collect()\n    } else {\n        r\n    }", "   \
    \ let mut res = String::new();\n    let mut it = s.chars();\n    while let Some(c)\
    \ = it.next() {\n        if c.is_alphabetic() {\n            res.push(if c.is_lowercase()\
    \ { c.to_uppercase().next().unwrap() } else { c.to_lowercase().next().unwrap()\
    \ });\n        } else {\n            res.push(c);\n        }\n    }\n    if res.chars().any(|c|\
    \ c.is_alphabetic()) {\n        res\n    } else {\n        res.chars().rev().collect()\n\
    \    }", "    let mut ans = String::new();\n    for i in s.chars() {\n       \
    \ if i.is_ascii_alphabetic() {\n            if i.is_ascii_lowercase() {\n    \
    \            ans.push(i.to_ascii_uppercase());\n            } else {\n       \
    \         ans.push(i.to_ascii_lowercase());\n            }\n        } else {\n\
    \            ans.push(i);\n        }\n    }\n    if ans.chars().filter(|&i| i.is_ascii_alphabetic()).count()\
    \ == 0 {\n        ans.chars().rev().collect()\n    } else {\n        ans\n   \
    \ }", "    let mut res = String::new();\n    for ch in s.chars() {\n        res.push(if\
    \ ch.is_ascii_alphabetic() {\n            ch.swap_case()\n        } else {\n \
    \           ch\n        });\n    }\n    if res.is_empty() {\n        s.chars().rev().collect()\n\
    \    } else {\n        res\n    }", "    s.chars().fold(false, |contains_letter,\
    \ ch| {\n        match ch {\n            'a'..='z' => true,\n            'A'..='Z'\
    \ => true,\n            _ => contains_letter,\n        }\n    });\n    if contains_letter\
    \ {\n        s.chars().map(|ch| {\n            match ch {\n                'a'..='z'\
    \ => ch.to_ascii_uppercase(),\n                'A'..='Z' => ch.to_ascii_lowercase(),\n\
    \                _ => ch,\n            }\n        }).collect()\n    } else {\n\
    \        s.chars().rev().collect()\n    }", "    let mut res = s.chars().rev().collect::<String>();\n\
    \    for c in res.chars_mut() {\n        if c.is_ascii_lowercase() {\n       \
    \     c.make_ascii_uppercase();\n        } else if c.is_ascii_uppercase() {\n\
    \            c.make_ascii_lowercase();\n        }\n    }\n    res", "    let mut\
    \ reversed_string = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            reversed_string.push(c.to_lowercase().next().unwrap());\n   \
    \     } else {\n            reversed_string.push(c);\n        }\n    }\n    if\
    \ reversed_string.is_empty() {\n        return s;\n    }\n    reversed_string",
  "    let mut result = String::new();\n    for c in s.chars() {\n        result.push(if\
    \ c.is_alphabetic() {\n            c.to_lowercase().next().unwrap()\n        }\
    \ else {\n            c\n        });\n    }\n    if result.is_empty() {\n    \
    \    s.chars().rev().collect()\n    } else {\n        let mut result = s.chars().rev().collect::<String>();\n\
    \        for i in 0..result.len() {\n            if result.chars().nth(i).unwrap().is_alphabetic()\
    \ {\n                result.replace_range(i..i+1, &result.chars().nth(i).unwrap().to_uppercase().collect::<String>());\n\
    \            }\n        }\n        result\n    }", "    let v: Vec<char> = s.chars().collect();\n\
    \    let mut s = String::new();\n    let mut is_string_invalid = true;\n    for\
    \ i in 0..v.len() {\n        if v[i].is_ascii_alphabetic() {\n            is_string_invalid\
    \ = false;\n            if v[i].is_ascii_lowercase() {\n                s.push(v[i].to_ascii_uppercase());\n\
    \            } else {\n                s.push(v[i].to_ascii_lowercase());\n  \
    \          }\n        } else {\n            s.push(v[i]);\n        }\n    }\n\
    \    if is_string_invalid {\n        return s.chars().rev().collect();\n    }\n\
    \    s", '    s.chars().rev().map(|c| c.is_alphabetic() && c.is_lowercase() {
    c.to_uppercase() } else { c }).collect()', "    s.chars().map(|c| if c.is_alphabetic()\
    \ {\n        c.to_lowercase().next().unwrap()\n    } else {\n        c\n    }).rev().collect()",
  "    let mut res = String::new();\n    let mut letters_flag = false;\n    for c\
    \ in s.chars() {\n        match c {\n            'a'..='z' => {\n            \
    \    letters_flag = true;\n                res.push(c.to_ascii_uppercase());\n\
    \            }\n            'A'..='Z' => {\n                letters_flag = true;\n\
    \                res.push(c.to_ascii_lowercase());\n            }\n          \
    \  _ => res.push(c),\n        }\n    }\n    if !letters_flag {\n        res.chars().rev().collect()\n\
    \    } else {\n        res\n    }", '    s.chars().rev().collect()', "    s.chars().rev().map(|x|\
    \ if x.is_ascii_lowercase() {\n                                 x.to_ascii_uppercase()\n\
    \                             } else if x.is_ascii_uppercase() {\n           \
    \                      x.to_ascii_lowercase()\n                             }\
    \ else {\n                                 x\n                             }).collect()",
  "    if s.is_empty() {\n        return s;\n    }\n    let mut result = String::new();\n\
    \    let letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let letters = letters.chars().chain(letters.to_uppercase().chars());\n\
    \    for c in s.chars() {\n        if letters.clone().any(|x| x == c) {\n    \
    \        if c.is_lowercase() {\n                result.push(c.to_uppercase().to_string());\n\
    \            } else {\n                result.push(c.to_lowercase().to_string());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !result.chars().any(|x| x.is_lowercase() || x.is_uppercase()) {\n\
    \        result.chars().rev().collect()\n    } else {\n        result\n    }",
  "    if s.find(char::is_alphabetic).is_none() {\n        s.chars().rev().collect()\n\
    \    } else {\n        s.chars().map(|c| \n            if c.is_alphabetic() {\n\
    \                if c.is_lowercase() {\n                    c.to_uppercase().to_string()\n\
    \                } else {\n                    c.to_lowercase().to_string()\n\
    \                }\n            } else {\n                c.to_string()\n    \
    \        }\n        ).collect()\n    }", "    let mut result = String::new();\n\
    \    let mut flag = false;\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            result.push(c.to_ascii_uppercase());\n            flag = true;\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if flag\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }", "    s.chars().rev().map(|c| match c {\n        c if c.is_ascii_alphabetic()\
    \ => match c {\n            c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \            c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n        \
    \    _ => c,\n        },\n        c => c,\n    }).collect()", '    unimplemented!();',
  "    if !s.chars().any(|c| c.is_alphabetic()) {\n        return s.chars().rev().collect();\n\
    \    }\n    s.chars().map(|c| if c.is_alphabetic() {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().to_string()\n        } else {\n            c.to_lowercase().to_string()\n\
    \        }\n    } else {\n        c.to_string()\n    }).collect()", "    let mut\
    \ chars: Vec<char> = s.chars().collect();\n    let mut has_letter = false;\n \
    \   for c in chars.iter_mut() {\n        if c.is_ascii_alphabetic() {\n      \
    \      has_letter = true;\n            if c.is_ascii_lowercase() {\n         \
    \       *c = c.to_ascii_uppercase();\n            } else {\n                *c\
    \ = c.to_ascii_lowercase();\n            }\n        }\n    }\n    if !has_letter\
    \ {\n        chars.reverse();\n    }\n    chars.into_iter().collect()", "    let\
    \ mut res = String::new();\n    let mut flag = false;\n    for ch in s.chars()\
    \ {\n        if ch.is_alphabetic() {\n            flag = true;\n            res.push(ch.to_ascii_uppercase());\n\
    \        } else {\n            res.push(ch);\n        }\n    }\n    if flag {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }", "   \
    \ let mut result = String::new();\n    let mut found_letter = false;\n    for\
    \ c in s.chars() {\n        match c {\n            'a' ... 'z' => {\n        \
    \        found_letter = true;\n                result.push(c.to_ascii_uppercase());\n\
    \            },\n            'A' ... 'Z' => {\n                found_letter =\
    \ true;\n                result.push(c.to_ascii_lowercase());\n            },\n\
    \            _ => result.push(c),\n        }\n    }\n    if !found_letter {\n\
    \        result.chars().rev().collect()\n    } else {\n        result\n    }",
  "    if s.len() == 0 {\n        return String::from(\"\");\n    }\n    let mut ss\
    \ = String::new();\n    for x in s.chars() {\n        if x.is_ascii_lowercase()\
    \ {\n            ss.push(x.to_ascii_uppercase());\n        } else if x.is_ascii_uppercase()\
    \ {\n            ss.push(x.to_ascii_lowercase());\n        } else {\n        \
    \    ss.push(x);\n        }\n    }\n    if ss.chars().all(|x| !x.is_ascii_alphabetic())\
    \ {\n        ss.chars().rev().collect()\n    } else {\n        ss\n    }", " \
    \   s.chars().rev().map( |c| match c {\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        'a'...'z' => c.to_ascii_uppercase(),\n        _ => c\n    }).collect()",
  "    let mut v = Vec::new();\n    for c in s.chars() {\n        if let Some(c) =\
    \ c.to_lowercase().next() {\n            v.push(c);\n        }\n    }\n    if\
    \ v.is_empty() {\n        v.reverse();\n    }\n    v.into_iter().map(|c| c.to_ascii_uppercase()).collect()",
  "    if s.is_empty() {\n        return String::from(\"\");\n    }\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic() {\n\
    \            result.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.chars().all(|c|\
    \ c.is_alphabetic()) {\n        result = result.chars().rev().collect();\n   \
    \ }\n    result", "    if s.chars().any(|c| c.is_alphabetic()) {\n        s.chars().map(|c|\
    \ if c.is_alphabetic() { c.swap_case() } else { c }).collect()\n    } else {\n\
    \        s.chars().rev().collect()\n    }", "    // your code here\n    s", " \
    \   let mut chars: Vec<char> = s.chars().collect();\n    for (i, c) in chars.iter_mut().enumerate()\
    \ {\n        if *c >= 'a' && *c <= 'z' {\n            *c = c.to_ascii_uppercase();\n\
    \        } else if *c >= 'A' && *c <= 'Z' {\n            *c = c.to_ascii_lowercase();\n\
    \        }\n    }\n    chars.iter().collect()", "    if s.matches(char::is_alphabetic).count()\
    \ == 0 {\n        return s.chars().rev().collect::<String>();\n    }\n    s.chars().map(|c|\
    \ if c.is_alphabetic() {\n        if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        }\n \
    \   } else {\n        c\n    }).collect::<String>()", "    let mut is_letter =\
    \ false;\n    let mut res = String::new();\n    for ch in s.chars() {\n      \
    \  if ch.is_alphabetic() {\n            is_letter = true;\n            res.push(ch.to_uppercase().next().unwrap_or(ch));\n\
    \        } else {\n            res.push(ch);\n        }\n    }\n    if !is_letter\
    \ {\n        res.chars().rev().collect()\n    } else {\n        res\n    }", " \
    \   let mut result = String::new();\n    let chars = s.chars();\n    let mut is_letter\
    \ = false;\n    for c in chars {\n        if c.is_alphabetic() {\n           \
    \ is_letter = true;\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        let mut result = result.chars();\n        let mut r = String::new();\n\
    \        for c in result {\n            r.push(c.to_uppercase().next().unwrap());\n\
    \        }\n        return r;\n    } else {\n        let mut result = result.chars();\n\
    \        let mut r = String::new();\n        for c in result.rev() {\n       \
    \     r.push(c);\n        }\n        return r;\n    }", '    unimplemented!()',
  "    // Write your code here\n    String::new()", '    s.chars().map(|c| if c.is_ascii_alphabetic()
    { c.swap_case() } else { c }).collect()', "    let mut reversed = String::new();\n\
    \    for c in s.chars() {\n        match c {\n            'a'...'z' => reversed.push(c.to_ascii_uppercase()),\n\
    \            'A'...'Z' => reversed.push(c.to_ascii_lowercase()),\n           \
    \ _ => reversed.push(c),\n        }\n    }\n    reversed.chars().rev().collect()",
  "    let mut result = String::new();\n    for c in s.chars() {\n        match c\
    \ {\n            'a'..='z' => result.push((c as u8 - b'a' + b'A') as char),\n\
    \            'A'..='Z' => result.push((c as u8 - b'A' + b'a') as char),\n    \
    \        _ => result.push(c),\n        }\n    }\n    result", "    let mut s =\
    \ s.chars().collect::<Vec<char>>();\n    if s.iter().all(|c| !c.is_alphabetic())\
    \ {\n        s.reverse();\n    } else {\n        for i in 0..s.len() {\n     \
    \       s[i] = if s[i].is_lowercase() {\n                s[i].to_uppercase().next().unwrap()\n\
    \            } else {\n                s[i].to_lowercase().next().unwrap()\n \
    \           };\n        }\n    }\n    s.into_iter().collect()", "    let mut s\
    \ = s.chars().collect::<Vec<char>>();\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s[i].is_alphabetic() {\n            if s[i].is_uppercase() {\n\
    \                s[i] = s[i].to_lowercase().to_string().chars().next().unwrap();\n\
    \            } else {\n                s[i] = s[i].to_uppercase().to_string().chars().next().unwrap();\n\
    \            }\n        }\n        i += 1;\n    }\n    s.iter().collect::<String>()",
  "\tlet mut res = String::new();\n\tlet mut flag = false;\n\tfor c in s.chars() {\n\
    \t\tif c.is_alphabetic() {\n\t\t\tres.push(c.to_ascii_uppercase());\n\t\t\tflag\
    \ = true;\n\t\t} else {\n\t\t\tres.push(c);\n\t\t}\n\t}\n\tif flag {\n\t\tres.chars().rev().collect()\n\
    \t} else {\n\t\tres\n\t}", "    let mut s: Vec<char> = s.chars().collect();\n\
    \    let mut characters = false;\n    let mut count = 0;\n    for c in s.iter_mut()\
    \ {\n        if c.is_ascii_alphabetic() {\n            characters = true;\n  \
    \          *c = if c.is_lowercase() { c.to_ascii_uppercase() } else { c.to_ascii_lowercase()\
    \ };\n        }\n        count += 1;\n    }\n    if !characters {\n        s.reverse();\n\
    \    }\n    s.into_iter().collect()", '    s.chars().rev().collect()', "    let\
    \ mut st: Vec<char> = s.chars().collect();\n    let mut lower_letters: Vec<char>\
    \ = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n    let mut upper_letters:\
    \ Vec<char> = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars().collect();\n    let mut indexes\
    \ = Vec::new();\n    for (i, c) in st.iter().enumerate() {\n        if upper_letters.contains(c)\
    \ {\n            indexes.push(i);\n        }\n    }\n    for i in indexes {\n\
    \        let j = upper_letters.iter().position(|&r| r == st[i]).unwrap();\n  \
    \      st[i] = lower_letters[j];\n    }\n    for (i, c) in st.iter().enumerate()\
    \ {\n        if lower_letters.contains(c) {\n            indexes.push(i);\n  \
    \      }\n    }\n    for i in indexes {\n        let j = lower_letters.iter().position(|&r|\
    \ r == st[i]).unwrap();\n        st[i] = upper_letters[j];\n    }\n    if st.contains(&'a')\
    \ || st.contains(&'A') {\n        st.reverse();\n    }\n    st.into_iter().collect()",
  "    let mut res = String::new();\n    let mut chars = s.chars();\n    for c in\
    \ chars {\n        if c.is_alphabetic() {\n            res.push(c.to_uppercase().nth(0).unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    res", "   \
    \ let mut res = String::new();\n    for i in s.chars() {\n        if i.is_alphabetic()\
    \ {\n            res.push(i.to_uppercase().next().unwrap_or(i));\n        } else\
    \ {\n            res.push(i);\n        }\n    }\n    if res.chars().all(|i| !i.is_alphabetic())\
    \ {\n        res.chars().rev().collect()\n    } else {\n        res\n    }", " \
    \   s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n            c.to_ascii_uppercase()\n\
    \        } else {\n            c\n        }\n    }).collect()", "    if s.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        return s.chars().rev().collect();\n    }\n  \
    \  s.chars().map(|c| if c.is_alphabetic() {\n        match c {\n            'a'..='z'\
    \ => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => unreachable!(),\n        }\n    } else {\n        c\n    }).collect()",
  "    let mut result = String::new();\n    let mut letters = false;\n    for c in\
    \ s.chars() {\n        let lc = c.to_lowercase().to_string();\n        if c !=\
    \ lc {\n            letters = true;\n        }\n        result.push(match c {\n\
    \            'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        });\n    }\n    if !letters {\n        result =\
    \ result.chars().rev().collect();\n    }\n    result", "    // your code here\n\
    \    \"\".to_string()", "\tlet mut res = String::new();\n\tfor c in s.chars()\
    \ {\n\t\tmatch c {\n\t\t\t'a'...'z' => res.push((c as u8 ^ 1) as char),\n\t\t\t\
    'A'...'Z' => res.push((c as u8 ^ 32) as char),\n\t\t\t_ => res.push(c),\n\t\t\
    }\n\t}\n\tif res.chars().all(|c| c < 'a' || c > 'z') {\n\t\tlet mut rev = String::new();\n\
    \t\trev.push_str(&res.chars().rev().collect::<String>());\n\t\trev\n\t} else {\n\
    \t\tres\n\t}", "    let mut result = String::new();\n    for i in s.chars() {\n\
    \        match i {\n            'a'..='z' => result.push(i.to_ascii_uppercase()),\n\
    \            'A'..='Z' => result.push(i.to_ascii_lowercase()),\n            _\
    \ => result.push(i),\n        }\n    }\n    result.chars().rev().collect()", " \
    \   if s.is_empty() {\n        return String::from(\"\");\n    }\n    let mut\
    \ res = String::from(\"\");\n    for c in s.chars() {\n        if c.is_lowercase()\
    \ {\n            res.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        } else if c.is_uppercase() {\n            res.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    res", "   \
    \ if s.find(char::is_alphabetic).is_none() {\n        return s.chars().rev().collect();\n\
    \    }\n    s.chars().map(|c| if c.is_ascii_alphabetic() { c.swap_case() } else\
    \ { c }).collect()", "    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n \
    \           has_letter = true;\n            if c.is_lowercase() {\n          \
    \      res.push(c.to_ascii_uppercase());\n            } else {\n             \
    \   res.push(c.to_ascii_lowercase());\n            }\n        } else {\n     \
    \       res.push(c);\n        }\n    }\n    if !has_letter {\n        return res.chars().rev().collect();\n\
    \    }\n    res", "    s.chars().rev().map(|c| {\n        if c.is_alphabetic()\
    \ {\n            c.to_ascii_uppercase()\n        } else {\n            c\n   \
    \     }\n    }).collect()", "    let mut result = String::from(\"\");\n    let\
    \ mut a = false;\n    for i in s.chars() {\n        if i.is_ascii_lowercase()\
    \ || i.is_ascii_uppercase() {\n            a = true;\n            result.push(i.to_ascii_uppercase());\n\
    \        } else {\n            result.push(i);\n        }\n    }\n    if a {\n\
    \        result\n    } else {\n        result.chars().rev().collect()\n    }",
  "    let mut flag = false;\n    let v: Vec<char> = s.chars().collect();\n    let\
    \ mut new_str = String::new();\n    for i in v {\n        if i.is_alphabetic()\
    \ {\n            flag = true;\n            if i.is_lowercase() {\n           \
    \     new_str.push(i.to_uppercase().next().unwrap());\n            } else {\n\
    \                new_str.push(i.to_lowercase().next().unwrap());\n           \
    \ }\n        } else {\n            new_str.push(i);\n        }\n    }\n    if\
    \ flag {\n        new_str\n    } else {\n        new_str.chars().rev().collect()\n\
    \    }"]
stop_tokens:
- "\n}"
