name: HumanEval_161_solve
language: rs
prompt: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the\
  \ string contains no letters, reverse the string.\n/// The function should return\
  \ the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n///\
  \ String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
  AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
  \ String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
  AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
  )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
  AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
  ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
  ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
  \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
  \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"
completions: ["    let mut s = s.as_bytes().to_vec();\n    for i in 0..s.len() {\n\
    \        if s[i] > 64 && s[i] < 91 {\n            s[i] += 32;\n        } else\
    \ if s[i] > 96 && s[i] < 123 {\n            s[i] -= 32;\n        }\n    }\n  \
    \  String::from_utf8(s).unwrap()", "    // for c in s.chars() {\n    //     if\
    \ c.is_ascii_uppercase() {\n    //         //\n    //     }\n    // }\n    unimplemented!()",
  "    let mut reversed_string = String::new();\n    let mut is_letter_exists = false;\n\
    \    for ch in s.chars() {\n        if ch.is_alphabetic() {\n            is_letter_exists\
    \ = true;\n            if ch.is_lowercase() {\n                reversed_string.push(ch.to_uppercase().next().unwrap());\n\
    \            } else {\n                reversed_string.push(ch.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            reversed_string.push(ch);\n    \
    \    }\n    }\n    if is_letter_exists {\n        reversed_string\n    } else\
    \ {\n        reversed_string.chars().rev().collect()\n    }", "\tlet mut v = s.chars().collect::<Vec<char>>();\n\
    \tv.reverse();\n\tlet s: String = v.into_iter().map(|x| {\n\t\tmatch x {\n\t\t\
    \t'a'..='z' => x.to_ascii_uppercase(),\n\t\t\t'A'..='Z' => x.to_ascii_lowercase(),\n\
    \t\t\t_ => x,\n\t\t}\n\t}).collect();\n\tif s.chars().any(|x| x.is_alphabetic())\
    \ {\n\t\ts\n\t} else {\n\t\tlet mut v = s.chars().collect::<Vec<char>>();\n\t\t\
    v.reverse();\n\t\tv.into_iter().collect()\n\t}", "    s.chars().rev().map(|c|\
    \ match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n        'A'..='Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", "    let mut s:\
    \ Vec<char> = s.chars().collect();\n    let mut contains_letter = false;\n   \
    \ let mut counter = 0;\n    while counter < s.len() {\n        if s[counter].is_alphabetic()\
    \ {\n            contains_letter = true;\n            if s[counter].is_lowercase()\
    \ {\n                s[counter] = s[counter].to_uppercase().next().unwrap();\n\
    \            } else {\n                s[counter] = s[counter].to_lowercase().next().unwrap();\n\
    \            }\n        }\n        counter += 1;\n    }\n    if !contains_letter\
    \ {\n        s.reverse();\n    }\n    s.into_iter().collect()", "    let mut res\
    \ = String::new();\n    let mut found = false;\n    for c in s.chars() {\n   \
    \     if c.is_alphabetic() {\n            found = true;\n            if c.is_lowercase()\
    \ {\n                res.push(c.to_uppercase().to_string().pop().unwrap());\n\
    \            } else {\n                res.push(c.to_lowercase().to_string().pop().unwrap());\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    if !found {\n        res.chars().rev().collect()\n    } else {\n        res\n\
    \    }", "    s.chars().rev().map(|c| \n        if c.is_alphabetic() {\n     \
    \       if c.is_lowercase() { c.to_uppercase().to_string() }\n            else\
    \ { c.to_lowercase().to_string() }\n        } else { c.to_string() }\n    ).collect()",
  "    let mut chars = s.chars();\n    let mut s = String::new();\n    let mut found\
    \ = false;\n    while let Some(c) = chars.next() {\n        if c.is_ascii_alphabetic()\
    \ {\n            found = true;\n            s.push(c.swap_case());\n        }\
    \ else {\n            s.push(c);\n        }\n    }\n    if !found {\n        s.chars().rev().collect()\n\
    \    } else {\n        s\n    }", "    let mut v: Vec<char> = s.chars().collect();\n\
    \    let mut b: bool = false;\n    for i in 0..v.len() {\n        if v[i].is_alphabetic()\
    \ {\n            b = true;\n            v[i] = v[i].to_ascii_lowercase();\n  \
    \      }\n    }\n    if b {\n        v.reverse();\n        for i in 0..v.len()\
    \ {\n            if v[i].is_alphabetic() {\n                v[i] = v[i].to_ascii_uppercase();\n\
    \            }\n        }\n    } else {\n        v.reverse();\n    }\n    return\
    \ v.into_iter().collect();", '    s.chars().rev().collect()', '    unimplemented!()',
  "\tString::from(\"Not implemented yet.\")", "    let mut buffer = String::new();\n\
    \    let mut has_letter = false;\n    for ch in s.chars() {\n        if ch.is_alphabetic()\
    \ {\n            buffer.push(ch.swap_case());\n            has_letter = true;\n\
    \        } else {\n            buffer.push(ch);\n        }\n    }\n    if !has_letter\
    \ {\n        buffer.chars().rev().collect()\n    } else {\n        buffer\n  \
    \  }", "    let mut res = s.chars().rev().collect::<String>();\n    for (i, c)\
    \ in res.chars().enumerate() {\n        if c.is_alphabetic() {\n            res.replace_range(i..i+1,\
    \ &c.to_string().to_uppercase());\n        }\n    }\n    res", '    unimplemented!();',
  "    let mut result = String::new();\n    for c in s.chars() {\n        match c\
    \ {\n            'A'...'Z' => result.push(c.to_ascii_lowercase()),\n         \
    \   'a'...'z' => result.push(c.to_ascii_uppercase()),\n            _ => result.push(c),\n\
    \        }\n    }\n    if result.chars().any(|c| c.is_alphabetic()) {\n      \
    \  result\n    } else {\n        result.chars().rev().collect()\n    }", "   \
    \ let mut letters = Vec::new();\n    for ch in s.chars() {\n        if ch.is_ascii_alphabetic()\
    \ {\n            letters.push(ch.to_ascii_lowercase());\n        }\n    }\n  \
    \  if letters.is_empty() {\n        return s.chars().rev().collect();\n    }\n\
    \n    let mut result = String::new();\n    for ch in s.chars() {\n        if ch.is_ascii_alphabetic()\
    \ {\n            result.push(letters.pop().unwrap().to_ascii_uppercase());\n \
    \       } else {\n            result.push(ch);\n        }\n    }\n    result",
  "    let mut new_string = String::new();\n    for ch in s.chars() {\n        match\
    \ ch {\n            'a' => new_string.push('A'),\n            'b' => new_string.push('B'),\n\
    \            'c' => new_string.push('C'),\n            'd' => new_string.push('D'),\n\
    \            'e' => new_string.push('E'),\n            'f' => new_string.push('F'),\n\
    \            'g' => new_string.push('G'),\n            'h' => new_string.push('H'),\n\
    \            'i' => new_string.push('I'),\n            'j' => new_string.push('J'),\n\
    \            'k' => new_string.push('K'),\n            'l' => new_string.push('L'),\n\
    \            'm' => new_string.push('M'),\n            'n' => new_string.push('N'),\n\
    \            'o' => new_string.push('O'),\n            'p' => new_string.push('P'),\n\
    \            'q' => new_string.push('Q'),\n            'r' => new_string.push('R'),\n\
    \            's' => new_string.push('S'),\n            't' => new_string.push('T'),\n\
    \            'u' => new_string.push('U'),\n            'v' => new_string.push('V'),\n\
    \            'w' => new_string.push('W'),\n            'x' => new_string.push('X'),\n\
    \            'y' => new_string.push('Y'),\n            'z' => new_string.push('Z'),\n\
    \            'A' => new_string.push('a'),\n            'B' => new_string.push('b'),\n\
    \            'C' => new_string.push('c'),\n            'D' => new_string.push('d'),\n\
    \            'E' => new_string.push('e'),\n            'F' => new_string.push('f'),\n\
    \            'G' => new_string.push('g'),\n            'H' => new_string.push('h'),\n\
    \            'I' => new_", "    s.chars().rev().map(|c| {\n        match c {\n\
    \            'a' => 'A',\n            'b' => 'B',\n            'c' => 'C',\n \
    \           'd' => 'D',\n            'e' => 'E',\n            'f' => 'F',\n  \
    \          'g' => 'G',\n            'h' => 'H',\n            'i' => 'I',\n   \
    \         'j' => 'J',\n            'k' => 'K',\n            'l' => 'L',\n    \
    \        'm' => 'M',\n            'n' => 'N',\n            'o' => 'O',\n     \
    \       'p' => 'P',\n            'q' => 'Q',\n            'r' => 'R',\n      \
    \      's' => 'S',\n            't' => 'T',\n            'u' => 'U',\n       \
    \     'v' => 'V',\n            'w' => 'W',\n            'x' => 'X',\n        \
    \    'y' => 'Y',\n            'z' => 'Z',\n            'A' => 'a',\n         \
    \   'B' => 'b',\n            'C' => 'c',\n            'D' => 'd',\n          \
    \  'E' => 'e',\n            'F' => 'f',\n            'G' => 'g',\n           \
    \ 'H' => 'h',\n            'I' => 'i',\n            'J' => 'j',\n            'K'\
    \ => 'k',\n            'L' => 'l',\n            'M' => 'm',\n            'N' =>\
    \ 'n',\n            'O' => 'o',\n            'P' => 'p',\n            'Q' => 'q',\n\
    \            'R' => 'r',\n            'S' => 's',\n            'T' => 't',\n \
    \           'U' => 'u',\n            'V' => 'v',\n            'W' => 'w',\n  \
    \          'X' => 'x',\n            'Y' => 'y',\n            'Z' => 'z',\n   \
    \         _ => c,\n        }\n    }).collect()"]
stop_tokens:
- "\n}"
