language: rs
name: HumanEval_37_sort_even
results:
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted_list = Vec::new();\n    sorted_list.push(l[0]);\n    let mut\
    \ even_list = Vec::new();\n    for i in 1..l.len() {\n        if i % 2 == 0 {\n\
    \            even_list.push(l[i]);\n        } else {\n            sorted_list.push(l[i]);\n\
    \        }\n    }\n    even_list.sort();\n    for i in 0..even_list.len() {\n\
    \        sorted_list.insert(2 * i + 1, even_list[i]);\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp1ocv1ry1.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = Vec::new();\n    let mut odds = Vec::new();\n    let mut evens\
    \ = Vec::new();\n    for (i, element) in l.iter().enumerate() {\n        if i\
    \ % 2 == 0 {\n            odds.push(*element);\n        } else {\n           \
    \ evens.push(*element);\n        }\n    }\n    evens.sort();\n    new_vec.append(&mut\
    \ odds);\n    new_vec.append(&mut evens);\n    new_vec\n}\n\nfn main() {\n   \
    \ let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpon863wpl.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // TODO: Implement this function\n    let mut v = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            v.push(l[i]);\n        }\
    \ else {\n            v.push(l[i - 1]);\n            v.push(l[i]);\n        }\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpggjpm0y_.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut odds: Vec<isize> = vec![];\n    let mut evens: Vec<isize> = vec![];\n\
    \    for (i, v) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   odds.push(*v);\n        } else {\n            evens.push(*v);\n        }\n\
    \    }\n    evens.sort();\n    for (i, v) in evens.iter().enumerate() {\n    \
    \    odds.insert(i * 2 + 1, *v);\n    }\n    odds\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp2n526_sk.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted_evens = Vec::new();\n    let mut evens_indicies = vec![];\n \
    \   let mut odds_indicies = vec![];\n    let mut sorted_l = Vec::new();\n    for\
    \ (i, item) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds_indicies.push(i);\n\
    \        } else {\n            evens_indicies.push(i);\n            sorted_evens.push(*item);\n\
    \        }\n    }\n    sorted_evens.sort();\n    for i in 0..odds_indicies.len()\
    \ {\n        sorted_l.push(l[odds_indicies[i]]);\n        sorted_l.push(sorted_evens[i]);\n\
    \    }\n    sorted_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpjqixxa1s.rs:24:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ if l.len() < 2 {\n        return l;\n    }\n\n    let mut evens = l.iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 0).map(|(_, &x)| x).collect::<Vec<isize>>();\n    evens.sort();\n\
    \n    l.iter().enumerate().map(|(i, &x)| if i % 2 == 0 { evens.remove(0) } else\
    \ { x }).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_v = Vec::new();\n    let mut vec_slice = &l[..];\n    while !vec_slice.is_empty()\
    \ {\n        if vec_slice.len() > 1 {\n            let mut l = vec_slice[0..2].to_vec();\n\
    \            l.sort();\n            new_v.push(l[0]);\n            new_v.push(l[1]);\n\
    \            vec_slice = &vec_slice[2..];\n        } else {\n            new_v.push(vec_slice[0]);\n\
    \            vec_slice = &vec_slice[1..];\n        }\n    }\n    new_v\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmphl4vs7gs.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n\tlet\
    \ mut res: Vec<isize> = Vec::new();\n\tlet mut even_indicies: Vec<isize> = Vec::new();\n\
    \tlet mut odd_indicies: Vec<isize> = Vec::new();\n\tfor (i, n) in l.iter().enumerate()\
    \ {\n\t\tif i % 2 == 0 {\n\t\t\teven_indicies.push(*n);\n\t\t} else {\n\t\t\t\
    odd_indicies.push(*n);\n\t\t}\n\t}\n\teven_indicies.sort();\n\tfor i in 0..even_indicies.len()\
    \ {\n\t\tres.push(even_indicies[i]);\n\t\tres.push(odd_indicies[i]);\n\t}\n\t\
    res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmp0fxxa1ra.rs:22:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut clone = l.clone();\n    for i in 0..l.len() {\n        if i % 2 == 0\
    \ {\n            clone[i] = l[i + 1];\n        }\n    }\n    clone.sort();\n \
    \   let mut j = 0;\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n     \
    \       clone[i] = l[j];\n            j += 2;\n        }\n    }\n    clone\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpt8lh1hdz.rs:12:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // get the even indicies\n    let even_indicies = l.iter().enumerate().filter(|x|\
    \ x.0 % 2 == 0).map(|x| x.1).collect::<Vec<&isize>>();\n    // get the odd indicies\n\
    \    let odd_indicies = l.iter().enumerate().filter(|x| x.0 % 2 == 1).map(|x|\
    \ x.1).collect::<Vec<&isize>>();\n    // sort the even indicies\n    let mut even_indicies\
    \ = even_indicies.clone();\n    even_indicies.sort();\n    // return a new vector\n\
    \    let mut new_vec = vec![];\n    for i in 0..even_indicies.len() {\n      \
    \  new_vec.push(*even_indicies[i]);\n        new_vec.push(*odd_indicies[i]);\n\
    \    }\n    new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpmld8etbc.rs:20:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // vec![5, 6, 3, 4].iter().enumerate().filter(|(i,_)| i % 2 == 0).map(|(i,_)|\
    \ i).collect::<Vec<_>>()\n    // (0..l.len()).filter(|&i| i % 2 == 0).collect::<Vec<_>>()\n\
    \    let mut v = l.clone();\n    // let mut v = vec![5, 6, 3, 4];\n    for i in\
    \ 0..v.len() {\n        if i % 2 == 0 {\n            v[i] = l[i + 1];\n      \
    \  }\n    }\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpeheny21j.rs:15:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut odd_indices = Vec::new();\n    let mut even_indices\
    \ = Vec::new();\n    for (index, value) in v.iter().enumerate() {\n        if\
    \ index % 2 == 0 {\n            even_indices.push(value);\n        } else {\n\
    \            odd_indices.push(value);\n        }\n    }\n    even_indices.sort();\n\
    \    for (index, value) in even_indices.iter().enumerate() {\n        v[index\
    \ * 2] = *value;\n    }\n    return v;\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphxbnzxb5.rs:21:24\n   |\n\
    21 |         v[index * 2] = *value;\n   |         ------------   ^^^^^^ expected\
    \ `isize`, found `&isize`\n   |         |\n   |         expected due to the type\
    \ of this binding\n   |\nhelp: consider dereferencing the borrow\n   |\n21 | \
    \        v[index * 2] = **value;\n   |                        +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // TODO: Implement this function.\n\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 3]`', /tmp/tmp7k6orqwk.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n\tlet\
    \ mut odd_list: Vec<isize> = vec![];\n\tlet mut even_list: Vec<isize> = vec![];\n\
    \tfor (index, element) in l.iter().enumerate() {\n\t\tif index % 2 == 0 {\n\t\t\
    \todd_list.push(*element);\n\t\t} else {\n\t\t\teven_list.push(*element);\n\t\t\
    }\n\t}\n\teven_list.sort();\n\tlet mut list: Vec<isize> = vec![];\n\tfor (index,\
    \ element) in l.iter().enumerate() {\n\t\tif index % 2 == 0 {\n\t\t\tlist.push(odd_list[index\
    \ / 2]);\n\t\t} else {\n\t\t\tlist.push(even_list[index / 2]);\n\t\t}\n\t}\n\t\
    list\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp6ujfuxrw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut res = l.clone();\n    // sort\n    let mut even_indexes = Vec::new();\n\
    \    for (i, v) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_indexes.push(v);\n        }\n    }\n    even_indexes.sort();\n    //\
    \ fill res\n    for (i, v) in even_indexes.iter().enumerate() {\n        res[i\
    \ * 2] = *v;\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2c9pnkxi.rs:20:22\n   |\n\
    20 |         res[i * 2] = *v;\n   |         ----------   ^^ expected `isize`,\
    \ found `&isize`\n   |         |\n   |         expected due to the type of this\
    \ binding\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |         res[i\
    \ * 2] = **v;\n   |                      +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    for i in 0..v.len() {\n        if i % 2 == 0 {\n\
    \            v[i] = l[i];\n        } else {\n            v[i] = l[i].clone();\n\
    \            let mut small_v = v[i].clone();\n            let mut small_i = i;\n\
    \            for j in i..v.len() {\n                if v[j] < small_v {\n    \
    \                small_v = v[j].clone();\n                    small_i = j;\n \
    \               }\n            }\n            let temp = v[i].clone();\n     \
    \       v[i] = small_v;\n            v[small_i] = temp;\n        }\n    }\n  \
    \  v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -3, -3, 0, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3,\
    \ 3, 5, 0, 9, 1, 123]`', /tmp/tmpgvidfi7t.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    for i in 0..v.len() {\n        if i % 2 == 0 {\n\
    \            for j in 0..v.len() {\n                if j % 2 == 0 && v[j] > v[i]\
    \ {\n                    let temp = v[i];\n                    v[i] = v[j];\n\
    \                    v[j] = temp;\n                }\n            }\n        }\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut odd_indicies: Vec<isize> = Vec::new();\n    let mut even_indicies: Vec<isize>\
    \ = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n        \
    \    even_indicies.push(l[i]);\n        } else {\n            odd_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    let mut result: Vec<isize> =\
    \ Vec::new();\n    let mut odd_index: usize = 0;\n    let mut even_index: usize\
    \ = 0;\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result.push(even_indicies[even_index]);\n\
    \            even_index += 1;\n        } else {\n            result.push(odd_indicies[odd_index]);\n\
    \            odd_index += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ if l.len() == 0 {\n        return l;\n    }\n    let mut evens = vec![];\n \
    \   let mut odds = vec![];\n    for (index, val) in l.iter().enumerate() {\n \
    \       if index % 2 == 0 {\n            odds.push(*val);\n        } else {\n\
    \            evens.push(*val);\n        }\n    }\n    evens.sort();\n    let mut\
    \ res = vec![];\n    for (index, val) in odds.iter().enumerate() {\n        res.push(*val);\n\
    \        if index < evens.len() {\n            res.push(evens[index]);\n     \
    \   }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvha_j7tm.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut l_copy = l.clone();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            l_copy[i] = l[i / 2];\n        }\n    }\n\
    \    l_copy.sort();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n    \
    \        l[i / 2] = l_copy[i];\n        }\n    }\n    l\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, 0, 2, 3, 3, 5, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3, 5,\
    \ 0, 9, 1, 123]`', /tmp/tmpxj_qhwrs.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let (even, odd) = partition_even_odd(l);\n    even.sort();\n\
    \    let mut new_l = Vec::new();\n    let mut e = even.iter();\n    let mut o\
    \ = odd.iter();\n    loop {\n        match (e.next(), o.next()) {\n          \
    \  (Some(x), Some(y)) => {\n                new_l.push(*x);\n                new_l.push(*y);\n\
    \            }\n            (Some(x), None) => new_l.push(*x),\n            (None,\
    \ Some(y)) => new_l.push(*y),\n            (None, None) => break,\n        }\n\
    \    }\n    new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `partition_even_odd` in this scope\n\
    \  --> /tmp/tmppriga3n2.rs:10:23\n   |\n10 |     let (even, odd) = partition_even_odd(l);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut a = l.clone();\n    let mut b = Vec::new();\n    for i in 0..a.len()\
    \ {\n        if i % 2 == 0 {\n            b.push(a[i]);\n        }\n    }\n  \
    \  b.sort();\n    for i in 0..a.len() {\n        if i % 2 == 0 {\n           \
    \ a[i] = b[i/2];\n        }\n    }\n    a\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let even_indicies: Vec<usize> = (0..l.len()).filter(|i|\
    \ i % 2 == 0).collect();\n    let mut even_indicies_sorted = even_indicies.clone();\n\
    \    even_indicies_sorted.sort();\n    for (i, j) in even_indicies.iter().zip(even_indicies_sorted.iter())\
    \ {\n        l.swap(*i, *j);\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvq379klk.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l2 = l.clone();\n    for i in 1..l.len() {\n        if i % 2 == 0 {\n\
    \            let temp = l2[i];\n            l2[i] = l[i-1];\n            l2[i-1]\
    \ = temp;\n        }\n    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpmo3bgyzz.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut m = l.clone();\n    let len = m.len();\n    if len > 1 {\n        let\
    \ (left, right) = m.split_at_mut(len / 2);\n        let sorted_left = sort_even(left.to_vec());\n\
    \        let sorted_right = sort_even(right.to_vec());\n        let mut li = 0;\n\
    \        let mut ri = 0;\n        for i in 0..len {\n            if li < len /\
    \ 2 && (ri == len / 2 || sorted_left[li] < sorted_right[ri]) {\n             \
    \   m[i] = sorted_left[li];\n                li += 1;\n            } else {\n\
    \                m[i] = sorted_right[ri];\n                ri += 1;\n        \
    \    }\n        }\n    }\n    m\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 3, 3, 5, 2, 9, 123, 1]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpjnvnlwos.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l1 = Vec::new();\n    let mut l2 = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            l1.push(l[i]);\n        } else {\n \
    \           l2.push(l[i]);\n        }\n    }\n    l1.sort();\n    for i in 0..l2.len()\
    \ {\n        l1.insert(i * 2 + 1, l2[i]);\n    }\n    l1\n}\n\nfn main() {\n \
    \   let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut out: Vec<isize> = Vec::new();\n    let mut even: Vec<isize> = Vec::new();\n\
    \    let mut odd: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n      \
    \  if i % 2 == 0 {\n            even.push(l[i]);\n        } else {\n         \
    \   odd.push(l[i]);\n        }\n    }\n    even.sort();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            out.push(even[i / 2]);\n        } else\
    \ {\n            out.push(odd[i / 2]);\n        }\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut vec_to_sort = Vec::new();\n    let mut sorted_vec = Vec::new();\n  \
    \  let mut sorted_v = Vec::new();\n    for (i, n) in l.iter().enumerate() {\n\
    \        if i % 2 == 0 {\n            vec_to_sort.push(*n);\n        } else {\n\
    \            sorted_vec.push(*n);\n        }\n    }\n    vec_to_sort.sort();\n\
    \    for (i, n) in sorted_vec.iter().enumerate() {\n        sorted_v.push(vec_to_sort[i]);\n\
    \        sorted_v.push(*n);\n    }\n    sorted_v\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpr7g90qmf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // TODO: implement sort_even\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpdyogjhzl.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut arr = l.clone();\n    let mut even_indices: Vec<isize> = Vec::new();\n\
    \    let mut odd_indices: Vec<isize> = Vec::new();\n    let mut v: Vec<isize>\
    \ = Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n        if i % 2\
    \ == 0 {\n            even_indices.push(*n);\n        } else {\n            odd_indices.push(*n);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..even_indices.len()\
    \ {\n        v.push(even_indices[i]);\n        v.push(odd_indices[i]);\n    }\n\
    \    return v;\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmptsu_purs.rs:23:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // The list is empty, or has a single element, so it's already sorted\n    if\
    \ l.len() < 2 {\n        return l;\n    }\n\n    // Use pattern matching to split\
    \ the list into a head and a tail, the latter being\n    // all the elements after\
    \ the first one.\n    let mut head = l[0];\n    let mut tail = l[1..].to_vec();\n\
    \n    // If the first element is even, sort the tail, then put the head at the\
    \ right place\n    // inside the tail.\n    if head % 2 == 0 {\n        tail =\
    \ sort_even(tail);\n        head = insert_sorted(head, tail);\n    }\n    // Otherwise,\
    \ just sort the tail.\n    else {\n        tail = sort_even(tail);\n    }\n\n\
    \    // In the end, just return the head and the tail.\n    vec![head].append(&mut\
    \ tail)\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `insert_sorted` in this scope\n  -->\
    \ /tmp/tmp6hia7mjy.rs:23:16\n   |\n23 |         head = insert_sorted(head, tail);\n\
    \   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6hia7mjy.rs:31:5\n   |\n8  | fn sort_even(l: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n31 |     vec![head].append(&mut tail)\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method\
    \ `append` modifies its receiver in-place\n  --> /tmp/tmp6hia7mjy.rs:31:16\n \
    \  |\n31 |     vec![head].append(&mut tail)\n   |     ---------- ^^^^^^ this call\
    \ modifies its receiver in-place\n   |     |\n   |     you probably want to use\
    \ this value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `append`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted_list = Vec::new();\n    let mut i = 0;\n    while i < l.len()\
    \ {\n        if i % 2 == 0 {\n            sorted_list.push(l[i]);\n        } else\
    \ {\n            let mut temp_list = Vec::new();\n            for j in i - 1..i\
    \ + 1 {\n                temp_list.push(l[j]);\n            }\n            sorted_list.append(&mut\
    \ temp_list.clone());\n            sorted_list.sort();\n        }\n        i +=\
    \ 1;\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpgsft4gfb.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = l.clone();\n    let even_vec: Vec<_> = l.into_iter().enumerate().filter(|x|\
    \ x.0 % 2 == 0).map(|x| x.1).collect();\n    let mut even_vec = even_vec.clone();\n\
    \    even_vec.sort();\n    let mut even_it = even_vec.into_iter();\n    for i\
    \ in 0..new_vec.len() {\n        if i % 2 == 0 {\n            new_vec[i] = even_it.next().unwrap();\n\
    \        }\n    }\n    new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Given a vector, create another vector that only contains even indicies of\
    \ the first vector\n    let mut evens = l.iter().enumerate().filter(|x| x.0 %\
    \ 2 == 0).map(|x| x.1).collect::<Vec<&isize>>();\n    // Sort the vector\n   \
    \ evens.sort();\n    // Convert back to a vector of isize\n    let mut evens =\
    \ evens.iter().map(|x| *x).collect::<Vec<isize>>();\n    // Combine this sorted\
    \ vector of evens back with the original vector l\n    let mut combined = vec![];\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            combined.push(evens.remove(0));\n\
    \        } else {\n            combined.push(l[i]);\n        }\n    }\n    //\
    \ Return the combined vector\n    combined\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpg78kin4a.rs:14:46\n     |\n\
    14   |     let mut evens = evens.iter().map(|x| *x).collect::<Vec<isize>>();\n\
    \     |                                              ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result: Vec<isize> = Vec::new();\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut odds: Vec<isize> = Vec::new();\n    let mut index = 0;\n    for i\
    \ in l {\n        if index % 2 == 0 {\n            odds.push(i);\n        } else\
    \ {\n            evens.push(i);\n        }\n        index += 1;\n    }\n    evens.sort();\n\
    \    index = 0;\n    while index < l.len() {\n        if index % 2 == 0 {\n  \
    \          result.push(odds[index / 2]);\n        } else {\n            result.push(evens[index\
    \ / 2]);\n        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpei3u73dh.rs:23:19\n\
    \    |\n8   | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    |             \
    \ - move occurs because `l` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n13  |     for i in l {\n    |              - `l` moved due\
    \ to this implicit call to `.into_iter()`\n...\n23  |     while index < l.len()\
    \ {\n    |                   ^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `l`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |     for i in &l {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l: Vec<isize> = l;\n    let mut even_indexes = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indexes.push(i);\n\
    \        }\n    }\n    for i in 0..even_indexes.len() {\n        let mut min_index\
    \ = i;\n        for j in i + 1..even_indexes.len() {\n            if l[even_indexes[j]]\
    \ < l[even_indexes[min_index]] {\n                min_index = j;\n           \
    \ }\n        }\n        l.swap(even_indexes[i], even_indexes[min_index]);\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut evens = l.iter().enumerate().filter(|&(i,_)| i % 2 == 0).map(|(_,&v)|\
    \ v).collect::<Vec<isize>>();\n    evens.sort();\n    let mut result = Vec::new();\n\
    \    for (i, v) in l.iter().enumerate() {\n        result.push(if i % 2 == 0 {\n\
    \            evens.remove(0)\n        } else {\n            *v\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut vec = Vec::new();\n    let mut vec_sorted = Vec::new();\n    let mut\
    \ i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n            vec.push(l[i]);\n\
    \        } else {\n            vec_sorted.push(l[i]);\n        }\n        i +=\
    \ 1;\n    }\n    let mut vec_sorted = vec_sorted.iter().cloned().collect::<Vec<isize>>();\n\
    \    vec_sorted.sort();\n    let mut vec_sorted_iter = vec_sorted.iter();\n  \
    \  let mut vec_iter = vec.iter();\n    let mut vec_new = Vec::new();\n    while\
    \ vec_iter.len() > 0 || vec_sorted_iter.len() > 0 {\n        if vec_iter.len()\
    \ > 0 {\n            vec_new.push(*vec_iter.next().unwrap());\n        }\n   \
    \     if vec_sorted_iter.len() > 0 {\n            vec_new.push(*vec_sorted_iter.next().unwrap());\n\
    \        }\n    }\n    vec_new\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpbkx4c_jh.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Declare a variable to store our result\n    let mut result = Vec::new();\n\
    \    // Get an iterator over the even indices\n    let mut even_indices = (0..l.len()).step_by(2);\n\
    \    // Iterate over the even indices, and sort the values\n    for i in even_indices\
    \ {\n        // Take ownership of the reference to the even index\n        let\
    \ mut even_values = l[i..i + 2].to_vec();\n        // Sort the even values\n \
    \       even_values.sort();\n        // Push them back to the result\n       \
    \ result.push(even_values[0]);\n        result.push(even_values[1]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''range end index 4 out of range for slice
    of length 3'', library/core/src/slice/index.rs:73:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ l.iter().enumerate().fold(Vec::new(), |mut acc, (i, x)| {\n        if i % 2\
    \ == 0 {\n            acc.push(*x);\n        } else {\n            let mut v =\
    \ acc.pop().unwrap();\n            v.push(*x);\n            v.sort();\n      \
    \      acc.push(v);\n        }\n        acc\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpgrr5419v.rs:14:15\n   |\n14 |             v.push(*x);\n\
    \   |               ^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `sort` found for type `isize` in the current scope\n  --> /tmp/tmpgrr5419v.rs:15:15\n\
    \   |\n15 |             v.sort();\n   |               ^^^^ method not found in\
    \ `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut copy = l.clone();\n    let odd = l.iter().enumerate().filter(|&(i, _)|\
    \ i % 2 == 0).map(|(_, &x)| x).collect::<Vec<_>>();\n    let even = l.iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 1).map(|(_, &x)| x).collect::<Vec<_>>();\n    let mut sorted_even\
    \ = even.clone();\n    sorted_even.sort();\n    for (i, x) in odd.iter().enumerate()\
    \ {\n        copy[i * 2] = *x;\n    }\n    for (i, x) in sorted_even.iter().enumerate()\
    \ {\n        copy[i * 2 + 1] = *x;\n    }\n    copy\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpogq_5ok4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // The `as_mut_slice` function returns a mutable slice object,\n    // named\
    \ `l_slice`, from the vector `l` that we pass to it.\n    // This mutable slice\
    \ object is like a reference to a slice\n    // containing the elements of `l`.\
    \ That is, it is just a reference\n    // to the memory where `l` stores its elements.\n\
    \    //\n    // We need to use `as_mut_slice` because the `sort` function\n  \
    \  // requires a mutable slice and not a vector.\n    let mut l_slice = l.as_mut_slice();\n\
    \n    // We slice the vector at the even indicies, and sort the resulting\n  \
    \  // slice, leaving the odd indicies unsorted.\n    sort_slice(l_slice.as_mut_slice());\n\
    \n    // This is a bit hacky. It is not possible to convert a slice to a vector.\n\
    \    // Slices and vectors are different concepts. So, we convert a vector to\
    \ a slice,\n    // modify the slice and then convert the slice back to a vector.\n\
    \    //\n    // Note that the type of the variable `l_slice` is `&mut [isize]`.\n\
    \    // That is, a mutable slice of isize. The expression `l_slice.to_vec()`\n\
    \    // converts the variable `l_slice` to a vector.\n    //\n    // The type\
    \ of the variable `l_slice` is `&mut [isize]`\n    // so `l_slice.to_vec()` has\
    \ the type `Vec<isize>`.\n    // Since the type of `l_slice` is `&mut [isize]`,\n\
    \    // when we call `to_vec` on `l_slice`, the elements of the\n    // slice\
    \ are moved (copied) into the new vector.\n    // We cannot then use `l_slice`\
    \ anymore.\n    //\n    // This is why we assign `l_slice` to the _new_ vector\
    \ returned by `to_vec`.\n    // This way, the vector `l` that we had at the beginning\
    \ of the function\n    // and the vector `l_slice` that we get at the end of the\
    \ function\n    // contain the same elements.\n\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_slice` in this scope\n  --> /tmp/tmpc19yff5d.rs:21:5\n\
    \   |\n21 |     sort_slice(l_slice.as_mut_slice());\n   |     ^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `as_mut_slice` found for mutable\
    \ reference `&mut [isize]` in the current scope\n  --> /tmp/tmpc19yff5d.rs:21:24\n\
    \   |\n21 |     sort_slice(l_slice.as_mut_slice());\n   |                    \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `as_mut_ptr`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpc19yff5d.rs:8:32\n  |\n8 | fn sort_even(l:\
    \ Vec<isize>) -> Vec<isize> {\n  |    ---------                   ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            continue;\n        } else {\n            l_prime[i] = l[i];\n\
    \        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpmw0u94c7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut evens: Vec<isize> = Vec::new();\n    let mut odds: Vec<isize> = Vec::new();\n\
    \    for (i, n) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   odds.push(*n);\n        } else {\n            evens.push(*n);\n        }\n\
    \    }\n    evens.sort();\n    let mut new_l: Vec<isize> = Vec::new();\n    for\
    \ i in 0..odds.len() {\n        new_l.push(odds[i]);\n        new_l.push(evens[i]);\n\
    \    }\n    new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmporkjc821.rs:22:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_even: Vec<isize> = Vec::new();\n    let mut l_odd: Vec<isize> = Vec::new();\n\
    \    let mut l_prime: Vec<isize> = Vec::new();\n    let mut i = 0;\n    for i\
    \ in 0..l.len() {\n        if i % 2 == 0 {\n            l_even.push(l[i]);\n \
    \       } else {\n            l_odd.push(l[i]);\n        }\n    }\n    l_even.sort();\n\
    \    for i in 0..l_even.len() {\n        l_prime.push(l_even[i]);\n        l_prime.push(l_odd[i]);\n\
    \    }\n    return l_prime;\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpwalqwi1n.rs:23:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even_indices = Vec::new();\n    let mut even_indices_sorted = Vec::new();\n\
    \    let mut l_result = Vec::new();\n    let mut i = 0;\n    for x in l {\n  \
    \      if i % 2 == 0 {\n            even_indices.push(x);\n        }\n       \
    \ l_result.push(x);\n        i += 1;\n    }\n    even_indices_sorted = even_indices.clone();\n\
    \    even_indices_sorted.sort();\n    i = 0;\n    for x in even_indices_sorted\
    \ {\n        l_result[i] = x;\n        i += 2;\n    }\n    l_result\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let evens: Vec<isize> = l.iter().enumerate().filter(|(i, _)| i % 2 == 0).map(|(_,\
    \ n)| *n).collect();\n    let odds: Vec<isize> = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 1).map(|(_, n)| *n).collect();\n    let mut evens_sorted = evens.clone();\n\
    \    evens_sorted.sort();\n    let mut result: Vec<isize> = Vec::new();\n    for\
    \ (i, _) in evens.iter().enumerate() {\n        result.push(evens_sorted[i]);\n\
    \        result.push(odds[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmp2jgu1ckt.rs:16:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut n = l.clone();\n    n.sort();\n    let mut o = l.clone();\n    o.sort();\n\
    \    // Gets the even indicies of o\n    o.retain(|&x| x % 2 == 0);\n    //Gets\
    \ the even indicies of n\n    n.retain(|&x| x % 2 == 0);\n    let mut out = Vec::new();\n\
    \    // Pushes elements from o and n into the output vector\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            out.push(n[i / 2]);\n        } else\
    \ {\n            out.push(o[i / 2]);\n        }\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpey2dt2hy.rs:21:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted = l;\n    sorted.sort();\n    sorted\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpxjuo58gr.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut evens = l.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_, &e)|\
    \ e).collect::<Vec<isize>>();\n    evens.sort();\n    l.iter().enumerate().map(|(i,\
    \ &e)| if i % 2 == 0 { evens.remove(0) } else { e }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even_vec = vec![];\n    let mut odd_vec = vec![];\n    let mut res =\
    \ vec![];\n    for (index, value) in l.iter().enumerate() {\n        if index\
    \ % 2 == 0 {\n            even_vec.push(*value);\n        } else {\n         \
    \   odd_vec.push(*value);\n        }\n    }\n    even_vec.sort();\n    let mut\
    \ index = 0;\n    for value in l.iter() {\n        if index % 2 == 0 {\n     \
    \       res.push(even_vec[index / 2]);\n        } else {\n            res.push(*value);\n\
    \        }\n        index += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Build up the result vector with even indicies\n    let mut result = Vec::with_capacity(l.len());\n\
    \    let mut sorted_evens = Vec::with_capacity(l.len() / 2);\n    for (index,\
    \ value) in l.iter().enumerate() {\n        if index % 2 == 0 {\n            sorted_evens.push(*value);\n\
    \        }\n    }\n    sorted_evens.sort();\n    // Now iterate again and assemble\
    \ the result\n    let mut even_index = 0;\n    for (index, value) in l.iter().enumerate()\
    \ {\n        if index % 2 == 0 {\n            result.push(sorted_evens[even_index]);\n\
    \            even_index += 1;\n        } else {\n            result.push(*value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // panic!(\"Not implemented\");\n    let mut answer: Vec<isize> = Vec::new();\n\
    \    let mut evens: Vec<isize> = Vec::new();\n    let mut odd = false;\n    for\
    \ i in l {\n        if odd {\n            answer.push(i);\n        } else {\n\
    \            evens.push(i);\n        }\n        odd = !odd;\n    }\n    evens.sort();\n\
    \    for i in evens {\n        answer.push(i);\n    }\n    answer\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpwtid_49x.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut ret_vec = l.clone();\n    let mut temp_vec = Vec::new();\n    for i\
    \ in 0..ret_vec.len() {\n        if i % 2 == 0 {\n            temp_vec.push(ret_vec[i]);\n\
    \        }\n    }\n    temp_vec.sort();\n    for i in 0..ret_vec.len() {\n   \
    \     if i % 2 == 0 {\n            ret_vec[i] = temp_vec[i / 2];\n        }\n\
    \    }\n    ret_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut li = l.clone();\n    let even_indicies = li.iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 0).map(|(i, _)| i).collect::<Vec<usize>>();\n    for (i, ind) in\
    \ even_indicies.iter().enumerate() {\n        li[*ind] = even_indicies.iter().map(|x|\
    \ l[*x]).collect::<Vec<isize>>()[i];\n    }\n    li\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp6rah2l5f.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_sorted = l.clone();\n    l_sorted.sort();\n    let mut l_prime = Vec::new();\n\
    \    let mut j = 0;\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n    \
    \        l_prime.push(l[i]);\n        } else {\n            l_prime.push(l_sorted[j]);\n\
    \            j += 1;\n        }\n    }\n    l_prime\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpbetwtiu1.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    // We must not sort elements at odd indicies\n    for i\
    \ in 0..l.len() {\n        if i % 2 == 0 {\n            // Sort each element at\
    \ an even index\n            for j in 0..l.len() {\n                if j > i &&\
    \ j % 2 == 0 {\n                    // If the value at j is smaller than the value\
    \ at i, swap their values\n                    if l[j] < l[i] {\n            \
    \            let temp = l[i];\n                        l[i] = l[j];\n        \
    \                l[j] = temp;\n                    }\n                }\n    \
    \        }\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted_evens = Vec::new();\n    let mut evens = Vec::new();\n    let\
    \ mut odds = Vec::new();\n    for (i, &x) in l.iter().enumerate() {\n        if\
    \ i % 2 == 0 {\n            odds.push(x);\n        } else {\n            evens.push(x);\n\
    \        }\n    }\n    evens.sort();\n    for (i, _) in l.iter().enumerate() {\n\
    \        if i % 2 == 0 {\n            sorted_evens.push(odds[i/2]);\n        }\
    \ else {\n            sorted_evens.push(evens[i/2]);\n        }\n    }\n    sorted_evens\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpf2tahuy0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = Vec::new();\n    let mut odd_vec = Vec::new();\n    let mut\
    \ even_vec = Vec::new();\n    let mut current_index = 0;\n    for i in l {\n \
    \       if current_index % 2 == 0 {\n            even_vec.push(i);\n        }\
    \ else {\n            odd_vec.push(i);\n        }\n        current_index += 1;\n\
    \    }\n    even_vec.sort();\n    current_index = 0;\n    for i in even_vec {\n\
    \        new_vec.push(i);\n        new_vec.push(odd_vec[current_index]);\n   \
    \     current_index += 1;\n    }\n    new_vec\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpvlap4a17.rs:25:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut out = Vec::with_capacity(l.len());\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            out.push(l[i]);\n        } else {\n        \
    \    out.push(l[i]);\n            out.sort();\n        }\n    }\n    out\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 2, 3, 3, 5, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmplrk7x831.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut ret_vec = Vec::new();\n    let mut odd_vec = Vec::new();\n    let mut\
    \ even_vec = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n        if\
    \ i % 2 == 0 {\n            odd_vec.push(*x);\n        } else {\n            even_vec.push(*x);\n\
    \        }\n    }\n    even_vec.sort();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            ret_vec.push(odd_vec[i / 2]);\n        } else {\n\
    \            ret_vec.push(even_vec[i / 2]);\n        }\n    }\n    ret_vec\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp4v0uqf6s.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut res: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            res.push(l[i]);\n        } else {\n            let\
    \ evens: Vec<isize> = l[..i]\n                .iter()\n                .filter(|x|\
    \ **x % 2 == 0)\n                .map(|x| *x)\n                .collect();\n \
    \           let mut evens = evens.clone();\n            evens.sort();\n      \
    \      let index = evens.binary_search(&l[i]).unwrap();\n            res.push(evens[index\
    \ - 1]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    0'', /tmp/tmph39g5uc5.rs:21:52

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut lc = l.clone();\n    let mut lp = Vec::new();\n    for (i, v) in lc.iter().enumerate()\
    \ {\n        // Creates a new vector containing only the even indicies of l\n\
    \        if i % 2 == 0 {\n            lp.push(*v);\n        }\n    }\n    lp.sort();\n\
    \    // Pushes odd values from l into lp\n    for (i, v) in l.iter().enumerate()\
    \ {\n        if i % 2 != 0 {\n            lp.insert(i, *v);\n        }\n    }\n\
    \    lp\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut l_even = l.drain(2..).collect::<Vec<isize>>();\n\
    \    l_even.sort();\n    l.extend(l_even);\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -10, -5, -3, 0, 1, 2, 3, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpkg5urfix.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = l.clone();\n    let mut even_indices: Vec<_> = (0..new_vec.len()).filter(|x|\
    \ x % 2 == 0).collect();\n    let even_elements: Vec<_> = even_indices.iter().map(|&x|\
    \ new_vec[x]).collect();\n    let mut sorted_elements = even_elements.clone();\n\
    \    sorted_elements.sort();\n    for (&sorted_index, &sorted_element) in sorted_elements.iter().zip(even_elements.iter())\
    \ {\n        new_vec[sorted_index] = *sorted_element;\n    }\n    new_vec\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpsnqjf0gc.rs:15:33\n\
    \   |\n15 |         new_vec[sorted_index] = *sorted_element;\n   |           \
    \                      ^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpsnqjf0gc.rs:15:9\n   |\n15 |         new_vec[sorted_index]\
    \ = *sorted_element;\n   |         ^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_list = l.clone();\n    new_list[1] = l[0].min(l[1]);\n    new_list[3]\
    \ = l[2].min(l[3]);\n    new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpk6_0og43.rs:11:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // TODO: implement the sort_even function\n    let mut lp = l.clone();\n   \
    \ let mut lo = 0;\n    let mut hi = 0;\n    let n = l.len();\n    if n > 1 {\n\
    \        lo = 1;\n        hi = n;\n        while lo < hi {\n            while\
    \ lo < hi && l[lo - 1] <= l[lo] {\n                lo += 2;\n            }\n \
    \           while lo < hi && l[hi - 1] >= l[hi] {\n                hi -= 2;\n\
    \            }\n            if lo < hi {\n                swap(&mut lp, lo - 1,\
    \ hi - 1);\n                swap(&mut lp, lo, hi);\n            }\n        }\n\
    \    }\n    lp\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmptql64ee8.rs:25:17\n\
    \   |\n25 |                 swap(&mut lp, lo - 1, hi - 1);\n   |             \
    \    ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmptql64ee8.rs:26:17\n\
    \   |\n26 |                 swap(&mut lp, lo, hi);\n   |                 ^^^^\
    \ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut evens = Vec::new();\n    for (i, element)\
    \ in v.iter().enumerate() {\n        if i % 2 == 0 {\n            evens.push(*element);\n\
    \        }\n    }\n    evens.sort();\n    for (i, element) in evens.iter().enumerate()\
    \ {\n        v[i * 2] = *element;\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut m: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        if i\
    \ % 2 == 0 {\n            m.push(l[i]);\n        } else {\n            let mut\
    \ j = i;\n            while l[j] > l[j - 1] {\n                let t = l[j];\n\
    \                l[j] = l[j - 1];\n                l[j - 1] = t;\n           \
    \     j -= 1;\n            }\n            m.push(l[i]);\n        }\n    }\n  \
    \  m\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp2jrx_cso.rs:17:17\n   |\n8  | fn sort_even(l: Vec<isize>) -> Vec<isize>\
    \ {\n   |              - help: consider changing this to be mutable: `mut l`\n\
    ...\n17 |                 l[j] = l[j - 1];\n   |                 ^ cannot borrow\
    \ as mutable\n\nerror[E0596]: cannot borrow `l` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmp2jrx_cso.rs:18:17\n   |\n8  | fn sort_even(l: Vec<isize>)\
    \ -> Vec<isize> {\n   |              - help: consider changing this to be mutable:\
    \ `mut l`\n...\n18 |                 l[j - 1] = t;\n   |                 ^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut output: Vec<isize> = Vec::new();\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut odds: Vec<isize> = Vec::new();\n    for (i, item) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            evens.push(*item);\n        } else {\n\
    \            odds.push(*item);\n        }\n    }\n    evens.sort();\n    for (i,\
    \ item) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            output.push(evens.remove(0));\n\
    \        } else {\n            output.push(*item);\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut i = 0;\n    let mut a = 0;\n    let mut\
    \ b = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut p = 0;\n    let\
    \ mut q = 0;\n    if v.len() == 0 {\n        return vec![];\n    }\n    while\
    \ i < v.len() {\n        if i % 2 == 0 {\n            a = v[i];\n            x\
    \ = i;\n            while x < v.len() {\n                if v[x] < a {\n     \
    \               a = v[x];\n                    p = x;\n                }\n   \
    \             x += 1;\n            }\n            v[p] = v[i];\n            v[i]\
    \ = a;\n        }\n        i += 1;\n    }\n    return v;\n}\n\nfn main() {\n \
    \   let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 3]`,\n right: `[1, 2, 3]`', /tmp/tmps7148ulp.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result = l.clone();\n    let mut even = vec![];\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even.push(l[i]);\n        }\n    }\n\
    \    even.sort();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n      \
    \      result[i] = even[i / 2];\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = Vec::new();\n    for (index, elem) in l.iter().enumerate()\
    \ {\n        if index % 2 == 0 {\n            new_vec.push(*elem);\n        }\
    \ else {\n            new_vec.push(*elem);\n            let mut temp_vec = new_vec.clone();\n\
    \            temp_vec.sort();\n            new_vec = temp_vec;\n        }\n  \
    \  }\n    new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 2, 3, 3, 5, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp54xn1xd7.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_iter = l.iter();\n    let mut l_even: Vec<isize> = Vec::new();\n \
    \   while let Some(num) = l_iter.next() {\n        if l_even.len() % 2 == 0 {\n\
    \            l_even.push(*num);\n        } else {\n            let mut j = 0;\n\
    \            while j < l_even.len() {\n                if l_even[j] > *num {\n\
    \                    l_even.insert(j, *num);\n                    break;\n   \
    \             }\n                j += 1;\n            }\n            if j == l_even.len()\
    \ {\n                l_even.push(*num);\n            }\n        }\n    }\n   \
    \ l_even\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 3, 5, -5, -3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpy6j6xl03.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_copy = l.clone();\n    let mut sorted_vector = vec![];\n    // Remove\
    \ even values and sort\n    for i in 0..l_copy.len() {\n        if i % 2 == 0\
    \ {\n            sorted_vector.push(l_copy.remove(i));\n        }\n    }\n   \
    \ sorted_vector.sort();\n    // Insert sorted even values into the vector\n  \
    \  for i in 0..l_copy.len() {\n        if i % 2 == 0 {\n            l_copy.insert(i,\
    \ sorted_vector.remove(0));\n        }\n    }\n    l_copy\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''removal index (is 2) should be < len (is
    2)'', /tmp/tmpfsmzvvyx.rs:14:39

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // The first value in the vector will always be even,\n    // so we can safely\
    \ skip the first value.\n    // This is done so that we can set the starting value\
    \ for `is_even` as false.\n    let mut working_vec = l[1..].to_vec();\n    let\
    \ mut sorted_vec = Vec::new();\n    let mut is_even = false;\n\n    // Go through\
    \ the values in `working_vec`\n    for i in 0..working_vec.len() {\n        if\
    \ working_vec[i] % 2 == 0 {\n            is_even = true;\n            // Move\
    \ the value at the current index to the end\n            // This will put all\
    \ even values in sorted_vec\n            sorted_vec.push(working_vec.remove(i));\n\
    \        }\n    }\n\n    // If there were no even values, return `l`\n    if !is_even\
    \ {\n        return l;\n    }\n\n    // Sort the even values in sorted_vec\n \
    \   sorted_vec.sort();\n\n    // Iterate through the even indicies of l\n    for\
    \ i in (0..l.len()).step_by(2) {\n        // Go through each even value in sorted_vec\n\
    \        for j in 0..sorted_vec.len() {\n            // If the current even value\
    \ matches the value at the current index in l\n            if sorted_vec[j] ==\
    \ l[i] {\n                // Replace the value at the current index in l with\
    \ the new value from sorted_vec\n                l[i] = sorted_vec[j];\n     \
    \           // Remove the value from sorted_vec, since it is no longer needed\n\
    \                sorted_vec.remove(j);\n                // Break out of the inner\
    \ loop, as this value is no longer needed\n                break;\n          \
    \  }\n        }\n    }\n\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpo6u5l6eu.rs:41:17\n   |\n8  | fn sort_even(l: Vec<isize>) -> Vec<isize>\
    \ {\n   |              - help: consider changing this to be mutable: `mut l`\n\
    ...\n41 |                 l[i] = sorted_vec[j];\n   |                 ^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Hint: \n    // 1. Implement the function, but do not sort the entire vector.\n\
    \    // 2. Use the helper function to split the vector in two parts.\n    // 3.\
    \ Sort only the even elements.\n    // 4. Use the helper function to merge the\
    \ two parts back into a single vector.\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp696ut_vs.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // start with a clone of the input vector\n    let mut sorted_list = l.clone();\n\
    \    // gather the even indicies\n    let even_indicies: Vec<usize> = l.iter().enumerate().filter(|(i,\
    \ _)| *i % 2 == 0).map(|(i, _)| i).collect();\n    // mutable pointers to the\
    \ even indicies\n    let even_indicies_ptrs: Vec<&mut isize> = even_indicies.iter().map(|i|\
    \ &mut sorted_list[*i]).collect();\n    // sort the pointers to the even indicies\n\
    \    even_indicies_ptrs.sort();\n    // return the vector\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: captured variable cannot escape `FnMut` closure body\n  --> /tmp/tmp2tesus5q.rs:14:76\n\
    \   |\n10 |     let mut sorted_list = l.clone();\n   |         ---------------\
    \ variable defined here\n...\n14 |     let even_indicies_ptrs: Vec<&mut isize>\
    \ = even_indicies.iter().map(|i| &mut sorted_list[*i]).collect();\n   |      \
    \                                                                    - ^^^^^-----------^^^^\n\
    \   |                                                                        \
    \  | |    |\n   |                                                            \
    \              | |    variable captured here\n   |                           \
    \                                               | returns a reference to a captured\
    \ variable which escapes the closure body\n   |                              \
    \                                            inferred to be a `FnMut` closure\n\
    \   |\n   = note: `FnMut` closures only have access to their captured variables\
    \ while they are executing...\n   = note: ...therefore, they cannot allow references\
    \ to captured variables to escape\n\nerror[E0596]: cannot borrow `even_indicies_ptrs`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp2tesus5q.rs:16:5\n\
    \   |\n14 |     let even_indicies_ptrs: Vec<&mut isize> = even_indicies.iter().map(|i|\
    \ &mut sorted_list[*i]).collect();\n   |         ------------------ help: consider\
    \ changing this to be mutable: `mut even_indicies_ptrs`\n15 |     // sort the\
    \ pointers to the even indicies\n16 |     even_indicies_ptrs.sort();\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // TODO: Implement me!\n    let mut l = l;\n    let mut i = 0;\n    while i\
    \ < l.len() {\n        let mut j = i + 1;\n        while j < l.len() {\n     \
    \       if l[i] > l[j] {\n                l.swap(i, j);\n            }\n     \
    \       j += 2;\n        }\n        i += 2;\n    }\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 5, -5, 3, -3, 3, 1, 9, 2, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpkny482st.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even = l.iter().enumerate().filter(|(i, _)| i % 2 == 0).map(|(_, &x)|\
    \ x).collect::<Vec<isize>>();\n    even.sort();\n    l.iter().enumerate().map(|(i,\
    \ &x)| if i % 2 == 0 { even.remove(0) } else { x }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            let mut max = 0;\n            for j in 0..l.len() {\n     \
    \           if l[j] > max && j % 2 == 0 {\n                    max = l[j];\n \
    \               }\n            }\n            l_prime[i] = max;\n        }\n \
    \   }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp28gwusz8.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ if l.len() == 0 {\n        return l;\n    }\n\n    let mut res = Vec::with_capacity(l.len());\n\
    \    let mut temp_vec = l[0..2].to_vec();\n    temp_vec.sort();\n    res.push(temp_vec[0]);\n\
    \    res.push(temp_vec[1]);\n\n    for i in 2..l.len() {\n        if i % 2 ==\
    \ 0 {\n            let mut temp_vec = l[i..i + 2].to_vec();\n            temp_vec.sort();\n\
    \            res.push(temp_vec[0]);\n            res.push(temp_vec[1]);\n    \
    \    } else {\n            res.push(l[i]);\n        }\n    }\n\n    res\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''range end index 4 out of range for slice
    of length 3'', library/core/src/slice/index.rs:73:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let temp = l.iter().enumerate().filter(|&(index, _)| index\
    \ % 2 == 0).map(|(_, &v)| v).collect::<Vec<isize>>();\n    let mut temp = temp;\n\
    \    temp.sort();\n    for (index, element) in temp.iter().enumerate() {\n   \
    \     l[index * 2] = *element;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut s = l.clone();\n    s.sort();\n    let r: Vec<isize> = l.iter().zip(s.iter()).map(|(a,\
    \ b)| {\n        if a % 2 == 0 {\n            *b\n        } else {\n         \
    \   *a\n        }\n    }).collect();\n    r\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 0, -3, 3, 9, 3, 123, 1, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmppgg0lcrx.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Your code here\n    let mut even_vec = vec![];\n    let mut odd_vec = vec![];\n\
    \    let mut result = vec![];\n    for (index, item) in l.iter().enumerate() {\n\
    \        if index % 2 == 0 {\n            odd_vec.push(*item);\n        } else\
    \ {\n            even_vec.push(*item);\n        }\n    }\n    even_vec.sort();\n\
    \    result.extend(odd_vec);\n    result.extend(even_vec);\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp5osaotgh.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut l_sorted: Vec<isize> = Vec::new();\n    let mut\
    \ mut_counter = 0;\n    let mut counter = 0;\n    while mut_counter < l.len()\
    \ {\n        if mut_counter % 2 == 0 {\n            l_sorted.push(l[mut_counter]);\n\
    \        }\n        mut_counter += 1;\n    }\n    l_sorted.sort();\n    mut_counter\
    \ = 0;\n    while mut_counter < l.len() {\n        if mut_counter % 2 == 0 {\n\
    \            l[mut_counter] = l_sorted[counter];\n            counter += 1;\n\
    \        }\n        mut_counter += 1;\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted_l = l.clone();\n    sorted_l.sort();\n    let mut res = vec![];\n\
    \    for i in 0..sorted_l.len() {\n        if i % 2 == 0 {\n            res.push(l[i]);\n\
    \        } else {\n            res.push(sorted_l[i]);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, -5, 0, -3, 2, 9, 3, 123, 9, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpty55074t.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l1 = l.clone();\n    let mut l2 = l.clone();\n    l1.retain(|x| (x %\
    \ 2) == 0);\n    l2.retain(|x| (x % 2) != 0);\n    l1.sort();\n    let mut l3\
    \ = Vec::new();\n    let mut j = 0;\n    for i in 0..l.len() {\n        if (i\
    \ % 2) == 0 {\n            l3.push(l1[j]);\n            j += 1;\n        } else\
    \ {\n            l3.push(l2[i / 2]);\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpc5n98sr1.rs:18:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result: Vec<isize> = Vec::new();\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut num_evens = 0;\n    for i in 0..l.len() {\n        if i % 2 == 0\
    \ {\n            result.push(l[i]);\n        } else {\n            evens.push(l[i]);\n\
    \            num_evens += 1;\n        }\n    }\n    evens.sort();\n    for i in\
    \ 0..num_evens {\n        result.push(evens[i]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpogjae4zd.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    for i in 0..l.len() {\n        for j in (i + 1)..l.len()\
    \ {\n            if i % 2 == 0 && l[i] > l[j] {\n                l.swap(i, j);\n\
    \            }\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpq7lpgta5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Finish me!\n    return vec![];\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 3]`', /tmp/tmpbzg3poq9.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v: Vec<isize> = Vec::new();\n    let mut u: Vec<isize> = Vec::new();\n\
    \    for n in l {\n        if v.len() % 2 == 0 {\n            u.push(n);\n   \
    \     } else {\n            v.push(n);\n        }\n    }\n    u.sort();\n    for\
    \ n in u {\n        v.push(n);\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpx5kie8_p.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    // TODO: write this function as described above.\n    let\
    \ mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n            if\
    \ l[i] < l[i+1] {\n                let c = l[i];\n                l[i] = l[i+1];\n\
    \                l[i+1] = c;\n            }\n        }\n        i += 1;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpjrt3as5q.rs:14:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_l = l.clone();\n    for i in 0..l.len() {\n        if i % 2 == 0\
    \ {\n            new_l[i] = *l.iter().min().unwrap();\n        }\n    }\n    new_l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmp0qvwobz1.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v: Vec<isize> = l.clone();\n    v.sort();\n    v\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpuse1avzd.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let (even, odd) = l.into_iter().enumerate().partition(|&(i, _)| i % 2 == 0);\n\
    \    let sorted_even = even.map(|(_, x)| x).collect::<Vec<_>>().sort();\n    let\
    \ new_even = sorted_even.iter().enumerate().map(|(i, x)| (i * 2, *x));\n    new_even.chain(odd).map(|(_,\
    \ x)| x).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `(B, B)`\n  --> /tmp/tmpbuur4y5o.rs:10:23\n\
    \   |\n9  |     let (even, odd) = l.into_iter().enumerate().partition(|&(i, _)|\
    \ i % 2 == 0);\n   |         ----------- consider giving this pattern the explicit\
    \ type `(B, B)`, with the type parameters specified\n10 |     let sorted_even\
    \ = even.map(|(_, x)| x).collect::<Vec<_>>().sort();\n   |                   \
    \    ^^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    for i in 1..l.len() {\n        if i % 2 ==\
    \ 0 {\n            let even_index = l_prime.remove(i);\n            l_prime.insert(i,\
    \ even_index);\n        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpjxh7yw8g.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even_sorted: Vec<isize> = Vec::new();\n    let mut odd_indicies: Vec<isize>\
    \ = Vec::new();\n    for n in l {\n        if n % 2 == 0 {\n            even_sorted.push(n);\n\
    \        } else {\n            odd_indicies.push(n);\n        }\n    }\n    even_sorted.sort();\n\
    \    let mut sorted: Vec<isize> = Vec::new();\n    for i in 0..even_sorted.len()\
    \ {\n        if i % 2 == 0 {\n            sorted.push(even_sorted[i]);\n     \
    \   } else {\n            sorted.push(odd_indicies[i]);\n        }\n    }\n  \
    \  sorted\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[1, 2, 3]`', /tmp/tmps8cotjzv.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even_values: Vec<isize> = Vec::new();\n    let mut odd_values: Vec<isize>\
    \ = Vec::new();\n    let mut result: Vec<isize> = Vec::new();\n\n    let mut index\
    \ = 0;\n    while index < l.len() {\n        if index % 2 == 0 {\n           \
    \ even_values.push(l[index]);\n        } else {\n            odd_values.push(l[index]);\n\
    \        }\n        index += 1;\n    }\n\n    even_values.sort();\n\n    index\
    \ = 0;\n    while index < l.len() {\n        if index % 2 == 0 {\n           \
    \ result.push(even_values[index / 2]);\n        } else {\n            result.push(odd_values[index\
    \ / 2]);\n        }\n        index += 1;\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = Vec::new();\n    let length = l.len();\n    for i in 0..length\
    \ {\n        if i % 2 == 0 {\n            new_vec.push(l[i]);\n        } else\
    \ {\n            let mut sorted_vec = l[i..i + 2].to_vec();\n            sorted_vec.sort();\n\
    \            new_vec.append(&mut sorted_vec);\n        }\n    }\n    new_vec\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpsq9auafe.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l1 = l.clone();\n    let mut l2 = l.clone();\n    l1.sort();\n    for\
    \ i in (0..l.len()).filter(|n| n % 2 == 0) {\n        l2[i] = l1[i];\n    }\n\
    \    l2\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 3, -3, 2, 1, 3, 3, 0, 5, 1, 123]`,\n right: `[-10, 3, -5, 2, -3, 3, 5,\
    \ 0, 9, 1, 123]`', /tmp/tmpeamx89_y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // TODO: Implement\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpbqjsa2ip.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // set up the output vector\n    let mut out = l.clone();\n    // get the size\
    \ of the list\n    let length = l.len();\n    // get the value of the list for\
    \ index\n    for i in 0..length {\n        if i % 2 == 0 {\n            out[i]\
    \ = l[i];\n        } else {\n            let mut temp_vec = l[i - 1..i + 1].to_vec();\n\
    \            temp_vec.sort();\n            out[i - 1] = temp_vec[0];\n       \
    \     out[i] = temp_vec[1];\n        }\n    }\n    return out;\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpi74c_lra.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ l.iter().enumerate().map(|(i, x)| match i % 2 {\n        0 => *x,\n        _\
    \ => *x,\n    }).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpj7kp7nzx.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Your implementation here\n    unimplemented!()\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp09uoshc_.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ l.into_iter().enumerate().map(|(i, x)| if i % 2 == 0 { x } else { l[i - 1] }).collect()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpkt7opyn_.rs:9:35\n\
    \    |\n8   | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    |             \
    \ - move occurs because `l` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n9   |     l.into_iter().enumerate().map(|(i, x)| if i % 2 == 0\
    \ { x } else { l[i - 1] }).collect()\n    |       -----------                \
    \ ^^^^^^^^                            - borrow occurs due to use in closure\n\
    \    |       |                           |\n    |       |                    \
    \       value borrowed here after move\n    |       `l` moved due to this method\
    \ call\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `l`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    //start at first odd index\n    for i in (1..v.len()).step_by(2)\
    \ {\n        //for each item at that odd index, check the value at the previous\
    \ index\n        for j in (1..v.len()).step_by(2) {\n            //check if the\
    \ value at the jth index is less than the value at the previous index\n      \
    \      if v[j - 1] > v[j] {\n                //swap the elements if so\n     \
    \           v.swap(j - 1, j);\n            }\n        }\n    }\n    //return new\
    \ vector\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpi6rk44rn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut res: Vec<isize> = Vec::new();\n    let mut even_vec: Vec<isize> = Vec::new();\n\
    \    let mut odd_vec: Vec<isize> = Vec::new();\n    let mut it_l = l.iter();\n\
    \    while let Some(n) = it_l.next() {\n        if n % 2 == 0 {\n            even_vec.push(*n);\n\
    \        } else {\n            odd_vec.push(*n);\n        }\n    }\n    even_vec.sort();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            res.push(odd_vec[i\
    \ / 2]);\n        } else {\n            res.push(even_vec[i / 2]);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp2scnu7x4.rs:25:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut odd = l.clone();\n    for i in (0..l.len()).filter(|x| x % 2 == 0) {\n\
    \        let mut even: Vec<isize> = l.clone();\n        even.sort();\n       \
    \ odd[i] = even[i];\n    }\n    odd\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 3, -3, 2, 1, 3, 3, 0, 5, 1, 123]`,\n right: `[-10, 3, -5, 2, -3, 3, 5,\
    \ 0, 9, 1, 123]`', /tmp/tmp_p7kkqen.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    for x in 0..l.len() {\n        if x % 2 ==\
    \ 0 {\n            let y = l_prime[x];\n            l_prime[x] = l_prime[x + 1];\n\
    \            l_prime[x + 1] = y;\n        }\n    }\n    return l_prime;\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpwd7dafkm.rs:13:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // todo!()\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpwsmsj408.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_l = l.clone();\n    new_l.drain_filter(|_| true).collect()\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'drain_filter': recently\
    \ added\n  --> /tmp/tmpzd64hcj_.rs:10:11\n   |\n10 |     new_l.drain_filter(|_|\
    \ true).collect()\n   |           ^^^^^^^^^^^^\n   |\n   = note: see issue #43244\
    \ <https://github.com/rust-lang/rust/issues/43244> for more information\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even = l.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_, &x)|\
    \ x).collect::<Vec<isize>>();\n    even.sort();\n    l.iter().enumerate().map(|(i,\
    \ &x)| if i % 2 == 0 { even.remove(0) } else { x }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l2 = l.clone();\n    // TODO: implement me\n    let mut sorted_even_idx\
    \ = Vec::new();\n    let mut sorted_even_val = Vec::new();\n    for i in 1..l.len()\
    \ {\n        if i % 2 == 0 {\n            sorted_even_idx.push(i);\n         \
    \   sorted_even_val.push(l[i]);\n        }\n    }\n    sorted_even_val.sort();\n\
    \    for i in 0..sorted_even_idx.len() {\n        l2[sorted_even_idx[i]] = sorted_even_val[i];\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -10, 2, -5, 3, -3, 0, 9, 1, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpdnmpw7lo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Make a mutable copy of l.\n    let mut copy = l.clone();\n    // Get the\
    \ elements at the even indices.\n    let evens = &mut copy[0..][..copy.len() /\
    \ 2];\n    // Sort them using merge sort.\n    merge_sort(evens);\n    // Return\
    \ our sorted list.\n    copy\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `merge_sort` in this scope\n  --> /tmp/tmp4bmk15ky.rs:14:5\n\
    \   |\n14 |     merge_sort(evens);\n   |     ^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_copy = l.clone();\n    let mut sorted_odds = vec![];\n    let mut\
    \ sorted_evens = vec![];\n    let mut even_indexes = Vec::new();\n    let mut\
    \ odd_indexes = Vec::new();\n    let mut index = 0;\n    while index < l_copy.len()\
    \ {\n        if index % 2 == 0 {\n            sorted_evens.push(l_copy[index]);\n\
    \            even_indexes.push(index);\n        } else {\n            sorted_odds.push(l_copy[index]);\n\
    \            odd_indexes.push(index);\n        }\n        index += 1;\n    }\n\
    \    sorted_evens.sort();\n    for idx in even_indexes {\n        l_copy[idx]\
    \ = sorted_evens.pop().unwrap();\n    }\n    l_copy\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmpgu5yvbdw.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l2 = l.clone();\n    for i in (0..l.len()).step_by(2) {\n        for\
    \ j in (0..l.len()).step_by(2) {\n            if l2[i] < l2[j] {\n           \
    \     let temp = l2[i];\n                l2[i] = l2[j];\n                l2[j]\
    \ = temp;\n            }\n        }\n    }\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted_evens = vec![];\n    let mut odds = vec![];\n    let mut counter\
    \ = 0;\n    for i in l {\n        if (counter % 2) == 0 {\n            odds.push(i);\n\
    \        } else {\n            sorted_evens.push(i);\n        }\n        counter\
    \ += 1;\n    }\n    sorted_evens.sort();\n    odds.append(&mut sorted_evens);\n\
    \    odds\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpo2z5cja1.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Return a new list which is `l` in the odd indicies and a sorted list of `l`\
    \ in the even indicies\n    //\n    // # Examples\n    //\n    // ```\n    //\
    \ # use c_challenge::sort_even;\n    // assert_eq!(sort_even(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    // assert_eq!(sort_even(vec![5, 6, 3, 4]), vec![3, 6, 5, 4]);\n\
    \    // ```\n    let mut res: Vec<isize> = Vec::new();\n    let mut even_vec:\
    \ Vec<isize> = Vec::new();\n    for (index, value) in l.iter().enumerate() {\n\
    \        if index % 2 == 0 {\n            even_vec.push(*value);\n        } else\
    \ {\n            res.push(*value);\n        }\n    }\n    even_vec.sort();\n \
    \   for (index, value) in even_vec.iter().enumerate() {\n        res.insert(index\
    \ * 2, *value);\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // FIXME: implement this function.\n    let mut l = l;\n    let mut l_even =\
    \ Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n          \
    \  l_even.push(l[i]);\n        }\n    }\n    let mut l_odd = Vec::new();\n   \
    \ for i in 0..l.len() {\n        if i % 2 != 0 {\n            l_odd.push(l[i]);\n\
    \        }\n    }\n    l_even.sort();\n    for i in 0..l_even.len() {\n      \
    \  l[i * 2] = l_even[i];\n    }\n    for i in 0..l_odd.len() {\n        l[i *\
    \ 2 + 1] = l_odd[i];\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut n = l.clone();\n    let even_l: Vec<isize> = n.iter().enumerate().filter(|(x,\
    \ _)| x % 2 == 0).map(|(_, y)| *y).collect();\n    let mut even_l = even_l.clone();\n\
    \    even_l.sort();\n    let new_l: Vec<isize> = n.iter().enumerate().map(|(x,\
    \ y)| if x % 2 == 0 { even_l[x / 2] } else { *y }).collect();\n    new_l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let len = l.len();\n    let mut sorted = Vec::with_capacity(len);\n    let mut\
    \ even_sorted = l.clone();\n    even_sorted.sort();\n    for i in 0..len {\n \
    \       if i % 2 == 0 {\n            sorted.push(l[i]);\n        } else {\n  \
    \          sorted.push(even_sorted[i - 1]);\n        }\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpda2m4p6x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n      \
    \  if i % 2 == 0 {\n            result.push(l[i]);\n        } else {\n       \
    \     let mut temp: Vec<isize> = Vec::new();\n            for j in 0..l.len()\
    \ {\n                if j % 2 == 0 {\n                    temp.push(l[j]);\n \
    \               }\n            }\n            temp.sort();\n            let mut\
    \ j = 0;\n            while j < temp.len() {\n                if temp[j] == l[i\
    \ - 1] {\n                    break;\n                }\n                j +=\
    \ 1;\n            }\n            result.push(temp[j + 1]);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp7lfe0eep.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // This is just a crude implementation that runs in linear time.\n    // As\
    \ a project, try to implement a sorting algorithm that runs in linearithmic time\n\
    \    // on even indicies of the vector.\n    let mut l = l;\n    for i in (0..l.len()).step_by(2)\
    \ {\n        let mut swapped = false;\n        for j in (i + 2..l.len()).step_by(2)\
    \ {\n            if l[j] < l[i] {\n                l.swap(i, j);\n           \
    \     swapped = true;\n            }\n        }\n        if !swapped {\n     \
    \       break;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976052
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let sorted_evens = l.iter().step_by(2).map(|x| *x).collect::<Vec<isize>>();\n\
    \    sorted_evens.sort();\n    let mut l_prime = Vec::new();\n    for (idx, element)\
    \ in l.iter().enumerate() {\n        if idx % 2 == 0 {\n            l_prime.push(*element);\n\
    \        } else {\n            l_prime.push(sorted_evens.pop().unwrap());\n  \
    \      }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `sorted_evens` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmprzy8_x52.rs:10:5\n   |\n9  |     let sorted_evens\
    \ = l.iter().step_by(2).map(|x| *x).collect::<Vec<isize>>();\n   |         ------------\
    \ help: consider changing this to be mutable: `mut sorted_evens`\n10 |     sorted_evens.sort();\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `sorted_evens` as mutable, as it is not declared as mutable\n  --> /tmp/tmprzy8_x52.rs:16:26\n\
    \   |\n9  |     let sorted_evens = l.iter().step_by(2).map(|x| *x).collect::<Vec<isize>>();\n\
    \   |         ------------ help: consider changing this to be mutable: `mut sorted_evens`\n\
    ...\n16 |             l_prime.push(sorted_evens.pop().unwrap());\n   |       \
    \                   ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (i, x)\
    \ in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds.push(*x);\n\
    \        } else {\n            evens.push(*x);\n        }\n    }\n    evens.sort();\n\
    \    let mut output = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n\
    \        if i % 2 == 0 {\n            output.push(*x);\n        } else {\n   \
    \         output.push(evens.pop().unwrap());\n        }\n    }\n    output\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 3, -3, 2, 9, 1, 123, 0, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpe5cp2p9c.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut s = l.clone();\n    s.insert(0, -1);\n    let mut i = 2;\n    while\
    \ i < s.len() {\n        let mut k = i;\n        while k > 1 && s[k] < s[k - 2]\
    \ {\n            s.swap(k, k - 2);\n            k -= 2;\n        }\n        i\
    \ += 2;\n    }\n    s.remove(0);\n    s\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp71utrmlf.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut a = l.clone();\n    let b = a.split_off(1);\n    let mut c = b.clone();\n\
    \    c.sort();\n    a.append(&mut c);\n    a\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -3, 0, 1, 2, 3, 3, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmplgxu583g.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let even = l.iter().enumerate().filter(|tup| tup.0 % 2 == 0).map(|tup| tup.1).collect::<Vec<&isize>>();\n\
    \    let mut even = even.iter().map(|x| *x).collect::<Vec<isize>>();\n    even.sort();\n\
    \    let odd = l.iter().enumerate().filter(|tup| tup.0 % 2 == 1).map(|tup| tup.1).collect::<Vec<&isize>>();\n\
    \    let mut odd = odd.iter().map(|x| *x).collect::<Vec<isize>>();\n    even.append(&mut\
    \ odd);\n    even\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpsfnrznye.rs:10:44\n     |\n\
    10   |     let mut even = even.iter().map(|x| *x).collect::<Vec<isize>>();\n \
    \    |                                            ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: a value of type `Vec<isize>` cannot\
    \ be built from an iterator over elements of type `&isize`\n    --> /tmp/tmpsfnrznye.rs:13:42\n\
    \     |\n13   |     let mut odd = odd.iter().map(|x| *x).collect::<Vec<isize>>();\n\
    \     |                                          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let n = l.len();\n    let mut l = l;\n    for i in 0..n {\n        if i % 2\
    \ == 0 {\n            for j in 0..n {\n                if j % 2 == 0 && l[i] >\
    \ l[j] {\n                    l.swap(i, j);\n                }\n            }\n\
    \        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n \
    \   assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmp4wezxlqi.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut i = 1;\n    while i < v.len() {\n      \
    \  let mut j = i;\n        while j > 0 && v[j] < v[j - 1] {\n            v.swap(j,\
    \ j - 1);\n            j -= 1;\n        }\n        i += 2;\n    }\n    v\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmppd_r3_5y.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l_prime[i] = l[i + 1];\n        }\n    }\n    for i in 0..l.len()\
    \ {\n        for j in i + 1..l.len() {\n            if l_prime[i] > l_prime[j]\
    \ {\n                let temp = l_prime[i];\n                l_prime[i] = l_prime[j];\n\
    \                l_prime[j] = temp;\n            }\n        }\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp0phras7w.rs:12:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result = l.clone();\n    let i: usize = l.len() / 2;\n    let mut evens:\
    \ Vec<isize> = Vec::new();\n    for j in 0..i {\n        evens.push(l[2 * j]);\n\
    \    }\n    evens.sort();\n    for j in 0..i {\n        result[2 * j] = evens[j];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, 3, -3, 2, 5, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp3bqv10lf.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted_even = even_indicies(&l);\n    sorted_even.sort();\n    let result:\
    \ Vec<isize> = l.iter().enumerate().map(|(i, &x)| if i % 2 == 0 { x } else { sorted_even[i\
    \ / 2] }).collect();\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `even_indicies` in this scope\n -->\
    \ /tmp/tmp_sasmele.rs:9:27\n  |\n9 |     let mut sorted_even = even_indicies(&l);\n\
    \  |                           ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976052
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ if l.len() < 3 {\n        return l;\n    }\n\n    // get the even and odd slices\n\
    \    let even = &l[0..l.len() / 2];\n    let odd = &l[l.len() / 2..l.len()];\n\
    \n    // sort the even slice\n    let mut even_sorted = even.to_vec();\n    even_sorted.sort();\n\
    \n    // zip together the even and odd slices and return\n    even_sorted.iter().zip(odd.iter()).flat_map(|(a,\
    \ b)| vec![*a, *b]).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp91tbt3ax.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Hint: the following function will be useful\n    // pub fn sort_by<T, F>(&mut\
    \ self, f: F) where F: FnMut(&T, &T) -> Ordering;\n    let mut ls = l.clone();\n\
    \    ls.sort_by(|a, b| b.cmp(a));\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpcdw0qoya.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut res = l.clone();\n    for i in 0..res.len() {\n        if i % 2 == 0\
    \ {\n            continue;\n        }\n        res[i] = *res[i..].iter().min().unwrap();\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -10, -3, -10, 9, -10, 123, -10, -10]`,\n right: `[-10, 3, -5,\
    \ 2, -3, 3, 5, 0, 9, 1, 123]`', /tmp/tmp18j59pd3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n\tlet\
    \ mut result = Vec::new();\n\tlet mut eresult = Vec::new();\n\tlet mut index =\
    \ 0;\n\tfor i in l {\n\t\tif index % 2 == 0 {\n\t\t\teresult.push(i);\n\t\t} else\
    \ {\n\t\t\tresult.push(i);\n\t\t}\n\t\tindex += 1;\n\t}\n\teresult.sort();\n\t\
    for i in eresult {\n\t\tresult.insert(index, i);\n\t\tindex += 1;\n\t}\n\tresult\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''insertion index (is 3) should be <= len (is
    1)'', library/alloc/src/vec/mod.rs:1347:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = Vec::new();\n    let mut l_even = Vec::new();\n    let mut\
    \ l_odd = Vec::new();\n    for (idx, val) in l.iter().enumerate() {\n        if\
    \ idx % 2 == 0 {\n            l_even.push(*val);\n        } else {\n         \
    \   l_odd.push(*val);\n        }\n    }\n    l_even.sort();\n    for idx in 0..l.len()\
    \ {\n        if idx % 2 == 0 {\n            l_prime.push(l_even[idx/2]);\n   \
    \     } else {\n            l_prime.push(l_odd[idx/2]);\n        }\n    }\n  \
    \  l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let l_odd: Vec<isize> = l.iter().enumerate().filter(|x| x.0 % 2 == 1).map(|x|\
    \ x.1).cloned().collect();\n    let l_even: Vec<isize> = l.iter().enumerate().filter(|x|\
    \ x.0 % 2 == 0).map(|x| x.1).cloned().collect();\n    let l_even_sorted: Vec<isize>\
    \ = l_even.clone();\n    let mut l_even_sort: Vec<isize> = l_even_sorted.iter().cloned().collect();\n\
    \    l_even_sort.sort();\n    let mut l_even_sort_unsort: Vec<isize> = l_even_sort.iter().cloned().collect();\n\
    \    l_even_sort_unsort.sort_by(|a, b| l_even_sorted.iter().position(|&r| r ==\
    \ *a).cmp(&l_even_sorted.iter().position(|&r| r == *b)));\n    let mut out: Vec<isize>\
    \ = Vec::new();\n    for (i, x) in l_even_sort_unsort.iter().enumerate() {\n \
    \       out.push(*x);\n        out.push(l_odd[i]);\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpco8z57k5.rs:19:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut odd_indicies = l.iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 1).map(|(i, _)| i).collect::<Vec<usize>>();\n    let mut sorted_odd_indicies\
    \ = odd_indicies.clone();\n    sorted_odd_indicies.sort();\n    for (i, j) in\
    \ odd_indicies.iter().zip(sorted_odd_indicies.iter()) {\n        l.swap(*i, *j);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpb7m2_o49.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ l.iter().enumerate().map(|(x, y)| {\n        if x % 2 == 0 {\n            *y\n\
    \        } else {\n            let mut odd_vec = l.clone();\n            odd_vec.retain(|&z|\
    \ z % 2 != 0);\n            odd_vec.sort();\n            odd_vec[x/2]\n      \
    \  }\n    }).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp2g51s9xo.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ if l.len() == 0 {\n        l\n    } else {\n        let mut l = l;\n       \
    \ l.sort();\n        // concatenate the odd and even indices to create the result\
    \ vector\n        l.iter().enumerate().fold(vec![], |mut acc, (i, &x)| {\n   \
    \         if i % 2 == 0 {\n                acc.push(x);\n            } else {\n\
    \                acc.insert(i, x);\n            }\n            acc\n        })\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpm30wzu1g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    for i in (1..l.len()).step_by(2) {\n        let mut j =\
    \ i;\n        while j > 0 && l[j] < l[j - 1] {\n            l.swap(j, j - 1);\n\
    \            j -= 1;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp_jgiasue.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut b = l.to_vec();\n    for i in (0..b.len()).step_by(2) {\n        b[i]\
    \ = (b[i], i).min().0;\n    }\n    b\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpqcubsje3.rs:11:26\n    |\n11  |         b[i] = (b[i], i).min().0;\n\
    \    |                          ^^^- supplied 0 arguments\n    |             \
    \             |\n    |                          expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut vec = l.clone();\n    let (even, odd) = vec.split_at_mut(vec.len() /\
    \ 2);\n    let mut even: Vec<isize> = even.to_vec();\n    even.sort();\n    let\
    \ mut ret = Vec::new();\n    for i in 0..even.len() {\n        ret.push(even[i]);\n\
    \        ret.push(odd[i]);\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `vec` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpn8bt0jc1.rs:10:40\n   |\n10 |     let (even, odd)\
    \ = vec.split_at_mut(vec.len() / 2);\n   |                       -----------------^^^^^^^^^-----\n\
    \   |                       |   |            |\n   |                       | \
    \  |            immutable borrow occurs here\n   |                       |   mutable\
    \ borrow later used by call\n   |                       mutable borrow occurs\
    \ here\n   |\nhelp: try adding a local storing this argument...\n  --> /tmp/tmpn8bt0jc1.rs:10:40\n\
    \   |\n10 |     let (even, odd) = vec.split_at_mut(vec.len() / 2);\n   |     \
    \                                   ^^^^^^^^^\nhelp: ...and then using that local\
    \ as the argument to this call\n  --> /tmp/tmpn8bt0jc1.rs:10:23\n   |\n10 |  \
    \   let (even, odd) = vec.split_at_mut(vec.len() / 2);\n   |                 \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut ret = l.clone();\n    if ret.len() % 2 == 0 {\n        let mut even\
    \ = ret.split_off(1);\n        even.sort();\n        ret.append(&mut even);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp_0v8l5f9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut left_part = l.clone();\n    let mut right_part = l.clone();\n    let\
    \ mut sorted_left_part = left_part.clone();\n    let mut sorted_right_part = right_part.clone();\n\
    \    left_part.sort();\n    right_part.sort();\n    for (sorted_left, left) in\
    \ sorted_left_part.iter_mut().zip(left_part.iter()) {\n        *sorted_left =\
    \ *left;\n    }\n    for (sorted_right, right) in sorted_right_part.iter_mut().zip(right_part.iter())\
    \ {\n        *sorted_right = *right;\n    }\n    let mut res = vec![];\n    for\
    \ (left, right) in sorted_left_part.iter().zip(sorted_right_part.iter()) {\n \
    \       res.push(*left);\n        res.push(*right);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 2, 3, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpwy26ok4f.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even = l.clone();\n    let mut odd = l.clone();\n    even.retain(|x|\
    \ x % 2 == 0);\n    odd.retain(|x| x % 2 != 0);\n    even.sort();\n    odd.sort();\n\
    \    return merge(even, odd);\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `merge` in this scope\n  --> /tmp/tmpnx8txkla.rs:15:12\n\
    \   |\n15 |     return merge(even, odd);\n   |            ^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // This function splits the vec in two, sorts the even values and then appends\
    \ them.\n    let mut left = l.clone();\n    let mut right = l.clone();\n    left.sort();\n\
    \    right.sort();\n    // This is the tricky bit - we have to remove the odd\
    \ values.\n    let left_values: Vec<isize> = left.into_iter().filter(|x| x % 2\
    \ == 0).collect();\n    let right_values: Vec<isize> = right.into_iter().filter(|x|\
    \ x % 2 == 1).collect();\n    // We zip the values and then flatten them.\n  \
    \  left_values.into_iter().zip(right_values.into_iter()).flatten().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `(isize, isize)` is not an iterator\n    --> /tmp/tmpggpfvc18.rs:18:59\n\
    \     |\n18   |     left_values.into_iter().zip(right_values.into_iter()).flatten().collect()\n\
    \     |                                                           ^^^^^^^ `(isize,\
    \ isize)` is not an iterator\n     |\n     = help: the trait `Iterator` is not\
    \ implemented for `(isize, isize)`\n     = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `(isize, isize)`\nnote: required by a bound\
    \ in `flatten`\n\nerror[E0599]: the method `collect` exists for struct `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::vec::IntoIter<isize>>>`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmpggpfvc18.rs:18:69\n    |\n18  |       left_values.into_iter().zip(right_values.into_iter()).flatten().collect()\n\
    \    |                                                                       ^^^^^^^\
    \ method cannot be called on `Flatten<Zip<std::vec::IntoIter<isize>, std::vec::IntoIter<isize>>>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `<(isize, isize) as IntoIterator>::IntoIter\
    \ = _`\n            which is required by `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::vec::IntoIter<isize>>>: Iterator`\n            `<(isize, isize) as IntoIterator>::Item\
    \ = _`\n            which is required by `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::vec::IntoIter<isize>>>: Iterator`\n            `(isize, isize): IntoIterator`\n\
    \            which is required by `Flatten<Zip<std::vec::IntoIter<isize>, std::vec::IntoIter<isize>>>:\
    \ Iterator`\n            `Flatten<Zip<std::vec::IntoIter<isize>, std::vec::IntoIter<isize>>>:\
    \ Iterator`\n            which is required by `&mut Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::vec::IntoIter<isize>>>: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ return if l.len() == 0 {\n        l\n    } else {\n        let mut sorted =\
    \ l.clone();\n        let mut odd = vec![];\n        let mut even = vec![];\n\
    \        for i in 0..l.len() {\n            if i % 2 == 0 {\n                even.push(l[i]);\n\
    \            } else {\n                odd.push(l[i]);\n            }\n      \
    \  }\n        even.sort();\n        for i in 0..even.len() {\n            sorted[i\
    \ * 2] = even[i];\n        }\n        for i in 0..odd.len() {\n            sorted[i\
    \ * 2 + 1] = odd[i];\n        }\n        sorted\n    };\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    // do some work and return l\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5mg4pylb.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut ret: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        let\
    \ num = l[i];\n        if i % 2 == 0 {\n            ret.push(num);\n        }\
    \ else {\n            let even_vals: Vec<isize> = ret.iter().filter(|&x| x % 2\
    \ == 0).cloned().collect();\n            let mut even_vals_copy = even_vals.clone();\n\
    \            even_vals_copy.push(num);\n            even_vals_copy.sort();\n \
    \           let j = even_vals_copy.iter().position(|&x| x == num).unwrap();\n\
    \            for i in 0..even_vals.len() {\n                ret.push(even_vals_copy[i]);\n\
    \            }\n            ret.push(even_vals_copy[j]);\n        }\n    }\n \
    \   ret\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 2, 3, 9, 0, 2, 0, 123, 0, 0, 1, 2, 2, 1, -10]`,\n right:\
    \ `[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]`', /tmp/tmpwpukr6ui.rs:32:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let n = l.len();\n    let mut l1 = Vec::new();\n    let mut l2 = Vec::new();\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            l1.push(l[i]);\n  \
    \      } else {\n            l2.push(l[i]);\n        }\n    }\n    l1.sort();\n\
    \    let mut l3 = Vec::new();\n    for i in 0..n {\n        if i % 2 == 0 {\n\
    \            l3.push(l1[i/2]);\n        } else {\n            l3.push(l2[i/2]);\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    for i in (0..l.len()).filter(|i| i % 2 == 0) {\n       \
    \ for j in (i + 2..l.len()).filter(|j| j % 2 == 0) {\n            if l[i] > l[j]\
    \ {\n                l.swap(i, j);\n            }\n        }\n    }\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result = l.clone();\n    let mut index = 0;\n    while index < result.len()\
    \ {\n        let mut sub_vec = Vec::new();\n        let mut i = index;\n     \
    \   while i < result.len() && i % 2 == 0 {\n            sub_vec.push(result[i]);\n\
    \            i += 1;\n        }\n        sub_vec.sort();\n        for i in 0..sub_vec.len()\
    \ {\n            result[index + i] = sub_vec[i];\n        }\n        index +=\
    \ i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmppqt6o5z2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            result.push(l[i]);\n        } else {\n            let mut v\
    \ = Vec::new();\n            v.push(l[i]);\n            v.push(l[i - 1]);\n  \
    \          v.sort();\n            result.push(v[0]);\n            result.push(v[1]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp9qpwibvv.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut vec_prime = Vec::new();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            vec_prime.push(l[i]);\n        } else {\n            let\
    \ mut vec_copy = l.clone();\n            vec_copy.sort();\n            vec_prime.push(vec_copy[i]);\n\
    \        }\n    }\n    vec_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, -5, 0, -3, 2, 9, 3, 123, 9, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpt1kb21po.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut odd = Vec::new();\n    let mut even = Vec::new();\n    for (i, num)\
    \ in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odd.push(*num);\n\
    \        } else {\n            even.push(*num);\n        }\n    }\n    even.sort();\n\
    \    let mut result = Vec::new();\n    for i in 0..odd.len() {\n        result.push(odd[i]);\n\
    \        result.push(even[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpkfyd0ofl.rs:22:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_list = l.clone();\n    let evens: Vec<isize> = new_list.iter().enumerate().filter(|x|\
    \ x.0 % 2 == 0).map(|(_, x)| *x).collect();\n    let sorted_evens: Vec<isize>\
    \ = evens.clone().iter().enumerate().filter(|x| x.0 % 2 == 0).map(|(_, x)| *x).collect();\n\
    \    for (index, _) in new_list.iter().enumerate().filter(|x| x.0 % 2 == 0) {\n\
    \        new_list[index] = sorted_evens[index / 2];\n    }\n    new_list\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `new_list` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpg_gqlsf6.rs:13:9\n   |\n12 |     for (index, _)\
    \ in new_list.iter().enumerate().filter(|x| x.0 % 2 == 0) {\n   |            \
    \           ----------------------------------------------------\n   |       \
    \                |\n   |                       immutable borrow occurs here\n\
    \   |                       immutable borrow later used here\n13 |         new_list[index]\
    \ = sorted_evens[index / 2];\n   |         ^^^^^^^^ mutable borrow occurs here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even_indicies: Vec<isize> = vec![];\n    let mut odd_indicies: Vec<isize>\
    \ = vec![];\n    for (index, num) in l.iter().enumerate() {\n        if index\
    \ % 2 == 0 {\n            even_indicies.push(*num);\n        } else {\n      \
    \      odd_indicies.push(*num);\n        }\n    }\n    even_indicies.sort();\n\
    \    let mut sorted_l: Vec<isize> = vec![];\n    for (index, num) in l.iter().enumerate()\
    \ {\n        if index % 2 == 0 {\n            sorted_l.push(even_indicies.remove(0));\n\
    \        } else {\n            sorted_l.push(*num);\n        }\n    }\n    sorted_l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ //TODO: implement this function\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmppy3fe4cu.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ //l.len() is length, cap is capacity\n    let mut new_list: Vec<isize> = Vec::with_capacity(l.len());\n\
    \    //divide by 2 because that's how many values are in the even indicies\n \
    \   let mut even_values: Vec<isize> = Vec::with_capacity(l.len() / 2);\n    for\
    \ (index, value) in l.iter().enumerate() {\n        if index % 2 == 0 {\n    \
    \        new_list.push(*value);\n        } else {\n            even_values.push(*value);\n\
    \        }\n    }\n    //sort even_values\n    even_values.sort();\n    //add\
    \ the sorted even_values to the new_list\n    for value in even_values {\n   \
    \     new_list.push(value);\n    }\n    new_list\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpzr4f3n4b.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even_list = Vec::new();\n    let mut list = l.clone();\n    for i in\
    \ 0..list.len() {\n        if i % 2 == 0 {\n            even_list.push(list[i]);\n\
    \        }\n    }\n    even_list.sort();\n    let mut index = 0;\n    for i in\
    \ 0..list.len() {\n        if i % 2 == 0 {\n            list[i] = even_list[index];\n\
    \            index += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // TODO (optional)\n    // If the input vector l has 0 or 1 element, then l'\
    \ = l\n    // Otherwise, the even indicies of l' are sorted.\n    // The sorted\
    \ vector can be obtained by calling the sort function on an even-indexed\n   \
    \ // subslice of l.\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpe_j_yixx.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (index,\
    \ i) in l.iter().enumerate() {\n        if index % 2 == 0 {\n            odds.push(*i);\n\
    \        } else {\n            evens.push(*i);\n        }\n    }\n    evens.sort();\n\
    \    let mut sorted = Vec::new();\n    for (index, i) in l.iter().enumerate()\
    \ {\n        if index % 2 == 0 {\n            sorted.push(odds.pop().unwrap());\n\
    \        } else {\n            sorted.push(evens.pop().unwrap());\n        }\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmpb1606kzx.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut sorted = false;\n    while !sorted {\n \
    \       sorted = true;\n        for i in (0..(v.len() - 1)).step_by(2) {\n   \
    \         if v[i] > v[i + 1] {\n                sorted = false;\n            \
    \    v.swap(i, i + 1);\n            }\n        }\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpv6twrezi.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n\
    \    let mut result = Vec::new();\n    for (i, &x) in l.iter().enumerate() {\n\
    \        if i % 2 == 0 {\n            even.push(x);\n        } else {\n      \
    \      odd.push(x);\n        }\n    }\n    even.sort();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            result.push(even[i / 2]);\n        }\
    \ else {\n            result.push(odd[i / 2]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // Insert code here\n    let mut result = l.clone();\n    let len = result.len();\n\
    \    for i in 0..len {\n        let j = i + 1;\n        if j < len && j % 2 ==\
    \ 0 {\n            let mut temp = result[i];\n            result[i] = result[j];\n\
    \            result[j] = temp;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpun_pa5mr.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // TODO: Implement the function.\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 3]`', /tmp/tmp1bwqxmi1.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut evens = l.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_, &x)|\
    \ x).collect::<Vec<isize>>();\n    evens.sort();\n    let mut ans = vec![];\n\
    \    for (i, &x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n        \
    \    ans.push(evens.pop().unwrap());\n        } else {\n            ans.push(x);\n\
    \        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmpfsql8j02.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result = l.clone();\n    for idx in (0..result.len()).step_by(2) {\n\
    \        result[idx] = result[idx..].iter().min().unwrap().clone();\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 3, -10, 2, -10, 3, -10, 0, -10, 1, -10]`,\n right: `[-10, 3, -5, 2, -3,\
    \ 3, 5, 0, 9, 1, 123]`', /tmp/tmp9uggsw3n.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let even_indicies_length = even_indicies.len();\n    let\
    \ mut sorter = Vec::new();\n    for i in 0..even_indicies_length {\n        sorter.push(l[even_indicies[i]]);\n\
    \    }\n    sorter.sort();\n    for i in 0..even_indicies_length {\n        l_prime[even_indicies[i]]\
    \ = sorter[i];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // split the vec into two:\n    // one with the odd indicies and one with the\
    \ even indicies\n    let mut odd_indicies: Vec<isize> = vec![];\n    let mut even_indicies:\
    \ Vec<isize> = vec![];\n    let mut i = 0;\n    for element in l {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(element);\n        } else {\n \
    \           odd_indicies.push(element);\n        }\n        i += 1;\n    }\n \
    \   // sort the even indicies\n    even_indicies.sort();\n    // combine the two\
    \ vecs\n    let mut new_vec: Vec<isize> = vec![];\n    for element in even_indicies\
    \ {\n        new_vec.push(element);\n    }\n    for element in odd_indicies {\n\
    \        new_vec.push(element);\n    }\n    new_vec\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpkj00xo9x.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut l_even = l.iter().enumerate().filter(|&(i, _)| i\
    \ % 2 == 0).map(|(_, x)| *x).collect::<Vec<isize>>();\n    l_even.sort();\n  \
    \  for (i, v) in l_even.iter().enumerate() {\n        l[i * 2] = *v;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut vec = l.clone();\n    for i in (0..l.len()).step_by(2) {\n        for\
    \ j in (i..l.len()).step_by(2) {\n            if vec[i] > vec[j] {\n         \
    \       vec.swap(i, j);\n            }\n        }\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut odd: Vec<isize> = Vec::new();\n    let mut even: Vec<isize> = Vec::new();\n\
    \    for x in l {\n        if x % 2 == 0 {\n            even.push(x);\n      \
    \  } else {\n            odd.push(x);\n        }\n    }\n    even.sort();\n  \
    \  let mut k: Vec<isize> = Vec::new();\n    let mut j: isize = 0;\n    for x in\
    \ odd {\n        k.push(x);\n        k.push(even[j as usize]);\n        j += 1;\n\
    \    }\n    k\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmp0l1hhifh.rs:23:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut v_even = Vec::new();\n    let mut v_odd\
    \ = Vec::new();\n    let mut v_sorted = Vec::new();\n    for i in 0..v.len() {\n\
    \        if i % 2 == 0 {\n            v_even.push(v[i]);\n        } else {\n \
    \           v_odd.push(v[i]);\n        }\n    }\n    let v_even_sorted = v_even.clone();\n\
    \    v_even_sorted.sort();\n    for i in 0..v_even.len() {\n        v_sorted.push(v_even_sorted[i]);\n\
    \        v_sorted.push(v_odd[i]);\n    }\n    return v_sorted;\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpjeokxw1z.rs:9:9\n\
    \  |\n9 |     let mut v = l.clone();\n  |         ----^\n  |         |\n  |  \
    \       help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0596]: cannot borrow `v_even_sorted` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpjeokxw1z.rs:21:5\n   |\n20 |     let v_even_sorted\
    \ = v_even.clone();\n   |         ------------- help: consider changing this to\
    \ be mutable: `mut v_even_sorted`\n21 |     v_even_sorted.sort();\n   |     ^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut list = l;\n    for i in 0..list.len() {\n        if i % 2 == 0 {\n \
    \           let mut odd_list = vec![];\n            for j in 0..list.len() {\n\
    \                if j % 2 != 0 {\n                    odd_list.push(list[j]);\n\
    \                }\n            }\n            odd_list.sort();\n            let\
    \ mut odd_index = 0;\n            for k in 0..list.len() {\n                if\
    \ k % 2 != 0 {\n                    list[k] = odd_list[odd_index];\n         \
    \           odd_index += 1;\n                }\n            }\n        }\n   \
    \ }\n    list\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpbpqj_r5z.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // This is an incomplete function; you need to write the rest of it!\n    let\
    \ mut o = l.clone();\n    for i in 1..l.len() {\n        if i % 2 == 0 {\n   \
    \         for j in 1..i {\n                if i % 2 == 0 && l[j] > l[i] {\n  \
    \                  let temp = l[i];\n                    o[i] = l[j];\n      \
    \              o[j] = temp;\n                }\n            }\n        }\n   \
    \ }\n    o\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -10, -10, -10, -10, -10, -10, -10, -10, 1]`,\n right: `[-10, 3, -5,\
    \ 2, -3, 3, 5, 0, 9, 1, 123]`', /tmp/tmp3cdkbes7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_l = Vec::new();\n    let mut even_l = Vec::new();\n    for (index,\
    \ element) in l.iter().enumerate() {\n        if index % 2 == 0 {\n          \
    \  new_l.push(*element);\n        } else {\n            even_l.push(*element);\n\
    \        }\n    }\n    even_l.sort();\n    for (index, element) in even_l.iter().enumerate()\
    \ {\n        new_l.insert(index * 2 + 1, *element);\n    }\n    new_l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpz1lhemvl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut i = 0;\n    while i < v.len() {\n      \
    \  let mut j = i;\n        while j + 1 < v.len() && j % 2 == 0 {\n           \
    \ if v[j] > v[j + 1] {\n                let temp = v[j];\n                v[j]\
    \ = v[j + 1];\n                v[j + 1] = temp;\n            }\n            j\
    \ += 2;\n        }\n        i += 1;\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpdedby3ne.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    for i in (0..v.len()).step_by(2) {\n        for\
    \ j in (i+2..v.len()).step_by(2) {\n            if v[i] > v[j] {\n           \
    \     let temp = v[i];\n                v[i] = v[j];\n                v[j] = temp;\n\
    \            }\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l2 = l.clone();\n    for i in 1..l.len() {\n        if i % 2 == 0 {\n\
    \            l2[i] = l[i];\n        }\n    }\n    let mut l3 = l2.clone();\n \
    \   for i in 1..l2.len() {\n        if i % 2 == 0 {\n            l3[i] = l2[i\
    \ - 1];\n        }\n    }\n    let mut l4 = l3.clone();\n    for i in 1..l3.len()\
    \ {\n        if i % 2 == 0 {\n            l4[i] = l3[i + 1];\n        }\n    }\n\
    \    let mut l5 = l4.clone();\n    for i in 1..l4.len() {\n        if i % 2 ==\
    \ 0 {\n            l5[i] = l4[i - 1];\n        }\n    }\n    l5\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp2_3e1fvl.rs:24:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976053
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = l.clone();\n    let mut count = 0;\n    let mut evens: Vec<isize>\
    \ = Vec::new();\n    while count < new_vec.len() {\n        if count % 2 == 0\
    \ {\n            evens.push(new_vec[count]);\n        }\n        count += 1;\n\
    \    }\n    evens.sort();\n    count = 0;\n    while count < new_vec.len() {\n\
    \        if count % 2 == 0 {\n            new_vec[count] = evens[count / 2];\n\
    \        }\n        count += 1;\n    }\n    new_vec\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut l1 = l.clone();\n    l1.sort();\n    l.iter().enumerate().map(|(i,\
    \ &x)| if i % 2 == 0 { l1[i / 2] } else { x }).collect()\n}\n\nfn main() {\n \
    \   let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpuco4orl4.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l2 = l.clone();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            l2[i] = l[i];\n        } else {\n            let min = min_even(l2.clone());\n\
    \            l2[i] = min;\n        }\n    }\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min_even` in this scope\n  --> /tmp/tmp5lh2ew8x.rs:14:23\n\
    \   |\n14 |             let min = min_even(l2.clone());\n   |                \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    // This loop goes from indices 0 to the second to last\n\
    \    for i in 0..l.len() - 1 {\n        // If i is even\n        if i % 2 == 0\
    \ {\n            // Then if the i'th element is greater than the (i+1)'th element\n\
    \            if l[i] > l[i + 1] {\n                // Then swap them\n       \
    \         let temp = l[i];\n                l[i] = l[i + 1];\n               \
    \ l[i + 1] = temp;\n            }\n        }\n    }\n    // Return the resulting\
    \ list\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpgapwbp7z.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted = l.clone();\n    sorted.sort();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            sorted[i] = l[i];\n        }\n    }\n  \
    \  sorted\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, -5, 0, -3, 2, 9, 3, 123, 9, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmplj8v009o.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut temp_vec = Vec::new();\n    for (i, j) in l.iter().enumerate() {\n \
    \       if i % 2 == 0 {\n            temp_vec.push(*j);\n        }\n    }\n  \
    \  temp_vec.sort();\n    for (i, j) in l.iter().enumerate() {\n        if i %\
    \ 2 == 0 {\n            *temp_vec.get_mut(i / 2).unwrap() = *j;\n        }\n \
    \   }\n    temp_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp_1akebii.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut sorted = false;\n    while !sorted {\n        sorted\
    \ = true;\n        for i in 1..l.len() {\n            if i % 2 == 0 && l[i] <\
    \ l[i - 1] {\n                l.swap(i, i - 1);\n                sorted = false;\n\
    \            }\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, 3, -3, 2, 3, 9, 0, 123, -10, 1]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpote9tgsi.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // We need to create a vector to store the sorted vector in.\n    let mut sorted_vector\
    \ = vec![];\n    // We need to create a vector to store the odd indicies of the\
    \ vector in.\n    let mut odd_indicies = vec![];\n    // We need to create a vector\
    \ to store the even indicies of the vector in.\n    let mut even_indicies = vec![];\n\
    \    // This is the counter we will use to check if the index is even or odd.\n\
    \    let mut counter = 0;\n    // We need to iterate through the vector to find\
    \ the even and odd indicies.\n    for num in l {\n        if counter % 2 == 0\
    \ {\n            even_indicies.push(num);\n        } else {\n            odd_indicies.push(num);\n\
    \        }\n        counter += 1;\n    }\n    // We want to sort the even indicies.\n\
    \    even_indicies.sort();\n    // We want to add the odd indicies to the empty\
    \ vector we created.\n    sorted_vector.extend(odd_indicies);\n    // We want\
    \ to add the even indicies to the empty vector we created.\n    sorted_vector.extend(even_indicies);\n\
    \    sorted_vector\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpb9bzsbsw.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n\tlet\
    \ mut out = l.clone();\n\tlet mut even_idx = 0;\n\tfor i in (0..l.len()).step_by(2)\
    \ {\n\t\tout[i] = {\n\t\t\tlet mut temp = l[i..l.len()].to_vec();\n\t\t\ttemp.sort();\n\
    \t\t\ttemp[even_idx]\n\t\t};\n\t\teven_idx += 1;\n\t}\n\tout\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpon0s_w3d.rs:15:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l1 = l.clone();\n    let mut l2 = l.clone();\n    l1.sort();\n    let\
    \ len = l1.len();\n    for i in (0..len).step_by(2) {\n        l2[i] = l1[i];\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 3, -3, 2, 1, 3, 3, 0, 5, 1, 123]`,\n right: `[-10, 3, -5, 2, -3, 3, 5,\
    \ 0, 9, 1, 123]`', /tmp/tmpdbu7dqfp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ // use l.len() to get the length of the vector\n    // use l.get(i) to get an\
    \ element at index i.\n    // use l.iter() to iterate over the vector\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmplt3oxa8_.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ l.iter().enumerate().fold(vec![], |mut acc, (i, &x)| {\n        if i % 2 ==\
    \ 0 {\n            acc.push(x);\n        } else {\n            acc.insert(i -\
    \ 1, x);\n            acc.sort();\n        }\n        acc\n    })\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 2, 3, 3, 5, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp1gl6dwtl.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_new = l.clone();\n    for i in 1..l.len() {\n        if i % 2 == 0\
    \ {\n            l_new[i] = l[i - 1];\n        }\n    }\n    l_new\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpykj11f0c.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    for i in 0..v.len() {\n        if i % 2 == 0 {\n\
    \            v[i] = v[i+1];\n        }\n    }\n    for i in 0..v.len() {\n   \
    \     if i % 2 == 0 {\n            for j in i+1..v.len() {\n                if\
    \ v[j] < v[i] {\n                    let temp = v[i];\n                    v[i]\
    \ = v[j];\n                    v[j] = temp;\n                }\n            }\n\
    \        }\n    }\n    return v;\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpk2pf90sm.rs:12:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976054
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_l = l.clone();\n    let mut new_l_evens: Vec<isize> = Vec::new();\n\
    \    for i in 0..new_l.len() {\n        if i % 2 == 0 {\n            new_l_evens.push(new_l[i]);\n\
    \        }\n    }\n    new_l_evens.sort();\n    for i in 0..new_l.len() {\n  \
    \      if i % 2 == 0 {\n            new_l[i] = new_l_evens[i/2];\n        }\n\
    \    }\n    new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976054
- exit_code: 0
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = l.clone();\n    // new_vec.iter_mut().enumerate().filter(|(i,\
    \ _)| i % 2 == 0).sort();\n    let mut i = 0;\n    while i < new_vec.len() {\n\
    \        if i % 2 == 0 {\n            let mut temp = new_vec[i];\n           \
    \ let mut j = i + 1;\n            while j < new_vec.len() {\n                if\
    \ j % 2 == 0 {\n                    if new_vec[j] < temp {\n                 \
    \       new_vec[i] = new_vec[j];\n                        new_vec[j] = temp;\n\
    \                        temp = new_vec[i];\n                    }\n         \
    \       }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976054
