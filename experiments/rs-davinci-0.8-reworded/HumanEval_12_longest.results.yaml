language: rs
name: HumanEval_12_longest
results:
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut current_longest = None;\n    for s in strings {\n        if current_longest.is_none()\
    \ || s.len() > current_longest.unwrap().len() {\n            current_longest =\
    \ Some(s);\n        }\n    }\n    current_longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpdg_e3lbw.rs:12:67\n\
    \   |\n10 |     let mut current_longest = None;\n   |         -------------------\
    \ consider giving `current_longest` the explicit type `Option<T>`, where the type\
    \ parameter `T` is specified\n11 |     for s in strings {\n12 |         if current_longest.is_none()\
    \ || s.len() > current_longest.unwrap().len() {\n   |                        \
    \                                           ^^^^^^ cannot infer type for type\
    \ parameter `T`\n   |\n   = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = usize::min_value();\n    let mut max_len_idx = usize::min_value();\n    for\
    \ (idx, string) in strings.iter().enumerate() {\n        if string.len() > max_len\
    \ {\n            max_len = string.len();\n            max_len_idx = idx;\n   \
    \     }\n    }\n    return Some(strings[max_len_idx].clone());\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    // TODO: return\
    \ the longest string\n    let mut longest = &strings[0];\n    for string in &strings\
    \ {\n        if string.len() > longest.len() {\n            longest = string;\n\
    \        }\n    }\n    Some(longest.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    // This won't\
    \ work. `maximum` is never evaluated, because\n    // it is not used by the code.\n\
    \    // let maximum = strings.iter().max_by_key(|s| s.len());\n    // So we need\
    \ to do this:\n    let mut maximum = strings[0].clone();\n    for s in strings\
    \ {\n        if s.len() > maximum.len() {\n            maximum = s;\n        }\n\
    \    }\n    Some(maximum)\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| match acc {\n        None =>\
    \ Some(s),\n        Some(acc) => Some(match s.len().cmp(&acc.len()) {\n      \
    \      Ordering::Greater => s,\n            _ => acc,\n        }),\n    })\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpw5qpi2u4.rs:13:13\n   |\n13 |             Ordering::Greater => s,\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp86msuqov.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut strings = strings;\n    match strings.len() {\n        0 => None,\n\
    \        _ => {\n            let mut longest = strings.remove(0);\n          \
    \  for string in strings {\n                if string.len() > longest.len() {\n\
    \                    longest = string;\n                }\n            }\n   \
    \         Some(longest)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        longest = match\
    \ longest {\n            None => Some(s),\n            Some(ref current) => {\n\
    \                if s.len() > current.len() {\n                    Some(s)\n \
    \               } else {\n                    Some(current.clone())\n        \
    \        }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = String::from(\"\");\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4rt1wd2q.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // ...\n    None\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpgtcmyego.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.iter().max_by_key(|x| x.len()) {\n        Some(s) => Some(s.to_string()),\n\
    \        None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpfoahz0ib.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmplow9an02.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max().map(|x| x.to_string())\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpc0j68su0.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string: Option<String> = None;\n    for s in strings\
    \ {\n        longest_string = match longest_string {\n            None => Some(s),\n\
    \            Some(ref current_longest) => {\n                if s.len() > current_longest.len()\
    \ {\n                    Some(s)\n                } else {\n                 \
    \   Some(current_longest.clone())\n                }\n            }\n        }\n\
    \    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut cur) =>\
    \ {\n                if s.len() > cur.len() {\n                    *cur = s;\n\
    \                }\n            }\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // if strings.len() == 0 {\n    //     return None;\n    // }\n    //\
    \ let mut length = 0;\n    // let mut longest = &strings[0];\n    // for s in\
    \ strings {\n    //     if s.len() > length {\n    //         length = s.len();\n\
    \    //         longest = &s;\n    //     }\n    // }\n    // Some(String::from(longest))\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpgds0l61f.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_idx = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_idx = i;\n        }\n    }\n    match max_len {\n        0 => None,\n\
    \        _ => Some(strings[max_idx].clone()),\n    }\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > max.len() {\n            max = string;\n        }\n    }\n    Some(max)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut longest_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            longest_string = Some(string);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut ret\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > ret.len() {\n\
    \            ret = s;\n        }\n    }\n    Some(ret.clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = String::new();\n    for\
    \ s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_string = s;\n        }\n    }\n    if max_len == 0 {\n      \
    \  None\n    } else {\n        Some(max_string)\n    }\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max = 0;\n    let mut index = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max {\n            max = s.len();\n            index\
    \ = i;\n        }\n    }\n    if strings.is_empty() {\n        None\n    } else\
    \ {\n        Some(strings[index].clone())\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = 0;\n    let mut max_idx = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_idx = i;\n        }\n    }\n    return Some(strings[max_idx].clone());\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_string\
    \ = String::from(&strings[0]);\n    for string in strings {\n        if string.len()\
    \ > longest_string.len() {\n            longest_string = string;\n        }\n\
    \    }\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut strings = strings;\n    if strings.is_empty() {\n        return\
    \ None;\n    }\n    strings.sort_by(|a, b| b.len().cmp(&a.len()));\n    Some(strings[0].clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|x| x.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpmf9a44_e.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|x| x.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = None;\n    for s in strings {\n        if let\
    \ Some(longest) = longest_string {\n            if s.len() > longest.len() {\n\
    \                longest_string = Some(s);\n            }\n        } else {\n\
    \            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpdt4_3cn1.rs:13:26\n\
    \   |\n10 |     let mut longest_string = None;\n   |         ------------------\
    \ consider giving `longest_string` the explicit type `Option<T>`, with the type\
    \ parameters specified\n...\n13 |             if s.len() > longest.len() {\n \
    \  |                          ^^^^^^^ cannot infer type\n   |\n   = note: type\
    \ must be known at this point\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| match acc {\n        None =>\
    \ Some(s),\n        Some(acc) => Some(if acc.len() > s.len() { acc } else { s\
    \ }),\n    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpnku1hqvr.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut long_str = String::new();\n    for s in strings {\n        if\
    \ s.len() > long_str.len() {\n            long_str = s;\n        }\n    }\n  \
    \  if long_str.len() > 0 {\n        Some(long_str)\n    } else {\n        None\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut output: Option<String> = None;\n    for string in strings {\n\
    \        match output {\n            None => output = Some(string),\n        \
    \    Some(curr_max) => {\n                if string.len() > curr_max.len() {\n\
    \                    output = Some(string);\n                }\n            }\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmpjxnxr22v.rs:14:18\n   |\n\
    14 |             Some(curr_max) => {\n   |                  ^^^^^^^^ value moved\
    \ here, in previous iteration of loop\n   |\nnote: these 2 reinitializations might\
    \ get skipped\n  --> /tmp/tmpjxnxr22v.rs:13:21\n   |\n13 |             None =>\
    \ output = Some(string),\n   |                     ^^^^^^\n...\n16 |         \
    \            output = Some(string);\n   |                     ^^^^^^\n   = note:\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_index = 0;\n    for (index, str)\
    \ in strings.iter().enumerate() {\n        if str.len() > max_len {\n        \
    \    max_len = str.len();\n            max_index = index;\n        }\n    }\n\
    \    if max_len == 0 {\n        None\n    } else {\n        Some(strings[max_index].clone())\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // This is a simple `match` statement that looks at three cases:\n  \
    \  //   1. If the vector is empty, it returns None\n    //   2. If the vector\
    \ has one element, it returns it without further processing\n    //   3. If the\
    \ vector has more than one element, it looks at the first and the rest of the\n\
    \    //      vector and returns whichever one is longest.\n    match strings.len()\
    \ {\n        0 => None,\n        1 => Some(strings[0].clone()),\n        _ =>\
    \ {\n            let mut tail = strings.clone();\n            let head = tail.remove(0);\n\
    \            let head_len = head.len();\n            match longest(tail) {\n \
    \               None => Some(head),\n                Some(s) => {\n          \
    \          if head_len > s.len() {\n                        Some(head)\n     \
    \               } else {\n                        Some(s)\n                  \
    \  }\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpm2i_qmcw.rs:39:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string: Option<String> = None;\n    for s in strings\
    \ {\n        if longest_string.is_none() || s.len() > longest_string.as_ref().unwrap().len()\
    \ {\n            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| {\n        match acc {\n    \
    \        None => Some(s),\n            Some(acc_string) => if acc_string.len()\
    \ < s.len() {\n                Some(s)\n            } else {\n               \
    \ Some(acc_string)\n            }\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut iter = strings.iter();\n    let mut longest = match iter.next()\
    \ {\n        Some(string) => string,\n        None => return None,\n    };\n \
    \   for s in iter {\n        if s.len() > longest.len() {\n            longest\
    \ = s;\n        }\n    }\n    Some(String::from(longest))\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = strings[0].len();\n    let mut result = strings[0].clone();\n    for s in\
    \ strings.iter() {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            result = s.clone();\n        }\n    }\n    Some(result)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_string\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n    Some(longest_string.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut current)\
    \ => {\n                if string.len() > current.len() {\n                  \
    \  *current = string;\n                }\n            }\n        }\n    }\n  \
    \  longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // this is what i did\n    // let mut lengths = Vec::new();\n    // for\
    \ s in strings {\n    //     lengths.push(s.len());\n    // }\n    // let max_length\
    \ = lengths.iter().max();\n    // if let Some(max_length) = max_length {\n   \
    \ //     Some(strings[lengths.iter().position(|i| i == max_length).unwrap()].clone())\n\
    \    // } else {\n    //     None\n    // }\n\n    // this is how i could have\
    \ done it\n    let mut max_length = 0;\n    let mut max_idx = 0;\n    for (idx,\
    \ s) in strings.iter().enumerate() {\n        if s.len() > max_length {\n    \
    \        max_length = s.len();\n            max_idx = idx;\n        }\n    }\n\
    \    if max_length == 0 {\n        None\n    } else {\n        Some(strings[max_idx].clone())\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = 0;\n    let mut index = 0;\n    for (i, s) in strings.iter().enumerate() {\n\
    \        if s.len() > max_len {\n            max_len = s.len();\n            index\
    \ = i;\n        }\n    }\n    Some(strings[index].clone())\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |longest, s| {\n        match longest\
    \ {\n            None => Some(s),\n            Some(l) => {\n                if\
    \ l.len() > s.len() {\n                    Some(l)\n                } else {\n\
    \                    Some(s)\n                }\n            }\n        }\n  \
    \  })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpnbfzty68.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_length {\n            max_length\
    \ = string.len();\n            max_string = Some(string);\n        }\n    }\n\
    \    max_string\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > max.len() {\n\
    \            max = s;\n        }\n    }\n    Some(max.clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_len = 0;\n    let mut longest_str = String::new();\n\
    \    for string in strings {\n        if string.len() > longest_len {\n      \
    \      longest_len = string.len();\n            longest_str = string;\n      \
    \  }\n    }\n    if longest_len == 0 {\n        None\n    } else {\n        Some(longest_str)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    strings.iter().max_by_key(|s|\
    \ s.len()).cloned()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp7vs_1w6e.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // add code here\n    let mut max = 0;\n    let mut longest_string =\
    \ String::new();\n    for s in strings {\n        if s.len() > max {\n       \
    \     max = s.len();\n            longest_string = s;\n        }\n    }\n    if\
    \ max > 0 {\n        Some(longest_string)\n    } else {\n        None\n    }\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.is_empty() {\n        true => None,\n        false => {\n\
    \            let mut longest = &strings[0];\n            for s in &strings {\n\
    \                if s.len() > longest.len() {\n                    longest = s;\n\
    \                }\n            }\n            Some(longest.to_string())\n   \
    \     }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|string| string.len()).map(|string| string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpfnalyb_h.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = 0;\n    let mut max_str = String::new();\n    for s in strings {\n       \
    \ if s.len() > max_len {\n            max_len = s.len();\n            max_str\
    \ = s;\n        }\n    }\n    Some(max_str)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.iter().max_by_key(|s| s.len()) {\n        Some(s) => Some(s.to_string()),\n\
    \        None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpz45emm1j.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_idx = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_idx = i;\n        }\n    }\n    if max_len == 0 {\n        None\n   \
    \ } else {\n        Some(strings[max_idx].clone())\n    }\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmplow9an02.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let len = strings.len();\n    if len == 0 {\n        return None;\n \
    \   }\n    let mut max_size = 0;\n    let mut max_size_index = 0;\n    for i in\
    \ 0..len {\n        let s = &strings[i];\n        if s.len() > max_size {\n  \
    \          max_size = s.len();\n            max_size_index = i;\n        }\n \
    \   }\n    Some(strings[max_size_index].clone())\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.len() {\n        0 => None,\n        _ => {\n         \
    \   let mut max = strings[0].clone();\n            for i in 1..strings.len() {\n\
    \                if strings[i].len() > max.len() {\n                    max =\
    \ strings[i].clone();\n                }\n            }\n            Some(max)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |current, next| {\n        if let Some(ref\
    \ current) = current {\n            if current.len() >= next.len() {\n       \
    \         Some(current.clone())\n            } else {\n                Some(next)\n\
    \            }\n        } else {\n            Some(next)\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_length\
    \ = 0;\n    let mut longest_string = String::new();\n    for s in strings {\n\
    \        if s.len() > max_length {\n            max_length = s.len();\n      \
    \      longest_string = s;\n        }\n    }\n    Some(longest_string)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut max_str: String = strings[0].clone();\n \
    \           for str in strings.iter() {\n                if str.len() > max_str.len()\
    \ {\n                    max_str = str.clone();\n                }\n         \
    \   }\n            Some(max_str)\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |max, string| {\n        match max {\n\
    \            None => Some(string),\n            Some(s) => if s.len() < string.len()\
    \ {\n                Some(string)\n            } else {\n                Some(s)\n\
    \            }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = strings[0].len();\n    let mut longest_string = &strings[0];\n    for s in\
    \ &strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            longest_string = s;\n        }\n    }\n    Some(longest_string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = None;\n    let mut max_len = 0;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    result = Some(s);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > max.len() {\n\
    \            max = s;\n        }\n    }\n    Some(max.clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        if longest.is_none()\
    \ || longest.as_ref().unwrap().len() < s.len() {\n            longest = Some(s);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpobxek0bz.rs:12:41\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for s in strings {\n12 |         if longest.is_none() || longest.as_ref().unwrap().len()\
    \ < s.len() {\n   |                                         ^^^^^^ cannot infer\
    \ type for type parameter `T`\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |longest, string| {\n        match longest\
    \ {\n            None => Some(string),\n            Some(ref longest) => if string.len()\
    \ > longest.len() {\n                Some(string)\n            } else {\n    \
    \            Some(longest.clone())\n            }\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut longest_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |max, s| {\n        match max {\n    \
    \        None => Some(s),\n            Some(ref m) => if s.len() > m.len() { Some(s)\
    \ } else { max }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = None;\n    for string in strings {\n        match result\
    \ {\n            None => result = Some(string),\n            Some(ref s) => if\
    \ string.len() > s.len() {\n                result = Some(string);\n         \
    \   },\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut m = None;\n    for s in strings {\n        m = match m {\n  \
    \          None => Some(s),\n            Some(x) => if x.len() > s.len() {\n \
    \               Some(x)\n            } else {\n                Some(s)\n     \
    \       }\n        }\n    }\n    m\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpfmd_org1.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => {\n  \
    \              if s.len() > l.len() {\n                    longest = Some(s);\n\
    \                }\n            }\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_len_string = Some(string);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // TODO: implement this function\n    if strings.is_empty() {\n     \
    \   return None;\n    }\n    let mut max_length = 0;\n    let mut max_index =\
    \ 0;\n    for (index, string) in strings.iter().enumerate() {\n        if string.len()\
    \ > max_length {\n            max_length = string.len();\n            max_index\
    \ = index;\n        }\n    }\n    Some(strings[max_index].clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.iter().max_by_key(|s| s.len()) {\n        Some(s) => Some(s.to_string()),\n\
    \        None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpz45emm1j.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut res = None;\n    let mut longest_len = 0;\n    for string in\
    \ strings {\n        if string.len() > longest_len {\n            res = Some(string);\n\
    \            longest_len = string.len();\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmp8ny9arg_.rs:15:27\n\
    \   |\n12 |     for string in strings {\n   |         ------ move occurs because\
    \ `string` has type `String`, which does not implement the `Copy` trait\n13 |\
    \         if string.len() > longest_len {\n14 |             res = Some(string);\n\
    \   |                        ------ value moved here\n15 |             longest_len\
    \ = string.len();\n   |                           ^^^^^^^^^^^^ value borrowed\
    \ here after move\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max\
    \ = 0;\n    let mut longest = &strings[0];\n    for s in &strings {\n        if\
    \ s.len() > max {\n            max = s.len();\n            longest = s;\n    \
    \    }\n    }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |longest, string| {\n        match longest\
    \ {\n            None => Some(string),\n            Some(ref long) => {\n    \
    \            if long.len() < string.len() {\n                    Some(string)\n\
    \                } else {\n                    Some(long.clone())\n          \
    \      }\n            }\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut result\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > result.len()\
    \ {\n            result = s;\n        }\n    }\n    Some(result)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut result\
    \ = strings[0].clone();\n    for i in 1..strings.len() {\n        if strings[i].len()\
    \ > result.len() {\n            result = strings[i].clone();\n        }\n    }\n\
    \    Some(result)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| match acc {\n        None =>\
    \ Some(s),\n        Some(s1) => {\n            if s.len() > s1.len() {\n     \
    \           Some(s)\n            } else {\n                Some(s1)\n        \
    \    }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp86msuqov.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.len() {\n        0 => None,\n        n => {\n         \
    \   let mut max_idx = 0;\n            for (i, string) in strings.iter().enumerate()\
    \ {\n                if string.len() > strings[max_idx].len() {\n            \
    \        max_idx = i;\n                }\n            }\n            Some(strings[max_idx].clone())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut result\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > result.len()\
    \ {\n            result = s;\n        }\n    }\n    Some(result)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut res = None;\n    for s in strings {\n\
    \        if s.len() > max_len {\n            max_len = s.len();\n            res\
    \ = Some(s);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max\
    \ = &strings[0];\n    for i in &strings {\n        if i.len() > max.len() {\n\
    \            max = i;\n        }\n    }\n    Some(max.clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|string| string.len()).map(|string| string.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpmq2_4z0m.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_string\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n    Some(longest_string.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut longest_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp86msuqov.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = &String::from(\"\");\n    for s in strings {\n    \
    \    if s.len() > longest.len() {\n            longest = &s;\n        }\n    }\n\
    \    if longest.len() == 0 {\n        None\n    } else {\n        Some(String::from(longest))\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `s` does not live long enough\n  --> /tmp/tmp2uceuzm4.rs:13:23\n\
    \   |\n12 |         if s.len() > longest.len() {\n   |                      -------------\
    \ borrow later used here\n13 |             longest = &s;\n   |               \
    \        ^^ borrowed value does not live long enough\n14 |         }\n15 |   \
    \  }\n   |     - `s` dropped here while still borrowed\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0597`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut strings = strings;\n            strings.sort_by(|a,\
    \ b| b.len().cmp(&a.len()));\n            Some(strings[0].clone())\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4rt1wd2q.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_string: Option<String> = None;\n    let mut max_len = 0;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_string\
    \ = Some(s);\n            max_len = s.len();\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp3x62diz2.rs:15:23\n\
    \   |\n12 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n13 |         if s.len()\
    \ > max_len {\n14 |             max_string = Some(s);\n   |                  \
    \             - value moved here\n15 |             max_len = s.len();\n   |  \
    \                     ^^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp86msuqov.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_length\
    \ = strings[0].len();\n    let mut max_string = strings[0].clone();\n    for (i,\
    \ string) in strings.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        if string.len() > max_length {\n            max_length = string.len();\n\
    \            max_string = string.clone();\n        }\n    }\n    Some(max_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // The implementation is intentionally left blank.\n    let mut longest_string:\
    \ Option<String> = None;\n    for string in strings {\n        let current_longest\
    \ = match longest_string {\n            Some(ref s) => s.len(),\n            None\
    \ => 0,\n        };\n        if string.len() > current_longest {\n           \
    \ longest_string = Some(string);\n        }\n    }\n    longest_string\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_length {\n            max_length = s.len();\n\
    \            max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max = 0;\n    let mut longest = None;\n    for string in strings\
    \ {\n        if string.len() > max {\n            max = string.len();\n      \
    \      longest = Some(string);\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // (1)\n    // strings.iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    \    // (2)\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpkabjkuxh.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.first() {\n        Some(s) => strings.iter().fold(s.clone(),\
    \ |m, s| if s.len() > m.len() { s.clone() } else { m }),\n        None => None,\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz43a0wot.rs:11:40\n   |\n\
    11 |         Some(s) => strings.iter().fold(s.clone(), |m, s| if s.len() > m.len()\
    \ { s.clone() } else { m }),\n   |                                        ^^^^^^^^^\
    \ expected enum `Option`, found struct `String`\n   |\n   = note: expected enum\
    \ `Option<String>`\n            found struct `String`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n11 |         Some(s) => strings.iter().fold(Some(s.clone()),\
    \ |m, s| if s.len() > m.len() { s.clone() } else { m }),\n   |               \
    \                         +++++         +\n\nerror[E0599]: no method named `len`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpz43a0wot.rs:11:73\n\
    \   |\n11 |         Some(s) => strings.iter().fold(s.clone(), |m, s| if s.len()\
    \ > m.len() { s.clone() } else { m }),\n   |                                 \
    \                                        ^^^ method not found in `Option<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz43a0wot.rs:11:81\n   |\n11 |\
    \         Some(s) => strings.iter().fold(s.clone(), |m, s| if s.len() > m.len()\
    \ { s.clone() } else { m }),\n   |                                           \
    \                                      ^^^^^^^^^ expected enum `Option`, found\
    \ struct `String`\n   |\n   = note: expected enum `Option<String>`\n         \
    \   found struct `String`\nhelp: try wrapping the expression in `Some`\n   |\n\
    11 |         Some(s) => strings.iter().fold(s.clone(), |m, s| if s.len() > m.len()\
    \ { Some(s.clone()) } else { m }),\n   |                                     \
    \                                            +++++         +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_len_str = Some(s);\n        }\n    }\n    max_len_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |mut longest, s| {\n        if let Some(l)\
    \ = longest {\n            if s.len() > l.len() {\n                longest = Some(s);\n\
    \            }\n        } else {\n            longest = Some(s);\n        }\n\
    \        longest\n    })\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of partially moved value: `longest`\n  --> /tmp/tmp1u354l1n.rs:18:9\n\
    \   |\n11 |         if let Some(l) = longest {\n   |                     - value\
    \ partially moved here\n12 |             if s.len() > l.len() {\n13 |        \
    \         longest = Some(s);\n   |                 ------- this reinitialization\
    \ might get skipped\n...\n18 |         longest\n   |         ^^^^^^^ value used\
    \ here after partial move\n   |\n   = note: partial move occurs because value\
    \ has type `String`, which does not implement the `Copy` trait\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = String::new();\n    for string in strings {\n\
    \        if string.len() > longest_string.len() {\n            longest_string\
    \ = string;\n        }\n    }\n    match longest_string.len() {\n        0 =>\
    \ None,\n        _ => Some(longest_string),\n    }\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut longest = None;\n    for string in\
    \ strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            longest = Some(string);\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut current_longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > current_longest.len() {\n            current_longest = string.clone();\n \
    \       }\n    }\n    Some(current_longest)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut longest = None;\n    for s in strings\
    \ {\n        if s.len() > max_length {\n            max_length = s.len();\n  \
    \          longest = Some(s);\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut ret\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > ret.len()\
    \ {\n            ret = s.clone();\n        }\n    }\n    Some(ret)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // `max` is a function of iterator traits. It will iterate through the\
    \ input list and \n    // return the greatest element.\n    // `max` takes a function,\
    \ which takes two elements and returns the greatest element.\n    // `max` will\
    \ take the first two element from the list, call the function to get the largest\n\
    \    // of the two, and store that as the max. Then it will call the function\
    \ again to compare the\n    // current max and the next element of the list.\n\
    \    // In this case, the function is `|a, b| a.len() < b.len()`, which takes\
    \ two strings and return \n    // the length of the longer one.\n    // This is\
    \ called a closure. It's a function that doesn't have a name or have to be defined\n\
    \    // elsewhere. It is an inline function.\n    // We can define this closure\
    \ as a variable and pass it to `max` instead.\n    // The most important thing\
    \ is to make sure the closure *captures* its environment.\n    // Let's see an\
    \ example of what happens if the closure doesn't capture its environment:\n  \
    \  //\n    // fn main() {\n    //     let n = 10;\n    //     let s = max(strings,\
    \ |a, b| a.len() < b.len());\n    // }\n    //\n    // fn max<T>(strings: Vec<T>,\
    \ closure: &Fn(T, T) -> T) -> Option<T> {\n    //     strings.iter().max().map(|s|\
    \ s.clone())\n    // }\n    //\n    // Here the parameter of the closure is `&T`,\
    \ which means the closure takes references to\n    // elements of the vector.\
    \ The closure will try to dereference `s`, which is also a reference,\n    //\
    \ and return the dereferenced element.\n    // However, `s` is a *mutable* reference,\
    \ and we can't dereference it. Here is a different error:\n    //\n    // error[E0506]:\
    \ cannot assign to `s` because it is borrowed\n    //  --> src/main.rs:7:9\n \
    \   //   |\n    // 5 |     let s = max(strings, |a, b| a.len() < b.\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpb5xge65q.rs:9:37\n  |\n9 |\
    \ fn longest(strings: Vec<String>) -> Option<String> {\n  |    -------       \
    \                   ^^^^^^^^^^^^^^ expected enum `Option`, found `()`\n  |   \
    \ |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note:   expected enum `Option<String>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = String::new();\n    for string in strings {\n     \
    \   if string.len() > longest.len() {\n            longest = string;\n       \
    \ }\n    }\n    if longest.is_empty() {\n        None\n    } else {\n        Some(longest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = None;\n    for string in strings {\n        if let Some(current)\
    \ = result {\n            if string.len() > current.len() {\n                result\
    \ = Some(string);\n            }\n        } else {\n            result = Some(string);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpd5qwco_m.rs:13:31\n\
    \   |\n10 |     let mut result = None;\n   |         ---------- consider giving\
    \ `result` the explicit type `Option<T>`, with the type parameters specified\n\
    ...\n13 |             if string.len() > current.len() {\n   |                \
    \               ^^^^^^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut long_string\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > long_string.len()\
    \ {\n            long_string = string;\n        }\n    }\n    Some(long_string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmplow9an02.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // When you're looking to find the largest or smallest value in a collection,\
    \ you can use the\n    // max or min method. This method takes a closure that\
    \ compares two values, and returns the\n    // largest or smallest one.\n    //\n\
    \    // The following demonstrates how to find the largest value in a collection\
    \ of integers:\n    //\n    // let a = [1, 2, 3, 4, 5];\n    // let b = &a;\n\
    \    // let c = a.iter();\n    //\n    // let largest = a.iter().max();\n    //\n\
    \    // println!(\"The largest number is {}\", largest);\n    //\n    // You can\
    \ also use the max method with two or more arguments, like this:\n    //\n   \
    \ // let a = [1, 2, 3, 4, 5];\n    // let b = &a;\n    // let c = a.iter();\n\
    \    //\n    // let largest = a.iter().max();\n    //\n    // println!(\"The largest\
    \ number is {}\", largest);\n    //\n    // You can also use the max method with\
    \ two or more arguments, like this:\n    //\n    // let a = [1, 2, 3, 4, 5];\n\
    \    // let b = &a;\n    // let c = a.iter();\n    //\n    // let largest = a.iter().max();\n\
    \    //\n    // println!(\"The largest number is {}\", largest);\n    //\n   \
    \ // You can also use the max method with two or more arguments, like this:\n\
    \    //\n    // let a = [1, 2, 3, 4, 5];\n    // let b = &a;\n    // let c = a.iter();\n\
    \    //\n    // let largest = a.iter().max();\n    //\n    // println!(\"The largest\
    \ number is {}\", largest);\n    //\n    // You can also use the max method with\
    \ two or more arguments, like this:\n    //\n    // let a = [1, 2, 3, 4, 5];\n\
    \    // let b = &a;\n    // let c = a.iter();\n    //\n    // let largest = a.iter().max();\n\
    \    //\n    // println!(\"The largest number is {}\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpatb6n3d4.rs:9:37\n  |\n9 |\
    \ fn longest(strings: Vec<String>) -> Option<String> {\n  |    -------       \
    \                   ^^^^^^^^^^^^^^ expected enum `Option`, found `()`\n  |   \
    \ |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note:   expected enum `Option<String>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // Filling the blanks with your code\n    let mut longest_string = None;\n\
    \    for current_string in strings {\n        longest_string = match longest_string\
    \ {\n            None => Some(current_string),\n            Some(string) => {\n\
    \                if string.len() > current_string.len() {\n                  \
    \  Some(string)\n                } else {\n                    Some(current_string)\n\
    \                }\n            }\n        };\n    }\n    longest_string\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp5jnf1pa4.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max().cloned()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpvgp7l0ve.rs:10:31\n\
    \    |\n10  |       strings.into_iter().max().cloned()\n    |                \
    \                 ^^^^^^ `Option<String>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<String>:\
    \ Iterator`\n            which is required by `&mut Option<String>: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|x| x.len()).or(None)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpwqqi6gwq.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_str = None;\n    let mut longest_len = 0;\n    for s\
    \ in strings {\n        if s.len() > longest_len {\n            longest_str =\
    \ Some(s);\n            longest_len = s.len();\n        }\n    }\n    longest_str\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpvknl_9o6.rs:15:27\n\
    \   |\n12 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n13 |         if s.len()\
    \ > longest_len {\n14 |             longest_str = Some(s);\n   |             \
    \                   - value moved here\n15 |             longest_len = s.len();\n\
    \   |                           ^^^^^^^ value borrowed here after move\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_index = 0;\n    let mut max_length = 0;\n    for (i, string)\
    \ in strings.iter().enumerate() {\n        if string.len() > max_length {\n  \
    \          max_index = i;\n            max_length = string.len();\n        }\n\
    \    }\n    if max_length == 0 {\n        None\n    } else {\n        Some(strings[max_index].clone())\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmplow9an02.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.is_empty() {\n        true => None,\n        false => {\n\
    \            let mut longest = &strings[0];\n            for string in &strings\
    \ {\n                if string.len() > longest.len() {\n                    longest\
    \ = string;\n                }\n            }\n            Some(longest.to_string())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // code here\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpg8ssttyp.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_idx = None;\n    for (idx, string)\
    \ in strings.iter().enumerate() {\n        if string.len() > max_length {\n  \
    \          max_length = string.len();\n            max_idx = Some(idx);\n    \
    \    }\n    }\n    match max_idx {\n        Some(idx) => Some(strings[idx].clone()),\n\
    \        None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |longest, string| {\n        match longest\
    \ {\n            None => Some(string),\n            Some(current_longest) => {\n\
    \                if string.len() > current_longest.len() {\n                 \
    \   Some(string)\n                } else {\n                    Some(current_longest)\n\
    \                }\n            }\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let max_length = match strings.iter().max_by_key(|s| s.len()) {\n   \
    \     Some(s) => s.len(),\n        None => return None,\n    };\n    let strs\
    \ = strings.iter().filter(|s| s.len() == max_length);\n    strs.fold(None, |acc,\
    \ s| match acc {\n        Some(_) => acc,\n        None => Some(s.to_string()),\n\
    \    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut strings = strings;\n    strings.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    strings.first().cloned()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = strings[0].len();\n    let mut max_idx = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_idx = i;\n        }\n    }\n    Some(strings[max_idx].clone())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = strings.first().clone();\n    for s in strings {\n\
    \        if longest.as_ref().map_or(true, |l| l.len() < s.len()) {\n         \
    \   longest = Some(s);\n        }\n    }\n    longest\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5qiszi3e.rs:13:28\n   |\n\
    13 |             longest = Some(s);\n   |                            ^\n   | \
    \                           |\n   |                            expected `&String`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&s`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5qiszi3e.rs:16:5\n\
    \   |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |       \
    \                              -------------- expected `Option<String>` because\
    \ of return type\n...\n16 |     longest\n   |     ^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\n   = note: expected enum `Option<String>`\n         \
    \     found enum `Option<&String>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // Extracting the length.\n    let length = |s: &String| s.len();\n \
    \   // Defining the \"longest\" function.\n    let longest = |a: &String, b: &String|\
    \ {\n        if length(a) > length(b) { a } else { b }\n    };\n    // Applying\
    \ the fold method.\n    strings.iter().fold(None, |acc, s| {\n        match acc\
    \ {\n            Some(old) => Some(longest(s, &old)),\n            None => Some(s.clone())\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzc51n34s.rs:19:31\n   |\n\
    19 |             Some(old) => Some(longest(s, &old)),\n   |                  \
    \             ^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                               |\n   |                               expected\
    \ struct `String`, found `&String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmplow9an02.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = String::from(\"\");\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|string| string.len()).cloned()\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpl8ehanc5.rs:10:59\n\
    \    |\n10  |       strings.into_iter().max_by_key(|string| string.len()).cloned()\n\
    \    |                                                             ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| {\n        match acc {\n    \
    \        None => Some(s),\n            Some(acc_s) => Some(if acc_s.len() < s.len()\
    \ { s } else { acc_s }),\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max().map(|s| s.to_string())\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpsj_9wh7d.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // I guess this is the \"idiomatic way\" of doing it.\n    strings.into_iter().max_by_key(|s|\
    \ s.len()).cloned()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpoudwbwq7.rs:11:49\n\
    \    |\n11  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp86msuqov.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|string| string.len()).map(|string| string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpfnalyb_h.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut strings = strings;\n            strings.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n            Some(strings.pop().unwrap())\n     \
    \   }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpekebf7qa.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmplow9an02.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_string\
    \ = String::from(\"\");\n    for string in strings {\n        if string.len()\
    \ > longest_string.len() {\n            longest_string = string;\n        }\n\
    \    }\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n    Some(longest)\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_str = None;\n    for s in strings {\n        if max_str.is_none()\
    \ || s.len() > max_str.as_ref().unwrap().len() {\n            max_str = Some(s);\n\
    \        }\n    }\n    max_str\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmp17x7sx4g.rs:12:51\n\
    \   |\n10 |     let mut max_str = None;\n   |         ----------- consider giving\
    \ `max_str` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for s in strings {\n12 |         if max_str.is_none() || s.len() > max_str.as_ref().unwrap().len()\
    \ {\n   |                                                   ^^^^^^ cannot infer\
    \ type for type parameter `T`\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_so_far = String::new();\n    for string in strings {\n\
    \        if string.len() > longest_so_far.len() {\n            longest_so_far\
    \ = string;\n        }\n    }\n    if longest_so_far.is_empty() {\n        None\n\
    \    } else {\n        Some(longest_so_far)\n    }\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut result\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > result.len() {\n\
    \            result = s;\n        }\n    }\n    Some(result.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut res = None;\n    let mut max_len = 0;\n    for string in strings\
    \ {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            res = Some(string);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut res\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > res.len()\
    \ {\n            res = s;\n        }\n    }\n    Some(res)\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut ret\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > ret.len()\
    \ {\n            ret = s;\n        }\n    }\n    Some(ret)\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut r = strings.into_iter().peekable();\n    let mut l = r.peek().cloned();\n\
    \    let mut f = l.clone();\n    while let Some(s) = r.next() {\n        l = l.and_then(|l|\
    \ match l.len().cmp(&s.len()) {\n            Ordering::Less => Some(s),\n    \
    \        Ordering::Equal => {\n                f = Some(s);\n                Some(l)\n\
    \            }\n            Ordering::Greater => Some(l),\n        });\n    }\n\
    \    l.or(f)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpnv879qll.rs:15:13\n   |\n15 |             Ordering::Less => Some(s),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpnv879qll.rs:16:13\n\
    \   |\n16 |             Ordering::Equal => {\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpnv879qll.rs:20:13\n   |\n20 |             Ordering::Greater\
    \ => Some(l),\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut iterator = strings.iter();\n    if let Some(max) = iterator.next()\
    \ {\n        let mut longest = max;\n        for string in iterator {\n      \
    \      if string.len() > longest.len() {\n                longest = string;\n\
    \            }\n        }\n        Some(longest.to_string())\n    } else {\n \
    \       None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max = 0;\n    let mut result = None;\n    for s in strings {\n\
    \        if s.len() > max {\n            max = s.len();\n            result =\
    \ Some(s);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_index\
    \ = 0;\n    for i in 1..strings.len() {\n        if strings[i].len() > strings[longest_index].len()\
    \ {\n            longest_index = i;\n        }\n    }\n    Some(strings[longest_index].clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut res\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > res.len() {\n\
    \            res = s;\n        }\n    }\n    Some(res.clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        longest = match\
    \ longest {\n            None => Some(s),\n            Some(l) => if s.len() >\
    \ l.len() { Some(s) } else { Some(l) },\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| match acc {\n        None =>\
    \ Some(s),\n        Some(acc) => if acc.len() < s.len() { Some(s) } else { Some(acc)\
    \ },\n    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = None;\n    for s in strings {\n        result = match\
    \ result {\n            None => Some(s),\n            Some(x) => {\n         \
    \       if x.len() < s.len() {\n                    Some(s)\n                }\
    \ else {\n                    Some(x)\n                }\n            }\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = None;\n    let mut max_len = 0;\n    for string in strings\
    \ {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            result = Some(string);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|x| x.len()).map(|x| x.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpoerqt52h.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for x in strings {\n        match longest\
    \ {\n            None => longest = Some(x),\n            Some(ref mut longest_str)\
    \ => {\n                if x.len() > longest_str.len() {\n                   \
    \ *longest_str = x;\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_string\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest_string.len()\
    \ {\n            longest_string = s;\n        }\n    }\n    Some(longest_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut iter = strings.iter();\n    if let Some(initial) = iter.next()\
    \ {\n        let mut max = initial;\n        for string in iter {\n          \
    \  if string.len() > max.len() {\n                max = string;\n            }\n\
    \        }\n        Some(max.to_string())\n    } else {\n        None\n    }\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut res = None;\n    let mut max_len = 0;\n    for s in strings {\n\
    \        if s.len() > max_len {\n            max_len = s.len();\n            res\
    \ = Some(s);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4rt1wd2q.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprqu1mv9l.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976544
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|x| x.len()).map(String::from)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp6820yteu.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut first = true;\n    let mut max_len = 0;\n    let mut max_str\
    \ = None;\n    for s in strings {\n        if first {\n            max_len = s.len();\n\
    \            max_str = Some(s);\n            first = false;\n        } else {\n\
    \            if s.len() > max_len {\n                max_len = s.len();\n    \
    \            max_str = Some(s);\n            }\n        }\n    }\n    max_str\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976545
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(String::from)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpqfd00mqw.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976545
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut res: Option<String> = None;\n    for\
    \ s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            res = Some(s);\n        }\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976545
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut l =\
    \ strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > l.len()\
    \ {\n            l = s.clone();\n        }\n    }\n    Some(l)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976545
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = None;\n    for s in strings {\n        match result\
    \ {\n            None => result = Some(s),\n            Some(ref mut r) => {\n\
    \                if r.len() < s.len() {\n                    *r = s;\n       \
    \         }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976545
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_string\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > max_string.len()\
    \ {\n            max_string = s;\n        }\n    }\n    Some(max_string)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976545
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut longest = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    longest = Some(s);\n        }\n    }\n    longest\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976545
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > max.len() {\n\
    \            max = s;\n        }\n    }\n    Some(max.clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        longest = match\
    \ longest {\n            None => Some(s),\n            Some(l) => if s.len() >\
    \ l.len() { Some(s) } else { Some(l) },\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, x| {\n        match acc {\n    \
    \        None => Some(x),\n            Some(y) => if x.len() > y.len() { Some(x)\
    \ } else { Some(y) }\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976545
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976544
