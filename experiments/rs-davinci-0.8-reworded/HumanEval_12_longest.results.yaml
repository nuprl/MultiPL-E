language: rs
name: HumanEval_12_longest
results:
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut current_longest = None;\n    for s in strings {\n        if current_longest.is_none()\
    \ || s.len() > current_longest.unwrap().len() {\n            current_longest =\
    \ Some(s);\n        }\n    }\n    current_longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpdg_e3lbw.rs:12:67\n\
    \   |\n10 |     let mut current_longest = None;\n   |         -------------------\
    \ consider giving `current_longest` the explicit type `Option<T>`, where the type\
    \ parameter `T` is specified\n11 |     for s in strings {\n12 |         if current_longest.is_none()\
    \ || s.len() > current_longest.unwrap().len() {\n   |                        \
    \                                           ^^^^^^ cannot infer type for type\
    \ parameter `T`\n   |\n   = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = usize::min_value();\n    let mut max_len_idx = usize::min_value();\n    for\
    \ (idx, string) in strings.iter().enumerate() {\n        if string.len() > max_len\
    \ {\n            max_len = string.len();\n            max_len_idx = idx;\n   \
    \     }\n    }\n    return Some(strings[max_len_idx].clone());\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    // TODO: return\
    \ the longest string\n    let mut longest = &strings[0];\n    for string in &strings\
    \ {\n        if string.len() > longest.len() {\n            longest = string;\n\
    \        }\n    }\n    Some(longest.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    // This won't\
    \ work. `maximum` is never evaluated, because\n    // it is not used by the code.\n\
    \    // let maximum = strings.iter().max_by_key(|s| s.len());\n    // So we need\
    \ to do this:\n    let mut maximum = strings[0].clone();\n    for s in strings\
    \ {\n        if s.len() > maximum.len() {\n            maximum = s;\n        }\n\
    \    }\n    Some(maximum)\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| match acc {\n        None =>\
    \ Some(s),\n        Some(acc) => Some(match s.len().cmp(&acc.len()) {\n      \
    \      Ordering::Greater => s,\n            _ => acc,\n        }),\n    })\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpw5qpi2u4.rs:13:13\n   |\n13 |             Ordering::Greater => s,\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp69sf1fbi.rs:10:49\n    |\n\
    10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp86msuqov.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut strings = strings;\n    match strings.len() {\n        0 => None,\n\
    \        _ => {\n            let mut longest = strings.remove(0);\n          \
    \  for string in strings {\n                if string.len() > longest.len() {\n\
    \                    longest = string;\n                }\n            }\n   \
    \         Some(longest)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        longest = match\
    \ longest {\n            None => Some(s),\n            Some(ref current) => {\n\
    \                if s.len() > current.len() {\n                    Some(s)\n \
    \               } else {\n                    Some(current.clone())\n        \
    \        }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = String::from(\"\");\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4rt1wd2q.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // ...\n    None\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpgtcmyego.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    match strings.iter().max_by_key(|x| x.len()) {\n        Some(s) => Some(s.to_string()),\n\
    \        None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpfoahz0ib.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmplow9an02.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max().map(|x| x.to_string())\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpc0j68su0.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string: Option<String> = None;\n    for s in strings\
    \ {\n        longest_string = match longest_string {\n            None => Some(s),\n\
    \            Some(ref current_longest) => {\n                if s.len() > current_longest.len()\
    \ {\n                    Some(s)\n                } else {\n                 \
    \   Some(current_longest.clone())\n                }\n            }\n        }\n\
    \    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut cur) =>\
    \ {\n                if s.len() > cur.len() {\n                    *cur = s;\n\
    \                }\n            }\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // if strings.len() == 0 {\n    //     return None;\n    // }\n    //\
    \ let mut length = 0;\n    // let mut longest = &strings[0];\n    // for s in\
    \ strings {\n    //     if s.len() > length {\n    //         length = s.len();\n\
    \    //         longest = &s;\n    //     }\n    // }\n    // Some(String::from(longest))\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpgds0l61f.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
