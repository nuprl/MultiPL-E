name: HumanEval_45_triangle_area
language: rs
prompt: "/// Given length of a side and high return area for a triangle.\n/// >>>\
  \ triangle_area(5, 3)\n/// 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5,\
  \ 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10,\
  \ 8), 40.0);\n}\n"
completions: ['  a as f64 * h as f64 / 2.0', '    (a as f64 * h as f64) / 2.0', '    (a
    as f64 * h as f64) / 2.0', "    let a = a as f64;\n    let h = h as f64;\n   \
    \ (a * h) / 2.0", '    0.5 * a as f64 * h as f64', "    // TODO\n    unimplemented!()",
  '    (a as f64 * h as f64) / 2_f64', '    (a as f64) * (h as f64) / 2.0', "    if\
    \ a <= 0 || h <= 0 {\n        panic!(\"Triangle side can't be negative or equal\
    \ to zero.\");\n    }\n    a as f64 * h as f64 / 2.0", '    a as f64 * h as f64
    / 2.0', '    (a as f64 * h as f64) / 2.0', '    f64::from(a * h) / 2.0', '    (a
    as f64 * h as f64) / 2.0', '    0.5 * a as f64 * h as f64', '    (a as f64 * h
    as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64)
    / 2.0', '    0.5 * (a as f64) * (h as f64)', '    (a as f64) * (h as f64) / 2.0',
  '    a as f64 * h as f64 / 2.0', '    unimplemented!()', '    0.5 * a as f64 * h
    as f64', '    (0.5 * a as f64 * h as f64) as f64', '    (a as f64 * h as f64)
    / 2.0', "    let s = triangle_space(a, h);\n    (s * (s - a as f64) * (s - h as\
    \ f64)).sqrt()", '    (a as f64 * h as f64) / 2.0', '    0.5 * a as f64 * h as
    f64', '  (a as f64 * h as f64 / 2f64).round() / 1f64', "    let half: f64 = 0.5;\n\
    \    half * (a as f64) * (h as f64)", "    let area = a as f64 * h as f64 / 2.0;\n\
    \    area", '    0.5 * a as f64 * h as f64', '    (a as f64 * h as f64) / 2.0',
  '    0.5 * (a as f64) * (h as f64)', '    (a as f64 * h as f64) / 2.0', '  (a as
    f64 * h as f64 / 2.0).abs()', "    let numerator = a as f64 * h as f64;\n    let\
    \ denominator = 2.0;\n    numerator / denominator", '    (a as f64 * h as f64)
    / 2.0', "    // isize -> f64\n    let c: f64 = (a * h) as f64;\n    c / 2.0",
  "    let area = (a as f64) * (h as f64) / 2.0;\n    return area;", '    (0.5 * a
    as f64 * h as f64) as f64', '    (a as f64 * h as f64) / 2.0', "    let a: f64\
    \ = a as f64;\n    let h: f64 = h as f64;\n    (a * h) / 2.0", '    (a as f64
    * h as f64) / 2.0', '    ((a as f64) * (h as f64)) / 2.0', '    (a as f64 * h
    as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    a as f64 * h as f64 /
    2f64', "    // todo!()\n    a as f64 / 2.0 * h as f64", '    (a as f64) * (h as
    f64) / 2.0', '  (a * h) as f64 / 2.0', '    (a as f64 * h as f64) / 2.0', '    (a
    as f64) * (h as f64) / 2.0', '    0.5 * a as f64 * h as f64', '    ((a as f64
    / 2.0) * h as f64).round() / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a
    as f64 * h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    ((a as f64)
    * (h as f64)) / 2.0', "    let area = 0.5 * (a as f64) * (h as f64);\n    area",
  "    let area = a as f64 * h as f64 / 2.0;\n    area", '    return (a as f64 * h
    as f64) / 2.0;', '  (a as f64 * h as f64 / 2.0).abs()', '    ((a as f64) * (h
    as f64)) / 2.0', '    0.5 * a as f64 * h as f64', '    (a as f64) * (h as f64)
    / 2.0', '    a as f64 * h as f64 / 2 as f64', '    (a as f64 * h as f64) / 2.0',
  '    (a as f64 * h as f64) / 2.0', '    a as f64 * h as f64 / 2.0', '    (a as f64
    * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    return (a as f64 *
    h as f64) / 2.0;', '    a as f64 * h as f64 / 2.0', '    (a as f64 * h as f64)
    / 2.0', "    let area = (a as f64 * h as f64)/2 as f64;\n    area", '    (a as
    f64 * h as f64 / 2.0).abs()', '    0.5 * a as f64 * h as f64', '    (a as f64)
    * (h as f64) / 2.0', '    0.5 * a as f64 * h as f64', '    (a as f64 * h as f64)
    / 2.0', '    (a as f64 * h as f64) / 2f64', '    (a as f64) * (h as f64) / 2.0',
  '    (a as f64 * h as f64 / 2.0).round() / 1.0', '    (a as f64 * h as f64) / 2.0',
  '    ((a as f64) * (h as f64)) / 2.0', '    (a as f64) * (h as f64) / 2.0', "  \
    \  let mut area: f64 = (a * h) as f64 / 2.0;\n    area", '    (a as f64) * (h
    as f64) / 2.0', "    let area = (a as f64) * (h as f64) / 2.0;\n    area", '    return
    (a as f64) * (h as f64) / 2.0;', '    return (a as f64) * (h as f64) / 2f64;',
  '    (a as f64) * (h as f64) / 2f64', '    (a as f64 * h as f64) / 2.0', '    (a
    as f64 * h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a as f64
    * h as f64) / 2.0', '    (a as f64) * (h as f64) / 2f64', '    0.5 * (a as f64)
    * (h as f64)', '    (a as f64) * (h as f64) / 2.0', "    // TODO\n    0.0", " \
    \   // a * h / 2.0\n    a as f64 * h as f64 / 2.0", '    ((a as f64) * (h as f64))
    / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0',
  '  a as f64 * h as f64 / 2.0', '    (a as f64 * h as f64 / 2.0).round() / 1.0',
  '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    (a as
    f64 * h as f64) / 2.0', "  // TODO write your code here\n  unimplemented!()",
  "    let area = a as f64 * h as f64 * 0.5;\n    area", '    0.5 * a as f64 * h as
    f64', '    (a as f64) * (h as f64) / 2.0', "    let area = (a as f64 * h as f64)\
    \ / 2.0;\n    area", "    let area = (a as f64) * (h as f64) / 2.0;\n    area",
  "    let area = (0.5 * (a as f64) * (h as f64)).abs();\n    area", "    let a: f64\
    \ = a as f64;\n    let h: f64 = h as f64;\n    (a * h) / 2.0", '    (a as f64
    * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    (a as f64) * (h as
    f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0',
  '    (a as f64) * (h as f64) / 2.0', '    0.5 * a as f64 * h as f64', "    let area\
    \ = (a as f64 * h as f64) / 2.0;\n    area", '    (a as f64 * h as f64) / 2.0',
  "    let area = (a as f64 * h as f64) / 2.0;\n    area", '    (0.5 * a as f64 *
    h as f64) as f64', '    a as f64 * h as f64 / 2.0', '    (a as f64 * h as f64)
    / 2.0', '    (((a as f64) * (h as f64)) / 2.0) as f64', '    (a as f64 * h as
    f64) / 2.0', '    a as f64 * h as f64 / 2.0', '    (a as f64 * h as f64 / 2.0).abs()',
  "    let s = triangle_perimeter(a, h);\n    let p = s as f64 / 2.0;\n    p * p *\
    \ (s - a as f64) * (s - h as f64) * (s - (a + h) as f64)", '    (a as f64 * h
    as f64) / 2.0', '    (0.5 * a as f64 * h as f64) as f64', "    let result = (a\
    \ as f64 * h as f64) / 2.0;\n    result", '    (0.5 * a as f64 * h as f64) as
    f64', '    (a as f64 * h as f64 / 2.0)', "    let f_a = a as f64;\n    let f_h\
    \ = h as f64;\n    0.5 * f_a * f_h", '    (a as f64 * h as f64 / 2.0).round()
    / 10.0', '    (a as f64 * h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0',
  '    (a as f64 * h as f64) / 2.0', "    // ...\n    unimplemented!()", '    (a as
    f64 * h as f64 / 2.0).abs()', "    let a: f64 = a as f64;\n    let h: f64 = h\
    \ as f64;\n    a * h / 2.0", '    (a as f64 * h as f64) / 2.0', '    (a as f64
    * h as f64 / 2.0).abs()', '    (a as f64 * h as f64) / 2f64', '    (((a as f64)
    * (h as f64)) / 2_f64).abs()', '    (a as f64 * h as f64) / 2.0', '    (a as f64
    * h as f64) / 2f64', "    // TODO:\n    return 0.0;", '    (a as f64 * h as f64)
    / 2.0', '    a as f64 * h as f64 / 2.0', "    //TODO\n    return 0 as f64;", '    (a
    as f64 * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    0.5 * a as
    f64 * h as f64', '    a as f64 * h as f64 / 2.0', '    ((a as f64) * (h as f64))
    / 2_f64', '    0.5 * a as f64 * h as f64', '    a as f64 * h as f64 / 2 as f64',
  '    (a as f64) * (h as f64) / 2.0', '    0.5 * (a as f64) * (h as f64)', '    (a
    as f64 * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    0.5 * a as
    f64 * h as f64', '  (a as f64 * h as f64 / 2.0).abs()', '    (a as f64 * h as
    f64) / 2.0', '    (a as f64 * h as f64 / 2.0).floor()', '    0.5 * (a as f64)
    * (h as f64)', '    f64::from(a) * f64::from(h) / 2.0', '    (a as f64 * h as
    f64) / 2.0', "    let a = a as f64;\n    let h = h as f64;\n    0.5 * a * h",
  "    let a = a as f64;\n    let h = h as f64;\n    (a * h) / 2.0", "    let area\
    \ = (a as f64 * h as f64) / 2.0;\n    area", '    (a as f64 * h as f64) / 2f64',
  '    (a as f64 * h as f64) / 2.0', '    return (a as f64) * (h as f64) / 2.0;',
  "    let mut result = a * h;\n    result = result / 2;\n    result as f64", '    (a
    as f64 * h as f64) / 2_f64', '    a as f64 * h as f64 / 2.0', "    // ?\n    let\
    \ area = (a * h) as f64 / 2.0;\n    return area;", '    (a as f64 * h as f64)
    / 2.0', '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0',
  "    let float_a = a as f64;\n    let float_h = h as f64;\n    (float_a * float_h)\
    \ / 2.0", "    let a = a as f64;\n    let h = h as f64;\n    (a * h) / 2.0", '    (a
    as f64 * h as f64) / 2_f64', '    (0.5 * a as f64 * h as f64) as f64', '    (a
    as f64) * (h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a as f64)
    * (h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as
    f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    return a as f64 * h as f64
    / 2.0;']
stop_tokens:
- "\n}"
