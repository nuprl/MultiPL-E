name: HumanEval_87_get_row
language: rs
results:
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        let mut cur_x = 0;\n        for (x1, &item) in row.iter().enumerate()\
    \ {\n            if item == x {\n                res.push((y as isize, x1 as isize));\n\
    \                cur_x = x1 as isize;\n            }\n        }\n        if cur_x\
    \ != 0 {\n            res.push((y as isize, 0));\n        }\n    }\n    res.sort_by(|&(a,\
    \ b), &(c, d)| match a.cmp(&c) {\n        Ordering::Less => Ordering::Less,\n\
    \        Ordering::Greater => Ordering::Greater,\n        Ordering::Equal => d.cmp(&b),\n\
    \    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp3oap2t4n.rs:31:9\n   |\n31 |         Ordering::Less => Ordering::Less,\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp3oap2t4n.rs:31:27\n\
    \   |\n31 |         Ordering::Less => Ordering::Less,\n   |                  \
    \         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp3oap2t4n.rs:32:9\n\
    \   |\n32 |         Ordering::Greater => Ordering::Greater,\n   |         ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmp3oap2t4n.rs:32:30\n   |\n32 |    \
    \     Ordering::Greater => Ordering::Greater,\n   |                          \
    \    ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmp3oap2t4n.rs:33:9\n   |\n33\
    \ |         Ordering::Equal => d.cmp(&b),\n   |         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter()\n\
    \        .enumerate()\n        .flat_map(|(i, row)| {\n            row.iter()\n\
    \                .enumerate()\n                .filter(|&(_, y)| x == *y)\n  \
    \              .map(move |(j, _)| (i as isize, j as isize))\n        })\n    \
    \    .sorted_by(|&(i1, j1), &(i2, j2)| if i1 != i2 {\n            i1.cmp(&i2)\n\
    \        } else {\n            j2.cmp(&j1)\n        })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmpb38hmh0s.rs:25:10\n   |\n25 |         .sorted_by(|&(i1,\
    \ j1), &(i2, j2)| if i1 != i2 {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpb38hmh0s.rs:22:25:\
    \ 22:42]>, [closure@/tmp/tmpb38hmh0s.rs:23:22: 23:60]>, [closure@/tmp/tmpb38hmh0s.rs:19:19:\
    \ 24:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coordinates = Vec::new();\n    for (i, row) in lst.iter().enumerate() {\n  \
    \      for (j, x) in row.iter().enumerate() {\n            if *x == x {\n    \
    \            coordinates.push((i as isize, j as isize));\n            }\n    \
    \    }\n    }\n    coordinates.sort_by(|(x, y), (x1, y1)| x.cmp(x1).then(y1.cmp(y)));\n\
    \    coordinates\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljlnzdu2.rs:20:22\n   |\n\
    20 |             if *x == x {\n   |                      ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |        \
    \     if *x == *x {\n   |                      +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    let len = lst.len();\n    for i in 0..len\
    \ {\n        let lst_len = lst[i].len();\n        for j in 0..lst_len {\n    \
    \        if lst[i][j] == x {\n                res.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    res.sort_by(|a, b| {\n        if a.0 ==\
    \ b.0 {\n            return b.1.cmp(&a.1);\n        }\n        a.0.cmp(&b.0)\n\
    \    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x, i) in row.iter().enumerate() {\n            if *i == x {\n\
    \                result.push((y as isize, x as isize));\n            }\n     \
    \   }\n    }\n    result.sort_by(|a, b| {\n        let row_cmp = a.0.cmp(&b.0);\n\
    \        if row_cmp == Ordering::Equal {\n            return b.1.cmp(&a.1);\n\
    \        }\n        row_cmp\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp7m2cidj2.rs:27:23\n   |\n27 |         if row_cmp == Ordering::Equal\
    \ {\n   |                       ^^^^^^^^ use of undeclared type `Ordering`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7m2cidj2.rs:20:22\n   |\n20 |  \
    \           if *i == x {\n   |                      ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |             if *i == x.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut rows: Vec<(isize, isize)> = vec![];\n\
    \    for (r, row) in lst.iter().enumerate() {\n        if row.contains(&x) {\n\
    \            let c = row.iter().position(|&x_| x_ == x).unwrap() as isize;\n \
    \           rows.push((r as isize, c));\n        }\n    }\n    rows.sort_by(|a,\
    \ b| {\n        if a.0 < b.0 {\n            Ordering::Less\n        } else if\
    \ a.0 > b.0 {\n            Ordering::Greater\n        } else {\n            b.1.cmp(&a.1)\n\
    \        }\n    });\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp_3vqms_k.rs:29:13\n   |\n29 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp_3vqms_k.rs:31:13\n\
    \   |\n31 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|(r1, c1), (r2, c2)| {\n        match r1.cmp(r2)\
    \ {\n            Ordering::Equal => c2.cmp(c1),\n            _ => r1.cmp(r2),\n\
    \        }\n    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp69lznn9f.rs:27:13\n   |\n27 |             Ordering::Equal => c2.cmp(c1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    let mut temp_row = 0;\n    for row\
    \ in lst {\n        let mut temp_col = -1;\n        for col in row {\n       \
    \     if col == x {\n                temp_col += 1;\n                result.push((temp_row,\
    \ temp_col));\n            }\n        }\n        temp_row += 1;\n    }\n    result.sort_by(|a,\
    \ b| {\n        match a.0.cmp(&b.0) {\n            Ordering::Equal => a.1.cmp(&b.1),\n\
    \            other => other,\n        }\n    });\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpw58o9aow.rs:31:13\n   |\n31 |             Ordering::Equal => a.1.cmp(&b.1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut lst: Vec<(isize, isize)> = lst\n\
    \        .iter()\n        .enumerate()\n        .flat_map(|(i, x)| {\n       \
    \     x.iter()\n                .enumerate()\n                .filter(|(_, &x)|\
    \ x == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n    \
    \    })\n        .collect();\n    lst.sort_by(|(row1, _), (row2, _)| row1.cmp(row2));\n\
    \    lst.sort_by(|(row1, _), (row2, _)| row1.cmp(row2));\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 0), (1, 1), (1, 2), (1,\
    \ 3), (1, 4), (1, 5), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5)]`,\n right:\
    \ `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmp_cf1ozqq.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // Your\
    \ code here!\n    let mut to_ret = Vec::new();\n    for (y, xs) in lst.iter().enumerate()\
    \ {\n        for (x, x) in xs.iter().enumerate() {\n            if *x == x {\n\
    \                to_ret.push((y as isize, x as isize));\n            }\n     \
    \   }\n    }\n    to_ret.sort_by(|a, b| {\n        if a.0 != b.0 {\n         \
    \   a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n        }\n  \
    \  });\n    to_ret\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0416]: identifier `x` is bound more than once in the same pattern\n\
    \  --> /tmp/tmpm3eovmrb.rs:20:17\n   |\n20 |         for (x, x) in xs.iter().enumerate()\
    \ {\n   |                 ^ used in a pattern more than once\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm3eovmrb.rs:21:22\n   |\n21 |             if\
    \ *x == x {\n   |                      ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n21 |             if *x ==\
    \ *x {\n   |                      +\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmpm3eovmrb.rs:22:42\n   |\n22 |                 to_ret.push((y\
    \ as isize, x as isize));\n   |                                          -^^^^^^^^^\n\
    \   |                                          |\n   |                       \
    \                   cannot cast `&isize` as `isize`\n   |                    \
    \                      help: dereference the expression: `*x`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0416,\
    \ E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (row, i) in lst.iter().enumerate()\
    \ {\n        for (col, val) in i.iter().enumerate() {\n            if val == &x\
    \ {\n                res.push((row as isize, col as isize));\n            }\n\
    \        }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result: Vec<(isize, isize)> =\
    \ Vec::new();\n    for i in 0..lst.len() {\n        for j in 0..lst[i].len() {\n\
    \            if lst[i][j] == x {\n                result.push((i as isize, j as\
    \ isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| (a.0, b.1).cmp(&(b.0,\
    \ a.1)));\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ v = Vec::new();\n    for i in 0..lst.len() {\n        for j in 0..lst[i].len()\
    \ {\n            if lst[i][j] == x {\n                v.push((i as isize, j as\
    \ isize));\n            }\n        }\n    }\n    v.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    v\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ v = Vec::new();\n    for (i, elem) in lst.iter().enumerate() {\n        for\
    \ (j, num) in elem.iter().enumerate() {\n            if *num == x {\n        \
    \        v.push((i as isize, j as isize));\n            }\n        }\n    }\n\
    \    v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n    v.sort_by(|&(_, a), &(_, b)|\
    \ b.cmp(&a));\n    v\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmphw_2kuv0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter()\n\
    \        .enumerate()\n        .map(|(i, row)| {\n            row.iter()\n   \
    \             .enumerate()\n                .filter(|(_, &e)| e == x)\n      \
    \          .map(|(j, _)| (i as isize, j as isize))\n        })\n        .flatten()\n\
    \        .collect::<Vec<(isize, isize)>>()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0373]: closure may outlive the current function, but it borrows\
    \ `i`, which is owned by the current function\n  --> /tmp/tmphr5d2g1_.rs:23:22\n\
    \   |\n23 |                 .map(|(j, _)| (i as isize, j as isize))\n   |    \
    \                  ^^^^^^^^  - `i` is borrowed here\n   |                    \
    \  |\n   |                      may outlive borrowed value `i`\n   |\nnote: closure\
    \ is returned here\n  --> /tmp/tmphr5d2g1_.rs:20:13\n   |\n20 | /            \
    \ row.iter()\n21 | |                 .enumerate()\n22 | |                 .filter(|(_,\
    \ &e)| e == x)\n23 | |                 .map(|(j, _)| (i as isize, j as isize))\n\
    \   | |_______________________________________________________^\nhelp: to force\
    \ the closure to take ownership of `i` (and any other referenced variables), use\
    \ the `move` keyword\n   |\n23 |                 .map(move |(j, _)| (i as isize,\
    \ j as isize))\n   |                      ++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0373`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter()\n\
    \        .enumerate()\n        .flat_map(|(y, row)| {\n            row.iter()\n\
    \                .enumerate()\n                .filter(|&(_, n)| n == &x)\n  \
    \              .map(move |(x, _)| (y as isize, x as isize))\n        })\n    \
    \    .sorted_by(|&(y1, x1), &(y2, x2)| (y1, -x1).cmp(&(y2, -x2)))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmptc5hcm02.rs:25:10\n   |\n25 |         .sorted_by(|&(y1,\
    \ x1), &(y2, x2)| (y1, -x1).cmp(&(y2, -x2)))\n   |          ^^^^^^^^^ method not\
    \ found in `FlatMap<Enumerate<std::slice::Iter<'_, Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmptc5hcm02.rs:22:25: 22:42]>, [closure@/tmp/tmptc5hcm02.rs:23:22:\
    \ 23:60]>, [closure@/tmp/tmptc5hcm02.rs:19:19: 24:10]>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, v) in row.iter().enumerate() {\n            if *v == x {\n\
    \                result.push((i as isize, j as isize));\n            }\n     \
    \   }\n    }\n    result.sort_by(|a, b| (a.0, -a.1).cmp(&(b.0, -b.1)));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    for (y, sub) in lst.iter().enumerate()\
    \ {\n        for (x, &item) in sub.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((y as isize, x as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| match a.0.cmp(&b.0) {\n        Ordering::Equal\
    \ => b.1.cmp(&a.1),\n        x => x,\n    });\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpd2f0z5n4.rs:26:9\n   |\n26 |         Ordering::Equal => b.1.cmp(&a.1),\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd2f0z5n4.rs:20:24\n   |\n20 |             if item == x\
    \ {\n   |                        ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |             if item == x.try_into().unwrap() {\n   |       \
    \                  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // TODO:\
    \ implement function\n    let mut result = Vec::new();\n    if lst.len() == 0\
    \ {\n        return result;\n    }\n    for (y, line) in lst.iter().enumerate()\
    \ {\n        for (x1, item) in line.iter().enumerate() {\n            if *item\
    \ == x {\n                result.push((y as isize, x1 as isize));\n          \
    \  }\n        }\n    }\n    result.sort_by(|a, b| {\n        let row_cmp = a.0.cmp(&b.0);\n\
    \        match row_cmp {\n            Ordering::Equal => b.1.cmp(&a.1),\n    \
    \        _ => row_cmp,\n        }\n    });\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpgy8qg0wc.rs:32:13\n   |\n32 |             Ordering::Equal => b.1.cmp(&a.1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
