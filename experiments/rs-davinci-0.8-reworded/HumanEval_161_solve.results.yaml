name: HumanEval_161_solve
language: rs
results:
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.as_bytes().to_vec();\n    for i in 0..s.len()\
    \ {\n        if s[i] > 64 && s[i] < 91 {\n            s[i] += 32;\n        } else\
    \ if s[i] > 96 && s[i] < 123 {\n            s[i] -= 32;\n        }\n    }\n  \
    \  String::from_utf8(s).unwrap()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpvt1dh0hx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    // for c in s.chars() {\n    //     if c.is_ascii_uppercase()\
    \ {\n    //         //\n    //     }\n    // }\n    unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpa5c06izs.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ is_letter_exists = false;\n    for ch in s.chars() {\n        if ch.is_alphabetic()\
    \ {\n            is_letter_exists = true;\n            if ch.is_lowercase() {\n\
    \                reversed_string.push(ch.to_uppercase().next().unwrap());\n  \
    \          } else {\n                reversed_string.push(ch.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            reversed_string.push(ch);\n    \
    \    }\n    }\n    if is_letter_exists {\n        reversed_string\n    } else\
    \ {\n        reversed_string.chars().rev().collect()\n    }\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n\tlet mut v = s.chars().collect::<Vec<char>>();\n\tv.reverse();\n\
    \tlet s: String = v.into_iter().map(|x| {\n\t\tmatch x {\n\t\t\t'a'..='z' => x.to_ascii_uppercase(),\n\
    \t\t\t'A'..='Z' => x.to_ascii_lowercase(),\n\t\t\t_ => x,\n\t\t}\n\t}).collect();\n\
    \tif s.chars().any(|x| x.is_alphabetic()) {\n\t\ts\n\t} else {\n\t\tlet mut v\
    \ = s.chars().collect::<Vec<char>>();\n\t\tv.reverse();\n\t\tv.into_iter().collect()\n\
    \t}\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpfd1hs49n.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().rev().map(|c| match c {\n        'a'..='z'\
    \ => c.to_ascii_uppercase(),\n        'A'..='Z' => c.to_ascii_lowercase(),\n \
    \       _ => c,\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpf4t97as9.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    let\
    \ mut contains_letter = false;\n    let mut counter = 0;\n    while counter <\
    \ s.len() {\n        if s[counter].is_alphabetic() {\n            contains_letter\
    \ = true;\n            if s[counter].is_lowercase() {\n                s[counter]\
    \ = s[counter].to_uppercase().next().unwrap();\n            } else {\n       \
    \         s[counter] = s[counter].to_lowercase().next().unwrap();\n          \
    \  }\n        }\n        counter += 1;\n    }\n    if !contains_letter {\n   \
    \     s.reverse();\n    }\n    s.into_iter().collect()\n}\n\nfn main() {\n   \
    \ let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut found = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            found =\
    \ true;\n            if c.is_lowercase() {\n                res.push(c.to_uppercase().to_string().pop().unwrap());\n\
    \            } else {\n                res.push(c.to_lowercase().to_string().pop().unwrap());\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    if !found {\n        res.chars().rev().collect()\n    } else {\n        res\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().rev().map(|c| \n        if c.is_alphabetic()\
    \ {\n            if c.is_lowercase() { c.to_uppercase().to_string() }\n      \
    \      else { c.to_lowercase().to_string() }\n        } else { c.to_string() }\n\
    \    ).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp3pb3aete.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut chars = s.chars();\n    let mut s = String::new();\n\
    \    let mut found = false;\n    while let Some(c) = chars.next() {\n        if\
    \ c.is_ascii_alphabetic() {\n            found = true;\n            s.push(c.swap_case());\n\
    \        } else {\n            s.push(c);\n        }\n    }\n    if !found {\n\
    \        s.chars().rev().collect()\n    } else {\n        s\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap_case` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp0q4z8hkp.rs:20:22\n   |\n20 |             s.push(c.swap_case());\n\
    \   |                      ^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut v: Vec<char> = s.chars().collect();\n    let\
    \ mut b: bool = false;\n    for i in 0..v.len() {\n        if v[i].is_alphabetic()\
    \ {\n            b = true;\n            v[i] = v[i].to_ascii_lowercase();\n  \
    \      }\n    }\n    if b {\n        v.reverse();\n        for i in 0..v.len()\
    \ {\n            if v[i].is_alphabetic() {\n                v[i] = v[i].to_ascii_uppercase();\n\
    \            }\n        }\n    } else {\n        v.reverse();\n    }\n    return\
    \ v.into_iter().collect();\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp4ob5eotf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().rev().collect()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fDsA\"`,\n right: `\"aSdF\"`', /tmp/tmp59cnl03_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpb0jopx7z.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n\tString::from(\"Not implemented yet.\")\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Not implemented yet.\"`,\n right: `\"aSdF\"`', /tmp/tmpnpv78vrx.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut buffer = String::new();\n    let mut has_letter\
    \ = false;\n    for ch in s.chars() {\n        if ch.is_alphabetic() {\n     \
    \       buffer.push(ch.swap_case());\n            has_letter = true;\n       \
    \ } else {\n            buffer.push(ch);\n        }\n    }\n    if !has_letter\
    \ {\n        buffer.chars().rev().collect()\n    } else {\n        buffer\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap_case` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpttiwhxiu.rs:18:28\n   |\n18 |             buffer.push(ch.swap_case());\n\
    \   |                            ^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = s.chars().rev().collect::<String>();\n\
    \    for (i, c) in res.chars().enumerate() {\n        if c.is_alphabetic() {\n\
    \            res.replace_range(i..i+1, &c.to_string().to_uppercase());\n     \
    \   }\n    }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `res` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp7pqsawba.rs:17:13\n   |\n15 |     for (i, c) in\
    \ res.chars().enumerate() {\n   |                   -----------------------\n\
    \   |                   |\n   |                   immutable borrow occurs here\n\
    \   |                   immutable borrow later used here\n16 |         if c.is_alphabetic()\
    \ {\n17 |             res.replace_range(i..i+1, &c.to_string().to_uppercase());\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpfrov1z4p.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        match c {\n            'A'...'Z' => result.push(c.to_ascii_lowercase()),\n\
    \            'a'...'z' => result.push(c.to_ascii_uppercase()),\n            _\
    \ => result.push(c),\n        }\n    }\n    if result.chars().any(|c| c.is_alphabetic())\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut letters = Vec::new();\n    for ch in s.chars()\
    \ {\n        if ch.is_ascii_alphabetic() {\n            letters.push(ch.to_ascii_lowercase());\n\
    \        }\n    }\n    if letters.is_empty() {\n        return s.chars().rev().collect();\n\
    \    }\n\n    let mut result = String::new();\n    for ch in s.chars() {\n   \
    \     if ch.is_ascii_alphabetic() {\n            result.push(letters.pop().unwrap().to_ascii_uppercase());\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp0d_jv1i6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut new_string = String::new();\n    for ch in\
    \ s.chars() {\n        match ch {\n            'a' => new_string.push('A'),\n\
    \            'b' => new_string.push('B'),\n            'c' => new_string.push('C'),\n\
    \            'd' => new_string.push('D'),\n            'e' => new_string.push('E'),\n\
    \            'f' => new_string.push('F'),\n            'g' => new_string.push('G'),\n\
    \            'h' => new_string.push('H'),\n            'i' => new_string.push('I'),\n\
    \            'j' => new_string.push('J'),\n            'k' => new_string.push('K'),\n\
    \            'l' => new_string.push('L'),\n            'm' => new_string.push('M'),\n\
    \            'n' => new_string.push('N'),\n            'o' => new_string.push('O'),\n\
    \            'p' => new_string.push('P'),\n            'q' => new_string.push('Q'),\n\
    \            'r' => new_string.push('R'),\n            's' => new_string.push('S'),\n\
    \            't' => new_string.push('T'),\n            'u' => new_string.push('U'),\n\
    \            'v' => new_string.push('V'),\n            'w' => new_string.push('W'),\n\
    \            'x' => new_string.push('X'),\n            'y' => new_string.push('Y'),\n\
    \            'z' => new_string.push('Z'),\n            'A' => new_string.push('a'),\n\
    \            'B' => new_string.push('b'),\n            'C' => new_string.push('c'),\n\
    \            'D' => new_string.push('d'),\n            'E' => new_string.push('e'),\n\
    \            'F' => new_string.push('f'),\n            'G' => new_string.push('g'),\n\
    \            'H' => new_string.push('h'),\n            'I' => new_\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc554_m39.rs:64:3\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n14 |     let mut new_string = String::new();\n15 | \
    \    for ch in s.chars() {\n   |                         - unclosed delimiter\n\
    16 |         match ch {\n   |                  - this delimiter might not be properly\
    \ closed...\n...\n52 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n64 | }\n   |   ^\n\nerror[E0425]: cannot find value `new_` in this scope\n\
    \  --> /tmp/tmpc554_m39.rs:51:20\n   |\n51 |             'I' => new_\n   |   \
    \                 ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc554_m39.rs:15:5\n   |\n13 |   fn solve(s: String) -> String {\n\
    \   |                          ------ expected `String` because of return type\n\
    14 |       let mut new_string = String::new();\n15 | /     for ch in s.chars()\
    \ {\n16 | |         match ch {\n17 | |             'a' => new_string.push('A'),\n\
    18 | |             'b' => new_string.push('B'),\n...  |\n63 | |     assert_eq!(candidate(String::from(\"\
    #ccc\")), String::from(\"#CCC\"));\n64 | | }\n   | |__^ expected struct `String`,\
    \ found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().rev().map(|c| {\n        match c {\n    \
    \        'a' => 'A',\n            'b' => 'B',\n            'c' => 'C',\n     \
    \       'd' => 'D',\n            'e' => 'E',\n            'f' => 'F',\n      \
    \      'g' => 'G',\n            'h' => 'H',\n            'i' => 'I',\n       \
    \     'j' => 'J',\n            'k' => 'K',\n            'l' => 'L',\n        \
    \    'm' => 'M',\n            'n' => 'N',\n            'o' => 'O',\n         \
    \   'p' => 'P',\n            'q' => 'Q',\n            'r' => 'R',\n          \
    \  's' => 'S',\n            't' => 'T',\n            'u' => 'U',\n           \
    \ 'v' => 'V',\n            'w' => 'W',\n            'x' => 'X',\n            'y'\
    \ => 'Y',\n            'z' => 'Z',\n            'A' => 'a',\n            'B' =>\
    \ 'b',\n            'C' => 'c',\n            'D' => 'd',\n            'E' => 'e',\n\
    \            'F' => 'f',\n            'G' => 'g',\n            'H' => 'h',\n \
    \           'I' => 'i',\n            'J' => 'j',\n            'K' => 'k',\n  \
    \          'L' => 'l',\n            'M' => 'm',\n            'N' => 'n',\n   \
    \         'O' => 'o',\n            'P' => 'p',\n            'Q' => 'q',\n    \
    \        'R' => 'r',\n            'S' => 's',\n            'T' => 't',\n     \
    \       'U' => 'u',\n            'V' => 'v',\n            'W' => 'w',\n      \
    \      'X' => 'x',\n            'Y' => 'y',\n            'Z' => 'z',\n       \
    \     _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpcxzybnkz.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
