name: HumanEval_8_sum_product
language: rs
prompt: "/// For a given vector of integers, return a tuple consisting of a sum and\
  \ a product of all the integers in a vector.\n/// Empty sum should be equal to 0\
  \ and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n/// (0,\
  \ 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
  \ Vec<isize>) -> (isize, isize) {\n"
tests: "}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
  \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
  \ (10, 10));\n}\n"
completions: ["    let s: isize = numbers.iter().sum();\n    let p: isize = numbers.iter().product();\n\
    \    (s, p)", "    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n\
    \    )", "    let mut sum = 0;\n    let mut product = 1;\n    for num in numbers\
    \ {\n        sum += num;\n        product *= num;\n    }\n    (sum, product)",
  "    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n \
    \   for n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum,\
    \ product)", "    let mut sum = 0;\n    let mut product = 1;\n    for num in numbers\
    \ {\n        sum += num;\n        product *= num;\n    }\n    (sum, product)",
  '    (numbers.iter().sum(), numbers.iter().product())', "    // This code produces\
    \ the same result, but it is not as concise as the code in the solution.\n   \
    \ let mut sum = 0;\n    let mut product = 1;\n    for number in numbers {\n  \
    \      sum += number;\n        product *= number;\n    }\n    (sum, product)",
  "    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)", "    let sum = numbers.iter().sum();\n    let product\
    \ = numbers.iter().product();\n    (sum, product)", '    unimplemented!()', " \
    \   let mut total_sum = 0;\n    let mut total_product = 1;\n    for number in\
    \ numbers {\n        total_sum += number;\n        total_product *= number;\n\
    \    }\n    (total_sum, total_product)", "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n   \
    \ }\n    (sum, product)", "    let mut prod: isize = 1;\n    let mut sum: isize\
    \ = 0;\n    for i in numbers {\n        prod *= i;\n        sum += i;\n    }\n\
    \    (sum, prod)", "    let mut sum = 0;\n    let mut product = 1;\n    for number\
    \ in numbers {\n        sum += number;\n        product *= number;\n    }\n  \
    \  (sum, product)", '    (0, 1)', '    (numbers.iter().sum(), numbers.iter().product())',
  "    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)", '    (numbers.iter().sum(), numbers.iter().product())',
  '    unimplemented!()', "    let empty_sum: isize = 0;\n    let empty_product: isize\
    \ = 1;\n    if numbers.len() == 0 {\n        return (empty_sum, empty_product);\n\
    \    } else {\n        let mut sum: isize = empty_sum;\n        let mut product:\
    \ isize = empty_product;\n        for number in numbers {\n            sum +=\
    \ number;\n            product *= number;\n        }\n        return (sum, product);\n\
    \    }", "    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers\
    \ {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)", " \
    \   let mut acc_sum = 0;\n    let mut acc_prod = 1;\n    for n in numbers {\n\
    \        acc_sum += n;\n        acc_prod *= n;\n    }\n    (acc_sum, acc_prod)",
  "    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)",
  "    (\n        numbers.iter().fold(0, |sum, num| sum + num),\n        numbers.iter().fold(1,\
    \ |product, num| product * num),\n    )", "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)", "    let mut res = (0, 1);\n    for n in numbers\
    \ {\n        res.0 += n;\n        res.1 *= n;\n    }\n    res", '    unimplemented!()',
  "    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers {\n      \
    \  sum += n;\n        product *= n;\n    }\n    (sum, product)", "    // TODO:\
    \ Implement function here\n    (0, 0)", "    if numbers.is_empty() {\n       \
    \ return (0, 1);\n    }\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)", '    (numbers.iter().sum(), numbers.iter().product())',
  '    (0, 0)', "    let mut sum = 0;\n    let mut product = 1;\n    for i in numbers\
    \ {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)", " \
    \   if numbers.is_empty() {\n        return (0, 1);\n    }\n\n    let mut product\
    \ = 1;\n    let mut sum = 0;\n\n    for number in numbers {\n        product *=\
    \ number;\n        sum += number;\n    }\n\n    (sum, product)", "    let sum\
    \ = numbers.iter().fold(0, |acc, &x| acc + x);\n    let product = numbers.iter().fold(1,\
    \ |acc, &x| acc * x);\n    (sum, product)", "    let mut sum = 0;\n    let mut\
    \ product = 1;\n    for n in numbers {\n        sum += n;\n        product *=\
    \ n;\n    }\n    (sum, product)", "    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)",
  "    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers {\n      \
    \  sum += n;\n        product *= n;\n    }\n    (sum, product)", '    unimplemented!()',
  '    (numbers.iter().sum(), numbers.iter().product())', "    (\n        numbers.iter().sum(),\n\
    \        numbers.iter().product(),\n    )", "    // write your code here\n   \
    \ (0, 0)", '    unimplemented!()', '    return (0, 1);', "    let mut sum = 0;\n\
    \    let mut product = 1;\n    for i in numbers {\n        sum += i;\n       \
    \ product *= i;\n    }\n    (sum, product)", "    let mut sum = 0;\n    let mut\
    \ product = 1;\n    for n in numbers {\n        sum += n;\n        product *=\
    \ n;\n    }\n    (sum, product)", "    // Write your code here\n    (0, 0)", " \
    \   if numbers.is_empty() {\n        return (0, 1);\n    }\n    let mut sum =\
    \ 0;\n    let mut product = 1;\n    for num in numbers {\n        sum += num;\n\
    \        product *= num;\n    }\n    (sum, product)", "    let sum = numbers.iter().sum();\n\
    \    let product = numbers.iter().product();\n    (sum, product)", '    (0, 1)',
  '    (0, 1)', "    let mut sum = 0;\n    let mut product = 1;\n    for num in numbers\
    \ {\n        sum += num;\n        product *= num;\n    }\n    (sum, product)",
  "    let v = if numbers.is_empty() {\n        vec![0, 1]\n    } else {\n       \
    \ vec![numbers.iter().sum(), numbers.iter().product()]\n    };\n    (v[0], v[1])",
  "    let mut sum = 0;\n    let mut product = 1;\n    for i in &numbers {\n     \
    \   sum += i;\n        product *= i;\n    }\n    (sum, product)", "    (\n   \
    \     numbers.iter().sum(),\n        numbers.iter().product(),\n    )", "    let\
    \ mut sum = 0;\n    let mut product = 1;\n    for num in numbers {\n        sum\
    \ += num;\n        product *= num;\n    }\n    (sum, product)", '    numbers.iter().fold((0,
    1), |acc, &x| (acc.0 + x, acc.1 * x))', '    unimplemented!()', "    if numbers.is_empty()\
    \ {\n        return (0, 1);\n    }\n    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n   \
    \ }\n    (sum, product)", '    numbers.iter().fold((0, 1), |(sum, product), &x|
    (sum + x, product * x))', "    let sum = numbers.iter().sum();\n    let product\
    \ = numbers.iter().product();\n    (sum, product)", "    if numbers.is_empty()\
    \ {\n        return (0, 1);\n    }\n    let (sum, product) = numbers.iter().fold((0,\
    \ 1), |(a, b), c| (a + c, b * c));\n    (sum, product)", "    let mut sum = 0;\n\
    \    let mut product = 1;\n    for i in numbers {\n        sum += i;\n       \
    \ product *= i;\n    }\n    (sum, product)", '    unimplemented!();', "    //\
    \ TODO\n    let mut sum = 0;\n    let mut product = 1;\n    for i in numbers {\n\
    \        sum += i;\n        product *= i;\n    }\n    (sum, product)", '    numbers.iter().fold((0,
    1), |(a, b), x| (a + x, b * x))', "    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)",
  "    // iterator over the vector can be defined with\n    // let mut iter = numbers.iter();\n\
    \    // let sum = iter.sum();\n    // let product = iter.product();\n    // (sum,\
    \ product)\n    // but it leads to wasted computational resources.\n    //\n \
    \   // An alternative solution is to use fold method\n    // let (sum, product)\
    \ = numbers.iter().fold((0, 1), |(sum, product), &x| (sum + x, product * x));\n\
    \    // but it is less readable.\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for x in numbers {\n        sum += x;\n        product *= x;\n    }\n\
    \    (sum, product)", "    // unimplemented!()\n    let sum = numbers.iter().fold(0,\
    \ |acc, n| acc + n);\n    let product = numbers.iter().fold(1, |acc, n| acc *\
    \ n);\n    (sum, product)", '    unimplemented!()', '    unimplemented!();', " \
    \   let mut sum = 0;\n    let mut product = 1;\n    for n in numbers {\n     \
    \   sum += n;\n        product *= n;\n    }\n    (sum, product)", "    // TODO:\
    \ use fold\n    unimplemented!();", "    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n\n    let (sum, product) = numbers.iter().fold((0, 1), |acc,\
    \ &x| (acc.0 + x, acc.1 * x));\n    (sum, product)", "    if numbers.is_empty()\
    \ {\n        return (0, 1);\n    }\n    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n   \
    \ }\n    (sum, product)", "    // Todo: implement this function\n    unimplemented!();",
  "    let mut sum = 0;\n    let mut product = 1;\n    for number in numbers {\n \
    \       sum += number;\n        product *= number;\n    }\n    (sum, product)",
  '    numbers.iter().fold((0, 1), |acc, &num| (acc.0 + num, acc.1 * num))', "   \
    \ let mut sum = 0;\n    let mut product = 1;\n    for number in numbers {\n  \
    \      sum += number;\n        product *= number;\n    }\n    (sum, product)",
  '    numbers.iter().fold((0, 1), |(sum, product), number| (sum + number, product
    * number))', "    let mut sum = 0;\n    let mut product = 1;\n    for &n in numbers.iter()\
    \ {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)", " \
    \   (\n        numbers.iter().sum(),\n        numbers.iter().product()\n    )",
  "    // Rust doc refers to the value of references as owned values, Borrowed values\
    \ and\n    // temporarily borrowed values.\n    // Owned values are what most\
    \ people mean when they say \u201Cvalue\u201D; the values which come from\n  \
    \  // variable bindings and that are moved around by assignment.\n    // Borrowed\
    \ values, on the other hand, are values that reference a memory location. A borrowed\n\
    \    // value can be read from and written to just like owned values, but they\
    \ don\u2019t have an owner\n    // and they can\u2019t be moved, so they must\
    \ always be returned with their original binding.\n    // Borrowed values can\
    \ be split into two categories:\n    // 1. Immutable borrows, which are references\
    \ to a value that can\u2019t be written to; and\n    // 2. Mutable borrows, which\
    \ are references to a value that can be written to.\n\n    // A temporary borrowed\
    \ value is either a borrowed value or an owned value which is implicitly\n   \
    \ // converted to a borrowed value, either because there is no way to move it\
    \ or because the\n    // programmer has explicitly given up the value\u2019s ownership\
    \ by passing it by reference to\n    // some function.\n\n    // When a temporary\
    \ borrowed value is implicitly converted to a borrowed value, it has the\n   \
    \ // lifetime of the reference it was converted to.\n    let mut result: (isize,\
    \ isize) = (0, 1);\n    for i in numbers {\n        result.0 += i;\n        result.1\
    \ *= i;\n    }\n    result", "    let mut sum = 0;\n    let mut product = 1;\n\
    \    for number in numbers {\n        sum += number;\n        product *= number;\n\
    \    }\n    (sum, product)", '    unimplemented!()', "    let mut sum = 0;\n \
    \   let mut product = 1;\n    for number in numbers {\n        sum += number;\n\
    \        product *= number;\n    }\n    (sum, product)", '    numbers.iter().fold((0,
    1), |acc, &x| (acc.0 + x, acc.1 * x))', "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n   \
    \ }\n    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n  \
    \  for num in numbers {\n        sum += num;\n        product *= num;\n    }\n\
    \    (sum, product)", '    numbers.iter().fold((0, 1), |acc, n| (acc.0 + n, acc.1
    * n))', "    (\n        numbers.iter().fold(0, |sum, &x| sum + x),\n        numbers.iter().fold(1,\
    \ |sum, &x| sum * x),\n    )", "    let mut sum = 0;\n    let mut product = 1;\n\
    \    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n   \
    \ (sum, product)", "    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let prod = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, prod)", " \
    \   (\n        numbers.iter().sum(),\n        numbers.iter().product()\n    )",
  "    // TODO: implement function\n    unimplemented!()", "    let mut sum = 0;\n\
    \    let mut product = 1;\n    for num in numbers {\n        sum += num;\n   \
    \     product *= num;\n    }\n    (sum, product)", "    let (mut sum, mut product)\
    \ = (0, 1);\n    for number in numbers {\n        sum += number;\n        product\
    \ *= number;\n    }\n    (sum, product)", "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n   \
    \ }\n    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n  \
    \  for num in numbers {\n        sum += num;\n        product *= num;\n    }\n\
    \    (sum, product)", "    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \n    (sum, product)", "    // It's not hard to do this without `fold`, but fold\
    \ is cool.\n    numbers.iter().fold((0, 1), |acc, n| (acc.0 + n, acc.1 * n))",
  "    if numbers.is_empty() {\n        return (0, 1);\n    }\n    numbers.iter().fold((0,\
    \ 1), |acc, &item| (acc.0 + item, acc.1 * item))", '    numbers.iter().fold((0,
    1), |acc, x| (acc.0 + x, acc.1 * x))', "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n   \
    \ }\n    (sum, product)", "    // get an iterator over all the numbers and aggregate\
    \ it\n    numbers.iter().fold((0, 1), |(acc_sum, acc_prod), num| {\n        (acc_sum\
    \ + num, acc_prod * num)\n    })", '    unimplemented!()', '    (0, 1)', "   \
    \ let mut product = 1;\n    let mut sum = 0;\n    for num in numbers {\n     \
    \   product *= num;\n        sum += num;\n    }\n    (sum, product)", "    let\
    \ mut sum = 0;\n    let mut product = 1;\n    for x in numbers {\n        sum\
    \ += x;\n        product *= x;\n    }\n    (sum, product)", "    let mut sum =\
    \ 0;\n    let mut product = 1;\n    for i in numbers {\n        sum += i;\n  \
    \      product *= i;\n    }\n    (sum, product)", "    // It is possible to solve\
    \ this problem with an explicit loop.\n    // But I prefer to use the iterator\
    \ API.\n    // The Iterator API is very powerful, and it is used almost everywhere\
    \ in Rust.\n    //\n    // Hint: if you're wondering how to compute a product\
    \ of integers, look at std::iter::Product.\n    (\n        numbers.iter().sum(),\n\
    \        numbers.iter().product(),\n    )", '    (0, 1)', "    let (mut sum, mut\
    \ product) = (0, 1);\n    for i in numbers {\n        sum += i;\n        product\
    \ *= i;\n    }\n    (sum, product)", "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)", '    (numbers.iter().sum(), numbers.iter().product())',
  "    let (mut sum, mut product) = (0, 1);\n    for n in numbers {\n        sum +=\
    \ n;\n        product *= n;\n    }\n    (sum, product)", "    if numbers.is_empty()\
    \ {\n        return (0, 1);\n    }\n\n    let mut sum = 0;\n    let mut product\
    \ = 1;\n\n    for number in numbers {\n        sum += number;\n        product\
    \ *= number;\n    }\n\n    (sum, product)", "    let mut sum = 0;\n    let mut\
    \ product = 1;\n    for i in numbers {\n        sum += i;\n        product *=\
    \ i;\n    }\n    (sum, product)", "    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)", '    unimplemented!()', '    unimplemented!()',
  "    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)", "    // return (numbers.iter().sum(), numbers.iter().product());\n\
    \    (numbers.iter().sum(), numbers.iter().product())", "    let mut sum = 0;\n\
    \    let mut product = 1;\n    for n in numbers {\n        sum += n;\n       \
    \ product *= n;\n    }\n    (sum, product)", "    let mut product = 1;\n    let\
    \ mut sum = 0;\n    for number in numbers {\n        product *= number;\n    \
    \    sum += number;\n    }\n    (sum, product)", "    (\n        numbers.iter().sum(),\n\
    \        numbers.iter().product(),\n    )", "    (\n        numbers.iter().sum(),\n\
    \        numbers.iter().product(),\n    )", '    unimplemented!()', "    let sum\
    \ = numbers.iter().sum();\n    let product = numbers.iter().product();\n    (sum,\
    \ product)", '    unimplemented!()', "    let sum = numbers.iter().sum();\n  \
    \  let product = numbers.iter().product();\n    (sum, product)", "    if numbers.is_empty()\
    \ {\n        return (0, 1);\n    }\n    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n   \
    \ }\n    (sum, product)", '    (numbers.iter().fold(0, |sum, i| sum + i), numbers.iter().fold(1,
    |prod, i| prod * i))', '    (numbers.iter().sum(), numbers.iter().product())',
  "    let mut sum = 0;\n    let mut product = 1;\n    for number in numbers {\n \
    \       sum += number;\n        product *= number;\n    }\n    (sum, product)",
  "    if numbers.is_empty() {\n        return (0, 1);\n    }\n    let mut sum = 0;\n\
    \    let mut product = 1;\n    for num in numbers {\n        sum += num;\n   \
    \     product *= num;\n    }\n    (sum, product)", "    let sum = numbers.iter().sum();\n\
    \    let product = numbers.iter().product();\n    (sum, product)", "    let mut\
    \ sum = 0;\n    let mut product = 1;\n    for num in numbers {\n        sum +=\
    \ num;\n        product *= num;\n    }\n    (sum, product)", '    (numbers.iter().sum(),
    numbers.iter().product())', "    let sum = numbers.iter().sum();\n    let product\
    \ = numbers.iter().product();\n    (sum, product)", '    (numbers.iter().sum(),
    numbers.iter().product())', "    let sum = numbers.iter().sum();\n    let product\
    \ = numbers.iter().product();\n    (sum, product)", "    let sum = numbers.iter().sum();\n\
    \    let product = numbers.iter().product();\n    (sum, product)", '    unimplemented!();',
  "    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n    let product = numbers.iter().fold(1,\
    \ |acc, x| acc * x);\n    (sum, product)", '    (numbers.iter().sum(), numbers.iter().product())',
  "    let sum = numbers.iter().fold(0, |acc, i| acc + i);\n    let product = numbers.iter().fold(1,\
    \ |acc, i| acc * i);\n    (sum, product)", "    let mut sum = 0;\n    let mut\
    \ product = 1;\n    for number in numbers {\n        sum += number;\n        product\
    \ *= number;\n    }\n    (sum, product)", "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n\
    \    for number in numbers {\n        sum += number;\n        product *= number;\n\
    \    }\n    (sum, product)", "    let mut product = 1;\n    let mut sum = 0;\n\
    \    for number in numbers {\n        product *= number;\n        sum += number;\n\
    \    }\n    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n\
    \    for number in numbers {\n        sum += number;\n        product *= number;\n\
    \    }\n    (sum, product)", '    numbers.iter().fold((0, 1), |(acc_sum, acc_prod),
    &val| (acc_sum + val, acc_prod * val))', '    (numbers.iter().fold(0, |acc, &x|
    acc + x), numbers.iter().fold(1, |acc, &x| acc * x))', "    let sum = numbers.iter().sum();\n\
    \    let product = numbers.iter().product();\n    (sum, product)", "    let (mut\
    \ sum, mut product) = (0, 1);\n    for i in numbers {\n        sum += i;\n   \
    \     product *= i;\n    }\n    (sum, product)", "    let mut sum = 0;\n    let\
    \ mut product = 1;\n    for number in numbers {\n        sum += number;\n    \
    \    product *= number;\n    }\n    (sum, product)", "    let mut sum = 0;\n \
    \   let mut product = 1;\n    for n in numbers {\n        sum += n;\n        product\
    \ *= n;\n    }\n    (sum, product)", "    let v: (isize, isize) = numbers.iter().fold((0,\
    \ 1), |acc, num| (acc.0 + num, acc.1 * num));\n    v", '    numbers.iter().fold((0,
    1), |(sum, prod), &n| (sum + n, prod * n))', "    let sum = numbers.iter().sum();\n\
    \    let product = numbers.iter().product();\n    (sum, product)", "    let mut\
    \ sum = 0;\n    let mut product = 1;\n    for number in numbers {\n        sum\
    \ += number;\n        product *= number;\n    }\n    (sum, product)", '    unimplemented!();',
  '    (0, 1)', "    if numbers.is_empty() {\n        return (0, 1);\n    }\n\n  \
    \  let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \n    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)", "    let mut sum = 0;\n    let mut product = 1;\n    for num in numbers\
    \ {\n        sum += num;\n        product *= num;\n    }\n    (sum, product)",
  "    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n    )",
  "    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)", '    unimplemented!();', '    (0, 1)', '    (0, 1)', " \
    \   let mut product = 1;\n    let mut sum = 0;\n    for x in numbers {\n     \
    \   product *= x;\n        sum += x;\n    }\n    (sum, product)", "    // implement\
    \ this function here\n    // use it to pass the test\n    (0, 0)", "    let sum\
    \ = numbers.iter().sum();\n    let product = numbers.iter().product();\n    (sum,\
    \ product)", "    // YOUR CODE HERE\n    panic!(\"Not implemented\")", '    (numbers.iter().fold(0,
    |acc, x| acc + x), numbers.iter().fold(1, |acc, x| acc * x))', '    numbers.iter().fold((0,
    1), |acc, x| (acc.0 + x, acc.1 * x))', "    (\n        numbers.iter().sum(),\n\
    \        numbers.iter().product(),\n    )", "    (\n        numbers.iter().sum(),\n\
    \        numbers.iter().product(),\n    )", "    let sum = numbers.iter().sum();\n\
    \    let product = numbers.iter().product();\n    (sum, product)", '    unimplemented!();',
  "    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)", "    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)", '    numbers.iter().fold((0,
    1), |acc, x| (acc.0 + x, acc.1 * x))', "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)", '    unimplemented!();', "    // TODO: implement\
    \ the function\n    (0, 0)", '    (numbers.iter().sum(), numbers.iter().product())',
  "    let mut sum = 0;\n    let mut product = 1;\n    for i in numbers {\n      \
    \  sum += i;\n        product *= i;\n    }\n    (sum, product)", "    let sum\
    \ = numbers.iter().sum();\n    let product = numbers.iter().product();\n    (sum,\
    \ product)", "    // TODO: Implement it\n    (0, 1)", "    if numbers.is_empty()\
    \ {\n        return (0, 1);\n    }\n    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)", "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n   \
    \ }\n    (sum, product)"]
stop_tokens:
- "\n}"
