name: HumanEval_56_correct_bracketing
language: rs
prompt: "/// brackets is a string of \"<\" and \">\".\n/// return true if every opening\
  \ bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
  <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n///\
  \ >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
  ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
  <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n   \
  \ assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
  <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
  <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
  \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
  <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
  <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
  \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
  }\n"
completions: ["    let mut stack = vec![];\n    for b in brackets.chars() {\n    \
    \    match b {\n            '<' => stack.push(b),\n            '>' => {\n    \
    \            match stack.pop() {\n                    Some(x) => {\n         \
    \               if x != '<' {\n                            return false;\n   \
    \                     }\n                    }\n                    None => return\
    \ false,\n                }\n            }\n            _ => (),\n        }\n\
    \    }\n    if stack.len() == 0 {\n        return true;\n    }\n    false", " \
    \   // TODO\n    false", "    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push(ch),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                if let Some('<') = stack.pop() {\n       \
    \             continue;\n                } else {\n                    return\
    \ false;\n                }\n            }\n            _ => continue,\n     \
    \   }\n    }\n    if stack.is_empty() {\n        true\n    } else {\n        false\n\
    \    }", "    let mut stack = Stack::new();\n    for b in brackets.chars() {\n\
    \        match b {\n            '<' => stack.push('<'),\n            '>' => {\n\
    \                if stack.is_empty() {\n                    return false;\n  \
    \              }\n                if stack.pop().unwrap() != '<' {\n         \
    \           return false;\n                }\n            }\n            _ =>\
    \ return false,\n        }\n    }\n    stack.is_empty()", "    if brackets.len()\
    \ == 0 {\n        return true;\n    }\n    let mut result = vec![];\n    for c\
    \ in brackets.chars() {\n        if c == '<' {\n            result.push(c);\n\
    \        } else if c == '>' {\n            if result.pop() != Some('<') {\n  \
    \              return false;\n            }\n        }\n    }\n    result.len()\
    \ == 0", "    let mut stack = Stack::new();\n    for b in brackets.chars() {\n\
    \        match b {\n            '<' => stack.push('<'),\n            '>' => match\
    \ stack.pop() {\n                None => return false,\n                Some(_)\
    \ => (),\n            },\n            _ => (),\n        }\n    }\n    if stack.len()\
    \ == 0 {\n        true\n    } else {\n        false\n    }", "    let mut count\
    \ = 0;\n    for c in brackets.chars() {\n        match c {\n            '<' =>\
    \ count += 1,\n            '>' => count -= 1,\n            _ => panic!(\"Illegal\
    \ character: {}\", c),\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0", "    let mut left_open_count = 0;\n\
    \    for character in brackets.chars() {\n        if character == '<' {\n    \
    \        left_open_count += 1;\n        } else if character == '>' {\n       \
    \     left_open_count -= 1;\n        }\n        if left_open_count < 0 {\n   \
    \         return false;\n        }\n    }\n    left_open_count == 0", "    let\
    \ mut input = brackets.chars();\n    let mut stack = Vec::new();\n    while let\
    \ Some(c) = input.next() {\n        match c {\n            '<' => stack.push(c),\n\
    \            '>' => match stack.pop() {\n                Some('<') => (),\n  \
    \              _ => return false,\n            },\n            _ => return false,\n\
    \        }\n    }\n    if stack.len() == 0 {\n        true\n    } else {\n   \
    \     false\n    }", "    let mut open_brackets = 0;\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            open_brackets += 1;\n        } else\
    \ if bracket == '>' {\n            open_brackets -= 1;\n        }\n        if\
    \ open_brackets < 0 {\n            return false;\n        }\n    }\n    return\
    \ open_brackets == 0;", "    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.pop() != Some('<') {\n                    return\
    \ false;\n                }\n            }\n            _ => return false,\n \
    \       }\n    }\n    stack.is_empty()", "    let mut bracket_count = 0;\n   \
    \ for letter in brackets.chars() {\n        match letter {\n            '<' =>\
    \ bracket_count += 1,\n            '>' => bracket_count -= 1,\n            _ =>\
    \ panic!(\"invalid bracket\"),\n        }\n        if bracket_count < 0 {\n  \
    \          return false;\n        }\n    }\n    return bracket_count == 0;", " \
    \   let mut bracket_stack: Vec<&str> = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => bracket_stack.push(\"<\"),\n     \
    \       '>' => {\n                if bracket_stack.is_empty() {\n            \
    \        return false;\n                }\n                if bracket_stack.pop()\
    \ != Some(&\"<\") {\n                    return false;\n                }\n  \
    \          }\n            _ => {}\n        }\n    }\n    bracket_stack.is_empty()",
  "    let mut count: i32 = 0;\n    for _x in brackets.chars() {\n        if _x ==\
    \ '<' {\n            count += 1;\n        } else if _x == '>' {\n            count\
    \ -= 1;\n        }\n        if count < 0 {\n            return false;\n      \
    \  }\n    }\n    count == 0", "    let mut bracket_stack: Vec<char> = Vec::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    bracket_stack.push(bracket);\n        } else if bracket == '>' {\n      \
    \      if bracket_stack.len() > 0 {\n                bracket_stack.pop();\n  \
    \          } else {\n                return false;\n            }\n        }\n\
    \    }\n    return bracket_stack.len() == 0;", "    let mut tracker = 0;\n   \
    \ for c in brackets.chars() {\n        if c == '<' {\n            tracker += 1;\n\
    \        } else if c == '>' {\n            tracker -= 1;\n        }\n        if\
    \ tracker < 0 {\n            return false;\n        }\n    }\n    tracker == 0",
  "    if brackets.is_empty() {\n        return true;\n    }\n    let mut v: Vec<char>\
    \ = vec![];\n    for c in brackets.chars() {\n        match c {\n            '<'\
    \ => v.push(c),\n            '>' => match v.pop() {\n                Some(a) =>\
    \ if a != '<' {\n                    return false;\n                },\n     \
    \           None => return false,\n            },\n            _ => return false,\n\
    \        }\n    }\n    if v.is_empty() {\n        return true;\n    }\n    false",
  "    let mut iter = brackets.chars();\n    let mut stack = Vec::new();\n    while\
    \ let Some(b) = iter.next() {\n        match b {\n            '<' => stack.push(b),\n\
    \            '>' => {\n                if stack.pop() != Some('<') {\n       \
    \             return false;\n                }\n            }\n            _ =>\
    \ unreachable!(),\n        }\n    }\n    stack.is_empty()", "    let mut balance\
    \ = 0;\n    for bracket in brackets.chars() {\n        match bracket {\n     \
    \       '<' => balance += 1,\n            '>' => balance -= 1,\n            _\
    \ => (),\n        }\n        if balance < 0 {\n            return false;\n   \
    \     }\n    }\n    return balance == 0;", "    let mut stack = Vec::new();\n\
    \    for ch in brackets.chars() {\n        match ch {\n            '<' => stack.push(ch),\n\
    \            '>' => {\n                if stack.pop() != Some('<') {\n       \
    \             return false;\n                }\n            }\n            _ =>\
    \ return false,\n        }\n    }\n    stack.is_empty()"]
stop_tokens:
- "\n}"
