name: HumanEval_141_file_name_check
language: rs
prompt: "/// Create a function which takes a string representing a file's name, and\
  \ returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
  /// A file's name is considered to be valid if and only if all the following conditions\
  \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
  \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The\
  \ substring before the dot should not be empty, and it starts with a letter from\
  \ \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the\
  \ dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>> file_name_check(String::from(\"\
  example.txt\"))\n/// String::from(\"Yes\")\n/// >>> file_name_check(String::from(\"\
  1example.dll\"))\n/// String::from(\"No\")\nfn file_name_check(file_name: String)\
  \ -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
  example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
  1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
  s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
  K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"\
  No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n\
  }\n"
completions: ["    if file_name.matches(char::is_numeric).count() > 3 {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name.matches('.').count() != 1 {\n\
    \        return String::from(\"No\");\n    }\n    let file_name_split: Vec<&str>\
    \ = file_name.split('.').collect();\n    if file_name_split[0].is_empty() || !file_name_split[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n    match file_name_split[1]\
    \ {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _\
    \ => String::from(\"No\"),\n    }", "    // Take care of the following case: when\
    \ the input is an empty string,\n    // the file name is valid.\n    if file_name.is_empty()\
    \ {\n        return String::from(\"Yes\");\n    }\n\n    // Check if there are\
    \ more than three digits in the file name.\n    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n\n    // Check if the file's\
    \ name contains exactly one dot '.'\n    let mut num_of_dots = 0;\n    for ch\
    \ in file_name.chars() {\n        if ch == '.' {\n            num_of_dots += 1;\n\
    \        }\n    }\n    if num_of_dots != 1 {\n        return String::from(\"No\"\
    );\n    }\n\n    // Check if the substring before the dot start with a latin letter.\n\
    \    let sub_str_before_dot: Vec<char> = file_name.chars().take_while(|ch| *ch\
    \ != '.').collect();\n    if !sub_str_before_dot.is_empty() && sub_str_before_dot[0].is_ascii_alphabetic()\
    \ {\n        // Check if the substring after the dot is one of the following:\n\
    \        // ['txt', 'exe', 'dll']\n        let sub_str_after_dot: Vec<char> =\
    \ file_name.chars().skip_while(|ch| *ch != '.').collect();\n        if sub_str_after_dot.len()\
    \ > 1 && (sub_str_after_dot[1] == 't' || sub_str_after_dot[1] == 'e' || sub_str_after_dot[1]\
    \ == 'd') {\n            return String::from(\"Yes\");\n        }\n    }\n\n \
    \   String::from(\"No\")", "    let file_name_chars: Vec<char> = file_name.chars().collect();\n\
    \    let mut has_dot = false;\n    let mut name_char_count = 0;\n    let mut digit_count\
    \ = 0;\n    let mut last_dot_index = 0;\n    for (i, c) in file_name_chars.iter().enumerate()\
    \ {\n        match c {\n            '.' => {\n                has_dot = true;\n\
    \                last_dot_index = i;\n            },\n            _ => {},\n \
    \       }\n        if c.is_ascii_digit() {\n            digit_count += 1;\n  \
    \      }\n        if c.is_ascii_alphabetic() {\n            name_char_count +=\
    \ 1;\n        }\n    }\n    if !has_dot ||\n        digit_count > 3 ||\n     \
    \   name_char_count == 0 ||\n        file_name_chars[last_dot_index + 1..].len()\
    \ != 3 {\n        return String::from(\"No\");\n    }\n    let file_type: Vec<char>\
    \ = file_name_chars[last_dot_index + 1..].to_vec();\n    let file_type_str: String\
    \ = file_type.into_iter().collect();\n    match file_type_str.as_str() {\n   \
    \     \"txt\" | \"exe\" | \"dll\" => return String::from(\"Yes\"),\n        _\
    \ => return String::from(\"No\"),\n    }", "    let patterns = vec![\n       \
    \ Regex::new(r\"^[a-zA-Z]+[\\w]*\\.[a-zA-Z]+$\").unwrap(),\n        Regex::new(r\"\
    ^[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\w]*\\.[a-zA-Z]+$\").unwrap(),\n        Regex::new(r\"\
    ^[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\w]*\\.[a-zA-Z]+$\").unwrap(),\n\
    \    ];\n    if patterns.iter().any(|pattern| pattern.is_match(&file_name)) {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }",
  '    unimplemented!();', "    lazy_static! {\n        static ref VALID_SUFFIXES:\
    \ HashSet<&'static str> = {\n            let mut suffixes = HashSet::new();\n\
    \            suffixes.insert(\"txt\");\n            suffixes.insert(\"exe\");\n\
    \            suffixes.insert(\"dll\");\n            suffixes\n        };\n   \
    \ }\n\n    // As per the spec, it's guaranteed that the file name contains exactly\
    \ one dot '.'.\n    let dot_index = file_name.find('.').unwrap();\n    let pre_dot\
    \ = &file_name[..dot_index];\n    let post_dot = &file_name[dot_index + 1..];\n\
    \n    // Check if the prefix is empty.\n    if pre_dot.is_empty() {\n        return\
    \ String::from(\"No\");\n    }\n\n    // Check if the prefix contains any digits.\n\
    \    if !pre_dot.chars().all(|ch| !ch.is_digit(10)) {\n        return String::from(\"\
    No\");\n    }\n\n    // Check if the prefix starts with a letter in the latin\
    \ alphabet.\n    if !pre_dot.chars().next().unwrap().is_ascii_alphabetic() {\n\
    \        return String::from(\"No\");\n    }\n\n    // Check if the suffix is\
    \ valid.\n    if !VALID_SUFFIXES.contains(post_dot) {\n        return String::from(\"\
    No\");\n    }\n\n    String::from(\"Yes\")", '    unimplemented!();', "    let\
    \ mut digits_found = 0;\n    let mut dot_found = false;\n    let mut valid_extensions\
    \ = vec![\"txt\", \"exe\", \"dll\"];\n    for c in file_name.chars() {\n     \
    \   match c {\n            '0'...'9' => digits_found += 1,\n            '.' =>\
    \ dot_found = true,\n            _ => (),\n        }\n    }\n    if digits_found\
    \ > 3 || !dot_found {\n        return String::from(\"No\");\n    }\n    let parts:\
    \ Vec<&str> = file_name.split('.').collect();\n    if parts.len() != 2 {\n   \
    \     return String::from(\"No\");\n    }\n    if parts[0].len() == 0 || !(parts[0].chars().next().unwrap().is_alphabetic())\
    \ {\n        return String::from(\"No\");\n    }\n    if valid_extensions.iter().find(|&s|\
    \ s == parts[1]).is_none() {\n        return String::from(\"No\");\n    }\n  \
    \  String::from(\"Yes\")", "    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    let mut dot_idx = 0;\n\
    \    for (idx, ch) in file_name.chars().enumerate() {\n        if ch == '.' {\n\
    \            dot_idx = idx;\n            break;\n        }\n    }\n    let mut\
    \ after_dot = file_name[dot_idx + 1..].to_string();\n    if file_name.matches('.').count()\
    \ != 1 || after_dot.len() > 3 || dot_idx == 0 {\n        return String::from(\"\
    No\");\n    }\n    after_dot = after_dot.chars().take(3).collect();\n    if !((after_dot\
    \ == \"txt\") || (after_dot == \"exe\") || (after_dot == \"dll\")) {\n       \
    \ return String::from(\"No\");\n    }\n    let mut before_dot = file_name[..dot_idx].to_string();\n\
    \    before_dot = before_dot.chars().take(1).collect();\n    if !((before_dot\
    \ >= \"a\" && before_dot <= \"z\") || (before_dot >= \"A\" && before_dot <= \"\
    Z\")) {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");", "    let mut digits_count = 0;\n    let mut dot_count = 0;\n    let\
    \ mut file_type_check = false;\n    let file_type_check_list = [\"txt\", \"exe\"\
    , \"dll\"];\n    let mut char_iter = file_name.chars();\n    let mut char_count\
    \ = 0;\n    let mut alpha_digit_count = 0;\n    let mut first_dot_pos = 0;\n \
    \   let mut second_dot_pos = 0;\n    let mut alpha_valid = false;\n    for c in\
    \ char_iter {\n        if !file_type_check {\n            if c.is_ascii_digit()\
    \ {\n                if char_count == 0 {\n                    return String::from(\"\
    No\");\n                }\n                digits_count += 1;\n              \
    \  if digits_count > 3 {\n                    return String::from(\"No\");\n \
    \               }\n            } else if c == '.' {\n                dot_count\
    \ += 1;\n                if dot_count == 1 {\n                    first_dot_pos\
    \ = char_count;\n                } else if dot_count == 2 {\n                \
    \    second_dot_pos = char_count;\n                } else {\n                \
    \    return String::from(\"No\");\n                }\n            } else if c.is_ascii_alphabetic()\
    \ {\n                alpha_digit_count += 1;\n                if char_count ==\
    \ 0 {\n                    alpha_valid = true;\n                }\n          \
    \  } else {\n                return String::from(\"No\");\n            }\n   \
    \         if dot_count == 2 {\n                if second_dot_pos - first_dot_pos\
    \ == 4 {\n                    let mut file_type_check_str = String::new();\n \
    \                   file_type_check_str.push(file_name.chars().nth(first_dot_pos\
    \ + 1).unwrap());\n                    file_type_check_str.push(file_name.chars().nth(first_dot_pos\
    \ + 2).unwrap());\n                    file_type_check_str.push(file_name.chars().nth(first_dot_pos\
    \ + 3).unwrap());\n                    for i in file_type_check_list.iter() {\n\
    \                        if file_", "    if file_name.len() < 3 {\n        return\
    \ String::from(\"No\");\n    }\n    let file_name_chars: Vec<char> = file_name.chars().collect();\n\
    \    let mut count_digits = 0;\n    let mut dot_pos = 0;\n    for (i, char) in\
    \ file_name_chars.iter().enumerate() {\n        if char.is_digit(10) {\n     \
    \       count_digits += 1;\n        }\n        if *char == '.' {\n           \
    \ dot_pos = i;\n        }\n    }\n    if count_digits > 3 {\n        return String::from(\"\
    No\");\n    }\n    if dot_pos == 0 || dot_pos == file_name.len() - 1 {\n     \
    \   return String::from(\"No\");\n    }\n    let extension = file_name_chars[dot_pos\
    \ + 1..].iter().collect::<String>();\n    if extension != \"txt\" && extension\
    \ != \"exe\" && extension != \"dll\" {\n        return String::from(\"No\");\n\
    \    }\n    if file_name_chars[..dot_pos].iter().all(|c| c.is_alphabetic()) {\n\
    \        return String::from(\"Yes\");\n    }\n    String::from(\"No\")", "  \
    \  let mut digits_counter = 0;\n    let mut dot_counter = 0;\n    let mut char_counter\
    \ = 0;\n    let mut file_start_with_letter = false;\n    let mut file_end_with_txt_exe_dll\
    \ = false;\n    let mut char_iter = file_name.chars();\n    let mut char_before_dot\
    \ = Vec::new();\n    let mut char_after_dot = Vec::new();\n    for c in char_iter\
    \ {\n        char_counter += 1;\n        if c.is_digit(10) {\n            digits_counter\
    \ += 1;\n        } else if c == '.' {\n            dot_counter += 1;\n       \
    \ } else if dot_counter == 0 {\n            char_before_dot.push(c);\n       \
    \ } else if dot_counter == 1 {\n            char_after_dot.push(c);\n        }\n\
    \    }\n    let after_dot_str = char_after_dot.iter().collect::<String>();\n \
    \   if char_counter <= 3 {\n        file_start_with_letter = true;\n    } else\
    \ if char_before_dot[0].is_ascii_alphabetic() {\n        file_start_with_letter\
    \ = true;\n    }\n    if after_dot_str == \"txt\" || after_dot_str == \"exe\"\
    \ || after_dot_str == \"dll\" {\n        file_end_with_txt_exe_dll = true;\n \
    \   }\n    if digits_counter <= 3 && dot_counter == 1 && file_start_with_letter\
    \ && file_end_with_txt_exe_dll {\n        return String::from(\"Yes\");\n    }\
    \ else {\n        return String::from(\"No\");\n    }", "    let mut counter =\
    \ 0;\n    let mut dot_location = 0;\n    let mut is_invalid = false;\n    for\
    \ (i, ch) in file_name.chars().enumerate() {\n        if (ch as u8) >= 0x30 &&\
    \ (ch as u8) <= 0x39 {\n            counter += 1;\n        } else if ch == '.'\
    \ {\n            dot_location = i;\n        } else if i == 0 && !(ch >= 'a' &&\
    \ ch <= 'z' || ch >= 'A' && ch <= 'Z') {\n            is_invalid = true;\n   \
    \     }\n    }\n    if counter > 3 || dot_location == 0 || is_invalid {\n    \
    \    return String::from(\"No\");\n    }\n    let mut valid_extensions = vec![\"\
    txt\", \"exe\", \"dll\"];\n    valid_extensions.sort();\n    let actual_extension\
    \ = &file_name[dot_location + 1..];\n    if valid_extensions.binary_search(&actual_extension).is_err()\
    \ {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")",
  "    let vec: Vec<&str> = file_name.split(\".\").collect();\n    if vec.len() >\
    \ 2 {\n        return String::from(\"No\");\n    }\n    let first_part = vec[0];\n\
    \    let last_part = vec[1];\n    if first_part.len() > 255 {\n        return\
    \ String::from(\"No\");\n    }\n    if last_part != \"txt\" && last_part != \"\
    exe\" && last_part != \"dll\" {\n        return String::from(\"No\");\n    }\n\
    \    let mut is_digit = false;\n    let mut count = 0;\n    for i in first_part.chars()\
    \ {\n        if i.is_digit(10) {\n            is_digit = true;\n            count\
    \ += 1;\n        }\n    }\n    if count > 3 {\n        return String::from(\"\
    No\");\n    }\n    if is_digit {\n        return String::from(\"No\");\n    }\n\
    \    String::from(\"Yes\")", "    let mut digits_count = 0;\n    let mut dot_cnt\
    \ = 0;\n    let mut ext_found = false;\n    let mut upper_found = false;\n   \
    \ let mut valid_ext = false;\n    let mut valid_name = false;\n    let mut name_found\
    \ = false;\n    for c in file_name.chars() {\n        if c.is_digit(10) {\n  \
    \          digits_count += 1;\n        }\n        if c == '.' {\n            dot_cnt\
    \ += 1;\n        }\n        if c == '.' && !ext_found {\n            ext_found\
    \ = true;\n        }\n        if c == '.' && ext_found {\n            valid_ext\
    \ = false;\n        }\n        if ext_found && (c == 'e' || c == 'x' || c == 'd')\
    \ {\n            valid_ext = true;\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            upper_found = true;\n        }\n        if c.is_ascii_lowercase()\
    \ {\n            name_found = true;\n        }\n    }\n    if digits_count <=\
    \ 3 && dot_cnt == 1 && valid_ext && name_found && !upper_found {\n        valid_name\
    \ = true;\n    }\n    if valid_name {\n        return String::from(\"Yes\");\n\
    \    }\n    return String::from(\"No\");", '    String::from("Yes")', "    if\
    \ file_name.len() < 4 {\n        return String::from(\"No\");\n    }\n    let\
    \ mut count = 0;\n    let mut dot_count = 0;\n    let mut valid_after_dot = false;\n\
    \    for i in 0..file_name.len() {\n        let c = file_name.chars().nth(i).unwrap();\n\
    \        if c.is_digit(10) {\n            count += 1;\n        }\n        if c\
    \ == '.' {\n            dot_count += 1;\n        }\n        if dot_count == 1\
    \ {\n            if c == 't' || c == 'e' || c == 'd' {\n                valid_after_dot\
    \ = true;\n            }\n        }\n    }\n    if count > 3 || dot_count != 1\
    \ || !valid_after_dot {\n        return String::from(\"No\");\n    } else {\n\
    \        return String::from(\"Yes\");\n    }", "    let (first_part, last_part)\
    \ = get_parts(file_name);\n    if !is_first_part_valid(first_part) {\n       \
    \ return String::from(\"No\");\n    }\n    if !is_last_part_valid(last_part) {\n\
    \        return String::from(\"No\");\n    }\n    String::from(\"Yes\")", "  \
    \  let re = Regex::new(r\"^[a-zA-Z]{1}[a-zA-Z0-9]{0,2}\\.(txt|exe|dll)$\").unwrap();\n\
    \    if re.is_match(&file_name) {\n        String::from(\"Yes\")\n    } else {\n\
    \        String::from(\"No\")\n    }", "    let mut is_valid: bool = true;\n \
    \   let mut has_dot: bool = false;\n    let mut has_digit: bool = false;\n   \
    \ let mut has_non_digit: bool = false;\n    let mut has_letter: bool = false;\n\
    \    let mut has_txt: bool = false;\n    let mut has_exe: bool = false;\n    let\
    \ mut has_dll: bool = false;\n    let mut dot_index: usize = 0;\n    let mut dot_count:\
    \ usize = 0;\n    let mut extension_index: usize = 0;\n    let mut digit_count:\
    \ usize = 0;\n    let mut extension_count: usize = 0;\n    let mut letter_count:\
    \ usize = 0;\n    for (i, c) in file_name.chars().enumerate() {\n        if has_digit\
    \ && !c.is_digit(10) {\n            has_non_digit = true;\n        }\n       \
    \ if c.is_digit(10) {\n            has_digit = true;\n            digit_count\
    \ += 1;\n        }\n        if !has_dot && c == '.' {\n            has_dot = true;\n\
    \            dot_index = i;\n            dot_count += 1;\n        }\n        if\
    \ !has_letter && c.is_alphabetic() {\n            has_letter = true;\n       \
    \     letter_count += 1;\n        }\n        if has_dot && i > dot_index && c.is_alphabetic()\
    \ {\n            extension_index = i;\n            extension_count += 1;\n   \
    \     }\n        if extension_count == 3 && c == 't' {\n            has_txt =\
    \ true;\n        }\n        if extension_count == 3 && c == 'e' {\n          \
    \  has_exe = true;\n        }\n        if extension_count == 3 && c == 'd' {\n\
    \            has_dll = true;\n        }\n    }\n    is_valid = has_dot && !has_digit\
    \ && has_non_digit && has_letter && (has_txt || has_exe || has_dll) && dot_count\
    \ == 1 && extension_count == 3 && letter_count >= 1 && digit", "    let mut latin_letter\
    \ = false;\n    let mut digits = 0;\n    let mut dot = false;\n    let mut ok_extension\
    \ = false;\n    let mut extension = String::new();\n    for c in file_name.chars()\
    \ {\n        if c == '.' {\n            dot = true;\n        } else if c.is_digit(10)\
    \ {\n            digits += 1;\n        } else if c.is_alphabetic() {\n       \
    \     if !latin_letter {\n                latin_letter = c.is_ascii_alphabetic();\n\
    \            }\n            if !ok_extension {\n                extension.push(c);\n\
    \                ok_extension = match extension.as_str() {\n                 \
    \   \"txt\" | \"exe\" | \"dll\" => true,\n                    _ => false,\n  \
    \              };\n            }\n        }\n    }\n    if digits <= 3 && latin_letter\
    \ && dot && ok_extension {\n        \"Yes\".to_string()\n    } else {\n      \
    \  \"No\".to_string()\n    }", "    let mut count = 0;\n    let mut dot_exists\
    \ = false;\n    let mut sub_string_before_dot = String::new();\n    let mut sub_string_after_dot\
    \ = String::new();\n    for ch in file_name.chars() {\n        if ch == '.' {\n\
    \            dot_exists = true;\n        }\n        if ch.is_digit(10) {\n   \
    \         count += 1;\n        }\n        if dot_exists {\n            sub_string_after_dot.push(ch);\n\
    \        } else {\n            sub_string_before_dot.push(ch);\n        }\n  \
    \  }\n    if count > 3 || !dot_exists || \n        sub_string_before_dot.len()\
    \ == 0 || \n        !sub_string_before_dot.chars().next().unwrap().is_alphabetic()\
    \ || \n        ![\"txt\", \"exe\", \"dll\"].contains(&sub_string_after_dot.as_str())\
    \ {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")",
  "    let mut digits_counter = 0;\n    let mut dot_counter = 0;\n    let mut ext_found\
    \ = false;\n    let mut before_dot_found = false;\n    let mut after_dot_found\
    \ = false;\n    let file_name = file_name.as_bytes();\n    for i in 0..file_name.len()\
    \ {\n        match file_name[i] {\n            b'0'..=b'9' => {\n            \
    \    digits_counter += 1;\n                if digits_counter > 3 {\n         \
    \           return String::from(\"No\");\n                }\n            },\n\
    \            b'a'..=b'z' | b'A'..=b'Z' => {\n                if !after_dot_found\
    \ {\n                    before_dot_found = true;\n                }\n       \
    \     },\n            b'.' => {\n                dot_counter += 1;\n         \
    \       if dot_counter > 1 {\n                    return String::from(\"No\");\n\
    \                }\n                before_dot_found = false;\n              \
    \  after_dot_found = true;\n            },\n            _ => return String::from(\"\
    No\"),\n        }\n    }\n    if !before_dot_found || !after_dot_found {\n   \
    \     return String::from(\"No\");\n    }\n    let mut sub_str = String::new();\n\
    \    let mut started = false;\n    for i in (0..file_name.len()).rev() {\n   \
    \     match file_name[i] {\n            b'.' => {\n                started = true;\n\
    \                continue;\n            },\n            _ => {\n             \
    \   if started {\n                    sub_str.push(file_name[i] as char);\n  \
    \              }\n            },\n        }\n    }\n    match sub_str.as_str()\
    \ {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _\
    \ => String::from(\"No\"),\n    }", "    let mut digits = 0;\n    let mut dot_counter\
    \ = 0;\n    let mut last_element = 0;\n    let valid_extensions = [\"txt\", \"\
    exe\", \"dll\"];\n    for (i, c) in file_name.chars().enumerate() {\n        if\
    \ c.is_digit(10) {\n            digits += 1;\n        }\n        if c == '.' {\n\
    \            dot_counter += 1;\n            last_element = i;\n        }\n   \
    \ }\n    if !file_name.starts_with(|c: char| c.is_alphabetic()) {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name.ends_with(\".txt\") || file_name.ends_with(\"\
    .exe\") || file_name.ends_with(\".dll\") {\n        return String::from(\"Yes\"\
    );\n    }\n    if digits > 3 || dot_counter != 1 || file_name.len() < 4 {\n  \
    \      return String::from(\"No\");\n    }\n    if last_element == 1 {\n     \
    \   return String::from(\"No\");\n    }\n    if !valid_extensions.contains(&file_name.split('.').last().unwrap())\
    \ {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")",
  "    if file_name.contains(\"..\") {\n        return String::from(\"No\");\n   \
    \ }\n    let mut has_dot = false;\n    let mut number_of_digits = 0;\n    let\
    \ mut is_valid = true;\n    for ch in file_name.chars() {\n        if ch == '.'\
    \ {\n            if has_dot {\n                is_valid = false;\n           \
    \     break;\n            }\n            has_dot = true;\n        } else if ch.is_digit(10)\
    \ {\n            number_of_digits += 1;\n            if number_of_digits > 3 {\n\
    \                is_valid = false;\n                break;\n            }\n  \
    \      }\n    }\n    if is_valid {\n        let parts: Vec<&str> = file_name.split(\"\
    .\").collect();\n        if parts.len() != 2 {\n            is_valid = false;\n\
    \        } else {\n            if parts[0].is_empty() || !parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n                is_valid = false;\n            } else if parts[1] != \"txt\"\
    \ && parts[1] != \"exe\" && parts[1] != \"dll\" {\n                is_valid =\
    \ false;\n            }\n        }\n    }\n    if is_valid {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }", "    // Write your\
    \ code here\n    let mut digits = 0;\n    let mut dot = false;\n    let mut after_dot\
    \ = String::new();\n    let mut before_dot = String::new();\n    for char in file_name.chars()\
    \ {\n        if char == '.' {\n            dot = true;\n        } else if char.is_numeric()\
    \ {\n            digits += 1;\n        } else if char.is_alphabetic() {\n    \
    \        if dot {\n                after_dot.push(char);\n            } else {\n\
    \                before_dot.push(char);\n            }\n        }\n    }\n   \
    \ if digits > 3 || !dot || before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic()\
    \ ||\n        ![\"txt\", \"exe\", \"dll\"].contains(&after_dot.as_str()) {\n \
    \       return String::from(\"No\");\n    }\n    String::from(\"Yes\")", "   \
    \ const FILE_EXTENSIONS: &[&str] = &[\"txt\", \"exe\", \"dll\"];\n    // \uCCAB\
    \ \uAE00\uC790\uAC00 a~z, A~Z\uB85C \uC2DC\uC791\uD558\uC9C0 \uC54A\uC73C\uBA74\
    \ No\n    if !file_name.chars().next().unwrap().is_ascii_alphabetic() {\n    \
    \    return String::from(\"No\");\n    }\n    // \uC22B\uC790\uAC00 3\uAC1C \uC774\
    \uC0C1\uC774\uBA74 No\n    if file_name.chars().filter(|&c| c.is_ascii_digit()).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    // .\uC774 \uB450 \uAC1C\
    \ \uC774\uC0C1\uC774\uBA74 No\n    if file_name.chars().filter(|&c| c == '.').count()\
    \ != 1 {\n        return String::from(\"No\");\n    }\n    // \uD655\uC7A5\uC790\
    \uAC00 \uD2C0\uB9AC\uBA74 No\n    if !FILE_EXTENSIONS.contains(&file_name.split('.').last().unwrap())\
    \ {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")",
  "    // return \"Yes\" if the file name is valid, otherwise return \"No\"\n    let\
    \ re = Regex::new(r\"^[a-zA-Z]+[0-9]{1,3}(\\.[a-zA-Z]+[0-9]{1,3})*\\.(txt|exe|dll)$\"\
    ).unwrap();\n    return re.is_match(&file_name).to_string();", "    let is_valid\
    \ = if file_name.len() < 3 {\n        false\n    } else {\n        let mut count\
    \ = 0;\n        let mut is_dot_exist = false;\n        let mut dot_index = 0;\n\
    \        for (i, c) in file_name.chars().enumerate() {\n            if c.is_ascii_digit()\
    \ {\n                count += 1;\n            } else if c == '.' {\n         \
    \       is_dot_exist = true;\n                dot_index = i;\n            }\n\
    \        }\n        if count > 3 || !is_dot_exist {\n            false\n     \
    \   } else {\n            let prefix = &file_name[..dot_index];\n            let\
    \ suffix = &file_name[dot_index + 1..];\n            if prefix.is_empty() || prefix.chars().next().unwrap().is_ascii_digit()\
    \ || \n               suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\"\
    \ {\n                false\n            } else {\n                true\n     \
    \       }\n        }\n    };\n    if is_valid {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }", "    if file_name.contains(\"\
    .\") {\n        let mut count = 0;\n        for x in file_name.chars() {\n   \
    \         if x == '.' {\n                break;\n            }\n            if\
    \ x.is_numeric() {\n                count += 1;\n            }\n        }\n  \
    \      if count > 3 {\n            return String::from(\"No\");\n        }\n \
    \       let file_name_split: Vec<&str> = file_name.split(\".\").collect();\n \
    \       let file_name_split_len = file_name_split.len();\n        if file_name_split_len\
    \ == 2 {\n            if file_name_split[0].is_empty() {\n                return\
    \ String::from(\"No\");\n            }\n            let mut is_numeric = false;\n\
    \            for x in file_name_split[0].chars() {\n                if x.is_numeric()\
    \ {\n                    is_numeric = true;\n                    break;\n    \
    \            }\n            }\n            if is_numeric {\n                return\
    \ String::from(\"No\");\n            }\n            if file_name_split[1] == \"\
    txt\" || file_name_split[1] == \"exe\"\n                || file_name_split[1]\
    \ == \"dll\" {\n                return String::from(\"Yes\");\n            }\n\
    \        }\n    }\n    String::from(\"No\")", "    let mut num_of_digits = 0;\n\
    \    let mut dot_index = -1;\n    let mut sub_string_after_dot = false;\n    let\
    \ mut file_name_extension = false;\n    for (index, letter) in file_name.chars().enumerate()\
    \ {\n        if letter == '.' {\n            if dot_index != -1 {\n          \
    \      return String::from(\"No\");\n            }\n            dot_index = index;\n\
    \            continue;\n        }\n        if dot_index != -1 {\n            if\
    \ letter == 't' || letter == 'e' || letter == 'd' {\n                sub_string_after_dot\
    \ = true;\n            }\n            else if (letter == 'x' || letter == 'l')\
    \ && sub_string_after_dot {\n                sub_string_after_dot = false;\n \
    \               file_name_extension = true;\n            }\n            else {\n\
    \                return String::from(\"No\");\n            }\n        }\n    \
    \    else {\n            if letter >= '0' && letter <= '9' {\n               \
    \ num_of_digits += 1;\n                if num_of_digits > 3 {\n              \
    \      return String::from(\"No\");\n                }\n            }\n      \
    \      else if !((letter >= 'a' && letter <= 'z') || (letter >= 'A' && letter\
    \ <= 'Z')) {\n                return String::from(\"No\");\n            }\n  \
    \      }\n    }\n    if !(file_name_extension && dot_index > 0) {\n        return\
    \ String::from(\"No\");\n    }\n    String::from(\"Yes\")", "    // TODO: Write\
    \ your code here!\n    String::from(\"unimplemented\")", "    let file_name =\
    \ file_name.as_str();\n    let file_name_vec: Vec<&str> = file_name.split('.').collect();\n\
    \    let mut dot_count = 0;\n    let mut digit_count = 0;\n    if file_name_vec.len()\
    \ != 2 {\n        return String::from(\"No\");\n    }\n    for c in file_name.chars()\
    \ {\n        if c == '.' {\n            dot_count += 1;\n        }\n        if\
    \ c.is_digit(10) {\n            digit_count += 1;\n        }\n    }\n    if dot_count\
    \ != 1 || digit_count > 3 {\n        return String::from(\"No\");\n    }\n   \
    \ let valid_suffix = [\"txt\", \"exe\", \"dll\"];\n    if !file_name_vec[0].chars().next().unwrap().is_alphabetic()\
    \ || file_name_vec[0].is_empty() {\n        return String::from(\"No\");\n   \
    \ }\n    for suffix in valid_suffix.iter() {\n        if suffix == file_name_vec[1]\
    \ {\n            return String::from(\"Yes\");\n        }\n    }\n    String::from(\"\
    No\")", "\tlet mut number_of_digits = 0;\n\tlet mut number_of_dots = 0;\n\tlet\
    \ mut has_non_digit_char = false;\n\tlet mut has_empty_prefix = false;\n\tlet\
    \ mut has_incorrect_prefix = false;\n\tlet mut has_incorrect_suffix = false;\n\
    \tfor ch in file_name.chars() {\n\t\tif ch >= '0' && ch <= '9' {\n\t\t\tnumber_of_digits\
    \ += 1;\n\t\t} else if ch == '.' {\n\t\t\tnumber_of_dots += 1;\n\t\t} else if\
    \ !has_non_digit_char {\n\t\t\thas_non_digit_char = true;\n\t\t\tif !(ch >= 'a'\
    \ && ch <= 'z' || ch >= 'A' && ch <= 'Z') {\n\t\t\t\thas_incorrect_prefix = true;\n\
    \t\t\t}\n\t\t}\n\t}\n\tif !has_non_digit_char {\n\t\thas_empty_prefix = true;\n\
    \t}\n\tif number_of_digits > 3 {\n\t\tprintln!(\"Error: There are more than three\
    \ digits in file's name.\");\n\t}\n\tif number_of_dots != 1 {\n\t\tprintln!(\"\
    Error: The file's name should contain exactly one dot.\");\n\t}\n\tif has_empty_prefix\
    \ {\n\t\tprintln!(\"Error: The substring before the dot should not be empty.\"\
    );\n\t}\n\tif has_incorrect_prefix {\n\t\tprintln!(\"Error: The substring before\
    \ the dot should start with a letter from the latin alphapet ('a'-'z' and 'A'-'Z').\"\
    );\n\t}\n\tif !file_name.ends_with(\"txt\") && !file_name.ends_with(\"exe\") &&\
    \ !file_name.ends_with(\"dll\") {\n\t\thas_incorrect_suffix = true;\n\t\tprintln!(\"\
    Error: The substring after the dot should be one of these: ['txt', 'exe', 'dll'].\"\
    );\n\t}\n\tif number_of_digits <= 3 && number", '    String::from("Yes")', " \
    \   //TODO: Implement file_name_check\n    String::from(\"Implement me!\")", " \
    \   let mut counter: usize = 0;\n    let mut allowed_ending: bool = false;\n \
    \   let mut file_name_vec: Vec<char> = file_name.chars().collect();\n    let mut\
    \ file_name_slice: &[char] = &file_name_vec;\n    let mut file_ending: String\
    \ = String::new();\n    let mut file_name_end: String = String::new();\n    let\
    \ mut file_number: String = String::new();\n    let mut file_name_end_index: usize\
    \ = 0;\n    let mut file_number_index: usize = 0;\n    let mut file_ending_index:\
    \ usize = 0;\n    let valid_file_ending: [&str; 3] = [\"txt\", \"exe\", \"dll\"\
    ];\n    let is_valid: &str = \"Yes\";\n    let is_invalid: &str = \"No\";\n\n\
    \    // iterate through the slice and find the index of the '.'\n    for i in\
    \ 0..file_name_slice.len() {\n        if file_name_slice[i] == '.' {\n       \
    \     file_name_end_index = i;\n            break;\n        }\n    }\n\n    //\
    \ use the index of the '.' to create a substring representing the file ending\n\
    \    for i in file_name_end_index..file_name_slice.len() {\n        file_ending.push(file_name_slice[i]);\n\
    \    }\n\n    // iterate through the valid file endings to find a match\n    for\
    \ i in 0..valid_file_ending.len() {\n        if file_ending == valid_file_ending[i]\
    \ {\n            allowed_ending = true;\n            break;\n        }\n    }\n\
    \n    // create a substring which represents the file name, and another\n    //\
    \ substring which represents the numerical value in the file name\n    for i in\
    \ 0..file_name_end_index {\n        if file_name_slice[i].is_digit(10) {\n   \
    \         file_number.push(file_name_slice[i]);\n            file_number_index\
    \ = i;\n        } else {\n            file_name_end.push(file_name_", "    if\
    \ file_name.chars().filter(|&c| c.is_digit(10)).count() > 3 {\n        return\
    \ String::from(\"No\");\n    }\n    let mut dot_count = 0;\n    let mut found_dot\
    \ = false;\n    let mut end_of_digit = false;\n    let mut start_of_ext = false;\n\
    \    let mut end_of_ext = false;\n    let mut ext = String::new();\n    for c\
    \ in file_name.chars() {\n        if c == '.' {\n            if dot_count > 0\
    \ {\n                return String::from(\"No\");\n            }\n           \
    \ dot_count += 1;\n            found_dot = true;\n            continue;\n    \
    \    } else if c.is_digit(10) {\n            if found_dot {\n                return\
    \ String::from(\"No\");\n            }\n            end_of_digit = true;\n   \
    \         continue;\n        } else if !c.is_alphabetic() {\n            return\
    \ String::from(\"No\");\n        } else if end_of_digit {\n            start_of_ext\
    \ = true;\n        }\n        if start_of_ext {\n            ext.push(c);\n  \
    \          if ext.len() == 3 {\n                end_of_ext = true;\n         \
    \       break;\n            }\n        }\n    }\n    if !end_of_ext {\n      \
    \  return String::from(\"No\");\n    }\n    if !['txt', 'exe', 'dll'].contains(&ext.as_str())\
    \ {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")",
  "    if !file_name.contains('.') {\n        return String::from(\"No\");\n    }\n\
    \    let mut dot_count = 0;\n    let mut digit_count = 0;\n    let mut first_char\
    \ = true;\n    let mut first_substr_empty = true;\n    let mut second_substr_empty\
    \ = true;\n    let second_substr = [\"txt\", \"exe\", \"dll\"];\n    for (i, c)\
    \ in file_name.chars().enumerate() {\n        if c == '.' {\n            dot_count\
    \ += 1;\n            if dot_count > 1 {\n                return String::from(\"\
    No\");\n            }\n            first_char = true;\n            continue;\n\
    \        }\n        if first_char {\n            first_char = false;\n       \
    \     if first_substr_empty {\n                first_substr_empty = false;\n \
    \           }\n            if !c.is_alphabetic() {\n                return String::from(\"\
    No\");\n            }\n        }\n        if i > file_name.len() - 4 {\n     \
    \       if second_substr_empty {\n                second_substr_empty = false;\n\
    \            }\n            if !second_substr.contains(&file_name[i..].as_str())\
    \ {\n                return String::from(\"No\");\n            }\n        }\n\
    \        if c.is_digit(10) {\n            digit_count += 1;\n            if digit_count\
    \ > 3 {\n                return String::from(\"No\");\n            }\n       \
    \ }\n    }\n    if first_substr_empty || second_substr_empty {\n        return\
    \ String::from(\"No\");\n    }\n    String::from(\"Yes\")", "    let mut digit_count\
    \ = 0;\n    let mut dot_count = 0;\n    let mut extension_count = 0;\n    let\
    \ mut extension_match = false;\n    let mut letter_count = 0;\n    let mut first_letter\
    \ = false;\n    let file_name_chars: Vec<char> = file_name.chars().collect();\n\
    \    for i in 0..file_name_chars.len() {\n        match file_name_chars[i] {\n\
    \            '0'...'9' => {\n                digit_count += 1;\n             \
    \   first_letter = false;\n            },\n            'a'...'z' | 'A'...'Z' =>\
    \ {\n                if i == 0 {\n                    first_letter = true;\n \
    \               }\n                letter_count += 1;\n            },\n      \
    \      '.' => {\n                if dot_count == 0 {\n                    dot_count\
    \ += 1;\n                } else {\n                    return String::from(\"\
    No\");\n                }\n            },\n            _ => {\n              \
    \  if i > 0 && i < file_name_chars.len() - 4 && file_name_chars[i - 1] == '.'\
    \ {\n                    match &file_name_chars[i..i + 3] {\n                \
    \        ['t', 'x', 't'] => {\n                            extension_match = true;\n\
    \                            extension_count += 1;\n                        },\n\
    \                        ['e', 'x', 'e'] => {\n                            extension_match\
    \ = true;\n                            extension_count += 1;\n               \
    \         },\n                        ['d', 'l', 'l'] => {\n                 \
    \           extension_match = true;\n                            extension_count\
    \ += 1;\n                        },\n                        _ => {\n        \
    \                    extension_match = false;\n                        },\n  \
    \                  }\n                }\n            },\n        }\n    }\n  \
    \  if digit_count > 3 || dot_count != 1 || !first_letter || letter_count == 0\
    \ ||\n        extension_count > 1 || !extension_match {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");", "    // We will return this\
    \ default value\n    let result = String::from(\"No\");\n    // Make sure that\
    \ the string is not empty\n    if file_name.is_empty() {\n        return result;\n\
    \    }\n    // Split the string by '.'\n    let file_name_split: Vec<&str> = file_name.split('.').collect();\n\
    \    // Make sure that only one '.' exists in the file name\n    if file_name_split.len()\
    \ != 2 {\n        return result;\n    }\n    // Get the substring before the dot\n\
    \    let sub_str_before_dot = file_name_split[0];\n    // Make sure that the substring\
    \ is not empty\n    if sub_str_before_dot.is_empty() {\n        return result;\n\
    \    }\n    // Make sure that the substring starts with a letter\n    let first_letter\
    \ = sub_str_before_dot.chars().next().unwrap();\n    if !first_letter.is_alphabetic()\
    \ {\n        return result;\n    }\n    // Make sure that the substring contains\
    \ at most three digits\n    let mut num_of_digits = 0;\n    for c in sub_str_before_dot.chars()\
    \ {\n        if c.is_digit(10) {\n            num_of_digits += 1;\n        }\n\
    \    }\n    if num_of_digits > 3 {\n        return result;\n    }\n    // Get\
    \ the substring after the dot\n    let sub_str_after_dot = file_name_split[1];\n\
    \    // Make sure that the substring is one of ['txt', 'exe', 'dll']\n    if sub_str_after_dot\
    \ != \"txt\" && sub_str_after_dot != \"exe\" && sub_str_after_dot != \"dll\" {\n\
    \        return result;\n    }\n    // We have passed all checks, so return 'Yes'\n\
    \    return String::from(\"Yes\");", '    unimplemented!()', "    // Turn file_name\
    \ into an array of characters\n    let mut chars = file_name.chars();\n    //\
    \ Get the first character of the file_name\n    let first_char = chars.next();\n\
    \    // Get the last character of the file_name\n    let last_char = chars.last();\n\
    \    // Find the dot in the file_name\n    let dot_location = file_name.find('.');\n\
    \    // Get the substring between the first and the last character of the file_name\n\
    \    let sub_string = &file_name[1..file_name.len() - 1];\n    // Check if the\
    \ string does not contain more than three digits\n    let mut num_digits = 0;\n\
    \    for c in sub_string.chars() {\n        if c.is_digit(10) {\n            num_digits\
    \ += 1;\n        }\n    }\n    if num_digits > 3 {\n        return String::from(\"\
    No\");\n    }\n\n    // Check if the substring before the dot matches the corresponding\
    \ regex\n    let before_dot = &file_name[..dot_location.unwrap()];\n    if !before_dot.chars().next().unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n\n    // Check if the substring\
    \ after the dot matches the corresponding regex\n    let after_dot = &file_name[dot_location.unwrap()\
    \ + 1..];\n    let valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    if !valid_extensions.contains(&after_dot)\
    \ {\n        return String::from(\"No\");\n    }\n\n    // Check if the first\
    \ and the last character are alphanumeric\n    if first_char.unwrap().is_alphanumeric()\
    \ && last_char.unwrap().is_alphanumeric() {\n        return String::from(\"Yes\"\
    );\n    }\n\n    String::from(\"No\")", "    let mut match_digits = false;\n \
    \   let mut match_dot = false;\n    let mut match_before_dot = false;\n    let\
    \ mut match_after_dot = false;\n    let mut digits_counter = 0;\n    let mut before_dot\
    \ = \"\".to_string();\n    let mut after_dot = \"\".to_string();\n    for c in\
    \ file_name.chars() {\n        if !match_dot {\n            if c.is_digit(10)\
    \ {\n                digits_counter += 1;\n                if digits_counter >\
    \ 3 {\n                    return \"No\".to_string();\n                }\n   \
    \         } else if c == '.' {\n                match_dot = true;\n          \
    \  } else if c.is_alphabetic() {\n                before_dot.push(c);\n      \
    \      } else {\n                return \"No\".to_string();\n            }\n \
    \       } else {\n            after_dot.push(c);\n        }\n    }\n    if !before_dot.is_empty()\
    \ && (after_dot == \"txt\" || after_dot == \"exe\" || after_dot == \"dll\") {\n\
    \        return \"Yes\".to_string();\n    }\n    \"No\".to_string()", "    let\
    \ mut is_name_valid = true;\n    let mut digit_counter = 0;\n    let mut dot_index\
    \ = -1;\n    let mut extension = String::new();\n    let available_extension =\
    \ vec![\"txt\", \"exe\", \"dll\"];\n    let mut is_extension_valid = false;\n\n\
    \    for (i, ch) in file_name.chars().enumerate() {\n        if ch.is_digit(10)\
    \ {\n            digit_counter += 1;\n        } else if ch == '.' {\n        \
    \    dot_index = i;\n        }\n    }\n\n    if digit_counter > 3 {\n        is_name_valid\
    \ = false;\n    }\n\n    if dot_index == -1 || dot_index == 0 {\n        is_name_valid\
    \ = false;\n    }\n\n    if dot_index != -1 {\n        let len = file_name.len();\n\
    \        extension = file_name[dot_index + 1..len].to_string();\n    }\n\n   \
    \ for e in available_extension {\n        if e == extension {\n            is_extension_valid\
    \ = true;\n        }\n    }\n\n    if !is_extension_valid {\n        is_name_valid\
    \ = false;\n    }\n\n    if is_name_valid {\n        String::from(\"Yes\")\n \
    \   } else {\n        String::from(\"No\")\n    }", "    if file_name.find(\"\
    .\").is_none() {\n        return String::from(\"No\");\n    }\n\n    let sub_name\
    \ = file_name.split(\".\").collect::<Vec<&str>>();\n    if sub_name.len() != 2\
    \ {\n        return String::from(\"No\");\n    }\n\n    let sub_name_1 = sub_name[0];\n\
    \    let sub_name_2 = sub_name[1];\n    let mut num_of_digit: i32 = 0;\n    let\
    \ mut num_of_letter: i32 = 0;\n    for i in 0..sub_name_1.len() {\n        let\
    \ each_char = sub_name_1.chars().nth(i).unwrap();\n        if each_char.is_ascii_digit()\
    \ {\n            num_of_digit += 1;\n        } else if each_char.is_ascii_alphabetic()\
    \ {\n            num_of_letter += 1;\n        }\n    }\n\n    if num_of_digit\
    \ > 3 || num_of_letter == 0 {\n        return String::from(\"No\");\n    }\n\n\
    \    if sub_name_2 != \"txt\" && sub_name_2 != \"exe\" && sub_name_2 != \"dll\"\
    \ {\n        return String::from(\"No\");\n    }\n\n    return String::from(\"\
    Yes\");", "    let mut regexp = Regex::new(r\"(^([a-zA-Z]\\w*)(\\.dll|\\.txt|\\\
    .exe))|^([a-zA-Z]\\w*)(\\.[a-zA-Z]\\w*[3-9]\\w*)\").unwrap();\n    let matched\
    \ = regexp.is_match(&file_name);\n    if matched {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }", "    // check if there\
    \ are more than 3 digits\n    if file_name.chars().filter(|&x| x >= '0' && x <=\
    \ '9').count() > 3 {\n        return String::from(\"No\");\n    }\n    // check\
    \ if there is exactly one dot\n    if file_name.chars().filter(|&x| x == '.').count()\
    \ != 1 {\n        return String::from(\"No\");\n    }\n    // check if before\
    \ dot is an alphabet and not empty\n    if !file_name.split('.').nth(0).unwrap().chars().all(|x|\
    \ x >= 'a' && x <= 'z' || x >= 'A' && x <= 'Z') ||\n       file_name.split('.').nth(0).unwrap().chars().count()\
    \ == 0 {\n        return String::from(\"No\");\n    }\n    // check if after dot\
    \ is correct\n    let after_dot = file_name.split('.').nth(1).unwrap();\n    if\
    \ after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\" {\n   \
    \     return String::from(\"No\");\n    }\n    return String::from(\"Yes\");",
  "    if file_name.len() < 5 {\n        return String::from(\"No\");\n    }\n   \
    \ let mut dot_count = 0;\n    let mut digits_count = 0;\n    let mut file_name_len\
    \ = file_name.len();\n    let mut has_letter = false;\n    let file_name_chars:\
    \ Vec<char> = file_name.chars().collect();\n    let mut i = 0;\n    while i <\
    \ file_name_len {\n        if file_name_chars[i] == '.' {\n            dot_count\
    \ += 1;\n            break;\n        }\n        if file_name_chars[i].is_digit(10)\
    \ {\n            digits_count += 1;\n        }\n        if file_name_chars[i].is_ascii_alphabetic()\
    \ {\n            has_letter = true;\n        }\n        i += 1;\n    }\n    if\
    \ !has_letter || dot_count != 1 || digits_count > 3 {\n        return String::from(\"\
    No\");\n    }\n    i += 1;\n    let file_type = String::from(&file_name[i..]);\n\
    \    let file_types = vec![\"txt\", \"exe\", \"dll\"];\n    if file_types.contains(&file_type.as_str())\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")",
  "    if file_name.chars().filter(|&ch| ch.is_ascii_digit()).count() > 3 {\n    \
    \    String::from(\"No\")\n    } else {\n        let mut iter = file_name.split('.');\n\
    \        let file_name = iter.next().unwrap();\n        let ext = iter.next().unwrap();\n\
    \        if file_name.chars().next().unwrap().is_ascii_alphabetic()\n        \
    \    && (ext == \"txt\" || ext == \"exe\" || ext == \"dll\")\n        {\n    \
    \        String::from(\"Yes\")\n        } else {\n            String::from(\"\
    No\")\n        }\n    }", "    let mut digits = 0;\n    let mut name_valid = false;\n\
    \    let mut ext_valid = false;\n    let mut dot_count = 0;\n    let ext_values\
    \ = vec![\"txt\", \"exe\", \"dll\"];\n    let mut ext_start_index = 0;\n    for\
    \ (index, character) in file_name.chars().enumerate() {\n        match character\
    \ {\n            '.' => {\n                dot_count += 1;\n                ext_start_index\
    \ = index + 1;\n            },\n            '0'..='9' => digits += 1,\n      \
    \      'a'..='z' | 'A'..='Z' => name_valid = true,\n            _ => {},\n   \
    \     }\n    }\n    let file_ext = &file_name[ext_start_index..];\n    if ext_values.contains(&file_ext)\
    \ {\n        ext_valid = true;\n    }\n    if name_valid && ext_valid && dot_count\
    \ == 1 && digits <= 3 {\n        return String::from(\"Yes\");\n    }\n    String::from(\"\
    No\")", "    let mut digits_count = 0;\n    let mut dots_count = 0;\n    let mut\
    \ letters_found = false;\n    let mut valid_file_type = false;\n    let mut file_name_chars\
    \ = file_name.chars();\n    loop {\n        match file_name_chars.next() {\n \
    \           Some(c) => {\n                if c == '.' {\n                    dots_count\
    \ += 1;\n                } else if '0' <= c && c <= '9' {\n                  \
    \  digits_count += 1;\n                } else if c.is_ascii_alphabetic() {\n \
    \                   letters_found = true;\n                }\n            }\n\
    \            None => break,\n        }\n    }\n    if letters_found && dots_count\
    \ == 1 && digits_count <= 3 {\n        let file_type = file_name.split('.').nth(1).unwrap();\n\
    \        valid_file_type = match file_type {\n            \"txt\" | \"exe\" |\
    \ \"dll\" => true,\n            _ => false,\n        };\n    }\n    match valid_file_type\
    \ {\n        true => String::from(\"Yes\"),\n        false => String::from(\"\
    No\"),\n    }", "    let mut count_of_digits = 0;\n    let mut first_dot_seen\
    \ = false;\n    let mut first_part_started = false;\n    let mut first_part_string\
    \ = String::new();\n    let mut second_part_string = String::new();\n    let mut\
    \ first_part_string_is_valid = false;\n    let mut second_part_string_is_valid\
    \ = false;\n    for c in file_name.chars() {\n        if c == '.' {\n        \
    \    if first_dot_seen {\n                return String::from(\"No\");\n     \
    \       }\n            first_dot_seen = true;\n            first_part_started\
    \ = false;\n            first_part_string_is_valid = first_part_string.len() >\
    \ 0 && \n                first_part_string.chars().next().unwrap().is_ascii_alphabetic();\n\
    \        } else if first_dot_seen {\n            second_part_string.push(c);\n\
    \        } else if c.is_ascii_digit() {\n            count_of_digits += 1;\n \
    \           if count_of_digits > 3 {\n                return String::from(\"No\"\
    );\n            }\n            first_part_started = true;\n        } else if first_part_started\
    \ {\n            first_part_string.push(c);\n        }\n    }\n    if first_part_string_is_valid\
    \ {\n        second_part_string_is_valid = second_part_string == \"txt\" || \n\
    \            second_part_string == \"exe\" || second_part_string == \"dll\";\n\
    \    }\n    if first_part_string_is_valid && second_part_string_is_valid {\n \
    \       return String::from(\"Yes\");\n    }\n    return String::from(\"No\");",
  "    let index = file_name.rfind('.').unwrap();\n    let name_without_extension\
    \ = &file_name[..index];\n    let extension = &file_name[index + 1..];\n    if\
    \ name_without_extension.len() == 0 || name_without_extension.chars().nth(0).unwrap().is_numeric()\
    \ {\n        return String::from(\"No\");\n    }\n    if ![\"txt\", \"exe\", \"\
    dll\"].contains(&extension) {\n        return String::from(\"No\");\n    }\n \
    \   for c in name_without_extension.chars() {\n        if c.is_numeric() {\n \
    \           return String::from(\"No\");\n        }\n    }\n    return String::from(\"\
    Yes\");", "    // let r: Regex = Regex::new(r\"^[a-zA-Z][^\\d]{0,3}\\.txt$|^[a-zA-Z][^\\\
    d]{0,3}\\.exe$|^[a-zA-Z][^\\d]{0,3}\\.dll$\").unwrap();\n    let r: Regex = Regex::new(r\"\
    ^[a-zA-Z][^\\d]{0,3}\\.(txt|exe|dll)$\").unwrap();\n    if r.is_match(&file_name)\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")",
  "    let mut digits_count = 0;\n    let mut dot_position = 0;\n    let mut result\
    \ = String::from(\"Yes\");\n    for (index, element) in file_name.chars().enumerate()\
    \ {\n        if element == '.' {\n            dot_position = index;\n        }\n\
    \        if element.is_digit(10) {\n            digits_count += 1;\n        }\n\
    \    }\n    if digits_count > 3 {\n        result = String::from(\"No\");\n  \
    \  }\n    if file_name.chars().filter(|&x| x == '.').count() != 1 {\n        result\
    \ = String::from(\"No\");\n    }\n    if dot_position == 0 {\n        result =\
    \ String::from(\"No\");\n    }\n    if !file_name[..dot_position].chars().next().unwrap().is_alphabetic()\
    \ {\n        result = String::from(\"No\");\n    }\n    if !(file_name[dot_position\
    \ + 1..] == \"txt\" || file_name[dot_position + 1..] == \"exe\" || file_name[dot_position\
    \ + 1..] == \"dll\") {\n        result = String::from(\"No\");\n    }\n    result",
  "    if file_name.matches(\"[0-9]\").count() > 3 {\n        return String::from(\"\
    No\");\n    }\n    if file_name.chars().filter(|x| *x == '.').count() != 1 {\n\
    \        return String::from(\"No\");\n    }\n    let mut parts = file_name.split(\"\
    .\");\n    let first_part = parts.next().unwrap();\n    let second_part = parts.next().unwrap();\n\
    \    if first_part.chars().next().unwrap().is_digit(10) {\n        return String::from(\"\
    No\");\n    }\n    if second_part != \"txt\" && second_part != \"exe\" && second_part\
    \ != \"dll\" {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");", '    //...', "    let mut dot_count = 0;\n    let mut num_count = 0;\n\
    \    let mut char_count = 0;\n    let mut suffix = \"\";\n    for x in file_name.chars()\
    \ {\n        if '.' == x {\n            dot_count += 1;\n        } else if x.is_numeric()\
    \ {\n            num_count += 1;\n        } else if x.is_alphabetic() {\n    \
    \        char_count += 1;\n        }\n    }\n    if dot_count != 1 || num_count\
    \ > 3 || char_count < 1 {\n        return String::from(\"No\");\n    }\n    let\
    \ dot_pos = file_name.find('.').unwrap();\n    suffix = &file_name[dot_pos+1..];\n\
    \    if suffix == \"txt\" || suffix == \"exe\" || suffix == \"dll\" {\n      \
    \  return String::from(\"Yes\");\n    }\n    return String::from(\"No\");", " \
    \   let mut char_count = 0;\n    let mut counter = 0;\n    let mut flag = false;\n\
    \    for c in file_name.chars() {\n        if c.is_numeric() {\n            char_count\
    \ += 1;\n        }\n        if c == '.' {\n            flag = true;\n        }\n\
    \        if flag {\n            counter += 1;\n        }\n    }\n    if char_count\
    \ > 3 || counter != 4 {\n        return String::from(\"No\");\n    }\n    let\
    \ mut prefix = true;\n    for c in file_name.chars() {\n        if c == '.' {\n\
    \            prefix = false;\n        }\n        if prefix {\n            if !c.is_alphabetic()\
    \ {\n                return String::from(\"No\");\n            }\n        }\n\
    \    }\n    match &file_name[(file_name.len() - 3)..] {\n        \"txt\" | \"\
    exe\" | \"dll\" => return String::from(\"Yes\"),\n        _ => return String::from(\"\
    No\"),\n    }", "    // Write code here..\n    unimplemented!()", "    let (before_dot,\
    \ after_dot) = file_name.split_at(file_name.find('.').unwrap());\n    if after_dot.len()\
    \ != 4 {\n        return String::from(\"No\");\n    }\n    if before_dot.len()\
    \ == 0 {\n        return String::from(\"No\");\n    }\n    if (before_dot.find(|c:\
    \ char| !c.is_alphabetic()).is_some()) || \n       (before_dot.find(|c: char|\
    \ !c.is_numeric()).unwrap() != 0) {\n        return String::from(\"No\");\n  \
    \  }\n    if (after_dot.find(|c: char| !c.is_alphabetic()).is_some()) || \n  \
    \     (after_dot.chars().filter(|c| c.is_numeric()).count() > 3) {\n        return\
    \ String::from(\"No\");\n    }\n    if after_dot != \".txt\" && after_dot != \"\
    .exe\" && after_dot != \".dll\" {\n        return String::from(\"No\");\n    }\n\
    \    String::from(\"Yes\")", '    unimplemented!()', "    let file_name_vec: Vec<&str>\
    \ = file_name.split('.').collect();\n    if file_name_vec.len() != 2 {\n     \
    \   return String::from(\"No\");\n    }\n    let file_extension = file_name_vec[1];\n\
    \    let file_extension_vec: Vec<&str> = file_extension.split(char::is_numeric).collect();\n\
    \    if file_extension_vec.len() != 2 {\n        return String::from(\"No\");\n\
    \    }\n    let file_extension_digit_count = file_extension_vec[0].len();\n  \
    \  if file_extension_digit_count > 3 {\n        return String::from(\"No\");\n\
    \    }\n    let file_name_without_extension = file_name_vec[0];\n    let file_name_without_extension_vec:\
    \ Vec<&str> = file_name_without_extension.split(char::is_alphabetic).collect();\n\
    \    if file_name_without_extension_vec.len() != 2 {\n        return String::from(\"\
    No\");\n    }\n    let file_name_without_extension_first_char = file_name_without_extension_vec[0];\n\
    \    if file_name_without_extension_first_char.len() != 1 {\n        return String::from(\"\
    No\");\n    }\n    let file_name_without_extension_last_char = file_name_without_extension_vec[1];\n\
    \    if file_name_without_extension_last_char.len() != 1 {\n        return String::from(\"\
    No\");\n    }\n    let file_name_without_extension_digit_count = file_name_without_extension_last_char.len();\n\
    \    if file_name_without_extension_digit_count > 3 {\n        return String::from(\"\
    No\");\n    }\n    let vec_of_approved_extensions = vec![\"txt\", \"exe\", \"\
    dll\"];\n    if !vec_of_approved_extensions.contains(&file_extension) {\n    \
    \    return String::from(\"No\");\n    }\n    return", "    let mut digits_num\
    \ = 0;\n    let mut dot_num = 0;\n    let mut digit_flag = false;\n    let mut\
    \ non_digit_flag = false;\n    let mut letter_flag = false;\n    let mut dot_flag\
    \ = false;\n    let mut extension_flag = false;\n    let mut extension_check =\
    \ false;\n    let mut extension_check2 = false;\n    let mut extension_check3\
    \ = false;\n    for c in file_name.chars() {\n        if c.is_digit(10) {\n  \
    \          digit_flag = true;\n            non_digit_flag = false;\n         \
    \   digits_num += 1;\n        } else if c.is_alphabetic() {\n            non_digit_flag\
    \ = true;\n            digit_flag = false;\n            if !letter_flag {\n  \
    \              letter_flag = true;\n            }\n        } else if c == '.'\
    \ {\n            digit_flag = false;\n            non_digit_flag = false;\n  \
    \          dot_num += 1;\n            if !dot_flag {\n                dot_flag\
    \ = true;\n            }\n        } else {\n            return String::from(\"\
    No\");\n        }\n        if digits_num > 3 && digit_flag {\n            return\
    \ String::from(\"No\");\n        }\n        if !dot_flag && letter_flag && digit_flag\
    \ {\n            return String::from(\"No\");\n        }\n        if dot_num >\
    \ 1 {\n            return String::from(\"No\");\n        }\n        if !non_digit_flag\
    \ && !letter_flag && dot_flag {\n            return String::from(\"No\");\n  \
    \      }\n        if dot_flag && !extension_flag {\n            if file_name.len()\
    \ > 3 {\n                extension_check = match file_name.chars().nth(file_name.len()\
    \ - 4) {\n                    Some(c) => c == '.',\n                    None =>\
    \ false,\n                };\n                extension_check2 = match file_name.chars().nth(file_name.len()\
    \ - 4) {\n                    Some(c) => c == 't',\n                    None =>\
    \ false,\n                };\n                extension_check3 = match", "   \
    \ // Write your code here\n    let mut file_name_chars = file_name.chars();\n\
    \    let mut first_dot = false;\n    let mut count_digits = 0;\n    let mut count_dots\
    \ = 0;\n    while let Some(c) = file_name_chars.next() {\n        if c == '.'\
    \ {\n            count_dots += 1;\n            first_dot = true;\n        }\n\
    \        if !first_dot && c.is_digit(10) {\n            count_digits += 1;\n \
    \       }\n    }\n    if count_digits > 3 || count_dots != 1 {\n        return\
    \ String::from(\"No\");\n    }\n\n    let mut first_char = true;\n    let mut\
    \ is_valid = false;\n    for c in file_name.chars() {\n        if c == '.' {\n\
    \            break;\n        }\n        if first_char && !c.is_alphabetic() {\n\
    \            return String::from(\"No\");\n        }\n        first_char = false;\n\
    \    }\n\n    if file_name.ends_with(\".txt\") {\n        is_valid = true;\n \
    \   }\n    if file_name.ends_with(\".exe\") {\n        is_valid = true;\n    }\n\
    \    if file_name.ends_with(\".dll\") {\n        is_valid = true;\n    }\n   \
    \ if is_valid {\n        return String::from(\"Yes\");\n    }\n    return String::from(\"\
    No\");", "    let extention = vec![\"txt\", \"exe\", \"dll\"];\n    let file_name_split:\
    \ Vec<&str> = file_name.split(\".\").collect();\n    let file_name_vec: Vec<char>\
    \ = file_name.chars().collect();\n    let mut number_of_digits = 0;\n    let mut\
    \ number_of_dots = 0;\n    let mut dot_index = 0;\n    let mut first_letter_index\
    \ = 0;\n    let mut valid_extention = false;\n    if file_name_split.len() ==\
    \ 2 {\n        for i in 0..file_name_vec.len() {\n            if file_name_vec[i].is_digit(10)\
    \ {\n                number_of_digits += 1;\n            }\n            if file_name_vec[i]\
    \ == '.' {\n                number_of_dots += 1;\n                dot_index =\
    \ i;\n            }\n            if file_name_vec[i].is_alphabetic() {\n     \
    \           first_letter_index = i;\n                break;\n            }\n \
    \       }\n        if number_of_digits <= 3 && number_of_dots == 1 && first_letter_index\
    \ < dot_index {\n            let mut file_name_ext = String::new();\n        \
    \    for i in dot_index + 1..file_name_vec.len() {\n                file_name_ext.push(file_name_vec[i]);\n\
    \            }\n            for ext in extention {\n                if file_name_ext\
    \ == ext {\n                    valid_extention = true;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    if number_of_digits <=\
    \ 3 && number_of_dots == 1 && first_letter_index < dot_index && valid_extention\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }", "    // Check if the substring before the dot is empty\n    let mut\
    \ parts = file_name.split('.');\n    let left = parts.next().unwrap();\n    if\
    \ left.is_empty() {\n        return String::from(\"No\");\n    }\n\n    // Check\
    \ if there is more than three digits in the file's name\n    let digits = left.chars().filter(|c|\
    \ c.is_digit(10)).count();\n    if digits > 3 {\n        return String::from(\"\
    No\");\n    }\n\n    // Check if the substring before the dot starts with a latin\
    \ alphabet\n    let mut chars = left.chars();\n    let first_char = chars.next().unwrap();\n\
    \    if !first_char.is_ascii_alphabetic() {\n        return String::from(\"No\"\
    );\n    }\n\n    // Check if the substring after the dot is one of the following:\
    \ ['txt', 'exe', 'dll']\n    let right = parts.next().unwrap();\n    if right\
    \ != \"txt\" && right != \"exe\" && right != \"dll\" {\n        return String::from(\"\
    No\");\n    }\n\n    // If we reached this line, the file name is valid, so we\
    \ return 'Yes'\n    String::from(\"Yes\")", "    let mut num_digits = 0;\n   \
    \ let mut has_dot = false;\n    let mut has_valid_pre = false;\n    let mut has_valid_suf\
    \ = false;\n    let mut pre_str = String::new();\n    let mut suf_str = String::new();\n\
    \    for c in file_name.chars() {\n        if c == '.' {\n            has_dot\
    \ = true;\n        } else if c.is_digit(10) {\n            num_digits += 1;\n\
    \        } else if c.is_ascii_alphabetic() {\n            if has_dot {\n     \
    \           suf_str.push(c);\n            } else {\n                pre_str.push(c);\n\
    \            }\n        }\n    }\n    if num_digits <= 3 && has_dot && !pre_str.is_empty()\
    \ && pre_str.chars().next().unwrap().is_ascii_alphabetic() {\n        has_valid_pre\
    \ = true;\n    }\n    if has_valid_pre && suf_str == \"txt\" || suf_str == \"\
    exe\" || suf_str == \"dll\" {\n        has_valid_suf = true;\n    }\n    if has_valid_pre\
    \ && has_valid_suf {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }", "    // your code here\n    \"No\".to_string()", "    let mut dot_index\
    \ = 0;\n    let mut count = 0;\n    let end = file_name.len();\n    let mut i\
    \ = 0;\n    while i < end {\n        if file_name.chars().nth(i).unwrap().is_digit(10)\
    \ {\n            count += 1;\n        }\n        if file_name.chars().nth(i).unwrap()\
    \ == '.' {\n            dot_index = i;\n        }\n        i += 1;\n    }\n  \
    \  if count > 3 {\n        return String::from(\"No\");\n    }\n    let char_list\
    \ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z'];\n    if !char_list.contains(&file_name.chars().nth(0).unwrap())\
    \ {\n        return String::from(\"No\");\n    }\n    if !file_name.contains('.')\
    \ {\n        return String::from(\"No\");\n    }\n    let extension = &file_name[dot_index\
    \ + 1..];\n    let allowed_extensions = [\"txt\", \"exe\", \"dll\"];\n    if !allowed_extensions.contains(&extension)\
    \ {\n        return String::from(\"No\");\n    }\n    return String::from(\"Yes\"\
    );", "    // check digit\n    let valid_digit = file_name.chars().filter(|c| c.is_digit(10)).count()\
    \ <= 3;\n    // check dot\n    let valid_dot = file_name.chars().filter(|c| *c\
    \ == '.').count() == 1;\n    // check extension\n    let valid_extension = {\n\
    \        let v: Vec<&str> = file_name.split('.').collect();\n        v.len() ==\
    \ 2 && &v[1] == \"txt\" || &v[1] == \"exe\" || &v[1] == \"dll\"\n    };\n    //\
    \ check prefix\n    let valid_prefix = {\n        let v: Vec<&str> = file_name.split('.').collect();\n\
    \        !v[0].is_empty() && v[0].chars().next().unwrap().is_alphabetic()\n  \
    \  };\n    if valid_digit && valid_dot && valid_extension && valid_prefix {\n\
    \        String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n \
    \   }", "    // Write here\n    unimplemented!()", "    let l = file_name.chars().filter(|&c|\
    \ c.is_ascii_digit()).count();\n    if l > 3 {\n        return String::from(\"\
    No\");\n    }\n    if !file_name.chars().any(|c| c == '.') {\n        return String::from(\"\
    No\");\n    }\n    let mut file_name_iter = file_name.split('.');\n    let left\
    \ = file_name_iter.next().unwrap();\n    let right = file_name_iter.next().unwrap();\n\
    \    if left.is_empty() || !left.chars().next().unwrap().is_ascii_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n    if !(right == \"txt\" ||\
    \ right == \"exe\" || right == \"dll\") {\n        return String::from(\"No\"\
    );\n    }\n    String::from(\"Yes\")", "    let re = Regex::new(r\"(^[a-zA-Z]+\\\
    d*)+\\.[a-zA-Z]{3}$\").unwrap();\n    if re.is_match(&file_name) {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }", "    // Write your\
    \ code here\n    let mut chars = file_name.chars();\n    let mut ch = chars.next();\n\
    \    let mut dots = 0;\n    let mut numbers = 0;\n    while ch.is_some() {\n \
    \       if ch.unwrap() == '.' {\n            dots += 1;\n        }\n        else\
    \ if ch.unwrap().is_digit(10) {\n            numbers += 1;\n        }\n      \
    \  ch = chars.next();\n    }\n    if (dots != 1) || (numbers > 3) {\n        String::from(\"\
    No\")\n    }\n    else {\n        let parts: Vec<&str> = file_name.split('.').collect();\n\
    \        if (parts[0].len() == 0) || !parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n            String::from(\"No\")\n        }\n        else if (parts[1] !=\
    \ \"txt\") && (parts[1] != \"exe\") && (parts[1] != \"dll\") {\n            String::from(\"\
    No\")\n        }\n        else {\n            String::from(\"Yes\")\n        }\n\
    \    }", "    // your code goes here\n    let digit_count = file_name.chars().filter(|x|\
    \ \"0123456789\".contains(*x)).count();\n    if digit_count > 3 {\n        return\
    \ String::from(\"No\");\n    }\n    let dot_count = file_name.chars().filter(|x|\
    \ *x == '.').count();\n    if dot_count != 1 {\n        return String::from(\"\
    No\");\n    }\n    let dot_index = file_name.find('.').unwrap();\n    let (name,\
    \ extension) = file_name.split_at(dot_index);\n    if name.is_empty() || !is_valid_letter(name.chars().next().unwrap())\
    \ {\n        return String::from(\"No\");\n    }\n    if extension != \".txt\"\
    \ && extension != \".exe\" && extension != \".dll\" {\n        return String::from(\"\
    No\");\n    }\n    String::from(\"Yes\")", "    let file_name = file_name.clone();\n\
    \    let file_name_chars = file_name.chars().collect::<Vec<char>>();\n    let\
    \ file_name_chars_size = file_name_chars.len();\n    let mut digits_counter =\
    \ 0;\n    let mut dot_counter = 0;\n    let mut correct_file_name = false;\n \
    \   let mut valid_substring_before_dot = false;\n    let mut valid_substring_after_dot\
    \ = false;\n    if file_name_chars_size > 0 {\n        for i in 0..file_name_chars_size\
    \ {\n            if file_name_chars[i].is_digit(10) {\n                digits_counter\
    \ += 1;\n            }\n            if file_name_chars[i] == '.' {\n         \
    \       dot_counter += 1;\n            }\n        }\n        if digits_counter\
    \ <= 3 && dot_counter == 1 {\n            for i in 0..file_name_chars_size {\n\
    \                if file_name_chars[i] == '.' {\n                    let substring_before_dot:\
    \ String = \n                        file_name.chars().take(i).collect();\n  \
    \                  let substring_after_dot: String = \n                      \
    \  file_name.chars().skip(i + 1).collect();\n                    let file_name_substring_before_dot_size\
    \ = substring_before_dot.len();\n                    let file_name_substring_after_dot_size\
    \ = substring_after_dot.len();\n                    if file_name_substring_before_dot_size\
    \ > 0 {\n                        let substring_before_dot_chars = substring_before_dot.chars().collect::<Vec<char>>();\n\
    \                        if substring_before_dot_chars[0].is_alphabetic() {\n\
    \                            valid_substring_before_dot = true;\n            \
    \            }\n                    }\n                    if file_name_substring_after_dot_size\
    \ > 0 {\n                        if substring_after_dot == \"txt\" || \n     \
    \                       substring_after_dot == \"exe\" || \n                 \
    \           substring_", "    let re = Regex::new(r\"^[a-zA-Z]{1}[a-zA-Z0-9]{0,3}(\\\
    .[a-zA-Z]{3})$\").unwrap();\n    let result = re.is_match(&file_name);\n    if\
    \ result {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }", "    let dot_idx = file_name.find('.').unwrap();\n    let file_name_without_dot\
    \ = &file_name[..dot_idx];\n    let file_extension = &file_name[dot_idx+1..];\n\
    \    if file_name_without_dot.len() == 0 || file_name_without_dot.len() > 10 {\n\
    \        return String::from(\"No\");\n    }\n    if file_name_without_dot.chars().any(|ch|\
    \ !ch.is_alphabetic()) {\n        return String::from(\"No\");\n    }\n    if\
    \ file_name_without_dot.chars().filter(|ch| ch.is_numeric()).count() > 3 {\n \
    \       return String::from(\"No\");\n    }\n    if ![\"txt\", \"exe\", \"dll\"\
    ].contains(&file_extension.as_str()) {\n        return String::from(\"No\");\n\
    \    }\n    String::from(\"Yes\")", "    // let's define the valid characters\
    \ and the dot character\n    let valid_characters = ['0', '1', '2', '3', '4',\
    \ '5', '6', '7', '8', '9', '.'];\n    let dot_character = '.';\n    // define\
    \ the extension names as a vector of String\n    let extensions = vec![String::from(\"\
    txt\"), String::from(\"exe\"), String::from(\"dll\")];\n    // define the number\
    \ of digits allowed in the filename\n    let allowed_digits = 3;\n    // let's\
    \ iterate over the string's characters\n    let mut digits_count = 0;\n    let\
    \ mut dot_count = 0;\n    let mut is_first_character_letter = false;\n    let\
    \ mut is_dot_the_first_character = false;\n    let mut extension = String::new();\n\
    \    for character in file_name.chars() {\n        // check if the character is\
    \ an allowed character\n        if !valid_characters.contains(&character) {\n\
    \            return String::from(\"No\");\n        }\n        // check if the\
    \ character is a digit\n        if character.is_digit(10) {\n            digits_count\
    \ += 1;\n            if digits_count > allowed_digits {\n                return\
    \ String::from(\"No\");\n            }\n        }\n        // check if the character\
    \ is a dot\n        if character == dot_character {\n            dot_count +=\
    \ 1;\n            if dot_count > 1 {\n                return String::from(\"No\"\
    );\n            }\n            if file_name.len() == 1 {\n                is_dot_the_first_character\
    \ = true;\n            }\n        }\n        // check if the character is a letter\n\
    \        if character.is_alphabetic() {\n            is_first_character_letter\
    \ = true;\n        }\n        // get the extension\n        if character == dot_character\
    \ {\n            let mut file_name_iter = file_name.chars();\n            while\
    \ let Some(c) = file_name_iter.next() {\n                if c == dot_character\
    \ {\n                    break;\n                }\n            }\n          \
    \  while let Some(c) = file_name_iter.next() {\n                extension.", " \
    \   if file_name.find('.').is_none() {\n        return String::from(\"No\");\n\
    \    }\n    let mut digits_count = 0;\n    let mut first_part_end = file_name.find('.').unwrap();\n\
    \    for character in file_name.chars().take(first_part_end) {\n        if !((character\
    \ >= 'a' && character <= 'z') ||\n             (character >= 'A' && character\
    \ <= 'Z')) {\n            return String::from(\"No\");\n        }\n        if\
    \ character >= '0' && character <= '9' {\n            digits_count += 1;\n   \
    \     }\n    }\n    if digits_count > 3 {\n        return String::from(\"No\"\
    );\n    }\n    let second_part = &file_name[first_part_end + 1..];\n    match\
    \ second_part {\n        \"txt\" | \"exe\" | \"dll\" => return String::from(\"\
    Yes\"),\n        _ => return String::from(\"No\"),\n    }", "    // TODO: return\
    \ 'Yes' if the file's name is valid, 'No' otherwise\n    if file_name.len() >\
    \ 256 {\n        return String::from(\"No\");\n    }\n    let check_file_name\
    \ = file_name.clone();\n    let mut check_number = 0;\n    let mut count_number\
    \ = 0;\n    let mut count_dot = 0;\n    let mut check_extension = 0;\n    for\
    \ i in check_file_name.chars() {\n        if i.is_numeric() == true {\n      \
    \      count_number += 1;\n        }\n        if i == '.' {\n            count_dot\
    \ += 1;\n        }\n    }\n    if count_number > 3 {\n        return String::from(\"\
    No\");\n    }\n    if count_dot > 1 {\n        return String::from(\"No\");\n\
    \    }\n    if count_dot == 0 {\n        return String::from(\"No\");\n    }\n\
    \    let split = file_name.split(\".\");\n    let vec: Vec<&str> = split.collect();\n\
    \    let extension = vec[1];\n    let check_extension = extension.clone();\n \
    \   let check_name = vec[0];\n    let check_extension = check_extension.to_lowercase();\n\
    \    let mut set_character: Vec<char> = vec![];\n    for i in check_name.chars()\
    \ {\n        set_character.push(i);\n    }\n    if set_character[0].is_alphabetic()\
    \ == false {\n        return String::from(\"No\");\n    }\n    if check_extension\
    \ != \"txt\" && check_extension != \"exe\" && check_extension != \"dll\" {\n \
    \       return String::from(\"No\");\n    }\n    return String::from(\"Yes\");",
  "    let mut cnt_digits = 0;\n    let mut cnt_dot = 0;\n    let mut valid_prefix\
    \ = false;\n    let mut valid_suffix = false;\n    let mut iter = file_name.chars();\n\
    \    let mut curr_char = iter.next();\n    while curr_char != None {\n       \
    \ if curr_char.unwrap().is_digit(10) {\n            cnt_digits += 1;\n       \
    \ } else if curr_char.unwrap() == '.' {\n            cnt_dot += 1;\n        }\
    \ else if curr_char.unwrap().is_alphabetic() {\n            valid_prefix = true;\n\
    \        }\n        curr_char = iter.next();\n    }\n    if cnt_digits > 3 ||\
    \ cnt_dot != 1 || !valid_prefix {\n        return String::from(\"No\");\n    }\n\
    \    let mut suffix = file_name.split(\".\").collect::<Vec<&str>>()[1];\n    if\
    \ suffix == \"txt\" || suffix == \"exe\" || suffix == \"dll\" {\n        valid_suffix\
    \ = true;\n    }\n    if valid_suffix {\n        return String::from(\"Yes\");\n\
    \    }\n    return String::from(\"No\");", "    let v: Vec<&str> = file_name.split('.').collect();\n\
    \    if v.len() != 2 {\n        return String::from(\"No\");\n    }\n    for c\
    \ in v[0].chars() {\n        if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <=\
    \ 'Z')) {\n            return String::from(\"No\");\n        }\n    }\n    if\
    \ v[1] != \"txt\" && v[1] != \"exe\" && v[1] != \"dll\" {\n        return String::from(\"\
    No\");\n    }\n    if v[0].len() == 0 {\n        return String::from(\"No\");\n\
    \    }\n    let mut counter = 0;\n    for c in v[0].chars() {\n        if c >=\
    \ '0' && c <= '9' {\n            counter += 1;\n        }\n    }\n    if counter\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");", "    let mut count_digits = 0;\n    let mut count_dot = 0;\n    let\
    \ mut has_latin_letter = false;\n    let mut has_txt = false;\n    let mut has_exe\
    \ = false;\n    let mut has_dll = false;\n    for ch in file_name.chars() {\n\
    \        if ch >= '0' && ch <= '9' {\n            count_digits += 1;\n       \
    \ } else if ch == '.' {\n            count_dot += 1;\n        } else if ch >=\
    \ 'a' && ch <= 'z' {\n            has_latin_letter = true;\n        } else if\
    \ ch >= 'A' && ch <= 'Z' {\n            has_latin_letter = true;\n        } else\
    \ if ch == 't' {\n            has_txt = true;\n        } else if ch == 'e' {\n\
    \            has_exe = true;\n        } else if ch == 'd' {\n            has_dll\
    \ = true;\n        }\n    }\n    if count_digits > 3 || count_dot != 1 || !has_latin_letter\
    \ || !has_txt && !has_exe && !has_dll {\n        return String::from(\"No\");\n\
    \    }\n    String::from(\"Yes\")", "    use regex::Regex;\n    let re = Regex::new(r\"\
    ^[a-zA-Z][a-zA-Z0-9]{0,2}\\.(txt|exe|dll)$\").unwrap();\n    if re.is_match(&file_name)\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }", "    let bytes = file_name.as_bytes();\n    let mut dot_index = -1;\n\
    \    let mut digits_count = 0;\n    for i in 0..bytes.len() {\n        if bytes[i]\
    \ == b'.' {\n            dot_index = i;\n        }\n        if b'0' <= bytes[i]\
    \ && bytes[i] <= b'9' {\n            digits_count += 1;\n        }\n    }\n  \
    \  if digits_count > 3 || dot_index < 1 || dot_index == bytes.len() - 1 {\n  \
    \      return String::from(\"No\");\n    }\n    let file_name_prefix = &file_name[..dot_index];\n\
    \    let mut prefix_chars = file_name_prefix.chars();\n    let first_char = prefix_chars.next().unwrap();\n\
    \    if !(first_char.is_alphabetic() && first_char.is_lowercase()) {\n       \
    \ return String::from(\"No\");\n    }\n    for c in prefix_chars {\n        if\
    \ !c.is_alphanumeric() {\n            return String::from(\"No\");\n        }\n\
    \    }\n    let file_name_suffix = &file_name[dot_index + 1..];\n    if file_name_suffix\
    \ == \"txt\" || file_name_suffix == \"exe\" || file_name_suffix == \"dll\" {\n\
    \        return String::from(\"Yes\");\n    }\n    return String::from(\"No\"\
    );", '    unimplemented!()', "    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n\n    let after_dot = &file_name[file_name.find('.').unwrap()\
    \ + 1..];\n    if ![\"txt\", \"exe\", \"dll\"].contains(&after_dot.as_str()) {\n\
    \        return String::from(\"No\");\n    }\n\n    return String::from(\"Yes\"\
    );", '    unimplemented!();', "    let mut num_of_digits = 0;\n    let mut dot_found\
    \ = false;\n    let mut after_dot = String::new();\n    let mut before_dot = String::new();\n\
    \    for c in file_name.chars() {\n        if c.is_ascii_digit() {\n         \
    \   num_of_digits += 1;\n        }\n        if c == '.' {\n            dot_found\
    \ = true;\n        }\n        if c.is_ascii_alphabetic() && !dot_found {\n   \
    \         before_dot.push(c);\n        }\n        if c.is_ascii_alphabetic() &&\
    \ dot_found {\n            after_dot.push(c);\n        }\n    }\n    if num_of_digits\
    \ > 3 || !before_dot.chars().next().unwrap().is_ascii_alphabetic() || !dot_found\
    \ || !['txt', 'exe', 'dll'].contains(&after_dot.as_str()) {\n        String::from(\"\
    No\")\n    } else {\n        String::from(\"Yes\")\n    }", "    // Assuming that\
    \ the file name is valid by default.\n    let mut result = String::from(\"Yes\"\
    );\n    // If the file name is valid, the number of digits in the file name should\
    \ be less than\n    // or equal to 3.\n    let mut number_of_digits = 0;\n   \
    \ // Keep track of the number of dots. There should be exactly one.\n    let mut\
    \ number_of_dots = 0;\n    // Start and end index of the substring before the\
    \ dot.\n    let mut substring_before_dot_start_index = 0;\n    let mut substring_before_dot_end_index\
    \ = 0;\n    // Start and end index of the substring after the dot.\n    let mut\
    \ substring_after_dot_start_index = 0;\n    let mut substring_after_dot_end_index\
    \ = 0;\n    // Traverse the given file name, and set the start and end index of\
    \ the substrings before\n    // and after the dot.\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c.is_digit(10) {\n            number_of_digits += 1;\n       \
    \ } else if c == '.' {\n            number_of_dots += 1;\n            substring_before_dot_end_index\
    \ = i;\n            substring_after_dot_start_index = i + 1;\n            substring_after_dot_end_index\
    \ = file_name.len();\n        }\n    }\n    // The number of digits should be\
    \ less than or equal to 3.\n    if number_of_digits > 3 {\n        result = String::from(\"\
    No\");\n    }\n    // There should be exactly one dot.\n    if number_of_dots\
    \ != 1 {\n        result = String::from(\"No\");\n    }\n    // Validate the substring\
    \ before the dot.\n    let mut first_letter_valid = false;\n    for c in file_name.chars().take(substring_before_dot_end_index)\
    \ {\n        if c.is_alphabetic() {\n            first_letter_valid = true;\n\
    \            break;\n        }\n    }\n    if !first_letter", "    if file_name.matches(char::is_digit).count()\
    \ > 3 || file_name.matches(\".\").count() != 1 {\n        return String::from(\"\
    No\");\n    }\n    let mut split = file_name.split(\".\");\n    let before_dot\
    \ = split.next().unwrap();\n    let after_dot = split.next().unwrap();\n    let\
    \ bool_is_ext = [\"txt\", \"exe\", \"dll\"].contains(&after_dot);\n    let bool_is_valid\
    \ = !before_dot.is_empty() && before_dot.chars().next().unwrap().is_alphabetic();\n\
    \    if bool_is_ext && bool_is_valid {\n        return String::from(\"Yes\");\n\
    \    }\n    String::from(\"No\")", "\tlet re = Regex::new(r\"(?i)^[a-z]([a-z0-9]{0,2}?)\\\
    .(txt|exe|dll)$\").unwrap();\n\tif re.is_match(&file_name) {\n\t\tString::from(\"\
    Yes\")\n\t} else {\n\t\tString::from(\"No\")\n\t}", "    // write your code here\n\
    \    String::from(\"No\")", "    let mut file_parts = file_name.split('.');\n\
    \    let pre_dot = file_parts.next().unwrap();\n    let post_dot = file_parts.next().unwrap();\n\
    \    if post_dot != \"txt\" && post_dot != \"exe\" && post_dot != \"dll\" {\n\
    \        return String::from(\"No\");\n    }\n    if pre_dot.len() == 0 {\n  \
    \      return String::from(\"No\");\n    }\n    let mut n_digits = 0;\n    for\
    \ c in pre_dot.chars() {\n        if c.is_digit(10) {\n            n_digits +=\
    \ 1;\n        }\n    }\n    if n_digits > 3 {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");", '    return String::from("Not
    implemented");', "    let mut digit_count = 0;\n    let mut dot_count = 0;\n \
    \   let mut extension = \"\";\n    let mut file_name_part = \"\";\n    let mut\
    \ extension_empty = true;\n    let mut file_name_part_empty = true;\n    for c\
    \ in file_name.chars() {\n        if c.is_numeric() {\n            digit_count\
    \ += 1;\n        } else if c == '.' {\n            dot_count += 1;\n         \
    \   extension_empty = false;\n        } else if c.is_alphabetic() {\n        \
    \    if dot_count == 0 {\n                file_name_part_empty = false;\n    \
    \        }\n        }\n    }\n    if extension_empty || file_name_part_empty {\n\
    \        return String::from(\"No\");\n    } else if digit_count > 3 || dot_count\
    \ != 1 {\n        return String::from(\"No\");\n    }\n    let file_extension_regex\
    \ = Regex::new(r\"(txt|exe|dll)$\").unwrap();\n    if file_extension_regex.is_match(&file_name)\
    \ {\n        return String::from(\"Yes\");\n    }\n    return String::from(\"\
    No\");", "    if file_name.len() < 3 {\n        return String::from(\"No\");\n\
    \    }\n    if file_name.chars().count() < 3 {\n        return String::from(\"\
    No\");\n    }\n    let chars: Vec<char> = file_name.chars().collect();\n    let\
    \ mut dot_pos = 0;\n    let mut digits_count = 0;\n    for (i, char) in chars.iter().enumerate()\
    \ {\n        if char.is_digit(10) {\n            digits_count += 1;\n        }\n\
    \        if digits_count > 3 {\n            return String::from(\"No\");\n   \
    \     }\n        if char == &'.' {\n            dot_pos = i;\n        }\n    }\n\
    \    if dot_pos == 0 {\n        return String::from(\"No\");\n    }\n    if chars[dot_pos\
    \ + 1] == '.' {\n        return String::from(\"No\");\n    }\n    let ext_name\
    \ = &file_name[dot_pos + 1..];\n    if ext_name == \"txt\" || ext_name == \"exe\"\
    \ || ext_name == \"dll\" {\n        return String::from(\"Yes\");\n    }\n   \
    \ String::from(\"No\")", "    const DIGITS: &str = \"0123456789\";\n    let mut\
    \ digit_count = 0;\n    let mut letter_count = 0;\n    let mut dot_count = 0;\n\
    \    let mut last_char = '_';\n    for c in file_name.chars() {\n        if DIGITS.contains(c)\
    \ {\n            digit_count += 1;\n        }\n        if (c >= 'a' && c <= 'z')\
    \ || (c >= 'A' && c <= 'Z') {\n            letter_count += 1;\n        }\n   \
    \     if c == '.' {\n            dot_count += 1;\n        }\n        last_char\
    \ = c;\n    }\n    if dot_count != 1 ||\n        digit_count > 3 ||\n        letter_count\
    \ == 0 ||\n        last_char == '.' {\n        return String::from(\"No\");\n\
    \    }\n    let mut split = file_name.split('.');\n    let ext = split.next_back().unwrap();\n\
    \    let valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    if valid_extensions.contains(&ext)\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")",
  "    let file_name = file_name.chars().collect::<Vec<char>>();\n    let mut digit_count\
    \ = 0;\n    let mut dot_count = 0;\n    let mut has_letter = false;\n    let mut\
    \ has_ext = false;\n    let mut has_no_letter = false;\n    let mut has_dot =\
    \ false;\n    let mut valid_dot = false;\n    let ext_vec = [\"txt\", \"exe\"\
    , \"dll\"];\n    let mut ext_str = String::new();\n    for i in 0..file_name.len()\
    \ {\n        let c = file_name[i];\n        if c.is_digit(10) {\n            digit_count\
    \ += 1;\n        }\n        if c == '.' {\n            has_dot = true;\n     \
    \       dot_count += 1;\n        }\n        if c.is_lowercase() || c.is_uppercase()\
    \ {\n            has_letter = true;\n        }\n        if c == '.' && i != 0\
    \ && i != file_name.len() - 1 && has_letter {\n            valid_dot = true;\n\
    \        }\n        if (c.is_lowercase() || c.is_uppercase()) && !has_letter {\n\
    \            has_no_letter = true;\n        }\n        if valid_dot && i != 0\
    \ && i != file_name.len() - 1 {\n            ext_str.push(c);\n        }\n   \
    \ }\n    for ext in ext_vec.iter() {\n        if ext_str == ext.to_string() {\n\
    \            has_ext = true;\n        }\n    }\n    if digit_count > 3 || dot_count\
    \ != 1 || has_no_letter || !has_dot || !has_ext {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");", "    // TODO\n    \"Yes\".to_string()",
  '    unimplemented!()', "    const NUM_DIGITS: usize = 3;\n    const MAX_FILE_SIZE:\
    \ usize = 256;\n    let mut digits = 0;\n    let mut dot_count = 0;\n    let mut\
    \ fname_size = 0;\n    let mut fname_begin = 0;\n    let mut fname_end = 0;\n\
    \    let mut is_valid = true;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        match c {\n            '.' => {\n                if dot_count > 0\
    \ {\n                    is_valid = false;\n                    break;\n     \
    \           }\n                if fname_size < 2 {\n                    is_valid\
    \ = false;\n                    break;\n                }\n                dot_count\
    \ += 1;\n                fname_end = i;\n            },\n            '0'...'9'\
    \ => {\n                digits += 1;\n                if digits > NUM_DIGITS {\n\
    \                    is_valid = false;\n                    break;\n         \
    \       }\n            },\n            'a'...'z' | 'A'...'Z' => {\n          \
    \      if dot_count > 0 {\n                    is_valid = false;\n           \
    \         break;\n                }\n                if fname_size == 0 {\n  \
    \                  fname_begin = i;\n                }\n                fname_size\
    \ += 1;\n            },\n            _ => {\n                is_valid = false;\n\
    \                break;\n            }\n        }\n    }\n    if is_valid {\n\
    \        if fname_size == 0 || fname_size + NUM_DIGITS + 1 != file_name.len()\
    \ {\n            is_valid = false;\n        } else {\n            let ext = &file_name[fname_end\
    \ + 1..];\n            if ext != \"txt\" && ext != \"exe\" && ext != \"dll\" {\n\
    \                is_valid = false;\n            }\n        }\n    }\n    if is_valid\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }", "    let mut dot_found = false;\n    let mut digits_count = 0;\n  \
    \  let mut letters_count = 0;\n    let file_name_bytes = file_name.as_bytes();\n\
    \    for i in 0..file_name_bytes.len() {\n        if file_name_bytes[i] == b'.'\
    \ {\n            dot_found = true;\n        } else if dot_found {\n          \
    \  match file_name_bytes[i] {\n                b't' => {\n                   \
    \ if digits_count > 3 || letters_count == 0 {\n                        return\
    \ String::from(\"No\");\n                    }\n                    digits_count\
    \ = 0;\n                    letters_count = 0;\n                },\n         \
    \       b'x' => {\n                    if digits_count > 3 || letters_count ==\
    \ 0 {\n                        return String::from(\"No\");\n                \
    \    }\n                    digits_count = 0;\n                    letters_count\
    \ = 0;\n                },\n                b'd' => {\n                    if\
    \ digits_count > 3 || letters_count == 0 {\n                        return String::from(\"\
    No\");\n                    }\n                    digits_count = 0;\n       \
    \             letters_count = 0;\n                },\n                b'0'...b'9'\
    \ => {\n                    digits_count += 1;\n                    if digits_count\
    \ > 3 {\n                        return String::from(\"No\");\n              \
    \      }\n                },\n                _ => {\n                    return\
    \ String::from(\"No\");\n                }\n            }\n        } else {\n\
    \            match file_name_bytes[i] {\n                b'a'...b'z' => {\n  \
    \                  letters_count += 1;\n                },\n                b'A'...b'Z'\
    \ => {\n                    letters_count += 1;\n                },\n        \
    \        b'0'...b'9' => {\n                    digits_count += 1;\n          \
    \          if digits_count > 3 {\n                        return String::from(\"\
    No\");\n                    }\n                },\n                _ => {\n  \
    \                  return String::from(\"No\");\n                }\n         \
    \   }\n        }\n    }\n    if digits_count > 3 || letters_count == 0 {\n   \
    \     return String::from(\"No\");\n    }\n    String::from(\"Yes\")", "    let\
    \ mut count = 0;\n    let mut valid = true;\n    let mut letters = false;\n  \
    \  let mut dot = false;\n    let mut check = false;\n    let mut check_end = false;\n\
    \    let mut end = false;\n    let mut end_str = String::new();\n    let mut ext_str\
    \ = String::new();\n    for i in file_name.chars() {\n        if i == '.' {\n\
    \            dot = true;\n            end = true;\n        } else if !end {\n\
    \            if !letters {\n                letters = i.is_alphabetic();\n   \
    \         }\n            if i.is_numeric() {\n                count += 1;\n  \
    \          }\n        } else {\n            end_str.push(i);\n        }\n    }\n\
    \    for i in end_str.chars() {\n        if !check {\n            check = i.is_alphabetic();\n\
    \        } else if !check_end {\n            check_end = i.is_alphabetic();\n\
    \        } else {\n            ext_str.push(i);\n        }\n    }\n    valid =\
    \ !(count > 3 || dot == false || !letters || \n        (check_end && check) ||\
    \ end_str != \".txt\" && end_str != \".exe\" && end_str != \".dll\");\n    if\
    \ valid {\n        return String::from(\"Yes\");\n    } else {\n        return\
    \ String::from(\"No\");\n    }", "    // TODO: Implement\n    String::from(\"\
    Yes\")", "    // We can use the same regex as we used for checking file name for\
    \ assignments,\n    // but we'll omit the module names and the assignment's number\
    \ from the regex\n    // and create an entirely new function\n    if is_valid_file_name(file_name)\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }", "    let mut digits_count = 0;\n    let mut dot_count = 0;\n    let mut\
    \ valid_extensions = vec![\"txt\", \"exe\", \"dll\"];\n    for c in file_name.chars()\
    \ {\n        match c {\n            '0'...'9' => digits_count += 1,\n        \
    \    '.' => dot_count += 1,\n            _ => (),\n        }\n    }\n    if digits_count\
    \ > 3 || dot_count != 1 {\n        return String::from(\"No\");\n    }\n    let\
    \ parts: Vec<&str> = file_name.split('.').collect();\n    if parts[0].is_empty()\
    \ || valid_extensions.contains(&parts[1]) == false {\n        return String::from(\"\
    No\");\n    }\n    if !(parts[0].chars().next().unwrap().is_alphabetic()) {\n\
    \        return String::from(\"No\");\n    }\n    return String::from(\"Yes\"\
    );", "    // TODO: Complete the function\n    String::from(\"No\")", "    let\
    \ mut count_digits = 0;\n    let mut count_dots = 0;\n    let mut ext = 0;\n \
    \   let mut flag = false;\n    let mut first_letter = false;\n    for c in file_name.chars()\
    \ {\n        match c {\n            '.' => {\n                if flag == false\
    \ {\n                    count_dots += 1;\n                    flag = true;\n\
    \                } else {\n                    return String::from(\"No\");\n\
    \                }\n            }\n            '0'..='9' => {\n              \
    \  count_digits += 1;\n            }\n            'A'..='Z' | 'a'..='z' => {\n\
    \                if flag == false {\n                    first_letter = true;\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  if count_digits > 3 {\n        return String::from(\"No\");\n    }\n    if\
    \ count_dots != 1 {\n        return String::from(\"No\");\n    }\n    if first_letter\
    \ == false {\n        return String::from(\"No\");\n    }\n    if file_name.contains(\"\
    .txt\") {\n        ext = 1;\n    } else if file_name.contains(\".exe\") {\n  \
    \      ext = 2;\n    } else if file_name.contains(\".dll\") {\n        ext = 3;\n\
    \    } else {\n        return String::from(\"No\");\n    }\n    if ext != 0 {\n\
    \        return String::from(\"Yes\");\n    }\n    String::from(\"No\")", "  \
    \  // Your code goes here\n    let reg = Regex::new(r\"^[A-Za-z][A-Za-z0-9]{0,3}\\\
    .txt$|^[A-Za-z][A-Za-z0-9]{0,3}\\.exe$|^[A-Za-z][A-Za-z0-9]{0,3}\\.dll$\").unwrap();\n\
    \    if reg.is_match(&file_name) {\n        return String::from(\"Yes\");\n  \
    \  }\n    return String::from(\"No\");", "    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        String::from(\"No\")\n    } else if file_name.chars().filter(|&c|\
    \ c == '.').count() != 1 {\n        String::from(\"No\")\n    } else if !file_name.chars().take_while(|&c|\
    \ c != '.').all(char::is_alphabetic) {\n        String::from(\"No\")\n    } else\
    \ if !file_name.split('.').last().map_or(false, |s| s == \"txt\" || s == \"exe\"\
    \ || s == \"dll\") {\n        String::from(\"No\")\n    } else {\n        String::from(\"\
    Yes\")\n    }", "    // Check that there are not more than three digits\n    if\
    \ file_name.chars().filter(|&x| x >= '0' && x <= '9').count() > 3 {\n        return\
    \ String::from(\"No\");\n    }\n\n    // Check that the file name contains exactly\
    \ one dot, and check for its location\n    let dot_index = file_name.find('.');\n\
    \    if dot_index.is_none() || file_name.matches(\".\").count() != 1 {\n     \
    \   return String::from(\"No\");\n    }\n    let dot_index = dot_index.unwrap();\n\
    \n    // Check that the string before the dot is not empty, and starts with a\
    \ letter\n    let before_dot = &file_name[..dot_index];\n    if before_dot.is_empty()\
    \ || !(before_dot.chars().next().unwrap().is_alphabetic()) {\n        return String::from(\"\
    No\");\n    }\n\n    // Check that the string after the dot is one of the valid\
    \ options\n    let after_dot = &file_name[dot_index+1..];\n    match after_dot\
    \ {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _\
    \ => String::from(\"No\"),\n    }", '    unimplemented!();', "    let mut is_a_valid_file_name\
    \ = true;\n    let mut digits_number = 0;\n    let mut dot_number = 0;\n    let\
    \ mut dot_position = 0;\n    let mut last_character_position = 0;\n    for (index,\
    \ character) in file_name.chars().enumerate() {\n        if character.is_numeric()\
    \ {\n            digits_number += 1;\n        }\n        if character == '.' {\n\
    \            dot_number += 1;\n            dot_position = index;\n        }\n\
    \        last_character_position = index;\n    }\n    if digits_number > 3 ||\
    \ dot_number != 1 || dot_position == 0 || dot_position == last_character_position\
    \ {\n        is_a_valid_file_name = false;\n    }\n    let mut file_name_splitted\
    \ = file_name.split('.');\n    let (file_name_first_part, file_name_second_part)\
    \ = (file_name_splitted.next().unwrap(), file_name_splitted.next().unwrap());\n\
    \    if !file_name_first_part.is_empty() {\n        let mut first_character =\
    \ file_name_first_part.chars().next().unwrap();\n        if !first_character.is_alphabetic()\
    \ {\n            is_a_valid_file_name = false;\n        }\n    }\n    if file_name_second_part\
    \ != \"txt\" && file_name_second_part != \"exe\" && file_name_second_part != \"\
    dll\" {\n        is_a_valid_file_name = false;\n    }\n    if is_a_valid_file_name\
    \ {\n        return String::from(\"Yes\");\n    }\n    return String::from(\"\
    No\");", "    // check for more than three digits\n    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n\n    // check for exatly\
    \ one dot\n    if file_name.matches('.').count() != 1 {\n        return String::from(\"\
    No\");\n    }\n\n    // check for the first character to be a letter\n    if !file_name.chars().next().unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n\n    // check for file extensions\n\
    \    let mut parts = file_name.split('.');\n    let file_name = parts.next().unwrap();\n\
    \    let file_extension = parts.next().unwrap();\n    if file_extension == \"\
    exe\" || file_extension == \"txt\" || file_extension == \"dll\" {\n        return\
    \ String::from(\"Yes\");\n    }\n    return String::from(\"No\");", "    let mut\
    \ dot_counter = 0;\n    let mut digit_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut is_extension_valid = false;\n    let mut last_char_is_dot\
    \ = false;\n    let mut is_file_name_valid = true;\n    let mut dot_position =\
    \ file_name.len();\n    let mut valid_extensions = vec![\"txt\", \"exe\", \"dll\"\
    ];\n    let mut file_name_without_extension: String = String::new();\n    let\
    \ mut file_name_extension: String = String::new();\n\n    // First check if there\
    \ is only one dot\n    for character in file_name.chars() {\n        if character\
    \ == '.' {\n            dot_counter += 1;\n            dot_position = file_name.len()\
    \ - (file_name.chars().rev().position(|x| x == '.').unwrap() + 1);\n        }\n\
    \    }\n\n    if dot_counter != 1 {\n        return String::from(\"No\");\n  \
    \  } else {\n        // Check if the extension is one of the valid extensions\n\
    \        for valid_extension in valid_extensions.iter() {\n            if valid_extension\
    \ == &file_name[dot_position + 1..] {\n                is_extension_valid = true;\n\
    \            }\n        }\n\n        if !is_extension_valid {\n            return\
    \ String::from(\"No\");\n        } else {\n            // Check if the file's\
    \ name contains no more than three digits\n            for character in file_name.chars()\
    \ {\n                if character.is_digit(10) {\n                    digit_counter\
    \ += 1;\n                }\n            }\n\n            if digit_counter > 3\
    \ {\n                return String::from(\"No\");\n            } else {\n    \
    \            // Check if the file's name contains at least one latin letter\n\
    \                for character in file_name.chars() {\n                    if\
    \ character.is_alphabetic() {\n                        letter_counter += 1;\n\
    \                    }\n                }\n\n                if letter_counter\
    \ == 0 {\n                    return String::from(\"No\");\n                }\
    \ else {\n                    // Check if the file's name ends with a dot\n  \
    \                  for", "    // EXPLANATION:\n    // We are going to split the\
    \ string (file_name) into a vector of substrings, using '.' as a delimiter.\n\
    \    // This is going to yield a vector with two elements, one for the substring\
    \ before the dot,\n    // and the other for the substring after the dot.\n   \
    \ // If the substring before the dot is empty, this means that there is no letter\
    \ 'a'-'z' or 'A'-'Z' \n    // in the file's name.\n    // If the substring after\
    \ the dot is empty, this means that there is no substring after the dot,\n   \
    \ // which means that the file's name doesn't contain a dot.\n    // If the length\
    \ of the vector after splitting the file's name with '.' as a delimiter is not\
    \ equal\n    // to 2, this means that the file's name contains either more than\
    \ one dot, or no dot at all.\n    // If the length of the vector after splitting\
    \ the file's name with '.' as a delimiter is equal to 2,\n    // we are going\
    \ to check the rest of the conditions\n    // We are going to create a vector\
    \ named 'substrings' and then we are going to insert into it the substrings\n\
    \    // resulting from splitting the file's name.\n    let mut substrings: Vec<&str>\
    \ = Vec::new();\n    // We are going to push the substrings into the vector 'substrings'.\n\
    \    substrings.push(file_name.split('.').next().unwrap());\n    substrings.push(file_name.split('.').last().unwrap());\n\
    \    // EXPLANATION:\n    // We are going to count the number of digits inside\
    \ the file's name.\n    // We are going to create a variable named 'digits_count'\
    \ and we are going to assign to it the value 0.\n    let mut digits_count = 0;\n\
    \    // We are going to loop through all the characters inside the file's name.\n\
    \    for c in file_name.chars() {\n        // We are going to check if the current\
    \ character is a digit ('0'-'9').\n        if c.is_digit(10) {\n            //\
    \ If it is, we are going to increment the variable 'digits_count'", "    match\
    \ count_digits(&file_name) {\n        None => String::from(\"No\"),\n        Some(x)\
    \ => {\n            if x > 3 {\n                String::from(\"No\")\n       \
    \     } else {\n                let extension = file_name.split('.').last().unwrap().to_lowercase();\n\
    \                if extension == \"txt\" || extension == \"exe\" || extension\
    \ == \"dll\" {\n                    let file_name_split = file_name.split('.').collect::<Vec<&str>>();\n\
    \                    if file_name_split.len() == 2 && file_name_split[0].chars().next().unwrap().is_alphabetic()\
    \ {\n                        String::from(\"Yes\")\n                    } else\
    \ {\n                        String::from(\"No\")\n                    }\n   \
    \             } else {\n                    String::from(\"No\")\n           \
    \     }\n            }\n        }\n    }", '    unimplemented!()', "    if let\
    \ Some(position) = file_name.find('.') {\n        if position == 0 {\n       \
    \     return String::from(\"No\");\n        }\n        let sub_string: String\
    \ = file_name.chars().take(position).collect();\n        if sub_string.parse::<u32>().is_ok()\
    \ {\n            return String::from(\"No\");\n        }\n        let mut counter\
    \ = 0;\n        for c in sub_string.chars() {\n            if c.is_numeric() {\n\
    \                counter += 1;\n            }\n        }\n        if counter >\
    \ 3 {\n            return String::from(\"No\");\n        }\n        let (start,\
    \ end) = file_name.split_at(position);\n        let (_, extension) = end.split_at(1);\n\
    \        if extension == \"txt\" || extension == \"exe\" || extension == \"dll\"\
    \ {\n            return String::from(\"Yes\");\n        }\n    }\n    String::from(\"\
    No\")", "    let mut digits_num = 0;\n    let mut dot_num = 0;\n    let mut has_letter\
    \ = false;\n    let mut has_extension = false;\n    let mut dot_index = 0;\n \
    \   let mut l_char = '.';\n    let mut r_char = '.';\n    for (i, ch) in file_name.chars().enumerate()\
    \ {\n        if ch.is_digit(10) {\n            digits_num += 1;\n        }\n \
    \       if ch == '.' {\n            dot_num += 1;\n            dot_index = i;\n\
    \        }\n        if ch.is_alphabetic() {\n            has_letter = true;\n\
    \        }\n        if i < dot_index {\n            l_char = ch;\n        }\n\
    \        if i > dot_index {\n            r_char = ch;\n        }\n    }\n    if\
    \ digits_num > 3 {\n        return String::from(\"No\");\n    }\n    if !has_letter\
    \ {\n        return String::from(\"No\");\n    }\n    if !((l_char >= 'a' && l_char\
    \ <= 'z') || (l_char >= 'A' && l_char <= 'Z')) {\n        return String::from(\"\
    No\");\n    }\n    if dot_num != 1 {\n        return String::from(\"No\");\n \
    \   }\n    if r_char == 't' {\n        has_extension = true;\n    }\n    if r_char\
    \ == 'e' {\n        has_extension = true;\n    }\n    if r_char == 'd' {\n   \
    \     has_extension = true;\n    }\n    if has_extension {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");", "    let mut digit_count =\
    \ 0;\n    let mut dot_count = 0;\n    let mut prefix_ok = false;\n    let mut\
    \ suffix_ok = false;\n    let prefix_len = 0;\n    let suffix_len = 0;\n    for\
    \ character in file_name.chars() {\n        if character.is_digit(10) {\n    \
    \        digit_count += 1;\n        } else if character == '.' {\n           \
    \ dot_count += 1;\n        } else if !prefix_ok {\n            if character.is_ascii_alphabetic()\
    \ {\n                prefix_ok = true;\n            }\n        }\n    }\n    if\
    \ prefix_ok && dot_count == 1 && digit_count <= 3 {\n        let suffix = &file_name[prefix_len\
    \ + 1..];\n        suffix_ok = suffix == \"txt\" || suffix == \"exe\" || suffix\
    \ == \"dll\";\n    }\n    if prefix_ok && suffix_ok {\n        return String::from(\"\
    Yes\");\n    }\n    String::from(\"No\")", "    let mut digits_counter = 0;\n\
    \    let mut dot_counter = 0;\n    let mut in_sub_string = false;\n    let mut\
    \ is_valid = true;\n    let mut previous_char = '.';\n    for c in file_name.chars()\
    \ {\n        if !c.is_alphanumeric() {\n            if c == '.' {\n          \
    \      dot_counter += 1;\n                if dot_counter > 1 {\n             \
    \       is_valid = false;\n                    break;\n                }\n   \
    \             in_sub_string = false;\n            } else {\n                is_valid\
    \ = false;\n                break;\n            }\n        } else {\n        \
    \    if c.is_digit(10) {\n                digits_counter += 1;\n             \
    \   if digits_counter > 3 {\n                    is_valid = false;\n         \
    \           break;\n                }\n            } else if !in_sub_string {\n\
    \                if c.is_lowercase() || c.is_uppercase() {\n                 \
    \   in_sub_string = true;\n                } else {\n                    is_valid\
    \ = false;\n                    break;\n                }\n            }\n   \
    \     }\n        previous_char = c;\n    }\n    if previous_char == '.' {\n  \
    \      is_valid = false;\n    }\n    if is_valid {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }", "    let mut counter =\
    \ 0;\n    for (i, c) in file_name.chars().enumerate() {\n        if c.is_numeric()\
    \ {\n            counter += 1;\n        }\n        if counter > 3 {\n        \
    \    return String::from(\"No\");\n        }\n        if counter == 1 && !c.is_numeric()\
    \ {\n            return String::from(\"No\");\n        }\n        if counter ==\
    \ 2 && !c.is_numeric() {\n            return String::from(\"No\");\n        }\n\
    \        if counter == 3 && !c.is_numeric() {\n            return String::from(\"\
    No\");\n        }\n        if i == file_name.len() - 1 && !c.is_numeric() {\n\
    \            return String::from(\"No\");\n        }\n    }\n    let chars: Vec<char>\
    \ = file_name.chars().collect();\n    if chars[0].is_numeric() {\n        return\
    \ String::from(\"No\");\n    }\n    if chars[0] == '.' {\n        return String::from(\"\
    No\");\n    }\n    if chars[file_name.len() - 1] == '.' {\n        return String::from(\"\
    No\");\n    }\n    let mut counter = 0;\n    for c in file_name.chars() {\n  \
    \      if c == '.' {\n            counter += 1;\n        }\n    }\n    if counter\
    \ != 1 {\n        return String::from(\"No\");\n    }\n    let v: Vec<&str> =\
    \ file_name.split('.').collect();\n    if v[1] != \"txt\" && v[1] != \"exe\" &&\
    \ v[1] != \"dll\" {\n        return String::from(\"No\");\n    }\n    String::from(\"\
    Yes\")", "    let bytes = file_name.as_bytes();\n    let mut i = 0;\n    let mut\
    \ count = 0;\n    let mut is_digit = false;\n    let mut dot_found = false;\n\
    \    let mut dot_index = 0;\n    let mut chars_found = 0;\n    for _ in 0..bytes.len()\
    \ {\n        if (bytes[i] >= b'a' && bytes[i] <= b'z') || (bytes[i] >= b'A' &&\
    \ bytes[i] <= b'Z') {\n            chars_found += 1;\n        }\n        if bytes[i]\
    \ >= b'0' && bytes[i] <= b'9' {\n            is_digit = true;\n            count\
    \ += 1;\n        }\n        if bytes[i] == b'.' {\n            dot_found = true;\n\
    \            dot_index = i;\n        }\n        i += 1;\n    }\n    if count >\
    \ 3 || !dot_found || chars_found == 0 ||\n        !(&file_name[dot_index+1..]\
    \ == \"txt\" ||\n        &file_name[dot_index+1..] == \"exe\" ||\n        &file_name[dot_index+1..]\
    \ == \"dll\") {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");", "    if file_name.chars().filter(|&c| c.is_digit(10)).count() > 3 {\n\
    \        return String::from(\"No\");\n    }\n    let dot_index = file_name.rfind('.').unwrap();\n\
    \    let (after_dot, before_dot) = file_name.split_at(dot_index);\n    let after_dot\
    \ = &after_dot[1..];\n    let before_dot = &before_dot[..dot_index];\n    if !(after_dot\
    \ == \"txt\" || after_dot == \"exe\" || after_dot == \"dll\") {\n        return\
    \ String::from(\"No\");\n    }\n    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")",
  "    // Your code goes here.\n    // Feel free to write helper functions as you\
    \ see fit.\n    if file_name.len() < 4 {\n        return String::from(\"No\");\n\
    \    }\n    if file_name.chars().nth(0).unwrap().is_digit(10) {\n        return\
    \ String::from(\"No\");\n    }\n    let dots: Vec<_> = file_name.match_indices(\"\
    .\").collect();\n    if dots.len() != 1 {\n        return String::from(\"No\"\
    );\n    }\n    let (start, end) = dots[0];\n    if end == file_name.len()-1 {\n\
    \        return String::from(\"No\");\n    }\n    let (name, extension) = file_name.split_at(end);\n\
    \    let mut digits = 0;\n    for c in name.chars() {\n        if c.is_digit(10)\
    \ {\n            digits += 1;\n        }\n    }\n    if digits > 3 {\n       \
    \ return String::from(\"No\");\n    }\n    if extension == \"txt\" || extension\
    \ == \"exe\" || extension == \"dll\" {\n        return String::from(\"Yes\");\n\
    \    }\n    return String::from(\"No\");", '    unimplemented!()', "    let mut\
    \ counter = 0;\n    let mut new_str = String::new();\n    let mut flag_1 = false;\n\
    \    let mut flag_2 = false;\n    let string_vec: Vec<&str> = file_name.split('.').collect();\n\
    \    let mut dot_index = 0;\n    let mut ext_index = 0;\n    let ext: Vec<&str>\
    \ = [\".txt\", \".exe\", \".dll\"].to_vec();\n    if string_vec.len() > 2 {\n\
    \        return String::from(\"No\");\n    }\n    for (i, str) in string_vec.iter().enumerate()\
    \ {\n        dot_index = i;\n        new_str = str.to_string();\n        if i\
    \ == 1 {\n            ext_index = i;\n        }\n    }\n    for c in new_str.chars()\
    \ {\n        match c {\n            '0' | '1' | '2' | '3' | '4' | '5' | '6' |\
    \ '7' | '8' | '9' => {\n                counter += 1;\n            }\n       \
    \     'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' |\
    \ 'm' | 'n'\n            | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w'\
    \ | 'x' | 'y' | 'z' | 'A'\n            | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H'\
    \ | 'I' | 'J' | 'K' | 'L' | 'M' | 'N'\n            | 'O' | 'P' | 'Q' | 'R' | 'S'\
    \ | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' => {\n                flag_1 = true;\n\
    \            }\n            _ => {}\n        }\n    }\n    if counter > 3 {\n\
    \       ", "    // this is a placeholder to make the code below compile\n    //\
    \ you can delete it and return anything you want\n    \"Yes\".to_string()", " \
    \   let digits = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n   \
    \ let num_digits = file_name.chars().filter(|x| digits.contains(x)).count();\n\
    \    if num_digits > 3 {\n        return String::from(\"No\");\n    }\n    let\
    \ mut dot_exists = false;\n    let mut name_has_extension = false;\n    let mut\
    \ ext_is_valid = false;\n    let mut dot_index = 0;\n    for (index, ch) in file_name.chars().enumerate()\
    \ {\n        if ch == '.' {\n            dot_exists = true;\n            dot_index\
    \ = index;\n            break;\n        }\n    }\n    if !dot_exists {\n     \
    \   return String::from(\"No\");\n    }\n    if dot_index + 1 < file_name.len()\
    \ {\n        name_has_extension = true;\n    }\n    if name_has_extension {\n\
    \        let extension = &file_name[dot_index + 1..];\n        let valid_extensions\
    \ = vec![\"txt\", \"exe\", \"dll\"];\n        if valid_extensions.contains(&extension)\
    \ {\n            ext_is_valid = true;\n        }\n    }\n    if !dot_exists ||\
    \ !name_has_extension || !ext_is_valid {\n        return String::from(\"No\");\n\
    \    }\n    return String::from(\"Yes\");", "    // 1. Check if there are more\
    \ than three digits\n    let digits_count = file_name.chars().filter(|c| c.is_digit(10)).count();\n\
    \    if digits_count > 3 {\n        return String::from(\"No\");\n    }\n\n  \
    \  // 2. Check if there is exactly one dot, and the substring before it is not\
    \ empty\n    let dot_index = file_name.find('.');\n    if dot_index.is_none()\
    \ || dot_index.unwrap() == 0 {\n        return String::from(\"No\");\n    }\n\n\
    \    // 3. Check if substring after the dot is one of [txt, exe, dll]\n    let\
    \ extention = &file_name[dot_index.unwrap()+1..];\n    if extention != \"txt\"\
    \ && extention != \"exe\" && extention != \"dll\" {\n        return String::from(\"\
    No\");\n    }\n\n    String::from(\"Yes\")", "    // Write your code here\n  \
    \  unimplemented!();", "    let (before_dot, after_dot) = get_substrings(file_name);\n\
    \    if has_more_than_three_digits(&before_dot) {\n        return String::from(\"\
    No\");\n    }\n    if is_latin_letter(&before_dot[0..1]) == false {\n        return\
    \ String::from(\"No\");\n    }\n    match after_dot.as_ref() {\n        \"txt\"\
    \ | \"exe\" | \"dll\" => return String::from(\"Yes\"),\n        _ => return String::from(\"\
    No\"),\n    }", "    if file_name.contains(\"..\") || !file_name.contains(\".\"\
    ) {\n        return String::from(\"No\");\n    }\n    let mut dot_count = 0;\n\
    \    let mut digit_count = 0;\n    let mut last_char = ' ';\n    for c in file_name.chars()\
    \ {\n        if c == '.' {\n            dot_count += 1;\n            continue;\n\
    \        }\n        if c.is_digit(10) {\n            digit_count += 1;\n     \
    \   }\n        last_char = c;\n    }\n    if digit_count > 3 || dot_count != 1\
    \ || !last_char.is_alphabetic() {\n        return String::from(\"No\");\n    }\n\
    \    let mut file_type = None;\n    for ext in [\"txt\", \"exe\", \"dll\"].iter()\
    \ {\n        if file_name.ends_with(ext) {\n            file_type = Some(ext);\n\
    \            break;\n        }\n    }\n    match file_type {\n        Some(_)\
    \ => return String::from(\"Yes\"),\n        None => return String::from(\"No\"\
    ),\n    }", "    let dot_cnt = file_name.chars().filter(|&c| c == '.').count();\n\
    \    let digit_cnt = file_name.chars().filter(|&c| c.is_digit(10)).count();\n\
    \    let dot_index = file_name.find('.').unwrap();\n    let digit_index = file_name.find(|c:\
    \ char| c.is_digit(10)).unwrap();\n    let allowed_extensions = [\"txt\", \"exe\"\
    , \"dll\"];\n    let substring_ext = &file_name[dot_index + 1..];\n    if digit_cnt\
    \ > 3 || dot_cnt != 1 || \n       (digit_index < dot_index && file_name.chars().nth(0).unwrap().is_alphabetic())\
    \ ||\n       !allowed_extensions.contains(&substring_ext) {\n        return String::from(\"\
    No\");\n    }\n    String::from(\"Yes\")", "    let mut numbers = 0;\n    let\
    \ mut dot_pos = 0;\n    let mut letter_found = false;\n    let mut extension =\
    \ String::new();\n    for (pos, c) in file_name.chars().enumerate() {\n      \
    \  match c {\n            '0'..='9' => numbers += 1,\n            '.' => dot_pos\
    \ = pos,\n            'a'..='z' | 'A'..='Z' => letter_found = true,\n        \
    \    _ => {},\n        }\n    }\n    if numbers > 3 || dot_pos == 0 || !letter_found\
    \ {\n        return String::from(\"No\");\n    }\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if i > dot_pos {\n            extension.push(c);\n        }\n   \
    \ }\n    match extension.as_str() {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"\
    Yes\"),\n        _ => String::from(\"No\"),\n    }", "    // As we need to verify\
    \ that there is at most one dot in the file name, and the file name\n    // is\
    \ not empty, we'll check the length of the file name\n    if file_name.len() ==\
    \ 0 {\n        return String::from(\"No\");\n    }\n    // Here we're checking\
    \ that the first character of the string is a letter\n    if ! file_name.chars().nth(0).unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n    // In order to verify the\
    \ file name, we'll split the file name by '.' and then we'll check\n    // each\
    \ sub string\n    let file_name_split: Vec<String> = file_name.split('.').map(|x|\
    \ x.to_string()).collect();\n    // Since we're splitting by '.', the length of\
    \ the vector should be at least 2\n    if file_name_split.len() < 2 {\n      \
    \  return String::from(\"No\");\n    }\n    // Here we're checking that there\
    \ are at most 3 numbers in the string\n    if file_name_split[0].chars().filter(|&c|\
    \ c.is_numeric()).count() > 3 {\n        return String::from(\"No\");\n    }\n\
    \    // We need to verify that the substring after the dot is one of these ['txt',\
    \ 'exe', 'dll']\n    // So we'll check the length of the string, and then if the\
    \ string is not empty, we'll check \n    // the string's elements.\n    if file_name_split[1].len()\
    \ == 0 {\n        return String::from(\"No\");\n    }\n    let accepted_sub_strings\
    \ = vec![String::from(\"txt\"), String::from(\"exe\"), String::from(\"dll\")];\n\
    \    if ! accepted_sub_strings.contains(&file_name_split[1]) {\n        return\
    \ String::from(\"No\");\n    }\n    String::from(\"Yes\")", "    // TODO: return\
    \ a correct value.\n    String::from(\"Yes\")", "    // Write your code here\n\
    \    let mut count_dot = 0;\n    let mut count_digit = 0;\n    let mut is_start_with_latin\
    \ = false;\n    let length = file_name.len();\n    let mut sub_extension: String\
    \ = String::new();\n    for (i, c) in file_name.chars().enumerate() {\n      \
    \  if c == '.' {\n            count_dot += 1;\n            sub_extension = file_name[i+1..length].to_string();\n\
    \        }\n        if c.is_digit(10) {\n            count_digit += 1;\n     \
    \   }\n        if c.is_alphabetic() {\n            is_start_with_latin = true;\n\
    \        }\n    }\n    if count_dot != 1 || !is_start_with_latin || count_digit\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    match sub_extension.as_str()\
    \ {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _\
    \ => String::from(\"No\"),\n    }", '    "TODO".to_string()', "    let count_digit:\
    \ Vec<_> = file_name.matches(char::is_numeric).collect();\n    if count_digit.len()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    if !file_name.contains('.')\
    \ {\n        return String::from(\"No\");\n    }\n    let file_name_vec: Vec<_>\
    \ = file_name.split('.').collect();\n    if file_name_vec.len() > 2 {\n      \
    \  return String::from(\"No\");\n    }\n    let &file_name_vec = file_name_vec.get(0).unwrap();\n\
    \    if file_name_vec.len() == 0 {\n        return String::from(\"No\");\n   \
    \ }\n    if !file_name_vec.chars().all(|x| x.is_alphabetic()) {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name_vec.chars().any(|x| x.is_uppercase())\
    \ {\n        return String::from(\"No\");\n    }\n    let &file_extension = file_name_vec.get(1).unwrap();\n\
    \    if file_extension != \"txt\" && file_extension != \"exe\" && file_extension\
    \ != \"dll\" {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");", "    let mut number_of_digits = 0;\n    let mut number_of_dots = 0;\n\
    \    let mut previous_char_is_letter = false;\n    let mut previous_char_is_digit\
    \ = false;\n    let mut previous_char_is_dot = false;\n    let mut previous_char_is_equals_to_dot\
    \ = false;\n    let mut previous_char_is_equals_to_digit = false;\n    let mut\
    \ substring_after_dot = String::new();\n    let mut substring_before_dot = String::new();\n\
    \    let mut index = 0;\n    for char in file_name.chars() {\n        if char.is_numeric()\
    \ {\n            number_of_digits += 1;\n            previous_char_is_letter =\
    \ false;\n            previous_char_is_digit = true;\n            previous_char_is_dot\
    \ = false;\n            previous_char_is_equals_to_dot = false;\n            previous_char_is_equals_to_digit\
    \ = false;\n        } else if char == '.' {\n            number_of_dots += 1;\n\
    \            previous_char_is_letter = false;\n            previous_char_is_digit\
    \ = false;\n            previous_char_is_dot = true;\n            previous_char_is_equals_to_dot\
    \ = true;\n            previous_char_is_equals_to_digit = false;\n        } else\
    \ if char.is_alphabetic() {\n            previous_char_is_letter = true;\n   \
    \         previous_char_is_digit = false;\n            previous_char_is_dot =\
    \ false;\n            previous_char_is_equals_to_dot = false;\n            previous_char_is_equals_to_digit\
    \ = false;\n        }\n        if char == '.' {\n            index = 0;\n    \
    \    } else {\n            index += 1;\n        }\n        if index == 1 && previous_char_is_equals_to_dot\
    \ {\n            substring_after_dot.push(char);\n        } else if previous_char_is_dot\
    \ {\n            substring_before_dot.push(char", "    // TODO: return the appropriate\
    \ string representing\n    // the result of the check\n    unimplemented!();",
  "    let mut counter = 0;\n    let v: Vec<&str> = file_name.split('.').collect();\n\
    \    let mut extension = Vec::new();\n    extension.push(\"txt\");\n    extension.push(\"\
    exe\");\n    extension.push(\"dll\");\n    for c in file_name.chars() {\n    \
    \    if c.is_digit(10) {\n            counter += 1;\n        }\n    }\n    if\
    \ counter > 3 {\n        return String::from(\"No\");\n    }\n    if v.len() !=\
    \ 2 {\n        return String::from(\"No\");\n    }\n    if !v[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n    if !extension.contains(&v[1])\
    \ {\n        return String::from(\"No\");\n    }\n    return String::from(\"Yes\"\
    );", "    let mut n_digit = 0;\n    let mut n_dots = 0;\n    let mut file_name_chars\
    \ = file_name.chars();\n    let mut c = file_name_chars.next();\n    let mut is_valid\
    \ = true;\n    loop {\n        match c {\n            Some(ch) => {\n        \
    \        if ch.is_ascii_digit() {\n                    n_digit += 1;\n       \
    \         } else if ch == '.' {\n                    n_dots += 1;\n          \
    \      } else if ch.is_ascii_lowercase() {\n                    break;\n     \
    \           } else {\n                    is_valid = false;\n                \
    \    break;\n                }\n            }\n            None => {\n       \
    \         is_valid = false;\n                break;\n            }\n        }\n\
    \        c = file_name_chars.next();\n    }\n    if n_digit > 3 || n_dots != 1\
    \ || !is_valid {\n        return String::from(\"No\");\n    }\n    let mut ext\
    \ = String::new();\n    loop {\n        match c {\n            Some(ch) => {\n\
    \                ext.push(ch);\n            }\n            None => {\n       \
    \         break;\n            }\n        }\n        c = file_name_chars.next();\n\
    \    }\n    match ext.as_str() {\n        \"txt\" | \"exe\" | \"dll\" => {\n \
    \           return String::from(\"Yes\");\n        }\n        _ => {\n       \
    \     return String::from(\"No\");\n        }\n    }", "    let mut counter =\
    \ 0;\n    let mut digits = 0;\n    let mut file_name_bytes = file_name.bytes();\n\
    \    let mut first_char = file_name_bytes.next();\n    let mut first_char_is_letter\
    \ = false;\n    let mut second_char_is_dot = false;\n    let mut dot_position\
    \ = 0;\n    let mut valid_last_chars = false;\n    let mut last_three_chars =\
    \ String::new();\n    for _ in 0..file_name.len() {\n        match first_char\
    \ {\n            Some(c) => {\n                match c {\n                   \
    \ 48...57 => {\n                        digits += 1;\n                       \
    \ if digits > 3 {\n                            return String::from(\"No\");\n\
    \                        }\n                    },\n                    46 =>\
    \ {\n                        counter += 1;\n                        second_char_is_dot\
    \ = true;\n                        dot_position = counter;\n                 \
    \   },\n                    97...122 | 65...90 => {\n                        first_char_is_letter\
    \ = true;\n                    },\n                    _ => {},\n            \
    \    }\n            },\n            None => {},\n        }\n        if counter\
    \ == file_name.len()-1 {\n            let mut last_three_chars_bytes = file_name_bytes.clone();\n\
    \            last_three_chars_bytes.skip(counter-3);\n            for _ in 0..3\
    \ {\n                match last_three_chars_bytes.next() {\n                 \
    \   Some(c) => {\n                        last_three_chars.push(c as char);\n\
    \                    },\n                    None => {},\n                }\n\
    \            }\n            match last_three_chars.as_str() {\n              \
    \  \"txt\" | \"exe\" | \"dll\" => {\n                    valid_last_chars = true;\n\
    \                },\n                _ => {},\n            }\n        }\n    \
    \    first_char = file_name_bytes.next();\n        counter += 1;\n    }\n    if\
    \ first_char_is_letter && second_char_is_dot && dot_position == digits && \n \
    \       valid_last_chars {\n        return String::from(\"Yes\");\n    }\n   \
    \ String::from(\"No", "    // TODO: Implement your solution here\n    if file_name.find(\"\
    .\").is_none() {\n        return String::from(\"No\");\n    }\n    let file_name_vec:\
    \ Vec<&str> = file_name.split(\".\").collect();\n    if file_name_vec.len() !=\
    \ 2 {\n        return String::from(\"No\");\n    }\n    let first_part = file_name_vec[0];\n\
    \    let second_part = file_name_vec[1];\n    if second_part != \"txt\" && second_part\
    \ != \"exe\" && second_part != \"dll\" {\n        return String::from(\"No\");\n\
    \    }\n    if first_part.chars().next().unwrap().is_numeric() {\n        return\
    \ String::from(\"No\");\n    }\n    if first_part.chars().filter(|&c| c.is_numeric()).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");", "    // TODO Write me\n    \"Yes\".to_string()", "    // TODO: Add your\
    \ implementation here\n    unimplemented!()", "    let v: Vec<&str> = file_name.split('.').collect();\n\
    \    if v.len() != 2 {\n        return String::from(\"No\");\n    }\n    let mut\
    \ counter = 0;\n    for char in v[0].chars() {\n        if char.is_digit(10) {\n\
    \            counter += 1;\n        }\n    }\n    if counter > 3 {\n        return\
    \ String::from(\"No\");\n    }\n    let v: Vec<char> = v[0].chars().collect();\n\
    \    if !v[0].is_alphabetic() {\n        return String::from(\"No\");\n    }\n\
    \    if !(v[1] == \"txt\" || v[1] == \"exe\" || v[1] == \"dll\") {\n        return\
    \ String::from(\"No\");\n    }\n    return String::from(\"Yes\");", "\tlet mut\
    \ str_len = file_name.len();\n\tlet mut digits_count = 0;\n\tlet mut dot_count\
    \ = 0;\n\tlet mut letter_count = 0;\n\tlet mut valid_extension = 0;\n\tlet valid_extensions\
    \ = [\".txt\", \".exe\", \".dll\"];\n\tlet mut dot_index = 0;\n\tlet mut extension_index\
    \ = 0;\n\tlet mut result = String::from(\"No\");\n\t\n\tfor (index, ch) in file_name.chars().enumerate()\
    \ {\n\t\tif ch.is_digit(10) {\n\t\t\tdigits_count += 1;\n\t\t} else if ch == '.'\
    \ {\n\t\t\tdot_count += 1;\n\t\t\tdot_index = index;\n\t\t} else if ch.is_alphabetic()\
    \ {\n\t\t\tletter_count += 1;\n\t\t}\n\t}\n\t\n\tfor (index, ext) in valid_extensions.iter().enumerate()\
    \ {\n\t\tif ext == &file_name[dot_index..] {\n\t\t\tvalid_extension = 1;\n\t\t\
    \textension_index = index;\n\t\t}\n\t}\n\t\n\tif digits_count <= 3 && dot_count\
    \ == 1 && letter_count >= 1 && valid_extension == 1 {\n\t\tresult = String::from(\"\
    Yes\");\n\t}\n\t\n\tprintln!(\"file_name_check({:?}) --> {:?}\", file_name, result);\n\
    \t\n\tresult", "    // TODO: Implement the function\n    let mut num = 0;\n  \
    \  let mut contains_dot = false;\n    let mut not_empty = false;\n    let mut\
    \ correct_extension = false;\n    let mut index = 0;\n    for _ in file_name.chars()\
    \ {\n        if let Some(a) = file_name.chars().nth(index) {\n            if a.is_digit(10)\
    \ {\n                num += 1;\n            }\n            if a == '.' {\n   \
    \             contains_dot = true;\n            }\n            if index == 0 {\n\
    \                if a.is_alphabetic() {\n                    not_empty = true;\n\
    \                }\n            }\n            if index == file_name.len() - 1\
    \ {\n                if let Some(b) = file_name.chars().nth(index - 1) {\n   \
    \                 if b == 't' {\n                        if let Some(c) = file_name.chars().nth(index\
    \ - 2) {\n                            if c == 'x' {\n                        \
    \        if let Some(d) = file_name.chars().nth(index - 3) {\n               \
    \                     if d == 't' {\n                                        correct_extension\
    \ = true;\n                                    }\n                           \
    \     }\n                            }\n                        }\n          \
    \          }\n                    if b == 'l' {\n                        if let\
    \ Some(c) = file_name.chars().nth(index - 2) {\n                            if\
    \ c == 'l' {\n                                if let Some(d) = file_name.chars().nth(index\
    \ - 3) {\n                                    if d == 'e' {\n                \
    \                        correct_extension = true;\n                         \
    \           }\n                                }\n                           \
    \ }\n                        }\n                    }\n                    if\
    \ b == 'e' {\n                        if let Some(c) = file_name.chars().nth(index\
    \ - 2) {\n                            if c == 'x' {\n                        \
    \        if let Some(d) = file_name.chars().nth(index - 3) {\n               \
    \                     if d == 'e' {\n                                        correct_extension\
    \ = true;\n                                    }\n                           \
    \     }\n                           ", "    let dot_pos = file_name.rfind('.');\n\
    \    if dot_pos == None {\n        return String::from(\"No\");\n    }\n\n   \
    \ let dot_pos = dot_pos.unwrap();\n    let file_extension = &file_name[dot_pos\
    \ + 1..];\n    let valid_extensions = vec![\"txt\", \"exe\", \"dll\"];\n    if\
    \ !valid_extensions.contains(&file_extension) {\n        return String::from(\"\
    No\");\n    }\n\n    let mut digit_count = 0;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if i < dot_pos && c.is_ascii_digit() {\n            digit_count +=\
    \ 1;\n        }\n    }\n    if digit_count > 3 {\n        return String::from(\"\
    No\");\n    }\n\n    let file_name = &file_name[..dot_pos];\n    if file_name.is_empty()\
    \ {\n        return String::from(\"No\");\n    }\n\n    let (first_char, _) =\
    \ file_name.chars().next().unwrap();\n    if !first_char.is_ascii_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n\n    return String::from(\"\
    Yes\");", "    // write your code here\n    let mut digits_count = 0;\n    let\
    \ mut dot_count = 0;\n    let mut letter_count = 0;\n    let mut extension_check\
    \ = false;\n    let file_name: Vec<&str> = file_name.split(\".\").collect();\n\
    \    let extension: &str = file_name[1];\n    for c in file_name[0].chars() {\n\
    \        if c.is_numeric() {\n            digits_count += 1;\n        }\n    \
    \    if c.is_alphabetic() {\n            letter_count += 1;\n        }\n    }\n\
    \    for c in extension.chars() {\n        if c == '.' {\n            dot_count\
    \ += 1;\n        }\n    }\n    match extension {\n        \"txt\" => extension_check\
    \ = true,\n        \"exe\" => extension_check = true,\n        \"dll\" => extension_check\
    \ = true,\n        _ => extension_check = false,\n    }\n    if digits_count >\
    \ 3 || letter_count == 0 || dot_count != 1 || !extension_check {\n        return\
    \ String::from(\"No\");\n    }\n    return String::from(\"Yes\");", "    // write\
    \ your code here.\n    return String::from(\"Yes\");", "    // TODO: Task 1.A\
    \ -> create a function which returns 'Yes' if the file name is valid\n    unimplemented!();",
  "    let count = file_name.chars().filter(|&c| c >= '0' && c <= '9').count();\n\
    \    if count > 3 {\n        return String::from(\"No\");\n    }\n    let mut\
    \ split = file_name.split('.');\n    let before_dot = split.next().unwrap();\n\
    \    let after_dot = split.next().unwrap();\n    let target_after_dot = ['txt',\
    \ 'exe', 'dll'];\n    if before_dot.is_empty() || !(before_dot.chars().next().unwrap()\
    \ >= 'a' && before_dot.chars().next().unwrap() <= 'z'\n        || before_dot.chars().next().unwrap()\
    \ >= 'A' && before_dot.chars().next().unwrap() <= 'Z') {\n        return String::from(\"\
    No\");\n    }\n    if !target_after_dot.contains(&after_dot.as_ref()) {\n    \
    \    return String::from(\"No\");\n    }\n    String::from(\"Yes\")", "    let\
    \ max_num_digit = 3;\n    let dot_pos = file_name.find('.').unwrap();\n    let\
    \ ext = file_name.split_at(dot_pos).1;\n    let ext_vec = vec![\"txt\", \"exe\"\
    , \"dll\"];\n    if dot_pos == 0 {\n        return String::from(\"No\");\n   \
    \ }\n    let is_num = |c: char| c >= '0' && c <= '9';\n    let mut num_digit =\
    \ 0;\n    for c in file_name.chars() {\n        if is_num(c) {\n            num_digit\
    \ += 1;\n        }\n    }\n    if num_digit > max_num_digit {\n        return\
    \ String::from(\"No\");\n    }\n    let is_in_ext_vec = |s: &str| ext_vec.contains(&s);\n\
    \    let is_in_a_z = |c: char| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n\
    \    if !is_in_a_z(file_name.chars().next().unwrap()) {\n        return String::from(\"\
    No\");\n    }\n    if is_in_ext_vec(ext) {\n        return String::from(\"Yes\"\
    );\n    }\n    String::from(\"No\")", "    // TODO: Complete here\n    return\
    \ String::from(\"No\");", "    let mut digits_count = 0;\n    let mut dot_count\
    \ = 0;\n    let mut extension = false;\n    let valid_extensions = [\"txt\", \"\
    exe\", \"dll\"];\n    let mut extension_index = 0;\n    let mut is_valid = true;\n\
    \    for (index, c) in file_name.chars().enumerate() {\n        if c.is_digit(10)\
    \ {\n            digits_count += 1;\n        } else if c == '.' {\n          \
    \  dot_count += 1;\n            extension_index = index;\n        } else if !c.is_alphabetic()\
    \ {\n            is_valid = false;\n            break;\n        }\n    }\n   \
    \ if digits_count > 3 || dot_count != 1 || extension_index < 1 {\n        is_valid\
    \ = false;\n    }\n    let file_extension = &file_name[extension_index + 1..];\n\
    \    for ext in valid_extensions.iter() {\n        if ext == file_extension {\n\
    \            extension = true;\n            break;\n        }\n    }\n    if !extension\
    \ {\n        is_valid = false;\n    }\n    if is_valid {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }", "    let mut digits\
    \ = 0;\n    let mut has_dot = false;\n    let mut has_pre_dot = false;\n    let\
    \ mut suffix = String::new();\n    for c in file_name.chars() {\n        if c.is_digit(10)\
    \ {\n            digits += 1;\n        } else if c == '.' {\n            has_dot\
    \ = true;\n        } else if has_dot && !has_pre_dot {\n            suffix.push(c);\n\
    \        } else if has_dot && has_pre_dot {\n            suffix.push(c);\n   \
    \     } else if !has_dot && (c.is_alphabetic() || c == '_') {\n            has_pre_dot\
    \ = true;\n        } else {\n            return String::from(\"No\");\n      \
    \  }\n    }\n    if digits > 3 || !has_dot || !has_pre_dot || !suffix.eq(\"exe\"\
    ) && !suffix.eq(\"txt\") && !suffix.eq(\"dll\") {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");", "    let (before_dot, after_dot)\
    \ = split_by_dot(file_name);\n    let max_digits = 3;\n    let digits_count =\
    \ before_dot.chars().filter(|x| x.is_digit(10)).count();\n    let mut is_valid\
    \ = true;\n    if digits_count > max_digits {\n        is_valid = false;\n   \
    \ }\n    if after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\"\
    \ {\n        is_valid = false;\n    }\n    if before_dot.chars().nth(0).unwrap().is_digit(10)\
    \ {\n        is_valid = false;\n    }\n    if is_valid {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }", "    let count_digits\
    \ = file_name.chars().filter(|c| c.is_digit(10)).count();\n    if count_digits\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    let index_of_dot = file_name.find('.').unwrap();\n\
    \    let sub_filename = &file_name[..index_of_dot];\n    if sub_filename.len()\
    \ == 0 || !sub_filename.chars().next().unwrap().is_alphabetic() {\n        return\
    \ String::from(\"No\");\n    }\n    let extension = &file_name[index_of_dot +\
    \ 1..];\n    if extension != \"txt\" && extension != \"exe\" && extension != \"\
    dll\" {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\"\
    )", "    let mut counter: u8 = 0;\n    let mut is_valid = true;\n    let mut dot_counter\
    \ = 0;\n    let mut dot_position = 0;\n    let mut before_dot = String::new();\n\
    \    let mut after_dot = String::new();\n    let mut test_after_dot = false;\n\
    \    let mut valid_after_dot = false;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c.is_ascii_digit() {\n            counter += 1;\n        }\n \
    \       if c == '.' {\n            dot_counter += 1;\n            dot_position\
    \ = i;\n        }\n    }\n    if counter > 3 || dot_counter != 1 {\n        is_valid\
    \ = false;\n    }\n    for c in file_name.chars() {\n        if c == '.' {\n \
    \           test_after_dot = true;\n        }\n        if test_after_dot {\n \
    \           after_dot.push(c);\n        } else {\n            before_dot.push(c);\n\
    \        }\n    }\n    before_dot.pop();\n    after_dot.remove(0);\n    if after_dot\
    \ == \"txt\" || after_dot == \"exe\" || after_dot == \"dll\" {\n        valid_after_dot\
    \ = true;\n    }\n    if !is_valid || dot_position == 0 || !valid_after_dot {\n\
    \        return String::from(\"No\");\n    }\n    if let Some(c) = before_dot.chars().next()\
    \ {\n        if !c.is_ascii_alphabetic() {\n            return String::from(\"\
    No\");\n        }\n    }\n    return String::from(\"Yes\");", "    let mut count\
    \ = 0;\n    for c in file_name.chars() {\n        if c.is_digit(10) {\n      \
    \      count += 1;\n        }\n    }\n    if count > 3 {\n        return String::from(\"\
    No\");\n    }\n    let v: Vec<&str> = file_name.split('.').collect();\n    if\
    \ v.len() != 2 {\n        return String::from(\"No\");\n    }\n    let (sub1,\
    \ sub2) = (v[0], v[1]);\n    if sub1.is_empty() || !sub1.chars().next().unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n    if sub2 != \"txt\" && sub2\
    \ != \"exe\" && sub2 != \"dll\" {\n        return String::from(\"No\");\n    }\n\
    \    String::from(\"Yes\")", "    let mut count_digits = 0;\n    let mut count_dots\
    \ = 0;\n    let mut file_name_valid = false;\n    let mut word_valid = false;\n\
    \    let mut ext_valid = false;\n    let ext = vec![\"txt\", \"exe\", \"dll\"\
    ];\n    for (index, character) in file_name.chars().enumerate() {\n        if\
    \ character.is_ascii_digit() {\n            count_digits += 1;\n        } else\
    \ if character == '.' {\n            count_dots += 1;\n            if index ==\
    \ 0 {\n                return String::from(\"No\");\n            }\n         \
    \   let sub_string = &file_name[0..index];\n            if let Some(character)\
    \ = sub_string.chars().next() {\n                if character.is_ascii_alphabetic()\
    \ {\n                    word_valid = true;\n                }\n            }\n\
    \            let sub_string = &file_name[index + 1..];\n            if ext.contains(&sub_string.as_str())\
    \ {\n                ext_valid = true;\n            }\n        }\n    }\n    if\
    \ count_digits <= 3 && count_dots == 1 && word_valid && ext_valid {\n        file_name_valid\
    \ = true;\n    }\n    if file_name_valid {\n        String::from(\"Yes\")\n  \
    \  } else {\n        String::from(\"No\")\n    }", "    const MAX_ALLOWED_NUMBERS:\
    \ usize = 3;\n    // TODO: Implement the function here.\n    let mut file_name_chars:\
    \ Vec<char> = file_name.chars().collect();\n    // Finding the dot\n    let mut\
    \ dot_pos: Option<usize> = None;\n    for i in 0..file_name_chars.len() {\n  \
    \      if file_name_chars[i] == '.' {\n            dot_pos = Some(i);\n      \
    \      break;\n        }\n    }\n    // Checking the substring before the dot.\n\
    \    if let Some(dot_pos) = dot_pos {\n        let before_dot: String = file_name_chars[..dot_pos].iter().collect();\n\
    \        if before_dot.is_empty() || !is_valid_identifier(&before_dot) {\n   \
    \         return String::from(\"No\");\n        }\n    } else {\n        return\
    \ String::from(\"No\");\n    }\n    // Checking the substring after the dot.\n\
    \    let after_dot: String = file_name_chars[dot_pos+1..].iter().collect();\n\
    \    if ![\"txt\", \"exe\", \"dll\"].contains(&after_dot.as_str()) {\n       \
    \ return String::from(\"No\");\n    }\n    // Counting the number of digits in\
    \ the file's name.\n    let mut num_of_digits: usize = 0;\n    for ch in file_name_chars.iter()\
    \ {\n        if ch.is_ascii_digit() {\n            num_of_digits += 1;\n     \
    \   }\n    }\n    if num_of_digits > MAX_ALLOWED_NUMBERS {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");", "    let file_name = file_name.chars().collect::<Vec<char>>();\n\
    \    let file_name_len = file_name.len();\n    let dot_pos = find_dot_pos(&file_name);\n\
    \    let extension = get_extension(&file_name);\n    let pre_dot = file_name[..dot_pos].to_vec();\n\
    \    let num_digits = get_num_digits(&pre_dot);\n    if dot_pos != file_name_len\
    \ - 4 || num_digits > 3 || !is_latin(&pre_dot) || !is_allowed_extension(&extension)\
    \ {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")",
  "    let mut num_digits = 0;\n    let mut has_dot = false;\n    let mut has_digit_after_dot\
    \ = false;\n    let mut has_char_before_dot = false;\n    let mut has_valid_file_extension\
    \ = false;\n    let mut file_extension = String::new();\n    for c in file_name.chars()\
    \ {\n        if c == '.' {\n            has_dot = true;\n        } else if c.is_ascii_digit()\
    \ {\n            num_digits += 1;\n            if has_dot {\n                has_digit_after_dot\
    \ = true;\n            }\n        } else if c.is_ascii_alphabetic() {\n      \
    \      if has_dot {\n                file_extension.push(c);\n            } else\
    \ {\n                has_char_before_dot = true;\n            }\n        }\n \
    \   }\n    has_valid_file_extension = file_extension == \"txt\" || file_extension\
    \ == \"exe\" || file_extension == \"dll\";\n    if num_digits <= 3 && has_dot\
    \ && has_char_before_dot && !has_digit_after_dot && has_valid_file_extension {\n\
    \        return String::from(\"Yes\");\n    }\n    return String::from(\"No\"\
    );", "    let file_name_length = file_name.len();\n    if file_name_length ==\
    \ 0 {\n        return String::from(\"No\");\n    }\n    let file_name_chars: Vec<char>\
    \ = file_name.chars().collect();\n    let mut digit_counter = 0;\n    let mut\
    \ dot_found = false;\n    let mut dot_index = 0;\n    for (index, c) in file_name_chars.iter().enumerate()\
    \ {\n        if (*c).is_digit(10) {\n            digit_counter += 1;\n       \
    \ }\n        if *c == '.' {\n            dot_found = true;\n            dot_index\
    \ = index;\n        }\n    }\n    if digit_counter > 3 || !dot_found {\n     \
    \   return String::from(\"No\");\n    }\n    let tail = &file_name[dot_index +\
    \ 1..];\n    if tail != \"txt\" && tail != \"exe\" && tail != \"dll\" {\n    \
    \    return String::from(\"No\");\n    }\n    let head = &file_name[..dot_index];\n\
    \    if head.len() == 0 {\n        return String::from(\"No\");\n    }\n    if\
    \ head.chars().next().unwrap().is_ascii_alphabetic() {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");", "    let file_name_chars: Vec<char>\
    \ = file_name.chars().collect();\n    let mut dot_flag = false;\n    let mut extension_str\
    \ = String::new();\n    let mut number_count = 0;\n    for ch in file_name_chars\
    \ {\n        if ch.is_digit(10) {\n            number_count += 1;\n        }\n\
    \        if ch == '.' {\n            dot_flag = true;\n        }\n        if dot_flag\
    \ {\n            extension_str.push(ch);\n        }\n    }\n    if dot_flag &&\
    \ number_count <= 3 {\n        match extension_str.as_str() {\n            \"\
    .txt\" | \".exe\" | \".dll\" => {\n                return String::from(\"Yes\"\
    );\n            }\n            _ => {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    String::from(\"No\")", "    let digit_regex\
    \ = Regex::new(r\"[0-9]\").unwrap();\n    let latin_regex = Regex::new(r\"[a-zA-Z]\"\
    ).unwrap();\n    let dot_count = file_name.split(\".\").count() - 1;\n    let\
    \ digit_count = digit_regex.find_iter(&file_name).count();\n    let latin_count\
    \ = latin_regex.find_iter(&file_name).count();\n    let dot_index = file_name.find(\"\
    .\").unwrap();\n    let file_type = file_name.split(\".\").last().unwrap();\n\
    \    if digit_count > 3 || dot_count != 1 || latin_count == 0 {\n        String::from(\"\
    No\")\n    } else if file_type != \"txt\" && file_type != \"exe\" && file_type\
    \ != \"dll\" {\n        String::from(\"No\")\n    } else if file_name.split_at(dot_index).0.len()\
    \ == 0 {\n        String::from(\"No\")\n    } else {\n        String::from(\"\
    Yes\")\n    }", "    let file_name_bytes = file_name.as_bytes();\n    if !file_name_bytes.iter().all(|b|\
    \ is_acceptable(*b)) {\n        return String::from(\"No\");\n    }\n    let mut\
    \ number_of_digits = 0;\n    let mut number_of_dots = 0;\n    let mut substring_after_the_dot_has_been_seen\
    \ = false;\n    let mut substring_after_the_dot_contains_bad_characters = false;\n\
    \    let dot_index = file_name_bytes.iter().position(|b| *b == b'.');\n    if\
    \ dot_index.is_none() {\n        return String::from(\"No\");\n    }\n    let\
    \ dot_index = dot_index.unwrap();\n    for i in 0..file_name_bytes.len() {\n \
    \       let b = file_name_bytes[i];\n        if b >= b'0' && b <= b'9' {\n   \
    \         number_of_digits += 1;\n        }\n        if b == b'.' {\n        \
    \    number_of_dots += 1;\n            substring_after_the_dot_has_been_seen =\
    \ true;\n        }\n        if substring_after_the_dot_has_been_seen && !(b >=\
    \ b'a' && b <= b'z') && !(b >= b'A' && b <= b'Z') {\n            substring_after_the_dot_contains_bad_characters\
    \ = true;\n        }\n    }\n    if number_of_digits > 3 || number_of_dots !=\
    \ 1 || dot_index == 0 || substring_after_the_dot_contains_bad_characters {\n \
    \       return String::from(\"No\");\n    }\n    let acceptable_substrings_after_the_dot\
    \ = [b\"txt\", b\"exe\", b\"dll\"];\n    for asad in acceptable_substrings_after_the_dot.iter()\
    \ {\n        if &file_name_bytes[dot_index + 1..] == asad {\n            return\
    \ String::from(\"Yes\");\n        }\n    }\n    String::from", "    let mut digits\
    \ = 0;\n    let mut dot_count = 0;\n    let mut before_dot = false;\n    let mut\
    \ after_dot = false;\n    let mut invalid_after_dot = false;\n    let after_dot_values\
    \ = [\"txt\", \"exe\", \"dll\"];\n    for c in file_name.chars() {\n        if\
    \ c.is_numeric() {\n            digits += 1;\n        }\n        if c == '.' {\n\
    \            dot_count += 1;\n            after_dot = true;\n        } else if\
    \ after_dot {\n            invalid_after_dot = !after_dot_values.contains(&c.to_string().as_str());\n\
    \        } else {\n            before_dot = !c.is_numeric();\n        }\n    }\n\
    \    if digits <= 3 && dot_count == 1 && before_dot && !invalid_after_dot {\n\
    \        return String::from(\"Yes\");\n    }\n    String::from(\"No\")", "  \
    \  let file_name = file_name.chars().filter(|c| !c.is_whitespace()).collect::<String>();\n\
    \    let mut chars = file_name.chars();\n    let mut dot_count = 0;\n    let mut\
    \ digit_count = 0;\n    let mut ext_count = 0;\n    let mut letter_count = 0;\n\
    \    let mut i = 0;\n    while let Some(c) = chars.next() {\n        if (c >=\
    \ 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') {\n            letter_count += 1;\n\
    \        }\n        if (c >= '0' && c <= '9') {\n            digit_count += 1;\n\
    \        }\n        if c == '.' {\n            dot_count += 1;\n            let\
    \ ext = chars.collect::<String>();\n            if ext == \"txt\" || ext == \"\
    exe\" || ext == \"dll\" {\n                ext_count += 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    if digit_count > 3 || dot_count != 1 ||\
    \ letter_count == 0 || ext_count != 1 {\n        String::from(\"No\")\n    } else\
    \ {\n        String::from(\"Yes\")\n    }", "    // Write your code here\n   \
    \ unimplemented!();", "    // To be completed.\n    \"No\".to_string()", "   \
    \ if file_name.starts_with(char::is_numeric) {\n        return String::from(\"\
    No\");\n    }\n    if let Some(index) = file_name.find('.') {\n        if index\
    \ == 0 {\n            return String::from(\"No\");\n        }\n        if let\
    \ Some(ext) = file_name.get(index + 1..) {\n            if !ext.starts_with(char::is_alphabetic)\
    \ {\n                return String::from(\"No\");\n            }\n           \
    \ if !matches!(ext, \"txt\" | \"exe\" | \"dll\") {\n                return String::from(\"\
    No\");\n            }\n        } else {\n            return String::from(\"No\"\
    );\n        }\n    } else {\n        return String::from(\"No\");\n    }\n   \
    \ String::from(\"Yes\")", "    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n\n    let mut index = 0;\n\
    \    for (i, c) in file_name.chars().enumerate() {\n        if c == '.' {\n  \
    \          index = i;\n            break;\n        }\n    }\n\n    if index ==\
    \ 0 {\n        return String::from(\"No\");\n    }\n\n    let mut extensions =\
    \ vec![\"txt\", \"exe\", \"dll\"];\n    extensions.retain(|&item| file_name.contains(item));\n\
    \n    if extensions.len() == 0 {\n        return String::from(\"No\");\n    }\n\
    \n    let start = &file_name[..index];\n    if !start.chars().nth(0).unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n\n    return String::from(\"\
    Yes\");", '    "Yes".to_string()', "    let digits_regex = Regex::new(r\"[0-9]\"\
    ).unwrap();\n    let alphapet_regex = Regex::new(r\"[a-zA-Z]\").unwrap();\n  \
    \  let file_extention_regex = Regex::new(r\"(txt|exe|dll)\").unwrap();\n    let\
    \ mut chars_count = 0;\n    let mut digits_count = 0;\n    let mut alphapet_count\
    \ = 0;\n    let mut dot_count = 0;\n    let mut dot_index = 0;\n    let mut file_extention_valid\
    \ = false;\n    for (index, ch) in file_name.chars().enumerate() {\n        chars_count\
    \ += 1;\n        if ch == '.' {\n            dot_count += 1;\n            dot_index\
    \ = index;\n        }\n        if digits_regex.is_match(&ch.to_string()) {\n \
    \           digits_count += 1;\n        }\n        if alphapet_regex.is_match(&ch.to_string())\
    \ {\n            alphapet_count += 1;\n        }\n    }\n    if digits_count >\
    \ 3 {\n        return String::from(\"No\");\n    }\n    if dot_count == 1 && dot_index\
    \ > 0 && alphapet_count > 0 {\n        let file_extention = &file_name[dot_index\
    \ + 1..chars_count];\n        if file_extention_regex.is_match(file_extention)\
    \ {\n            file_extention_valid = true;\n        }\n    }\n    if chars_count\
    \ > 3 && dot_count == 1 && alphapet_count > 0 && file_extention_valid {\n    \
    \    return String::from(\"Yes\");\n    }\n    return String::from(\"No\");",
  "    let mut count = 0;\n    let mut has_dot = false;\n    let mut has_letter =\
    \ false;\n    let mut dot_index = 0;\n    let mut letter_index = 0;\n    let mut\
    \ end_with_text = false;\n    let mut text_length = 0;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c == '.' {\n            if has_dot {\n                return String::from(\"\
    No\");\n            }\n            has_dot = true;\n            dot_index = i;\n\
    \        }\n        if c.is_digit(10) {\n            count += 1;\n        }\n\
    \        if !has_letter && c.is_alphabetic() {\n            has_letter = true;\n\
    \            letter_index = i;\n        }\n        if i > dot_index {\n      \
    \      text_length += 1;\n            if text_length == 3 {\n                if\
    \ file_name[dot_index+1..dot_index+4] == \"txt\" ||\n                    file_name[dot_index+1..dot_index+4]\
    \ == \"exe\" ||\n                    file_name[dot_index+1..dot_index+4] == \"\
    dll\" {\n                    end_with_text = true;\n                }\n      \
    \      }\n        }\n    }\n    if !end_with_text || count > 3 || !has_dot ||\
    \ !has_letter || dot_index <= letter_index {\n        return String::from(\"No\"\
    );\n    }\n    String::from(\"Yes\")", "    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    let parts: Vec<&str>\
    \ = file_name.split('.').collect();\n    if parts.len() != 2 {\n        return\
    \ String::from(\"No\");\n    }\n    if parts[0].is_empty() || !parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n    if !(parts[1] == \"txt\"\
    \ || parts[1] == \"exe\" || parts[1] == \"dll\") {\n        return String::from(\"\
    No\");\n    }\n    String::from(\"Yes\")", "    let mut count = 0;\n    let mut\
    \ is_dot = false;\n    let mut chars = file_name.chars();\n    let mut is_valid\
    \ = false;\n    let mut is_empty = true;\n    let mut has_no_digit = true;\n \
    \   let mut has_letter = false;\n    let mut has_digit = false;\n    while let\
    \ Some(c) = chars.next() {\n        match c {\n            '.' => {\n        \
    \        if !is_dot {\n                    is_dot = true;\n                } else\
    \ {\n                    is_valid = false;\n                    break;\n     \
    \           }\n            }\n            'a'...'z' | 'A'...'Z' => {\n       \
    \         if is_empty {\n                    is_empty = false;\n             \
    \   }\n                if !has_letter {\n                    has_letter = true;\n\
    \                }\n            }\n            '0'...'9' => {\n              \
    \  if !has_digit {\n                    has_digit = true;\n                }\n\
    \                if !has_no_digit {\n                    count += 1;\n       \
    \         }\n                if count > 3 {\n                    is_valid = false;\n\
    \                    break;\n                }\n            }\n            _ =>\
    \ {\n                is_valid = false;\n                break;\n            }\n\
    \        }\n    }\n    if is_empty || !has_letter || !has_digit || count > 3 {\n\
    \        return String::from(\"No\");\n    }\n    if is_valid {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }", "\tlet mut digit_num\
    \ = 0;\n\tlet mut last_char = ' ';\n\tlet mut pre_dot = true;\n\tlet mut is_first_letter\
    \ = true;\n\tlet mut first_letter = ' ';\n\tlet mut has_dot = false;\n\tlet mut\
    \ post_dot = false;\n\tfor c in file_name.chars() {\n\t\tmatch c {\n\t\t\t'0'..='9'\
    \ => {\n\t\t\t\tif digit_num == 3 {\n\t\t\t\t\treturn String::from(\"No\");\n\t\
    \t\t\t}\n\t\t\t\tdigit_num += 1;\n\t\t\t\tlast_char = c;\n\t\t\t}\n\t\t\t'a'..='z'\
    \ | 'A'..='Z' => {\n\t\t\t\tif pre_dot && is_first_letter {\n\t\t\t\t\tfirst_letter\
    \ = c;\n\t\t\t\t\tis_first_letter = false;\n\t\t\t\t}\n\t\t\t\tif post_dot {\n\
    \t\t\t\t\treturn String::from(\"No\");\n\t\t\t\t}\n\t\t\t\tlast_char = c;\n\t\t\
    \t}\n\t\t\t'.' => {\n\t\t\t\tif last_char == '.' || pre_dot == false {\n\t\t\t\
    \t\treturn String::from(\"No\");\n\t\t\t\t}\n\t\t\t\tif pre_dot && is_first_letter\
    \ {\n\t\t\t\t\treturn String::from(\"No\");\n\t\t\t\t}\n\t\t\t\tpre_dot = false;\n\
    \t\t\t\thas_dot = true;\n\t\t\t\tpost_dot = true;\n\t\t\t\tlast_char = c;\n\t\t\
    \t}\n\t\t\t_ => {\n\t\t\t\tif pre_dot && first_letter == '.' {\n\t\t\t\t\treturn\
    \ String::from(\"No\");\n\t\t\t\t}\n\t\t\t\tif !pre_dot && has_dot && (c == 't'\
    \ || c == 'e' || c == 'd') {\n\t\t\t\t\tif c == 't' && last_char == 't' {\n\t\t\
    \t\t\t", "    let mut digits_counter = 0;\n    let mut dot_counter = 0;\n    let\
    \ mut is_empty = true;\n    let mut is_letter = false;\n    let mut correct_ending\
    \ = false;\n    let mut is_valid = true;\n    for c in file_name.chars() {\n \
    \       if c == '.' {\n            dot_counter += 1;\n            if is_empty\
    \ {\n                is_valid = false;\n            }\n            is_letter =\
    \ false;\n        } else if c == '0' || c == '1' || c == '2' || c == '3' || c\
    \ == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' {\n     \
    \       digits_counter += 1;\n        } else if (c >= 'a' && c <= 'z') || (c >=\
    \ 'A' && c <= 'Z') {\n            is_empty = false;\n            is_letter = true;\n\
    \        } else {\n            is_valid = false;\n        }\n    }\n    if is_letter\
    \ {\n        let ending = file_name.split('.').last().unwrap();\n        if ending\
    \ == \"txt\" || ending == \"exe\" || ending == \"dll\" {\n            correct_ending\
    \ = true;\n        }\n    }\n    if dot_counter != 1 || digits_counter > 3 ||\
    \ !is_valid || !correct_ending {\n        String::from(\"No\")\n    } else {\n\
    \        String::from(\"Yes\")\n    }", "    if file_name.contains('.') {\n  \
    \      let file_name_split: Vec<&str> = file_name.split('.').collect();\n    \
    \    if file_name_split.len() == 2 {\n            let file_name_split: Vec<&str>\
    \ = file_name_split[0].split('.').collect();\n            if file_name_split.len()\
    \ == 1 {\n                if file_name_split[0].len() >= 1 {\n               \
    \     if file_name_split[0].len() == 1 {\n                        if file_name_split[0].chars().nth(0).unwrap().is_ascii_alphabetic()\
    \ {\n                            if file_name_split[0].chars().nth(0).unwrap().is_ascii_uppercase()\
    \ ||\n                                file_name_split[0].chars().nth(0).unwrap().is_ascii_lowercase()\
    \ {\n                                if file_name_split[0].chars().all(|c| \n\
    \                                    !c.is_digit(10)) {\n                    \
    \                let file_name_split: Vec<&str> = file_name.split('.').collect();\n\
    \                                    if file_name_split[1] == \"txt\" ||\n   \
    \                                     file_name_split[1] == \"exe\" ||\n     \
    \                                   file_name_split[1] == \"dll\" {\n        \
    \                                return String::from(\"Yes\");\n             \
    \                       }\n                                }\n               \
    \             }\n                        }\n                    } else {\n   \
    \                     if file_name_split[0].chars().nth(0).unwrap().is_ascii_alphabetic()\
    \ {\n                            if file_name_split[0].chars().nth(0).unwrap().is_ascii_uppercase()\
    \ ||\n                                file_name_split[0].chars().nth(0).unwrap().is_ascii_lowercase()\
    \ {\n                                if file_name_split[0].chars().all(|c| \n\
    \                                    !c.is_digit(10)) {\n                    \
    \                let file_name_split: Vec<&str> =", '    return String::from("No");',
  "    let file_name_split: Vec<&str> = file_name.split(\".\").collect();\n    if\
    \ file_name_split.len() != 2 {\n        return String::from(\"No\");\n    }\n\
    \    if !(file_name_split[0].is_ascii_alphabetic() && \n        file_name_split[0].chars().all(|c|\
    \ c.is_ascii_alphabetic() || c.is_ascii_digit())) {\n        return String::from(\"\
    No\");\n    }\n    if !file_name_split[1].is_ascii_alphabetic() {\n        return\
    \ String::from(\"No\");\n    }\n    if file_name_split[1].chars().filter(|c| c.is_ascii_digit()).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    let file_name_extension\
    \ = String::from(file_name_split[1]);\n    if !(file_name_extension == \"txt\"\
    \ || file_name_extension == \"exe\" || file_name_extension == \"dll\") {\n   \
    \     return String::from(\"No\");\n    }\n    return String::from(\"Yes\");",
  "    let file_name_regex = Regex::new(r\"^([a-zA-Z]+)([0-9]{0,3})(\\.[a-zA-Z]+$)\"\
    ).unwrap();\n    if file_name_regex.is_match(&file_name) {\n        let captures\
    \ = file_name_regex.captures(&file_name).unwrap();\n        if captures.get(3).unwrap().as_str()\
    \ == \".txt\" ||\n            captures.get(3).unwrap().as_str() == \".exe\" ||\n\
    \            captures.get(3).unwrap().as_str() == \".dll\" {\n            String::from(\"\
    Yes\")\n        } else {\n            String::from(\"No\")\n        }\n    } else\
    \ {\n        String::from(\"No\")\n    }", "    let mut letters_count = 0;\n \
    \   let mut digits_count = 0;\n    let mut dot_count = 0;\n    let mut dll_count\
    \ = 0;\n    let mut txt_count = 0;\n    let mut exe_count = 0;\n    let mut prev_ch\
    \ = '_';\n    for ch in file_name.chars() {\n        if ch.is_digit(10) {\n  \
    \          digits_count += 1;\n        } else if ch.is_alphabetic() {\n      \
    \      letters_count += 1;\n        } else if ch == '.' {\n            dot_count\
    \ += 1;\n        }\n        if prev_ch == '.' {\n            match ch {\n    \
    \            'd' => dll_count += 1,\n                't' => txt_count += 1,\n\
    \                'e' => exe_count += 1,\n                _ => continue,\n    \
    \        }\n        }\n        prev_ch = ch;\n    }\n    if letters_count == 0\
    \ || digits_count > 3 || dot_count != 1 || \n        (dll_count + txt_count +\
    \ exe_count) < 3 {\n        return String::from(\"No\");\n    }\n    String::from(\"\
    Yes\")", "    let mut result = \"Yes\".to_string();\n    let file_name = file_name.to_lowercase();\n\
    \    let splitted: Vec<&str> = file_name.split('.').collect();\n    let file_type\
    \ = splitted[1];\n    let mut counter = 0;\n    let mut is_digit = false;\n  \
    \  if !(file_type == \"txt\" || file_type == \"exe\" || file_type == \"dll\")\
    \ {\n        result = \"No\".to_string();\n    }\n    for elem in splitted[0].chars()\
    \ {\n        if elem.is_numeric() {\n            is_digit = true;\n          \
    \  counter += 1;\n        }\n    }\n    if is_digit && counter > 3 {\n       \
    \ result = \"No\".to_string();\n    }\n    result", "    if file_name.len() <=\
    \ 4 {\n        return String::from(\"No\");\n    }\n    let mut counter: u8 =\
    \ 0;\n    let mut index_of_first_digit: Option<usize> = None;\n    let mut index_of_last_digit:\
    \ Option<usize> = None;\n    let mut index_of_dot: Option<usize> = None;\n   \
    \ for (index, ch) in file_name.chars().enumerate() {\n        if ch.is_digit(10)\
    \ {\n            counter += 1;\n            index_of_first_digit = match index_of_first_digit\
    \ {\n                Some(v) => Some(v),\n                None => Some(index),\n\
    \            };\n            index_of_last_digit = Some(index);\n        }\n \
    \       if ch == '.' {\n            index_of_dot = Some(index);\n        }\n \
    \   }\n    if counter > 3 {\n        return String::from(\"No\");\n    }\n   \
    \ match index_of_dot {\n        Some(index) => {\n            let file_type: String\
    \ = String::from(&file_name[index + 1..]);\n            let latin_alphabet = ['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\
    \ 'X', 'Y', 'Z'];\n            if !latin_alphabet.contains(&file_name.chars().nth(0).unwrap())\
    \ {\n                return String::from(\"No\");\n            }\n           \
    \ match index_of_first_digit {\n                Some(v) => {\n               \
    \     if index - v < 1 {\n                        return", "    // Unimplemented!()\n\
    \    let mut digits = 0;\n    let mut dot = 0;\n    let mut substring_before_dot\
    \ = \"\";\n    let mut substring_after_dot = \"\";\n    let a: Vec<char> = file_name.chars().collect();\n\
    \    for i in 0..a.len() {\n        if a[i] >= '0' && a[i] <= '9' {\n        \
    \    digits += 1;\n        }\n        if a[i] == '.' {\n            dot += 1;\n\
    \        }\n    }\n    if digits > 3 || dot != 1 {\n        return String::from(\"\
    No\");\n    }\n    if a[0] < 'a' || a[0] > 'z' {\n        return String::from(\"\
    No\");\n    }\n    substring_before_dot = &file_name[0..file_name.find('.').unwrap()];\n\
    \    substring_after_dot = &file_name[file_name.find('.').unwrap() + 1..file_name.len()];\n\
    \    if substring_after_dot != \"txt\" && substring_after_dot != \"exe\" && substring_after_dot\
    \ != \"dll\" {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");", '    unimplemented!()', "    let mut digits_count = 0;\n    let mut\
    \ dot_found = false;\n    let mut dot_index = 0;\n    let mut string_before_dot\
    \ = String::new();\n    let mut string_after_dot = String::new();\n    for (i,\
    \ c) in file_name.chars().enumerate() {\n        if c.is_digit(10) {\n       \
    \     digits_count += 1;\n        } else if c == '.' {\n            dot_found\
    \ = true;\n            dot_index = i;\n        }\n    }\n    if digits_count >\
    \ 3 || !dot_found {\n        return String::from(\"No\");\n    }\n    for (i,\
    \ c) in file_name.chars().enumerate() {\n        if i < dot_index {\n        \
    \    string_before_dot.push(c);\n        } else if i > dot_index {\n         \
    \   string_after_dot.push(c);\n        }\n    }\n    if string_before_dot.len()\
    \ == 0 || !string_before_dot.chars().next().unwrap().is_alphabetic() {\n     \
    \   return String::from(\"No\");\n    }\n    match string_after_dot.as_str() {\n\
    \        \"txt\" => String::from(\"Yes\"),\n        \"exe\" => String::from(\"\
    Yes\"),\n        \"dll\" => String::from(\"Yes\"),\n        _ => String::from(\"\
    No\"),\n    }"]
stop_tokens:
- "\n}"
