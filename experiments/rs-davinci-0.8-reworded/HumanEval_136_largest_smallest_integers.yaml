name: HumanEval_136_largest_smallest_integers
language: rs
prompt: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in a vector.\n/// If there is no negative or positive integers, return them as\
  \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n\
  /// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None, None)\n///\
  \ >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
  \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
  \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
  \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
  \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
  \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
  \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
  \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
  \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6,\
  \ 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3),\
  \ Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3),\
  \ Some(1)));\n}\n"
completions: ["    let mut negative_numbers: Vec<isize> = vec![];\n    let mut positive_numbers:\
    \ Vec<isize> = vec![];\n    let mut negative_max: Option<isize> = None;\n    let\
    \ mut positive_min: Option<isize> = None;\n\n    for num in lst {\n        if\
    \ num < 0 {\n            negative_numbers.push(num);\n        }\n        if num\
    \ > 0 {\n            positive_numbers.push(num);\n        }\n    }\n\n    for\
    \ num in negative_numbers {\n        if negative_max == None {\n            negative_max\
    \ = Some(num);\n        }\n        if negative_max != None && num > negative_max.unwrap()\
    \ {\n            negative_max = Some(num);\n        }\n    }\n\n    for num in\
    \ positive_numbers {\n        if positive_min == None {\n            positive_min\
    \ = Some(num);\n        }\n        if positive_min != None && num < positive_min.unwrap()\
    \ {\n            positive_min = Some(num);\n        }\n    }\n\n    (negative_max,\
    \ positive_min)", "    if lst.len() == 0 {\n        return (None, None);\n   \
    \ }\n    let mut largest_neg = None;\n    let mut smallest_pos = None;\n    for\
    \ item in lst {\n        if item < 0 {\n            match largest_neg {\n    \
    \            None => largest_neg = Some(item),\n                Some(x) => if\
    \ item > x { largest_neg = Some(item) }\n            }\n        } else if item\
    \ > 0 {\n            match smallest_pos {\n                None => smallest_pos\
    \ = Some(item),\n                Some(x) => if item < x { smallest_pos = Some(item)\
    \ }\n            }\n        }\n    }\n    (largest_neg, smallest_pos)", '    unimplemented!();',
  "    let mut large = None;\n    let mut small = None;\n    for i in lst {\n    \
    \    if i > 0 {\n            if small == None {\n                small = Some(i);\n\
    \            } else if i < small.unwrap() {\n                small = Some(i);\n\
    \            }\n        } else if i < 0 {\n            if large == None {\n  \
    \              large = Some(i);\n            } else if i > large.unwrap() {\n\
    \                large = Some(i);\n            }\n        }\n    }\n    (large,\
    \ small)", '  unimplemented!()', "    let mut lst_neg = vec![];\n    let mut lst_pos\
    \ = vec![];\n    for &i in &lst {\n        if i >= 0 {\n            lst_pos.push(i);\n\
    \        } else {\n            lst_neg.push(i);\n        }\n    }\n    if lst_neg.len()\
    \ > 0 {\n        lst_neg.sort();\n        lst_neg.reverse();\n    }\n    if lst_pos.len()\
    \ > 0 {\n        lst_pos.sort();\n    }\n    let mut res = (None, None);\n   \
    \ if lst_neg.len() > 0 {\n        res.0 = Some(lst_neg[0]);\n    }\n    if lst_pos.len()\
    \ > 0 {\n        res.1 = Some(lst_pos[0]);\n    }\n    res", "    let mut max\
    \ = None;\n    let mut min = None;\n    for e in lst {\n        if e > 0 {\n \
    \           min = match min {\n                None => Some(e),\n            \
    \    Some(m) => Some(cmp::min(m, e)),\n            };\n        } else if e < 0\
    \ {\n            max = match max {\n                None => Some(e),\n       \
    \         Some(m) => Some(cmp::max(m, e)),\n            };\n        }\n    }\n\
    \    (max, min)", "    let mut min = None;\n    let mut max = None;\n    for x\
    \ in lst {\n        if x > 0 {\n            if min.is_none() || x < min.unwrap()\
    \ {\n                min = Some(x);\n            }\n        } else if x < 0 {\n\
    \            if max.is_none() || x > max.unwrap() {\n                max = Some(x);\n\
    \            }\n        }\n    }\n    (max, min)", "    if lst.len() == 0 {\n\
    \        return (None, None);\n    }\n    let mut smallest = None;\n    let mut\
    \ largest = None;\n    for num in lst {\n        if num > 0 {\n            match\
    \ smallest {\n                None => smallest = Some(num),\n                Some(x)\
    \ => {\n                    if num < x {\n                        smallest = Some(num);\n\
    \                    }\n                }\n            }\n        } else if num\
    \ < 0 {\n            match largest {\n                None => largest = Some(num),\n\
    \                Some(x) => {\n                    if num > x {\n            \
    \            largest = Some(num);\n                    }\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)", '    unimplemented!();',
  "    // Your code here!\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for i in lst.iter() {\n        if i > &0 {\n            match smallest {\n\
    \                None => smallest = Some(*i),\n                Some(x) => if x\
    \ > *i { smallest = Some(*i) },\n            }\n        } else if i < &0 {\n \
    \           match largest {\n                None => largest = Some(*i),\n   \
    \             Some(x) => if x < *i { largest = Some(*i) },\n            }\n  \
    \      }\n    }\n    (largest, smallest)", "    let mut largest_negative: Option<isize>\
    \ = None;\n    let mut smallest_positive: Option<isize> = None;\n    for el in\
    \ lst {\n        if el > 0 {\n            match smallest_positive {\n        \
    \        None => smallest_positive = Some(el),\n                Some(x) => {\n\
    \                    if el < x {\n                        smallest_positive =\
    \ Some(el);\n                    }\n                }\n            }\n       \
    \ } else if el < 0 {\n            match largest_negative {\n                None\
    \ => largest_negative = Some(el),\n                Some(x) => {\n            \
    \        if el > x {\n                        largest_negative = Some(el);\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  (largest_negative, smallest_positive)", '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!()', '    (None, None)', '  unimplemented!();', "    let x =\
    \ lst.iter().filter(|&x| x < &0).max();\n    let y = lst.iter().filter(|&x| x\
    \ > &0).min();\n    (x.map(|a| *a), y.map(|a| *a))", "    let mut neg: Option<isize>\
    \ = None;\n    let mut pos: Option<isize> = None;\n    for i in lst {\n      \
    \  match i.signum() {\n            -1 => {\n                match neg {\n    \
    \                Some(x) => {\n                        if i > x {\n          \
    \                  neg = Some(i);\n                        }\n               \
    \     }\n                    None => neg = Some(i),\n                }\n     \
    \       }\n            1 => {\n                match pos {\n                 \
    \   Some(x) => {\n                        if i < x {\n                       \
    \     pos = Some(i);\n                        }\n                    }\n     \
    \               None => pos = Some(i),\n                }\n            }\n   \
    \         _ => continue,\n        }\n    }\n    (neg, pos)", "    let mut a: Option<isize>\
    \ = None;\n    let mut b: Option<isize> = None;\n    for i in lst {\n        if\
    \ i < 0 {\n            if let Some(a_val) = a {\n                if i > a_val\
    \ {\n                    a = Some(i);\n                }\n            } else {\n\
    \                a = Some(i);\n            }\n        } else if i > 0 {\n    \
    \        if let Some(b_val) = b {\n                if i < b_val {\n          \
    \          b = Some(i);\n                }\n            } else {\n           \
    \     b = Some(i);\n            }\n        }\n    }\n    (a, b)"]
stop_tokens:
- "\n}"
