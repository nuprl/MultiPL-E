name: HumanEval_136_largest_smallest_integers
language: rs
prompt: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in a vector.\n/// If there is no negative or positive integers, return them as\
  \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n\
  /// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None, None)\n///\
  \ >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
  \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
  \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
  \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
  \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
  \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
  \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
  \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
  \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6,\
  \ 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3),\
  \ Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3),\
  \ Some(1)));\n}\n"
completions: ["    let mut negative_numbers: Vec<isize> = vec![];\n    let mut positive_numbers:\
    \ Vec<isize> = vec![];\n    let mut negative_max: Option<isize> = None;\n    let\
    \ mut positive_min: Option<isize> = None;\n\n    for num in lst {\n        if\
    \ num < 0 {\n            negative_numbers.push(num);\n        }\n        if num\
    \ > 0 {\n            positive_numbers.push(num);\n        }\n    }\n\n    for\
    \ num in negative_numbers {\n        if negative_max == None {\n            negative_max\
    \ = Some(num);\n        }\n        if negative_max != None && num > negative_max.unwrap()\
    \ {\n            negative_max = Some(num);\n        }\n    }\n\n    for num in\
    \ positive_numbers {\n        if positive_min == None {\n            positive_min\
    \ = Some(num);\n        }\n        if positive_min != None && num < positive_min.unwrap()\
    \ {\n            positive_min = Some(num);\n        }\n    }\n\n    (negative_max,\
    \ positive_min)", "    if lst.len() == 0 {\n        return (None, None);\n   \
    \ }\n    let mut largest_neg = None;\n    let mut smallest_pos = None;\n    for\
    \ item in lst {\n        if item < 0 {\n            match largest_neg {\n    \
    \            None => largest_neg = Some(item),\n                Some(x) => if\
    \ item > x { largest_neg = Some(item) }\n            }\n        } else if item\
    \ > 0 {\n            match smallest_pos {\n                None => smallest_pos\
    \ = Some(item),\n                Some(x) => if item < x { smallest_pos = Some(item)\
    \ }\n            }\n        }\n    }\n    (largest_neg, smallest_pos)", '    unimplemented!();',
  "    let mut large = None;\n    let mut small = None;\n    for i in lst {\n    \
    \    if i > 0 {\n            if small == None {\n                small = Some(i);\n\
    \            } else if i < small.unwrap() {\n                small = Some(i);\n\
    \            }\n        } else if i < 0 {\n            if large == None {\n  \
    \              large = Some(i);\n            } else if i > large.unwrap() {\n\
    \                large = Some(i);\n            }\n        }\n    }\n    (large,\
    \ small)", '  unimplemented!()', "    let mut lst_neg = vec![];\n    let mut lst_pos\
    \ = vec![];\n    for &i in &lst {\n        if i >= 0 {\n            lst_pos.push(i);\n\
    \        } else {\n            lst_neg.push(i);\n        }\n    }\n    if lst_neg.len()\
    \ > 0 {\n        lst_neg.sort();\n        lst_neg.reverse();\n    }\n    if lst_pos.len()\
    \ > 0 {\n        lst_pos.sort();\n    }\n    let mut res = (None, None);\n   \
    \ if lst_neg.len() > 0 {\n        res.0 = Some(lst_neg[0]);\n    }\n    if lst_pos.len()\
    \ > 0 {\n        res.1 = Some(lst_pos[0]);\n    }\n    res", "    let mut max\
    \ = None;\n    let mut min = None;\n    for e in lst {\n        if e > 0 {\n \
    \           min = match min {\n                None => Some(e),\n            \
    \    Some(m) => Some(cmp::min(m, e)),\n            };\n        } else if e < 0\
    \ {\n            max = match max {\n                None => Some(e),\n       \
    \         Some(m) => Some(cmp::max(m, e)),\n            };\n        }\n    }\n\
    \    (max, min)", "    let mut min = None;\n    let mut max = None;\n    for x\
    \ in lst {\n        if x > 0 {\n            if min.is_none() || x < min.unwrap()\
    \ {\n                min = Some(x);\n            }\n        } else if x < 0 {\n\
    \            if max.is_none() || x > max.unwrap() {\n                max = Some(x);\n\
    \            }\n        }\n    }\n    (max, min)", "    if lst.len() == 0 {\n\
    \        return (None, None);\n    }\n    let mut smallest = None;\n    let mut\
    \ largest = None;\n    for num in lst {\n        if num > 0 {\n            match\
    \ smallest {\n                None => smallest = Some(num),\n                Some(x)\
    \ => {\n                    if num < x {\n                        smallest = Some(num);\n\
    \                    }\n                }\n            }\n        } else if num\
    \ < 0 {\n            match largest {\n                None => largest = Some(num),\n\
    \                Some(x) => {\n                    if num > x {\n            \
    \            largest = Some(num);\n                    }\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)", '    unimplemented!();',
  "    // Your code here!\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for i in lst.iter() {\n        if i > &0 {\n            match smallest {\n\
    \                None => smallest = Some(*i),\n                Some(x) => if x\
    \ > *i { smallest = Some(*i) },\n            }\n        } else if i < &0 {\n \
    \           match largest {\n                None => largest = Some(*i),\n   \
    \             Some(x) => if x < *i { largest = Some(*i) },\n            }\n  \
    \      }\n    }\n    (largest, smallest)", "    let mut largest_negative: Option<isize>\
    \ = None;\n    let mut smallest_positive: Option<isize> = None;\n    for el in\
    \ lst {\n        if el > 0 {\n            match smallest_positive {\n        \
    \        None => smallest_positive = Some(el),\n                Some(x) => {\n\
    \                    if el < x {\n                        smallest_positive =\
    \ Some(el);\n                    }\n                }\n            }\n       \
    \ } else if el < 0 {\n            match largest_negative {\n                None\
    \ => largest_negative = Some(el),\n                Some(x) => {\n            \
    \        if el > x {\n                        largest_negative = Some(el);\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  (largest_negative, smallest_positive)", '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!()', '    (None, None)', '  unimplemented!();', "    let x =\
    \ lst.iter().filter(|&x| x < &0).max();\n    let y = lst.iter().filter(|&x| x\
    \ > &0).min();\n    (x.map(|a| *a), y.map(|a| *a))", "    let mut neg: Option<isize>\
    \ = None;\n    let mut pos: Option<isize> = None;\n    for i in lst {\n      \
    \  match i.signum() {\n            -1 => {\n                match neg {\n    \
    \                Some(x) => {\n                        if i > x {\n          \
    \                  neg = Some(i);\n                        }\n               \
    \     }\n                    None => neg = Some(i),\n                }\n     \
    \       }\n            1 => {\n                match pos {\n                 \
    \   Some(x) => {\n                        if i < x {\n                       \
    \     pos = Some(i);\n                        }\n                    }\n     \
    \               None => pos = Some(i),\n                }\n            }\n   \
    \         _ => continue,\n        }\n    }\n    (neg, pos)", "    let mut a: Option<isize>\
    \ = None;\n    let mut b: Option<isize> = None;\n    for i in lst {\n        if\
    \ i < 0 {\n            if let Some(a_val) = a {\n                if i > a_val\
    \ {\n                    a = Some(i);\n                }\n            } else {\n\
    \                a = Some(i);\n            }\n        } else if i > 0 {\n    \
    \        if let Some(b_val) = b {\n                if i < b_val {\n          \
    \          b = Some(i);\n                }\n            } else {\n           \
    \     b = Some(i);\n            }\n        }\n    }\n    (a, b)", "    let mut\
    \ max = None;\n    let mut min = None;\n    for i in lst {\n        if i < 0 {\n\
    \            if max.is_none() || i > max.unwrap() {\n                max = Some(i);\n\
    \            }\n        } else if i > 0 {\n            if min.is_none() || i <\
    \ min.unwrap() {\n                min = Some(i);\n            }\n        }\n \
    \   }\n    (max, min)", '    (None, None)', "    let mut v = lst.clone();\n  \
    \  v.sort();\n    if v.len() == 0 {\n        return (None, None);\n    }\n   \
    \ let mut neg = None;\n    let mut pos = None;\n    for i in v {\n        if i\
    \ < 0 {\n            neg = Some(i);\n        } else if i > 0 {\n            pos\
    \ = Some(i);\n            break;\n        }\n    }\n    (neg, pos)", '    unimplemented!();',
  '    unimplemented!()', '    unimplemented!();', "    // TODO\n    (None, None)",
  '    unimplemented!();', '    unimplemented!()', '    unimplemented!()', "    if\
    \ lst.len() == 0 {\n        return (None, None);\n    }\n    let mut max_negative:\
    \ Option<isize> = None;\n    let mut min_positive: Option<isize> = None;\n   \
    \ for n in lst {\n        if n < 0 {\n            if max_negative.is_none() ||\
    \ n > max_negative.unwrap() {\n                max_negative = Some(n);\n     \
    \       }\n        } else if n > 0 {\n            if min_positive.is_none() ||\
    \ n < min_positive.unwrap() {\n                min_positive = Some(n);\n     \
    \       }\n        }\n    }\n    (max_negative, min_positive)", '    unimplemented!();',
  "    let mut min_value: Option<isize> = None;\n    let mut max_value: Option<isize>\
    \ = None;\n    for i in lst {\n        min_value = match min_value {\n       \
    \     None => Some(i),\n            Some(m) => {\n                if i < m &&\
    \ i > 0 {\n                    Some(i)\n                } else {\n           \
    \         Some(m)\n                }\n            }\n        };\n        max_value\
    \ = match max_value {\n            None => Some(i),\n            Some(m) => {\n\
    \                if i > m && i < 0 {\n                    Some(i)\n          \
    \      } else {\n                    Some(m)\n                }\n            }\n\
    \        };\n    }\n    (max_value, min_value)", "    let mut smallest_pos: Option<isize>\
    \ = None;\n    let mut largest_neg: Option<isize> = None;\n    for x in lst {\n\
    \        if x > 0 {\n            match smallest_pos {\n                None =>\
    \ smallest_pos = Some(x),\n                Some(num) => {\n                  \
    \  if x < num {\n                        smallest_pos = Some(x);\n           \
    \         }\n                }\n            }\n        } else if x < 0 {\n   \
    \         match largest_neg {\n                None => largest_neg = Some(x),\n\
    \                Some(num) => {\n                    if x > num {\n          \
    \              largest_neg = Some(x);\n                    }\n               \
    \ }\n            }\n        }\n    }\n    (largest_neg, smallest_pos)", '    unimplemented!()',
  "    let mut largest_neg = None;\n    let mut smallest_pos = None;\n    for i in\
    \ lst {\n        match i {\n            i if i < 0 => {\n                match\
    \ largest_neg {\n                    None => largest_neg = Some(i),\n        \
    \            Some(j) if i > j => largest_neg = Some(i),\n                    _\
    \ => (),\n                }\n            }\n            i if i > 0 => {\n    \
    \            match smallest_pos {\n                    None => smallest_pos =\
    \ Some(i),\n                    Some(j) if i < j => smallest_pos = Some(i),\n\
    \                    _ => (),\n                }\n            }\n            _\
    \ => (),\n        }\n    }\n    (largest_neg, smallest_pos)", '    unimplemented!()',
  "    let mut smallest_positive = None;\n    let mut largest_negative = None;\n \
    \   for i in lst {\n        if i < 0 {\n            if largest_negative.is_none()\
    \ || i > largest_negative.unwrap() {\n                largest_negative = Some(i);\n\
    \            }\n        } else if i > 0 {\n            if smallest_positive.is_none()\
    \ || i < smallest_positive.unwrap() {\n                smallest_positive = Some(i);\n\
    \            }\n        }\n    }\n    (largest_negative, smallest_positive)",
  "    let mut large = None;\n    let mut small = None;\n    for v in lst {\n    \
    \    if large.is_none() && v < 0 {\n            large = Some(v);\n        } else\
    \ if small.is_none() && v > 0 {\n            small = Some(v);\n        } else\
    \ if large.is_some() && v < large.unwrap() {\n            large = Some(v);\n \
    \       } else if small.is_some() && v > small.unwrap() {\n            small =\
    \ Some(v);\n        }\n    }\n    (large, small)", "    let mut small = None;\n\
    \    let mut large = None;\n    for i in lst {\n        if i < 0 {\n         \
    \   if small == None {\n                small = Some(i);\n            } else if\
    \ small.unwrap() < i {\n                small = Some(i);\n            }\n    \
    \    } else if i > 0 {\n            if large == None {\n                large\
    \ = Some(i);\n            } else if large.unwrap() > i {\n                large\
    \ = Some(i);\n            }\n        }\n    }\n    (small, large)", "    let mut\
    \ neg: Option<isize> = None;\n    let mut pos: Option<isize> = None;\n    for\
    \ num in lst {\n        match num {\n            0 => (),\n            x if x\
    \ < 0 => {\n                match neg {\n                    None => neg = Some(x),\n\
    \                    Some(y) if x > y => neg = Some(x),\n                    _\
    \ => (),\n                }\n            }\n            x if x > 0 => {\n    \
    \            match pos {\n                    None => pos = Some(x),\n       \
    \             Some(y) if x < y => pos = Some(x),\n                    _ => (),\n\
    \                }\n            }\n            _ => unreachable!(),\n        }\n\
    \    }\n    (neg, pos)", "    let mut neg = None;\n    let mut pos = None;\n \
    \   for i in lst {\n        if i < 0 {\n            neg = if let Some(n) = neg\
    \ {\n                Some(cmp::max(n, i))\n            } else {\n            \
    \    Some(i)\n            }\n        } else if i > 0 {\n            pos = if let\
    \ Some(p) = pos {\n                Some(cmp::min(p, i))\n            } else {\n\
    \                Some(i)\n            }\n        }\n    }\n    (neg, pos)", " \
    \   let mut lst = lst;\n    lst.sort();\n    let l = lst.len();\n    if l == 0\
    \ {\n        return (None, None);\n    }\n    let mut b = None;\n    let mut a\
    \ = None;\n    for i in lst {\n        if i < 0 {\n            a = Some(i);\n\
    \        } else if i > 0 {\n            b = Some(i);\n            break;\n   \
    \     }\n    }\n    (a, b)", "    let mut res = (None, None);\n    for x in lst\
    \ {\n        if x > 0 {\n            if res.1.is_none() || res.1.unwrap() > x\
    \ {\n                res.1 = Some(x);\n            }\n        } else if x < 0\
    \ {\n            if res.0.is_none() || res.0.unwrap() < x {\n                res.0\
    \ = Some(x);\n            }\n        }\n    }\n    res", '    unimplemented!()',
  '    unimplemented!()', '  unimplemented!()', "    let mut min = None;\n    let\
    \ mut max = None;\n    for i in lst {\n        if min.is_none() && i > 0 {\n \
    \           min = Some(i);\n        }\n        if max.is_none() && i < 0 {\n \
    \           max = Some(i);\n        }\n        if let Some(n) = min {\n      \
    \      if i > 0 && i < n {\n                min = Some(i);\n            }\n  \
    \      }\n        if let Some(n) = max {\n            if i < 0 && i > n {\n  \
    \              max = Some(i);\n            }\n        }\n    }\n    (max, min)",
  "    let mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n\
    \        if i > 0 {\n            if smallest == None || i < smallest.unwrap()\
    \ {\n                smallest = Some(i);\n            }\n        } else if i <\
    \ 0 {\n            if largest == None || i > largest.unwrap() {\n            \
    \    largest = Some(i);\n            }\n        }\n    }\n    (largest, smallest)",
  "    let (mut max, mut min) = (None, None);\n    for v in lst {\n        if max.is_none()\
    \ && v < 0 {\n            max = Some(v);\n        } else if v < 0 && v > max.unwrap()\
    \ {\n            max = Some(v);\n        }\n\n        if min.is_none() && v >\
    \ 0 {\n            min = Some(v);\n        } else if v > 0 && v < min.unwrap()\
    \ {\n            min = Some(v);\n        }\n    }\n    (max, min)", "    if lst.len()\
    \ == 0 {\n        return (None, None);\n    }\n    let mut min_num = Some(isize::MAX);\n\
    \    let mut max_num = Some(isize::MIN);\n    for x in lst {\n        if x > 0\
    \ {\n            if x < min_num.unwrap() {\n                min_num = Some(x);\n\
    \            }\n        } else if x < 0 {\n            if x > max_num.unwrap()\
    \ {\n                max_num = Some(x);\n            }\n        }\n    }\n   \
    \ if min_num.unwrap() == isize::MAX {\n        min_num = None;\n    }\n    if\
    \ max_num.unwrap() == isize::MIN {\n        max_num = None;\n    }\n    (max_num,\
    \ min_num)", "    let v: Vec<isize> = lst.iter().filter(|&x| *x < 0).cloned().collect();\n\
    \    let w: Vec<isize> = lst.iter().filter(|&x| *x > 0).cloned().collect();\n\
    \    (v.iter().max().cloned(), w.iter().min().cloned())", "    let mut min = None;\n\
    \    let mut max = None;\n    for i in lst {\n        if i > 0 {\n           \
    \ if let Some(x) = min {\n                if i < x {\n                    min\
    \ = Some(i);\n                }\n            } else {\n                min = Some(i);\n\
    \            }\n        } else if i < 0 {\n            if let Some(x) = max {\n\
    \                if i > x {\n                    max = Some(i);\n            \
    \    }\n            } else {\n                max = Some(i);\n            }\n\
    \        }\n    }\n    (max, min)", "    let mut min = None;\n    let mut max\
    \ = None;\n    for i in lst {\n        if i < 0 {\n            max = Some(match\
    \ max {\n                Some(x) => cmp::max(x, i),\n                None => i,\n\
    \            });\n        } else if i > 0 {\n            min = Some(match min\
    \ {\n                Some(x) => cmp::min(x, i),\n                None => i,\n\
    \            });\n        }\n    }\n    (max, min)", '    unimplemented!();',
  "    let mut min = None;\n    let mut max = None;\n    for i in lst {\n        if\
    \ i < 0 {\n            max = Some(i.max(max.unwrap_or(i)));\n        } else if\
    \ i > 0 {\n            min = Some(i.min(min.unwrap_or(i)));\n        }\n    }\n\
    \    (max, min)", '    unimplemented!();', "    let mut negatives = Vec::new();\n\
    \    let mut positives = Vec::new();\n    for num in lst {\n        if num < 0\
    \ {\n            negatives.push(num);\n        } else if num > 0 {\n         \
    \   positives.push(num);\n        }\n    }\n    negatives.sort();\n    positives.sort();\n\
    \    negatives.reverse();\n    return (negatives.pop(), positives.pop());", " \
    \   let max_pos = lst.iter().cloned().filter(|&x| x > 0).max();\n    let min_neg\
    \ = lst.iter().cloned().filter(|&x| x < 0).min();\n    (min_neg, max_pos)", " \
    \   let mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n\
    \        match i {\n            x if x > 0 => {\n                match smallest\
    \ {\n                    None => smallest = Some(x),\n                    Some(y)\
    \ => if x < y { smallest = Some(x) }\n                }\n            },\n    \
    \        x if x < 0 => {\n                match largest {\n                  \
    \  None => largest = Some(x),\n                    Some(y) => if x > y { largest\
    \ = Some(x) }\n                }\n            },\n            _ => {}\n      \
    \  }\n    }\n    (largest, smallest)", "    let mut lst_pos = Vec::new();\n  \
    \  let mut lst_neg = Vec::new();\n    for i in lst {\n        if i > 0 {\n   \
    \         lst_pos.push(i);\n        } else if i < 0 {\n            lst_neg.push(i);\n\
    \        }\n    }\n    lst_pos.sort();\n    lst_neg.sort();\n    if lst_pos.len()\
    \ == 0 && lst_neg.len() == 0 {\n        (None, None)\n    } else if lst_pos.len()\
    \ == 0 {\n        (Some(lst_neg[0]), None)\n    } else if lst_neg.len() == 0 {\n\
    \        (None, Some(lst_pos[0]))\n    } else {\n        (Some(lst_neg[0]), Some(lst_pos[0]))\n\
    \    }", '    unimplemented!();', "    let mut pos = None;\n    let mut neg =\
    \ None;\n    for num in lst {\n        if num > 0 {\n            if pos.is_none()\
    \ || num < pos.unwrap() {\n                pos = Some(num);\n            }\n \
    \       } else if num < 0 {\n            if neg.is_none() || num > neg.unwrap()\
    \ {\n                neg = Some(num);\n            }\n        }\n    }\n    (neg,\
    \ pos)", "    // Write your code here\n    if lst.len() == 0 {\n        return\
    \ (None, None);\n    }\n    let mut a = None;\n    let mut b = None;\n    for\
    \ i in lst {\n        if i < 0 {\n            if let Some(x) = a {\n         \
    \       if i > x {\n                    a = Some(i);\n                }\n    \
    \        } else {\n                a = Some(i);\n            }\n        } else\
    \ if i > 0 {\n            if let Some(x) = b {\n                if i < x {\n \
    \                   b = Some(i);\n                }\n            } else {\n  \
    \              b = Some(i);\n            }\n        }\n    }\n    (a, b)", " \
    \   let mut max = None;\n    let mut min = None;\n    for el in lst {\n      \
    \  match (max, min) {\n            (None, None) => {\n                if el >\
    \ 0 {\n                    min = Some(el);\n                } else if el < 0 {\n\
    \                    max = Some(el);\n                }\n            }\n     \
    \       (None, Some(min)) => {\n                if el > 0 && el < min {\n    \
    \                min = el;\n                } else if el < 0 {\n             \
    \       max = Some(el);\n                }\n            }\n            (Some(max),\
    \ None) => {\n                if el > 0 {\n                    min = Some(el);\n\
    \                } else if el < 0 && el > max {\n                    max = el;\n\
    \                }\n            }\n            (Some(max), Some(min)) => {\n \
    \               if el > 0 && el < min {\n                    min = el;\n     \
    \           } else if el < 0 && el > max {\n                    max = el;\n  \
    \              }\n            }\n        }\n    }\n    (max, min)", '    unimplemented!()',
  '    unimplemented!()', "    let mut smallest = None;\n    let mut largest = None;\n\
    \    for x in lst {\n        if x > 0 {\n            if smallest == None || smallest.unwrap()\
    \ > x {\n                smallest = Some(x);\n            }\n        } else if\
    \ x < 0 {\n            if largest == None || largest.unwrap() < x {\n        \
    \        largest = Some(x);\n            }\n        }\n    }\n    (largest, smallest)",
  "    let mut largest_negative: Option<isize> = None;\n    let mut smallest_positive:\
    \ Option<isize> = None;\n    for num in lst {\n        if num > 0 {\n        \
    \    if smallest_positive.is_none() || num < smallest_positive.unwrap() {\n  \
    \              smallest_positive = Some(num);\n            }\n        } else if\
    \ num < 0 {\n            if largest_negative.is_none() || num > largest_negative.unwrap()\
    \ {\n                largest_negative = Some(num);\n            }\n        }\n\
    \    }\n    (largest_negative, smallest_positive)", '    unimplemented!()', " \
    \   let mut min = None;\n    let mut max = None;\n    for &item in &lst {\n  \
    \      if item < 0 {\n            max = match max {\n                None => Some(item),\n\
    \                Some(x) => Some(max(x, item)),\n            };\n        } else\
    \ if item > 0 {\n            min = match min {\n                None => Some(item),\n\
    \                Some(x) => Some(min(x, item)),\n            };\n        }\n \
    \   }\n    (max, min)", '    unimplemented!()', "    let mut largest_smallest_tuple\
    \ = (None, None);\n    for i in lst {\n        if largest_smallest_tuple.0 ==\
    \ None {\n            if i < 0 {\n                largest_smallest_tuple.0 = Some(i);\n\
    \            }\n        } else if largest_smallest_tuple.0.unwrap() < i {\n  \
    \          largest_smallest_tuple.0 = Some(i);\n        }\n        if largest_smallest_tuple.1\
    \ == None {\n            if i > 0 {\n                largest_smallest_tuple.1\
    \ = Some(i);\n            }\n        } else if largest_smallest_tuple.1.unwrap()\
    \ > i {\n            largest_smallest_tuple.1 = Some(i);\n        }\n    }\n \
    \   largest_smallest_tuple", "    let mut largest_negative: Option<isize> = None;\n\
    \    let mut smallest_positive: Option<isize> = None;\n    for i in lst {\n  \
    \      match i.cmp(&0) {\n            Ordering::Less => {\n                if\
    \ largest_negative.is_none() || i > largest_negative.unwrap() {\n            \
    \        largest_negative = Some(i);\n                }\n            }\n     \
    \       Ordering::Greater => {\n                if smallest_positive.is_none()\
    \ || i < smallest_positive.unwrap() {\n                    smallest_positive =\
    \ Some(i);\n                }\n            }\n            _ => (),\n        }\n\
    \    }\n    (largest_negative, smallest_positive)", '    unimplemented!()', " \
    \   let mut least_positive: Option<isize> = None;\n    let mut greatest_negative:\
    \ Option<isize> = None;\n    for &num in lst.iter() {\n        if num > 0 {\n\
    \            if least_positive.is_none() || num < least_positive.unwrap() {\n\
    \                least_positive = Some(num);\n            }\n        } else if\
    \ num < 0 {\n            if greatest_negative.is_none() || num > greatest_negative.unwrap()\
    \ {\n                greatest_negative = Some(num);\n            }\n        }\n\
    \    }\n    (greatest_negative, least_positive)", "    let mut negative_max: Option<isize>\
    \ = None;\n    let mut positive_min: Option<isize> = None;\n    for x in lst {\n\
    \        if x < 0 {\n            match negative_max {\n                None =>\
    \ negative_max = Some(x),\n                Some(y) => {\n                    if\
    \ x > y {\n                        negative_max = Some(x);\n                 \
    \   }\n                }\n            }\n        } else if x > 0 {\n         \
    \   match positive_min {\n                None => positive_min = Some(x),\n  \
    \              Some(y) => {\n                    if x < y {\n                \
    \        positive_min = Some(x);\n                    }\n                }\n \
    \           }\n        }\n    }\n    (negative_max, positive_min)", "    let mut\
    \ negatives = None;\n    let mut positives = None;\n    for i in lst {\n     \
    \   if i < 0 {\n            negatives = match negatives {\n                None\
    \ => Some(i),\n                Some(x) => Some(std::cmp::max(x, i)),\n       \
    \     };\n        } else if i > 0 {\n            positives = match positives {\n\
    \                None => Some(i),\n                Some(x) => Some(std::cmp::min(x,\
    \ i)),\n            };\n        }\n    }\n    (negatives, positives)", "    //\
    \ let mut it = lst.iter();\n    let mut largest = None;\n    let mut smallest\
    \ = None;\n    for item in lst {\n        if item < 0 {\n            largest =\
    \ match largest {\n                None => Some(item),\n                Some(a)\
    \ => Some(item.max(a)),\n            };\n        } else if item > 0 {\n      \
    \      smallest = match smallest {\n                None => Some(item),\n    \
    \            Some(a) => Some(item.min(a)),\n            };\n        }\n    }\n\
    \    (largest, smallest)", '    unimplemented!()', '    unimplemented!()', " \
    \   let sorted_lst = lst.clone();\n    sorted_lst.sort();\n    let largest = sorted_lst.iter().fold(None,\
    \ |acc, &x| {\n        match acc {\n            None => Some(x),\n           \
    \ Some(n) => if x < 0 && x > n { Some(x) } else { Some(n) },\n        }\n    });\n\
    \    let smallest = sorted_lst.iter().fold(None, |acc, &x| {\n        match acc\
    \ {\n            None => Some(x),\n            Some(n) => if x > 0 && x < n {\
    \ Some(x) } else { Some(n) },\n        }\n    });\n    (largest, smallest)", '    unimplemented!();',
  '    unimplemented!()', '    (None, None)', '    unimplemented!();', '    unimplemented!()',
  "    lst.iter().fold((None, None), |acc, &num| match (acc.0, acc.1) {\n        (None,\
    \ None) => (None, None),\n        (Some(x), None) => if num < 0 {\n          \
    \  (Some(cmp::max(x, num)), None)\n        } else {\n            (Some(x), Some(num))\n\
    \        },\n        (None, Some(y)) => if num < 0 {\n            (Some(num),\
    \ Some(y))\n        } else {\n            (None, Some(cmp::min(y, num)))\n   \
    \     },\n        (Some(x), Some(y)) => if num < 0 {\n            (Some(cmp::max(x,\
    \ num)), Some(y))\n        } else {\n            (Some(x), Some(cmp::min(y, num)))\n\
    \        },\n    })", '    unimplemented!()', '    unimplemented!()', '    unimplemented!()',
  "    let mut max = None;\n    let mut min = None;\n    for i in lst {\n        match\
    \ i {\n            i if i > 0 => {\n                if min.is_none() || i < min.unwrap()\
    \ {\n                    min = Some(i);\n                }\n            }\n  \
    \          i if i < 0 => {\n                if max.is_none() || i > max.unwrap()\
    \ {\n                    max = Some(i);\n                }\n            }\n  \
    \          _ => (),\n        }\n    }\n    (max, min)", "    let mut l = None;\n\
    \    let mut s = None;\n    for num in lst {\n        if num < 0 {\n         \
    \   if l.is_none() || l.unwrap() < num {\n                l = Some(num);\n   \
    \         }\n        } else if num > 0 {\n            if s.is_none() || s.unwrap()\
    \ > num {\n                s = Some(num);\n            }\n        }\n    }\n \
    \   (l, s)", "    let mut a = None;\n    let mut b = None;\n    for n in lst {\n\
    \        if n < 0 {\n            if a.is_none() || n > a.unwrap() {\n        \
    \        a = Some(n);\n            }\n        } else if n > 0 {\n            if\
    \ b.is_none() || n < b.unwrap() {\n                b = Some(n);\n            }\n\
    \        }\n    }\n    (a, b)", "    let mut max_neg = None;\n    let mut min_pos\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_neg.is_none()\
    \ || max_neg.unwrap() < x {\n                max_neg = Some(x);\n            }\n\
    \        } else if x > 0 {\n            if min_pos.is_none() || min_pos.unwrap()\
    \ > x {\n                min_pos = Some(x);\n            }\n        }\n    }\n\
    \    (max_neg, min_pos)", "    let mut largest_negative = None;\n    let mut smallest_positive\
    \ = None;\n    for item in lst {\n        if item < 0 {\n            if let Some(temp)\
    \ = largest_negative {\n                if item > temp {\n                   \
    \ largest_negative = Some(item);\n                }\n            } else {\n  \
    \              largest_negative = Some(item);\n            }\n        } else if\
    \ item > 0 {\n            if let Some(temp) = smallest_positive {\n          \
    \      if item < temp {\n                    smallest_positive = Some(item);\n\
    \                }\n            } else {\n                smallest_positive =\
    \ Some(item);\n            }\n        }\n    }\n    (largest_negative, smallest_positive)",
  "    // TODO\n    (None, None)", "    let mut min_pos = None;\n    let mut max_neg\
    \ = None;\n    for num in lst {\n        if num > 0 {\n            min_pos = match\
    \ min_pos {\n                None => Some(num),\n                Some(x) => Some(cmp::min(x,\
    \ num)),\n            };\n        } else if num < 0 {\n            max_neg = match\
    \ max_neg {\n                None => Some(num),\n                Some(x) => Some(cmp::max(x,\
    \ num)),\n            };\n        }\n    }\n    (max_neg, min_pos)", '    unimplemented!()',
  "    let mut a = None;\n    let mut b = None;\n    for x in lst {\n        if x\
    \ < 0 {\n            a = match a {\n                None => Some(x),\n       \
    \         Some(y) => Some(max(x, y)),\n            }\n        } else if x > 0\
    \ {\n            b = match b {\n                None => Some(x),\n           \
    \     Some(y) => Some(min(x, y)),\n            }\n        }\n    }\n    (a, b)",
  '    unimplemented!()', '    unimplemented!()', "    let mut max_neg: Option<isize>\
    \ = None;\n    let mut min_pos: Option<isize> = None;\n    for x in lst {\n  \
    \      match x < 0 {\n            true => {\n                if let Some(y) =\
    \ max_neg {\n                    if x > y {\n                        max_neg =\
    \ Some(x);\n                    }\n                } else {\n                \
    \    max_neg = Some(x);\n                }\n            }\n            false =>\
    \ {\n                if let Some(y) = min_pos {\n                    if x < y\
    \ {\n                        min_pos = Some(x);\n                    }\n     \
    \           } else {\n                    min_pos = Some(x);\n               \
    \ }\n            }\n        }\n    }\n    (max_neg, min_pos)", "    let mut neg_max\
    \ = None;\n    let mut pos_min = None;\n    for x in lst {\n        if x >= 0\
    \ {\n            if pos_min.is_none() || x < pos_min.unwrap() {\n            \
    \    pos_min = Some(x);\n            }\n        } else {\n            if neg_max.is_none()\
    \ || x > neg_max.unwrap() {\n                neg_max = Some(x);\n            }\n\
    \        }\n    }\n    (neg_max, pos_min)", '    unimplemented!()', '    unimplemented!()',
  '    (None, None)', "    // put your code here\n    (None, None)", "    // TODO\n\
    \    let mut min = None;\n    let mut max = None;\n    for i in lst {\n      \
    \  min = min.map_or(Some(i), |x| Some(x.min(i)));\n        max = max.map_or(Some(i),\
    \ |x| Some(x.max(i)));\n    }\n    (max, min)", '    unimplemented!()', "    //\
    \ Your code here.\n    let mut least = None;\n    let mut most = None;\n    for\
    \ i in lst {\n        match i.cmp(&0) {\n            Ordering::Less => {\n   \
    \             if let Some(i) = least {\n                    if i < i {\n     \
    \                   least = Some(i);\n                    }\n                }\
    \ else {\n                    least = Some(i);\n                }\n          \
    \  }\n            Ordering::Greater => {\n                if let Some(i) = most\
    \ {\n                    if i > i {\n                        most = Some(i);\n\
    \                    }\n                } else {\n                    most = Some(i);\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ (least, most)", '    unimplemented!()', '    unimplemented!();', "    let mut\
    \ max = None;\n    let mut min = None;\n    for x in lst {\n        if x < 0 {\n\
    \            if max.is_none() || max.unwrap() < x {\n                max = Some(x);\n\
    \            }\n        } else if x > 0 {\n            if min.is_none() || min.unwrap()\
    \ > x {\n                min = Some(x);\n            }\n        }\n    }\n   \
    \ (max, min)", '    (None, None)', "    if lst.len() == 0 {\n        return (None,\
    \ None);\n    }\n    let mut largest_neg = None;\n    let mut smallest_pos = None;\n\
    \    for item in lst {\n        if item < 0 {\n            if largest_neg.is_none()\
    \ || item > largest_neg.unwrap() {\n                largest_neg = Some(item);\n\
    \            }\n        } else if item > 0 {\n            if smallest_pos.is_none()\
    \ || item < smallest_pos.unwrap() {\n                smallest_pos = Some(item);\n\
    \            }\n        }\n    }\n    (largest_neg, smallest_pos)", '    unimplemented!()',
  '    (None, None)', '    unimplemented!();', "    let mut small_pos: Option<isize>\
    \ = None;\n    let mut large_neg: Option<isize> = None;\n    for n in lst {\n\
    \        if n > 0 {\n            match small_pos {\n                None => small_pos\
    \ = Some(n),\n                Some(m) => if n < m {\n                    small_pos\
    \ = Some(n);\n                }\n            }\n        } else if n < 0 {\n  \
    \          match large_neg {\n                None => large_neg = Some(n),\n \
    \               Some(m) => if n > m {\n                    large_neg = Some(n);\n\
    \                }\n            }\n        }\n    }\n    (large_neg, small_pos)",
  "    let mut large = None;\n    let mut small = None;\n    for i in lst {\n    \
    \    if i >= 0 {\n            if small == None {\n                small = Some(i);\n\
    \            } else if i < small.unwrap() {\n                small = Some(i);\n\
    \            }\n        } else {\n            if large == None {\n           \
    \     large = Some(i);\n            } else if i > large.unwrap() {\n         \
    \       large = Some(i);\n            }\n        }\n    }\n    (large, small)",
  "    let mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n\
    \        if i > 0 {\n            if smallest == None || i < smallest.unwrap()\
    \ {\n                smallest = Some(i);\n            }\n        } else if i <\
    \ 0 {\n            if largest == None || i > largest.unwrap() {\n            \
    \    largest = Some(i);\n            }\n        }\n    }\n    (largest, smallest)",
  "    let (pos, neg) = lst.iter().fold((None, None), |acc, x| {\n        let (x,\
    \ y) = acc;\n        if *x == None && *x > Some(*x) {\n            (*x, y)\n \
    \       } else if *y == None && *y < Some(*y) {\n            (x, *y)\n       \
    \ } else {\n            (*x, *y)\n        }\n    });\n    (neg, pos)", "    let\
    \ mut small: Option<isize> = None;\n    let mut large: Option<isize> = None;\n\
    \    for i in lst {\n        if i > 0 {\n            if let Some(s) = small {\n\
    \                if i < s {\n                    small = Some(i);\n          \
    \      }\n            } else {\n                small = Some(i);\n           \
    \ }\n        } else if i < 0 {\n            if let Some(l) = large {\n       \
    \         if i > l {\n                    large = Some(i);\n                }\n\
    \            } else {\n                large = Some(i);\n            }\n     \
    \   }\n    }\n    (large, small)", "    let mut min = None;\n    let mut max =\
    \ None;\n    for x in lst {\n        if x > 0 {\n            if max.is_none()\
    \ || x > max.unwrap() {\n                max = Some(x);\n            }\n     \
    \   } else if x < 0 {\n            if min.is_none() || x < min.unwrap() {\n  \
    \              min = Some(x);\n            }\n        }\n    }\n    (min, max)",
  '    (None, None)', "    // This function returns a tuple containing the largest\
    \ of negative integers,\n    // and the smallest of positive integers in the given\
    \ array.\n    let v: Vec<_> = lst.iter().filter(|x| x < &&0).collect();\n    let\
    \ u: Vec<_> = lst.iter().filter(|x| x > &&0).collect();\n    if !v.is_empty()\
    \ {\n        (Some(*v.iter().max().unwrap()), Some(*u.iter().min().unwrap()))\n\
    \    } else {\n        (None, None)\n    }", "    let mut pos_min = None;\n  \
    \  let mut neg_max = None;\n    for elem in lst {\n        if elem > 0 {\n   \
    \         pos_min = Some(match pos_min {\n                None => elem,\n    \
    \            Some(min) => if elem < min { elem } else { min },\n            });\n\
    \        } else if elem < 0 {\n            neg_max = Some(match neg_max {\n  \
    \              None => elem,\n                Some(max) => if elem > max { elem\
    \ } else { max },\n            });\n        }\n    }\n    (neg_max, pos_min)",
  "    let mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n\
    \        if i < 0 {\n            largest = Some(cmp::max(largest.unwrap_or(i),\
    \ i));\n        } else if i > 0 {\n            smallest = Some(cmp::min(smallest.unwrap_or(i),\
    \ i));\n        }\n    }\n    (largest, smallest)", "    let mut largest_neg =\
    \ None;\n    let mut smallest_pos = None;\n    for i in lst {\n        if i <\
    \ 0 {\n            largest_neg = match largest_neg {\n                None =>\
    \ Some(i),\n                Some(a) => Some(std::cmp::max(a, i)),\n          \
    \  };\n        } else if i > 0 {\n            smallest_pos = match smallest_pos\
    \ {\n                None => Some(i),\n                Some(a) => Some(std::cmp::min(a,\
    \ i)),\n            };\n        }\n    }\n    (largest_neg, smallest_pos)", " \
    \   let mut min: Option<isize> = None;\n    let mut max: Option<isize> = None;\n\
    \    for i in lst {\n        if i > 0 {\n            if min.is_none() || i < min.unwrap()\
    \ {\n                min = Some(i);\n            }\n        } else if i < 0 {\n\
    \            if max.is_none() || i > max.unwrap() {\n                max = Some(i);\n\
    \            }\n        }\n    }\n    (max, min)", '    unimplemented!()', " \
    \   if lst.len() == 0 {\n        return (None, None);\n    }\n    let mut min_pos\
    \ = None;\n    let mut max_neg = None;\n    for i in lst {\n        if i < 0 {\n\
    \            if let Some(x) = max_neg {\n                if i > x {\n        \
    \            max_neg = Some(i);\n                }\n            } else {\n   \
    \             max_neg = Some(i);\n            }\n        } else if i > 0 {\n \
    \           if let Some(x) = min_pos {\n                if i < x {\n         \
    \           min_pos = Some(i);\n                }\n            } else {\n    \
    \            min_pos = Some(i);\n            }\n        }\n    }\n    (max_neg,\
    \ min_pos)", "  //return a tuple\n  //(largest negative, smallest positive)\n\
    \  let mut largest_negative: Option<isize> = None;\n  let mut smallest_positive:\
    \ Option<isize> = None;\n  for i in lst {\n    if i >= 0 {\n      if smallest_positive\
    \ == None {\n        smallest_positive = Some(i);\n      } else if i < smallest_positive.unwrap()\
    \ {\n        smallest_positive = Some(i);\n      }\n    } else {\n      if largest_negative\
    \ == None {\n        largest_negative = Some(i);\n      } else if i > largest_negative.unwrap()\
    \ {\n        largest_negative = Some(i);\n      }\n    }\n  }\n  (largest_negative,\
    \ smallest_positive)", '    unimplemented!()', "    // initialize the result\n\
    \    let mut result = (None, None);\n    for i in lst {\n        if i > 0 {\n\
    \            if let Some(j) = result.1 {\n                if i < j {\n       \
    \             result.1 = Some(i);\n                }\n            } else {\n \
    \               result.1 = Some(i);\n            }\n        } else if i < 0 {\n\
    \            if let Some(j) = result.0 {\n                if i > j {\n       \
    \             result.0 = Some(i);\n                }\n            } else {\n \
    \               result.0 = Some(i);\n            }\n        }\n    }\n    result",
  '    unimplemented!()', '    unimplemented!()', "    let mut pos = None;\n    let\
    \ mut neg = None;\n    for &i in &lst {\n        if i < 0 {\n            if let\
    \ Some(n) = neg {\n                if i > n {\n                    neg = Some(i);\n\
    \                }\n            } else {\n                neg = Some(i);\n   \
    \         }\n        } else if i > 0 {\n            if let Some(p) = pos {\n \
    \               if i < p {\n                    pos = Some(i);\n             \
    \   }\n            } else {\n                pos = Some(i);\n            }\n \
    \       }\n    }\n    (neg, pos)", "    let mut max_neg = None;\n    let mut min_pos\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if let Some(max)\
    \ = max_neg {\n                if x > max {\n                    max_neg = Some(x);\n\
    \                }\n            } else {\n                max_neg = Some(x);\n\
    \            }\n        } else if x > 0 {\n            if let Some(min) = min_pos\
    \ {\n                if x < min {\n                    min_pos = Some(x);\n  \
    \              }\n            } else {\n                min_pos = Some(x);\n \
    \           }\n        }\n    }\n    (max_neg, min_pos)", "    let mut smallest\
    \ = None;\n    let mut largest = None;\n    for n in lst {\n        if n > 0 {\n\
    \            smallest = match smallest {\n                None => Some(n),\n \
    \               Some(n2) => Some(std::cmp::min(n, n2)),\n            };\n    \
    \    } else if n < 0 {\n            largest = match largest {\n              \
    \  None => Some(n),\n                Some(n2) => Some(std::cmp::max(n, n2)),\n\
    \            };\n        }\n    }\n    (largest, smallest)", "    // Your code\
    \ here\n    let mut smallest = None;\n    let mut largest = None;\n    for i in\
    \ lst {\n        if i < 0 {\n            match largest {\n                None\
    \ => largest = Some(i),\n                Some(x) => {\n                    if\
    \ i > x {\n                        largest = Some(i);\n                    }\n\
    \                }\n            }\n        } else if i > 0 {\n            match\
    \ smallest {\n                None => smallest = Some(i),\n                Some(x)\
    \ => {\n                    if i < x {\n                        smallest = Some(i);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   (largest, smallest)", "    let mut min: Option<isize> = None;\n    let mut\
    \ max: Option<isize> = None;\n    for i in lst {\n        if i < 0 {\n       \
    \     match max {\n                Some(n) => {\n                    if i > n\
    \ {\n                        max = Some(i);\n                    }\n         \
    \       }\n                None => max = Some(i),\n            }\n        } else\
    \ if i > 0 {\n            match min {\n                Some(n) => {\n        \
    \            if i < n {\n                        min = Some(i);\n            \
    \        }\n                }\n                None => min = Some(i),\n      \
    \      }\n        }\n    }\n    (max, min)", "    let mut negatives = vec![];\n\
    \    let mut positives = vec![];\n    for i in lst {\n        if i < 0 {\n   \
    \         negatives.push(i);\n        } else if i > 0 {\n            positives.push(i);\n\
    \        }\n    }\n    negatives.sort();\n    positives.sort();\n    (negatives.last().map(|x|\
    \ *x), positives.first().map(|x| *x))", '    unimplemented!()', '    unimplemented!()',
  '  (largest_integer(lst.clone()), smallest_integer(lst))', "    let mut max_neg\
    \ = None;\n    let mut min_pos = None;\n    for n in lst {\n        if n < 0 {\n\
    \            if max_neg.is_none() || n > max_neg.unwrap() {\n                max_neg\
    \ = Some(n);\n            }\n        } else if n > 0 {\n            if min_pos.is_none()\
    \ || n < min_pos.unwrap() {\n                min_pos = Some(n);\n            }\n\
    \        }\n    }\n    (max_neg, min_pos)", "    let mut smallest_positive = None;\n\
    \    let mut largest_negative = None;\n    for x in lst {\n        if x > 0 {\n\
    \            smallest_positive = Some(match smallest_positive {\n            \
    \    None => x,\n                Some(y) => cmp::min(x, y),\n            });\n\
    \        } else if x < 0 {\n            largest_negative = Some(match largest_negative\
    \ {\n                None => x,\n                Some(y) => cmp::max(x, y),\n\
    \            });\n        }\n    }\n    (largest_negative, smallest_positive)",
  "    let mut min_pos: Option<isize> = None;\n    let mut max_neg: Option<isize>\
    \ = None;\n    for i in lst {\n        match i > 0 {\n            true => {\n\
    \                if let Some(x) = min_pos {\n                    if i < x {\n\
    \                        min_pos = Some(i);\n                    }\n         \
    \       } else {\n                    min_pos = Some(i);\n                }\n\
    \            }\n            false => {\n                if let Some(x) = max_neg\
    \ {\n                    if i > x {\n                        max_neg = Some(i);\n\
    \                    }\n                } else {\n                    max_neg\
    \ = Some(i);\n                }\n            }\n        }\n    }\n    (max_neg,\
    \ min_pos)", "    let mut neg_cnt = 0;\n    let mut pos_cnt = 0;\n    let mut\
    \ largest_neg = std::isize::MIN;\n    let mut smallest_pos = std::isize::MAX;\n\
    \    for item in lst {\n        if item < 0 {\n            neg_cnt += 1;\n   \
    \         if item > largest_neg {\n                largest_neg = item;\n     \
    \       }\n        } else if item > 0 {\n            pos_cnt += 1;\n         \
    \   if item < smallest_pos {\n                smallest_pos = item;\n         \
    \   }\n        }\n    }\n    let largest_neg = if neg_cnt == 0 {\n        None\n\
    \    } else {\n        Some(largest_neg)\n    };\n    let smallest_pos = if pos_cnt\
    \ == 0 {\n        None\n    } else {\n        Some(smallest_pos)\n    };\n   \
    \ (largest_neg, smallest_pos)", '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!()', '    unimplemented!()', '    unimplemented!();', "    lst.iter().fold((None,\
    \ None), |(a, b), x| match x {\n        x if x < &0 => (Some(x.max(a.unwrap_or(0))),\
    \ b),\n        x if x > &0 => (a, Some(x.min(b.unwrap_or(0)))),\n        _ =>\
    \ (a, b),\n    })", '    unimplemented!()', '    unimplemented!()', "    if lst.len()\
    \ == 0 {\n        return (None, None);\n    }\n    let mut max = isize::min_value();\n\
    \    let mut min = isize::max_value();\n    for item in lst {\n        if item\
    \ > 0 {\n            if item < min {\n                min = item;\n          \
    \  }\n        } else if item < 0 {\n            if item > max {\n            \
    \    max = item;\n            }\n        }\n    }\n    if max == isize::min_value()\
    \ {\n        max = None;\n    } else {\n        max = Some(max);\n    }\n    if\
    \ min == isize::max_value() {\n        min = None;\n    } else {\n        min\
    \ = Some(min);\n    }\n    (max, min)", '    unimplemented!();', "    let mut\
    \ max_neg: Option<isize> = None;\n    let mut min_pos: Option<isize> = None;\n\
    \    for n in lst {\n        if n > 0 {\n            if min_pos.is_none() || n\
    \ < min_pos.unwrap() {\n                min_pos = Some(n);\n            }\n  \
    \      } else if n < 0 {\n            if max_neg.is_none() || n > max_neg.unwrap()\
    \ {\n                max_neg = Some(n);\n            }\n        }\n    }\n   \
    \ (max_neg, min_pos)", "    let mut largest = None;\n    let mut smallest = None;\n\
    \    for item in lst {\n        if item > 0 {\n            if let Some(ref current)\
    \ = smallest {\n                if item < *current {\n                    smallest\
    \ = Some(item);\n                }\n            } else {\n                smallest\
    \ = Some(item);\n            }\n        } else if item < 0 {\n            if let\
    \ Some(ref current) = largest {\n                if item > *current {\n      \
    \              largest = Some(item);\n                }\n            } else {\n\
    \                largest = Some(item);\n            }\n        }\n    }\n    (largest,\
    \ smallest)", "    let mut a = None;\n    let mut b = None;\n    for i in lst\
    \ {\n        if i < 0 {\n            if a.is_none() || a.unwrap() < i {\n    \
    \            a = Some(i);\n            }\n        } else if i > 0 {\n        \
    \    if b.is_none() || b.unwrap() > i {\n                b = Some(i);\n      \
    \      }\n        }\n    }\n    (a, b)", "    let mut largest_neg: Option<isize>\
    \ = None;\n    let mut smallest_pos: Option<isize> = None;\n    for i in lst {\n\
    \        if i < 0 {\n            if largest_neg.is_none() || i > largest_neg.unwrap()\
    \ {\n                largest_neg = Some(i);\n            }\n        } else if\
    \ i > 0 {\n            if smallest_pos.is_none() || i < smallest_pos.unwrap()\
    \ {\n                smallest_pos = Some(i);\n            }\n        }\n    }\n\
    \    (largest_neg, smallest_pos)", '    unimplemented!();', "    let mut largest_negative:\
    \ Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if let Some(y) = largest_negative\
    \ {\n                if x > y {\n                    largest_negative = Some(x);\n\
    \                }\n            } else {\n                largest_negative = Some(x);\n\
    \            }\n        } else if x > 0 {\n            if let Some(y) = smallest_positive\
    \ {\n                if x < y {\n                    smallest_positive = Some(x);\n\
    \                }\n            } else {\n                smallest_positive =\
    \ Some(x);\n            }\n        }\n    }\n    (largest_negative, smallest_positive)",
  "    let mut smallest_pos: Option<isize> = None;\n    let mut largest_neg: Option<isize>\
    \ = None;\n    for v in lst {\n        if v > 0 {\n            if let Some(x)\
    \ = smallest_pos {\n                if v < x {\n                    smallest_pos\
    \ = Some(v);\n                }\n            } else {\n                smallest_pos\
    \ = Some(v);\n            }\n        } else if v < 0 {\n            if let Some(x)\
    \ = largest_neg {\n                if v > x {\n                    largest_neg\
    \ = Some(v);\n                }\n            } else {\n                largest_neg\
    \ = Some(v);\n            }\n        }\n    }\n    (largest_neg, smallest_pos)",
  "    let mut neg: Option<isize> = None;\n    let mut pos: Option<isize> = None;\n\
    \    for i in lst {\n        if i < 0 {\n            if neg.is_none() || i > neg.unwrap()\
    \ {\n                neg = Some(i);\n            }\n        } else if i > 0 {\n\
    \            if pos.is_none() || i < pos.unwrap() {\n                pos = Some(i);\n\
    \            }\n        }\n    }\n    (neg, pos)", "    match lst.iter().max()\
    \ {\n        Some(x) => {\n            match x < &0 {\n                true =>\
    \ match lst.iter().min() {\n                    Some(y) => {\n               \
    \         match y > &0 {\n                            true => (Some(*x), Some(*y)),\n\
    \                            false => (Some(*x), None),\n                    \
    \    }\n                    }\n                    None => (Some(*x), None),\n\
    \                },\n                false => (None, None),\n            }\n \
    \       }\n        None => (None, None),\n    }", '    unimplemented!();', " \
    \   let mut small = None;\n    let mut large = None;\n    for i in lst {\n   \
    \     if i > 0 {\n            small = match small {\n                None => Some(i),\n\
    \                Some(n) => Some(if i < n { i } else { n }),\n            };\n\
    \        } else if i < 0 {\n            large = match large {\n              \
    \  None => Some(i),\n                Some(n) => Some(if i > n { i } else { n }),\n\
    \            };\n        }\n    }\n    (large, small)", '    unimplemented!()',
  "    let mut max_neg = None;\n    let mut min_pos = None;\n    for num in lst {\n\
    \        if num > 0 {\n            min_pos = min_pos.map_or(Some(num), |m| Some(num.min(m)));\n\
    \        } else if num < 0 {\n            max_neg = max_neg.map_or(Some(num),\
    \ |m| Some(num.max(m)));\n        }\n    }\n    (max_neg, min_pos)", "    let\
    \ mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n    \
    \    if i > 0 {\n            match smallest {\n                None => smallest\
    \ = Some(i),\n                Some(j) => if i < j { smallest = Some(i) },\n  \
    \          }\n        } else if i < 0 {\n            match largest {\n       \
    \         None => largest = Some(i),\n                Some(j) => if i > j { largest\
    \ = Some(i) },\n            }\n        }\n    }\n    (largest, smallest)", " \
    \   (\n        lst.iter().filter(|&n| n < &0).max().cloned(),\n        lst.iter().filter(|&n|\
    \ n > &0).min().cloned(),\n    )", '    unimplemented!()', "    let mut largest\
    \ = None;\n    let mut smallest = None;\n    for item in lst {\n        if item\
    \ < 0 {\n            if largest.is_none() || largest.unwrap() < item {\n     \
    \           largest = Some(item);\n            }\n        } else if item > 0 {\n\
    \            if smallest.is_none() || smallest.unwrap() > item {\n           \
    \     smallest = Some(item);\n            }\n        }\n    }\n    (largest, smallest)",
  '    unimplemented!()', "    let mut max_neg = None;\n    let mut min_pos = None;\n\
    \    for x in lst {\n        if x > 0 {\n            if min_pos.is_none() || x\
    \ < min_pos.unwrap() {\n                min_pos = Some(x);\n            }\n  \
    \      } else if x < 0 {\n            if max_neg.is_none() || x > max_neg.unwrap()\
    \ {\n                max_neg = Some(x);\n            }\n        }\n    }\n   \
    \ (max_neg, min_pos)", '    unimplemented!()', "    let mut neg = None;\n    let\
    \ mut pos = None;\n    for i in lst {\n        if i > 0 {\n            if neg.is_none()\
    \ || neg.unwrap() < i {\n                neg = Some(i);\n            }\n     \
    \   } else if i < 0 {\n            if pos.is_none() || pos.unwrap() > i {\n  \
    \              pos = Some(i);\n            }\n        }\n    }\n    (neg, pos)",
  "    let mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n\
    \        if i < 0 {\n            if largest.is_none() || i > largest.unwrap()\
    \ {\n                largest = Some(i);\n            }\n        } else if i >\
    \ 0 {\n            if smallest.is_none() || i < smallest.unwrap() {\n        \
    \        smallest = Some(i);\n            }\n        }\n    }\n    (largest, smallest)",
  "    let mut min = None;\n    let mut max = None;\n    for v in lst {\n        if\
    \ v > 0 {\n            if let Some(val) = min {\n                if v < val {\n\
    \                    min = Some(v);\n                }\n            } else {\n\
    \                min = Some(v);\n            }\n        } else if v < 0 {\n  \
    \          if let Some(val) = max {\n                if v > val {\n          \
    \          max = Some(v);\n                }\n            } else {\n         \
    \       max = Some(v);\n            }\n        }\n    }\n    (max, min)", "  \
    \  match (lst.iter().min(), lst.iter().max()) {\n        (Some(min), Some(max))\
    \ => {\n            if *min >= 0 {\n                (None, min)\n            }\
    \ else if *max <= 0 {\n                (max, None)\n            } else {\n   \
    \             (max, min)\n            }\n        }\n        _ => (None, None),\n\
    \    }", '    unimplemented!();', '    unimplemented!()', "    let mut max_negative\
    \ = None;\n    let mut min_positive = None;\n    for i in lst {\n        if i\
    \ < 0 {\n            if max_negative.is_none() || i > max_negative.unwrap() {\n\
    \                max_negative = Some(i);\n            }\n        } else if i >\
    \ 0 {\n            if min_positive.is_none() || i < min_positive.unwrap() {\n\
    \                min_positive = Some(i);\n            }\n        }\n    }\n  \
    \  (max_negative, min_positive)", '    unimplemented!()', '    unimplemented!()',
  "    let mut min_pos = None;\n    let mut max_neg = None;\n    for i in lst {\n\
    \        if i > 0 {\n            if let Some(min) = min_pos {\n              \
    \  if i < min {\n                    min_pos = Some(i);\n                }\n \
    \           } else {\n                min_pos = Some(i);\n            }\n    \
    \    } else if i < 0 {\n            if let Some(max) = max_neg {\n           \
    \     if i > max {\n                    max_neg = Some(i);\n                }\n\
    \            } else {\n                max_neg = Some(i);\n            }\n   \
    \     }\n    }\n    (max_neg, min_pos)", '    unimplemented!()', "    let mut\
    \ largest = None;\n    let mut smallest = None;\n    for n in lst {\n        if\
    \ n < 0 {\n            largest = match largest {\n                None => Some(n),\n\
    \                Some(x) => Some(if n > x { n } else { x }),\n            };\n\
    \        } else if n > 0 {\n            smallest = match smallest {\n        \
    \        None => Some(n),\n                Some(x) => Some(if n < x { n } else\
    \ { x }),\n            };\n        }\n    }\n    (largest, smallest)", '    unimplemented!()',
  '    unimplemented!();', "    let mut lst_pos = Vec::new();\n    let mut lst_neg\
    \ = Vec::new();\n    let mut largest = None;\n    let mut smallest = None;\n \
    \   for i in lst {\n        if i > 0 {\n            lst_pos.push(i);\n       \
    \ } else if i < 0 {\n            lst_neg.push(i);\n        }\n    }\n    match\
    \ lst_pos.len() {\n        0 => {\n            smallest = None;\n        }\n \
    \       _ => {\n            smallest = Some(lst_pos.iter().min().unwrap().clone());\n\
    \        }\n    }\n    match lst_neg.len() {\n        0 => {\n            largest\
    \ = None;\n        }\n        _ => {\n            largest = Some(lst_neg.iter().max().unwrap().clone());\n\
    \        }\n    }\n    (largest, smallest)", '    unimplemented!();', '  unimplemented!()',
  "    let mut largest_negative: Option<isize> = None;\n    let mut smallest_positive:\
    \ Option<isize> = None;\n    for number in lst {\n        if number < 0 {\n  \
    \          match largest_negative {\n                None => largest_negative\
    \ = Some(number),\n                Some(value) => {\n                    if number\
    \ > value {\n                        largest_negative = Some(number);\n      \
    \              }\n                }\n            }\n        }\n        if number\
    \ > 0 {\n            match smallest_positive {\n                None => smallest_positive\
    \ = Some(number),\n                Some(value) => {\n                    if number\
    \ < value {\n                        smallest_positive = Some(number);\n     \
    \               }\n                }\n            }\n        }\n    }\n    (largest_negative,\
    \ smallest_positive)", '    unimplemented!()']
stop_tokens:
- "\n}"
