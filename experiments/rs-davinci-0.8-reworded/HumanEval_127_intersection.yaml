name: HumanEval_127_intersection
language: rs
prompt: "/// You are given two intervals,\n/// where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed\
  \ which means that the interval (start, end)\n/// includes both start and end.\n\
  /// For each given interval, it is assumed that its start is less or equal its end.\n\
  /// Your task is to determine whether the length of intersection of these two \n\
  /// intervals is a prime number.\n/// Example, the intersection of the intervals\
  \ (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n\
  /// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise,\
  \ return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n///\
  \ [input/output] samples:\n/// >>> intersection((1, 2), (2, 3))\n/// String::from(\"\
  NO\")\n/// >>> intersection((-1, 1), (0, 4))\n/// String::from(\"NO\")\n/// >>>\
  \ intersection((-3, -1), (-5, 5))\n/// String::from(\"YES\")\nfn intersection(interval1:\
  \ (isize, isize), interval2: (isize, isize)) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
  \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
  YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
  \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
  \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
  NO\"));\n}\n"
completions: ["    let (_, end1) = interval1;\n    let (start2, _) = interval2;\n\
    \    let result = if end1 < start2 {\n        0\n    } else {\n        end1 -\
    \ start2 + 1\n    };\n    let is_prime = is_prime(result);\n    if is_prime {\n\
    \        String::from(\"YES\")\n    } else {\n        String::from(\"NO\")\n \
    \   }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n   \
    \     return String::from(\"NO\");\n    }\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if end <= start {\n        return\
    \ String::from(\"NO\");\n    }\n    let n = end - start + 1;\n    for i in 2..(n\
    \ as f64).sqrt() as isize + 1 {\n        if n % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let (a1, b1) = interval1;\n\
    \    let (a2, b2) = interval2;\n    if b1 < a2 || b2 < a1 {\n        return String::from(\"\
    NO\");\n    }\n    let (i1, i2) = (max(a1, a2), min(b1, b2));\n    if is_prime(i2\
    \ - i1 + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let intersection = match (interval1, interval2) {\n        ((a, b),\
    \ (c, d)) if b < c || d < a => None,\n        ((a, b), (c, d)) => Some((a.max(c),\
    \ b.min(d))),\n    };\n    match intersection {\n        None => String::from(\"\
    NO\"),\n        Some((start, end)) => {\n            if end < start {\n      \
    \          String::from(\"NO\")\n            } else {\n                let length\
    \ = end - start + 1;\n                if is_prime(length) {\n                \
    \    String::from(\"YES\")\n                } else {\n                    String::from(\"\
    NO\")\n                }\n            }\n        }\n    }", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return String::from(\"\
    NO\");\n    }\n    let inter = (\n        cmp::max(interval1.0, interval2.0),\n\
    \        cmp::min(interval1.1, interval2.1),\n    );\n    if is_prime(inter.1\
    \ - inter.0 + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let mut res = (0, 0);\n    if interval1.0 <= interval2.0 && interval2.0\
    \ <= interval1.1 {\n        res.0 = interval2.0;\n    } else if interval2.0 <=\
    \ interval1.0 && interval1.0 <= interval2.1 {\n        res.0 = interval1.0;\n\
    \    }\n    if interval1.0 <= interval2.1 && interval2.1 <= interval1.1 {\n  \
    \      res.1 = interval2.1;\n    } else if interval2.0 <= interval1.1 && interval1.1\
    \ <= interval2.1 {\n        res.1 = interval1.1;\n    }\n    if res.0 == 0 &&\
    \ res.1 == 0 {\n        String::from(\"NO\")\n    } else {\n        if is_prime(res.1\
    \ - res.0) {\n            String::from(\"YES\")\n        } else {\n          \
    \  String::from(\"NO\")\n        }\n    }", "    let it_min = interval1.0.max(interval2.0);\n\
    \    let it_max = interval1.1.min(interval2.1);\n    if it_min > it_max {\n  \
    \      return String::from(\"NO\");\n    }\n    let mut it_len = (it_max - it_min)\
    \ + 1;\n    if it_len == 1 {\n        return String::from(\"YES\");\n    }\n \
    \   let mut i = 2;\n    loop {\n        if i * i > it_len {\n            return\
    \ String::from(\"YES\");\n        }\n        if it_len % i == 0 {\n          \
    \  return String::from(\"NO\");\n        }\n        i += 1;\n    }", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return String::from(\"\
    NO\");\n    }\n    let low = std::cmp::max(interval1.0, interval2.0);\n    let\
    \ high = std::cmp::min(interval1.1, interval2.1);\n    match (low..=high).count()\
    \ {\n        x if x <= 2 => String::from(\"NO\"),\n        x => {\n          \
    \  for i in 2..(x-1) {\n                if x % i == 0 {\n                    return\
    \ String::from(\"NO\");\n                }\n            }\n            String::from(\"\
    YES\")\n        }\n    }", "    // Check if the intervals intersect\n    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return String::from(\"\
    NO\");\n    }\n    // intersection starts at the maximum of the two intervals'\
    \ minimums\n    let start = std::cmp::max(interval1.0, interval2.0);\n    // intersection\
    \ ends at the minimum of the two intervals' maximums\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    // find the length of the intersection\n    let length =\
    \ end - start + 1;\n    // check if the length is prime\n    if length < 2 {\n\
    \        return String::from(\"NO\");\n    }\n    let mut factor = 2;\n    while\
    \ factor * factor <= length {\n        if length % factor == 0 {\n           \
    \ return String::from(\"NO\");\n        }\n        factor += 1;\n    }\n    String::from(\"\
    YES\")", "    let mut sorted = [interval1, interval2];\n    sorted.sort_by(|&(a,\
    \ b), &(c, d)| a.cmp(&c));\n    let &(a, b) = sorted.get(0).unwrap();\n    let\
    \ &(c, d) = sorted.get(1).unwrap();\n    if a > d || b < c {\n        return String::from(\"\
    NO\");\n    }\n    let i = (c, d).cmp(&(a, b));\n    let k = match i {\n     \
    \   Ordering::Equal => (a, b),\n        Ordering::Less => (c, b),\n        Ordering::Greater\
    \ => (a, d),\n    };\n    let g = k.1 - k.0;\n    let mut is_prime = true;\n \
    \   for j in 2..g {\n        if g % j == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime && g > 1 {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (interval1_start,\
    \ interval1_end) = interval1;\n    let (interval2_start, interval2_end) = interval2;\n\
    \    if interval1_start >= interval2_end || interval2_start >= interval1_end {\n\
    \        String::from(\"NO\")\n    } else {\n        let intersection_start =\
    \ if interval1_start > interval2_start {\n            interval1_start\n      \
    \  } else {\n            interval2_start\n        };\n        let intersection_end\
    \ = if interval1_end < interval2_end {\n            interval1_end\n        } else\
    \ {\n            interval2_end\n        };\n        if is_prime(intersection_end\
    \ - intersection_start) {\n            String::from(\"YES\")\n        } else {\n\
    \            String::from(\"NO\")\n        }\n    }", "    let mut start = interval1.0;\n\
    \    let mut end = interval1.1;\n    if interval2.0 > start {\n        start =\
    \ interval2.0;\n    }\n    if interval2.1 < end {\n        end = interval2.1;\n\
    \    }\n    if start >= end {\n        return String::from(\"NO\");\n    }\n \
    \   let mut counter = 0;\n    for i in start..end {\n        if i == 1 {\n   \
    \         continue;\n        }\n        let mut is_prime = true;\n        for\
    \ j in 2..i {\n            if i % j == 0 {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if is_prime {\n   \
    \         counter += 1;\n        }\n    }\n    return if counter == 0 {\n    \
    \    String::from(\"NO\")\n    } else {\n        String::from(\"YES\")\n    };",
  "    let (mut start, mut end) = (0, 0);\n    if interval1.0 > interval2.0 {\n  \
    \      start = interval1.0;\n    } else {\n        start = interval2.0;\n    }\n\
    \    if interval1.1 < interval2.1 {\n        end = interval1.1;\n    } else {\n\
    \        end = interval2.1;\n    }\n    let len = end - start;\n    if start >\
    \ end {\n        return String::from(\"NO\");\n    }\n    if is_prime(len) {\n\
    \        return String::from(\"YES\");\n    }\n    String::from(\"NO\")", "  \
    \  if interval1.0 < interval2.0 {\n        if interval1.1 < interval2.0 {\n  \
    \          return String::from(\"NO\");\n        }\n        if interval1.1 < interval2.1\
    \ {\n            return is_prime(interval1.1 - interval2.0 + 1);\n        }\n\
    \        return is_prime(interval2.1 - interval2.0 + 1);\n    } else if interval1.0\
    \ == interval2.0 {\n        if interval1.1 < interval2.1 {\n            return\
    \ is_prime(interval1.1 - interval1.0 + 1);\n        }\n        return is_prime(interval2.1\
    \ - interval2.0 + 1);\n    } else {\n        if interval2.1 < interval1.0 {\n\
    \            return String::from(\"NO\");\n        }\n        if interval2.1 <\
    \ interval1.1 {\n            return is_prime(interval2.1 - interval1.0 + 1);\n\
    \        }\n        return is_prime(interval1.1 - interval1.0 + 1);\n    }", " \
    \   let inter = (interval1.0..interval1.1).intersection(&(interval2.0..interval2.1));\n\
    \    match inter {\n        None => String::from(\"NO\"),\n        Some(s) =>\
    \ {\n            let mut is_prime = true;\n            for i in 2..(s.len() -\
    \ 1) {\n                if s.len() % i == 0 {\n                    is_prime =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       if is_prime {\n                String::from(\"YES\")\n            } else\
    \ {\n                String::from(\"NO\")\n            }\n        }\n    }", " \
    \   if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ String::from(\"NO\");\n    }\n    let mut min = interval1.0;\n    let mut max\
    \ = interval1.1;\n    if interval2.0 > min {\n        min = interval2.0;\n   \
    \ }\n    if interval2.1 < max {\n        max = interval2.1;\n    }\n    let length\
    \ = (max - min + 1) as usize;\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    if\
    \ primes.contains(&length) {\n        return String::from(\"YES\");\n    }\n \
    \   String::from(\"NO\")", "    let int1_min = interval1.0.min(interval1.1);\n\
    \    let int1_max = interval1.0.max(interval1.1);\n    let int2_min = interval2.0.min(interval2.1);\n\
    \    let int2_max = interval2.0.max(interval2.1);\n    let int1_range = int1_max\
    \ - int1_min;\n    let int2_range = int2_max - int2_min;\n    if int1_range ==\
    \ 0 || int2_range == 0 {\n        return String::from(\"NO\");\n    }\n    if\
    \ int1_max < int2_min || int2_max < int1_min {\n        return String::from(\"\
    NO\");\n    }\n    let int_start = int1_min.max(int2_min);\n    let int_end =\
    \ int1_max.min(int2_max);\n    let int_range = int_end - int_start;\n    let mut\
    \ is_prime = true;\n    for i in 2..(int_range - 1) {\n        if int_range %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let start = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0\
    \ };\n    let end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    if start > end {\n        return String::from(\"NO\");\n    }\n    let\
    \ length = end - start + 1;\n    match length {\n        1 => String::from(\"\
    NO\"),\n        2 => String::from(\"YES\"),\n        3 => String::from(\"YES\"\
    ),\n        5 => String::from(\"YES\"),\n        7 => String::from(\"YES\"),\n\
    \        _ => {\n            if length % 2 == 0 || length % 3 == 0 || length %\
    \ 5 == 0 || length % 7 == 0 {\n                String::from(\"NO\")\n        \
    \    } else {\n                String::from(\"YES\")\n            }\n        }\n\
    \    }", "    let s1 = interval1.0;\n    let e1 = interval1.1;\n    let s2 = interval2.0;\n\
    \    let e2 = interval2.1;\n    let mut start = std::cmp::max(s1, s2);\n    let\
    \ mut end = std::cmp::min(e1, e2);\n    // no intersection\n    if end < start\
    \ {\n        return String::from(\"NO\");\n    }\n    let mut res = true;\n  \
    \  while start <= end {\n        if start < 2 {\n            start += 1;\n   \
    \         continue;\n        }\n        res = true;\n        for i in 2..start\
    \ {\n            if start % i == 0 {\n                res = false;\n         \
    \       break;\n            }\n        }\n        if res {\n            break;\n\
    \        }\n        start += 1;\n    }\n    if res {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }", "    let (mut l, mut\
    \ r) = (interval1.0, interval1.1);\n    l = l.max(interval2.0);\n    r = r.min(interval2.1);\n\
    \    if l > r {\n        return String::from(\"NO\");\n    }\n    match (l - r)\
    \ as usize {\n        0 | 1 => String::from(\"NO\"),\n        n => {\n       \
    \     if is_prime(n) {\n                String::from(\"YES\")\n            } else\
    \ {\n                String::from(\"NO\")\n            }\n        }\n    }", " \
    \   if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ String::from(\"NO\");\n    }\n    let (left, right) = if interval1.0 < interval2.0\
    \ {\n        (interval2.0, interval1.1)\n    } else {\n        (interval1.0, interval2.1)\n\
    \    };\n    let length = right - left + 1;\n    if length <= 1 {\n        return\
    \ String::from(\"NO\");\n    }\n    if length == 2 {\n        return String::from(\"\
    YES\");\n    }\n    for factor in 2..length {\n        if length % factor == 0\
    \ {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let mut inter: (isize, isize) = (0, 0);\n    let is_intsect = if\
    \ interval1.0 < interval2.0 {\n        if interval1.1 < interval2.0 {\n      \
    \      return String::from(\"NO\");\n        }\n        inter = (interval2.0,\
    \ cmp::min(interval1.1, interval2.1));\n    } else {\n        if interval2.1 <\
    \ interval1.0 {\n            return String::from(\"NO\");\n        }\n       \
    \ inter = (interval1.0, cmp::min(interval1.1, interval2.1));\n    };\n    let\
    \ diff = inter.1 - inter.0;\n    for i in 2..diff {\n        if diff % i == 0\
    \ {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let (i1_start, i1_end) = interval1;\n    let (i2_start, i2_end)\
    \ = interval2;\n    if i1_start > i2_end || i2_start > i1_end {\n        return\
    \ String::from(\"NO\");\n    }\n    let start = i1_start.max(i2_start);\n    let\
    \ end = i1_end.min(i2_end);\n    let diff = end - start;\n    let is_prime = (2..diff).all(|x|\
    \ diff % x != 0);\n    if is_prime {\n        String::from(\"YES\")\n    } else\
    \ {\n        String::from(\"NO\")\n    }", "    if interval1.0 < interval2.0 {\n\
    \        intersection(interval2, interval1)\n    } else if interval1.0 <= interval2.1\
    \ {\n        (interval1.0 - interval2.1).abs().is_prime().to_string()\n    } else\
    \ {\n        String::from(\"NO\")\n    }", "    let mut start = interval1.0;\n\
    \    let mut end = interval1.1;\n    if interval2.0 > start {\n        start =\
    \ interval2.0;\n    }\n    if interval2.1 < end {\n        end = interval2.1;\n\
    \    }\n    if start >= end {\n        return String::from(\"NO\");\n    }\n \
    \   let len = end - start + 1;\n    let sqrt = (len as f64).sqrt() as isize;\n\
    \    for i in 2..sqrt {\n        if len % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let (i1s, i1e) = interval1;\n\
    \    let (i2s, i2e) = interval2;\n    if (i1s > i2e) || (i2s > i1e) {\n      \
    \  return String::from(\"NO\");\n    }\n    let mut start = i1s;\n    let mut\
    \ end = i1e;\n    if i2s > i1s {\n        start = i2s;\n    }\n    if i2e < i1e\
    \ {\n        end = i2e;\n    }\n    if is_prime(end - start + 1) {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    match (interval1,\
    \ interval2) {\n        ((x1, y1), (x2, y2)) if x1 <= x2 && y1 >= x2 && y1 <=\
    \ y2 => {\n            is_prime(y1 - x2 + 1)\n        },\n        ((x1, y1), (x2,\
    \ y2)) if x1 >= x2 && x1 <= y2 && y1 >= y2 => {\n            is_prime(y2 - x1\
    \ + 1)\n        },\n        ((x1, y1), (x2, y2)) if x1 >= x2 && y1 <= y2 => {\n\
    \            is_prime(y1 - x1 + 1)\n        },\n        ((x1, y1), (x2, y2)) if\
    \ x1 <= x2 && y1 >= y2 => {\n            is_prime(y2 - x2 + 1)\n        },\n \
    \       _ => String::from(\"NO\"),\n    }", "    let (a1, b1) = interval1;\n \
    \   let (a2, b2) = interval2;\n    if a1 > b1 || a2 > b2 {\n        return String::from(\"\
    NO\");\n    }\n    let (s, e) = (max(a1, a2), min(b1, b2));\n    let interval\
    \ = (s, e);\n    if interval.0 > interval.1 {\n        return String::from(\"\
    NO\");\n    }\n    let len = interval.1 - interval.0 + 1;\n    match is_prime(len)\
    \ {\n        true => String::from(\"YES\"),\n        false => String::from(\"\
    NO\"),\n    }", "    let intersection = if interval1.0 > interval2.0 {\n     \
    \   (interval1.0, interval2.1)\n    } else {\n        (interval2.0, interval1.1)\n\
    \    };\n    if is_prime(intersection.1 - intersection.0) {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }", "    let i1 = interval1.0..=interval1.1;\n\
    \    let i2 = interval2.0..=interval2.1;\n    let i = i1.intersection(&i2);\n\
    \    match i {\n        None => \"NO\".to_string(),\n        Some(intersection)\
    \ => {\n            let distance = intersection.end - intersection.start;\n  \
    \          is_prime(distance)\n        }\n    }", "    let (interval1_start, interval1_end)\
    \ = interval1;\n    let (interval2_start, interval2_end) = interval2;\n    if\
    \ interval1_start > interval1_end || interval2_start > interval2_end {\n     \
    \   return String::from(\"NO\");\n    }\n    if interval1_end < interval2_start\
    \ || interval2_end < interval1_start {\n        return String::from(\"NO\");\n\
    \    }\n    let (new_start, new_end) = \n        if interval1_start > interval2_start\
    \ {\n            (interval1_start, if interval1_end < interval2_end { interval1_end\
    \ } else { interval2_end })\n        } else {\n            (interval2_start, if\
    \ interval2_end < interval1_end { interval2_end } else { interval1_end })\n  \
    \      };\n    let new_length = (new_end - new_start + 1) as usize;\n    if new_length\
    \ == 1 {\n        return String::from(\"NO\");\n    }\n    let mut prime = true;\n\
    \    for i in 2..new_length {\n        if new_length % i == 0 {\n            prime\
    \ = false;\n            break;\n        }\n    }\n    if prime {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (a, b) =\
    \ interval1;\n    let (c, d) = interval2;\n    if a > b || c > d {\n        return\
    \ String::from(\"NO\");\n    }\n    if a > d || b < c {\n        return String::from(\"\
    NO\");\n    }\n    let m = max(a, c);\n    let n = min(b, d);\n    if m == n {\n\
    \        String::from(\"YES\")\n    } else {\n        String::from(\"NO\")\n \
    \   }", "    let (x1, y1) = interval1;\n    let (x2, y2) = interval2;\n    let\
    \ a = x1.max(x2);\n    let b = y1.min(y2);\n    if a >= b {\n        return String::from(\"\
    NO\");\n    }\n    let len = b - a;\n    if is_prime(len) {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    if interval1.0 > interval2.1 ||\
    \ interval2.0 > interval1.1 {\n        return String::from(\"NO\");\n    }\n \
    \   let start = if interval1.0 < interval2.0 {\n        interval2.0\n    } else\
    \ {\n        interval1.0\n    };\n    let end = if interval1.1 < interval2.1 {\n\
    \        interval1.1\n    } else {\n        interval2.1\n    };\n    let len =\
    \ (end - start) + 1;\n    if len == 1 {\n        return String::from(\"NO\");\n\
    \    }\n    for i in 2..(len / 2) {\n        if len % i == 0 {\n            return\
    \ String::from(\"NO\");\n        }\n    }\n    String::from(\"YES\")", "    let\
    \ (mut left, mut right) = (interval1.0, interval1.1);\n    let (mut left2, mut\
    \ right2) = (interval2.0, interval2.1);\n    if left > right {\n        ::std::mem::swap(&mut\
    \ left, &mut right);\n    }\n    if left2 > right2 {\n        ::std::mem::swap(&mut\
    \ left2, &mut right2);\n    }\n    if left <= left2 && right2 <= right {\n   \
    \     if left2 <= right2 {\n            is_prime(right2 - left2 + 1)\n       \
    \ } else {\n            false\n        }\n    } else if left2 <= left && right\
    \ <= right2 {\n        if left <= right {\n            is_prime(right - left +\
    \ 1)\n        } else {\n            false\n        }\n    } else {\n        false\n\
    \    }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n  \
    \      return String::from(\"NO\");\n    }\n    let mut intersection = (interval1.0,\
    \ interval1.1);\n    if interval1.0 < interval2.0 {\n        intersection.0 =\
    \ interval2.0;\n    }\n    if interval1.1 > interval2.1 {\n        intersection.1\
    \ = interval2.1;\n    }\n    let diff = (intersection.1 - intersection.0) + 1;\n\
    \    for i in 2..diff {\n        if diff % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 >= end2 ||\
    \ start2 >= end1 {\n        return String::from(\"NO\");\n    }\n    if end1 <\
    \ end2 {\n        return is_prime(end1 - start2 + 1);\n    }\n    is_prime(end2\
    \ - start1 + 1)", "    if interval1.0 <= interval2.1 && interval2.0 <= interval1.1\
    \ {\n        if is_prime((interval2.0..=interval1.1).count() as isize) {\n   \
    \         return String::from(\"YES\");\n        }\n    }\n    String::from(\"\
    NO\")", "    let mut intersection = (0, 0);\n    // Check if intervals intersect\n\
    \    if interval1.0 <= interval2.1 && interval2.0 <= interval1.1 {\n        //\
    \ Determine start and end of the intersection\n        intersection.0 = interval1.0.max(interval2.0);\n\
    \        intersection.1 = interval1.1.min(interval2.1);\n    } else {\n      \
    \  return String::from(\"NO\");\n    }\n    let length = intersection.1 - intersection.0\
    \ + 1;\n    // Check if the length is a prime number\n    if length > 1 && (2..(length\
    \ as f64).sqrt() as isize + 1).all(|i| length % i != 0) {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }", "    let (i1_start,\
    \ i1_end) = interval1;\n    let (i2_start, i2_end) = interval2;\n    if i1_start\
    \ > i2_end || i2_start > i1_end {\n        return String::from(\"NO\");\n    }\n\
    \    let start = i1_start.max(i2_start);\n    let end = i1_end.min(i2_end);\n\
    \    let length = end - start + 1;\n    if is_prime(length) {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (mut a, mut\
    \ b) = (interval1.0, interval1.1);\n    let (mut c, mut d) = (interval2.0, interval2.1);\n\
    \    if a > b {\n        mem::swap(&mut a, &mut b);\n    }\n    if c > d {\n \
    \       mem::swap(&mut c, &mut d);\n    }\n    let (mut start, mut end) = (a,\
    \ b);\n    if c > a {\n        start = c;\n    }\n    if d < b {\n        end\
    \ = d;\n    }\n    if start <= end {\n        return format!(\"{}\", is_prime(end\
    \ - start));\n    }\n    return String::from(\"NO\");", "    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    if i1_start > i2_end\
    \ || i2_start > i1_end {\n        return String::from(\"NO\");\n    }\n    let\
    \ mut value = 0;\n    if i1_start > i2_start {\n        value = i1_start - i2_start;\n\
    \    } else {\n        value = i2_start - i1_start;\n    }\n    if is_prime(value\
    \ as u64) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let mut result = String::from(\"NO\");\n    let (start, end) = (interval1.0,\
    \ interval1.1);\n    let (start2, end2) = (interval2.0, interval2.1);\n    let\
    \ mut overlap = Vec::new();\n    if start <= start2 && start2 <= end {\n     \
    \   overlap.push(start2);\n    }\n    if start <= end2 && end2 <= end {\n    \
    \    overlap.push(end2);\n    }\n    if start2 <= start && start <= end2 {\n \
    \       overlap.push(start);\n    }\n    if start2 <= end && end <= end2 {\n \
    \       overlap.push(end);\n    }\n    if overlap.len() > 0 {\n        if overlap.len()\
    \ == 1 {\n            if overlap[0] == 1 {\n                result = String::from(\"\
    YES\");\n            }\n        } else {\n            overlap.sort();\n      \
    \      let dif = overlap[1] - overlap[0];\n            if is_prime(dif) {\n  \
    \              result = String::from(\"YES\");\n            }\n        }\n   \
    \ }\n    result", "    let (mut start, mut end) = (0, 0);\n    if interval1.0\
    \ <= interval2.0 {\n        start = interval2.0;\n    } else {\n        start\
    \ = interval1.0;\n    }\n    if interval1.1 <= interval2.1 {\n        end = interval1.1;\n\
    \    } else {\n        end = interval2.1;\n    }\n    if start > end {\n     \
    \   return String::from(\"NO\");\n    }\n    if end - start == 1 {\n        return\
    \ String::from(\"YES\");\n    }\n    let mut result = false;\n    for i in 2..end\
    \ {\n        if end % i == 0 {\n            result = true;\n            break;\n\
    \        }\n    }\n    if result {\n        return String::from(\"NO\");\n   \
    \ }\n    String::from(\"YES\")", "    let mut inter: (isize, isize) = (0, 0);\n\
    \    if interval1.0 < interval2.0 {\n        inter.0 = interval2.0;\n    } else\
    \ {\n        inter.0 = interval1.0;\n    }\n    if interval1.1 < interval2.1 {\n\
    \        inter.1 = interval1.1;\n    } else {\n        inter.1 = interval2.1;\n\
    \    }\n    if inter.0 >= inter.1 {\n        return String::from(\"NO\");\n  \
    \  }\n    let mut is_prime = true;\n    let mut i = 2;\n    while i < inter.1\
    \ - inter.0 + 1 {\n        if inter.1 - inter.0 + 1 % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n        i += 1;\n    }\n    if is_prime\
    \ {\n        return String::from(\"YES\");\n    } else {\n        return String::from(\"\
    NO\");\n    }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1\
    \ {\n        return String::from(\"NO\");\n    }\n    let left = if interval1.0\
    \ > interval2.0 { interval1.0 } else { interval2.0 };\n    let right = if interval1.1\
    \ < interval2.1 { interval1.1 } else { interval2.1 };\n    let len = (right -\
    \ left + 1) as usize;\n    if len == 1 {\n        return String::from(\"NO\");\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..len {\n        if len %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let range1 = interval1.0..=interval1.1;\n    let range2 = interval2.0..=interval2.1;\n\
    \    let difference = range1.symmetric_difference(&range2);\n    let distance\
    \ = difference.collect::<Vec<_>>();\n    let start = std::cmp::min(distance[0],\
    \ distance[1]);\n    let end = std::cmp::max(distance[0], distance[1]);\n    if\
    \ start == end {\n        String::from(\"NO\")\n    } else {\n        let length\
    \ = end - start - 1;\n        if prime(length) {\n            String::from(\"\
    YES\")\n        } else {\n            String::from(\"NO\")\n        }\n    }",
  "    let (int1_start, int1_end) = interval1;\n    let (int2_start, int2_end) = interval2;\n\
    \    let max_start = isize::max(int1_start, int2_start);\n    let min_end = isize::min(int1_end,\
    \ int2_end);\n    if max_start > min_end {\n        return String::from(\"NO\"\
    );\n    }\n    if is_prime(min_end - max_start + 1) {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let intersection_start = cmp::max(start1,\
    \ start2);\n    let intersection_end = cmp::min(end1, end2);\n    let len = intersection_end\
    \ - intersection_start;\n    if len <= 0 {\n        String::from(\"NO\")\n   \
    \ } else {\n        let mut is_prime = true;\n        for divisor in 2..len {\n\
    \            if len % divisor == 0 {\n                is_prime = false;\n    \
    \            break;\n            }\n        }\n        if is_prime {\n       \
    \     String::from(\"YES\")\n        } else {\n            String::from(\"NO\"\
    )\n        }\n    }", "    let (start1, end1) = interval1;\n    let (start2, end2)\
    \ = interval2;\n    if start1 >= end2 || start2 >= end1 {\n        return String::from(\"\
    NO\");\n    }\n    let l = min(end1, end2) - max(start1, start2);\n    if is_prime(l)\
    \ {\n        return String::from(\"YES\");\n    }\n    String::from(\"NO\")",
  "    let (mut left, mut right) = (interval1.0, interval1.1);\n    if left > right\
    \ {\n        std::mem::swap(&mut left, &mut right);\n    }\n    if left <= interval2.0\
    \ && interval2.0 <= right {\n        left = interval2.0;\n    }\n    if left <=\
    \ interval2.1 && interval2.1 <= right {\n        right = interval2.1;\n    }\n\
    \    if left > right {\n        return String::from(\"NO\");\n    }\n    let diff\
    \ = right - left + 1;\n    if diff < 2 {\n        return String::from(\"NO\");\n\
    \    }\n    if diff == 2 {\n        return String::from(\"YES\");\n    }\n   \
    \ let mut is_prime = true;\n    for i in 2..diff {\n        if diff % i == 0 {\n\
    \            is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        String::from(\"YES\")\n    } else {\n        String::from(\"NO\"\
    )\n    }", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    if end1 < start2 || end2 < start1 {\n        return String::from(\"NO\");\n\
    \    }\n    let start_intersection = start1.max(start2);\n    let end_intersection\
    \ = end1.min(end2);\n    let num = (end_intersection - start_intersection) + 1;\n\
    \    if is_prime(num) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let (max_left, min_right) = (interval1.0.max(interval2.0), interval1.1.min(interval2.1));\n\
    \    if max_left >= min_right { return String::from(\"NO\"); }\n    let diff =\
    \ min_right - max_left;\n    if diff == 1 { return String::from(\"YES\"); }\n\
    \    (2..diff).all(|x| diff % x != 0)\n        .then_some(String::from(\"YES\"\
    ))\n        .unwrap_or(String::from(\"NO\"))", "    if interval1.0 < interval2.0\
    \ {\n        intersection(interval2, interval1)\n    } else if interval1.0 > interval2.1\
    \ {\n        String::from(\"NO\")\n    } else {\n        let length = interval1.0\
    \ - interval2.1;\n        is_prime(length)\n    }", "    let mut res = String::from(\"\
    NO\");\n    let mut max_i1 = interval1.0;\n    let mut min_i2 = interval2.1;\n\
    \    if max_i1 < interval1.1 {\n        max_i1 = interval1.1;\n    }\n    if min_i2\
    \ > interval2.0 {\n        min_i2 = interval2.0;\n    }\n    if max_i1 >= min_i2\
    \ {\n        let len = min_i2 - max_i1 + 1;\n        if is_prime(len) {\n    \
    \        res = String::from(\"YES\");\n        }\n    }\n    res", "    match\
    \ (interval1, interval2) {\n        ((a, b), (c, d)) if a > b => intersection((b,\
    \ a), (c, d)),\n        ((a, b), (c, d)) if c > d => intersection((a, b), (d,\
    \ c)),\n        ((a, b), (c, d)) if a > d || b < c => String::from(\"NO\"),\n\
    \        ((a, b), (c, d)) => {\n            let intersect = (a.max(c), b.min(d));\n\
    \            if is_prime(&(intersect.1 - intersect.0 + 1)) {\n               \
    \ String::from(\"YES\")\n            } else {\n                String::from(\"\
    NO\")\n            }\n        }\n    }", "    let intervals = vec![interval1,\
    \ interval2];\n    let mut min = ::std::isize::MAX;\n    let mut max = ::std::isize::MIN;\n\
    \    for interval in intervals {\n        if interval.0 > interval.1 {\n     \
    \       return String::from(\"NO\");\n        }\n        if interval.0 < min {\n\
    \            min = interval.0;\n        }\n        if interval.1 > max {\n   \
    \         max = interval.1;\n        }\n    }\n    if min > max {\n        return\
    \ String::from(\"NO\");\n    }\n    if min == max {\n        if is_prime(min)\
    \ {\n            return String::from(\"YES\");\n        } else {\n           \
    \ return String::from(\"NO\");\n        }\n    }\n    if is_prime(max - min) {\n\
    \        return String::from(\"YES\");\n    } else {\n        return String::from(\"\
    NO\");\n    }", "    let (start1, end1) = interval1;\n    let (start2, end2) =\
    \ interval2;\n    if end1 < start2 || end2 < start1 {\n        return String::from(\"\
    NO\");\n    }\n    let mut start = cmp::max(start1, start2);\n    let mut end\
    \ = cmp::min(end1, end2);\n    if end < start {\n        end = start;\n    }\n\
    \    let len = end - start + 1;\n    if len > 2 && len % 2 == 0 {\n        return\
    \ String::from(\"NO\");\n    }\n    for i in 2..len {\n        if len % i == 0\
    \ {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let s1 = interval1.0;\n    let e1 = interval1.1;\n    let s2 = interval2.0;\n\
    \    let e2 = interval2.1;\n    let s = if s1 > s2 { s1 } else { s2 };\n    let\
    \ e = if e1 < e2 { e1 } else { e2 };\n    if s > e {\n        return String::from(\"\
    NO\");\n    }\n    if s == e {\n        if s == 1 {\n            return String::from(\"\
    YES\");\n        }\n        if s == 2 {\n            return String::from(\"YES\"\
    );\n        }\n        if s == 3 {\n            return String::from(\"YES\");\n\
    \        }\n        if s == 5 {\n            return String::from(\"YES\");\n \
    \       }\n        if s == 7 {\n            return String::from(\"YES\");\n  \
    \      }\n        return String::from(\"NO\");\n    }\n    if s - e == 1 {\n \
    \       return String::from(\"YES\");\n    }\n    if s - e == 2 {\n        return\
    \ String::from(\"YES\");\n    }\n    if s - e == 3 {\n        return String::from(\"\
    YES\");\n    }\n    if s - e == 5 {\n        return String::from(\"YES\");\n \
    \   }\n    if s - e == 7 {\n        return String::from(\"YES\");\n    }\n   \
    \ String::from(\"NO\")", "    // find the intersection of the two intervals\n\
    \    // return a None if no intersection\n    fn int_intersect(i1: (isize, isize),\
    \ i2: (isize, isize)) -> Option<(isize, isize)> {\n        let (i1_start, i1_end)\
    \ = i1;\n        let (i2_start, i2_end) = i2;\n        if i1_start > i2_end ||\
    \ i2_start > i1_end {\n            return None;\n        }\n        let (start,\
    \ end) = if i1_start > i2_start {\n            (i1_start, i1_end)\n        } else\
    \ {\n            (i2_start, i2_end)\n        };\n        if start > end {\n  \
    \          return None;\n        }\n        Some((start, end))\n    }\n    //\
    \ check if a number is prime\n    fn is_prime(n: isize) -> bool {\n        if\
    \ n <= 1 {\n            return false;\n        }\n        if n <= 3 {\n      \
    \      return true;\n        }\n        if n % 2 == 0 || n % 3 == 0 {\n      \
    \      return false;\n        }\n        let mut i = 5;\n        while i * i <=\
    \ n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return\
    \ false;\n            }\n            i += 6;\n        }\n        true\n    }\n\
    \    match int_intersect(interval1, interval2) {\n        Some((start, end)) =>\
    \ if is_prime(end - start + 1) {\n            \"YES\".to_string()\n        } else\
    \ {\n            \"NO\".to_string()\n        },\n        None => \"NO\".to_string(),\n\
    \    }", "    let (mut start, mut end) = match (interval1.0, interval1.1, interval2.0,\
    \ interval2.1) {\n        (s1, e1, s2, e2) if s1 < s2 && e1 < s2 => return String::from(\"\
    NO\"),\n        (s1, e1, s2, e2) if s1 > e2 && s1 > e1 => return String::from(\"\
    NO\"),\n        (s1, e1, s2, e2) if s1 < s2 && e1 > s2 && e1 < e2 => (s2, e1),\n\
    \        (s1, e1, s2, e2) if s1 < s2 && e1 > e2 => (s2, e2),\n        (s1, e1,\
    \ s2, e2) if s1 > s2 && s1 < e2 && e1 > e2 => (s1, e2),\n        (s1, e1, s2,\
    \ e2) if s1 > s2 && s1 < e2 && e1 < e2 => (s1, e1),\n        (s1, e1, s2, e2)\
    \ if s1 > s2 && s1 > e2 => (s1, e1),\n        _ => unreachable!(),\n    };\n \
    \   if start == end {\n        return match start {\n            2 | 3 | 5 | 7\
    \ => String::from(\"YES\"),\n            _ => String::from(\"NO\"),\n        };\n\
    \    }\n    for k in 2..end {\n        if start % k == 0 || end % k == 0 {\n \
    \           return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let (a, b) = interval1;\n    let (c, d) = interval2;\n    if a >\
    \ b || c > d {\n        return String::from(\"NO\");\n    }\n    let max_start\
    \ = if a > c { a } else { c };\n    let min_end = if b < d { b } else { d };\n\
    \    if max_start > min_end {\n        return String::from(\"NO\");\n    }\n \
    \   if primes::is_prime(min_end - max_start + 1) {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    let (first_start, first_end) =\
    \ interval1;\n    let (second_start, second_end) = interval2;\n    let start =\
    \ if first_start >= second_start {\n        first_start\n    } else {\n      \
    \  second_start\n    };\n    let end = if first_end <= second_end {\n        first_end\n\
    \    } else {\n        second_end\n    };\n    if start > end {\n        return\
    \ String::from(\"NO\");\n    }\n    if is_prime(end - start + 1) {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (a, b) =\
    \ interval1;\n    let (c, d) = interval2;\n    let mn = std::cmp::max(a, c);\n\
    \    let mx = std::cmp::min(b, d);\n    if mn <= mx {\n        is_prime(mx - mn\
    \ + 1)\n    } else {\n        String::from(\"NO\")\n    }", "    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    let (start, end)\
    \ = (max(start1, start2), min(end1, end2));\n    if start >= end {\n        return\
    \ String::from(\"NO\");\n    }\n    let length = end - start + 1;\n    let prime\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    if prime.contains(&length) {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    let (int1_start, int1_end) = interval1;\n\
    \    let (int2_start, int2_end) = interval2;\n    let mut max_start = int1_start;\n\
    \    let mut min_end = int1_end;\n    if int2_start > max_start {\n        max_start\
    \ = int2_start;\n    }\n    if int2_end < min_end {\n        min_end = int2_end;\n\
    \    }\n    if max_start <= min_end {\n        let length = min_end - max_start\
    \ + 1;\n        if length < 2 {\n            return String::from(\"NO\");\n  \
    \      }\n        let mut prime = true;\n        for i in 2..(length as f64).sqrt()\
    \ as isize + 1 {\n            if length % i == 0 {\n                prime = false;\n\
    \                break;\n            }\n        }\n        if prime {\n      \
    \      return String::from(\"YES\");\n        }\n    }\n    String::from(\"NO\"\
    )", "    if interval1.0 >= interval2.1 || interval2.0 >= interval1.1 {\n     \
    \   return String::from(\"NO\");\n    }\n    let len = if interval1.0 < interval2.0\
    \ {\n        interval2.0 - interval1.1\n    } else {\n        interval1.0 - interval2.1\n\
    \    };\n    if len == 1 {\n        return String::from(\"NO\");\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let a = cmp::max(interval1.0,\
    \ interval2.0);\n    let b = cmp::min(interval1.1, interval2.1);\n    let c =\
    \ b - a;\n    if c < 0 {\n        return String::from(\"NO\");\n    }\n    return\
    \ if primes::is_prime(c as usize) {\n        String::from(\"YES\")\n    } else\
    \ {\n        String::from(\"NO\")\n    };", "    let (mut x1, mut x2) = (interval1.0,\
    \ interval1.1);\n    let (mut y1, mut y2) = (interval2.0, interval2.1);\n    if\
    \ x1 > x2 {\n        ::std::mem::swap(&mut x1, &mut x2);\n    }\n    if y1 > y2\
    \ {\n        ::std::mem::swap(&mut y1, &mut y2);\n    }\n    let mut s = x2;\n\
    \    let mut e = y1;\n    if y2 < x2 {\n        s = y2;\n    }\n    if x1 > y1\
    \ {\n        e = x1;\n    }\n    if s > e {\n        return String::from(\"NO\"\
    );\n    }\n    if is_prime(s - e + 1) {\n        return String::from(\"YES\");\n\
    \    }\n    String::from(\"NO\")", "    let min = interval1.0.max(interval2.0);\n\
    \    let max = interval1.1.min(interval2.1);\n    if min <= max {\n        if\
    \ is_prime(max - min + 1) {\n            return String::from(\"YES\");\n     \
    \   }\n    }\n    String::from(\"NO\")", "    let (mut start, mut end) = (0, 0);\n\
    \    if interval1.0 > interval2.0 {\n        start = interval1.0;\n    } else\
    \ {\n        start = interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n\
    \        end = interval1.1;\n    } else {\n        end = interval2.1;\n    }\n\
    \    if start > end {\n        return String::from(\"NO\");\n    }\n    let mut\
    \ i = 2;\n    while i < end - start {\n        if (end - start) % i == 0 {\n \
    \           return String::from(\"NO\");\n        }\n        i += 1;\n    }\n\
    \    String::from(\"YES\")", "    let start = max(interval1.0, interval2.0);\n\
    \    let end = min(interval1.1, interval2.1);\n    let n = end - start + 1;\n\
    \    let is_prime = is_prime(n);\n    if is_prime && n > 0 {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }", "    let mut start\
    \ = std::cmp::max(interval1.0, interval2.0);\n    let mut end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return String::from(\"NO\");\n\
    \    }\n    if (start % 2 == 0 && end - start >= 1) || end - start >= 2 {\n  \
    \      return String::from(\"NO\");\n    }\n    for i in 3..end+1 {\n        if\
    \ i*i > end {\n            break;\n        }\n        if start % i == 0 || end\
    \ % i == 0 {\n            return String::from(\"NO\");\n        }\n    }\n   \
    \ String::from(\"YES\")", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end1 || start2 > end2 {\n        return\
    \ String::from(\"NO\");\n    }\n    let mut new_start = std::cmp::max(start1,\
    \ start2);\n    let mut new_end = std::cmp::min(end1, end2);\n    if new_start\
    \ > new_end {\n        return String::from(\"NO\");\n    }\n    let mut num =\
    \ 0;\n    while new_start <= new_end {\n        num += 1;\n        new_start +=\
    \ 1;\n    }\n    for i in 2..num + 1 {\n        if num % i == 0 && i != num {\n\
    \            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let intersection = match (interval1, interval2) {\n        ((is1,\
    \ ie1), (is2, ie2)) if ie1 < is2 || ie2 < is1 => return String::from(\"NO\"),\n\
    \        ((is1, ie1), (is2, ie2)) if is1 < is2 && ie1 < ie2 => (is2, ie1),\n \
    \       ((is1, ie1), (is2, ie2)) if is1 < is2 && ie1 > ie2 => (is2, ie2),\n  \
    \      ((is1, ie1), (is2, ie2)) if is1 > is2 && ie1 < ie2 => (is1, ie1),\n   \
    \     ((is1, ie1), (is2, ie2)) if is1 > is2 && ie1 > ie2 => (is1, ie2),\n    \
    \    ((is1, ie1), (is2, ie2)) if is1 == is2 && ie1 < ie2 => (is1, ie1),\n    \
    \    ((is1, ie1), (is2, ie2)) if is1 == is2 && ie1 > ie2 => (is1, ie2),\n    \
    \    ((is1, ie1), (is2, ie2)) if is1 < is2 && ie1 == ie2 => (is2, ie1),\n    \
    \    ((is1, ie1), (is2, ie2)) if is1 > is2 && ie1 == ie2 => (is1, ie2),\n    \
    \    ((is1, ie1), (is2, ie2)) if is1 == is2 && ie1 == ie2 => (is1, ie1),\n   \
    \     _ => panic!(\"WTF?\"),\n    };\n    let (_, ie) = intersection;\n    //\
    \ dbg!(&intersection);\n    // dbg!(&ie);\n    if is_prime(ie - intersection.0\
    \ + 1) {\n        String::from(\"YES\")\n    } else {\n        String::from(\"\
    NO\")\n    }", "    let (start1, end1) = interval1;\n    let (start2, end2) =\
    \ interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return String::from(\"NO\");\n    }\n    let len\
    \ = end - start + 1;\n    let is_prime = if len == 1 { true } else { !(2..len/2+1).any(|n|\
    \ len % n == 0) };\n    if is_prime {\n        String::from(\"YES\")\n    } else\
    \ {\n        String::from(\"NO\")\n    }", "    let (i1, j1) = interval1;\n  \
    \  let (i2, j2) = interval2;\n    let m1 = (i1, j1).minmax().into_option().unwrap();\n\
    \    let m2 = (i2, j2).minmax().into_option().unwrap();\n    let (min, max) =\
    \ m1.min(m2).minmax().into_option().unwrap();\n    let len = max - min;\n    if\
    \ len < 0 { return String::from(\"NO\"); }\n    match len {\n        2 | 3 | 5\
    \ | 7 => String::from(\"YES\"),\n        _ => String::from(\"NO\"),\n    }", " \
    \   if (interval1.0 <= interval2.0 && interval2.0 <= interval1.1) ||\n       (interval2.0\
    \ <= interval1.0 && interval1.0 <= interval2.1) {\n        let start = interval1.0.max(interval2.0);\n\
    \        let end = interval1.1.min(interval2.1);\n        if is_prime(end - start\
    \ + 1) {\n            String::from(\"YES\")\n        } else {\n            String::from(\"\
    NO\")\n        }\n    } else {\n        String::from(\"NO\")\n    }", "    let\
    \ (a, b) = (interval1.0, interval1.1);\n    let (c, d) = (interval2.0, interval2.1);\n\
    \    let l = if c > a {\n        if d >= b {\n            b - c\n        } else\
    \ {\n            d - c\n        }\n    } else {\n        if d <= b {\n       \
    \     d - a\n        } else {\n            b - a\n        }\n    };\n    if l\
    \ < 0 {\n        return String::from(\"NO\");\n    }\n    if l == 1 {\n      \
    \  return String::from(\"NO\");\n    }\n    for i in 2..l {\n        if l % i\
    \ == 0 {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let mut intersection = (0, 0);\n    if interval1.0 <= interval2.0\
    \ && interval2.0 <= interval1.1 {\n        intersection.0 = interval2.0;\n   \
    \ } else if interval2.0 <= interval1.0 && interval1.0 <= interval2.1 {\n     \
    \   intersection.0 = interval1.0;\n    } else {\n        return String::from(\"\
    NO\");\n    }\n    if interval1.0 <= interval2.1 && interval2.1 <= interval1.1\
    \ {\n        intersection.1 = interval2.1;\n    } else if interval2.0 <= interval1.1\
    \ && interval1.1 <= interval2.1 {\n        intersection.1 = interval1.1;\n   \
    \ }\n    if is_prime(intersection.1 - intersection.0) {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    // Get the intersection of the\
    \ two intervals\n    let left = interval1.0.max(interval2.0);\n    let right =\
    \ interval1.1.min(interval2.1);\n    // Check if they intersect\n    if left >\
    \ right {\n        String::from(\"NO\")\n    } else {\n        // Validate that\
    \ the distance between the left and right is a prime number\n        if is_prime(right\
    \ - left) {\n            String::from(\"YES\")\n        } else {\n           \
    \ String::from(\"NO\")\n        }\n    }", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let mut intersection = (0, 0);\n   \
    \ if start1 <= start2 && start2 <= end1 {\n        intersection.0 = start2;\n\
    \    } else if start2 <= start1 && start1 <= end2 {\n        intersection.0 =\
    \ start1;\n    }\n    if end1 <= end2 && end1 >= start2 {\n        intersection.1\
    \ = end1;\n    } else if end2 <= end1 && end2 >= start1 {\n        intersection.1\
    \ = end2;\n    }\n    if intersection.0 == 0 && intersection.1 == 0 {\n      \
    \  return String::from(\"NO\");\n    }\n    let len = (intersection.1 - intersection.0).abs()\
    \ + 1;\n    if len == 2 {\n        return String::from(\"YES\");\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..len {\n        if len % i == 0 {\n   \
    \         is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        return String::from(\"YES\");\n    }\n    String::from(\"NO\")",
  "    fn is_prime(n: usize) -> bool {\n        if n < 2 { return false; }\n     \
    \   if n == 2 { return true; }\n        if n % 2 == 0 { return false; }\n    \
    \    let max = (n as f64).sqrt() as usize + 1;\n        for x in (3..max).step_by(2)\
    \ {\n            if n % x == 0 { return false; }\n        }\n        true\n  \
    \  }\n    let (i1s, i1e) = interval1;\n    let (i2s, i2e) = interval2;\n    if\
    \ i1e < i2s || i2e < i1s {\n        return String::from(\"NO\");\n    }\n    let\
    \ i1e = min(i1e, i2e);\n    let i2s = max(i1s, i2s);\n    if is_prime((i1e - i2s\
    \ + 1) as usize) {\n        String::from(\"YES\")\n    } else {\n        String::from(\"\
    NO\")\n    }", "    let (mut start, mut end) = match is_intersect(interval1, interval2)\
    \ {\n        true => {\n            (\n                std::cmp::max(interval1.0,\
    \ interval2.0),\n                std::cmp::min(interval1.1, interval2.1),\n  \
    \          )\n        }\n        false => return String::from(\"NO\"),\n    };\n\
    \    if start > end {\n        std::mem::swap(&mut start, &mut end);\n    }\n\
    \    // pre-handle for number 1\n    if start < 2 {\n        start = 2;\n    }\n\
    \    // pre-handle for number 2\n    if start < 3 {\n        start = 3;\n    }\n\
    \    for i in start..end + 1 {\n        if i % 2 == 0 || i % 3 == 0 {\n      \
    \      return String::from(\"NO\");\n        }\n    }\n    String::from(\"YES\"\
    )", '    String::from("")', "    let mut length = 0;\n    let mut start: isize\
    \ = 0;\n    let mut end: isize = 0;\n    let mut found = false;\n    if interval1.0\
    \ <= interval2.0 && interval1.1 >= interval2.0 {\n        start = interval2.0;\n\
    \        end = interval1.1;\n        found = true;\n    } else if interval2.0\
    \ <= interval1.0 && interval2.1 >= interval1.0 {\n        start = interval1.0;\n\
    \        end = interval2.1;\n        found = true;\n    }\n\n    if found {\n\
    \        length = end - start;\n        for i in 2..length + 1 {\n           \
    \ if length % i == 0 {\n                return String::from(\"NO\");\n       \
    \     }\n        }\n        return String::from(\"YES\");\n    }\n\n    String::from(\"\
    NO\")", "    let pair = if interval1.0 < interval2.0 {\n        (interval1, interval2)\n\
    \    } else {\n        (interval2, interval1)\n    };\n    if pair.0.1 < pair.1.0\
    \ {\n        return String::from(\"NO\");\n    }\n    let len = pair.1.0 - pair.0.1;\n\
    \    if len < 2 {\n        return String::from(\"NO\");\n    }\n    let mut i\
    \ = 2;\n    while i * i <= len {\n        if len % i == 0 {\n            return\
    \ String::from(\"NO\");\n        }\n        i += 1;\n    }\n    String::from(\"\
    YES\")", "    let start = max(interval1.0, interval2.0);\n    let end = min(interval1.1,\
    \ interval2.1);\n    if end >= start {\n        if is_prime(end - start + 1) {\n\
    \            return String::from(\"YES\");\n        }\n    }\n    String::from(\"\
    NO\")", "    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    let length = end - start;\n    if length < 0 {\n        return String::from(\"\
    NO\");\n    }\n    let is_prime = length > 2 && length % 2 != 0 && (3..((length\
    \ as f64).sqrt() as isize + 1)).all(|n| length % n != 0);\n    match is_prime\
    \ {\n        true => String::from(\"YES\"),\n        false => String::from(\"\
    NO\"),\n    }", "    let mut inter = interval1.1.min(interval2.1) - interval1.0.max(interval2.0);\n\
    \    inter = inter.max(0);\n    if inter < 2 {\n        return String::from(\"\
    NO\");\n    }\n    for i in 2..=inter.sqrt() {\n        if inter % i == 0 {\n\
    \            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let (begin1, end1) = interval1;\n    let (begin2, end2) = interval2;\n\
    \    let intersection = (std::cmp::max(begin1, begin2), std::cmp::min(end1, end2));\n\
    \    if intersection.0 > intersection.1 {\n        return String::from(\"NO\"\
    );\n    }\n    is_prime(intersection.1 - intersection.0 + 1)", "    // first find\
    \ the intersection\n    let (max_start, min_end) = if interval1.0 > interval2.0\
    \ {\n        (interval1.0, interval2.1)\n    } else {\n        (interval2.0, interval1.1)\n\
    \    };\n    if max_start > min_end {\n        return String::from(\"NO\");\n\
    \    }\n    // check if intersection is prime\n    // if max_start < 0 { return\
    \ String::from(\"NO\"); }\n    if max_start == 1 { return String::from(\"NO\"\
    ); }\n    if max_start == 2 { return String::from(\"YES\"); }\n    if max_start\
    \ == 3 { return String::from(\"YES\"); }\n    if max_start % 2 == 0 { return String::from(\"\
    NO\"); }\n    if max_start % 3 == 0 { return String::from(\"NO\"); }\n    for\
    \ i in (5..(max_start+1)).step_by(6) {\n        if max_start % i == 0 { return\
    \ String::from(\"NO\"); }\n        if max_start % (i+2) == 0 { return String::from(\"\
    NO\"); }\n    }\n    String::from(\"YES\")", "    //println!(\"{:?}\", interval1);\n\
    \    //println!(\"{:?}\", interval2);\n    if interval1.0 < interval2.0 {\n  \
    \      //println!(\"here\");\n        if interval1.1 >= interval2.0 {\n      \
    \      //println!(\"here2\");\n            if interval1.1 <= interval2.1 {\n \
    \               if is_prime(interval1.1 - interval2.0 + 1) {\n               \
    \     return String::from(\"YES\");\n                } else {\n              \
    \      return String::from(\"NO\");\n                }\n            } else {\n\
    \                if is_prime(interval2.1 - interval2.0 + 1) {\n              \
    \      return String::from(\"YES\");\n                } else {\n             \
    \       return String::from(\"NO\");\n                }\n            }\n     \
    \   } else {\n            return String::from(\"NO\");\n        }\n    } else\
    \ {\n        if interval2.1 >= interval1.0 {\n            if interval2.1 <= interval1.1\
    \ {\n                if is_prime(interval2.1 - interval1.0 + 1) {\n          \
    \          return String::from(\"YES\");\n                } else {\n         \
    \           return String::from(\"NO\");\n                }\n            } else\
    \ {\n                if is_prime(interval1.1 - interval1.0 + 1) {\n          \
    \          return String::from(\"YES\");\n                } else {\n         \
    \           return String::from(\"NO\");\n                }\n            }\n \
    \       } else {\n            return String::from(\"NO\");\n        }\n    }",
  "    let (a, b) = interval1;\n    let (c, d) = interval2;\n    let (mut start, mut\
    \ end) = (0, 0);\n    // check if interval1 is in interval2\n    if a >= c &&\
    \ a <= d && b >= c && b <= d {\n        start = a;\n        end = b;\n    } else\
    \ if c >= a && c <= b && d >= a && d <= b {\n        start = c;\n        end =\
    \ d;\n    } else if (a <= c && b >= c) || (c <= a && d >= a) {\n        start\
    \ = cmp::max(a, c);\n        end = cmp::min(b, d);\n    } else {\n        return\
    \ String::from(\"NO\");\n    }\n    // check if length of intersection is prime\n\
    \    if start == end {\n        return String::from(\"YES\");\n    }\n    let\
    \ mut flag = true;\n    for i in 2..end {\n        if end % i == 0 {\n       \
    \     flag = false;\n            break;\n        }\n    }\n    if flag {\n   \
    \     String::from(\"YES\")\n    } else {\n        String::from(\"NO\")\n    }",
  "    let mut min_end = interval1.1;\n    let mut max_start = interval1.0;\n    if\
    \ interval2.1 < min_end {\n        min_end = interval2.1;\n    }\n    if interval2.0\
    \ > max_start {\n        max_start = interval2.0;\n    }\n    if max_start >=\
    \ min_end {\n        return String::from(\"NO\");\n    }\n    let length = (min_end\
    \ - max_start) + 1;\n    if is_prime(length) {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    match (interval1, interval2) {\n\
    \        ((a, b), (c, d)) if a > b || c > d => \"NO\".to_string(),\n        ((a,\
    \ b), (c, d)) if b < c || d < a => \"NO\".to_string(),\n        ((a, b), (c, d))\
    \ => {\n            let mut points = vec![(a, 1), (b, -1), (c, 1), (d, -1)];\n\
    \            points.sort_by(|a, b| (a.0 - b.0).cmp(&(b.0 - a.0)));\n         \
    \   let mut active = 0;\n            let mut count = 0;\n            let mut primes\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n            for p in points {\n                active\
    \ += p.1;\n                if active == 2 {\n                    count += 1;\n\
    \                }\n            }\n            if primes.contains(&count) {\n\
    \                \"YES\".to_string()\n            } else {\n                \"\
    NO\".to_string()\n            }\n        }\n    }", "    //let (a1, a2) = interval1;\n\
    \    //let (b1, b2) = interval2;\n    let mut interval = (interval1.0, interval1.1);\n\
    \    if interval2.0 > interval1.0 {\n        interval.0 = interval2.0;\n    }\n\
    \    if interval2.1 < interval1.1 {\n        interval.1 = interval2.1;\n    }\n\
    \    if interval.0 > interval.1 {\n        return String::from(\"NO\");\n    }\n\
    \    if interval.0 == interval.1 {\n        if interval.0 > 1 {\n            return\
    \ String::from(\"YES\");\n        }\n        return String::from(\"NO\");\n  \
    \  }\n    let mut flag = false;\n    for i in 2..interval.1 {\n        if interval.0\
    \ % i == 0 || interval.1 % i == 0 {\n            flag = true;\n            break;\n\
    \        }\n    }\n    if flag {\n        return String::from(\"NO\");\n    }\n\
    \    String::from(\"YES\")", "    // let (x0, x1) = interval1;\n    // let (y0,\
    \ y1) = interval2;\n    // let x_set: BTreeSet<_> = (x0..x1 + 1).collect();\n\
    \    // let y_set: BTreeSet<_> = (y0..y1 + 1).collect();\n    // let intersections:\
    \ BTreeSet<_> = x_set.intersection(&y_set).collect();\n    // println!(\"{:?}\"\
    , intersections);\n    // String::from(\"\")\n    let (x0, x1) = interval1;\n\
    \    let (y0, y1) = interval2;\n    let i0 = std::cmp::max(x0, y0);\n    let i1\
    \ = std::cmp::min(x1, y1);\n    if i0 <= i1 {\n        if i1 - i0 == 1 {\n   \
    \         String::from(\"NO\")\n        } else {\n            is_prime(i1 - i0)\n\
    \        }\n    } else {\n        String::from(\"NO\")\n    }", "    let (mut\
    \ start, mut end) = (0, 0);\n    if interval1.0 > interval2.0 {\n        start\
    \ = interval1.0;\n    } else {\n        start = interval2.0;\n    }\n    if interval1.1\
    \ < interval2.1 {\n        end = interval1.1;\n    } else {\n        end = interval2.1;\n\
    \    }\n    if start <= end {\n        let mut i = end - start;\n        if i\
    \ == 0 {\n            return String::from(\"NO\");\n        }\n        i += 1;\n\
    \        while i != 1 {\n            if i == 2 {\n                return String::from(\"\
    YES\");\n            }\n            if i % 2 == 0 {\n                return String::from(\"\
    NO\");\n            }\n            i -= 1;\n        }\n    }\n    String::from(\"\
    NO\")", "    let ((interval1_start, interval1_end), (interval2_start, interval2_end))\
    \ = (interval1, interval2);\n    let (left, right) = (\n        max(interval1_start,\
    \ interval2_start),\n        min(interval1_end, interval2_end)\n    );\n    let\
    \ length = right - left;\n    if length > 0 {\n        (2..length).all(|divisor|\
    \ length % divisor != 0)\n    } else {\n        false\n    }.to_string()", " \
    \ let a = interval1.0;\n  let b = interval1.1;\n  let c = interval2.0;\n  let\
    \ d = interval2.1;\n  let (start, end) = if a > c { (b, d) } else { (a, c) };\n\
    \  let len = (end - start).abs();\n  if len == 0 {\n    return String::from(\"\
    NO\");\n  }\n  match len {\n    2 | 3 | 5 | 7 => String::from(\"YES\"),\n    _\
    \ => String::from(\"NO\"),\n  }", "    let (i1, i2) = (interval1, interval2);\n\
    \    let (max, min) = if i1.0 > i2.0 {\n        (i1.0, i2.1)\n    } else {\n \
    \       (i2.0, i1.1)\n    };\n    let diff = if max <= min {\n        0\n    }\
    \ else {\n        max - min\n    };\n    let divisors = (2..diff)\n        .filter(|x|\
    \ diff % x == 0)\n        .collect::<Vec<isize>>();\n    if diff == 1 {\n    \
    \    String::from(\"NO\")\n    } else if divisors.len() == 0 {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }", "    let mut left\
    \ = interval1.0;\n    let mut right = interval1.1;\n    let mut left2 = interval2.0;\n\
    \    let mut right2 = interval2.1;\n    if left2 > left {\n        let temp =\
    \ left;\n        left = left2;\n        left2 = temp;\n    }\n    if right2 <\
    \ right {\n        let temp = right;\n        right = right2;\n        right2\
    \ = temp;\n    }\n    if left > right2 || right < left2 {\n        return String::from(\"\
    NO\");\n    }\n    if left2 > left {\n        left = left2;\n    }\n    if right2\
    \ < right {\n        right = right2;\n    }\n    let length = right - left + 1;\n\
    \    if length > 2 {\n        for i in 2..length {\n            if length % i\
    \ == 0 {\n                return String::from(\"NO\");\n            }\n      \
    \  }\n    }\n    return String::from(\"YES\");", "    let length = if interval1.0\
    \ <= interval2.0 {\n        if interval1.1 < interval2.0 {\n            0\n  \
    \      } else {\n            if interval1.1 <= interval2.1 {\n               \
    \ interval1.1 - interval2.0 + 1\n            } else {\n                interval2.1\
    \ - interval2.0 + 1\n            }\n        }\n    } else {\n        if interval2.1\
    \ < interval1.0 {\n            0\n        } else {\n            if interval2.1\
    \ <= interval1.1 {\n                interval2.1 - interval1.0 + 1\n          \
    \  } else {\n                interval1.1 - interval1.0 + 1\n            }\n  \
    \      }\n    };\n    if length == 0 {\n        String::from(\"NO\")\n    } else\
    \ {\n        if length == 1 {\n            String::from(\"NO\")\n        } else\
    \ {\n            match length {\n                2 => String::from(\"YES\"),\n\
    \                3 => String::from(\"YES\"),\n                5 => String::from(\"\
    YES\"),\n                7 => String::from(\"YES\"),\n                _ => {\n\
    \                    let mut is_prime = true;\n                    for i in 2..length\
    \ {\n                        if length % i == 0 {\n                          \
    \  is_prime = false;\n                            break;\n                   \
    \     }\n                    }\n                    if is_prime {\n          \
    \              String::from(\"YES\")\n                    } else {\n         \
    \               String::from(\"NO\")\n                    }\n                }\n\
    \            }\n        }\n    }", "    let is_prime = |x: isize| -> bool {\n\
    \        let mut i = 2;\n        while i * i <= x {\n            if x % i == 0\
    \ {\n                return false;\n            }\n            i += 1;\n     \
    \   }\n        true\n    };\n    if interval1.0 <= interval2.0 && interval2.0\
    \ <= interval1.1 {\n        let start = interval2.0;\n        let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n        if start == end {\n            return String::from(\"\
    NO\");\n        }\n        let cnt = end - start;\n        if is_prime(cnt) {\n\
    \            return String::from(\"YES\");\n        }\n    }\n    if interval2.0\
    \ <= interval1.0 && interval1.0 <= interval2.1 {\n        let start = interval1.0;\n\
    \        let end = std::cmp::min(interval1.1, interval2.1);\n        if start\
    \ == end {\n            return String::from(\"NO\");\n        }\n        let cnt\
    \ = end - start;\n        if is_prime(cnt) {\n            return String::from(\"\
    YES\");\n        }\n    }\n    String::from(\"NO\")", "    let (mut a, mut b)\
    \ = interval1;\n    let (mut c, mut d) = interval2;\n    if b < c || d < a {\n\
    \        return String::from(\"NO\");\n    }\n    a = max(a, c);\n    b = min(b,\
    \ d);\n    let l = (b - a + 1) as u64;\n    if l < 2 {\n        return String::from(\"\
    NO\");\n    }\n    if l < 4 {\n        return String::from(\"YES\");\n    }\n\
    \    if l % 2 == 0 || l % 3 == 0 {\n        return String::from(\"NO\");\n   \
    \ }\n    let mut i = 5;\n    while i * i <= l {\n        if l % i == 0 || l %\
    \ (i + 2) == 0 {\n            return String::from(\"NO\");\n        }\n      \
    \  i += 6;\n    }\n    String::from(\"YES\")", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ String::from(\"NO\");\n    }\n    let len = end - start + 1;\n    if len ==\
    \ 1 {\n        return String::from(\"NO\");\n    }\n    if len == 2 {\n      \
    \  return String::from(\"YES\");\n    }\n    for i in 2..(len/2 + 1) {\n     \
    \   if len % i == 0 {\n            return String::from(\"NO\");\n        }\n \
    \   }\n    String::from(\"YES\")", "    let mut max = cmp::max(interval1.0, interval2.0);\n\
    \    let mut min = cmp::min(interval1.1, interval2.1);\n    max = if max > min\
    \ { min } else { max };\n    min = cmp::max(interval1.0, interval2.0);\n    if\
    \ max > min {\n        if is_prime(max - min) {\n            String::from(\"YES\"\
    )\n        } else {\n            String::from(\"NO\")\n        }\n    } else {\n\
    \        String::from(\"NO\")\n    }", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let (intersect_start, intersect_end)\
    \ =\n        if start1 > start2 {\n            if end1 > end2 {\n            \
    \    (start1, end2)\n            } else {\n                (start1, end1)\n  \
    \          }\n        } else {\n            if end1 > end2 {\n               \
    \ (start2, end2)\n            } else {\n                (start2, end1)\n     \
    \       }\n        };\n    if intersect_start > intersect_end {\n        String::from(\"\
    NO\")\n    } else {\n        let interval_length = intersect_end - intersect_start\
    \ + 1;\n        if interval_length > 2 {\n            let mut is_prime = true;\n\
    \            for n in 2..interval_length {\n                if interval_length\
    \ % n == 0 {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if is_prime {\n               \
    \ String::from(\"YES\")\n            } else {\n                String::from(\"\
    NO\")\n            }\n        } else {\n            String::from(\"NO\")\n   \
    \     }\n    }", "    if interval1.0 >= interval2.1 || interval2.0 >= interval1.1\
    \ {\n        return String::from(\"NO\");\n    }\n    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    let\
    \ length = end - start;\n    if is_prime(length) {\n        return String::from(\"\
    YES\");\n    }\n    return String::from(\"NO\");", "    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    if i1_start > i2_end\
    \ || i2_start > i1_end {\n        return String::from(\"NO\");\n    }\n    let\
    \ _intersection_start = if i1_start > i2_start { i1_start } else { i2_start };\n\
    \    let _intersection_end = if i1_end < i2_end { i1_end } else { i2_end };\n\
    \    if _intersection_start > _intersection_end {\n        return String::from(\"\
    NO\");\n    }\n    let _intersection_len = _intersection_end - _intersection_start\
    \ + 1;\n    if _intersection_len <= 2 {\n        return String::from(\"NO\");\n\
    \    }\n    let mut _is_prime = true;\n    for i in 2..(_intersection_len - 1)\
    \ {\n        if _intersection_len % i == 0 {\n            _is_prime = false;\n\
    \            break;\n        }\n    }\n    if _is_prime {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    let min = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let max = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ min > max {\n        String::from(\"NO\")\n    } else {\n        let interval\
    \ = (min, max);\n        let difference = interval.1 - interval.0;\n        match\
    \ difference {\n            1 => String::from(\"YES\"),\n            2 => String::from(\"\
    NO\"),\n            3 => String::from(\"YES\"),\n            4 => String::from(\"\
    NO\"),\n            5 => String::from(\"YES\"),\n            6 => String::from(\"\
    NO\"),\n            7 => String::from(\"YES\"),\n            8 => String::from(\"\
    NO\"),\n            9 => String::from(\"NO\"),\n            _ => {\n         \
    \       let mut prime = true;\n                for i in 2..difference {\n    \
    \                if difference % i == 0 {\n                        prime = false;\n\
    \                        break;\n                    }\n                }\n  \
    \              if prime {\n                    String::from(\"YES\")\n       \
    \         } else {\n                    String::from(\"NO\")\n               \
    \ }\n            }\n        }\n    }", "    fn is_prime(n: isize) -> bool {\n\
    \        let mut i = 2;\n        while i * i <= n {\n            if n % i == 0\
    \ {\n                return false;\n            }\n            i += 1;\n     \
    \   }\n        true\n    }\n    let (x, y) = (interval1.0, interval1.1);\n   \
    \ let (a, b) = (interval2.0, interval2.1);\n    let (start, end) = if x > a {\
    \ (x, y) } else { (a, b) };\n    let (x, y) = (interval1.0, interval1.1);\n  \
    \  let (a, b) = (interval2.0, interval2.1);\n    let (other_start, other_end)\
    \ = if x < a { (x, y) } else { (a, b) };\n    let intersection = if start < other_end\
    \ {\n        if end < other_end { (start, end) } else { (start, other_end) }\n\
    \    } else {\n        (other_start, other_end)\n    };\n    if intersection.0\
    \ == intersection.1 {\n        String::from(\"NO\")\n    } else {\n        let\
    \ length = intersection.1 - intersection.0;\n        if is_prime(length) {\n \
    \           String::from(\"YES\")\n        } else {\n            String::from(\"\
    NO\")\n        }\n    }", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end1 || start2 > end2 {\n        return\
    \ String::from(\"NO\");\n    }\n    let start = if start1 > start2 { start1 }\
    \ else { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n   \
    \ if start >= end {\n        return String::from(\"NO\");\n    }\n    if is_prime(end\
    \ - start) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let (mut start, mut end) = (interval1.0, interval1.1);\n    if start\
    \ > end {\n        ::std::mem::swap(&mut start, &mut end);\n    }\n    let (mut\
    \ a, mut b) = (interval2.0, interval2.1);\n    if a > b {\n        ::std::mem::swap(&mut\
    \ a, &mut b);\n    }\n    let (mut l, mut r) = (start, end);\n    if l > r {\n\
    \        ::std::mem::swap(&mut l, &mut r);\n    }\n    if r < a || l > b {\n \
    \       return String::from(\"NO\");\n    }\n    let mut s = max(a, l);\n    let\
    \ mut e = min(b, r);\n    if s > e {\n        ::std::mem::swap(&mut s, &mut e);\n\
    \    }\n    for i in 2..(e - s + 1) {\n        if (e - s + 1) % i == 0 {\n   \
    \         return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let (i1, i2) = (interval1, interval2);\n    let (i1_start, i1_end)\
    \ = (i1.0, i1.1);\n    let (i2_start, i2_end) = (i2.0, i2.1);\n    let i = if\
    \ i1_start > i2_start {\n        (i1_start, i2_end)\n    } else {\n        (i2_start,\
    \ i1_end)\n    };\n    if i.0 >= i.1 {\n        return String::from(\"NO\");\n\
    \    }\n    let len = (i.1 - i.0) as usize;\n    let is_prime = (2..len).all(|x|\
    \ len % x != 0);\n    if is_prime {\n        String::from(\"YES\")\n    } else\
    \ {\n        String::from(\"NO\")\n    }", "    if interval1.0 >= interval2.1\
    \ || interval2.0 >= interval1.1 {\n        return String::from(\"NO\");\n    }\n\
    \    let mut intersection = (0, 0);\n    if interval1.0 <= interval2.0 {\n   \
    \     intersection.0 = interval2.0;\n    } else {\n        intersection.0 = interval1.0;\n\
    \    }\n    if interval1.1 <= interval2.1 {\n        intersection.1 = interval1.1;\n\
    \    } else {\n        intersection.1 = interval2.1;\n    }\n    let is_prime\
    \ = is_prime(intersection.1 - intersection.0);\n    if is_prime {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return String::from(\"\
    NO\");\n    }\n    let mut i = interval1.0.max(interval2.0);\n    let mut count\
    \ = 0;\n    while i <= interval1.1.min(interval2.1) {\n        count += 1;\n \
    \       i += 1;\n    }\n    if is_prime(count) {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    let mut a = vec![interval1.0,\
    \ interval1.1, interval2.0, interval2.1];\n    a.sort();\n    let len = match\
    \ a[2] - a[1] {\n        0 => String::from(\"NO\"),\n        len => if is_prime(len)\
    \ {\n            String::from(\"YES\")\n        } else {\n            String::from(\"\
    NO\")\n        }\n    };\n    len", "    let mut common_interval = (0, 0);\n \
    \   let is_intersect = if interval1.0 <= interval2.0 {\n        interval1.1 >=\
    \ interval2.0\n    } else {\n        interval2.1 >= interval1.0\n    };\n    if\
    \ is_intersect {\n        common_interval.0 = common_interval.0.max(interval1.0).max(interval2.0);\n\
    \        common_interval.1 = common_interval.1.min(interval1.1).min(interval2.1);\n\
    \    }\n    let length = common_interval.1 - common_interval.0;\n    if length\
    \ <= 1 {\n        return String::from(\"NO\");\n    }\n    let not_prime = [4,\
    \ 6, 8, 9, 10, 12, 14, 15, 16, 18, 20];\n    if not_prime.contains(&length) {\n\
    \        return String::from(\"NO\");\n    }\n    String::from(\"YES\")", "  \
    \  let a = interval1.0.max(interval2.0);\n    let b = interval1.1.min(interval2.1);\n\
    \    if a > b {\n        return String::from(\"NO\");\n    }\n    let result =\
    \ a - b + 1;\n    if result < 2 {\n        return String::from(\"NO\");\n    }\n\
    \    if result == 2 {\n        return String::from(\"YES\");\n    }\n    if result\
    \ == 3 {\n        return String::from(\"YES\");\n    }\n    if result % 2 == 0\
    \ {\n        return String::from(\"NO\");\n    }\n    if result % 3 == 0 {\n \
    \       return String::from(\"NO\");\n    }\n    if result % 5 == 0 {\n      \
    \  return String::from(\"NO\");\n    }\n    if result % 7 == 0 {\n        return\
    \ String::from(\"NO\");\n    }\n    return String::from(\"YES\");", "    if let\
    \ Some(intersection) = intersection(interval1, interval2) {\n        if is_prime(intersection.1\
    \ - intersection.0) {\n            return String::from(\"YES\");\n        }\n\
    \    }\n    String::from(\"NO\")", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return String::from(\"NO\");\n    }\n    let low =\
    \ max(interval1.0, interval2.0);\n    let high = min(interval1.1, interval2.1);\n\
    \    for i in low..high {\n        if is_prime(i) {\n            return String::from(\"\
    YES\");\n        }\n    }\n    String::from(\"NO\")", "    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end1 || start2\
    \ > end2 {\n        return String::from(\"NO\");\n    }\n    if start1 == end1\
    \ && start2 == end2 {\n        return String::from(\"YES\");\n    }\n    if start1\
    \ > start2 {\n        if end1 < start2 {\n            return String::from(\"NO\"\
    );\n        }\n        return intersection((start2, end1), (start1, end2));\n\
    \    }\n    if end1 < start2 {\n        return String::from(\"NO\");\n    }\n\
    \    if end1 < end2 {\n        let diff = end1 - start1;\n        return if is_prime(diff)\
    \ {\n            String::from(\"YES\")\n        } else {\n            String::from(\"\
    NO\")\n        };\n    }\n    let diff = end2 - start1;\n    return if is_prime(diff)\
    \ {\n        String::from(\"YES\")\n    } else {\n        String::from(\"NO\"\
    )\n    };", "    let left = std::cmp::max(interval1.0, interval2.0);\n    let\
    \ right = std::cmp::min(interval1.1, interval2.1);\n    if left > right {\n  \
    \      return String::from(\"NO\");\n    }\n    if prime::is_prime(left - right\
    \ + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"NO\"\
    )", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    let mut start = if start1 > start2 { start1 } else { start2 };\n    let mut\
    \ end = if end1 < end2 { end1 } else { end2 };\n    if start >= end { return String::from(\"\
    NO\"); }\n    while start <= end {\n        if start > 1 && end >= start {\n \
    \           let mut is_prime = true;\n            for i in 2..start {\n      \
    \          if start % i == 0 {\n                    is_prime = false;\n      \
    \              break;\n                }\n            }\n            if is_prime\
    \ { return String::from(\"YES\"); }\n        }\n        start += 1;\n    }\n \
    \   String::from(\"NO\")", "    let a = interval1.0.max(interval2.0);\n    let\
    \ b = interval1.1.min(interval2.1);\n    if a > b {\n        return String::from(\"\
    NO\");\n    }\n    if is_prime(b - a + 1) {\n        return String::from(\"YES\"\
    );\n    }\n    String::from(\"NO\")", "    let (a1, b1) = interval1;\n    let\
    \ (a2, b2) = interval2;\n    if (a1 > b2) || (a2 > b1) {\n        return String::from(\"\
    NO\");\n    }\n    let start = std::cmp::max(a1, a2);\n    let end = std::cmp::min(b1,\
    \ b2);\n    let diff = (end - start + 1) as usize;\n    match PRIMES.binary_search(&diff)\
    \ {\n        Ok(_) => String::from(\"YES\"),\n        Err(_) => String::from(\"\
    NO\"),\n    }", "    let mut res = String::from(\"NO\");\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return res;\n    }\n   \
    \ if is_prime(interval1.0.max(interval2.0) - interval1.1.min(interval2.1) + 1)\
    \ {\n        res = String::from(\"YES\");\n    }\n    res", "    use std::cmp::{max,\
    \ min};\n    let start1 = interval1.0;\n    let end1 = interval1.1;\n    let start2\
    \ = interval2.0;\n    let end2 = interval2.1;\n    let start = max(start1, start2);\n\
    \    let end = min(end1, end2);\n    if start >= end {\n        return String::from(\"\
    NO\");\n    }\n    let diff = end - start;\n    if diff <= 1 {\n        return\
    \ String::from(\"NO\");\n    }\n    for i in 2..(diff/2) {\n        if diff %\
    \ i == 0 {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let s1 = interval1.0;\n    let e1 = interval1.1;\n    let s2 = interval2.0;\n\
    \    let e2 = interval2.1;\n    let mut start = max(s1, s2);\n    let mut end\
    \ = min(e1, e2);\n    if end <= start {\n        return String::from(\"NO\");\n\
    \    }\n    if end == start {\n        return if end == 2 { String::from(\"YES\"\
    ) } else { String::from(\"NO\") };\n    }\n    let mut count = 0;\n    for i in\
    \ start..end {\n        count += 1;\n    }\n    if count == 2 {\n        return\
    \ String::from(\"YES\");\n    }\n    let mut prime = true;\n    let mut i = 2;\n\
    \    while i <= count / 2 {\n        if count % i == 0 {\n            prime =\
    \ false;\n            break;\n        }\n        i += 1;\n    }\n    if prime\
    \ {\n        return String::from(\"YES\");\n    }\n    String::from(\"NO\")",
  "    let mut is_prime = false;\n    if interval1.0 < interval2.0 {\n        let\
    \ intersection = (interval2.0, std::cmp::min(interval1.1, interval2.1));\n   \
    \     if intersection.0 <= intersection.1 {\n            is_prime = Prime::is_prime(intersection.1\
    \ - intersection.0 + 1);\n        }\n    } else {\n        let intersection =\
    \ (interval1.0, std::cmp::min(interval1.1, interval2.1));\n        if intersection.0\
    \ <= intersection.1 {\n            is_prime = Prime::is_prime(intersection.1 -\
    \ intersection.0 + 1);\n        }\n    }\n    if is_prime {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }", "    let (s1, e1)\
    \ = interval1;\n    let (s2, e2) = interval2;\n    if s1 > e1 || s2 > e2 {\n \
    \       return String::from(\"NO\");\n    }\n    let (left, right) = if s1 > s2\
    \ {\n        (s1, e2)\n    } else {\n        (s2, e1)\n    };\n    if right <\
    \ left {\n        return String::from(\"NO\");\n    }\n    if left < 0 {\n   \
    \     if right == 0 {\n            return String::from(\"NO\");\n        }\n \
    \       let tmp = right;\n        let right = (-left).min(tmp);\n        let left\
    \ = (-left).max(tmp);\n    }\n    for i in 2..(right + 1) {\n        if left %\
    \ i == 0 {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    if interval1.0 >= interval2.1 || interval2.0 >= interval1.1 {\n\
    \        return String::from(\"NO\");\n    }\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    let length = end - start;\n\
    \    if length < 2 {\n        return String::from(\"NO\");\n    }\n    let primes\
    \ = &[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    if primes.contains(&length) {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (mut a, mut\
    \ b) = if interval1.0 > interval2.0 {\n        (interval1.0, interval1.1)\n  \
    \  } else {\n        (interval2.0, interval2.1)\n    };\n    let (mut c, mut d)\
    \ = if interval1.0 > interval2.0 {\n        (interval2.0, interval2.1)\n    }\
    \ else {\n        (interval1.0, interval1.1)\n    };\n    let mut result = 0;\n\
    \    while a > c && d > b {\n        a -= 1;\n        b -= 1;\n        c += 1;\n\
    \        d += 1;\n        result += 1;\n    }\n    if is_prime(result) {\n   \
    \     return String::from(\"YES\");\n    }\n    return String::from(\"NO\");",
  "    let start = std::cmp::max(interval1.0, interval2.0);\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    if end <= start {\n        return String::from(\"NO\");\n\
    \    }\n    let length = end - start + 1;\n    if length <= 2 {\n        return\
    \ String::from(\"NO\");\n    }\n    for i in 2..length {\n        if length %\
    \ i == 0 {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    let max_start = std::cmp::max(start1, start2);\n    let min_end = std::cmp::min(end1,\
    \ end2);\n    if max_start > min_end {\n        return String::from(\"NO\");\n\
    \    }\n    let interval_len = (min_end - max_start) + 1;\n    let mut i = 2;\n\
    \    while i < interval_len {\n        if interval_len % i == 0 {\n          \
    \  return String::from(\"NO\");\n        }\n        i += 1;\n    }\n    String::from(\"\
    YES\")", "    let (a, b) = interval1;\n    let (c, d) = interval2;\n    let mut\
    \ vec = vec![];\n    if a > b {\n        vec.push(a);\n        vec.push(b);\n\
    \    } else {\n        vec.push(b);\n        vec.push(a);\n    }\n    if c > d\
    \ {\n        vec.push(c);\n        vec.push(d);\n    } else {\n        vec.push(d);\n\
    \        vec.push(c);\n    }\n    vec.sort();\n    let mut n = vec[1] - vec[0];\n\
    \    if n < 0 {\n        n = n.abs();\n    }\n    let mut ans = \"NO\";\n    if\
    \ n == 1 {\n        ans = \"YES\";\n    } else {\n        for i in 2..n {\n  \
    \          if n % i == 0 {\n                break;\n            } else if i ==\
    \ n - 1 {\n                ans = \"YES\";\n            }\n        }\n    }\n \
    \   return String::from(ans);", "  let mut start = max(interval1.0, interval2.0);\n\
    \  let mut end = min(interval1.1, interval2.1);\n  let mut result = String::from(\"\
    NO\");\n  if end >= start {\n    if end - start + 1 > 2 {\n      for n in 2..=(end\
    \ - start) {\n        if (end - start + 1) % n == 0 {\n          return result;\n\
    \        }\n      }\n    }\n    result = String::from(\"YES\");\n  }\n  result",
  "    let (mut start, mut end) = (interval1.0, interval1.1);\n    let (mut start1,\
    \ mut end1) = (interval2.0, interval2.1);\n    if start > end {\n        start\
    \ = interval1.1;\n        end = interval1.0;\n    }\n    if start1 > end1 {\n\
    \        start1 = interval2.1;\n        end1 = interval2.0;\n    }\n    if start\
    \ > end1 || start1 > end {\n        return String::from(\"NO\");\n    }\n    if\
    \ start >= start1 {\n        start = start1;\n    }\n    if end >= end1 {\n  \
    \      end = end1;\n    }\n    let mut flag = 0;\n    for i in 2..=end as usize\
    \ - start as usize {\n        if end as usize - start as usize + 1 == i {\n  \
    \          break;\n        }\n        if end as usize - start as usize + 1 % i\
    \ == 0 {\n            flag = 1;\n            break;\n        }\n    }\n    if\
    \ flag == 1 {\n        return String::from(\"NO\");\n    }\n    String::from(\"\
    YES\")", "    if interval1.0 <= interval2.1 && interval2.0 <= interval1.1 {\n\
    \        if interval1.0 > interval2.0 {\n            let start = interval1.0;\n\
    \            let end = interval2.1;\n            check_prime(start, end)\n   \
    \     } else {\n            let start = interval2.0;\n            let end = interval1.1;\n\
    \            check_prime(start, end)\n        }\n    } else {\n        String::from(\"\
    NO\")\n    }", "    let (start1, end1) = interval1;\n    let (start2, end2) =\
    \ interval2;\n    let max_start = std::cmp::max(start1, start2);\n    let min_end\
    \ = std::cmp::min(end1, end2);\n    if max_start > min_end {\n        return String::from(\"\
    NO\");\n    }\n    let length = min_end - max_start + 1;\n    if length <= 1 {\n\
    \        return String::from(\"NO\");\n    }\n    for i in 2..(length as f64).sqrt()\
    \ as isize + 1 {\n        if length % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let (a1, b1) = interval1;\n\
    \    let (a2, b2) = interval2;\n    if a1 <= a2 && a2 <= b1 {\n        (b1 - a2\
    \ + 1).to_string()\n    } else if a2 <= a1 && a1 <= b2 {\n        (b2 - a1 + 1).to_string()\n\
    \    } else {\n        String::from(\"NO\")\n    }", "    if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n        return String::from(\"NO\");\n    }\n\
    \    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if is_prime(end - start + 1) {\n        return String::from(\"YES\");\n \
    \   }\n    String::from(\"NO\")", "    let mut start = interval1.0;\n    let mut\
    \ end = interval1.1;\n    if start > end {\n        start = interval1.1;\n   \
    \     end = interval1.0;\n    }\n    let mut start2 = interval2.0;\n    let mut\
    \ end2 = interval2.1;\n    if start2 > end2 {\n        start2 = interval2.1;\n\
    \        end2 = interval2.0;\n    }\n    if start2 > end || start > end2 {\n \
    \       return String::from(\"NO\");\n    }\n    if start > start2 {\n       \
    \ start = start2;\n    }\n    if end > end2 {\n        end = end2;\n    }\n  \
    \  if start > end {\n        return String::from(\"NO\");\n    }\n    if end -\
    \ start <= 1 {\n        return String::from(\"NO\");\n    }\n    let mut result\
    \ = true;\n    for i in 2..=(end - start) {\n        if (end - start) % i == 0\
    \ {\n            result = false;\n            break;\n        }\n    }\n    if\
    \ result {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let left: isize = if interval1.0 < interval2.0 {\n        interval2.0\n\
    \    } else {\n        interval1.0\n    };\n    let right: isize = if interval1.1\
    \ < interval2.1 {\n        interval1.1\n    } else {\n        interval2.1\n  \
    \  };\n    if right < left {\n        return String::from(\"NO\");\n    }\n  \
    \  let len = right - left + 1;\n    if len == 2 {\n        return String::from(\"\
    YES\");\n    }\n    for i in 2..len {\n        if len % i == 0 {\n           \
    \ return String::from(\"NO\");\n        }\n    }\n    String::from(\"YES\")",
  "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    if\
    \ (start1 > end2) || (start2 > end1) {\n        return String::from(\"NO\");\n\
    \    }\n    let start = std::cmp::max(start1, start2);\n    let end = std::cmp::min(end1,\
    \ end2);\n    let len = end - start + 1;\n    if len > 2 {\n        if (len %\
    \ 2) == 0 {\n            return String::from(\"NO\");\n        }\n        let\
    \ mut i = 3;\n        while i < len {\n            if (len % i) == 0 {\n     \
    \           return String::from(\"NO\");\n            }\n            i += 2;\n\
    \        }\n    }\n    String::from(\"YES\")", "    let start = cmp::max(interval1.0,\
    \ interval2.0);\n    let end = cmp::min(interval1.1, interval2.1);\n    if start\
    \ > end {\n        return String::from(\"NO\");\n    }\n    // A prime is an integer\
    \ > 1 that is not divisible by any other integer\n    // except 1 and itself.\n\
    \    // So if the length of the intersection is >= 2, return \"NO\"\n    if end\
    \ - start >= 2 {\n        return String::from(\"NO\");\n    }\n    String::from(\"\
    YES\")", "    let mut intersection = (0, 0);\n    if interval1.0 <= interval2.0\
    \ && interval2.0 <= interval1.1 {\n        intersection.0 = interval2.0;\n   \
    \ } else if interval2.0 <= interval1.0 && interval1.0 <= interval2.1 {\n     \
    \   intersection.0 = interval1.0;\n    }\n    if interval1.0 <= interval2.1 &&\
    \ interval2.1 <= interval1.1 {\n        intersection.1 = interval2.1;\n    } else\
    \ if interval2.0 <= interval1.1 && interval1.1 <= interval2.1 {\n        intersection.1\
    \ = interval1.1;\n    }\n    if intersection.0 <= intersection.1 {\n        let\
    \ length = intersection.1 - intersection.0 + 1;\n        if is_prime(length) {\n\
    \            return String::from(\"YES\");\n        }\n    }\n    String::from(\"\
    NO\")", "    let (interval1_start, interval1_end) = interval1;\n    let (interval2_start,\
    \ interval2_end) = interval2;\n    let mut intersection_size = 0;\n    if interval1_start\
    \ <= interval2_start && interval2_start <= interval1_end {\n        if interval1_end\
    \ <= interval2_end {\n            intersection_size = interval1_end - interval2_start;\n\
    \        } else {\n            intersection_size = interval2_end - interval2_start;\n\
    \        }\n    } else if interval2_start <= interval1_start && interval1_start\
    \ <= interval2_end {\n        if interval2_end <= interval1_end {\n          \
    \  intersection_size = interval2_end - interval1_start;\n        } else {\n  \
    \          intersection_size = interval1_end - interval1_start;\n        }\n \
    \   }\n    return if is_prime(intersection_size) {\n        String::from(\"YES\"\
    )\n    } else {\n        String::from(\"NO\")\n    };", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ String::from(\"NO\");\n    }\n    if is_prime(end - start + 1) {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if interval1.0 > interval1.1 {\n\
    \        start = interval1.1;\n        end = interval1.0;\n    }\n    let (mut\
    \ start2, mut end2) = (interval2.0, interval2.1);\n    if interval2.0 > interval2.1\
    \ {\n        start2 = interval2.1;\n        end2 = interval2.0;\n    }\n    if\
    \ end < start2 || end2 < start {\n        return String::from(\"NO\");\n    }\n\
    \    let start = std::cmp::max(start, start2);\n    let end = std::cmp::min(end,\
    \ end2);\n    let length = end - start + 1;\n    if is_prime(length) {\n     \
    \   return String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let\
    \ (mut start, mut end) = (0, 0);\n    if interval1.0 > interval2.0 {\n       \
    \ start = interval1.0;\n    } else {\n        start = interval2.0;\n    }\n  \
    \  if interval1.1 < interval2.1 {\n        end = interval1.1;\n    } else {\n\
    \        end = interval2.1;\n    }\n    if start >= end {\n        return String::from(\"\
    NO\");\n    }\n    if is_prime(end - start) {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    if start1 >= end2 || start2 >= end1\
    \ {\n        return String::from(\"NO\");\n    }\n    let intersection = if start1\
    \ < start2 {\n        if end1 < end2 {\n            (start2, end1)\n        }\
    \ else {\n            (start2, end2)\n        }\n    } else {\n        if end1\
    \ < end2 {\n            (start1, end1)\n        } else {\n            (start1,\
    \ end2)\n        }\n    };\n    let (start, end) = intersection;\n    if start\
    \ == end {\n        return String::from(\"YES\");\n    }\n    for i in start..end\
    \ {\n        if i == 1 {\n            continue;\n        }\n        if end % i\
    \ == 0 {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let v: Vec<isize> = vec![interval1.0, interval1.1, interval2.0,\
    \ interval2.1];\n    let v_sorted = v.iter().cloned().collect::<Vec<isize>>();\n\
    \    let (s1, e1) = (v_sorted[1], v_sorted[2]);\n    if s1 > e1 { return String::from(\"\
    NO\"); }\n    let len = e1 - s1 + 1;\n    if is_prime(len) {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }", "    let a: isize\
    \ = cmp::max(interval1.0, interval2.0);\n    let b: isize = cmp::min(interval1.1,\
    \ interval2.1);\n    let diff: isize = b - a;\n    if diff <= 0 {\n        return\
    \ String::from(\"NO\");\n    }\n    let mut iter: Vec<isize> = (2..diff).collect();\n\
    \    iter.retain(|x| diff % x != 0);\n    if iter.len() == 0 {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (interval1_start,\
    \ interval1_end) = interval1;\n    let (interval2_start, interval2_end) = interval2;\n\
    \    if interval1_start > interval1_end || interval2_start > interval2_end {\n\
    \        return String::from(\"NO\");\n    }\n    let mut intersection_start =\
    \ interval1_start;\n    let mut intersection_end = interval1_end;\n    if interval2_start\
    \ > interval1_start {\n        intersection_start = interval2_start;\n    }\n\
    \    if interval2_end < interval1_end {\n        intersection_end = interval2_end;\n\
    \    }\n    if intersection_start >= intersection_end {\n        return String::from(\"\
    NO\");\n    }\n    let interval_length = intersection_end - intersection_start\
    \ + 1;\n    if interval_length == 1 {\n        return String::from(\"NO\");\n\
    \    }\n    if is_prime(interval_length) {\n        return String::from(\"YES\"\
    );\n    }\n    String::from(\"NO\")", "    let mut a = interval1.0;\n    let mut\
    \ b = interval1.1;\n    let mut c = interval2.0;\n    let mut d = interval2.1;\n\
    \    if a > b {\n        let temp = a;\n        a = b;\n        b = temp;\n  \
    \  }\n    if c > d {\n        let temp = c;\n        c = d;\n        d = temp;\n\
    \    }\n    let e = if a > c {a} else {c};\n    let f = if b < d {b} else {d};\n\
    \    let g = f - e + 1;\n    if g <= 0 {return String::from(\"NO\");}\n    let\
    \ mut n = 0;\n    for j in 2..g {\n        if g % j == 0 {\n            n += 1;\n\
    \        }\n    }\n    if n == 0 {\n        String::from(\"YES\")\n    } else\
    \ {\n        String::from(\"NO\")\n    }", "    let lower = interval1.0.max(interval2.0);\n\
    \    let upper = interval1.1.min(interval2.1);\n    let ret = if upper < lower\
    \ {\n        String::from(\"NO\")\n    } else {\n        if upper - lower < 2\
    \ {\n            String::from(\"NO\")\n        } else {\n            // (lower\
    \ + 1..upper).all(|x| is_prime(x))\n            if (lower + 1..upper).any(|x|\
    \ !is_prime(x)) {\n                String::from(\"NO\")\n            } else {\n\
    \                String::from(\"YES\")\n            }\n        }\n    };\n   \
    \ ret", "    let (a1, b1) = interval1;\n    let (a2, b2) = interval2;\n    let\
    \ low = a1.max(a2);\n    let high = b1.min(b2);\n    if low > high {\n       \
    \ return String::from(\"NO\");\n    }\n    if is_prime(high - low + 1) {\n   \
    \     return String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let\
    \ (mut low, mut high) = if interval1.0 < interval2.0 {\n        (interval2.0,\
    \ interval1.1)\n    } else {\n        (interval1.0, interval2.1)\n    };\n   \
    \ if low > high {\n        low = high;\n    }\n    if low < interval1.0 {\n  \
    \      low = interval1.0;\n    }\n    if low < interval2.0 {\n        low = interval2.0;\n\
    \    }\n    if high > interval1.1 {\n        high = interval1.1;\n    }\n    if\
    \ high > interval2.1 {\n        high = interval2.1;\n    }\n    if low > high\
    \ {\n        return String::from(\"NO\");\n    }\n    let mut count = 0;\n   \
    \ for i in low..=high {\n        count += 1;\n    }\n    for i in 2..=(count /\
    \ 2) {\n        if count % i == 0 {\n            return String::from(\"NO\");\n\
    \        }\n    }\n    String::from(\"YES\")", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    if start1 > end1 || start2 > end2 {\n\
    \        return String::from(\"NO\");\n    }\n    if start1 >= end2 || start2\
    \ >= end1 {\n        return String::from(\"NO\");\n    }\n    let (start, end)\
    \ = (cmp::max(start1, start2), cmp::min(end1, end2));\n    let len = end - start\
    \ + 1;\n    if is_prime(len) {\n        return String::from(\"YES\");\n    }\n\
    \    String::from(\"NO\")", "    if interval1.0 < interval2.0 {\n        intersection(interval2,\
    \ interval1)\n    } else if interval1.0 <= interval2.1 {\n        if interval1.1\
    \ < interval2.1 {\n            \"YES\".to_string()\n        } else {\n       \
    \     is_prime(interval2.1 - interval1.0 + 1)\n        }\n    } else {\n     \
    \   \"NO\".to_string()\n    }", "    let (min_start, max_end) = (\n        interval1.0.min(interval2.0),\n\
    \        interval1.1.max(interval2.1),\n    );\n    if max_end < min_start {\n\
    \        return String::from(\"NO\");\n    }\n    let (min_start, max_end) = (\n\
    \        interval1.0.max(interval2.0),\n        interval1.1.min(interval2.1),\n\
    \    );\n    let res = if min_start >= max_end {\n        \"NO\"\n    } else {\n\
    \        let len = (max_end - min_start) + 1;\n        if (len == 2) || (len ==\
    \ 3) || (len == 5) || (len == 7) {\n            \"YES\"\n        } else {\n  \
    \          \"NO\"\n        }\n    };\n    String::from(res)", "    let (mut start,\
    \ mut end) = match interval1.0.cmp(&interval2.0) {\n        Ordering::Less =>\
    \ (interval2.0, interval1.1),\n        Ordering::Equal => (interval2.0, interval1.1),\n\
    \        Ordering::Greater => (interval1.0, interval2.1),\n    };\n    start =\
    \ cmp::max(start, interval1.0);\n    end = cmp::min(end, interval1.1);\n    start\
    \ = cmp::max(start, interval2.0);\n    end = cmp::min(end, interval2.1);\n   \
    \ if start > end {\n        return String::from(\"NO\");\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n   \
    \     return String::from(\"NO\");\n    }\n    let start = if interval1.0 >= interval2.0\
    \ {\n        interval1.0\n    } else {\n        interval2.0\n    };\n    let end\
    \ = if interval1.1 >= interval2.1 {\n        interval2.1\n    } else {\n     \
    \   interval1.1\n    };\n    let result = end - start + 1;\n    if result == 2\
    \ {\n        return String::from(\"YES\");\n    }\n    for n in 2..result {\n\
    \        if result % n == 0 {\n            return String::from(\"NO\");\n    \
    \    }\n    }\n    String::from(\"YES\")", "    let mut vec = vec![interval1.0,\
    \ interval1.1, interval2.0, interval2.1];\n    vec.sort();\n    if vec[1] < vec[2]\
    \ {\n        let length = vec[2] - vec[1];\n        if length == 1 {\n       \
    \     return String::from(\"NO\");\n        }\n        let mut flag = true;\n\
    \        for i in 2..length {\n            if length % i == 0 {\n            \
    \    flag = false;\n                break;\n            }\n        }\n       \
    \ if flag {\n            return String::from(\"YES\");\n        }\n    }\n   \
    \ String::from(\"NO\")", "    match (interval1, interval2) {\n        ((a, b),\
    \ (c, d)) if a > b || c > d => String::from(\"NO\"),\n        ((a, b), (c, d))\
    \ if a > d || c > b => String::from(\"NO\"),\n        ((a, b), (c, d)) if a <=\
    \ c && c <= b && b <= d => is_prime(b - c + 1),\n        ((a, b), (c, d)) if c\
    \ <= a && a <= d && d <= b => is_prime(d - a + 1),\n        ((a, b), (c, d)) if\
    \ a <= c && d <= b => is_prime(d - c + 1),\n        ((a, b), (c, d)) if c <= a\
    \ && b <= d => is_prime(b - a + 1),\n        _ => String::from(\"NO\"),\n    }",
  "    let (min, max) = match (interval1.0 <= interval2.0, interval1.1 >= interval2.1)\
    \ {\n        (true, true) => (interval2.0, interval1.1),\n        (true, false)\
    \ => (interval2.0, interval2.1),\n        (false, true) => (interval1.0, interval1.1),\n\
    \        (false, false) => (interval1.0, interval2.1),\n    };\n    if min > max\
    \ {\n        return String::from(\"NO\");\n    }\n    let mut r = true;\n    for\
    \ i in 2..max {\n        if max % i == 0 {\n            r = false;\n         \
    \   break;\n        }\n    }\n    if r {\n        String::from(\"YES\")\n    }\
    \ else {\n        String::from(\"NO\")\n    }", "  if let Some(interval) = intersection_internal(interval1,\
    \ interval2) {\n    match interval.1 - interval.0 {\n      0 | 1 => String::from(\"\
    NO\"),\n      2 => String::from(\"YES\"),\n      _ => if is_prime(interval.1 -\
    \ interval.0) {\n        String::from(\"YES\")\n      } else {\n        String::from(\"\
    NO\")\n      }\n    }\n  } else {\n    String::from(\"NO\")\n  }", "    let (a1,\
    \ b1) = interval1;\n    let (a2, b2) = interval2;\n    let (start, end) = if a1\
    \ < a2 {\n        (a2, b1)\n    } else {\n        (a1, b2)\n    };\n    let length\
    \ = end - start;\n    if length <= 0 {\n        String::from(\"NO\")\n    } else\
    \ {\n        for i in 2..length {\n            if length % i == 0 {\n        \
    \        return String::from(\"NO\");\n            }\n        }\n        String::from(\"\
    YES\")\n    }", "    if (interval1.0 > interval2.1) || (interval2.0 > interval1.1)\
    \ {\n        return String::from(\"NO\");\n    }\n\n    let mut start = interval1.0;\n\
    \    let mut end = interval1.1;\n\n    if (interval2.0 > interval1.0) && (interval2.0\
    \ < interval1.1) {\n        start = interval2.0;\n    }\n\n    if (interval2.1\
    \ > interval1.0) && (interval2.1 < interval1.1) {\n        end = interval2.1;\n\
    \    }\n\n    if prime((end - start + 1) as usize) {\n        return String::from(\"\
    YES\");\n    }\n    return String::from(\"NO\");", "    let start = max(interval1.0,\
    \ interval2.0);\n    let end = min(interval1.1, interval2.1);\n    if start >\
    \ end {\n        String::from(\"NO\")\n    } else {\n        let result = (end\
    \ - start + 1) as u64;\n        if is_prime(result) {\n            String::from(\"\
    YES\")\n        } else {\n            String::from(\"NO\")\n        }\n    }",
  "    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    let interval = (start, end);\n    if interval.0 > interval.1 { return String::from(\"\
    NO\"); }\n    let mut len = 0;\n    for i in interval.0..interval.1 + 1 {\n  \
    \      len += 1;\n    }\n    let sq = ((len as f64).sqrt() as isize) + 1;\n  \
    \  for i in 2..sq {\n        if len % i == 0 { return String::from(\"NO\"); }\n\
    \    }\n    String::from(\"YES\")", "    let (interval1_start, interval1_end)\
    \ = interval1;\n    let (interval2_start, interval2_end) = interval2;\n    let\
    \ max_start = std::cmp::max(interval1_start, interval2_start);\n    let min_end\
    \ = std::cmp::min(interval1_end, interval2_end);\n    if max_start >= min_end\
    \ {\n        return String::from(\"NO\");\n    }\n    if is_prime(min_end - max_start)\
    \ {\n        return String::from(\"YES\");\n    }\n    String::from(\"NO\")",
  "    // let start = isize::max(interval1.0, interval2.0);\n    // let end = isize::min(interval1.1,\
    \ interval2.1);\n    // let length = end - start;\n    // if length < 2 {\n  \
    \  //     String::from(\"NO\")\n    // } else {\n    //     (2..length).all(|x|\
    \ length % x != 0) ? String::from(\"YES\") : String::from(\"NO\")\n    // }\n\
    \    match (interval1, interval2) {\n        ((a, b), (c, d)) if b < c || d <\
    \ a => String::from(\"NO\"),\n        ((a, b), (c, d)) => {\n            let (start,\
    \ end) = (isize::max(a, c), isize::min(b, d));\n            let length = end -\
    \ start;\n            if length < 2 {\n                String::from(\"NO\")\n\
    \            } else {\n                (2..length).all(|x| length % x != 0) ?\
    \ String::from(\"YES\") : String::from(\"NO\")\n            }\n        }\n   \
    \ }", "    let (interval1_start, interval1_end) = interval1;\n    let (interval2_start,\
    \ interval2_end) = interval2;\n    if interval1_start > interval1_end || interval2_start\
    \ > interval2_end {\n        return String::from(\"NO\");\n    }\n    if interval1_end\
    \ < interval2_start || interval2_end < interval1_start {\n        return String::from(\"\
    NO\");\n    }\n    let interval_start = interval1_start.max(interval2_start);\n\
    \    let interval_end = interval1_end.min(interval2_end);\n    let diff = interval_end\
    \ - interval_start;\n    if diff == 0 {\n        return String::from(\"NO\");\n\
    \    }\n    if diff == 1 {\n        return String::from(\"YES\");\n    }\n   \
    \ let mut is_prime = true;\n    for i in 2..=diff {\n        if diff % i == 0\
    \ {\n            is_prime = false;\n            break;\n        }\n    }\n   \
    \ if is_prime {\n        String::from(\"YES\")\n    } else {\n        String::from(\"\
    NO\")\n    }", "    match (interval1, interval2) {\n        ((x1, y1), (x2, y2))\
    \ if x1 > y2 || x2 > y1 => \"NO\".to_string(),\n        ((x1, y1), (x2, y2)) =>\
    \ {\n            let n = std::cmp::max(x1, x2) - std::cmp::min(y1, y2);\n    \
    \        if n < 2 { \"NO\".to_string() } else {\n                match (2..n).find(|x|\
    \ n % x == 0) {\n                    Some(_) => \"NO\".to_string(),\n        \
    \            None => \"YES\".to_string()\n                }\n            }\n \
    \       }\n    }", "    fn is_prime(n: usize) -> bool {\n        if n < 2 {\n\
    \            return false;\n        }\n\n        for i in 2..n {\n           \
    \ if n % i == 0 {\n                return false;\n            }\n        }\n\n\
    \        true\n    }\n\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n\n    if start1 > end1 || start2 > end2 {\n        return\
    \ String::from(\"NO\");\n    }\n\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n\n    if start > end {\n        return\
    \ String::from(\"NO\");\n    }\n\n    match is_prime((end - start + 1) as usize)\
    \ {\n        true => String::from(\"YES\"),\n        false => String::from(\"\
    NO\"),\n    }", "    let start = interval1.0.max(interval2.0);\n    let end =\
    \ interval1.1.min(interval2.1);\n    if start > end {\n        String::from(\"\
    NO\")\n    } else {\n        String::from(if is_prime(end - start + 1) { \"YES\"\
    \ } else { \"NO\" })\n    }", "    let (l1, r1) = interval1;\n    let (l2, r2)\
    \ = interval2;\n    if l1 > r1 || l2 > r2 {\n        String::from(\"NO\")\n  \
    \  } else if l1 > r2 || l2 > r1 {\n        String::from(\"NO\")\n    } else {\n\
    \        if l1 > l2 {\n            is_prime(r2 - l1 + 1)\n        } else {\n \
    \           is_prime(r1 - l2 + 1)\n        }\n    }", "    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (min, max) = (std::cmp::max(start1,\
    \ start2), std::cmp::min(end1, end2));\n    if min > max {\n        return String::from(\"\
    NO\");\n    }\n    let size = (max - min) + 1;\n    if is_prime(size) {\n    \
    \    return String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let\
    \ start = isize::max(interval1.0, interval2.0);\n    let end = isize::min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return String::from(\"NO\");\n\
    \    }\n    if prime(end - start + 1) {\n        return String::from(\"YES\");\n\
    \    }\n    String::from(\"NO\")", "    let mut intersection = (0, 0);\n    if\
    \ interval1.0 <= interval2.0 && interval2.0 <= interval1.1 {\n        intersection.0\
    \ = interval2.0;\n    } else if interval2.0 <= interval1.0 && interval1.0 <= interval2.1\
    \ {\n        intersection.0 = interval1.0;\n    }\n    if interval1.0 <= interval2.1\
    \ && interval2.1 <= interval1.1 {\n        intersection.1 = interval2.1;\n   \
    \ } else if interval2.0 <= interval1.1 && interval1.1 <= interval2.1 {\n     \
    \   intersection.1 = interval1.1;\n    }\n    let length = intersection.1 - intersection.0;\n\
    \    if length <= 0 {\n        return String::from(\"NO\");\n    } else if length\
    \ == 1 {\n        return String::from(\"NO\");\n    } else if length == 2 {\n\
    \        return String::from(\"YES\");\n    } else {\n        for i in 2..length\
    \ {\n            if length % i == 0 {\n                return String::from(\"\
    NO\");\n            }\n        }\n        return String::from(\"YES\");\n    }",
  "    let max = interval1.0.max(interval2.0);\n    let min = interval1.1.min(interval2.1);\n\
    \    if max > min { return String::from(\"NO\"); }\n    let interval_len = min\
    \ - max + 1;\n    if interval_len == 2 { return String::from(\"YES\"); }\n   \
    \ if interval_len == 1 { return String::from(\"NO\"); }\n    if interval_len %\
    \ 2 == 0 { return String::from(\"NO\"); }\n    for i in (3..=interval_len).step_by(2)\
    \ {\n        if interval_len % i == 0 { return String::from(\"NO\"); }\n    }\n\
    \    String::from(\"YES\")", "    let (mut start, mut end) = (0, 0);\n    if interval1.0\
    \ > interval2.0 {\n        start = interval1.0;\n    } else {\n        start =\
    \ interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n        end = interval1.1;\n\
    \    } else {\n        end = interval2.1;\n    }\n    if start > end {\n     \
    \   return String::from(\"NO\");\n    }\n    if is_prime((end - start) as usize)\
    \ {\n        return String::from(\"YES\");\n    }\n    String::from(\"NO\")",
  "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let\
    \ start = start1.max(start2);\n    let end = end1.min(end2);\n    if start > end\
    \ {\n        return String::from(\"NO\");\n    }\n    let length = end - start\
    \ + 1;\n    if is_prime(length) {\n        return String::from(\"YES\");\n   \
    \ }\n    String::from(\"NO\")", "    let (interval1_max, interval1_min) = if interval1.0\
    \ > interval1.1 {\n        (interval1.0, interval1.1)\n    } else {\n        (interval1.1,\
    \ interval1.0)\n    };\n    let (interval2_max, interval2_min) = if interval2.0\
    \ > interval2.1 {\n        (interval2.0, interval2.1)\n    } else {\n        (interval2.1,\
    \ interval2.0)\n    };\n    if interval1_max < interval2_min || interval2_max\
    \ < interval1_min {\n        String::from(\"NO\")\n    } else {\n        let max\
    \ = interval1_max.min(interval2_max);\n        let min = interval1_min.max(interval2_min);\n\
    \        if (max - min + 1) % 2 == 0 {\n            String::from(\"NO\")\n   \
    \     } else {\n            let mut i = 3;\n            while i * i <= (max -\
    \ min + 1) {\n                if (max - min + 1) % i == 0 {\n                \
    \    return String::from(\"NO\");\n                }\n                i += 2;\n\
    \            }\n            String::from(\"YES\")\n        }\n    }", "    let\
    \ (a1, b1) = interval1;\n    let (a2, b2) = interval2;\n    let range1 = a1..b1\
    \ + 1;\n    let range2 = a2..b2 + 1;\n    let mut v: Vec<isize> = range1.filter(|&x|\
    \ range2.contains(&x)).collect();\n    v.sort();\n    let len = v.len();\n   \
    \ if len == 0 {\n        return String::from(\"NO\");\n    } else if len == 1\
    \ {\n        return String::from(\"YES\");\n    } else {\n        for i in 2..len\
    \ {\n            if len % i == 0 {\n                return String::from(\"NO\"\
    );\n            }\n        }\n        return String::from(\"YES\");\n    }", " \
    \   // return \"NO\";\n    let (start1, end1) = interval1;\n    let (start2, end2)\
    \ = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        String::from(\"NO\")\n    } else {\n        String::from(if\
    \ is_prime(end - start + 1) { \"YES\" } else { \"NO\" })\n    }", "    let mut\
    \ start = cmp::max(interval1.0, interval2.0);\n    let mut end = cmp::min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return String::from(\"NO\");\n\
    \    }\n    let len = end - start + 1;\n    let mut flag = true;\n    for i in\
    \ 2..len {\n        if len % i == 0 {\n            flag = false;\n           \
    \ break;\n        }\n    }\n    if flag {\n        return String::from(\"YES\"\
    );\n    }\n    String::from(\"NO\")", "    let mut start = interval1.0;\n    let\
    \ mut end = interval1.1;\n    let mut start2 = interval2.0;\n    let mut end2\
    \ = interval2.1;\n    if start > end {\n        std::mem::swap(&mut start, &mut\
    \ end);\n    }\n    if start2 > end2 {\n        std::mem::swap(&mut start2, &mut\
    \ end2);\n    }\n    let start = start.max(start2);\n    let end = end.min(end2);\n\
    \    if start > end {\n        String::from(\"NO\")\n    } else {\n        if\
    \ is_prime(end - start + 1) {\n            String::from(\"YES\")\n        } else\
    \ {\n            String::from(\"NO\")\n        }\n    }", "    let mut in1 = interval1;\n\
    \    let mut in2 = interval2;\n    in1.0 = in1.0.max(in2.0);\n    in1.1 = in1.1.min(in2.1);\n\
    \    let (start, end) = (in1.0, in1.1);\n    if start > end {\n        return\
    \ String::from(\"NO\");\n    }\n    let mut arr: Vec<_> = (start..=end).collect();\n\
    \    arr.retain(|&x| x > 1);\n    for i in 2..arr.len() {\n        arr.retain(|&x|\
    \ x == i || x % i != 0);\n    }\n    if arr.len() == 0 {\n        return String::from(\"\
    NO\");\n    }\n    return String::from(\"YES\");", "    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    let\
    \ inter = end - start;\n    // if (start >= end) {\n    //     return String::from(\"\
    NO\");\n    // }\n    for div in 2..inter {\n        if inter % div == 0 {\n \
    \           return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    // Your code here!\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return String::from(\"NO\");\n    }\n    let min =\
    \ if interval1.0 > interval2.0 { interval1.0 } else { interval2.0 };\n    let\
    \ max = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1 };\n \
    \   if min > max {\n        return String::from(\"NO\");\n    }\n    let len =\
    \ (max - min) + 1;\n    if len <= 2 {\n        return String::from(\"NO\");\n\
    \    }\n    if len % 2 == 0 {\n        return String::from(\"NO\");\n    }\n \
    \   for i in 2..(len as f64).sqrt() as isize + 1 {\n        if len % i == 0 {\n\
    \            return String::from(\"NO\");\n        }\n    }\n    String::from(\"\
    YES\")", "    let res = interval1.0.max(interval2.0)\n                       .min(interval1.1)\n\
    \                       .max(interval2.0)\n                       .min(interval2.1)\n\
    \                       .max(interval1.0);\n    if res < 0 { String::from(\"NO\"\
    ) }\n    else {\n        if res.is_prime() { String::from(\"YES\") }\n       \
    \ else { String::from(\"NO\") }\n    }", "    if interval1.0 <= interval2.1 &&\
    \ interval2.0 <= interval1.1 {\n        let interval = (interval1.0.max(interval2.0),\
    \ interval1.1.min(interval2.1));\n        if interval.1 - interval.0 > 0 && primes::is_prime(interval.1\
    \ - interval.0) {\n            return String::from(\"YES\");\n        }\n    }\n\
    \    String::from(\"NO\")", "    let mut start = interval1.0;\n    let mut end\
    \ = interval1.1;\n    if interval2.0 > start {\n        start = interval2.0;\n\
    \    }\n    if interval2.1 < end {\n        end = interval2.1;\n    }\n    if\
    \ end <= start {\n        return String::from(\"NO\");\n    }\n    let mut n =\
    \ end - start + 1;\n    if n == 2 {\n        return String::from(\"YES\");\n \
    \   }\n    if n % 2 == 0 {\n        n /= 2;\n    }\n    loop {\n        if n <=\
    \ 3 {\n            break;\n        }\n        if n % 2 == 0 {\n            return\
    \ String::from(\"NO\");\n        }\n        let mut i = 3;\n        while i *\
    \ i <= n {\n            if n % i == 0 {\n                return String::from(\"\
    NO\");\n            }\n            i += 2;\n        }\n        break;\n    }\n\
    \    String::from(\"YES\")", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end1 || start2 > end2 {\n        return\
    \ String::from(\"NO\");\n    }\n    if end1 < start2 || end2 < start1 {\n    \
    \    return String::from(\"NO\");\n    }\n    let result = if start1 < start2\
    \ {\n        if end1 < end2 {\n            (start2, end1)\n        } else {\n\
    \            (start2, end2)\n        }\n    } else {\n        if end1 < end2 {\n\
    \            (start1, end1)\n        } else {\n            (start1, end2)\n  \
    \      }\n    };\n    let mut i = 2;\n    let length = result.1 - result.0 + 1;\n\
    \    let length = if length < 0 {\n        -length\n    } else {\n        length\n\
    \    };\n    while i < length {\n        if length % i == 0 {\n            return\
    \ String::from(\"NO\");\n        }\n        i += 1;\n    }\n    String::from(\"\
    YES\")", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    let mut ans = \"NO\";\n    if start1\
    \ > start2 {\n        start = start1;\n    } else {\n        start = start2;\n\
    \    }\n    if end1 < end2 {\n        end = end1;\n    } else {\n        end =\
    \ end2;\n    }\n    if start < end {\n        let mut len = (end - start) + 1;\n\
    \        if len % 2 == 0 {\n            ans = \"NO\";\n        } else {\n    \
    \        for i in 2..len {\n                if len % i == 0 {\n              \
    \      ans = \"NO\";\n                    break;\n                }\n        \
    \    }\n            if ans == \"NO\" {\n                ans = \"YES\";\n     \
    \       }\n        }\n    }\n    return String::from(ans);"]
stop_tokens:
- "\n}"
