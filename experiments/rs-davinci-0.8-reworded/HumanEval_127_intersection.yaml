name: HumanEval_127_intersection
language: rs
prompt: "/// You are given two intervals,\n/// where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed\
  \ which means that the interval (start, end)\n/// includes both start and end.\n\
  /// For each given interval, it is assumed that its start is less or equal its end.\n\
  /// Your task is to determine whether the length of intersection of these two \n\
  /// intervals is a prime number.\n/// Example, the intersection of the intervals\
  \ (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n\
  /// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise,\
  \ return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n///\
  \ [input/output] samples:\n/// >>> intersection((1, 2), (2, 3))\n/// String::from(\"\
  NO\")\n/// >>> intersection((-1, 1), (0, 4))\n/// String::from(\"NO\")\n/// >>>\
  \ intersection((-3, -1), (-5, 5))\n/// String::from(\"YES\")\nfn intersection(interval1:\
  \ (isize, isize), interval2: (isize, isize)) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
  \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
  YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
  \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
  \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
  NO\"));\n}\n"
completions: ["    let (_, end1) = interval1;\n    let (start2, _) = interval2;\n\
    \    let result = if end1 < start2 {\n        0\n    } else {\n        end1 -\
    \ start2 + 1\n    };\n    let is_prime = is_prime(result);\n    if is_prime {\n\
    \        String::from(\"YES\")\n    } else {\n        String::from(\"NO\")\n \
    \   }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n   \
    \     return String::from(\"NO\");\n    }\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if end <= start {\n        return\
    \ String::from(\"NO\");\n    }\n    let n = end - start + 1;\n    for i in 2..(n\
    \ as f64).sqrt() as isize + 1 {\n        if n % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let (a1, b1) = interval1;\n\
    \    let (a2, b2) = interval2;\n    if b1 < a2 || b2 < a1 {\n        return String::from(\"\
    NO\");\n    }\n    let (i1, i2) = (max(a1, a2), min(b1, b2));\n    if is_prime(i2\
    \ - i1 + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let intersection = match (interval1, interval2) {\n        ((a, b),\
    \ (c, d)) if b < c || d < a => None,\n        ((a, b), (c, d)) => Some((a.max(c),\
    \ b.min(d))),\n    };\n    match intersection {\n        None => String::from(\"\
    NO\"),\n        Some((start, end)) => {\n            if end < start {\n      \
    \          String::from(\"NO\")\n            } else {\n                let length\
    \ = end - start + 1;\n                if is_prime(length) {\n                \
    \    String::from(\"YES\")\n                } else {\n                    String::from(\"\
    NO\")\n                }\n            }\n        }\n    }", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return String::from(\"\
    NO\");\n    }\n    let inter = (\n        cmp::max(interval1.0, interval2.0),\n\
    \        cmp::min(interval1.1, interval2.1),\n    );\n    if is_prime(inter.1\
    \ - inter.0 + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let mut res = (0, 0);\n    if interval1.0 <= interval2.0 && interval2.0\
    \ <= interval1.1 {\n        res.0 = interval2.0;\n    } else if interval2.0 <=\
    \ interval1.0 && interval1.0 <= interval2.1 {\n        res.0 = interval1.0;\n\
    \    }\n    if interval1.0 <= interval2.1 && interval2.1 <= interval1.1 {\n  \
    \      res.1 = interval2.1;\n    } else if interval2.0 <= interval1.1 && interval1.1\
    \ <= interval2.1 {\n        res.1 = interval1.1;\n    }\n    if res.0 == 0 &&\
    \ res.1 == 0 {\n        String::from(\"NO\")\n    } else {\n        if is_prime(res.1\
    \ - res.0) {\n            String::from(\"YES\")\n        } else {\n          \
    \  String::from(\"NO\")\n        }\n    }", "    let it_min = interval1.0.max(interval2.0);\n\
    \    let it_max = interval1.1.min(interval2.1);\n    if it_min > it_max {\n  \
    \      return String::from(\"NO\");\n    }\n    let mut it_len = (it_max - it_min)\
    \ + 1;\n    if it_len == 1 {\n        return String::from(\"YES\");\n    }\n \
    \   let mut i = 2;\n    loop {\n        if i * i > it_len {\n            return\
    \ String::from(\"YES\");\n        }\n        if it_len % i == 0 {\n          \
    \  return String::from(\"NO\");\n        }\n        i += 1;\n    }", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return String::from(\"\
    NO\");\n    }\n    let low = std::cmp::max(interval1.0, interval2.0);\n    let\
    \ high = std::cmp::min(interval1.1, interval2.1);\n    match (low..=high).count()\
    \ {\n        x if x <= 2 => String::from(\"NO\"),\n        x => {\n          \
    \  for i in 2..(x-1) {\n                if x % i == 0 {\n                    return\
    \ String::from(\"NO\");\n                }\n            }\n            String::from(\"\
    YES\")\n        }\n    }", "    // Check if the intervals intersect\n    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return String::from(\"\
    NO\");\n    }\n    // intersection starts at the maximum of the two intervals'\
    \ minimums\n    let start = std::cmp::max(interval1.0, interval2.0);\n    // intersection\
    \ ends at the minimum of the two intervals' maximums\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    // find the length of the intersection\n    let length =\
    \ end - start + 1;\n    // check if the length is prime\n    if length < 2 {\n\
    \        return String::from(\"NO\");\n    }\n    let mut factor = 2;\n    while\
    \ factor * factor <= length {\n        if length % factor == 0 {\n           \
    \ return String::from(\"NO\");\n        }\n        factor += 1;\n    }\n    String::from(\"\
    YES\")", "    let mut sorted = [interval1, interval2];\n    sorted.sort_by(|&(a,\
    \ b), &(c, d)| a.cmp(&c));\n    let &(a, b) = sorted.get(0).unwrap();\n    let\
    \ &(c, d) = sorted.get(1).unwrap();\n    if a > d || b < c {\n        return String::from(\"\
    NO\");\n    }\n    let i = (c, d).cmp(&(a, b));\n    let k = match i {\n     \
    \   Ordering::Equal => (a, b),\n        Ordering::Less => (c, b),\n        Ordering::Greater\
    \ => (a, d),\n    };\n    let g = k.1 - k.0;\n    let mut is_prime = true;\n \
    \   for j in 2..g {\n        if g % j == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime && g > 1 {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (interval1_start,\
    \ interval1_end) = interval1;\n    let (interval2_start, interval2_end) = interval2;\n\
    \    if interval1_start >= interval2_end || interval2_start >= interval1_end {\n\
    \        String::from(\"NO\")\n    } else {\n        let intersection_start =\
    \ if interval1_start > interval2_start {\n            interval1_start\n      \
    \  } else {\n            interval2_start\n        };\n        let intersection_end\
    \ = if interval1_end < interval2_end {\n            interval1_end\n        } else\
    \ {\n            interval2_end\n        };\n        if is_prime(intersection_end\
    \ - intersection_start) {\n            String::from(\"YES\")\n        } else {\n\
    \            String::from(\"NO\")\n        }\n    }", "    let mut start = interval1.0;\n\
    \    let mut end = interval1.1;\n    if interval2.0 > start {\n        start =\
    \ interval2.0;\n    }\n    if interval2.1 < end {\n        end = interval2.1;\n\
    \    }\n    if start >= end {\n        return String::from(\"NO\");\n    }\n \
    \   let mut counter = 0;\n    for i in start..end {\n        if i == 1 {\n   \
    \         continue;\n        }\n        let mut is_prime = true;\n        for\
    \ j in 2..i {\n            if i % j == 0 {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if is_prime {\n   \
    \         counter += 1;\n        }\n    }\n    return if counter == 0 {\n    \
    \    String::from(\"NO\")\n    } else {\n        String::from(\"YES\")\n    };",
  "    let (mut start, mut end) = (0, 0);\n    if interval1.0 > interval2.0 {\n  \
    \      start = interval1.0;\n    } else {\n        start = interval2.0;\n    }\n\
    \    if interval1.1 < interval2.1 {\n        end = interval1.1;\n    } else {\n\
    \        end = interval2.1;\n    }\n    let len = end - start;\n    if start >\
    \ end {\n        return String::from(\"NO\");\n    }\n    if is_prime(len) {\n\
    \        return String::from(\"YES\");\n    }\n    String::from(\"NO\")", "  \
    \  if interval1.0 < interval2.0 {\n        if interval1.1 < interval2.0 {\n  \
    \          return String::from(\"NO\");\n        }\n        if interval1.1 < interval2.1\
    \ {\n            return is_prime(interval1.1 - interval2.0 + 1);\n        }\n\
    \        return is_prime(interval2.1 - interval2.0 + 1);\n    } else if interval1.0\
    \ == interval2.0 {\n        if interval1.1 < interval2.1 {\n            return\
    \ is_prime(interval1.1 - interval1.0 + 1);\n        }\n        return is_prime(interval2.1\
    \ - interval2.0 + 1);\n    } else {\n        if interval2.1 < interval1.0 {\n\
    \            return String::from(\"NO\");\n        }\n        if interval2.1 <\
    \ interval1.1 {\n            return is_prime(interval2.1 - interval1.0 + 1);\n\
    \        }\n        return is_prime(interval1.1 - interval1.0 + 1);\n    }", " \
    \   let inter = (interval1.0..interval1.1).intersection(&(interval2.0..interval2.1));\n\
    \    match inter {\n        None => String::from(\"NO\"),\n        Some(s) =>\
    \ {\n            let mut is_prime = true;\n            for i in 2..(s.len() -\
    \ 1) {\n                if s.len() % i == 0 {\n                    is_prime =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       if is_prime {\n                String::from(\"YES\")\n            } else\
    \ {\n                String::from(\"NO\")\n            }\n        }\n    }", " \
    \   if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ String::from(\"NO\");\n    }\n    let mut min = interval1.0;\n    let mut max\
    \ = interval1.1;\n    if interval2.0 > min {\n        min = interval2.0;\n   \
    \ }\n    if interval2.1 < max {\n        max = interval2.1;\n    }\n    let length\
    \ = (max - min + 1) as usize;\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    if\
    \ primes.contains(&length) {\n        return String::from(\"YES\");\n    }\n \
    \   String::from(\"NO\")", "    let int1_min = interval1.0.min(interval1.1);\n\
    \    let int1_max = interval1.0.max(interval1.1);\n    let int2_min = interval2.0.min(interval2.1);\n\
    \    let int2_max = interval2.0.max(interval2.1);\n    let int1_range = int1_max\
    \ - int1_min;\n    let int2_range = int2_max - int2_min;\n    if int1_range ==\
    \ 0 || int2_range == 0 {\n        return String::from(\"NO\");\n    }\n    if\
    \ int1_max < int2_min || int2_max < int1_min {\n        return String::from(\"\
    NO\");\n    }\n    let int_start = int1_min.max(int2_min);\n    let int_end =\
    \ int1_max.min(int2_max);\n    let int_range = int_end - int_start;\n    let mut\
    \ is_prime = true;\n    for i in 2..(int_range - 1) {\n        if int_range %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let start = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0\
    \ };\n    let end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    if start > end {\n        return String::from(\"NO\");\n    }\n    let\
    \ length = end - start + 1;\n    match length {\n        1 => String::from(\"\
    NO\"),\n        2 => String::from(\"YES\"),\n        3 => String::from(\"YES\"\
    ),\n        5 => String::from(\"YES\"),\n        7 => String::from(\"YES\"),\n\
    \        _ => {\n            if length % 2 == 0 || length % 3 == 0 || length %\
    \ 5 == 0 || length % 7 == 0 {\n                String::from(\"NO\")\n        \
    \    } else {\n                String::from(\"YES\")\n            }\n        }\n\
    \    }", "    let s1 = interval1.0;\n    let e1 = interval1.1;\n    let s2 = interval2.0;\n\
    \    let e2 = interval2.1;\n    let mut start = std::cmp::max(s1, s2);\n    let\
    \ mut end = std::cmp::min(e1, e2);\n    // no intersection\n    if end < start\
    \ {\n        return String::from(\"NO\");\n    }\n    let mut res = true;\n  \
    \  while start <= end {\n        if start < 2 {\n            start += 1;\n   \
    \         continue;\n        }\n        res = true;\n        for i in 2..start\
    \ {\n            if start % i == 0 {\n                res = false;\n         \
    \       break;\n            }\n        }\n        if res {\n            break;\n\
    \        }\n        start += 1;\n    }\n    if res {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }", "    let (mut l, mut\
    \ r) = (interval1.0, interval1.1);\n    l = l.max(interval2.0);\n    r = r.min(interval2.1);\n\
    \    if l > r {\n        return String::from(\"NO\");\n    }\n    match (l - r)\
    \ as usize {\n        0 | 1 => String::from(\"NO\"),\n        n => {\n       \
    \     if is_prime(n) {\n                String::from(\"YES\")\n            } else\
    \ {\n                String::from(\"NO\")\n            }\n        }\n    }"]
stop_tokens:
- "\n}"
