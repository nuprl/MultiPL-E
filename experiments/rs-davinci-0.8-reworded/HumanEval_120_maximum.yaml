name: HumanEval_120_maximum
language: rs
prompt: "/// Given a vector arr of integers and a positive integer k, return a sorted\
  \ vector \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n\
  /// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n/// >>>\
  \ maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
  \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
  \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
  \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
  \ k: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
  \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
  \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n \
  \   assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
  \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
  \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0,\
  \ 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n\
  \    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
  \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
  \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
  }\n"
completions: ["    let mut result = arr.clone();\n    let mut n = arr.len();\n   \
    \ for i in 0..k {\n        let mut max_index = i;\n        for j in i..n {\n \
    \           if result[j] > result[max_index] {\n                max_index = j;\n\
    \            }\n        }\n        result.swap(i, max_index);\n        n -= 1;\n\
    \    }\n    result.truncate(k as usize);\n    result", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter().take(k as usize).map(|&v|\
    \ v).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let len = arr.len();\n    if k == len as isize {\
    \ return arr; }\n    let mut arr = arr;\n    arr.sort();\n    let k = (k-1) as\
    \ usize;\n    arr.drain(..len-k-1).collect()", "    let mut k = k as usize;\n\
    \    let n = arr.len();\n    if k >= n {\n        return arr;\n    }\n    let\
    \ mut ans = vec![];\n    for i in 0..n {\n        while k > 0 && !ans.is_empty()\
    \ && ans[ans.len() - 1] < arr[i] {\n            ans.pop();\n            k -= 1;\n\
    \        }\n        ans.push(arr[i]);\n    }\n    ans.pop();\n    while k > 0\
    \ {\n        ans.pop();\n        k -= 1;\n    }\n    ans", "    assert!(k <= arr.len()\
    \ as isize);\n    let mut temp = Vec::with_capacity(k as usize);\n    for i in\
    \ 0..k {\n        if temp.is_empty() {\n            temp.push(arr[i as usize]);\n\
    \        } else {\n            temp.insert(0, arr[i as usize]);\n        }\n \
    \   }\n    for i in k..arr.len() as isize {\n        if arr[i as usize] > temp[0]\
    \ {\n            temp.remove(0);\n            temp.insert(0, arr[i as usize]);\n\
    \        }\n    }\n    temp", "    if k == 0 {\n        return vec![];\n    }\n\
    \    if k == arr.len() as isize {\n        return arr;\n    }\n    let mut max\
    \ = vec![];\n    for i in 0..k {\n        max.push(arr[i as usize]);\n    }\n\
    \    max.sort();\n    for i in k..arr.len() as isize {\n        let j = 0;\n \
    \       while j < k {\n            if arr[i as usize] > max[j as usize] {\n  \
    \              max.remove(j as usize);\n                max.insert(j as usize,\
    \ arr[i as usize]);\n                break;\n            }\n            j += 1;\n\
    \        }\n    }\n    max", "    let mut max = Vec::with_capacity(k as usize);\n\
    \    for n in arr {\n        let mut i = max.len();\n        while i > 0 && max[i\
    \ - 1] < n {\n            i -= 1;\n        }\n        if i < max.len() {\n   \
    \         max[i] = n;\n        } else if max.len() < k as usize {\n          \
    \  max.push(n);\n        }\n    }\n    max", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.truncate(k as usize);\n    arr", '    unimplemented!();',
  "    let n = arr.len();\n    let mut heap = BinaryHeap::new();\n    let mut res\
    \ = Vec::with_capacity(k as usize);\n    let mut count = 0;\n    while count <\
    \ k && count < n {\n        heap.push((-arr[count], count));\n        count +=\
    \ 1;\n    }\n    while count < n {\n        if arr[count] > heap.peek().unwrap().0\
    \ {\n            heap.pop();\n            heap.push((-arr[count], count));\n \
    \       }\n        count += 1;\n    }\n    while !heap.is_empty() {\n        res.push(-heap.pop().unwrap().0);\n\
    \    }\n    res", "    // Maximum: sort and take the last k elements\n    arr.iter().cloned().collect::<Vec<isize>>().sort();\n\
    \    return arr.iter().cloned().skip(arr.len() - k as usize).collect();", "  \
    \  let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.iter().rev().take(k\
    \ as usize).map(|x| *x).collect()", "    let mut max_k = Vec::with_capacity(k\
    \ as usize);\n    for num in arr {\n        if max_k.len() < k as usize {\n  \
    \          if let Err(index) = max_k.binary_search(&num) {\n                max_k.insert(index,\
    \ num);\n            }\n        } else if num > max_k[0] {\n            if let\
    \ Err(index) = max_k.binary_search(&num) {\n                max_k.insert(index,\
    \ num);\n            }\n            max_k.remove(0);\n        }\n    }\n    max_k",
  "    let mut result = vec![0; k as usize];\n    let mut idx = 0;\n    for num in\
    \ arr {\n        if idx < k as usize {\n            result[idx] = num;\n     \
    \       idx += 1;\n        } else {\n            for i in 0..k as usize {\n  \
    \              if result[i] < num {\n                    result[i] = num;\n  \
    \                  break;\n                }\n            }\n        }\n    }\n\
    \    result.sort();\n    result", "    // The worst case is that the vector is\
    \ sorted in descending order.\n    // O(n*k) time, O(k) space.\n    let k = k\
    \ as usize;\n    if k >= arr.len() {\n        return arr;\n    }\n    let mut\
    \ res = arr[..k].to_vec();\n    res.sort();\n    for i in k..arr.len() {\n   \
    \     if res[0] < arr[i] {\n            let mut insert_index = 0;\n          \
    \  for j in 0..k {\n                if res[j] < arr[i] {\n                   \
    \ insert_index = j;\n                } else {\n                    break;\n  \
    \              }\n            }\n            res.insert(insert_index, arr[i]);\n\
    \            res.pop();\n        }\n    }\n    res", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        res.push(arr[i as usize]);\n    }\n\
    \    res.sort();\n    for i in k..arr.len() as isize {\n        if arr[i as usize]\
    \ > res[0] {\n            res.remove(0);\n            res.push(arr[i as usize]);\n\
    \            res.sort();\n        }\n    }\n    res", '    unimplemented!()',
  "    let n = arr.len();\n    let mut v = Vec::with_capacity(n);\n    for i in 0..n\
    \ {\n        while !v.is_empty() && v.len() + n - i > k as usize && v.last().unwrap()\
    \ < &arr[i] {\n            v.pop();\n        }\n        if v.len() < k as usize\
    \ {\n            v.push(arr[i]);\n        }\n    }\n    v"]
stop_tokens:
- "\n}"
