name: HumanEval_120_maximum
language: rs
prompt: "/// Given a vector arr of integers and a positive integer k, return a sorted\
  \ vector \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n\
  /// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n/// >>>\
  \ maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
  \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
  \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
  \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
  \ k: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
  \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
  \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n \
  \   assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
  \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
  \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0,\
  \ 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n\
  \    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
  \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
  \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
  }\n"
completions: ["    let mut result = arr.clone();\n    let mut n = arr.len();\n   \
    \ for i in 0..k {\n        let mut max_index = i;\n        for j in i..n {\n \
    \           if result[j] > result[max_index] {\n                max_index = j;\n\
    \            }\n        }\n        result.swap(i, max_index);\n        n -= 1;\n\
    \    }\n    result.truncate(k as usize);\n    result", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter().take(k as usize).map(|&v|\
    \ v).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let len = arr.len();\n    if k == len as isize {\
    \ return arr; }\n    let mut arr = arr;\n    arr.sort();\n    let k = (k-1) as\
    \ usize;\n    arr.drain(..len-k-1).collect()", "    let mut k = k as usize;\n\
    \    let n = arr.len();\n    if k >= n {\n        return arr;\n    }\n    let\
    \ mut ans = vec![];\n    for i in 0..n {\n        while k > 0 && !ans.is_empty()\
    \ && ans[ans.len() - 1] < arr[i] {\n            ans.pop();\n            k -= 1;\n\
    \        }\n        ans.push(arr[i]);\n    }\n    ans.pop();\n    while k > 0\
    \ {\n        ans.pop();\n        k -= 1;\n    }\n    ans", "    assert!(k <= arr.len()\
    \ as isize);\n    let mut temp = Vec::with_capacity(k as usize);\n    for i in\
    \ 0..k {\n        if temp.is_empty() {\n            temp.push(arr[i as usize]);\n\
    \        } else {\n            temp.insert(0, arr[i as usize]);\n        }\n \
    \   }\n    for i in k..arr.len() as isize {\n        if arr[i as usize] > temp[0]\
    \ {\n            temp.remove(0);\n            temp.insert(0, arr[i as usize]);\n\
    \        }\n    }\n    temp", "    if k == 0 {\n        return vec![];\n    }\n\
    \    if k == arr.len() as isize {\n        return arr;\n    }\n    let mut max\
    \ = vec![];\n    for i in 0..k {\n        max.push(arr[i as usize]);\n    }\n\
    \    max.sort();\n    for i in k..arr.len() as isize {\n        let j = 0;\n \
    \       while j < k {\n            if arr[i as usize] > max[j as usize] {\n  \
    \              max.remove(j as usize);\n                max.insert(j as usize,\
    \ arr[i as usize]);\n                break;\n            }\n            j += 1;\n\
    \        }\n    }\n    max", "    let mut max = Vec::with_capacity(k as usize);\n\
    \    for n in arr {\n        let mut i = max.len();\n        while i > 0 && max[i\
    \ - 1] < n {\n            i -= 1;\n        }\n        if i < max.len() {\n   \
    \         max[i] = n;\n        } else if max.len() < k as usize {\n          \
    \  max.push(n);\n        }\n    }\n    max", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.truncate(k as usize);\n    arr", '    unimplemented!();',
  "    let n = arr.len();\n    let mut heap = BinaryHeap::new();\n    let mut res\
    \ = Vec::with_capacity(k as usize);\n    let mut count = 0;\n    while count <\
    \ k && count < n {\n        heap.push((-arr[count], count));\n        count +=\
    \ 1;\n    }\n    while count < n {\n        if arr[count] > heap.peek().unwrap().0\
    \ {\n            heap.pop();\n            heap.push((-arr[count], count));\n \
    \       }\n        count += 1;\n    }\n    while !heap.is_empty() {\n        res.push(-heap.pop().unwrap().0);\n\
    \    }\n    res", "    // Maximum: sort and take the last k elements\n    arr.iter().cloned().collect::<Vec<isize>>().sort();\n\
    \    return arr.iter().cloned().skip(arr.len() - k as usize).collect();", "  \
    \  let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.iter().rev().take(k\
    \ as usize).map(|x| *x).collect()", "    let mut max_k = Vec::with_capacity(k\
    \ as usize);\n    for num in arr {\n        if max_k.len() < k as usize {\n  \
    \          if let Err(index) = max_k.binary_search(&num) {\n                max_k.insert(index,\
    \ num);\n            }\n        } else if num > max_k[0] {\n            if let\
    \ Err(index) = max_k.binary_search(&num) {\n                max_k.insert(index,\
    \ num);\n            }\n            max_k.remove(0);\n        }\n    }\n    max_k",
  "    let mut result = vec![0; k as usize];\n    let mut idx = 0;\n    for num in\
    \ arr {\n        if idx < k as usize {\n            result[idx] = num;\n     \
    \       idx += 1;\n        } else {\n            for i in 0..k as usize {\n  \
    \              if result[i] < num {\n                    result[i] = num;\n  \
    \                  break;\n                }\n            }\n        }\n    }\n\
    \    result.sort();\n    result", "    // The worst case is that the vector is\
    \ sorted in descending order.\n    // O(n*k) time, O(k) space.\n    let k = k\
    \ as usize;\n    if k >= arr.len() {\n        return arr;\n    }\n    let mut\
    \ res = arr[..k].to_vec();\n    res.sort();\n    for i in k..arr.len() {\n   \
    \     if res[0] < arr[i] {\n            let mut insert_index = 0;\n          \
    \  for j in 0..k {\n                if res[j] < arr[i] {\n                   \
    \ insert_index = j;\n                } else {\n                    break;\n  \
    \              }\n            }\n            res.insert(insert_index, arr[i]);\n\
    \            res.pop();\n        }\n    }\n    res", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        res.push(arr[i as usize]);\n    }\n\
    \    res.sort();\n    for i in k..arr.len() as isize {\n        if arr[i as usize]\
    \ > res[0] {\n            res.remove(0);\n            res.push(arr[i as usize]);\n\
    \            res.sort();\n        }\n    }\n    res", '    unimplemented!()',
  "    let n = arr.len();\n    let mut v = Vec::with_capacity(n);\n    for i in 0..n\
    \ {\n        while !v.is_empty() && v.len() + n - i > k as usize && v.last().unwrap()\
    \ < &arr[i] {\n            v.pop();\n        }\n        if v.len() < k as usize\
    \ {\n            v.push(arr[i]);\n        }\n    }\n    v", "    // Initialize\
    \ the result vector.\n    let mut result = Vec::new();\n    // Validate the k\
    \ parameter.\n    if k <= 0 || k as usize > arr.len() {\n        return result;\n\
    \    }\n    // Iterate over the input vector.\n    for (index, &number) in arr.iter().enumerate()\
    \ {\n        // If the result vector is empty, push the current number onto it.\n\
    \        if result.is_empty() {\n            result.push(number);\n        }\n\
    \        // If the result vector has less than k elements, push the current number\
    \ onto it.\n        else if result.len() < k as usize {\n            result.push(number);\n\
    \        }\n        // If the result vector has k elements, start pruning it.\n\
    \        else {\n            // If the current number is greater than the smallest\
    \ number in the vector,\n            // remove the smallest number from the vector\
    \ and push the current number onto it.\n            if number > *result.last().unwrap()\
    \ {\n                result.pop();\n                result.push(number);\n   \
    \         }\n            // If the current number is less than the smallest number\
    \ in the vector,\n            // look for a number that is less than the current\
    \ number and greater than the \n            // next smallest number in the vector.\
    \ If found, remove the largest such number\n            // from the vector and\
    \ push the current number onto it.\n            else {\n                // Initialize\
    \ the minimum number.\n                let mut min = *result.last().unwrap();\n\
    \                // Initialize the next minimum number.\n                let mut\
    \ next_min = *result.last().unwrap();\n                // Iterate over the vector\
    \ in reverse order.\n                for (rindex, &rnumber) in result.iter().rev().enumerate()\
    \ {\n                    // If the current number is greater than the next minimum\
    \ number\n                    // and less than the minimum number, set the next\
    \ minimum number\n                    // to the minimum number and set the minimum\
    \ number to the current number.\n                    if rnumber < min && rnumber\
    \ > next_min {\n                        next_min = min;\n                    \
    \    min = rnumber;\n                    }\n                    // If the current\
    \ number is less than the next minimum number and\n                    // greater\
    \ than the current number, set the", "    if k == 0 {\n        return vec![];\n\
    \    }\n    let mut vec = vec![];\n    for i in 0..k {\n        vec.push(arr[i\
    \ as usize]);\n    }\n    vec.sort();\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > vec[0] {\n            vec.remove(0);\n         \
    \   vec.push(arr[i as usize]);\n            vec.sort();\n        }\n    }\n  \
    \  vec", "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut start\
    \ = 0;\n    let mut end = arr.len() - 1;\n    while k > 0 {\n        let mid =\
    \ partition(&mut arr, start, end);\n        if mid == k - 1 {\n            break;\n\
    \        } else if mid < k - 1 {\n            start = mid + 1;\n            k\
    \ -= mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n\
    \    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut heap = BinaryHeap::with_capacity(k\
    \ as usize);\n    let mut answer = Vec::with_capacity(k as usize);\n    let mut\
    \ count = 0;\n    for num in arr {\n        if count < k {\n            heap.push(num);\n\
    \            count += 1;\n        } else {\n            if heap.peek().unwrap()\
    \ < &num {\n                heap.pop();\n                heap.push(num);\n   \
    \         }\n        }\n    }\n    for _ in 0..k {\n        answer.push(heap.pop().unwrap());\n\
    \    }\n    answer.reverse();\n    answer", "    let mut max_k = Vec::with_capacity(k\
    \ as usize);\n    for x in arr {\n        if max_k.len() < k as usize {\n    \
    \        max_k.push(x);\n            max_k.sort();\n        } else if x > max_k[0]\
    \ {\n            max_k[0] = x;\n            max_k.sort();\n        }\n    }\n\
    \    max_k", "    if k == 0 {\n        return vec![];\n    }\n    let mut heap\
    \ = BinaryHeap::<isize>::new();\n    for n in arr {\n        heap.push(n);\n \
    \       if heap.len() > k as usize {\n            heap.pop();\n        }\n   \
    \ }\n    let mut result = vec![];\n    for _ in 0..k {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut indexes = (0..arr.len()).collect::<Vec<usize>>();\n\
    \    quick_sort_by(&mut indexes, &arr, k as usize);\n    indexes.iter().map(|&i|\
    \ arr[i]).collect()", "    let mut mutable_arr = arr.clone();\n    mutable_arr.sort();\n\
    \    let mut vec = Vec::new();\n    for i in 0..k {\n        vec.push(mutable_arr[mutable_arr.len()\
    \ - 1 - i as usize]);\n    }\n    vec", "    let mut res = vec![];\n    // put\
    \ all the elements in a queue in descending order\n    let mut q = arr.into_iter().map(|x|\
    \ HeapNode::new(x)).collect::<BinaryHeap<_>>();\n    // pop the maximum k elements\n\
    \    for _ in 0..k {\n        if let Some(x) = q.pop() {\n            res.push(x.val);\n\
    \        }\n    }\n    res", '    return arr.clone().into_iter().sorted().take(k
    as usize).collect();', "    let mut arr = arr;\n    arr.sort();\n    let k = k\
    \ as usize;\n    let mut res = Vec::with_capacity(k);\n    for x in arr.iter().rev().take(k)\
    \ {\n        res.push(*x);\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    let k = k as usize;\n    arr.into_iter().take(k).collect()",
  '    return Vec::new();', "    let mut heap = BinaryHeap::new();\n    for num in\
    \ arr {\n        heap.push(num);\n        if heap.len() > k as usize {\n     \
    \       heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "    // The\
    \ problem is the same as finding the k largest elements from the array. \n   \
    \ // We can use a max-heap to store the largest k elements and we can use a min-heap\
    \ for this purpose.\n    let mut min_heap = BinaryHeap::with_capacity(k as usize);\n\
    \    let mut res = Vec::with_capacity(k as usize);\n    for i in arr {\n     \
    \   if min_heap.len() < k as usize {\n            min_heap.push(i);\n        }\
    \ else {\n            if i > *min_heap.peek().unwrap() {\n                min_heap.pop();\n\
    \                min_heap.push(i);\n            }\n        }\n    }\n    while\
    \ !min_heap.is_empty() {\n        res.push(min_heap.pop().unwrap());\n    }\n\
    \    res.reverse();\n    res", "    let mut v = arr;\n    v.sort();\n    v.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut max_heap = BinaryHeap::new();\n\
    \    let k = k as usize;\n    for i in 0..k {\n        max_heap.push(arr[i]);\n\
    \    }\n    for i in k..arr.len() {\n        if arr[i] > max_heap.peek().unwrap()\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i]);\n       \
    \ }\n    }\n    let mut result = Vec::new();\n    for i in 0..k {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut s: Heap<isize> = Heap::from_iter(arr.iter().cloned());\n\
    \    let mut v: Vec<isize> = Vec::new();\n    for _ in 0..k {\n        v.push(s.pop().unwrap());\n\
    \    }\n    v", "    let mut res = Vec::new();\n    let mut min_max_heap = MinMaxHeap::new();\n\
    \    let k = k as usize;\n    for a in arr {\n        min_max_heap.insert(a);\n\
    \        if min_max_heap.heap.len() > k {\n            min_max_heap.pop_min();\n\
    \        }\n    }\n    while let Some(n) = min_max_heap.pop_max() {\n        res.push(n);\n\
    \    }\n    res", "    let mut new_arr = arr.clone();\n    new_arr.sort();\n \
    \   let mut result = Vec::new();\n    for i in (new_arr.len() - k as usize)..new_arr.len()\
    \ {\n        result.push(new_arr[i]);\n    }\n    result", "    // TODO\n    vec![]",
  "    let n = arr.len();\n    let mut max_nums = vec![];\n    for &x in arr.iter()\
    \ {\n        let mut i = 0;\n        while i < max_nums.len() && max_nums[i] <\
    \ x {\n            i += 1;\n        }\n        if i < k as usize {\n         \
    \   max_nums.insert(i, x);\n        }\n        if max_nums.len() > k as usize\
    \ {\n            max_nums.pop();\n        }\n    }\n    max_nums", "    let mut\
    \ res = vec![];\n    for v in arr {\n        res.push(v);\n        res.sort();\n\
    \        res.truncate(k as usize);\n    }\n    res", "    let mut v = arr;\n \
    \   v.sort();\n    v.reverse();\n    let mut out = Vec::new();\n    for i in 0..k\
    \ {\n        out.push(v[i as usize]);\n    }\n    out", "    let mut v = arr;\n\
    \    v.sort();\n    v.reverse();\n    v.iter().take(k as usize).map(|&x| x).collect()",
  "    let mut k_num: Vec<isize> = Vec::new();\n    let mut temp_arr: Vec<isize> =\
    \ arr.clone();\n    for _i in 0..k {\n        let max = temp_arr.iter().max().unwrap();\n\
    \        k_num.push(*max);\n        temp_arr.remove_item(max);\n    }\n    k_num",
  "    let mut res = vec![0; k as usize];\n    let mut j = 0;\n    for i in 0..arr.len()\
    \ {\n        if j == 0 {\n            res[j as usize] = arr[i];\n            j\
    \ += 1;\n        } else {\n            let mut idx = j as usize;\n           \
    \ while idx > 0 && res[idx - 1] < arr[i] {\n                idx -= 1;\n      \
    \      }\n            if idx < j as usize {\n                res.remove(idx);\n\
    \                res.insert(idx, arr[i]);\n            } else if idx < k as usize\
    \ {\n                res[idx] = arr[i];\n                j += 1;\n           \
    \ }\n        }\n    }\n    res", "    let mut result = Vec::new();\n    let mut\
    \ sorted_arr = arr.clone();\n    sorted_arr.sort();\n    let mut i = sorted_arr.len()\
    \ as isize - 1;\n    while i >= 0 && k > 0 {\n        result.push(sorted_arr[i\
    \ as usize]);\n        i -= 1;\n        k -= 1;\n    }\n    result", "    let\
    \ mut arr = arr;\n    arr.sort();\n    let mut res = Vec::new();\n    for i in\
    \ 0..k {\n        res.push(arr[arr.len() - 1 - i as usize]);\n    }\n    res",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut n = arr.len();\n\
    \    while k > 0 {\n        if n < k {\n            break;\n        }\n      \
    \  let mut i = 0;\n        for j in 1..(n - k + 1) {\n            if arr[j] >\
    \ arr[i] {\n                i = j;\n            }\n        }\n        for j in\
    \ (i + 1)..n {\n            arr[j - 1] = arr[j];\n        }\n        n -= 1;\n\
    \        k -= 1;\n    }\n    arr.truncate(k as usize);\n    arr", "    if k ==\
    \ 0 {\n        return vec![];\n    }\n    let mut result = arr.iter().take(k as\
    \ usize).cloned().collect::<Vec<isize>>();\n    result.sort();\n    for i in k\
    \ as usize..arr.len() {\n        let mut l = 0usize;\n        let mut r = k as\
    \ usize - 1;\n        while l <= r {\n            let m = (l + r) / 2;\n     \
    \       if result[m] < arr[i] {\n                l = m + 1;\n            } else\
    \ {\n                r = m - 1;\n            }\n        }\n        result.insert(l,\
    \ arr[i]);\n        result.pop();\n    }\n    result", "    let mut v = arr;\n\
    \    v.sort();\n    v.iter().rev().take(k as usize).cloned().collect()", "   \
    \ let mut max = Vec::new();\n    let mut idx = 0;\n    while idx < k {\n     \
    \   let mut max_value = ISIZE_MIN;\n        let mut max_idx = 0;\n        for\
    \ i in idx..arr.len() {\n            if arr[i] > max_value {\n               \
    \ max_value = arr[i];\n                max_idx = i;\n            }\n        }\n\
    \        max.push(max_value);\n        idx = max_idx + 1;\n    }\n    max", " \
    \   let mut heap = std::collections::BinaryHeap::new();\n    for x in arr {\n\
    \        heap.push(MaxEntry(x));\n        if heap.len() > k as usize {\n     \
    \       heap.pop();\n        }\n    }\n    heap.into_sorted_vec().into_iter().map(|MaxEntry(x)|\
    \ x).collect()", "    if k == arr.len() as isize {\n        return arr;\n    }\n\
    \    let mut max = MaxHeap::new();\n    for num in arr {\n        max.push(num);\n\
    \        if max.len() > k as usize {\n            max.pop();\n        }\n    }\n\
    \    max.into_vec()", "    use std::cmp::Ordering;\n    // create a new vector\
    \ of n zeros\n    let mut result = vec![0; k as usize];\n    // declare a mutable\
    \ vector to store the max numbers\n    let mut stack: Vec<isize> = Vec::new();\n\
    \    // iterate through the array\n    for i in 0..arr.len() {\n        // compare\
    \ the i-th number with the peek of the stack\n        match stack.last().unwrap().cmp(&arr[i])\
    \ {\n            // if the i-th number is larger, push it onto the stack\n   \
    \         Ordering::Less => stack.push(arr[i]),\n            // if the i-th number\
    \ is smaller, pop the stack until it is larger\n            Ordering::Greater\
    \ => {\n                while stack.last().unwrap() > &arr[i] {\n            \
    \        stack.pop();\n                }\n                stack.push(arr[i]);\n\
    \            }\n            // if they are equal, push it onto the stack\n   \
    \         Ordering::Equal => stack.push(arr[i]),\n        }\n        // make sure\
    \ the stack is no larger than k\n        if stack.len() > k as usize {\n     \
    \       stack.remove(0);\n        }\n    }\n    result.clone_from_slice(&stack);\n\
    \    result", "    let mut res = arr;\n    res.sort();\n    res.reverse();\n \
    \   let mut ret = Vec::new();\n    for i in 0..k {\n        ret.push(res[i as\
    \ usize]);\n    }\n    ret", "    let mut max = Vec::with_capacity(k as usize);\n\
    \    for el in arr {\n        match max.binary_search(&el) {\n            Ok(index)\
    \ => max.insert(index, el),\n            Err(index) => max.insert(index, el),\n\
    \        }\n        if max.len() > k as usize {\n            max.pop();\n    \
    \    }\n    }\n    max", "    let mut heap = BinaryHeap::<isize>::new();\n   \
    \ for i in arr {\n        heap.push(i);\n        if heap.len() > k as usize {\n\
    \            heap.pop();\n        }\n    }\n    let mut res = Vec::<isize>::new();\n\
    \    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n\
    \    res.reverse();\n    res", '    arr.into_iter().sorted().rev().take(k as usize).collect()',
  "    let len = arr.len();\n    let mut h = BinaryHeap::new();\n    let mut result\
    \ = Vec::with_capacity(k as usize);\n    if len == k as usize {\n        return\
    \ arr;\n    }\n    for i in 0..k {\n        h.push(arr[i as usize]);\n    }\n\
    \    for i in k..arr.len() as isize {\n        h.push(arr[i as usize]);\n    \
    \    h.pop();\n    }\n    while !h.is_empty() {\n        result.push(h.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = vec![0; k as\
    \ usize];\n    for i in 0..k {\n        result[i as usize] = maximum_helper(&arr,\
    \ k - i - 1);\n    }\n    result", "    let mut sorted_arr = arr.clone();\n  \
    \  sorted_arr.sort();\n    sorted_arr.iter().rev().take(k as usize).cloned().collect()",
  "    let arr: Vec<_> = arr.into_iter().collect();\n    let mut rv = Heap::new(k);\n\
    \    for x in arr {\n        rv.push(x);\n    }\n    rv.into_vec()", "    let\
    \ mut arr = arr;\n    let mut result = Vec::new();\n    arr.sort();\n    arr.reverse();\n\
    \    for i in 0..k {\n        result.push(arr[i as usize]);\n    }\n    result",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut min_heap = BinaryHeap::new();\n\
    \    let length = arr.len();\n    for (index, val) in arr.iter().enumerate() {\n\
    \        if index as isize >= k - 1 {\n            result.push(min_heap.pop().unwrap().0);\n\
    \        }\n        min_heap.push((*val, index));\n    }\n    for _ in 0..(length\
    \ - k as usize) {\n        min_heap.pop();\n    }\n    for (val, _) in min_heap\
    \ {\n        result.push(val);\n    }\n    result", "    let mut k = k as usize;\n\
    \    let mut arr = arr;\n    let mut p = (0, arr.len() - 1);\n    while p.0 <\
    \ p.1 {\n        let q = partition(&mut arr, p.0, p.1);\n        if q == k {\n\
    \            break;\n        } else if q < k {\n            p.0 = q + 1;\n   \
    \     } else {\n            p.1 = q - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let len = arr.len();\n    let mut heap = Heap::new(true);\n    for i in 0..len\
    \ {\n        heap.push(arr[i] as i64);\n        if heap.size() > k as usize {\n\
    \            heap.pop();\n        }\n    }\n    heap.to_vec()", "    let mut arr\
    \ = arr;\n    let mut new_arr = Vec::with_capacity(k as usize);\n    let heap\
    \ = BinaryHeap::from_iter(arr.iter().cloned());\n    for _ in 0..k {\n       \
    \ new_arr.push(heap.pop().unwrap());\n    }\n    new_arr", "    let mut clone\
    \ = arr.clone();\n    let k = (k as usize).min(clone.len());\n    clone.sort();\n\
    \    clone.into_iter().rev().take(k).collect()", "    let max: usize = k as usize;\n\
    \    arr.iter().cloned().collect::<std::collections::BinaryHeap<_>>().into_sorted_vec().truncate(max)",
  "    let mut nums = arr;\n    let n = k as usize;\n    build_max_heap(&mut nums);\n\
    \    for i in (0..n).rev() {\n        nums.swap(0, i);\n        max_heapify(&mut\
    \ nums, 0, i);\n    }\n    nums[..n].to_vec()", "    let len = arr.len();\n  \
    \  let mut result = arr[0..len - k as usize].to_vec();\n    result.append(&mut\
    \ arr[len - k as usize..len].to_vec());\n    result.sort();\n    result", "  \
    \  let mut tmp = arr.clone();\n    tmp.sort();\n    tmp.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut s = arr;\n    s.sort();\n    s.reverse();\n\
    \    s.into_iter().take(k as usize).collect()", "    // use heap to find the k\
    \ largest elements.\n    let mut heap = Heap::<isize>::new();\n    for i in arr\
    \ {\n        heap.push(i);\n        if heap.len() > k as usize {\n           \
    \ heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "    if k == 0 {\n\
    \        return vec![];\n    }\n    let mut heap = BinaryHeap::new();\n    for\
    \ num in arr {\n        heap.push(num);\n        if heap.len() > k as usize {\n\
    \            heap.pop();\n        }\n    }\n    let mut result = vec![];\n   \
    \ while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n    }\n\
    \    result.reverse();\n    result", "    let mut v: Vec<isize> = Vec::new();\n\
    \    for i in 0..k {\n        let max = arr.iter().max().unwrap();\n        v.push(*max);\n\
    \        let pos = arr.iter().position(|&x| x == *max).unwrap();\n        arr.remove(pos);\n\
    \    }\n    v", '    unimplemented!()', "    let n = arr.len();\n    let k = k\
    \ as usize;\n    if k == 0 {\n        return vec![];\n    }\n    if k >= n {\n\
    \        return arr;\n    }\n    let mut ans = vec![-isize::MAX; k];\n    // Solution\
    \ 1: Max Heap\n    // let mut hp = MaxHeap::new();\n    // for i in 0..k {\n \
    \   //     hp.push(arr[i]);\n    // }\n    // for i in k..n {\n    //     if arr[i]\
    \ > hp.top() {\n    //         hp.pop();\n    //         hp.push(arr[i]);\n  \
    \  //     }\n    // }\n    // for i in 0..k {\n    //     ans[i] = hp.pop();\n\
    \    // }\n    // Solution 2: Quick Select\n    quick_select(&mut ans, &arr, 0,\
    \ n, k - 1);\n    ans", "    let mut x = 0;\n    let mut max_list = Vec::new();\n\
    \    let mut temp_list = arr.clone();\n    while x < k {\n        x += 1;\n  \
    \      max_list.push(temp_list.pop().unwrap());\n    }\n    let mut y = 0;\n \
    \   while y < k {\n        y += 1;\n        let popped = max_list.pop().unwrap();\n\
    \        max_list.push(popped);\n        max_list.sort();\n    }\n    max_list",
  "    let mut arr = arr;\n    arr.sort();\n    let mut max = vec![];\n    for i in\
    \ 0..k {\n        max.push(arr[arr.len() - i as usize - 1]);\n    }\n    max",
  "    let mut max_heap = BinaryHeap::with_capacity(k as usize);\n    for i in 0..k\
    \ {\n        max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > max_heap.peek().unwrap() {\n      \
    \      max_heap.pop();\n            max_heap.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut max_vec = vec![];\n    while !max_heap.is_empty() {\n    \
    \    max_vec.push(max_heap.pop().unwrap());\n    }\n    max_vec.reverse();\n \
    \   max_vec", "    let mut k_max = arr[0..k as usize].to_vec();\n    // Heapify\n\
    \    for i in 1..k {\n        for j in (1..i+1).rev() {\n            if k_max[j\
    \ as usize] > k_max[(j-1) as usize] {\n                k_max.swap(j as usize,\
    \ (j-1) as usize);\n            }\n        }\n    }\n    // Maintain a k-max heap\n\
    \    for i in k..arr.len() as isize {\n        if arr[i as usize] > k_max[0] {\n\
    \            k_max[0] = arr[i as usize];\n            for j in (1..k).rev() {\n\
    \                if k_max[j as usize] > k_max[(j-1) as usize] {\n            \
    \        k_max.swap(j as usize, (j-1) as usize);\n                }\n        \
    \    }\n        }\n    }\n    k_max", "    let mut arr = arr;\n    arr.sort();\n\
    \    let mut res = Vec::new();\n    for i in (arr.len() - k as usize)..arr.len()\
    \ {\n        res.push(arr[i]);\n    }\n    res", "    let mut ret = Vec::with_capacity(k\
    \ as usize);\n    for x in arr {\n        if ret.len() == k as usize {\n     \
    \       ret.sort();\n            if ret[0] < x {\n                ret[0] = x;\n\
    \            }\n        } else {\n            ret.push(x);\n        }\n    }\n\
    \    ret.sort();\n    ret", "    // since we need to return a sorted vector, insert\
    \ the first n elements\n    // in a min heap, where n is the specified k value.\n\
    \    // since we remove the smallest element for k times, n - k elements will\n\
    \    // remain in the heap.\n    // finally, we can pop all remaining elements\
    \ from the heap\n    // and we will get a sorted vector of length k.\n    let\
    \ mut heap = BinaryHeap::with_capacity(k as usize);\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for j in k..arr.len() as isize {\n\
    \        if arr[j as usize] > *heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[j as usize]);\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut out = Vec::with_capacity(k as usize);\n    let mut max_stack = MinStack::new();\n\
    \    let mut min_stack = MinStack::new();\n    // Push at most k elements into\
    \ the max stack\n    for elem in arr.iter().take(k as usize) {\n        max_stack.push(*elem);\n\
    \    }\n    // Now, start pushing the remaining elements into the min stack\n\
    \    // Whenever the min stack top equals the max stack top, \n    // then pop\
    \ the top of the min stack and push it into the max stack\n    for elem in arr.iter().skip(k\
    \ as usize) {\n        if elem >= max_stack.top() {\n            max_stack.push(*elem);\n\
    \        } else {\n            min_stack.push(*elem);\n        }\n        if min_stack.top()\
    \ == max_stack.top() {\n            min_stack.pop();\n            max_stack.push(min_stack.pop());\n\
    \        }\n    }\n    out.extend(max_stack.stack);\n    out", "    // trivial\
    \ problem if k == arr.len()\n    if k as usize == arr.len() {\n        return\
    \ arr;\n    }\n    // if k == 1, then simply find the max\n    if k == 1 {\n \
    \       let mut max = arr[0];\n        for i in arr {\n            if i > max\
    \ {\n                max = i;\n            }\n        }\n        return vec![max];\n\
    \    }\n    // initialize a blank vector to hold the greatest k integers\n   \
    \ let mut answer: Vec<isize> = Vec::new();\n    for i in 0..k {\n        answer.push(0);\n\
    \    }\n    // start at the beginning of the arr\n    let mut index = 0;\n   \
    \ // find the location of the next greatest number relative to the current k numbers\n\
    \    let mut next_greatest_location = 0;\n    while index < arr.len() {\n    \
    \    // if the current index is greater than the current greatest number\n   \
    \     if arr[index] > answer[next_greatest_location] {\n            // replace\
    \ the greatest number in answer with the value of the current index\n        \
    \    answer[next_greatest_location] = arr[index];\n            // initialize the\
    \ next greatest number to 0\n            let mut greatest_num = 0;\n         \
    \   // iterate through the remaining greatest numbers in answer\n            for\
    \ i in (next_greatest_location + 1)..k as usize {\n                // if the next\
    \ greatest number is greater than the current greatest number\n              \
    \  if answer[i] > greatest_num {\n                    // set the current greatest\
    \ number to the next greatest number\n                    greatest_num = answer[i];\n\
    \                    // set the next greatest number location to the current index\n\
    \                    next_greatest_location = i;\n                }\n        \
    \    }\n        }\n        index += 1;\n    }\n    answer", "    if k == arr.len()\
    \ as isize {\n        return arr;\n    }\n    let mut vec: Vec<isize> = Vec::new();\n\
    \    for i in 0..k {\n        vec.push(arr[i as usize]);\n    }\n    vec.sort();\n\
    \    for i in k..arr.len() as isize {\n        let j = 0;\n        while j < k\
    \ {\n            if arr[i as usize] > vec[j as usize] {\n                vec.remove(j\
    \ as usize);\n                vec.insert(j as usize, arr[i as usize]);\n     \
    \           break;\n            }\n            j += 1;\n        }\n    }\n   \
    \ vec", "    let mut arr = arr;\n    let mut res = Vec::new();\n    for _ in 0..k\
    \ {\n        let i = arr.iter().enumerate().max_by_key(|(_, e)| e).unwrap().0;\n\
    \        res.push(arr.remove(i));\n    }\n    res", "    let mut res = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    res.sort();\n    res.reverse();\n    res.truncate(k as usize);\n    res",
  '    unimplemented!()', "    let mut max_heap = BinaryHeap::<isize>::new();\n  \
    \  for i in arr {\n        max_heap.push(i);\n        if max_heap.len() > k as\
    \ usize {\n            max_heap.pop();\n        }\n    }\n    max_heap.into_sorted_vec()",
  "    let mut tmp = BTreeSet::new();\n    for i in arr {\n        tmp.insert(i);\n\
    \        if tmp.len() > k as usize {\n            tmp.remove(&tmp.iter().next().unwrap());\n\
    \        }\n    }\n    tmp.iter().map(|&x| x).collect()", "    let mut heap =\
    \ BinaryHeap::new();\n    for n in arr {\n        heap.push(n);\n        if heap.len()\
    \ > k as usize {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let k = k as usize;\n    let mut heap = BinaryHeap::with_capacity(k);\n\
    \    for i in arr {\n        if heap.len() < k {\n            heap.push(i);\n\
    \        } else if heap.peek().unwrap() < &i {\n            heap.pop();\n    \
    \        heap.push(i);\n        }\n    }\n    heap.into_sorted_vec()", "    let\
    \ mut vec = arr;\n    vec.sort();\n    let mut res = vec![];\n    for num in vec.iter().rev()\
    \ {\n        res.push(*num);\n        if res.len() == k as usize {\n         \
    \   break;\n        }\n    }\n    res", "    let mut min_heap = BinaryHeap::<isize>::new();\n\
    \    for num in arr {\n        min_heap.push(num);\n        if min_heap.len()\
    \ > k as usize {\n            min_heap.pop();\n        }\n    }\n    let mut result\
    \ = Vec::new();\n    while !min_heap.is_empty() {\n        result.push(min_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut max_index = 0;\n    for i in 0..k {\n        for j in\
    \ (max_index..arr.len()).rev() {\n            if arr[j] > arr[max_index] {\n \
    \               max_index = j;\n            }\n        }\n        result.push(arr[max_index]);\n\
    \        max_index += 1;\n    }\n    result", "    let mut max = MaxBinHeap::new();\n\
    \    for el in arr {\n        max.push(el);\n    }\n    let mut result = Vec::with_capacity(k\
    \ as usize);\n    for _ in 0..k {\n        if let Some(val) = max.pop() {\n  \
    \          result.push(val);\n        }\n    }\n    result", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.reverse();\n    arr.truncate(k as usize);\n\
    \    arr", "    let mut res = Vec::with_capacity(k as usize);\n    let mut heap\
    \ = BinaryHeap::new();\n    let mut visited = HashSet::new();\n    for n in arr\
    \ {\n        if visited.len() < k as usize {\n            heap.push(n);\n    \
    \        visited.insert(n);\n        } else if n > *heap.peek().unwrap() {\n \
    \           heap.pop();\n            heap.push(n);\n        }\n    }\n    while\
    \ !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n\
    \    res", "    let mut arr = arr;\n    arr.sort();\n    let mut res = Vec::new();\n\
    \    for i in (arr.len() - k as usize)..arr.len() {\n        res.push(arr[i]);\n\
    \    }\n    res", "    let mut result = Vec::new();\n    for x in arr {\n    \
    \    if result.len() < k as usize {\n            result.push(x);\n        } else\
    \ {\n            result.sort();\n            if x > result[0] {\n            \
    \    result[0] = x;\n            }\n        }\n    }\n    result.sort();\n   \
    \ result", "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    if k == arr.len() as isize {\n        return arr;\n\
    \    }\n    // let (mut i, mut j, mut result) = (0, arr.len() as isize - 1, vec![]);\n\
    \    // let mut tmp = arr.clone();\n    // while i < k {\n    //     let max =\
    \ tmp.iter().max().unwrap();\n    //     result.push(*max);\n    //     tmp.remove(max\
    \ - &tmp[0]);\n    //     i += 1;\n    // }\n    // result\n    let (mut i, mut\
    \ j, mut result) = (0, arr.len() as isize - 1, vec![]);\n    let mut tmp = arr.clone();\n\
    \    while i < k {\n        let max = tmp.iter().max().unwrap();\n        result.push(*max);\n\
    \        if max == &tmp[j as usize] {\n            tmp.remove(j as usize);\n \
    \           j -= 1;\n        } else {\n            tmp.remove(max - &tmp[0]);\n\
    \        }\n        i += 1;\n    }\n    result", "    arr[arr.len() - k as usize..]\n\
    \        .iter()\n        .cloned()\n        .collect::<Vec<isize>>()", "    let\
    \ mut result = vec![];\n    for i in 0..k {\n        result.push(arr[i as usize]);\n\
    \    }\n    result.sort();\n    for i in k..arr.len() as isize {\n        for\
    \ j in 0..k {\n            if arr[i as usize] > result[j as usize] {\n       \
    \         result.remove(j as usize);\n                result.insert(j as usize,\
    \ arr[i as usize]);\n                break;\n            }\n        }\n    }\n\
    \    result", "    let mut largest = HashMap::new();\n    let mut smallest = HashMap::new();\n\
    \    let mut stack = Vec::new();\n    let mut res = Vec::new();\n    let mut len\
    \ = 0;\n    for num in arr {\n        if len < k {\n            stack.push(num);\n\
    \            len += 1;\n        } else {\n            if smallest.get(&num).is_some()\
    \ {\n                continue;\n            }\n            let mut i = len - 1;\n\
    \            while i >= 0 {\n                if num < stack[i as usize] {\n  \
    \                  let val = stack[i as usize];\n                    largest.insert(val,\
    \ i);\n                    smallest.insert(num, i);\n                    stack[i\
    \ as usize] = num;\n                    break;\n                }\n          \
    \      i -= 1;\n            }\n        }\n    }\n    for i in (0..len).rev() {\n\
    \        res.push(stack[i as usize]);\n    }\n    res", "    let mut v = arr;\n\
    \    v.sort();\n    v.reverse();\n    v.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut max = Vec::with_capacity(k);\n\
    \    arr.sort();\n    for x in arr.iter().rev() {\n        if k == 0 {\n     \
    \       break;\n        }\n        max.push(*x);\n        k -= 1;\n    }\n   \
    \ max", "    if k == 0 {\n        return vec![];\n    }\n    let mut result =\
    \ vec![];\n    let mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n  \
    \      max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize\
    \ {\n        let mut peek = max_heap.peek().unwrap().clone();\n        if peek\
    \ < arr[i as usize] {\n            peek = arr[i as usize];\n            max_heap.pop();\n\
    \            max_heap.push(peek);\n        }\n    }\n    while !max_heap.is_empty()\
    \ {\n        result.push(max_heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    let l = sorted_arr.len();\n    let mut ret: Vec<isize> = vec![];\n    for\
    \ i in (l - k as usize)..l {\n        ret.push(sorted_arr[i]);\n    }\n    ret",
  "    let mut result = vec![];\n    for v in arr {\n        if result.len() < k as\
    \ usize {\n            result.push(v);\n            result.sort();\n        }\
    \ else if result[0] < v {\n            result.remove(0);\n            result.push(v);\n\
    \            result.sort();\n        }\n    }\n    result", "    let mut ans =\
    \ Vec::with_capacity(k as usize);\n    for i in 0..arr.len() {\n        if ans.len()\
    \ < k as usize {\n            ans.push(arr[i]);\n            ans.sort();\n   \
    \     } else if ans[0] < arr[i] {\n            ans.remove(0);\n            ans.push(arr[i]);\n\
    \            ans.sort();\n        }\n    }\n    ans", "    let n = arr.len();\n\
    \    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.drain(k\
    \ as usize..n).collect()", '    arr[arr.len() - k as usize..].to_vec()', "   \
    \ let mut arr = arr;\n    let len = arr.len();\n    let mut k = k as usize;\n\
    \    if k >= len {\n        arr.sort();\n        return arr;\n    }\n    // sort\
    \ arr in place.\n    arr.sort();\n    // remove len - k elements\n    arr.truncate(len\
    \ - k);\n    // reverse the remaining elements\n    arr.reverse();\n    arr",
  "    let n = arr.len();\n    if n == 0 {\n        return Vec::new();\n    }\n  \
    \  if k == n as isize {\n        return arr;\n    }\n    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        res.push(arr[i as usize]);\n    }\n\
    \    res.sort();\n    for i in k..n as isize {\n        if arr[i as usize] > res[0]\
    \ {\n            res[0] = arr[i as usize];\n            res.sort();\n        }\n\
    \    }\n    res", '    unimplemented!()', "    if k as usize == arr.len() {\n\
    \        return arr;\n    }\n    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut v = arr;\n    let mut r = Vec::new();\n\
    \    quicksort(&mut v, 0, v.len() - 1);\n    for x in 0..k {\n        r.push(v[x\
    \ as usize]);\n    }\n    r", "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter().take(k as usize).collect()", "    let k = k as usize;\n \
    \   let mut arr = arr;\n    let mut res = Vec::with_capacity(k);\n    let mut\
    \ max_val = isize::min_value();\n    for i in 0..k {\n        for j in 0..arr.len()\
    \ {\n            if arr[j] > max_val {\n                max_val = arr[j];\n  \
    \              arr.swap(j, arr.len() - 1);\n            }\n        }\n       \
    \ res.push(max_val);\n        max_val = isize::min_value();\n        arr.pop();\n\
    \    }\n    res", "    let mut result = vec![];\n    let mut max = None;\n   \
    \ let mut index = 0;\n    let mut popped = 0;\n    for (i, &num) in arr.iter().enumerate()\
    \ {\n        if max.is_none() || max.unwrap() < num {\n            max = Some(num);\n\
    \            index = i;\n        }\n    }\n    let mut i = index;\n    while popped\
    \ < k {\n        if result.len() == 0 {\n            while i < arr.len() {\n \
    \               result.push(arr[i]);\n                popped += 1;\n         \
    \       if popped == k {\n                    break;\n                }\n    \
    \            i += 1;\n            }\n        } else {\n            i = index -\
    \ 1;\n            while i >= 0 {\n                result.push(arr[i]);\n     \
    \           popped += 1;\n                if popped == k {\n                 \
    \   break;\n                }\n                i -= 1;\n            }\n      \
    \  }\n    }\n    result.sort();\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.truncate(k as usize);\n    arr", "    let mut ans\
    \ = vec![];\n    let mut arr = arr;\n    let len = arr.len();\n    let k = k as\
    \ usize;\n    if k == 0 {\n        return ans;\n    }\n    if k == len {\n   \
    \     return arr;\n    }\n    quick_sort_range(&mut arr, 0, len - 1);\n    for\
    \ index in 0..k {\n        ans.push(arr[index]);\n    }\n    ans", "    let mut\
    \ arr: Vec<isize> = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let len = arr.len();\n    let k = k as usize;\n    assert!(k > 0 && k <= len);\n\
    \    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().take(k).cloned().collect()",
  "    let mut heap = BinaryHeap::new();\n    let len = arr.len();\n    for (i, &num)\
    \ in arr.iter().enumerate() {\n        heap.push(Reverse(num));\n        if i\
    \ >= k as usize {\n            heap.pop();\n        }\n    }\n    let mut res\
    \ = vec![0; len];\n    for i in (0..len).rev() {\n        res[i] = heap.pop().unwrap().0;\n\
    \    }\n    res", "    let mut result = arr;\n    result.sort();\n    result.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut res = arr.clone();\n    res.sort();\n\
    \    res.truncate(k as usize);\n    res", "    let mut res = arr;\n    let len\
    \ = arr.len();\n    let mut k = k as usize;\n    if k == len {\n        return\
    \ res;\n    }\n    let mut p = len - 1;\n    while k > 0 {\n        let mut q\
    \ = p;\n        while q > 0 && res[q] > res[q - 1] {\n            q -= 1;\n  \
    \      }\n        res.remove(q);\n        p = q;\n        k -= 1;\n    }\n   \
    \ res", "    let n = arr.len();\n    let mut ans = vec![];\n    for i in 0..n\
    \ {\n        while ans.len() > 0 && ans.len() as isize + n - i > k && ans[ans.len()\
    \ - 1] < arr[i] {\n            ans.pop();\n        }\n        if ans.len() < k\
    \ as usize {\n            ans.push(arr[i]);\n        }\n    }\n    ans", "   \
    \ let mut heap = BinaryHeap::new();\n    for &x in &arr {\n        heap.push(x);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec()", "    let k = k as usize;\n    let mut s = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    s.sort();\n    s.reverse();\n    s.into_iter().take(k).collect()", "    let\
    \ mut current_max = vec![];\n    let mut output: Vec<isize> = vec![];\n    for\
    \ x in 0..k {\n        current_max.push(x);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        for j in 0..k {\n            if arr[current_max[j] as usize]\
    \ < arr[i as usize] {\n                current_max[j] = i;\n                break;\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        output.push(arr[current_max[i\
    \ as usize] as usize]);\n    }\n    output", "    let mut heap = BinaryHeap::new();\n\
    \    for n in arr {\n        heap.push(n);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", " \
    \   if k == 0 {\n        return vec![];\n    }\n\n    let mut heap = BinaryHeap::<isize>::new();\n\
    \    for i in arr {\n        heap.push(i);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n\n    heap.into_sorted_vec()",
  "    let mut v = arr;\n    v.sort();\n    let mut r: Vec<isize> = Vec::new();\n\
    \    for i in 0..k {\n        r.push(v[v.len() - 1 - i as usize]);\n    }\n  \
    \  r", "    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    // let mut stack = Vec::new();\n    // for\
    \ num in arr {\n    //     while let Some(top) = stack.last() {\n    //      \
    \   if *top < num {\n    //             stack.pop();\n    //         } else {\n\
    \    //             break;\n    //         }\n    //     }\n    //     stack.push(num);\n\
    \    //     if stack.len() > k as usize {\n    //         stack.remove(0);\n \
    \   //     }\n    // }\n    // stack\n\n    let mut result = Vec::new();\n   \
    \ for i in 0..k {\n        result.push(arr[i as usize]);\n    }\n    result.sort();\n\
    \    for i in k..arr.len() as isize {\n        for j in 0..k {\n            if\
    \ arr[i as usize] > result[j as usize] {\n                result.remove(0);\n\
    \                result.push(arr[i as usize]);\n                result.sort();\n\
    \                break;\n            }\n        }\n    }\n    result", "    let\
    \ mut heap = BinaryHeap::with_capacity(k as usize);\n    let n = arr.len();\n\
    \    for i in 0..n {\n        if heap.len() < k as usize {\n            heap.push(arr[i]);\n\
    \        } else {\n            let min = heap.peek().unwrap();\n            if\
    \ *min < arr[i] {\n                heap.pop();\n                heap.push(arr[i]);\n\
    \            }\n        }\n    }\n    heap.into_sorted_vec()", "    use std::cmp::Reverse;\n\
    \    use std::collections::BinaryHeap;\n    use std::vec::IntoIter;\n    use utils::BinaryTree;\n\
    \    fn solution(arr: Vec<isize>, k: isize) -> Vec<isize> {\n        let arr_len\
    \ = arr.len();\n        let root = BinaryTree::from_vec(arr);\n        let mut\
    \ heap = BinaryHeap::new();\n        for _ in 0..k {\n            heap.push(Reverse(root.pop_max()));\n\
    \        }\n        let iter = heap.into_iter();\n        let mut result = Vec::with_capacity(arr_len);\n\
    \        for Reverse(n) in iter {\n            result.push(n);\n        }\n  \
    \      result\n    }\n    solution(arr, k)", "    let k = k as usize;\n    let\
    \ heap = BinaryHeap::from(arr);\n    let mut ans = Vec::with_capacity(k);\n  \
    \  for _ in 0..k {\n        ans.push(heap.pop().unwrap());\n    }\n    ans", " \
    \   let mut max: Vec<isize> = arr[0..k as usize].to_vec();\n    max.sort();\n\
    \    for a in arr[k as usize..].iter() {\n        if max[0] <= *a {\n        \
    \    for i in 0..k as usize {\n                if max[i] < *a {\n            \
    \        max.remove(i);\n                    max.insert(i, *a);\n            \
    \        break;\n                }\n            }\n        }\n    }\n    max",
  "    let mut heap = std::collections::BinaryHeap::new();\n    for value in arr {\n\
    \        heap.push(OrderBy::from(value));\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", " \
    \   let mut max: Vec<isize> = arr.clone();\n    max.sort();\n    max.reverse();\n\
    \    max.iter().take(k as usize).map(|x| *x).collect()", "    let mut heap = BinaryHeap::new();\n\
    \    let k = k as usize;\n    for i in 0..arr.len() {\n        heap.push(arr[i]);\n\
    \        if heap.len() > k {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut k = k as usize;\n    let mut a = arr;\n    let mut l = 0;\n    let\
    \ mut r = a.len() - 1;\n    while l < r {\n        let m = l + (r - l) / 2;\n\
    \        a.swap(m, r);\n        let mut i = l;\n        for j in l..r {\n    \
    \        if a[j] > a[r] {\n                a.swap(i, j);\n                i +=\
    \ 1;\n            }\n        }\n        a.swap(i, r);\n        if i == k {\n \
    \           break;\n        } else if i < k {\n            l = i + 1;\n      \
    \  } else {\n            r = i - 1;\n        }\n    }\n    a[..k].to_vec()", " \
    \   let mut arr = arr;\n    let mut arr_len = arr.len();\n    let mut res = Vec::new();\n\
    \    while k > 0 {\n        let index = find_max(&arr, arr_len);\n        res.push(arr[index]);\n\
    \        arr.remove(index);\n        arr_len -= 1;\n        k -= 1;\n    }\n \
    \   res", "    let mut max = Vec::with_capacity(k as usize);\n    let mut min\
    \ = Vec::with_capacity(k as usize);\n    for num in arr {\n        while !max.is_empty()\
    \ && num > max[max.len() - 1] {\n            max.pop();\n        }\n        max.push(num);\n\
    \        while !min.is_empty() && num < min[min.len() - 1] {\n            min.pop();\n\
    \        }\n        min.push(num);\n    }\n    max.reverse();\n    min.reverse();\n\
    \    let mut k = k;\n    while k > 0 {\n        if k % 2 == 1 {\n            max.pop();\n\
    \        } else {\n            min.pop();\n        }\n        k /= 2;\n    }\n\
    \    min.reverse();\n    min.append(&mut max);\n    min", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()", "   \
    \ let mut answer = Vec::with_capacity(k as usize);\n    let mut max_heap = BinaryHeap::new();\n\
    \    for item in arr {\n        max_heap.push(item);\n        if max_heap.len()\
    \ > k as usize {\n            max_heap.pop();\n        }\n    }\n    while !max_heap.is_empty()\
    \ {\n        answer.push(max_heap.pop().unwrap());\n    }\n    answer.reverse();\n\
    \    answer", "    let mut temp = arr.clone();\n    temp.sort();\n    temp.iter().rev().take(k\
    \ as usize).cloned().collect()", "    if k == 0 {\n        return vec![];\n  \
    \  }\n    let mut arr: Vec<isize> = arr.iter().cloned().collect();\n    arr.sort();\n\
    \    arr.reverse();\n    let mut k = k as usize;\n    let mut res: Vec<isize>\
    \ = vec![];\n    for i in arr {\n        res.push(i);\n        k -= 1;\n     \
    \   if k == 0 {\n            break;\n        }\n    }\n    res", "    arr.into_iter().fold(MaxHeap::new(),\
    \ |mut acc, x| {\n        acc.push(x);\n        if acc.len() > k as usize {\n\
    \            acc.pop();\n        }\n        acc\n    }).into_sorted_vec()", " \
    \   let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    use std::cmp::Ordering;\n    let mut a = arr;\n    a.sort_by(|x, y| \n    \
    \    match x.cmp(y) {\n            Ordering::Less => Ordering::Greater,\n    \
    \        Ordering::Greater => Ordering::Less,\n            Ordering::Equal =>\
    \ Ordering::Equal,\n        }\n    );\n    let mut b = Vec::new();\n    for x\
    \ in a.iter().take(k as usize) {\n        b.push(*x);\n    }\n    b", "    let\
    \ mut v: Vec<isize> = arr;\n    v.sort();\n    v.reverse();\n    let mut res:\
    \ Vec<isize> = Vec::new();\n    for i in 0..k {\n        res.push(v[i as usize]);\n\
    \    }\n    res", "    let mut res = vec![];\n    let n = arr.len();\n    let\
    \ k = k as usize;\n    for (i, &item) in arr.iter().enumerate() {\n        if\
    \ res.len() == k {\n            if item > res[0] {\n                res.remove(0);\n\
    \                res.push(item);\n            }\n        } else {\n          \
    \  let mut j = res.len();\n            while j > 0 && res[j - 1] < item {\n  \
    \              j -= 1;\n            }\n            res.insert(j, item);\n    \
    \    }\n    }\n    res", "    let mut list = arr.clone();\n    let mut pointer\
    \ = list.len() - 1;\n    let mut index = 0;\n    while index < k {\n        let\
    \ (start, end) = list.split_at_mut(pointer + 1);\n        let mut m = end[0];\n\
    \        let mut mi = 0;\n        for i in 0..start.len() {\n            if start[i]\
    \ > m {\n                m = start[i];\n                mi = i;\n            }\n\
    \        }\n        start.swap(mi, pointer);\n        pointer -= 1;\n        index\
    \ += 1;\n    }\n    list.split_at(k as usize).0.to_vec()", "    let mut result\
    \ = Vec::new();\n    let mut current = 0;\n    let mut index = 0;\n    let mut\
    \ len = arr.len();\n    for i in 0..k {\n        current = 0;\n        index =\
    \ 0;\n        for j in 0..len {\n            if arr[j] > current {\n         \
    \       current = arr[j];\n                index = j;\n            }\n       \
    \ }\n        result.push(current);\n        arr.remove(index);\n        len -=\
    \ 1;\n    }\n    result", "    let mut k_max: HashMap<isize, isize> = HashMap::new();\n\
    \    for i in 0..arr.len() {\n        for j in 0..arr.len() {\n            let\
    \ sum = arr[i] + arr[j];\n            let sum_val = k_max.entry(sum).or_insert(0);\n\
    \            *sum_val += 1;\n        }\n    }\n    let mut max_sums: Vec<isize>\
    \ = k_max.iter().map(|(a, _)| *a).collect();\n    max_sums.sort();\n    max_sums.reverse();\n\
    \    max_sums.truncate(k as usize);\n    max_sums", "    let mut result = Vec::new();\n\
    \    let mut target = arr.len() - k as usize;\n    for i in 0..arr.len() {\n \
    \       if i <= target {\n            continue;\n        } else {\n          \
    \  result.push(arr[i]);\n        }\n    }\n    result.sort();\n    result", " \
    \   // TODO: implement this\n    vec![]", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..arr.len() {\n        heap.push(arr[i]);\n        if heap.len()\
    \ > k as usize {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut result = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    result.iter().take(k as usize).map(|n| *n).collect()", "    let mut result\
    \ = vec![];\n    let mut queue = BinaryHeap::new();\n    for i in 0..arr.len()\
    \ {\n        queue.push(Reverse(arr[i]));\n        if queue.len() > k as usize\
    \ {\n            queue.pop();\n        }\n    }\n    while !queue.is_empty() {\n\
    \        result.push((queue.pop().unwrap()).0);\n    }\n    result.reverse();\n\
    \    result", "    let mut arr = arr;\n    arr.sort();\n    let k = k as usize;\n\
    \    arr.iter().rev().take(k).cloned().collect()", "    let mut _arr = arr;\n\
    \    _arr.sort();\n    _arr.iter().rev().take(k as usize).map(|&x| x).collect()",
  "    let mut res = Vec::new();\n    for i in arr {\n        res.push(i);\n    }\n\
    \    res.sort();\n    res.resize(k as usize, 0);\n    res", '    arr.iter().sorted().rev().take(k
    as usize).map(|i| *i).collect()', "    if k == arr.len() as isize {\n        return\
    \ arr;\n    }\n    let mut arr = arr;\n    for i in 0..k {\n        for j in i..arr.len()\
    \ - 1 {\n            if arr[j] > arr[j + 1] {\n                let temp = arr[j];\n\
    \                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n  \
    \          }\n        }\n    }\n    arr.drain(arr.len() - k as usize..).collect()",
  "    //\n    let mut heap = BinaryHeap::new();\n    for i in arr {\n        heap.push(i);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    let mut ans = vec![];\n    while let Some(i) = heap.pop() {\n      \
    \  ans.push(i);\n    }\n    ans.reverse();\n    ans", "    if k <= 0 {\n     \
    \   return vec![];\n    }\n    let mut sorted = arr.to_vec();\n    sorted.sort();\n\
    \    let k = k as usize;\n    sorted.iter().rev().take(k).cloned().collect()",
  "    let mut vec = arr;\n    vec.sort();\n    vec.reverse();\n    vec.iter().take(k\
    \ as usize).map(|x| *x).collect()", "    use std::cmp::Ordering;\n    let mut\
    \ values = arr.iter().map(|x| x.clone()).collect::<Vec<isize>>();\n    values.sort_by(|a,\
    \ b| match b.cmp(a) {\n        Ordering::Less => Ordering::Less,\n        Ordering::Greater\
    \ => Ordering::Greater,\n        Ordering::Equal => Ordering::Equal,\n    });\n\
    \    values.iter().take(k as usize).map(|x| x.clone()).collect::<Vec<isize>>()",
  "    let mut copy = arr.clone();\n    copy.sort();\n    copy.reverse();\n    let\
    \ mut output = Vec::new();\n    for i in 0..k {\n        output.push(copy[i as\
    \ usize]);\n    }\n    output", "    let n = arr.len();\n    let mut sorted =\
    \ arr.clone();\n    sorted.sort();\n    sorted.reverse();\n    sorted.drain(k\
    \ as usize..n).collect()", "    let mut res = vec![];\n    let mut arr = arr;\n\
    \    let mut len = arr.len();\n    for i in 0..k {\n        let max = arr.iter().cloned().max().unwrap();\n\
    \        res.push(max);\n        let index = arr.iter().position(|x| *x == max).unwrap();\n\
    \        arr.remove(index);\n        len -= 1;\n    }\n    res", "    let mut\
    \ arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    // TODO: Implement me\n    // https://stackoverflow.com/questions/60437653/how-to-get-a-vectors-max-element-in-rust\n\
    \    let mut result = Vec::with_capacity(k as usize);\n    // let mut max = arr[0];\n\
    \    // for i in arr {\n    //     if i > max {\n    //         max = i;\n   \
    \ //     }\n    // }\n    let max = arr.iter().max().unwrap();\n    result.push(*max);\n\
    \    result", "    let size = arr.len();\n    if size < k as usize {\n       \
    \ panic!(\"Size {} of arr is less than k {}\", size, k);\n    }\n    let mut heap\
    \ = BinaryHeap::<isize>::with_capacity(k as usize);\n    for i in 0..size {\n\
    \        heap.push(arr[i]);\n        if heap.len() > k as usize {\n          \
    \  heap.pop();\n        }\n    }\n    let mut result = Vec::with_capacity(k as\
    \ usize);\n    for i in 0..k {\n        result.push(heap.pop().unwrap());\n  \
    \  }\n    result.reverse();\n    result", "    // [1, 2, 3, 4, 5]\n    // [5,\
    \ 4, 3, 2, 1]\n    // [1, 2, 3, 4, 5]\n    // [5, 4, 3, 2, 1]\n    // [1, 2, 3,\
    \ 4, 5]\n    // [5, 4, 3, 2, 1]\n    // [1, 2, 3, 4, 5]\n    // [5, 4, 3, 2, 1]\n\
    \    let mut arr = arr;\n    if k > arr.len() as isize {\n        return arr;\n\
    \    }\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  '    unimplemented!();', "    // Sort array\n    let mut arr = arr;\n    arr.sort();\n\
    \    // Return vector with top k numbers\n    let mut v = Vec::with_capacity(k\
    \ as usize);\n    for i in (arr.len() - k as usize)..arr.len() {\n        v.push(arr[i]);\n\
    \    }\n    v", "    let mut xs = arr;\n    xs.sort();\n    xs.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr: Vec<isize> = arr;\n    arr.sort();\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for i in 0..k {\n        result.push(arr[arr.len()\
    \ - 1 - i as usize]);\n    }\n    result", "    let mut res = vec![isize::MIN;\
    \ k as usize];\n    for i in 0..arr.len() {\n        let v = arr[i];\n       \
    \ let mut j = k as usize - 1;\n        while j > 0 && res[j - 1] < v {\n     \
    \       res[j] = res[j - 1];\n            j -= 1;\n        }\n        res[j] =\
    \ v;\n    }\n    res", "    let mut vec: Vec<isize> = Vec::new();\n    for i in\
    \ 0..k {\n        vec.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        let mut max_index = 0;\n        for j in 0..k {\n      \
    \      if vec[j as usize] > vec[max_index as usize] {\n                max_index\
    \ = j;\n            }\n        }\n        if arr[i as usize] > vec[max_index as\
    \ usize] {\n            vec[max_index as usize] = arr[i as usize];\n        }\n\
    \    }\n    vec.sort();\n    vec", "    let mut v = arr;\n    v.sort();\n    v.into_iter().rev().take(k\
    \ as usize).collect()", "    // Sort the vector in the descending order.\n   \
    \ // Take the first k elements.\n    arr.into_iter().sorted().rev().take(k as\
    \ usize).collect()"]
stop_tokens:
- "\n}"
