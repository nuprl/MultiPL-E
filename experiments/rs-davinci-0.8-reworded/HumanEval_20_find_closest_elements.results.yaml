language: rs
name: HumanEval_20_find_closest_elements
results:
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"Invalid\
    \ vector size!\");\n    }\n\n    let mut closest_numbers = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = f64::abs(closest_numbers.0 - closest_numbers.1);\n\
    \n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let current_distance = f64::abs(numbers[i] - numbers[j]);\n     \
    \       if current_distance < closest_distance {\n                closest_numbers\
    \ = (numbers[i], numbers[j]);\n                closest_distance = current_distance;\n\
    \            }\n        }\n    }\n\n    if closest_numbers.0 > closest_numbers.1\
    \ {\n        (closest_numbers.1, closest_numbers.0)\n    } else {\n        closest_numbers\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut left = numbers[0];\n    let mut right\
    \ = numbers[1];\n    let mut minimum = (left - right).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        let tmp = (numbers[i] - numbers[i + 1]).abs();\n        if tmp\
    \ < minimum {\n            minimum = tmp;\n            left = numbers[i];\n  \
    \          right = numbers[i + 1];\n        }\n    }\n    (left, right)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpd98as0qy.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut first\
    \ = numbers[0];\n    let mut second = numbers[1];\n    let mut min_diff = second\
    \ - first;\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len()\
    \ {\n            if i != j {\n                let diff = numbers[j] - numbers[i];\n\
    \                if diff < min_diff {\n                    min_diff = diff;\n\
    \                    first = numbers[i];\n                    second = numbers[j];\n\
    \                }\n            }\n        }\n    }\n    if first > second {\n\
    \        (second, first)\n    } else {\n        (first, second)\n    }\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpainfnkwr.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut first\
    \ = 0.0;\n    let mut second = 0.0;\n    for i in 0..numbers.len() - 1 {\n   \
    \     for j in i + 1..numbers.len() {\n            let f = numbers[i];\n     \
    \       let s = numbers[j];\n            let diff = (f - s).abs();\n         \
    \   if diff < min {\n                min = diff;\n                first = f;\n\
    \                second = s;\n            }\n        }\n    }\n    (first, second)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpz0_bv89c.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3jb9gars.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::INFINITY;\n    let mut\
    \ closest = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in (i\
    \ + 1)..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        closest = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    closest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp1yw_1aoi.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    // TODO: think\
    \ about what you want to return, write it down, use the provided tests to write\
    \ it, and test it\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxuqkexuf.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist: f64 = 1.0;\n    let mut min_idx1:\
    \ usize = 0;\n    let mut min_idx2: usize = 0;\n    for (i, num) in numbers.iter().enumerate()\
    \ {\n        for (j, num2) in numbers.iter().enumerate() {\n            if i ==\
    \ j {\n                continue;\n            }\n            let dist = num2 -\
    \ num;\n            if dist < min_dist {\n                min_dist = dist;\n \
    \               min_idx1 = i;\n                min_idx2 = j;\n            }\n\
    \        }\n    }\n    let num1 = numbers[min_idx1];\n    let num2 = numbers[min_idx2];\n\
    \    if num1 < num2 {\n        (num1, num2)\n    } else {\n        (num2, num1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpsaqlaccx.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_diff = (numbers[0], numbers[1]);\n\
    \    let mut diff = (numbers[0] - numbers[1]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let tmp_diff = (numbers[i]\
    \ - numbers[j]).abs();\n            if tmp_diff < diff {\n                diff\
    \ = tmp_diff;\n                smallest_diff = (numbers[i], numbers[j]);\n   \
    \         }\n        }\n    }\n    smallest_diff\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_o4qm7s9.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut numbers_refs:\
    \ Vec<_> = numbers.iter().collect();\n    numbers_refs.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    numbers_refs.into_iter().map(|x| *x).zip(numbers_refs.into_iter().skip(1).map(|x|\
    \ *x)).min_by(|(a, b), (c, d)| (a - b).abs().partial_cmp(&(c - d).abs()).unwrap()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers_refs`\n   --> /tmp/tmpr8tsw8nx.rs:11:46\n\
    \    |\n9   |     let mut numbers_refs: Vec<_> = numbers.iter().collect();\n \
    \   |         ---------------- move occurs because `numbers_refs` has type `Vec<&f64>`,\
    \ which does not implement the `Copy` trait\n10  |     numbers_refs.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n11  |     numbers_refs.into_iter().map(|x| *x).zip(numbers_refs.into_iter().skip(1).map(|x|\
    \ *x)).min_by(|(a, b), (c, d)| (a - b).abs().partial_...\n    |              \
    \    -----------                 ^^^^^^^^^^^^ value used here after move\n   \
    \ |                  |\n    |                  `numbers_refs` moved due to this\
    \ method call\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers_refs`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO: Finish this function!\n    let mut sorted\
    \ = numbers.clone();\n    sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    (sorted[0], sorted[1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp_uskv25w.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = (1./0., 1./0.);\n    let mut\
    \ biggest = (0., 0.);\n    let mut current = 0.;\n    let mut first = true;\n\
    \    for i in numbers {\n        if i < smallest.0 {\n            smallest = (i,\
    \ current);\n        }\n        if i > biggest.0 {\n            biggest = (i,\
    \ current);\n        }\n        if first {\n            first = false;\n     \
    \   } else {\n            let diff = i - current;\n            if diff < smallest.1\
    \ {\n                smallest = (current, diff);\n            }\n            if\
    \ diff > biggest.1 {\n                biggest = (current, diff);\n           \
    \ }\n        }\n        current = i;\n    }\n    if smallest.1 < biggest.1 {\n\
    \        (smallest.0, smallest.0 + smallest.1)\n    } else {\n        (biggest.0\
    \ - biggest.1, biggest.0)\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmper1i8drd.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"We need\
    \ at least two numbers\");\n    }\n    let mut closest_elements = (numbers[0],\
    \ numbers[1]);\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len()\
    \ {\n            if i != j {\n                let (low, high) = order_pair(numbers[i],\
    \ numbers[j]);\n                if (high - low) < (closest_elements.1 - closest_elements.0)\
    \ {\n                    closest_elements = (low, high);\n                }\n\
    \            }\n        }\n    }\n    closest_elements\n}\n\nfn main() {\n   \
    \ let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `order_pair` in this scope\n  --> /tmp/tmp3oaglisj.rs:15:35\n\
    \   |\n15 |                 let (low, high) = order_pair(numbers[i], numbers[j]);\n\
    \   |                                   ^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_number_1 = numbers[0];\n    let\
    \ mut closest_number_2 = numbers[1];\n    let mut closest_difference = closest_number_2\
    \ - closest_number_1;\n\n    for &number_1 in numbers.iter() {\n        for &number_2\
    \ in numbers.iter() {\n            if number_1 == number_2 {\n               \
    \ continue;\n            }\n\n            let difference = number_2 - number_1;\n\
    \            if difference < closest_difference {\n                closest_number_1\
    \ = number_1;\n                closest_number_2 = number_2;\n                closest_difference\
    \ = difference;\n            }\n        }\n    }\n\n    (closest_number_1, closest_number_2)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp27lon8of.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut minimum = (numbers[0], numbers[1]);\n\
    \    for i in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n    \
    \        if ((numbers[i] - numbers[j]).abs() < (minimum.0 - minimum.1).abs())\
    \ {\n                minimum = (numbers[i], numbers[j]);\n            }\n    \
    \    }\n    }\n    return minimum;\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpe6j1f57y.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    (0.0, 0.0)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0.0, 0.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpk2a882py.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"`find_closest_elements`\
    \ requires at least two numbers!\");\n    }\n    let mut min_difference = f64::MAX;\n\
    \    let mut pair = (numbers[0], numbers[1]);\n    for i in 0..numbers.len() -\
    \ 1 {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[i]\
    \ - numbers[j]).abs();\n            if diff < min_difference {\n             \
    \   min_difference = diff;\n                pair = (numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpdtzz6s0t.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let (mut min, mut min_i) = (numbers[0] - numbers[1],\
    \ 0);\n    for i in 1..numbers.len() - 1 {\n        let diff = numbers[i] - numbers[i\
    \ + 1];\n        if diff < min {\n            min = diff;\n            min_i =\
    \ i;\n        }\n    }\n    (numbers[min_i], numbers[min_i + 1])\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.0, 3.9)`,\n right: `(3.9, 4.0)`', /tmp/tmpf4opdd_l.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smaller_number = numbers[0];\n    let\
    \ mut bigger_number = numbers[1];\n    let mut smaller_difference = numbers[1]\
    \ - numbers[0];\n\n    for number in numbers {\n        for number2 in numbers\
    \ {\n            if (number - number2).abs() < smaller_difference && number <\
    \ number2 {\n                smaller_number = number;\n                bigger_number\
    \ = number2;\n                smaller_difference = number2 - number;\n       \
    \     }\n        }\n    }\n\n    (smaller_number, bigger_number)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpgw_k8_n2.rs:13:24\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n12  |     for number in numbers\
    \ {\n    |                   ------- `numbers` moved due to this implicit call\
    \ to `.into_iter()`\n13  |         for number2 in numbers {\n    |           \
    \             ^^^^^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `numbers`\nhelp: consider iterating\
    \ over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n\
    \    |\n12  |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976359
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_delta = std::f64::MAX;\n    let mut\
    \ min_delta_pair = (0f64, 0f64);\n    for i in 0..numbers.len() {\n        for\
    \ j in i + 1..numbers.len() {\n            let delta = (numbers[i] - numbers[j]).abs();\n\
    \            if delta < min_delta {\n                min_delta = delta;\n    \
    \            min_delta_pair = (numbers[i], numbers[j]);\n            }\n     \
    \   }\n    }\n    min_delta_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpr25nb2v9.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_difference = f64::MAX;\n    let\
    \ mut closest_tuple = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for\
    \ j in i + 1..numbers.len() {\n            let difference = (numbers[i] - numbers[j]).abs();\n\
    \            if difference < closest_difference {\n                closest_difference\
    \ = difference;\n                closest_tuple = (numbers[i], numbers[j]);\n \
    \           }\n        }\n    }\n    if closest_tuple.0 > closest_tuple.1 {\n\
    \        (closest_tuple.1, closest_tuple.0)\n    } else {\n        closest_tuple\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Check to see if the vector is of length 2.\
    \ If it is, return the values directly.\n    if numbers.len() == 2 {\n       \
    \ return (numbers[0], numbers[1]);\n    }\n\n    // Check to see if the length\
    \ of the vector is less than 2. If it is, panic.\n    if numbers.len() < 2 {\n\
    \        panic!(\"Vector must be of length 2 or greater.\");\n    }\n\n    //\
    \ Sort the vector in increasing order.\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n\n    // Create a variable to hold the minimum\
    \ value of the absolute difference between consecutive elements.\n    let mut\
    \ minimum = numbers[1] - numbers[0];\n\n    // Initialize the values to hold the\
    \ values of the consecutive elements which have the minimum value of the\n   \
    \ // absolute difference between them.\n    let mut min_1 = numbers[0];\n    let\
    \ mut min_2 = numbers[1];\n\n    // Loop through the vector, comparing the absolute\
    \ differences between the consecutive elements and updating the\n    // minimum\
    \ and associated values if a smaller absolute difference is found.\n    for i\
    \ in 0..numbers.len() - 1 {\n        let value = numbers[i + 1] - numbers[i];\n\
    \        if value < minimum {\n            minimum = value;\n            min_1\
    \ = numbers[i];\n            min_2 = numbers[i + 1];\n        }\n    }\n\n   \
    \ // Return the values.\n    (min_1, min_2)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = f64::MAX;\n    let mut closest\
    \ = (0.0, 0.0);\n    for (x, y) in numbers.iter().zip(numbers.iter().skip(1))\
    \ {\n        let distance = x - y;\n        if distance.abs() < min {\n      \
    \      min = distance.abs();\n            closest = (*x, *y);\n        }\n   \
    \ }\n    closest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpjroq0nu8.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_numbers.1 - closest_numbers.0;\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let current_distance = numbers[j] - numbers[i];\n            if current_distance\
    \ < closest_distance {\n                closest_numbers = (numbers[i], numbers[j]);\n\
    \                closest_distance = current_distance;\n            }\n       \
    \ }\n    }\n    closest_numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp_av_jg2d.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let length = numbers.len();\n    let mut numbers_copy\
    \ = numbers.clone();\n    numbers_copy.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut lowest_diff = None;\n    let mut best_low = None;\n    let mut best_high\
    \ = None;\n    for i in 0..length - 1 {\n        let diff = numbers_copy[i + 1]\
    \ - numbers_copy[i];\n        if lowest_diff.is_none() || diff < lowest_diff.unwrap()\
    \ {\n            lowest_diff = Some(diff);\n            best_low = Some(numbers_copy[i]);\n\
    \            best_high = Some(numbers_copy[i + 1]);\n        }\n    }\n    (best_low.unwrap(),\
    \ best_high.unwrap())\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut sorted_numbers = numbers.clone();\n \
    \   sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut minimum_difference\
    \ = sorted_numbers[1] - sorted_numbers[0];\n    let mut min_pair = (sorted_numbers[0],\
    \ sorted_numbers[1]);\n    for pair in sorted_numbers.windows(2) {\n        let\
    \ difference = pair[1] - pair[0];\n        if difference < minimum_difference\
    \ {\n            minimum_difference = difference;\n            min_pair = (pair[0],\
    \ pair[1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let min_idx = numbers.iter().enumerate().fold(0,\
    \ |min_idx, (idx, &x)| if x < numbers[min_idx] { idx } else { min_idx });\n  \
    \  let max_idx = numbers.iter().enumerate().fold(0, |max_idx, (idx, &x)| if x\
    \ > numbers[max_idx] { idx } else { max_idx });\n    if min_idx == max_idx {\n\
    \        (numbers[min_idx], numbers[min_idx])\n    } else {\n        let min =\
    \ numbers[min_idx];\n        let max = numbers[max_idx];\n        let min_max_diff\
    \ = (min - max).abs();\n        let closest_idx = numbers.iter().enumerate().fold(0,\
    \ |closest_idx, (idx, &x)| {\n            if idx == min_idx || idx == max_idx\
    \ {\n                closest_idx\n            } else {\n                let closer_than_min_max\
    \ = (x - min).abs() < min_max_diff;\n                let closer_than_current =\
    \ (x - numbers[closest_idx]).abs() < (numbers[closest_idx] - numbers[min_idx]).abs();\n\
    \                if closer_than_min_max && closer_than_current {\n           \
    \         idx\n                } else {\n                    closest_idx\n   \
    \             }\n            }\n        });\n        if (numbers[closest_idx]\
    \ - numbers[min_idx]).abs() > (numbers[closest_idx] - numbers[max_idx]).abs()\
    \ {\n            (numbers[max_idx], numbers[closest_idx])\n        } else {\n\
    \            (numbers[min_idx], numbers[closest_idx])\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp_ghcyeug.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut minimum_distance = (numbers[0], numbers[1]);\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          if (numbers[j] - numbers[i]).abs() < (minimum_distance.1 - minimum_distance.0).abs()\
    \ {\n                minimum_distance = (numbers[i], numbers[j]);\n          \
    \  }\n        }\n    }\n    minimum_distance\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpd6vfa0he.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut temp = numbers.clone();\n    temp.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut result = temp[0];\n    let mut diff\
    \ = temp[1] - temp[0];\n    let mut saved_1 = temp[0];\n    let mut saved_2 =\
    \ temp[1];\n    for i in 0..temp.len() - 1 {\n        if (temp[i + 1] - temp[i])\
    \ < diff {\n            diff = temp[i + 1] - temp[i];\n            result = temp[i];\n\
    \            saved_1 = temp[i];\n            saved_2 = temp[i + 1];\n        }\n\
    \    }\n    (saved_1, saved_2)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest = (numbers[0], numbers[1]);\n\
    \    let mut diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let new_diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if new_diff < diff {\n                closest\
    \ = (numbers[i], numbers[j]);\n                diff = new_diff;\n            }\n\
    \        }\n    }\n    closest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp1avd6jto.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut smallest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() - 1 {\n        let distance = (numbers[i + 1] - numbers[i]).abs();\n\
    \        if distance < smallest_distance {\n            closest_elements = (numbers[i],\
    \ numbers[i + 1]);\n            smallest_distance = distance;\n        }\n   \
    \ }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmptdjq4ejt.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut nums = numbers;\n    nums.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    (nums[0], nums[1])\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpkegj20fi.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"Not\
    \ enough values to compare!\");\n    }\n    let mut closest_pair = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\
    \    let mut numbers_iter = numbers.iter();\n    let mut first_num = numbers_iter.next().unwrap();\n\
    \    for second_num in numbers_iter {\n        let new_distance = (second_num\
    \ - first_num).abs();\n        if new_distance < closest_distance {\n        \
    \    closest_distance = new_distance;\n            closest_pair = (*first_num,\
    \ *second_num);\n        }\n        first_num = second_num;\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp2cngsn6t.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_numbers = numbers[0..2].to_vec();\n\
    \    let mut closest_distance = find_distance(closest_numbers[0], closest_numbers[1]);\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in (i + 1)..numbers.len()\
    \ {\n            let distance = find_distance(numbers[i], numbers[j]);\n     \
    \       if distance < closest_distance {\n                closest_numbers = vec![numbers[i],\
    \ numbers[j]];\n                closest_distance = distance;\n            }\n\
    \        }\n    }\n    (closest_numbers[0], closest_numbers[1])\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_distance` in this scope\n -->\
    \ /tmp/tmp_v8pjlk6.rs:9:32\n  |\n9 |     let mut closest_distance = find_distance(closest_numbers[0],\
    \ closest_numbers[1]);\n  |                                ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `find_distance` in this\
    \ scope\n  --> /tmp/tmp_v8pjlk6.rs:12:28\n   |\n12 |             let distance\
    \ = find_distance(numbers[i], numbers[j]);\n   |                            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976359
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpuyjtrult.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut result: Vec<f64> = vec![];\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ result.push((numbers[i], numbers[j], (numbers[i] - numbers[j]).abs()));\n  \
    \      }\n    }\n    result.sort_by(|&x, &y| x.2.partial_cmp(&y.2).unwrap());\n\
    \    (result[0].0, result[0].1)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp815t8g33.rs:11:25\n   |\n\
    11 |             result.push((numbers[i], numbers[j], (numbers[i] - numbers[j]).abs()));\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found tuple\n   |\n   = note: expected type `f64`\n        \
    \     found tuple `(f64, f64, f64)`\n\nerror[E0610]: `f64` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmp815t8g33.rs:14:31\n   |\n14\
    \ |     result.sort_by(|&x, &y| x.2.partial_cmp(&y.2).unwrap());\n   |       \
    \                        ^\n\nerror[E0610]: `f64` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp815t8g33.rs:14:48\n   |\n14 |     result.sort_by(|&x,\
    \ &y| x.2.partial_cmp(&y.2).unwrap());\n   |                                 \
    \               ^\n\nerror[E0610]: `f64` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp815t8g33.rs:15:16\n   |\n15 |     (result[0].0, result[0].1)\n\
    \   |                ^\n\nerror[E0610]: `f64` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp815t8g33.rs:15:29\n   |\n15 |     (result[0].0,\
    \ result[0].1)\n   |                             ^\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0610.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976359
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_indices = (0, 1);\n    let mut\
    \ smallest_distance = numbers[1] - numbers[0];\n    for idx in 1..numbers.len()\
    \ {\n        for idx2 in idx + 1..numbers.len() {\n            let diff = numbers[idx2]\
    \ - numbers[idx];\n            if diff < smallest_distance {\n               \
    \ closest_indices = (idx, idx2);\n                smallest_distance = diff;\n\
    \            }\n        }\n    }\n    (numbers[closest_indices.0], numbers[closest_indices.1])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpyku0b2q_.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Create an iterator of the numbers\n    let\
    \ mut numbers_iter = numbers.iter();\n    // Get the first two numbers from the\
    \ iterator\n    let mut current_closest_pair = (numbers_iter.next().unwrap(),\
    \ numbers_iter.next().unwrap());\n    // Create a variable to store the smallest\
    \ difference between elements so far\n    let mut smallest_difference = current_closest_pair.1\
    \ - current_closest_pair.0;\n    // Loop through the rest of the elements in the\
    \ iterator\n    for n in numbers_iter {\n        // Calculate the difference between\
    \ the two elements\n        let difference = n - current_closest_pair.0;\n   \
    \     // If the difference is less than the current smallest difference we have\
    \ found a new pair of closest elements\n        if difference < smallest_difference\
    \ {\n            current_closest_pair = (current_closest_pair.0, n);\n       \
    \     smallest_difference = difference;\n        }\n        // If the difference\
    \ is equal to the current smallest difference we have found another pair of elements\
    \ that\n        // are equally as close to each other as the last pair. The pair\
    \ is only replaced if the current pair has the\n        // smaller element first\n\
    \        else if difference == smallest_difference && n < current_closest_pair.1\
    \ {\n            current_closest_pair = (current_closest_pair.0, n);\n       \
    \ }\n        // Set the second element of the pair to the current element, since\
    \ the current element is less than the first\n        // element.\n        else\
    \ if n < current_closest_pair.0 {\n            current_closest_pair = (n, current_closest_pair.1);\n\
    \        }\n    }\n    // Return the closest pair of elements\n    current_closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp07xhpx4a.rs:36:5\n   |\n\
    7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |       \
    \                                         ---------- expected `(f64, f64)` because\
    \ of return type\n...\n36 |     current_closest_pair\n   |     ^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n   |\n   = note: expected tuple `(f64, f64)`\n\
    \              found tuple `(&f64, &f64)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976359
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut diff = std::f64::MAX;\n    let mut res\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            let d = (numbers[i] - numbers[j]).abs();\n            if d <\
    \ diff {\n                diff = d;\n                res = (numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpljtiy9rk.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut nums = numbers;\n    nums.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut closest_pair = (nums[0], nums[1]);\n\
    \    let mut closest_diff = (nums[1] - nums[0]).abs();\n    for i in 0..nums.len()\
    \ - 1 {\n        let diff = (nums[i + 1] - nums[i]).abs();\n        if diff <\
    \ closest_diff {\n            closest_pair = (nums[i], nums[i + 1]);\n       \
    \     closest_diff = diff;\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut first = numbers[0];\n    let mut second\
    \ = numbers[1];\n    let mut difference = (first - second).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in 0..numbers.len() {\n            if i !=\
    \ j {\n                let number_difference = (numbers[i] - numbers[j]).abs();\n\
    \                if number_difference < difference {\n                    difference\
    \ = number_difference;\n                    first = numbers[i];\n            \
    \        second = numbers[j];\n                }\n            }\n        }\n \
    \   }\n    (first, second)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpykzlgr47.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut result\
    \ = (numbers[0], numbers[1]);\n    let mut d = f64::abs(result.0 - result.1);\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let d1 = f64::abs(numbers[i] - numbers[j]);\n            if d1 < d\
    \ {\n                d = d1;\n                result = (numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6u1jzvgy.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_difference = f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for index in 0..numbers.len() {\n  \
    \      for inner_index in (index + 1)..numbers.len() {\n            let difference\
    \ = (numbers[index] - numbers[inner_index]).abs();\n            if difference\
    \ < closest_difference {\n                closest_difference = difference;\n \
    \               closest_elements = (numbers[index], numbers[inner_index]);\n \
    \           }\n        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpvq7ng3ft.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    find_closest_elements_iter(numbers)\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_closest_elements_iter` in this\
    \ scope\n --> /tmp/tmpr1236bn_.rs:8:5\n  |\n8 |     find_closest_elements_iter(numbers)\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976359
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let d = numbers[j] - numbers[i];\n            if d < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = d;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpq2utpn7b.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n          \
    \  let this_distance = numbers[j] - numbers[i];\n            if this_distance\
    \ < closest_distance {\n                closest_pair = (numbers[i], numbers[j]);\n\
    \                closest_distance = this_distance;\n            }\n        }\n\
    \    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpqgjswn2x.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let len = numbers.len();\n    if len < 2 {\n\
    \        panic!(\"numbers.len() must be at least 2\");\n    }\n\n    let mut min_distance\
    \ = f64::MAX;\n    let mut a = 0.0;\n    let mut b = 0.0;\n\n    for i in 0..len\
    \ {\n        for j in i+1..len {\n            let d = (numbers[i] - numbers[j]).abs();\n\
    \            if d < min_distance {\n                min_distance = d;\n      \
    \          a = numbers[i];\n                b = numbers[j];\n            }\n \
    \       }\n    }\n\n    if a > b {\n        (b, a)\n    } else {\n        (a,\
    \ b)\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp59kbq6xq.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_dist = f64::INFINITY;\n    let\
    \ mut ret = (0.0, 0.0);\n    for &x in &numbers {\n        for &y in &numbers\
    \ {\n            if (x - y).abs() < closest_dist {\n                closest_dist\
    \ = (x - y).abs();\n                ret = (x, y);\n            }\n        }\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp_6te8cjr.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_numbers.1 - closest_numbers.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let current_difference = numbers[j] - numbers[i];\n            if current_difference\
    \ < closest_difference {\n                closest_numbers = (numbers[i], numbers[j]);\n\
    \                closest_difference = current_difference;\n            }\n   \
    \     }\n    }\n    closest_numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp_b5f525z.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut idx_first = 0;\n    let mut idx_second\
    \ = 1;\n    let mut diff = numbers[idx_second] - numbers[idx_first];\n    for\
    \ i in 0..numbers.len() - 1 {\n        let diff_new = numbers[i + 1] - numbers[i];\n\
    \        if diff_new < diff {\n            idx_first = i;\n            idx_second\
    \ = i + 1;\n            diff = diff_new;\n        }\n    }\n    (numbers[idx_first],\
    \ numbers[idx_second])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpsbgaxx6z.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut result: (f64, f64) = (0.0, 0.0);\n  \
    \  let mut distance: f64 = (numbers[1] - numbers[0]).abs();\n    let mut i = 0;\n\
    \    while i < numbers.len() - 1 {\n        if (numbers[i + 1] - numbers[i]).abs()\
    \ < distance {\n            distance = (numbers[i + 1] - numbers[i]).abs();\n\
    \            result = (numbers[i], numbers[i + 1]);\n        }\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0.0, 0.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpa2qu1o8s.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dif = 1000000.0;\n    let mut min_dif_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let dif = (numbers[i] - numbers[j]).abs();\n            if dif\
    \ < min_dif {\n                min_dif = dif;\n                min_dif_pair =\
    \ (numbers[i], numbers[j]);\n            }\n        }\n    }\n    min_dif_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpimhb8lyr.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut iter = numbers.iter();\n    let mut smallest\
    \ = iter.next().unwrap();\n    let mut next_smallest = iter.next().unwrap();\n\
    \    for i in iter {\n        if *i - *smallest < *next_smallest - *smallest {\n\
    \            next_smallest = i;\n        }\n    }\n    if *next_smallest < *smallest\
    \ {\n        (next_smallest, smallest)\n    } else {\n        (smallest, next_smallest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9ro742g.rs:17:10\n   |\n\
    17 |         (next_smallest, smallest)\n   |          ^^^^^^^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |    \
    \     (*next_smallest, smallest)\n   |          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb9ro742g.rs:17:25\n   |\n17 |         (next_smallest, smallest)\n\
    \   |                         ^^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n17 |         (next_smallest, *smallest)\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb9ro742g.rs:19:10\n\
    \   |\n19 |         (smallest, next_smallest)\n   |          ^^^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n19\
    \ |         (*smallest, next_smallest)\n   |          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb9ro742g.rs:19:20\n   |\n19 |         (smallest, next_smallest)\n\
    \   |                    ^^^^^^^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |         (smallest, *next_smallest)\n\
    \   |                    +\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = None;\n    let mut min_pair = None;\n\
    \    for (idx, _) in numbers.iter().enumerate() {\n        let (left, right) =\
    \ (numbers[idx], numbers[idx + 1]);\n        let pair = (left, right);\n     \
    \   let diff = (left - right).abs();\n        if let Some(min_value) = min {\n\
    \            if diff < min_value {\n                min = Some(diff);\n      \
    \          min_pair = Some(pair);\n            }\n        } else {\n         \
    \   min = Some(diff);\n            min_pair = Some(pair);\n        }\n    }\n\
    \    return (min_pair.unwrap().0, min_pair.unwrap().1);\n}\n\nfn main() {\n  \
    \  let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmpsubybqsy.rs:11:44

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut pairs = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        for j in i+1..numbers.len() {\n            pairs.push((numbers[i],\
    \ numbers[j]));\n        }\n    }\n    let mut pairs = pairs.into_iter().map(|(a,\
    \ b)| (a - b).abs()).collect::<Vec<f64>>();\n    pairs.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n    \
    \        if (numbers[i] - numbers[j]).abs() == pairs[0] {\n                return\
    \ (numbers[i], numbers[j]);\n            }\n        }\n    }\n    panic!(\"unreachable\"\
    );\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpom7t5kg2.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut min_dif = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let dif = (numbers[j]\
    \ - numbers[i]).abs();\n            if dif < min_dif {\n                min_dif\
    \ = dif;\n                closest_pair = (numbers[i], numbers[j]);\n         \
    \   }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgcz9m1ed.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_pair = (numbers[0], numbers[1]);\n\
    \    let mut min_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        let current_distance = (numbers[i + 1] - numbers[i]).abs();\n\
    \        if current_distance < min_distance {\n            min_distance = current_distance;\n\
    \            min_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n    min_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyessudv.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_numbers = vec![numbers[0], numbers[1]];\n\
    \    let mut min_distance = closest_numbers[0] - closest_numbers[1];\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = numbers[i] - numbers[j];\n            if distance.abs() < min_distance.abs()\
    \ {\n                min_distance = distance;\n                closest_numbers\
    \ = vec![numbers[i], numbers[j]];\n            }\n        }\n    }\n    closest_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    (closest_numbers[0], closest_numbers[1])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    find_closest_elements_iter(numbers.into_iter())\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_closest_elements_iter` in this\
    \ scope\n --> /tmp/tmptphnckxr.rs:8:5\n  |\n8 |     find_closest_elements_iter(numbers.into_iter())\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"Not\
    \ enough numbers to compute result\");\n    }\n    let mut candidates = vec![];\n\
    \    let mut prev_num = numbers[0];\n    for num in numbers[1..].iter() {\n  \
    \      candidates.push((prev_num, num));\n        prev_num = *num;\n    }\n  \
    \  candidates.sort_by(|c1, c2| {\n        let d1 = (c1.0 - c1.1).abs();\n    \
    \    let d2 = (c2.0 - c2.1).abs();\n        d1.partial_cmp(&d2).unwrap()\n   \
    \ });\n    return (candidates[0].0, candidates[0].1);\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpop6ua7w4.rs:22:30\n   |\n\
    22 |     return (candidates[0].0, candidates[0].1);\n   |                    \
    \          ^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     return (candidates[0].0, *candidates[0].1);\n\
    \   |                              +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_diff_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let new_diff = numbers[i + 1] - numbers[i];\n        if new_diff\
    \ < min_diff {\n            min_diff = new_diff;\n            min_diff_pair =\
    \ (numbers[i], numbers[i + 1]);\n        }\n    }\n    min_diff_pair\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpaptv8lqt.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = (numbers[0], numbers[1]);\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i..numbers.len() {\n  \
    \          if j > i {\n                let current_min = (numbers[i], numbers[j]);\n\
    \                if current_min.1 - current_min.0 < min_diff.1 - min_diff.0 {\n\
    \                    min_diff = current_min;\n                }\n            }\n\
    \        }\n    }\n    min_diff\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpack9whxa.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut min_diff = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let diff = numbers[j] - numbers[i];\n            if diff < min_diff\
    \ {\n                min_diff = diff;\n                closest_elements = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    closest_elements\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptdol73nn.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut sorted_vec = numbers.clone();\n    sorted_vec.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut diff_val: (f64, f64) = (0.0, 0.0);\n\
    \    let mut diff_vec: Vec<f64> = Vec::new();\n    let mut diff: f64 = 0.0;\n\
    \    let mut i: usize = 0;\n    while i < sorted_vec.len() - 1 {\n        diff\
    \ = sorted_vec[i + 1] - sorted_vec[i];\n        diff_vec.push(diff);\n       \
    \ i += 1;\n    }\n    diff_val = (sorted_vec[diff_vec.iter().position(|&r| r ==\
    \ diff_vec.iter().min().unwrap()).unwrap()],\n                sorted_vec[diff_vec.iter().position(|&r|\
    \ r == diff_vec.iter().min().unwrap()).unwrap() + 1]);\n    diff_val\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_36yicow.rs:19:79\n\
    \     |\n19   |     diff_val = (sorted_vec[diff_vec.iter().position(|&r| r ==\
    \ diff_vec.iter().min().unwrap()).unwrap()],\n     |                         \
    \                                                      ^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_36yicow.rs:19:63\n\
    \   |\n19 |     diff_val = (sorted_vec[diff_vec.iter().position(|&r| r == diff_vec.iter().min().unwrap()).unwrap()],\n\
    \   |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |     diff_val = (sorted_vec[diff_vec.iter().position(|&r| r == *diff_vec.iter().min().unwrap()).unwrap()],\n\
    \   |                                                               +\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_36yicow.rs:20:79\n\
    \     |\n20   |                 sorted_vec[diff_vec.iter().position(|&r| r ==\
    \ diff_vec.iter().min().unwrap()).unwrap() + 1]);\n     |                    \
    \                                                           ^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |\n     = help: the following other types\
    \ implement trait `Ord`:\n               i128\n               i16\n          \
    \     i32\n               i64\n               i8\n               isize\n     \
    \          u128\n               u16\n             and 4 others\n     = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\nnote: required\
    \ by a bound in `std::iter::Iterator::min`\n\nerror[E0308]: mismatched types\n\
    \  --> /t"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    (1.0, 2.0)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp48pv8ead.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut smallest_difference = numbers[1] - numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        let difference = numbers[i] - numbers[i - 1];\n        if difference\
    \ < smallest_difference {\n            closest_pair = (numbers[i - 1], numbers[i]);\n\
    \            smallest_difference = difference;\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut small_num: f64 = 0.0;\n    let mut big_num:\
    \ f64 = 0.0;\n    let mut diff: f64 = 0.0;\n    let mut out: (f64, f64) = (0.0,\
    \ 0.0);\n    for (i, num) in numbers.iter().enumerate() {\n        if i == 0 {\n\
    \            small_num = num.clone();\n            big_num = num.clone();\n  \
    \          diff = 0.0;\n            out = (num.clone(), num.clone());\n      \
    \  } else {\n            if num < &small_num {\n                small_num = num.clone();\n\
    \            } else if num > &big_num {\n                big_num = num.clone();\n\
    \            } else {\n                let curr_diff = num - &small_num;\n   \
    \             if curr_diff < diff {\n                    diff = curr_diff;\n \
    \                   out = (small_num, num.clone());\n                }\n     \
    \       }\n        }\n    }\n    return out;\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmppe96eoyn.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    numbers.pop();\n    let mut closests: (f64,\
    \ f64) = (numbers[0], numbers[1]);\n    let len = numbers.len();\n    for i in\
    \ 0..len - 1 {\n        if (numbers[i + 1] - numbers[i]).abs() < (closests.1 -\
    \ closests.0).abs() {\n            closests = (numbers[i], numbers[i + 1]);\n\
    \        }\n    }\n    closests\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpsvw18ubt.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_pair = (numbers[0], numbers[1]);\n\
    \    let mut min_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if diff < min_diff {\n                min_diff\
    \ = diff;\n                min_pair = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpdzsn89s5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut prev = numbers[0];\n    let mut min_diff\
    \ = numbers[1] - numbers[0];\n    let mut min_lower = prev;\n    let mut min_upper\
    \ = numbers[1];\n    for i in 1..numbers.len() {\n        let diff = numbers[i]\
    \ - prev;\n        if diff < min_diff {\n            min_diff = diff;\n      \
    \      min_lower = prev;\n            min_upper = numbers[i];\n        }\n   \
    \     prev = numbers[i];\n    }\n    (min_lower, min_upper)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp8qo57fjk.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_diff = f64::MAX;\n    let mut\
    \ closest = (0.0, 0.0);\n    for a in &numbers {\n        for b in &numbers {\n\
    \            if a == b {\n                continue;\n            }\n         \
    \   let diff = (a - b).abs();\n            if diff < closest_diff {\n        \
    \        closest_diff = diff;\n                closest = (*a, *b);\n         \
    \   }\n        }\n    }\n    closest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpostzsa5r.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_distance = std::f64::MAX;\n \
    \   let mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n\
    \        for j in (i + 1)..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_distance = distance;\n                closest_elements = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    closest_elements\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmprx9kl4pd.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"There\
    \ must be at least two numbers supplied\");\n    }\n\n    let mut sorted_numbers\
    \ = numbers.clone();\n    sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \n    let mut closest_elements = (sorted_numbers[0], sorted_numbers[1]);\n   \
    \ let mut closest_difference = closest_elements.1 - closest_elements.0;\n\n  \
    \  let mut i = 0;\n    while i < sorted_numbers.len() - 1 {\n        let current_difference\
    \ = sorted_numbers[i + 1] - sorted_numbers[i];\n        if current_difference\
    \ < closest_difference {\n            closest_elements = (sorted_numbers[i], sorted_numbers[i\
    \ + 1]);\n            closest_difference = current_difference;\n        }\n  \
    \      i += 1;\n    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    if numbers.len()\
    \ == 2 {\n        return (numbers[0], numbers[1]);\n    }\n\n    let mut min_delta\
    \ = numbers[1] - numbers[0];\n    let mut min_num = (numbers[0], numbers[1]);\n\
    \    for i in 1..numbers.len() - 1 {\n        let delta = numbers[i + 1] - numbers[i];\n\
    \        if delta < min_delta {\n            min_delta = delta;\n            min_num\
    \ = (numbers[i], numbers[i + 1]);\n        }\n    }\n    min_num\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp7u_6eq7u.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // compute and return the closest two numbers\
    \ in the vector\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut smallest = numbers[0];\n    let mut biggest = numbers[1];\n    let\
    \ mut smallest_diff = numbers[1] - numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        let diff = numbers[i] - numbers[i - 1];\n        if diff < smallest_diff\
    \ {\n            smallest_diff = diff;\n            smallest = numbers[i - 1];\n\
    \            biggest = numbers[i];\n        }\n    }\n    (smallest, biggest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    (numbers[0], numbers[1])\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpe227nw4_.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjxdjlv7l.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut r1\
    \ = 0f64;\n    let mut r2 = 0f64;\n    for i in 0..numbers.len() - 1 {\n     \
    \   for j in i + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min {\n                min = diff;\n                r1\
    \ = numbers[i];\n                r2 = numbers[j];\n            }\n        }\n\
    \    }\n    if r1 > r2 {\n        (r2, r1)\n    } else {\n        (r1, r2)\n \
    \   }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut original = numbers.clone();\n    original.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let index = original.iter().enumerate().min_by_key(|&(_,\
    \ &x)| (original[1] - x).abs()).unwrap().0;\n    let mut result = Vec::with_capacity(2);\n\
    \    result.push(original[index]);\n    result.push(original[index + 1]);\n  \
    \  (result[0], result[1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp6so3ce8r.rs:10:56\n\
    \     |\n10   |     let index = original.iter().enumerate().min_by_key(|&(_, &x)|\
    \ (original[1] - x).abs()).unwrap().0;\n     |                               \
    \              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |                                          \
    \   |\n     |                                             required by a bound\
    \ introduced by this call\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\nnote: required by a bound in `std::iter::Iterator::min_by_key`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    //\n    // YOUR CODE HERE\n    //\n    (0.0,\
    \ 0.0)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0.0, 0.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp876ammys.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut diff: f64 = std::f64::MAX;\n    let mut\
    \ current_first: f64 = 0.0;\n    let mut current_second: f64 = 0.0;\n    for i\
    \ in 0..numbers.len() {\n        for j in 0..numbers.len() {\n            if i\
    \ != j {\n                let temp_diff = (numbers[i] - numbers[j]).abs();\n \
    \               if temp_diff < diff {\n                    diff = temp_diff;\n\
    \                    current_first = numbers[i];\n                    current_second\
    \ = numbers[j];\n                }\n            }\n        }\n    }\n    (current_first,\
    \ current_second)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp633h5hnn.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_difference = f64::INFINITY;\n\
    \    let mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n\
    \        for j in 0..numbers.len() {\n            if i != j {\n              \
    \  let difference = (numbers[i] - numbers[j]).abs();\n                if difference\
    \ < smallest_difference {\n                    smallest_difference = difference;\n\
    \                    closest_elements = (numbers[i], numbers[j]);\n          \
    \      }\n            }\n        }\n    }\n    closest_elements\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpkr6mvw0k.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO: implement me!\n    let mut closest:(f64,\
    \ f64)=(0.0,0.0);\n    let mut diff=std::f64::MAX;\n    for i in numbers{\n  \
    \      for j in numbers{\n            if i!=j && (j-i).abs()<diff{\n         \
    \       closest=(i,j);\n                diff=(j-i).abs();\n            }\n   \
    \     }\n    }\n    closest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp07xyn1t0.rs:12:18\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n11  |     for i in numbers{\n\
    \    |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    12  |         for j in numbers{\n    |                  ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for i in &numbers{\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut v_min = (0, 1);\n    let mut v_max =\
    \ (0, 1);\n    let mut min_dist = (numbers[1] - numbers[0]).abs();\n    let mut\
    \ max_dist = (numbers[1] - numbers[0]).abs();\n    for (i, n1) in numbers.iter().enumerate()\
    \ {\n        for n2 in numbers.iter().skip(i + 1) {\n            let dist = (n2\
    \ - n1).abs();\n            if dist > max_dist {\n                max_dist = dist;\n\
    \                v_max = (i, i + 1);\n            }\n            if dist < min_dist\
    \ {\n                min_dist = dist;\n                v_min = (i, i + 1);\n \
    \           }\n        }\n    }\n    (numbers[v_min.0], numbers[v_min.1])\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 4.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_68_hu8l.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut prev = numbers[0];\n    let mut min_dist\
    \ = numbers[1] - numbers[0];\n    let mut min_nums = (numbers[0], numbers[1]);\n\
    \    for num in numbers[1..].iter() {\n        let dist = num - prev;\n      \
    \  if dist < min_dist {\n            min_dist = dist;\n            min_nums =\
    \ (prev, *num);\n        }\n        prev = *num;\n    }\n    min_nums\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpm5osuzey.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let (mut closest_small, mut closest_large) =\
    \ (0, 0);\n    let mut smallest_gap = std::f64::MAX;\n    for (i, x) in numbers.iter().enumerate()\
    \ {\n        for y in numbers.iter().skip(i + 1) {\n            let gap = (x -\
    \ y).abs();\n            if gap < smallest_gap {\n                smallest_gap\
    \ = gap;\n                closest_small = *x;\n                closest_large =\
    \ *y;\n            }\n        }\n    }\n    (closest_small, closest_large)\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi7nxlcdg.rs:15:33\n   |\n\
    8  |     let (mut closest_small, mut closest_large) = (0, 0);\n   |          -----------------\
    \ expected due to the type of this binding\n...\n15 |                 closest_small\
    \ = *x;\n   |                                 ^^ expected integer, found `f64`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi7nxlcdg.rs:16:33\n   |\n8  |\
    \     let (mut closest_small, mut closest_large) = (0, 0);\n   |             \
    \                ----------------- expected due to the type of this binding\n\
    ...\n16 |                 closest_large = *y;\n   |                          \
    \       ^^ expected integer, found `f64`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpi7nxlcdg.rs:20:6\n   |\n20 |     (closest_small, closest_large)\n\
    \   |      ^^^^^^^^^^^^^ expected `f64`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi7nxlcdg.rs:20:21\n   |\n20 |     (closest_small, closest_large)\n\
    \   |                     ^^^^^^^^^^^^^ expected `f64`, found integer\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = f64::INFINITY;\n    let\
    \ mut x_1 = 0.0;\n    let mut x_2 = 0.0;\n    for i in 0..numbers.len() {\n  \
    \      for j in 0..numbers.len() {\n            if i != j {\n                let\
    \ distance = (numbers[i] - numbers[j]).abs();\n                if distance < min_distance\
    \ {\n                    min_distance = distance;\n                    x_1 = numbers[i];\n\
    \                    x_2 = numbers[j];\n                }\n            }\n   \
    \     }\n    }\n    (x_1, x_2)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpcwn5rzht.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"Less\
    \ than two elements!\");\n    }\n    let mut v = numbers;\n    v.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    (v[0], v[1])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp19cfyzdo.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut prev = numbers[0];\n    let mut curr\
    \ = numbers[1];\n    let mut closest = (prev, curr);\n    for n in numbers.iter().skip(2)\
    \ {\n        if n - prev < curr - prev {\n            closest = (prev, *n);\n\
    \        }\n        prev = curr;\n        curr = *n;\n    }\n    closest\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(4.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpv_mtfkaq.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut best_diff = numbers[1] - numbers[0];\n\
    \    let mut best_pair = (numbers[0], numbers[1]);\n    for pair in numbers.windows(2)\
    \ {\n        let diff = pair[1] - pair[0];\n        if diff < best_diff {\n  \
    \          best_diff = diff;\n            best_pair = (pair[0], pair[1]);\n  \
    \      }\n    }\n    best_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut result = (f64::MAX, f64::MAX);\n    for\
    \ i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n     \
    \       let (first, second) = (numbers[i], numbers[j]);\n            if (second\
    \ - first).abs() < (result.1 - result.0).abs() {\n                result = (first,\
    \ second);\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.7976931348623157e308, 1.7976931348623157e308)`,\n right: `(3.9, 4.0)`',\
    \ /tmp/tmp9x7v9v7q.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut diff = numbers[1] - numbers[0];\n\
    \    let mut index = 0;\n    for i in 1..numbers.len() - 1 {\n        let new_diff\
    \ = numbers[i + 1] - numbers[i];\n        if new_diff < diff {\n            diff\
    \ = new_diff;\n            index = i;\n        }\n    }\n    (numbers[index],\
    \ numbers[index + 1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for (index, number) in numbers.iter().enumerate() {\n        if index + 1 <\
    \ numbers.len() {\n            let next_number = numbers[index + 1];\n       \
    \     let distance = next_number - number;\n            if distance < closest_distance\
    \ {\n                closest_elements = (number, next_number);\n             \
    \   closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpazr478z5.rs:15:37\n   |\n\
    15 |                 closest_elements = (number, next_number);\n   |         \
    \                            ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n15 |                 closest_elements\
    \ = (*number, next_number);\n   |                                     +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO 6\n    let mut min = numbers[0];\n  \
    \  let mut s_min = numbers[1];\n    if numbers[0] > numbers[1] {\n        min\
    \ = numbers[1];\n        s_min = numbers[0];\n    }\n    for i in numbers {\n\
    \        if i < min {\n            s_min = min;\n            min = i;\n      \
    \  } else if i < s_min {\n            s_min = i;\n        }\n    }\n    (min,\
    \ s_min)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpoeye0kxa.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Your code here\n    (1.0, 2.0)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmplulnt0ml.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // We convert the vector to an iterator.\n  \
    \  let mut it = numbers.iter();\n    // We get the first number and convert it\
    \ to a f64.\n    let mut first = *it.next().unwrap() as f64;\n    // We get the\
    \ second number and convert it to a f64.\n    let mut second = *it.next().unwrap()\
    \ as f64;\n    // We calculate the distance between the first and second number.\n\
    \    let mut diff = (first - second).abs();\n    // We iterate over the iterator.\n\
    \    for v in it {\n        // We convert the value to a f64.\n        let n =\
    \ *v as f64;\n        // We calculate the distance between the first and second\
    \ number.\n        let distance = (first - n).abs();\n        // If the distance\
    \ is smaller than the current difference.\n        if distance < diff {\n    \
    \        // We set the second number to the current number.\n            second\
    \ = n;\n            // We calculate the distance between the first and second\
    \ number.\n            diff = (first - second).abs();\n        }\n    }\n    //\
    \ We return the first and second number, in order.\n    (first, second)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpxg9e6vxe.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if diff < closest_diff {\n               \
    \ closest_pair = (numbers[i], numbers[j]);\n                closest_diff = diff;\n\
    \            }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpztqbmm3j.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut sorted_numbers = numbers.clone();\n \
    \   sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (\n       \
    \ sorted_numbers[0],\n        sorted_numbers[1]\n    )\n}\n\nfn main() {\n   \
    \ let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpeznmrrcs.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers_copy = numbers.clone();\n   \
    \ numbers_copy.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (\n        numbers_copy[0],\n\
    \        numbers_copy[1]\n    )\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmppsvpte7q.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n    for number in numbers.iter() {\n        if *number > max {\n\
    \            max = *number;\n        }\n        if *number < min {\n         \
    \   min = *number;\n        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpdvoym7eq.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Try to find two elements as close as possible.\n\
    \    // Return the two elements, or two identical elements if none are close.\n\
    \    let mut closest_pair: (f64, f64) = (numbers[0], numbers[0]);\n    let mut\
    \ closest_distance: f64 = std::f64::MAX;\n    for i in 0..numbers.len() {\n  \
    \      for j in i + 1..numbers.len() {\n            let difference = (numbers[i]\
    \ - numbers[j]).abs();\n            if difference < closest_distance {\n     \
    \           closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = difference;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmps09rg9sa.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // ensure that a slice of at least length 2 is\
    \ provided\n    let mut numbers = numbers;\n    assert!(numbers.len() >= 2);\n\
    \n    // we'll mutate the slice, so clone the first two elements to use as our\
    \ default starting values\n    let mut closest_a = numbers[0];\n    let mut closest_b\
    \ = numbers[1];\n\n    // iterate over all the possible combinations of elements\
    \ in the slice and keep track of the ones\n    // which have the smallest distance\
    \ between them\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len()\
    \ {\n            let a = numbers[i];\n            let b = numbers[j];\n      \
    \      let distance = b - a;\n            if distance < closest_b - closest_a\
    \ {\n                closest_a = a;\n                closest_b = b;\n        \
    \    }\n        }\n    }\n\n    (closest_a, closest_b)\n}\n\nfn main() {\n   \
    \ let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpms3mj0a0.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let (mut lower, mut upper) = (0.0, 0.0);\n  \
    \  let mut min_distance = std::f64::MAX;\n    for i in 0..numbers.len() - 1 {\n\
    \        for j in (i + 1)..numbers.len() {\n            let distance = (numbers[i]\
    \ - numbers[j]).abs();\n            if distance < min_distance {\n           \
    \     min_distance = distance;\n                lower = numbers[i];\n        \
    \        upper = numbers[j];\n            }\n        }\n    }\n    if lower >\
    \ upper {\n        (upper, lower)\n    } else {\n        (lower, upper)\n    }\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_difference = std::f64::MAX;\n\
    \    let mut result: (f64, f64) = (0.0, 0.0);\n    for i in 0..numbers.len() -\
    \ 1 {\n        for j in i + 1..numbers.len() {\n            let difference = (numbers[i]\
    \ - numbers[j]).abs();\n            if difference < smallest_difference {\n  \
    \              smallest_difference = difference;\n                result = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpd3gruemv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // find the 2 closest numbers\n    let mut closest_numbers:\
    \ Vec<&f64> = numbers.iter().take(2).collect();\n    let mut closest_distance\
    \ = closest_numbers[1] - closest_numbers[0];\n    for i in 0..numbers.len() {\n\
    \        for j in i+1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_numbers = vec![&numbers[i], &numbers[j]];\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    (closest_numbers[0].clone(),\
    \ closest_numbers[1].clone())\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjbgmvpbt.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO write your code here!\n    (0.0, 0.0)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0.0, 0.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp4v03j8kb.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"numbers\
    \ has less than two elements\")\n    }\n\n    let mut numbers = numbers;\n   \
    \ numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\n    let mut min_diff =\
    \ f64::MAX;\n    let mut min_a = 0.0;\n    let mut min_b = 0.0;\n\n    for i in\
    \ 0..numbers.len() - 1 {\n        let a = numbers[i];\n        let b = numbers[i\
    \ + 1];\n        let diff = (a - b).abs();\n        if diff < min_diff {\n   \
    \         min_diff = diff;\n            min_a = a;\n            min_b = b;\n \
    \       }\n    }\n\n    (min_a, min_b)\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut sorted_numbers = numbers.clone();\n \
    \   sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_diff\
    \ = 9999999999999.0;\n    let mut closest_numbers = (0.0, 0.0);\n    for i in\
    \ 0..sorted_numbers.len()-1 {\n        let current_diff = sorted_numbers[i+1]\
    \ - sorted_numbers[i];\n        if current_diff < min_diff {\n            min_diff\
    \ = current_diff;\n            closest_numbers = (sorted_numbers[i], sorted_numbers[i+1]);\n\
    \        }\n    }\n    closest_numbers\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let (closest, closest_values) = numbers.windows(2).min_by_key(|w|\
    \ {\n        let (a, b) = (w[0], w[1]);\n        (b - a).abs()\n    }).unwrap();\n\
    \    (closest_values[0], closest_values[1])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsvjikca8.rs:8:67\n\
    \     |\n8    |       let (closest, closest_values) = numbers.windows(2).min_by_key(|w|\
    \ {\n     |  ________________________________________________________----------_^\n\
    \     | |                                                        |\n     | | \
    \                                                       required by a bound introduced\
    \ by this call\n9    | |         let (a, b) = (w[0], w[1]);\n10   | |        \
    \ (b - a).abs()\n11   | |     }).unwrap();\n     | |_____^ the trait `Ord` is\
    \ not implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\nnote: required by a bound in `std::iter::Iterator::min_by_key`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsvjikca8.rs:8:9\n   |\n8  |  \
    \     let (closest, closest_values) = numbers.windows(2).min_by_key(|w| {\n  \
    \ |  _________^^^^^^^^^^^^^^^^^^^^^^^^^___-\n   | |         |\n   | |        \
    \ expected slice `[f64]`, found tuple\n9  | |         let (a, b) = (w[0], w[1]);\n\
    10 | |         (b - a).abs()\n11 | |     }).unwrap();\n   | |_______________-\
    \ this expression has type `&[f64]`\n   |\n   = note: expected slice `[f64]`\n\
    \              found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    (1.0, 2.0)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp48pv8ead.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_distance = f64::MAX;\n    let\
    \ mut closest_elements = (0f64, 0f64);\n    for num1 in numbers.iter() {\n   \
    \     for num2 in numbers.iter() {\n            if *num1 == *num2 {\n        \
    \        continue;\n            }\n            let distance = (*num1 - *num2).abs();\n\
    \            if distance < closest_distance {\n                closest_distance\
    \ = distance;\n                closest_elements = (*num1, *num2);\n          \
    \  }\n        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpyzg3xw1v.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut new_numbers = numbers.clone();\n    new_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut closest_distance = new_numbers[1]\
    \ - new_numbers[0];\n    let mut closest_elements = (new_numbers[0], new_numbers[1]);\n\
    \    for i in 1..new_numbers.len() - 1 {\n        let distance = new_numbers[i\
    \ + 1] - new_numbers[i];\n        if distance < closest_distance {\n         \
    \   closest_distance = distance;\n            closest_elements = (new_numbers[i],\
    \ new_numbers[i + 1]);\n        }\n    }\n    closest_elements\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut closest_distance\
    \ = f64::MAX;\n    let mut closest_values = (0.0, 0.0);\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[i]\
    \ - numbers[j]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_values = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    if closest_values.0 > closest_values.1\
    \ {\n        (closest_values.1, closest_values.0)\n    } else {\n        closest_values\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = 100.0;\n    let mut pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = numbers[i] - numbers[j];\n            if diff < 0.0\
    \ {\n                diff *= -1.0;\n            }\n            if diff < min {\n\
    \                min = diff;\n                pair = (numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `diff`\n  --> /tmp/tmpagi8n77r.rs:14:17\n\
    \   |\n12 |             let diff = numbers[i] - numbers[j];\n   |            \
    \     ----\n   |                 |\n   |                 first assignment to `diff`\n\
    \   |                 help: consider making this binding mutable: `mut diff`\n\
    13 |             if diff < 0.0 {\n14 |                 diff *= -1.0;\n   |   \
    \              ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut min_diff = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in (i + 1)..numbers.len() {\n            let diff = numbers[j]\
    \ - numbers[i];\n            if diff < min_diff {\n                min_diff =\
    \ diff;\n                closest_pair = (numbers[i], numbers[j]);\n          \
    \  }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpyi1_5d9g.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    let mut closest = std::f64::MAX;\n    for n in numbers {\n\
    \        if n < smallest {\n            smallest = n;\n        }\n        if n\
    \ > largest {\n            largest = n;\n        }\n        for n2 in numbers\
    \ {\n            if n == n2 {\n                continue;\n            }\n    \
    \        let candidate = (n - n2).abs();\n            if candidate < closest {\n\
    \                closest = candidate;\n                smallest = n;\n       \
    \         largest = n2;\n            }\n        }\n    }\n    if smallest > largest\
    \ {\n        (largest, smallest)\n    } else {\n        (smallest, largest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpe9du_hsf.rs:18:19\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n11  |     for n in numbers {\n\
    \    |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |         for n2 in numbers {\n    |                   ^^^^^^^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\nhelp: consider iterating over a slice of the\
    \ `Vec<f64>`'s content to avoid moving into the `for` loop\n    |\n11  |     for\
    \ n in &numbers {\n    |              +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut smallest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() {\n        for j in 0..numbers.len() {\n            if i\
    \ != j {\n                let diff = (numbers[i] - numbers[j]).abs();\n      \
    \          if diff < smallest_difference {\n                    smallest_difference\
    \ = diff;\n                    closest_elements = (numbers[i], numbers[j]);\n\
    \                }\n            }\n        }\n    }\n    closest_elements\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpkky4qd1u.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO\n\n    let mut index = 0;\n    let mut\
    \ distance = (numbers[0], numbers[1]).1 - (numbers[0], numbers[1]).0;\n    let\
    \ mut pair = (numbers[0], numbers[1]);\n\n    for i in 1..numbers.len() - 1 {\n\
    \        let temp = (numbers[i], numbers[i + 1]).1 - (numbers[i], numbers[i +\
    \ 1]).0;\n        if temp < distance {\n            distance = temp;\n       \
    \     pair = (numbers[i], numbers[i + 1]);\n            index = i;\n        }\n\
    \    }\n\n    if numbers[0] < numbers[1] {\n        let temp = (numbers[0], numbers[1]).1\
    \ - (numbers[0], numbers[1]).0;\n        if temp < distance {\n            pair\
    \ = (numbers[0], numbers[1]);\n        }\n    }\n\n    pair\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp87qb4izj.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO!\n    let mut min_diff = std::f64::MAX;\n\
    \    let mut min_num = (0.0, 0.0);\n    let mut has_same = false;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n  \
    \      if diff < min_diff {\n            min_diff = diff;\n            min_num\
    \ = (numbers[i], numbers[i + 1]);\n        }\n        if diff == 0.0 {\n     \
    \       has_same = true;\n        }\n    }\n    if has_same {\n        (numbers[0],\
    \ numbers[0])\n    } else {\n        min_num\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpkksfkoc5.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut closest = (numbers[0], numbers[1]);\n\
    \    let mut minimum_distance = closest.1 - closest.0;\n    for i in 1..numbers.len()\
    \ - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n        if distance\
    \ < minimum_distance {\n            closest = (numbers[i], numbers[i + 1]);\n\
    \            minimum_distance = distance;\n        }\n    }\n    closest\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let (diff, (a, b)) = numbers.windows(2)\n\
    \        .map(|x| (x[1] - x[0], (x[0], x[1])))\n        .min_by(|x, y| x.0.partial_cmp(&y.0).unwrap())\n\
    \        .unwrap();\n    (a, b)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let (mut number_1, mut number_2) = (0.0, 0.0);\n\
    \    let mut distance = std::f64::MAX;\n    let mut counter = 0;\n    let size\
    \ = numbers.len();\n    while counter < size {\n        let (first, second) =\
    \ (numbers[counter], numbers[counter + 1]);\n        let d = first - second;\n\
    \        if d.abs() < distance {\n            distance = d.abs();\n          \
    \  number_1 = first;\n            number_2 = second;\n        }\n        counter\
    \ += 1;\n    }\n    (number_1, number_2)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmp6abbmm8x.rs:13:50

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = numbers[1] - numbers[0];\n\
    \    let mut closest_numbers = (numbers[0], numbers[1]);\n    for (index, first_number)\
    \ in numbers.iter().enumerate() {\n        for second_number in numbers.iter().skip(index\
    \ + 1) {\n            let distance = second_number - first_number;\n         \
    \   if distance < min_distance {\n                min_distance = distance;\n \
    \               closest_numbers = (first_number, second_number);\n           \
    \ }\n        }\n    }\n    closest_numbers\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuav1mqcf.rs:15:36\n   |\n\
    15 |                 closest_numbers = (first_number, second_number);\n   |  \
    \                                  ^^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |                 closest_numbers\
    \ = (*first_number, second_number);\n   |                                    +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuav1mqcf.rs:15:50\n   |\n15 |\
    \                 closest_numbers = (first_number, second_number);\n   |     \
    \                                             ^^^^^^^^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |          \
    \       closest_numbers = (first_number, *second_number);\n   |              \
    \                                    +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Start with a very large diff as a basis\n\
    \    let mut min_diff = 99999.0;\n    let mut min_num1 = 0.0;\n    let mut min_num2\
    \ = 0.0;\n\n    // Loop over all numbers and look for the smallest difference\n\
    \    for i in 0..numbers.len() - 1 {\n        // We need to do abs() of the difference\
    \ to get a real minimum distance\n        let diff = (numbers[i] - numbers[i +\
    \ 1]).abs();\n        if diff < min_diff {\n            min_diff = diff;\n   \
    \         min_num1 = numbers[i];\n            min_num2 = numbers[i + 1];\n   \
    \     }\n    }\n\n    // We return the numbers so that the first one is lower\
    \ than the second\n    if min_num1 > min_num2 {\n        (min_num2, min_num1)\n\
    \    } else {\n        (min_num1, min_num2)\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp1cnd2x0z.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    for number in numbers.iter() {\n        for next_number in numbers.iter()\
    \ {\n            if next_number > number {\n                if (*next_number -\
    \ *number) < (*closest_pair.1 - *closest_pair.0) {\n                    closest_pair\
    \ = (*number, *next_number);\n                }\n            }\n        }\n  \
    \  }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpizhnxksq.rs:12:48\n\
    \   |\n12 |                 if (*next_number - *number) < (*closest_pair.1 - *closest_pair.0)\
    \ {\n   |                                                ^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpizhnxksq.rs:12:66\n   |\n12\
    \ |                 if (*next_number - *number) < (*closest_pair.1 - *closest_pair.0)\
    \ {\n   |                                                                  ^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut result = (numbers[0], numbers[1]);\n\
    \    for i in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n    \
    \        if abs_difference(numbers[i], numbers[j]) < abs_difference(result.0,\
    \ result.1) {\n                result = (numbers[i], numbers[j]);\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs_difference` in this scope\n  -->\
    \ /tmp/tmpi48qdlc5.rs:11:16\n   |\n11 |             if abs_difference(numbers[i],\
    \ numbers[j]) < abs_difference(result.0, result.1) {\n   |                ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `abs_difference`\
    \ in this scope\n  --> /tmp/tmpi48qdlc5.rs:11:57\n   |\n11 |             if abs_difference(numbers[i],\
    \ numbers[j]) < abs_difference(result.0, result.1) {\n   |                   \
    \                                      ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    //let mut min = std::f64::MAX;\n    let mut min\
    \ = (std::f64::MAX, std::f64::MAX);\n    let mut max = (std::f64::MIN, std::f64::MIN);\n\
    \    let mut prev = numbers[0];\n    for i in 1..numbers.len() {\n        let\
    \ current = numbers[i];\n        if current - prev < min.0 {\n            min\
    \ = (current - prev, current);\n        } else if current - prev > max.0 {\n \
    \           max = (current - prev, current);\n        }\n        prev = current;\n\
    \    }\n    if min.0 < max.0 {\n        (min.1 - min.0, min.1)\n    } else {\n\
    \        (max.1 - max.0, max.1)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpv33w7w7w.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    (1.0, 2.0)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp48pv8ead.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_diff = std::f64::MAX;\n    let mut current_diff = 0.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          current_diff = (numbers[i] - numbers[j]).abs();\n            if current_diff\
    \ < closest_diff {\n                closest_diff = current_diff;\n           \
    \     closest_pair = (numbers[i], numbers[j]);\n            }\n        }\n   \
    \ }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpjln_7iw7.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest = (numbers[0], numbers[1]);\n\
    \    let mut diff = numbers[1] - numbers[0];\n    for i in 0..numbers.len() -\
    \ 1 {\n        for j in i + 1..numbers.len() {\n            let ndiff = numbers[j]\
    \ - numbers[i];\n            if ndiff < diff {\n                closest = (numbers[i],\
    \ numbers[j]);\n                diff = ndiff;\n            }\n        }\n    }\n\
    \    closest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpuowunqql.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_pair = (numbers[0], numbers[1]);\n\
    \    let mut min_distance = numbers[1] - numbers[0];\n    for i in 0..numbers.len()\
    \ - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n        if distance\
    \ < min_distance {\n            min_distance = distance;\n            min_pair\
    \ = (numbers[i], numbers[i + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmphgyxnzot.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    let mut smallest_difference = None;\n    for i in 0..numbers.len()\
    \ {\n        for j in 0..numbers.len() {\n            if i != j {\n          \
    \      let curr_difference = numbers[i] - numbers[j];\n                let difference\
    \ = if curr_difference < 0.0 {\n                    -curr_difference\n       \
    \         } else {\n                    curr_difference\n                };\n\
    \                if smallest_difference.is_none() || difference < smallest_difference.unwrap()\
    \ {\n                    smallest_difference = Some(difference);\n           \
    \         smallest = numbers[i];\n                    largest = numbers[j];\n\
    \                }\n            }\n        }\n    }\n    if smallest < largest\
    \ {\n        (smallest, largest)\n    } else {\n        (largest, smallest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut min_diff = closest_pair.1 - closest_pair.0;\n    let mut pair_of_numbers\
    \ = (closest_pair.0, closest_pair.1);\n    for i in 0..numbers.len() {\n     \
    \   for j in (i + 1)..numbers.len() {\n            let diff = numbers[j] - numbers[i];\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        pair_of_numbers = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    pair_of_numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpj5gf4wc8.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut vec = numbers;\n    vec.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut min = vec[0];\n    let mut min_plus\
    \ = vec[1];\n    for i in 0..vec.len() - 1 {\n        if vec[i + 1] - vec[i] <\
    \ min_plus - min {\n            min = vec[i];\n            min_plus = vec[i +\
    \ 1];\n        }\n    }\n    (min, min_plus)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // if numbers.len() < 2 {\n    //     panic!(\"\
    Too few numbers ({:?}) in the supplied vector\", numbers.len());\n    // }\n \
    \   let mut numbers_iter = numbers.iter();\n    let mut minimum_distance = std::f64::MAX;\n\
    \    let mut result = (0.0, 0.0);\n    let mut first_num = numbers_iter.next().unwrap();\n\
    \    for second_num in numbers_iter {\n        let distance = first_num - second_num;\n\
    \        if distance < minimum_distance {\n            minimum_distance = distance;\n\
    \            result = (*first_num, *second_num);\n        }\n        first_num\
    \ = second_num;\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.0, 3.9)`,\n right: `(3.9, 4.0)`', /tmp/tmpinilp04f.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_values = (numbers[0], numbers[1]);\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = numbers[j]\
    \ - numbers[i];\n            if diff < min_diff {\n                min_diff =\
    \ diff;\n                min_values = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    min_values\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpf4om5nut.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        let diff\
    \ = numbers[i + 1] - numbers[i];\n        if diff < min_diff {\n            min_diff\
    \ = diff;\n            min_pair = (numbers[i], numbers[i + 1]);\n        }\n \
    \   }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_so_far = (numbers[0], numbers[1]);\n\
    \    let mut difference_so_far = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in 0..numbers.len() {\n            if (numbers[i]\
    \ - numbers[j]).abs() < difference_so_far {\n                closest_so_far =\
    \ (numbers[i], numbers[j]);\n                difference_so_far = (numbers[i] -\
    \ numbers[j]).abs();\n            }\n        }\n    }\n    closest_so_far\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpbx8axytn.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0] - numbers[1];\n    let\
    \ mut min_num1 = numbers[0];\n    let mut min_num2 = numbers[1];\n    for i in\
    \ 0..numbers.len() - 1 {\n        for j in i+1..numbers.len() {\n            let\
    \ diff = numbers[i] - numbers[j];\n            if diff.abs() < min.abs() {\n \
    \               min = diff;\n                min_num1 = numbers[i];\n        \
    \        min_num2 = numbers[j];\n            }\n        }\n    }\n    (min_num1,\
    \ min_num2)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbe7ls6ax.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let (mut first, mut second) = (0.0, 0.0);\n \
    \   let mut min_distance = f64::INFINITY;\n    for (i, ni) in numbers.iter().enumerate()\
    \ {\n        for (j, nj) in numbers.iter().enumerate() {\n            if i !=\
    \ j {\n                let distance = (ni - nj).abs();\n                if distance\
    \ < min_distance {\n                    min_distance = distance;\n           \
    \         first = *ni;\n                    second = *nj;\n                }\n\
    \            }\n        }\n    }\n    if first > second {\n        (second, first)\n\
    \    } else {\n        (first, second)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"At least\
    \ two numbers are required\")\n    }\n    let mut closest_pair = (numbers[0],\
    \ numbers[1]);\n    let mut delta = (numbers[1] - numbers[0]).abs();\n    let\
    \ mut current_pair = (numbers[0], numbers[1]);\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            current_pair = (numbers[i],\
    \ numbers[j]);\n            let new_delta = (current_pair.1 - current_pair.0).abs();\n\
    \            if new_delta < delta {\n                closest_pair = current_pair;\n\
    \                delta = new_delta;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpnse635g5.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_two: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_two_diff = (numbers[1] - numbers[0]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let diff = (numbers[j] - numbers[i]).abs();\n            if diff <\
    \ closest_two_diff {\n                closest_two = (numbers[i], numbers[j]);\n\
    \                closest_two_diff = diff;\n            }\n        }\n    }\n \
    \   closest_two\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp7i3z6czd.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut closest_numbers = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 1..numbers.len() - 1 {\n        let difference = (numbers[i + 1] - numbers[i]).abs();\n\
    \        if difference < closest_difference {\n            closest_difference\
    \ = difference;\n            closest_numbers = (numbers[i], numbers[i + 1]);\n\
    \        }\n    }\n    closest_numbers\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut first_value = numbers[0];\n    let mut\
    \ second_value = numbers[1];\n    let mut diff = abs(first_value - second_value);\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          if abs(numbers[i] - numbers[j]) < diff {\n                first_value\
    \ = numbers[i];\n                second_value = numbers[j];\n                diff\
    \ = abs(first_value - second_value);\n            }\n        }\n    }\n    (first_value,\
    \ second_value)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpyw2a_vaa.rs:10:20\n\
    \   |\n10 |     let mut diff = abs(first_value - second_value);\n   |        \
    \            ^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `abs` in this scope\n  --> /tmp/tmpyw2a_vaa.rs:13:16\n   |\n13 |           \
    \  if abs(numbers[i] - numbers[j]) < diff {\n   |                ^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  -->\
    \ /tmp/tmpyw2a_vaa.rs:16:24\n   |\n16 |                 diff = abs(first_value\
    \ - second_value);\n   |                        ^^^ not found in this scope\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut min_difference = numbers[1] - numbers[0];\n\
    \    let mut number_pair = (numbers[0], numbers[1]);\n    for i in 0..numbers.len()\
    \ - 1 {\n        let difference = numbers[i + 1] - numbers[i];\n        if difference\
    \ < min_difference {\n            min_difference = difference;\n            number_pair\
    \ = (numbers[i], numbers[i + 1]);\n        }\n    }\n    number_pair\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = f64::INFINITY;\n    let mut answer:\
    \ (f64, f64) = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        for j\
    \ in i + 1..numbers.len() {\n            let current = numbers[i] - numbers[j];\n\
    \            if current.abs() < min {\n                min = current.abs();\n\
    \                answer = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    answer\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqe498el2.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_difference = f64::INFINITY;\n   \
    \ let mut min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for\
    \ j in i + 1..numbers.len() {\n            let diff = numbers[j] - numbers[i];\n\
    \            if diff < min_difference {\n                min_difference = diff;\n\
    \                min_pair = (numbers[i], numbers[j]);\n            }\n       \
    \ }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpvw50sqv0.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_diff = std::f64::MAX;\n    let\
    \ mut closest_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for\
    \ j in i+1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < closest_diff {\n                closest_diff = diff;\n\
    \                closest_pair = (numbers[i], numbers[j]);\n            }\n   \
    \     }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpt50jbd14.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut last_number = 0.0;\n    let mut closest_pair\
    \ = (0.0, 0.0);\n    let mut delta = std::f64::MAX;\n    for x in numbers {\n\
    \        if x != last_number {\n            let difference = (x - last_number).abs();\n\
    \            if difference < delta {\n                delta = difference;\n  \
    \              closest_pair = (last_number, x);\n            }\n        }\n  \
    \      last_number = x;\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0.0, 1.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpvqodd6ru.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjvuujxrs.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers_sorted = numbers.clone();\n \
    \   numbers_sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut closest_pair\
    \ = (numbers_sorted[0], numbers_sorted[1]);\n    let mut min_distance = closest_pair.1\
    \ - closest_pair.0;\n    for i in 1..numbers_sorted.len() - 1 {\n        let distance\
    \ = numbers_sorted[i + 1] - numbers_sorted[i];\n        if distance < min_distance\
    \ {\n            min_distance = distance;\n            closest_pair = (numbers_sorted[i],\
    \ numbers_sorted[i + 1]);\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    (1.0, 2.0)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp48pv8ead.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_difference = 1000000.0;\n  \
    \  let mut closest_pair = (0.0, 0.0);\n    let mut temp = 0.0;\n    let mut c\
    \ = 0;\n    let mut d = 0;\n    let mut numbers_clone = numbers.clone();\n   \
    \ numbers_clone.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    for a in 0..numbers_clone.len()\
    \ - 1 {\n        temp = numbers_clone[a + 1] - numbers_clone[a];\n        if temp\
    \ < smallest_difference {\n            smallest_difference = temp;\n         \
    \   c = a;\n            d = a + 1;\n        }\n    }\n    closest_pair = (numbers_clone[c],\
    \ numbers_clone[d]);\n    closest_pair\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"need\
    \ at least two numbers\");\n    }\n    if numbers.len() == 2 {\n        return\
    \ (numbers[0], numbers[1]);\n    }\n    let mut lowest_difference = f64::MAX;\n\
    \    let mut lowest_numbers = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n\
    \        for j in i + 1..numbers.len() {\n            let difference = (numbers[i]\
    \ - numbers[j]).abs();\n            if difference < lowest_difference {\n    \
    \            lowest_difference = difference;\n                lowest_numbers =\
    \ (numbers[i], numbers[j]);\n            }\n        }\n    }\n    lowest_numbers\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp8l2qix8x.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_abs = std::f64::MAX;\n    let mut\
    \ ans = (0.0, 0.0);\n    let mut prev = numbers[0];\n    for num in numbers.iter().skip(1)\
    \ {\n        let abs = num - prev;\n        if abs < min_abs {\n            min_abs\
    \ = abs;\n            ans = (prev, *num);\n        }\n        prev = *num;\n \
    \   }\n    ans\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpyh5mtjhg.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"Input\
    \ must have length at least 2!\");\n    }\n    let mut nums = numbers.clone();\n\
    \    nums.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    // Find the closest\
    \ pair of elements.\n    let mut closest_diff = nums[1] - nums[0];\n    let mut\
    \ closest_pair = (nums[0], nums[1]);\n    for i in 1..nums.len() - 1 {\n     \
    \   let diff = nums[i + 1] - nums[i];\n        if diff < closest_diff {\n    \
    \        closest_diff = diff;\n            closest_pair = (nums[i], nums[i + 1]);\n\
    \        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut closest_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp4i0_xjyi.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut min_diff\
    \ = f64::MAX;\n    let mut smallest = 0;\n    let mut largest = 0;\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let tmp = (numbers[i] - numbers[j]).abs();\n            if tmp < min_diff {\n\
    \                min_diff = tmp;\n                smallest = i;\n            \
    \    largest = j;\n            }\n        }\n    }\n    if numbers[smallest] >\
    \ numbers[largest] {\n        return (numbers[largest], numbers[smallest]);\n\
    \    }\n    (numbers[smallest], numbers[largest])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    (1.0, 2.0)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp48pv8ead.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut sorted = numbers.clone();\n    sorted.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut difference = numbers[0] - numbers[1];\n\
    \    let mut output = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        if (numbers[i] - numbers[i + 1]).abs() < difference.abs() {\n\
    \            difference = numbers[i] - numbers[i + 1];\n            output = (numbers[i],\
    \ numbers[i + 1]);\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmphqn9vsdl.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO: Complete this function\n    let mut\
    \ min_abs = f64::MAX;\n    let mut ret: (f64, f64) = (0.0, 0.0);\n    for i in\
    \ 1..numbers.len() {\n        let abs = (numbers[i] - numbers[i - 1]).abs();\n\
    \        if abs < min_abs {\n            min_abs = abs;\n            ret = (numbers[i\
    \ - 1], numbers[i]);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqr524cb9.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // In order to find the closest values, we need\
    \ to \n    // 1. Compare the first and second elements.\n    // 2. Compare the\
    \ second and third elements.\n    // 3. If the second pair is closer to each other,\
    \ return them.\n    // 4. If the first pair is closer to each other, return them.\n\
    \    // 5. If the two pairs are equally close, return either of them.\n    let\
    \ mut temp_vec: Vec<f64> = numbers.clone();\n    temp_vec.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    if (temp_vec[1] - temp_vec[0]).abs() < (temp_vec[2] - temp_vec[1]).abs()\
    \ {\n        (temp_vec[0], temp_vec[1])\n    } else if (temp_vec[1] - temp_vec[0]).abs()\
    \ > (temp_vec[2] - temp_vec[1]).abs() {\n        (temp_vec[1], temp_vec[2])\n\
    \    } else {\n        (temp_vec[0], temp_vec[1])\n    }\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpa6thwuop.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bgmmzgw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut result: (f64, f64) = (std::f64::MAX,\
    \ std::f64::MAX);\n    let mut diff: f64 = std::f64::MAX;\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let temp = numbers[i]\
    \ - numbers[j];\n            if temp < 0.0 {\n                let temp = -temp;\n\
    \            }\n            if temp < diff {\n                diff = temp;\n \
    \               result = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpri0nbbun.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO\n    (0.0, 0.0)\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0.0, 0.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpj5dy0nf_.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut diff = numbers[1] - numbers[0];\n\
    \    let mut res = (numbers[0], numbers[1]);\n    for i in 1..numbers.len() -\
    \ 1 {\n        let cur_diff = numbers[i + 1] - numbers[i];\n        if cur_diff\
    \ < diff {\n            diff = cur_diff;\n            res = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO: return the numbers, not the tuple\n\
    \    (0.0, 0.0)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0.0, 0.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpikdxdm7u.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dif = (numbers[0], numbers[1]);\n\
    \    let len = numbers.len();\n    let mut i = 0;\n    while i < len - 1 {\n \
    \       if numbers[i + 1] - numbers[i] < min_dif.1 - min_dif.0 {\n           \
    \ min_dif = (numbers[i], numbers[i + 1]);\n        }\n        i += 1;\n    }\n\
    \    min_dif\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpdsr5b1q1.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = f64::MAX;\n    let mut result:\
    \ (f64, f64) = (0.0, 0.0);\n    for x in numbers.iter() {\n        for y in numbers.iter()\
    \ {\n            if x == y {\n                continue;\n            }\n     \
    \       let value = (x - y).abs();\n            if value < min {\n           \
    \     min = value;\n                result = (*x, *y);\n            }\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp4vd8jbs0.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() - 1 {\n        for j in (i + 1)..numbers.len() {\n\
    \            let distance = numbers[j] - numbers[i];\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpryuslfb6.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut nums = numbers;\n    nums.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut diffs = nums.windows(2).map(|v|\
    \ v[1] - v[0]).collect::<Vec<f64>>();\n    diffs.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let index = diffs.iter().position(|&r| r == diffs[0]).unwrap();\n    (nums[index],\
    \ nums[index + 1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpzqhty464.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut num_iter = numbers.iter();\n    let mut\
    \ prev = num_iter.next().unwrap();\n    let mut min_diff = std::f64::MAX;\n  \
    \  let mut closest_elems = (*prev, *prev);\n    for elem in num_iter {\n     \
    \   let curr_diff = elem - prev;\n        if curr_diff < min_diff {\n        \
    \    min_diff = curr_diff;\n            closest_elems = (*prev, *elem);\n    \
    \    }\n        prev = elem;\n    }\n    closest_elems\n}\n\nfn main() {\n   \
    \ let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp1mokxipt.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"Invalid\
    \ input length: {}\", numbers.len());\n    }\n    let mut sorted_numbers = numbers.clone();\n\
    \    sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_distance\
    \ = sorted_numbers[1] - sorted_numbers[0];\n    let mut a = sorted_numbers[0];\n\
    \    let mut b = sorted_numbers[1];\n    for i in 0..sorted_numbers.len() - 1\
    \ {\n        let distance = sorted_numbers[i + 1] - sorted_numbers[i];\n     \
    \   if distance < min_distance {\n            min_distance = distance;\n     \
    \       a = sorted_numbers[i];\n            b = sorted_numbers[i + 1];\n     \
    \   }\n    }\n    (a, b)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0] - numbers[1];\n    let\
    \ mut min_first = numbers[0];\n    let mut min_second = numbers[1];\n    let mut\
    \ min_first_index = 0;\n    let mut min_second_index = 1;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[i]\
    \ - numbers[j]).abs();\n            if diff < min {\n                min = diff;\n\
    \                min_first = numbers[i];\n                min_second = numbers[j];\n\
    \                min_first_index = i;\n                min_second_index = j;\n\
    \            }\n        }\n    }\n    if min_first_index > min_second_index {\n\
    \        (min_second, min_first)\n    } else {\n        (min_first, min_second)\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpvnzaguzq.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    (numbers[0], numbers[1])\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpe227nw4_.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
