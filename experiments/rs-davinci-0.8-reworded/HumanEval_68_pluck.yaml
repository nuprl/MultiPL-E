name: HumanEval_68_pluck
language: rs
prompt: "/// \"Given a vector representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
  \ its index ],\n/// If there are no even values or the given vector is empty, return\
  \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
  /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
  /// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n\
  /// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will\
  \ choose the first zero, which has the smallest index.\n/// Constraints:\n/// *\
  \ 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) ->\
  \ Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
  \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
  \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
  \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]),\
  \ vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n  \
  \  assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
  \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
completions: ["    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ min_even = None;\n    let mut min_even_index = None;\n    for (index, item)\
    \ in arr.iter().enumerate() {\n        if item % 2 == 0 {\n            if min_even.is_none()\
    \ || item < min_even.unwrap() {\n                min_even = Some(*item);\n   \
    \             min_even_index = Some(index as isize);\n            }\n        }\n\
    \    }\n    if min_even.is_none() {\n        return vec![];\n    }\n    vec![min_even.unwrap(),\
    \ min_even_index.unwrap()]", "    let mut res = Vec::new();\n    let mut first_even\
    \ = usize::max_value();\n    for (i, n) in arr.iter().enumerate() {\n        if\
    \ *n % 2 == 0 {\n            if i < first_even {\n                first_even =\
    \ i;\n                res = vec![*n, first_even as isize];\n            }\n  \
    \      }\n    }\n    res", "    let mut res = vec![];\n    for (i, &a) in arr.iter().enumerate()\
    \ {\n        if a % 2 == 0 {\n            if res.is_empty() {\n              \
    \  res = vec![a, i as isize];\n            } else if a < res[0] {\n          \
    \      res = vec![a, i as isize];\n            }\n        }\n    }\n    res",
  "    let index = match arr.iter().enumerate().filter(|&(_, &n)| n % 2 == 0).min_by_key(|&(_,\
    \ &n)| n) {\n        Some((i, _)) => i,\n        None => return vec![],\n    };\n\
    \    vec![arr[index], index as isize]", "    let mut even = vec![];\n    let mut\
    \ zero = vec![];\n    for (i, item) in arr.iter().enumerate() {\n        if item\
    \ % 2 == 0 {\n            even.push(item);\n        }\n        if item == &0 {\n\
    \            zero.push(i);\n        }\n    }\n    if even.is_empty() {\n     \
    \   if zero.is_empty() {\n            return vec![];\n        } else {\n     \
    \       return vec![0, zero[0] as isize];\n        }\n    }\n    even.sort();\n\
    \    if zero.is_empty() {\n        vec![even[0], arr.iter().position(|&x| x ==\
    \ even[0]).unwrap() as isize]\n    } else {\n        let mut zeropos = vec![];\n\
    \        for i in zero {\n            zeropos.push(arr.iter().position(|&x| x\
    \ == 0).unwrap() as isize);\n        }\n        if *even.first().unwrap() < 0\
    \ {\n            vec![0, zeropos[0]]\n        } else {\n            vec![*even.first().unwrap(),\
    \ arr.iter().position(|&x| x == *even.first().unwrap()).unwrap() as isize]\n \
    \       }\n    }", "    let mut last = 0;\n    let mut min_idx = arr.len();\n\
    \    for (idx, n) in arr.iter().enumerate() {\n        if *n % 2 == 0 && *n <\
    \ last {\n            last = *n;\n            min_idx = idx;\n        }\n    }\n\
    \    if min_idx == arr.len() {\n        vec![]\n    } else {\n        vec![last,\
    \ min_idx as isize]\n    }", "    let mut result = vec![];\n    let mut min =\
    \ isize::max_value();\n    let mut min_idx = isize::max_value();\n    for (idx,\
    \ val) in arr.iter().enumerate() {\n        if val % 2 == 0 && *val < min {\n\
    \            min = *val;\n            min_idx = idx as isize;\n        }\n   \
    \ }\n    if min != isize::max_value() {\n        result.push(min);\n        result.push(min_idx);\n\
    \    }\n    result", "    let mut min = isize::max_value();\n    let mut min_idx\
    \ = isize::max_value();\n    for (idx, el) in arr.iter().enumerate() {\n     \
    \   if el.is_even() && el.is_positive() && el < &min {\n            min = *el;\n\
    \            min_idx = idx as isize;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        return vec![];\n    }\n    vec![min, min_idx]", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.iter()\n        .filter(|x| *x % 2 == 0)\n\
    \        .map(|&x| vec![x, arr.iter().position(|&y| y == x).unwrap() as isize])\n\
    \        .next()\n        .unwrap_or(vec![])", "    if arr.is_empty() {\n    \
    \    return vec![];\n    }\n    let mut evens: Vec<isize> = arr.into_iter().filter(|x|\
    \ x % 2 == 0).collect();\n    if evens.is_empty() {\n        return vec![];\n\
    \    }\n    evens.sort();\n    vec![evens[0], arr.iter().position(|&x| x == evens[0]).unwrap()\
    \ as isize + 1]", "    let mut min = None;\n    let mut min_index = -1;\n    for\
    \ (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n            if\
    \ min.is_none() || *n < min.unwrap() {\n                min = Some(*n);\n    \
    \            min_index = i as isize;\n            }\n        }\n    }\n    match\
    \ min {\n        Some(x) => vec![x, min_index],\n        None => vec![],\n   \
    \ }", "    if arr.is_empty() {\n        return vec![];\n    }\n    let mut even\
    \ = None;\n    let mut index = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            even = Some(arr[i]);\n            index = i;\n     \
    \       break;\n        }\n    }\n    if even.is_none() {\n        return vec![];\n\
    \    }\n    for i in index..arr.len() {\n        if arr[i] % 2 == 0 && arr[i]\
    \ < even.unwrap() {\n            even = Some(arr[i]);\n            index = i;\n\
    \        }\n    }\n    vec![even.unwrap(), index as isize]", "    let mut evens:\
    \ Vec<isize> = arr.into_iter().filter(|x| x % 2 == 0).collect();\n    evens.sort();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    let mut sml = evens[0];\n\
    \    for e in evens {\n        if e < sml {\n            sml = e;\n        }\n\
    \    }\n    vec![sml, arr.iter().position(|&x| x == sml).unwrap() as isize]",
  "    if arr.is_empty() {\n        return vec![];\n    }\n    let mut first_even\
    \ = None;\n    let mut result = vec![];\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            if let Some(x) = first_even {\n    \
    \            if v < &x {\n                    first_even = Some(*v);\n       \
    \             result = vec![first_even.unwrap(), i as isize];\n              \
    \  }\n            } else {\n                first_even = Some(*v);\n         \
    \       result = vec![first_even.unwrap(), i as isize];\n            }\n     \
    \   }\n    }\n    if result.is_empty() {\n        vec![]\n    } else {\n     \
    \   result\n    }", "    if arr.is_empty() {\n        return vec![];\n    }\n\
    \    let mut evens: Vec<&isize> = arr.iter().filter(|x| x % 2 == 0).collect();\n\
    \    evens.sort();\n    let min = evens[0];\n    vec![*min, arr.iter().position(|&r|\
    \ r == *min).unwrap() as isize]", '    unimplemented!()', "    // TODO:\n    vec![]",
  "    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut index = -1;\n\
    \    let mut min_even = -1;\n    for i in 0..arr.len() {\n        if arr[i] %\
    \ 2 == 0 {\n            if min_even == -1 || arr[i] < min_even {\n           \
    \     min_even = arr[i];\n                index = i as isize;\n            }\n\
    \        }\n    }\n    if index != -1 {\n        vec![min_even, index]\n    }\
    \ else {\n        vec![]\n    }", "    let mut evens: Vec<&isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).collect();\n    evens.sort();\n    match evens.first() {\n     \
    \   Some(e) => {\n            match arr.iter().position(|x| x == *e) {\n     \
    \           Some(idx) => vec![**e, idx as isize],\n                None => vec![],\n\
    \            }\n        }\n        None => vec![],\n    }", "    // First filter\
    \ out the even values.\n    let evens: Vec<isize> = arr.iter().filter(|&x| *x\
    \ % 2 == 0).map(|x| *x).collect();\n    // Short circuit.\n    if evens.len()\
    \ == 0 {\n        return vec![];\n    }\n    // Find the minimum.\n    let min\
    \ = evens.iter().min().unwrap();\n    // Get the index of the minimum value.\n\
    \    let min_index = arr.iter().position(|&n| n == *min).unwrap();\n    vec![*min,\
    \ min_index as isize]"]
stop_tokens:
- "\n}"
