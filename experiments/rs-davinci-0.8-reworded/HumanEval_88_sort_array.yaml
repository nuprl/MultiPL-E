name: HumanEval_88_sort_array
language: rs
prompt: "/// Given a vector of non-negative integers, return a cors of the given vector\
  \ after sorting,\n/// you will sort the given vector in ascending order if the sum(\
  \ first index value, last index value) is odd,\n/// or sort it in descending order\
  \ if the sum( first index value, last index value) is even.\n/// Note:\n/// * don't\
  \ change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n/// vec![]\n\
  /// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1,\
  \ 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n\
  /// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
  \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2, 4,\
  \ 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
  \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
  \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
  \ 21, 14, 11]);\n}\n"
completions: ["    let mut sorted_array = array.clone();\n    sorted_array.sort();\n\
    \    if array.len() == 0 || array.len() == 1 {\n        return array;\n    }\n\
    \    let sum_value = array[0] + array[array.len() - 1];\n    if sum_value % 2\
    \ == 0 {\n        sorted_array.reverse();\n    }\n    sorted_array", "    let\
    \ mut result = array.clone();\n    if result.len() == 0 {\n        return result;\n\
    \    }\n    if (result[0] + result[result.len() - 1]) % 2 == 0 {\n        result.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        result.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    result", "    let mut array = array;\n    let size = array.len();\n    if\
    \ size > 1 {\n        let (l, r) = array.split_at_mut(size / 2);\n        let\
    \ (mut l, mut r) = (sort_array(l.to_vec()), sort_array(r.to_vec()));\n       \
    \ if size % 2 == 0 {\n            array.clear();\n            while !l.is_empty()\
    \ && !r.is_empty() {\n                if l.last().unwrap() > r.last().unwrap()\
    \ {\n                    array.push(l.pop().unwrap());\n                } else\
    \ {\n                    array.push(r.pop().unwrap());\n                }\n  \
    \          }\n            array.extend(l.into_iter().rev());\n            array.extend(r.into_iter().rev());\n\
    \        } else {\n            let mut nums = vec![];\n            while !l.is_empty()\
    \ && !r.is_empty() {\n                if l.last().unwrap() < r.last().unwrap()\
    \ {\n                    nums.push(l.pop().unwrap());\n                } else\
    \ {\n                    nums.push(r.pop().unwrap());\n                }\n   \
    \         }\n            nums.extend(l.into_iter().rev());\n            nums.extend(r.into_iter().rev());\n\
    \            array.clear();\n            array.extend(nums.into_iter().rev());\n\
    \        }\n    }\n    array", "    let mut result = array.clone();\n    if result.len()\
    \ < 2 {\n        return result;\n    }\n    let a = result[0];\n    let b = result[result.len()\
    \ - 1];\n    result.sort_by(|a, b| if (a + b) % 2 == 0 { cmp::Reverse(a).cmp(&cmp::Reverse(b))\
    \ } else { a.cmp(&b) });\n    result", "    if array.len() == 0 {\n        return\
    \ array;\n    }\n    if array.len() == 1 {\n        return array;\n    }\n   \
    \ let mut odd_array: Vec<isize> = vec![];\n    let mut even_array: Vec<isize>\
    \ = vec![];\n    for i in array {\n        if i % 2 == 0 {\n            even_array.push(i);\n\
    \        } else {\n            odd_array.push(i);\n        }\n    }\n    odd_array.sort();\n\
    \    even_array.sort();\n    if (odd_array.len() + even_array.len()) % 2 == 0\
    \ {\n        odd_array.append(&mut even_array);\n        return odd_array;\n \
    \   } else {\n        even_array.append(&mut odd_array);\n        return even_array;\n\
    \    }", "    let sorted = array.clone();\n    sorted.sort();\n    if (array[0]\
    \ + array[array.len() - 1]) % 2 == 0 {\n        sorted.reverse();\n    }\n   \
    \ sorted", "    let mut array = array;\n    array.sort_by(|a, b| {\n        if\
    \ a + b % 2 == 0 {\n            a.cmp(b)\n        } else {\n            b.cmp(a)\n\
    \        }\n    });\n    array", "    if array.len() <= 1 {\n        return array;\n\
    \    }\n    let mut res = array.clone();\n    if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n        res.sort_by(|a, b| b.cmp(a));\n    } else {\n    \
    \    res.sort_by(|a, b| a.cmp(b));\n    }\n    res", "    let mut input = array.clone();\n\
    \    input.sort();\n    let sum = array.first().unwrap() + array.last().unwrap();\n\
    \    if sum % 2 == 0 {\n        input.reverse();\n    }\n    input", "    let\
    \ mut result = array.clone();\n    let sum = result[0] + result[result.len() -\
    \ 1];\n    if sum % 2 == 0 {\n        result.sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        result.sort_by(|a, b| a.cmp(b));\n    }\n    result", "    let\
    \ mut ans = array.clone();\n    if ans.len() < 2 {\n        return ans;\n    }\n\
    \    if ans[0] + ans[ans.len() - 1] % 2 == 0 {\n        ans.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        ans.sort_by(|a, b| a.cmp(b));\n    }\n    ans", "    if\
    \ array.len() < 2 {\n        return array;\n    }\n    let pivot = &array[0];\n\
    \    let mut left: Vec<isize> = Vec::new();\n    let mut right: Vec<isize> = Vec::new();\n\
    \    for i in &array[1..] {\n        if i <= pivot {\n            left.push(*i);\n\
    \        } else {\n            right.push(*i);\n        }\n    }\n    let mut\
    \ result = sort_array(left);\n    result.push(*pivot);\n    result.append(&mut\
    \ sort_array(right));\n    if result.len() % 2 == 0 {\n        result.reverse();\n\
    \    }\n    result", '    array', "    let mut array = array;\n    let mut next_idx\
    \ = 0;\n    let mut i = 0;\n    while i < array.len() {\n        let (p, n) =\
    \ array.split_at_mut(i);\n        if i < p.len() && i + 1 < n.len() {\n      \
    \      next_idx = match (p[i] + n[i]) % 2 {\n                0 => i + 1,\n   \
    \             _ => i,\n            };\n        }\n        if i != next_idx {\n\
    \            if i + 1 < n.len() {\n                let (p, n) = n.split_at_mut(1);\n\
    \                p.swap(0, i);\n                array.extend_from_slice(n);\n\
    \            } else {\n                let (p, n) = p.split_at_mut(p.len() - 1);\n\
    \                p.swap(i, i - 1);\n                array.extend_from_slice(n);\n\
    \            }\n        }\n        i += 1;\n    }\n    array", "    let (mut left,\
    \ mut right) = array.split_at(array.len() / 2);\n    left.sort();\n    right.sort();\n\
    \    let mut result = Vec::new();\n    if array.len() % 2 == 0 {\n        while\
    \ left.len() > 0 {\n            result.push(left.pop().unwrap());\n          \
    \  result.push(right.pop().unwrap());\n        }\n    } else {\n        while\
    \ right.len() > 0 {\n            result.push(right.pop().unwrap());\n        \
    \    result.push(left.pop().unwrap());\n        }\n    }\n    result", "    let\
    \ mut ret = array.clone();\n    if ret.len() <= 1 {\n        return ret;\n   \
    \ }\n    ret.sort_by(|a, b| {\n        if (ret.len() - 1) % 2 == 0 {\n       \
    \     b.cmp(a)\n        } else {\n            a.cmp(b)\n        }\n    });\n \
    \   ret", "    if array.len() <= 1 {\n        return array;\n    }\n    let compare\
    \ = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n\
    \    array.sort_by(|a, b| if compare {\n        b.cmp(a)\n    } else {\n     \
    \   a.cmp(b)\n    });\n    array", "    if array.len() == 0 {\n        return\
    \ vec![];\n    }\n    if array.len() == 1 {\n        return array;\n    }\n  \
    \  let mut sorted_array = array.clone();\n    if (sorted_array[0] + sorted_array[sorted_array.len()\
    \ - 1]) % 2 == 0 {\n        sorted_array.sort_by(|a, b| b.cmp(a));\n    } else\
    \ {\n        sorted_array.sort_by(|a, b| a.cmp(b));\n    }\n    sorted_array",
  "    let mut array = array;\n    if let Some(n) = array.last() {\n        if n %\
    \ 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else {\n  \
    \          array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array", "  \
    \  let mut array = array;\n    if array.len() == 0 {\n        return vec![];\n\
    \    }\n    if array.len() == 1 {\n        return array;\n    }\n    let front\
    \ = array[0];\n    let back = array[array.len() - 1];\n    if (front + back) %\
    \ 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array"]
stop_tokens:
- "\n}"
