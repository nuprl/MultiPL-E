language: rs
name: HumanEval_159_eat
results:
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = match number + need - remaining {\n        num if num > remaining =>\
    \ remaining,\n        num => num,\n    };\n    vec![eaten, remaining - eaten]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 9]`,\n right: `[11, 4]`', /tmp/tmph3iu0h61.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res: Vec<isize> = Vec::new();\n    let mut number_ = number;\n    let mut\
    \ remaining_ = remaining;\n    while remaining_ > 0 && number_ < need {\n    \
    \    number_ += 1;\n        remaining_ -= 1;\n    }\n    res.push(number_);\n\
    \    res.push(remaining_);\n    res\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpr70fv4xk.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ <= remaining {\n        vec![number + need, remaining - need]\n    } else {\n\
    \        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = (number + need).min(number + remaining);\n    let remainder = (number\
    \ + remaining) - eaten;\n    vec![eaten, remainder]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut res: isize = number + need;\n    if remaining\
    \ <= 0 {\n        result.push(number);\n        result.push(remaining);\n    }\
    \ else if remaining <= need {\n        result.push(number + remaining);\n    \
    \    result.push(0);\n    } else {\n        result.push(res);\n        result.push(remaining\
    \ - need);\n    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ < remaining {\n        vec![number + need, remaining - need]\n    } else {\n\
    \        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    let mut meal = 0;\n\
    \    while left > 0 && eaten < need {\n        eaten += 1;\n        left -= 1;\n\
    \        meal += 1;\n    }\n    let mut result = vec![];\n    result.push(eaten);\n\
    \    result.push(left);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpx_hekmj7.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        if remaining >= need { number + need } else { number + remaining },\n\
    \        if remaining >= need { remaining - need } else { 0 },\n    ]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + need;\n    let left = if eaten > remaining { 0 } else { remaining\
    \ - eaten };\n    vec![eaten, left]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpc8ugi2dj.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut left = remaining - number;\n    let mut eaten = number;\n    if left < need\
    \ {\n        eaten += left;\n        left = 0;\n    } else {\n        eaten +=\
    \ need;\n        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpif55npu8.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ left = if number+need > remaining {\n        0\n    } else {\n        remaining\
    \ - (number+need)\n    };\n    vec![number+need, left]\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmp4ah3d21u.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    if total < remaining {\n        vec![total, remaining\
    \ - total]\n    } else {\n        vec![total, 0]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n \
    \   assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpif3mylvu.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ sum = number + need;\n    let delta = if sum < remaining { sum } else { remaining\
    \ };\n    vec![delta, remaining - delta]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpx4pdi_a7.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + if need < remaining { need } else { remaining };\n    let remaining\
    \ = if remaining - need > 0 { remaining - need } else { 0 };\n    vec![eaten,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need < remaining {\n        vec![number + need, remaining - number - need]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpr6g9ixwj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res = Vec::new();\n    if number < 0 || need < 0 || remaining < 0 {\n  \
    \      return res;\n    }\n    if number + need <= remaining {\n        res.push(number\
    \ + need);\n        res.push(remaining - (number + need));\n    } else {\n   \
    \     res.push(number + remaining);\n        res.push(0);\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpjnezai1y.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ + number <= remaining {\n        vec![need + number, remaining - need - number]\n\
    \    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp1_g9wrsk.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut output = Vec::new();\n    let total = number + need;\n    if total <= remaining\
    \ {\n        output.push(total);\n        output.push(remaining - total);\n  \
    \  } else {\n        output.push(remaining + number);\n        output.push(0);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpfygz4xms.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten: isize = number;\n    if remaining >= need {\n        eaten += need;\n\
    \        eaten -= remaining;\n    } else {\n        eaten += remaining;\n    }\n\
    \    vec![eaten, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 10]`,\n right: `[11, 4]`', /tmp/tmpilfy7yn3.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822564
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten: isize = number;\n    let mut remain: isize = remaining;\n    if need\
    \ > remaining {\n        eaten += remaining;\n        remain = 0;\n    } else\
    \ {\n        eaten += need;\n        remain -= need;\n    }\n    vec![eaten, remain]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // TODO:\
    \ Implement this function\n    // panic!(\"Not Implemented\");\n    let mut eaten:\
    \ isize = number;\n    if (need - number) <= remaining {\n        eaten += need\
    \ - number;\n    } else {\n        eaten += remaining;\n    }\n    let res = vec![eaten,\
    \ remaining - (need - number)];\n    res\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzblv4wgf.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if need <= remaining {\n        number + need\n    } else {\n      \
    \  number + remaining\n    };\n    let left = if need <= remaining {\n       \
    \ remaining - need\n    } else {\n        0\n    };\n    vec![eaten, left]\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ remaining = remaining - number;\n    let eaten = number + if remaining > need\
    \ { need } else { remaining };\n    vec![eaten, remaining.max(0)]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 5]`,\n right: `[11, 4]`', /tmp/tmp64ut9wmt.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    if total <= remaining {\n        vec![total, remaining\
    \ - total]\n    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpmbo8vaxv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut remaining = remaining;\n    if remaining >=\
    \ need {\n        eaten += need;\n        remaining -= need;\n    } else {\n \
    \       eaten += remaining;\n        remaining = 0;\n    }\n    vec![eaten, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need <= remaining {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp_1hkv6x3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total_carrots = number + need;\n    if total_carrots > remaining {\n       \
    \ vec![remaining, 0]\n    } else {\n        vec![total_carrots, remaining - total_carrots]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpbw2rwq5g.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut sum = number + need;\n    if sum <= remaining {\n        vec![sum, remaining\
    \ - sum]\n    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpbepr2vrd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + if need < remaining { need } else { remaining };\n    let remain\
    \ = if need < remaining { remaining - need } else { 0 };\n    vec![total, remain]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut ret = vec![];\n    if need >= remaining {\n        ret.push(number + remaining);\n\
    \        ret.push(0);\n    } else {\n        ret.push(number + need);\n      \
    \  ret.push(remaining - need);\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need > remaining {\n        return vec![remaining, 0];\n    } else {\n   \
    \     return vec![number + need, remaining - number - need];\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpygy96xtx.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ < 0 || need < 0 || remaining < 0 {\n        return vec![0, 0];\n    }\n    let\
    \ mut result = remaining - (number + need);\n    if result < 0 {\n        result\
    \ = 0;\n    }\n    vec![number + need, result]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpxaurrlfk.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    if total <= remaining {\n        vec![total, remaining\
    \ - total]\n    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpmbo8vaxv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + std::cmp::min(need, remaining);\n    vec![eaten, remaining\
    \ - eaten]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, -1]`,\n right: `[11, 4]`', /tmp/tmpmkjpdud6.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    if remaining <\
    \ need {\n        number += remaining;\n        remaining = 0;\n    } else {\n\
    \        number += need;\n        remaining -= need;\n    }\n    vec![number,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ number = number as usize;\n    let need = need as usize;\n    let remaining\
    \ = remaining as usize;\n    let mut carrots: Vec<isize> = Vec::new();\n    let\
    \ total_eaten: usize = number + need;\n    if total_eaten <= remaining {\n   \
    \     carrots.push(total_eaten as isize);\n        carrots.push((remaining - total_eaten)\
    \ as isize);\n    } else {\n        carrots.push(remaining as isize);\n      \
    \  carrots.push(0);\n    }\n    carrots\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmptcl1juwz.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + remaining - need.min(remaining), remaining - need.min(remaining)]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 4]`,\n right: `[11, 4]`', /tmp/tmp4badv05j.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp55h6qp9n.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let eaten = if number + need <= remaining {\n    \
    \    number + need\n    } else {\n        remaining\n    };\n    result.push(eaten);\n\
    \    result.push(remaining - eaten);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpbpskaxzv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    let mut diff = total - remaining;\n    if diff <=\
    \ 0 {\n        diff = 0;\n    }\n    vec![total - diff, diff]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 1]`,\n right: `[11, 4]`', /tmp/tmp_k4azr_b.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut hungry = need - number;\n    if hungry > remaining {\n        hungry = remaining;\n\
    \    }\n    vec![number + hungry, remaining - hungry]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpg6lo87mt.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= number + need {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpeg7rmvml.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ sum = number + need;\n    vec![\n        sum,\n        if sum < remaining {\n\
    \            remaining - sum\n        } else {\n            0\n        }\n   \
    \ ]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6,\
    \ 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpmisx746v.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need <= remaining {\n        vec![number + need, remaining - number - need]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpxr5q9oip.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if need <= remaining {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ < (need - number) {\n        vec![number + remaining, 0]\n    } else {\n   \
    \     vec![number + need, remaining - (need - number)]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmphf22osqj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut remaining = remaining;\n    let mut number = number;\n    for _ in number..number\
    \ + need {\n        if remaining > 0 {\n            remaining -= 1;\n        \
    \    number += 1;\n        }\n    }\n    vec![number, remaining]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    match\
    \ (number, need, remaining) {\n        (number, need, remaining) if need == 0\
    \ => vec![number, remaining],\n        (number, need, remaining) if need > remaining\
    \ => vec![number + remaining, 0],\n        (number, need, remaining) => vec![number\
    \ + need, remaining - need],\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ + number >= need {\n        vec![need, remaining + number - need]\n    } else\
    \ {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpxf8aa9ro.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ result = number + need;\n    let mut stock = remaining - need;\n    let mut\
    \ eaten = 0;\n    if stock < 0 {\n        eaten = result + stock;\n        stock\
    \ = 0;\n    } else {\n        eaten = result;\n    }\n    return vec![eaten, stock];\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut n = number;\n    let mut r = remaining;\n    let mut result = Vec::new();\n\
    \    if number + remaining >= need {\n        n += need;\n        r -= need;\n\
    \    } else {\n        n += remaining;\n        r = 0;\n    }\n    result.push(n);\n\
    \    result.push(r);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmp4ztpyuv3.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut all_carrots = number + remaining;\n    if all_carrots < need {\n       \
    \ all_carrots = 0;\n    } else {\n        all_carrots -= need;\n    }\n    vec![number\
    \ + remaining - all_carrots, all_carrots]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp4pbptntn.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res = number + need;\n    if res > remaining {\n        res = remaining;\n\
    \    }\n    vec![res, remaining - res]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpqo602yl7.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    if need < remaining\
    \ {\n        number += need;\n        remaining -= need;\n    } else {\n     \
    \   number += remaining;\n        remaining = 0;\n    }\n    vec![number, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ result = need + number;\n    let remaining = if result > remaining {0} else\
    \ {remaining - result};\n    vec![result, remaining]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpmtmj5ion.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total_need = number + need;\n    if total_need < remaining {\n        vec![total_need,\
    \ remaining - total_need]\n    } else {\n        vec![total_need - remaining,\
    \ 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 0]`,\n right: `[11, 4]`', /tmp/tmp4y9f4_51.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + need;\n    let left = if remaining >= need { remaining - need\
    \ } else { 0 };\n    vec![eaten, left]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, 0]`,\n right: `[7, 0]`', /tmp/tmp_ehgaoji.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![(number\
    \ + cmp::min(need, remaining)), cmp::max(0, remaining - need)]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpsf_yms79.rs:28:20\n   |\n28 |     vec![(number + cmp::min(need,\
    \ remaining)), cmp::max(0, remaining - need)]\n   |                    ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `cmp`\n  --> /tmp/tmpsf_yms79.rs:28:48\n   |\n\
    28 |     vec![(number + cmp::min(need, remaining)), cmp::max(0, remaining - need)]\n\
    \   |                                                ^^^ use of undeclared crate\
    \ or module `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need <= remaining {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp_1hkv6x3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need < remaining {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpwluzj8ig.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut num = number;\n    let mut rem = remaining;\n    let mut meal = 0;\n   \
    \ while rem > 0 && num < need {\n        num += 1;\n        rem -= 1;\n      \
    \  meal += 1;\n    }\n    let mut result = vec![];\n    result.push(num);\n  \
    \  result.push(rem);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp6blucug8.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ output = vec![number + std::cmp::min(need, remaining), std::cmp::max(0, remaining\
    \ - need)];\n    return output;\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ result: isize = number + remaining - need;\n    if result >= 0 {\n        vec![number\
    \ + remaining, result]\n    } else {\n        vec![number + remaining, 0]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmpwo2m2mz5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ < need - number {\n        vec![remaining + number, 0]\n    } else {\n     \
    \   vec![need, remaining - (need - number)]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpkrfvsct3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut ret = vec![];\n    let total_carrots = number + remaining;\n    if total_carrots\
    \ >= need {\n        ret.push(need);\n        ret.push(total_carrots - need);\n\
    \    } else {\n        ret.push(total_carrots);\n        ret.push(0);\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpuy409fi_.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut remaining = remaining;\n    let mut eaten_now\
    \ = 0;\n    let mut need = need;\n    while need > 0 {\n        if remaining >\
    \ 0 {\n            eaten_now += 1;\n            need -= 1;\n            remaining\
    \ -= 1;\n        } else {\n            break;\n        }\n    }\n    eaten +=\
    \ eaten_now;\n    return vec![eaten, remaining];\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut vec = Vec::new();\n    if number <= 1000 && need <= 1000 && remaining <=\
    \ 1000 {\n        let sum: isize = number + need;\n        if sum <= remaining\
    \ {\n            vec.push(sum);\n            vec.push(remaining - sum);\n    \
    \    } else {\n            vec.push(remaining + number);\n            vec.push(0);\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpzyer_fg0.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= number + need {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpb3s3_p71.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // your\
    \ code here\n    let mut res = vec![];\n    if number + need <= remaining {\n\
    \        res.push(number + need);\n        res.push(remaining - (number + need));\n\
    \    } else {\n        res.push(number + remaining);\n        res.push(0);\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpzjg6oi7r.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ < number {\n        panic!(\"number of carrots eaten can't be greater than number\
    \ of carrots needed\");\n    }\n    let remaining_carrots = remaining.checked_sub(need\
    \ - number);\n    match remaining_carrots {\n        Some(n) => vec![need, n],\n\
    \        None => vec![remaining + number, 0],\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpj78a01r4.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    let mut temp = 0;\n    if remaining == 0 {\n        return vec![number, 0];\n\
    \    }\n    if remaining < need {\n        temp = remaining;\n        need -=\
    \ remaining;\n        remaining = 0;\n    } else {\n        remaining -= need;\n\
    \        temp = need;\n        need = 0;\n    }\n    number += temp;\n    vec![number,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if remaining >= number + need {\n        result.push(number\
    \ + need);\n        result.push(remaining - number - need);\n    } else {\n  \
    \      result.push(number + remaining);\n        result.push(0);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpuz1ktq9u.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + cmp::min(need, remaining);\n    let remaining = remaining -\
    \ cmp::min(need, remaining);\n    vec![eaten, remaining]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp50s6rkxp.rs:28:26\n   |\n28 |     let eaten = number + cmp::min(need,\
    \ remaining);\n   |                          ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmp50s6rkxp.rs:29:33\n   |\n29 |     let remaining = remaining\
    \ - cmp::min(need, remaining);\n   |                                 ^^^ use of\
    \ undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ left = number + remaining - need;\n    let eaten = if left < 0 { remaining }\
    \ else { need };\n    vec![eaten, left.max(0)]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpsir0p2bb.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ diff = need - number;\n    if diff <= remaining {\n        vec![need, remaining\
    \ - diff]\n    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpo29gn9sc.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eat = remaining.min(number + need);\n    vec![eat, remaining - eat]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp_wdh44af.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total_carrots = number + remaining;\n    let left_carrots = total_carrots -\
    \ need;\n    if left_carrots >= 0 {\n        return vec![need, left_carrots];\n\
    \    }\n    if left_carrots < 0 {\n        return vec![total_carrots, 0];\n  \
    \  }\n    unreachable!();\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpvgqq_gw0.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= need {\n        return vec![number + need, remaining - need];\n    }\n  \
    \  vec![number + remaining, 0]\n}\n\nfn main() {\n    let candidate = eat;\n \
    \   assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![number + remaining, 0];\n    if remaining < need {\n        res[0]\
    \ -= (need - remaining);\n    } else {\n        res[1] = remaining - need;\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 4]`,\n right: `[11, 4]`', /tmp/tmpl7ugqbrz.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= number + need {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpb3s3_p71.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![number, remaining];\n    if res[1] >= res[0] + res[1] {\n   \
    \     res[0] += res[1];\n        res[1] = 0;\n    } else {\n        res[0] +=\
    \ res[1];\n        res[1] = 0;\n    }\n    return res;\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpwcif7bq3.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        number + ::std::cmp::min(need, remaining),\n        ::std::cmp::max(remaining\
    \ - need, 0),\n    ]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if remaining > need {\n        number + need\n    } else {\n       \
    \ number + remaining\n    };\n    let left = if remaining > need {\n        remaining\
    \ - need\n    } else {\n        0\n    };\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ remaining = remaining - number;\n    if remaining < need {\n        return vec![remaining\
    \ + number, 0];\n    } else {\n        return vec![need + number, remaining -\
    \ need];\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpmyz6h0fo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpe_hk0mmv.rs:28:19\n\
    \   |\n28 |     vec![number + min(need, remaining), max(0, remaining - need)]\n\
    \   |                   ^^^\n...\n31 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n28 |     vec![number + main(need, remaining), max(0, remaining - need)]\n\
    \   |                   ~~~~\nhelp: consider importing this function\n   |\n1\
    \  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmpe_hk0mmv.rs:28:41\n   |\n28 |     vec![number + min(need,\
    \ remaining), max(0, remaining - need)]\n   |                                \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ < need {\n        vec![number + remaining, 0]\n    } else {\n        vec![number\
    \ + need, remaining - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ - number <= remaining {\n        vec![number + need, remaining - (need - number)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmp2xucgha1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    while need > 0 && remaining > 0 {\n        number += 1;\n        need -=\
    \ 1;\n        remaining -= 1;\n    }\n    vec![number, remaining]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if need <= remaining {\n        number + need\n    } else {\n      \
    \  number + remaining\n    };\n    let left = if need <= remaining {\n       \
    \ remaining - need\n    } else {\n        0\n    };\n    vec![eaten, left]\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ > number + need {\n        vec![number + need, remaining - number - need]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpammoxkrd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need <= remaining {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp_1hkv6x3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut r = number + remaining;\n    if r > need {\n\
    \        r = need;\n    }\n    result.push(r);\n    result.push(remaining - r\
    \ + number);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp9gywuflr.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need <= remaining {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp_1hkv6x3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ x = (number + need).min(number + remaining);\n    vec![x, (number + remaining)\
    \ - x]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    let mut result = 0;\n    if total >= need\
    \ {\n        result = total - need;\n        total = need;\n    }\n    vec![total,\
    \ result]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp777x3swr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ > remaining {\n        let not_enough = remaining - number;\n        return\
    \ vec![not_enough, 0];\n    } else {\n        let enough = number + remaining;\n\
    \        return vec![enough, 0];\n    }\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp9m76s5s_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ out = remaining - (need - number);\n    if out >= 0 {\n        vec![number +\
    \ need, out]\n    } else {\n        vec![number + remaining, 0]\n    }\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmpij1xpnyk.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ hunger = need - number;\n    let num_carrots_left = remaining - hunger;\n  \
    \  if num_carrots_left < 0 {\n        return vec![number + remaining, 0];\n  \
    \  } else {\n        return vec![number + hunger, num_carrots_left];\n    }\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpz5700s7k.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ carrots_eaten = number + need;\n    let carrots_left = if carrots_eaten > remaining\
    \ {\n        0\n    } else {\n        remaining - carrots_eaten\n    };\n    vec![carrots_eaten,\
    \ carrots_left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpb4lm8ukk.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total_carrots = 0;\n    let mut n_carrots = number;\n    let mut r_carrots\
    \ = remaining;\n    while n_carrots < need {\n        if r_carrots > 0 {\n   \
    \         n_carrots += 1;\n            r_carrots -= 1;\n            total_carrots\
    \ += 1;\n        } else {\n            break;\n        }\n    }\n    vec![total_carrots,\
    \ r_carrots]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 9]`,\n right: `[11, 4]`', /tmp/tmp9ns4uu5o.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ remaining_carrots = remaining - need;\n    if remaining_carrots < 0 {\n    \
    \    return vec![number + remaining, 0];\n    } else {\n        return vec![number\
    \ + need, remaining_carrots];\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total_number: isize = number;\n    if remaining + number < need {\n    \
    \    total_number += remaining;\n        let left: isize = 0;\n        vec![total_number,\
    \ left]\n    } else {\n        total_number += need;\n        let left: isize\
    \ = remaining - need + number;\n        vec![total_number, left]\n    }\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmps5dfin3x.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        number + std::cmp::min(need, remaining),\n        std::cmp::max(remaining\
    \ - need, 0),\n    ]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res: Vec<isize> = Vec::new();\n    let mut eaten = number;\n    let mut\
    \ remaining = remaining;\n    if remaining == 0 {\n        res.push(eaten);\n\
    \        res.push(remaining);\n        return res;\n    }\n    while need > 0\
    \ {\n        if remaining == 0 {\n            break;\n        }\n        eaten\
    \ += 1;\n        remaining -= 1;\n        need -= 1;\n    }\n    res.push(eaten);\n\
    \    res.push(remaining);\n    res\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `need`\n  --> /tmp/tmptd52e4k9.rs:42:9\n\
    \   |\n27 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
    \ {\n   |                       ---- help: consider making this binding mutable:\
    \ `mut need`\n...\n42 |         need -= 1;\n   |         ^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ > number {\n        if need - number <= remaining {\n            return vec![need,\
    \ remaining - (need - number)];\n        } else {\n            return vec![number\
    \ + remaining, 0];\n        }\n    } else {\n        return vec![number, remaining];\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpvek_pkyo.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut carrots = number + remaining;\n    let mut need = need;\n    while carrots\
    \ > 0 && need > 0 {\n        carrots -= 1;\n        need -= 1;\n    }\n    vec![number\
    \ + remaining - carrots, carrots]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpxus391aa.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eat_number = number + need;\n    if eat_number <= remaining {\n        return\
    \ vec![eat_number, remaining - eat_number];\n    }\n    vec![eat_number - remaining,\
    \ 0]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 0]`,\n right: `[11, 4]`', /tmp/tmpmv1uosul.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + min(need, remaining);\n    let remain = max(0, remaining -\
    \ need);\n    vec![eaten, remain]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpsf_m3ti0.rs:28:26\n\
    \   |\n28 |     let eaten = number + min(need, remaining);\n   |             \
    \             ^^^\n...\n33 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    28 |     let eaten = number + main(need, remaining);\n   |                   \
    \       ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpsf_m3ti0.rs:29:18\n\
    \   |\n29 |     let remain = max(0, remaining - need);\n   |                 \
    \ ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut ans: Vec<isize> = Vec::new();\n    let remain = remaining - number;\n  \
    \  if need <= remain {\n        ans.push(number + need);\n        ans.push(remain\
    \ - need);\n    } else {\n        ans.push(number + remain);\n        ans.push(0);\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpz4e0ci17.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= need {\n        vec![number + need, remaining - need]\n    } else {\n   \
    \     vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eat = number + need;\n    let remaining = remaining - eat;\n    if remaining\
    \ > 0 {\n        return vec![eat, remaining];\n    } else {\n        return vec![eat,\
    \ 0];\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpkrf811mw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need <= remaining {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp_1hkv6x3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    let mut result\
    \ = Vec::new();\n    if number + remaining >= need {\n        number += need;\n\
    \        remaining -= need;\n    } else {\n        number += remaining;\n    \
    \    remaining = 0;\n    }\n    result.push(number);\n    result.push(remaining);\n\
    \    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpu49zx5f5.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    if number + remaining\
    \ >= need {\n        number += need;\n        remaining -= need;\n    } else {\n\
    \        number += remaining;\n        remaining = 0;\n    }\n    vec![number,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpoi2hchda.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    let mut need =\
    \ need;\n    if remaining <= need {\n        number += remaining;\n        remaining\
    \ = 0;\n    } else {\n        number += need;\n        remaining -= need;\n  \
    \  }\n    vec![number, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total_carrots = 0;\n    let carrots_eaten = number + need;\n    if remaining\
    \ > carrots_eaten {\n        total_carrots = carrots_eaten;\n    } else {\n  \
    \      total_carrots = remaining;\n    }\n    let remaining_carrots = remaining\
    \ - total_carrots;\n    vec![total_carrots, remaining_carrots]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpxzpjs19m.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // your\
    \ code here.\n    let missing_carrots = need - number;\n    let eaten_carrots\
    \ = if missing_carrots > remaining {\n        number + remaining\n    } else {\n\
    \        number + missing_carrots\n    };\n    let carrots_left = if missing_carrots\
    \ > remaining {\n        0\n    } else {\n        remaining - missing_carrots\n\
    \    };\n    vec![eaten_carrots, carrots_left]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpeqx5vywe.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ - number > remaining {\n        vec![number + remaining, 0]\n    } else {\n\
    \        vec![number + need, remaining - need]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpgpkibscl.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    if total < need {\n        vec![total, 0]\n\
    \    } else {\n        vec![need, total - need]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp57cfpayn.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpe_hk0mmv.rs:28:19\n\
    \   |\n28 |     vec![number + min(need, remaining), max(0, remaining - need)]\n\
    \   |                   ^^^\n...\n31 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n28 |     vec![number + main(need, remaining), max(0, remaining - need)]\n\
    \   |                   ~~~~\nhelp: consider importing this function\n   |\n1\
    \  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmpe_hk0mmv.rs:28:41\n   |\n28 |     vec![number + min(need,\
    \ remaining), max(0, remaining - need)]\n   |                                \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        return vec![need,\
    \ total - need];\n    } else {\n        return vec![total, 0];\n    }\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmprp593siy.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + min(need, remaining);\n    vec![eaten, max(0, remaining - need)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp3f080t0y.rs:28:26\n\
    \   |\n28 |     let eaten = number + min(need, remaining);\n   |             \
    \             ^^^\n...\n32 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    28 |     let eaten = number + main(need, remaining);\n   |                   \
    \       ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp3f080t0y.rs:29:17\n\
    \   |\n29 |     vec![eaten, max(0, remaining - need)]\n   |                 ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // your\
    \ code here\n    let total_eat = number + need;\n    if total_eat <= remaining\
    \ {\n        vec![total_eat, remaining - total_eat]\n    } else {\n        vec![total_eat\
    \ - (total_eat - remaining), 0]\n    }\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp0ikbqqyp.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    let total: isize;\n    let left: isize;\n    if number + remaining < need\
    \ {\n        total = number + remaining;\n        left = 0;\n    } else {\n  \
    \      total = need;\n        left = number + remaining - need;\n    }\n    vec![total,\
    \ left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmph6gwpqvv.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ left = number + remaining - need;\n    vec![number + remaining - left.max(0),\
    \ left.max(0)]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp_wwazrwg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res = Vec::new();\n    let mut sum = number + remaining;\n    if sum >=\
    \ need {\n        sum -= need;\n    } else {\n        sum = 0;\n    }\n    res.push(number\
    \ + remaining - sum);\n    res.push(sum);\n    res\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpp4wk96aq.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    let left = total - remaining;\n    if left > 0 {\n\
    \        vec![total - left, 0]\n    } else {\n        vec![total, -left]\n   \
    \ }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6,\
    \ 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpz4_meb3t.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need > remaining {\n        vec![remaining, 0]\n    } else {\n        vec![number\
    \ + need, remaining - (number + need)]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpof0j8pib.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ + number >= need {\n        vec![need, remaining + number - need]\n    } else\
    \ {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpxf8aa9ro.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ - number <= remaining {\n        vec![number + need, remaining - (need - number)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmp2xucgha1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ new_amount = number + need;\n    if new_amount > remaining {\n        vec![remaining,\
    \ 0]\n    } else {\n        vec![new_amount, remaining - new_amount]\n    }\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpq_jp4f8b.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= need {\n        return vec![number + need, remaining - need];\n    } else\
    \ {\n        return vec![number + remaining, 0];\n    }\n}\n\nfn main() {\n  \
    \  let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n \
    \   assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut remaining = remaining;\n    let mut number = number;\n    let mut need =\
    \ need;\n    let mut vec = Vec::new();\n    if remaining <= 0 {\n        vec.push(number);\n\
    \        vec.push(0);\n        return vec;\n    }\n    number += need;\n    remaining\
    \ -= need;\n    if remaining <= 0 {\n        vec.push(number);\n        vec.push(0);\n\
    \        return vec;\n    }\n    if remaining < need {\n        vec.push(number\
    \ + remaining);\n        vec.push(0);\n        return vec;\n    }\n    vec.push(number);\n\
    \    vec.push(remaining);\n    vec\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpczfd0le_.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need <= remaining {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp_1hkv6x3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ < need {\n        vec![number + remaining, 0]\n    } else {\n        vec![number\
    \ + need, remaining - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + remaining.min(need);\n    let left = remaining - (need - number);\n\
    \    vec![eaten, left.max(0)]\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmpqzod6mff.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut meal = number + need;\n    if meal > remaining {\n        meal = remaining;\n\
    \    }\n    return vec![meal, remaining - meal];\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpgi0d8p_7.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    if total >= need {\n        vec![need, total\
    \ - need]\n    } else {\n        vec![total, 0]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp6fbtcadp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    if total <= remaining {\n        vec![total, remaining\
    \ - total]\n    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpmbo8vaxv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ diff = number + need - remaining;\n    if diff > 0 {\n        return vec![number\
    \ + remaining, 0];\n    }\n    vec![number + need, remaining - need]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp7yc4c_vl.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    let mut left = need - total;\n    if left <\
    \ 0 {\n        left = 0;\n    }\n    vec![total, left]\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp_rfdr8dq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = if remaining >= need {\n        number + need\n    } else {\n      \
    \  number + remaining\n    };\n    vec![total, remaining - need]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmpb6klhnkf.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total_after_eat = number + need;\n    let carrots_left = if total_after_eat\
    \ > remaining { 0 } else { remaining - total_after_eat };\n    vec![total_after_eat,\
    \ carrots_left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpjgcch4ff.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // Your\
    \ code here\n    if remaining >= need {\n        vec![number + need, remaining\
    \ - need]\n    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ a = if remaining > need { need } else { remaining };\n    let b = if remaining\
    \ > need { 0 } else { remaining - need };\n    vec![number + a, b]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmp74d19mly.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    if need > remaining {\n        eaten += remaining;\n\
    \        return vec![eaten, 0];\n    }\n    eaten += need;\n    vec![eaten, remaining\
    \ - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ >= need {\n        return vec![number, remaining];\n    }\n    if remaining\
    \ <= 0 {\n        return vec![number, 0];\n    }\n    let mut r = remaining -\
    \ (need - number);\n    if r < 0 {\n        r = 0;\n    }\n    return vec![need,\
    \ r];\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp3eoddcf8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut r = remaining;\n    if number + need <= remaining {\n        r = remaining\
    \ - number - need;\n    } else {\n        r = 0;\n    }\n    vec![number + need,\
    \ r]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpzp1esj0a.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ > number + need {\n        vec![number + need, remaining - number - need]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpammoxkrd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ n = number + need;\n    let r = if n <= remaining { remaining - n } else { 0\
    \ };\n    vec![n, r]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpd2atspd_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ sum: isize = number + need;\n    if sum > remaining {\n        let rem = remaining\
    \ - number;\n        vec![remaining, rem]\n    } else {\n        vec![sum, 0]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 5]`,\n right: `[11, 4]`', /tmp/tmpchuj72rj.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut remain = need - number;\n    let mut total = number;\n    if remain < remaining\
    \ {\n        total += remain;\n        remain = 0;\n    } else {\n        total\
    \ += remaining;\n        remain -= remaining;\n    }\n    vec![total, remain]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmpjt368igi.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ remaining = if remaining < 0 {\n        0\n    } else {\n        remaining\n\
    \    };\n    let need = if need < 0 {\n        0\n    } else {\n        need\n\
    \    };\n    let number = if number < 0 {\n        0\n    } else {\n        number\n\
    \    };\n    let remaining = if remaining + number < need {\n        0\n    }\
    \ else {\n        remaining + number - need\n    };\n    vec![number + need, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmp9ivyhgwv.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + need;\n    if eaten <= remaining {\n        vec![eaten, remaining\
    \ - eaten]\n    } else {\n        vec![eaten - remaining, 0]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 0]`,\n right: `[11, 4]`', /tmp/tmpiie8aswi.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ (e, r) = if remaining > need - number {\n        (number + need, remaining -\
    \ need + number)\n    } else {\n        (number + remaining, 0)\n    };\n    vec![e,\
    \ r]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmp9nqv9a_u.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut carrots_eaten = number;\n    let mut carrots_remaining = remaining;\n  \
    \  while carrots_eaten < number + need && carrots_remaining > 0 {\n        carrots_eaten\
    \ += 1;\n        carrots_remaining -= 1;\n    }\n    vec![carrots_eaten, carrots_remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining == 0 {\n        result.push(number);\n\
    \        result.push(remaining);\n    } else if remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ r = match number + need.min(remaining) {\n        x if x >= number => {\n  \
    \          if number + need >= remaining {\n                x - remaining\n  \
    \          } else {\n                x - need\n            }\n        }\n    \
    \    _ => 0,\n    };\n    vec![number + need.min(remaining), r]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 1]`,\n right: `[11, 4]`', /tmp/tmp3n5_9n0k.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut a = number + remaining;\n    let mut b = 0;\n    if a >= need {\n      \
    \  a -= need;\n    } else {\n        b = need - a;\n        a = 0;\n    }\n  \
    \  vec![a, b]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 0]`,\n right: `[11, 4]`', /tmp/tmpx6wlj5v9.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    return\
    \ if remaining >= need {\n        vec![number + need, remaining - need]\n    }\
    \ else {\n        vec![number + remaining, 0]\n    };\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut carrots = remaining;\n    let mut meal = 0;\n\
    \    while meal < need {\n        if carrots > 0 {\n            eaten += 1;\n\
    \            carrots -= 1;\n            meal += 1;\n        } else {\n       \
    \     break;\n        }\n    }\n    vec![eaten, carrots]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= need {\n        vec![number + need, remaining - need]\n    } else {\n   \
    \     vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpe_hk0mmv.rs:28:19\n\
    \   |\n28 |     vec![number + min(need, remaining), max(0, remaining - need)]\n\
    \   |                   ^^^\n...\n31 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n28 |     vec![number + main(need, remaining), max(0, remaining - need)]\n\
    \   |                   ~~~~\nhelp: consider importing this function\n   |\n1\
    \  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmpe_hk0mmv.rs:28:41\n   |\n28 |     vec![number + min(need,\
    \ remaining), max(0, remaining - need)]\n   |                                \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if need <= remaining {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ n = number + min(need, remaining);\n    let r = max(0, remaining - need);\n\
    \    vec![n, r]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp7487wgp9.rs:28:22\n\
    \   |\n28 |     let n = number + min(need, remaining);\n   |                 \
    \     ^^^\n...\n33 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n28 |\
    \     let n = number + main(need, remaining);\n   |                      ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp7487wgp9.rs:29:13\n\
    \   |\n29 |     let r = max(0, remaining - need);\n   |             ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eat = if need > remaining { remaining } else { need };\n    vec![number + eat,\
    \ remaining - eat]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + remaining, 0];\n    if result[0] >= need {\n    \
    \    result[0] = need;\n        result[1] = remaining - (need - number);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpbdbc4kla.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    if total <= remaining {\n        vec![total, remaining\
    \ - total]\n    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpmbo8vaxv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + if need < remaining { need } else { remaining }, if need < remaining { remaining\
    \ - need } else { 0 }]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ (mut total, mut rem): (isize, isize) = (number, remaining);\n    for _ in 0..need\
    \ {\n        if rem > 0 {\n            total += 1;\n            rem -= 1;\n  \
    \      }\n    }\n    vec![total, rem]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total_carrots = number + need;\n    let mut carrots_left = remaining - need;\n\
    \    if carrots_left < 0 {\n        total_carrots = remaining + number;\n    \
    \    carrots_left = 0;\n    }\n    vec![total_carrots, carrots_left]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ > 1000 || need > 1000 || remaining > 1000 {\n        return vec![];\n    }\n\
    \n    if number > remaining || need > remaining {\n        return vec![remaining,\
    \ 0];\n    }\n\n    let mut total_number = number;\n    let mut total_remaining\
    \ = remaining;\n\n    for _ in 0..need {\n        if total_remaining > 0 {\n \
    \           total_number += 1;\n            total_remaining -= 1;\n        }\n\
    \    }\n\n    vec![total_number, total_remaining]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0]`,\n right: `[7, 0]`', /tmp/tmp0asxojnp.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ n = number + remaining;\n    if n >= need {\n        vec![need, n - need]\n\
    \    } else {\n        vec![n, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmps_uq70ck.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ available = remaining - number;\n    if available >= need {\n        vec![number\
    \ + need, available - need]\n    } else {\n        vec![number + available, 0]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp00idv3am.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        (number + remaining).min(need),\n        need.min(remaining) - number,\n\
    \    ]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 1]`,\n right: `[11, 4]`', /tmp/tmpp88ljuhy.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![];\n    if remaining < need {\n        res.push(number + remaining);\n\
    \        res.push(0);\n    } else {\n        res.push(number + need);\n      \
    \  res.push(remaining - need);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ <= remaining {\n        vec![number + need, remaining - need]\n    } else {\n\
    \        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // \
    \ if remaining < need - number\n    if remaining < need - number {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![number + need, remaining - need\
    \ + number]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmp5uqfzps8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut ret = Vec::with_capacity(2);\n    let eaten = number + std::cmp::min(need,\
    \ remaining);\n    let left = remaining - eaten;\n    ret.push(eaten);\n    ret.push(left);\n\
    \    ret\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, -1]`,\n right: `[11, 4]`', /tmp/tmpqzszva7_.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + need <= remaining {\n        vec![number + need, remaining - (number + need)]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp_1hkv6x3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976541
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // your\
    \ code\n    let mut eaten = number;\n    let mut remaining = remaining;\n    let\
    \ mut result = vec![];\n    if number >= need {\n        result.push(need);\n\
    \        result.push(remaining);\n    } else {\n        while eaten < need {\n\
    \            if remaining == 0 {\n                result.push(eaten);\n      \
    \          result.push(remaining);\n                break;\n            } else\
    \ {\n                eaten += 1;\n                remaining -= 1;\n          \
    \  }\n        }\n        if eaten >= need {\n            result.push(eaten);\n\
    \            result.push(remaining);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpdt2rokip.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut ret = vec![number, remaining];\n    let mut index = 0;\n    while ret[index]\
    \ < need {\n        ret[index] += 1;\n        ret[index + 1] -= 1;\n        if\
    \ ret[index + 1] == 0 {\n            break;\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpnxdb4k72.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ res = number + need;\n    let rem = if res > remaining { remaining - number\
    \ } else { remaining - res };\n    vec![res, rem]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 5]`,\n right: `[11, 4]`', /tmp/tmp32lyjlgh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ result: Vec<isize>;\n    if number + need <= remaining {\n        result = vec![number\
    \ + need, remaining - (number + need)];\n    } else {\n        result = vec![number\
    \ + remaining, 0];\n    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpd8xesxxv.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ num = number + std::cmp::min(need, remaining);\n    vec![num, std::cmp::max(0,\
    \ remaining - need)]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp29e3mi9x.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        number + std::cmp::min(need, remaining),\n        std::cmp::max(remaining\
    \ - need, 0),\n    ]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976542
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + remaining.min(need);\n    vec![eaten, remaining - need.min(remaining)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut v: Vec<isize> = Vec::new();\n    if remaining == 0 {\n        v.push(0);\n\
    \        v.push(0);\n    } else if remaining >= need {\n        v.push(number\
    \ + need);\n        v.push(remaining - need);\n    } else {\n        v.push(number\
    \ + remaining);\n        v.push(0);\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976543
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822564
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ sum = number + need;\n    let left = if sum > remaining {\n        sum - remaining\n\
    \    } else {\n        0\n    };\n    vec![sum, left]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 1]`,\n right: `[11, 4]`', /tmp/tmp1gjb6ba0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return a vector of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // your\
    \ code here :)\n    let mut total = number + need;\n    let mut remain = remaining\
    \ - total;\n    if remain < 0 {\n        total += remain;\n        remain = 0;\n\
    \    }\n    vec![total, remain]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp_phf6n31.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976543
