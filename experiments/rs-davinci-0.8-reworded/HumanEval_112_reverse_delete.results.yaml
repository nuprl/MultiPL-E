language: rs
name: HumanEval_112_reverse_delete
results:
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    (s, true)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"abcde\", true)`,\n right: `(\"bcd\", false)`', /tmp/tmpo720c6n1.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let s: Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    let mut result: Vec<char> = Vec::new();\n    let mut i = 0;\n    while i\
    \ < s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n        i += 1;\n    }\n    let mut j = 0;\n    let mut k = result.len()\
    \ - 1;\n    while j < k {\n        if result[j] != result[k] {\n            return\
    \ (result.into_iter().collect(), false);\n        }\n        j += 1;\n       \
    \ k -= 1;\n    }\n    (result.into_iter().collect(), true)\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp4us1nxjl.rs:25:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822474
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let s = s.chars().collect::<Vec<char>>();\n    let mut c = c.chars().collect::<Vec<char>>();\n\
    \    let mut result = String::new();\n    let mut delete = false;\n    for i in\
    \ s {\n        for j in &c {\n            if i == *j {\n                delete\
    \ = true;\n                break;\n            }\n        }\n        if !delete\
    \ {\n            result.push(i);\n        }\n        delete = false;\n    }\n\
    \    (result, is_palindrome(&result))\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpwxa96_ll.rs:30:14\n   |\n30 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpwhx6a8ja.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822474
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let s_v: Vec<char> = s.chars().collect();\n\
    \    let c_v: Vec<char> = c.chars().collect();\n    for i in s_v {\n        if\
    \ !c_v.contains(&i) {\n            result.push(i);\n        }\n    }\n    let\
    \ result_v: Vec<char> = result.chars().collect();\n    (result, result_v == result_v.iter().rev().collect())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmpuajyjdz1.rs:23:23\n\
    \   |\n23 |     (result, result_v == result_v.iter().rev().collect())\n   |  \
    \                     ^^ cannot infer type\n   |\n   = note: cannot satisfy `Vec<char>:\
    \ PartialEq<_>`\nhelp: consider specifying the type argument in the method call\n\
    \   |\n23 |     (result, result_v == result_v.iter().rev().collect::<B>())\n \
    \  |                                                       +++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let s_rev: String = s.chars().rev().collect();\n    let result = s_rev.chars().filter(|x|\
    \ !c.contains(x)).collect();\n    (result, result == s_rev)\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpldijjvja.rs:15:55\n\
    \   |\n15 |     let result = s_rev.chars().filter(|x| !c.contains(x)).collect();\n\
    \   |                                                       ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpwhx6a8ja.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822474
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpwhx6a8ja.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822474
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for char in s.chars() {\n        if !c.contains(char)\
    \ {\n            res.push(char);\n        }\n    }\n    let is_palindrome = res.chars().eq(res.chars().rev());\n\
    \    (res, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822475
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let s: Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    let s: String = s.into_iter().filter(|x| !c.contains(x)).collect();\n   \
    \ let s: Vec<char> = s.chars().collect();\n    let mut s: Vec<char> = s.into_iter().rev().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    (s.into_iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `char` with `&char`\n  --> /tmp/tmp4ggblq_n.rs:20:33\n\
    \   |\n20 |     (s.into_iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n\
    \   |                                 ^^ no implementation for `char == &char`\n\
    \   |\n   = help: the trait `PartialEq<&char>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&char>>`\
    \ for `Vec<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnd6tmzc2.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822474
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    let reversed: String = res.chars().rev().collect();\n\
    \    (res, res == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpj363qifv.rs:21:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n21 |     (res, res == reversed)\n   |      ---  ^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result: String = s;\n    for i in c.chars() {\n        result = result.chars().filter(|&x|\
    \ x != i).collect();\n    }\n    (result, is_palindrome(&result))\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpyvkoy5i9.rs:18:14\n   |\n18 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpwhx6a8ja.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822474
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut ret = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            ret.push(ch);\n        }\n    }\n    (ret, ret == ret.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `ret`\n  --> /tmp/tmphqm11ffr.rs:20:11\n\
    \   |\n14 |     let mut ret = String::new();\n   |         ------- move occurs\
    \ because `ret` has type `String`, which does not implement the `Copy` trait\n\
    ...\n20 |     (ret, ret == ret.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut new_string = String::new();\n    let mut is_palindrome = true;\n\
    \    let mut chars_in_c = Vec::new();\n    let mut count_chars_in_c = 0;\n   \
    \ for ch in c.chars() {\n        chars_in_c.push(ch);\n        count_chars_in_c\
    \ += 1;\n    }\n    for ch in s.chars() {\n        let mut is_in_c = false;\n\
    \        for index in 0..count_chars_in_c {\n            if ch == chars_in_c[index]\
    \ {\n                is_in_c = true;\n                break;\n            }\n\
    \        }\n        if !is_in_c {\n            new_string.push(ch);\n        }\n\
    \    }\n    for index in 0..new_string.len() {\n        if new_string.chars().nth(index)\
    \ != new_string.chars().rev().nth(index) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (new_string, is_palindrome)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822474
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let s: Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    let mut new_s: Vec<char> = Vec::new();\n    for i in s {\n        if !c.contains(&i)\
    \ {\n            new_s.push(i);\n        }\n    }\n    let new_s: String = new_s.into_iter().collect();\n\
    \    let len = new_s.len();\n    let new_s: Vec<char> = new_s.chars().collect();\n\
    \    for i in 0..len {\n        if new_s[i] != new_s[len - i - 1] {\n        \
    \    return (new_s.into_iter().collect(), false);\n        }\n    }\n    (new_s.into_iter().collect(),\
    \ true)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822475
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let s: Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    let s = s.into_iter().filter(|x| !c.contains(x)).collect::<String>();\n \
    \   (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp77hwmbis.rs:17:9\n\
    \   |\n16 |     let s = s.into_iter().filter(|x| !c.contains(x)).collect::<String>();\n\
    \   |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n17 |     (s, s == s.chars().rev().collect::<String>())\n \
    \  |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822474
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpwhx6a8ja.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822474
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result: String = s.chars().filter(|x| !c.contains(x)).collect();\n\
    \    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp__86a7ep.rs:14:63\n\
    \   |\n14 |     let mut result: String = s.chars().filter(|x| !c.contains(x)).collect();\n\
    \   |                                                               ^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659822474
