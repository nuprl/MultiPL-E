language: rs
name: HumanEval_59_largest_prime_factor
results:
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let f = |n: isize| {\n\
    \        let mut n = n;\n        let mut i = 2;\n        while i <= n {\n    \
    \        if n % i == 0 {\n                n /= i;\n            } else {\n    \
    \            i += 1;\n            }\n        }\n        i\n    };\n    f(n)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (mut n, mut i) =\
    \ (n, 2);\n    while i <= n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut biggest_factor\
    \ = 1;\n    let mut d = 2;\n    while d * d <= n {\n        if n % d == 0 {\n\
    \            biggest_factor = d;\n            n /= d;\n        } else {\n    \
    \        d += 1;\n        }\n    }\n    if n > 1 {\n        return n;\n    }\n\
    \    return biggest_factor;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpqdyros47.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= d;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut nn = n;\n    while nn > 1 {\n        if nn % f == 0 {\n            nn /=\
    \ f;\n        } else {\n            f += 1;\n        }\n    }\n    f\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut result = 0;\n    while p * p <= n {\n        if n % p == 0 {\n         \
    \   result = p;\n            while n % p == 0 {\n                n /= p;\n   \
    \         }\n        }\n        p += 1;\n    }\n    if n > 1 {\n        result\
    \ = n;\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdfj62787.rs:13:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \               n /= p;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let is_factor = |x: isize|\
    \ -> bool { n % x == 0 };\n    let is_prime = |x: isize| -> bool { !(2..(x as\
    \ f64).sqrt() as isize + 1).any(|i| x % i == 0) };\n    (2..n).filter(|x| is_factor(*x)).filter(|x|\
    \ is_prime(*x)).last().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ return 0;\n    }\n\n    // find if n is prime\n    let mut primes = prime_sieve(1,\
    \ (n as f64).sqrt() as isize);\n    if let Some(prime) = primes.iter().find(|x|\
    \ **x == n) {\n        return *prime;\n    }\n\n    // find max prime factor\n\
    \    for p in primes.iter().rev() {\n        if n % p == 0 {\n            return\
    \ *p;\n        }\n    }\n\n    0\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_sieve` in this scope\n  --> /tmp/tmpycys5m29.rs:12:22\n\
    \   |\n12 |     let mut primes = prime_sieve(1, (n as f64).sqrt() as isize);\n\
    \   |                      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..=n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    panic!(\"{} is a prime number, do not call me.\", n);\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpcx37z96n.rs:8:26\n\
    \  |\n8 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n           \
    \ n /= i;\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpy8px3zxd.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    panic!(\"Expected non-prime\");\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmptd61aaik.rs:8:26\n\
    \  |\n8 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n    let mut n = n;\n    let mut i = 2;\n    while i *\
    \ i <= n {\n        if n % i == 0 {\n            n /= i;\n        } else {\n \
    \           i += 1;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpxy7fp5_r.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime\
    \ = 1;\n    let mut i = 2;\n    while i <= n / i {\n        if n % i == 0 {\n\
    \            largest_prime = i;\n            n /= i;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    if n > 1 {\n        largest_prime = n;\n\
    \    }\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2v_5iitt.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n    \
    \        n /= i;\n            largest_factor = i;\n        } else {\n        \
    \    i += 1;\n        }\n    }\n    largest_factor\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpk498fv5p.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = n;\n  \
    \  let mut i = 2;\n    while i * i <= res {\n        if res % i == 0 {\n     \
    \       res /= i;\n        } else {\n            i += 1;\n        }\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (mut remainder, mut\
    \ factor) = (n, 2);\n    while factor < remainder {\n        if remainder % factor\
    \ == 0 {\n            remainder /= factor;\n        } else {\n            factor\
    \ += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut result = 1;\n    for prime in primes::new() {\n        if prime >= m {\n\
    \            break;\n        }\n        while m % prime == 0 {\n            result\
    \ = prime;\n            m /= prime;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \ --> /tmp/tmp7qcv2vjd.rs:9:18\n  |\n9 |     for prime in primes::new() {\n  |\
    \                  ^^^^^^ use of undeclared crate or module `primes`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut largest_factor = 0;\n    let mut remaining = n;\n    while remaining\
    \ > 1 {\n        if remaining % factor == 0 {\n            largest_factor = factor;\n\
    \            remaining /= factor;\n        } else {\n            factor += 1;\n\
    \        }\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822547
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO implement\n \
    \   return 0;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmpuhwutwuo.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 2;\n    let mut factor = 2;\n    let mut n = n;\n    while n > 1 {\n       \
    \ while n % factor == 0 {\n            n /= factor;\n            max_factor =\
    \ factor;\n        }\n        factor += 1;\n    }\n    max_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822547
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n\n    let mut n = n;\n    let mut largest_factor = 2;\n\
    \    while n != 1 {\n        if n % largest_factor == 0 {\n            n /= largest_factor;\n\
    \        } else {\n            largest_factor += 1;\n        }\n    }\n    largest_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpl5b1eygd.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for factor in (2..).take_while(|&factor|\
    \ factor * factor <= n) {\n        if n % factor == 0 {\n            return largest_prime_factor(n\
    \ / factor);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..=n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmprfldso7r.rs:8:26\n\
    \  |\n8 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut result = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            result = factor;\n            n /= factor;\n        }\n        factor\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1mv9yqb4.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= factor;\n   |             ^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut q = n;\n    let\
    \ mut d = 2;\n    while q > 1 {\n        while q % d == 0 {\n            q /=\
    \ d;\n        }\n        d += 1;\n    }\n    d - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 2;\n\
    \    let mut tmp = n;\n    while tmp > 1 {\n        while tmp % result == 0 {\n\
    \            tmp /= result;\n        }\n        result += 1;\n    }\n    result\
    \ - 1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    assert!(n > 1);\n   \
    \ let largest_prime_factor = 2;\n\n    // TODO: replace this with your implementation\n\
    \    largest_prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpdq6_dmmv.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Check 2, 3 and 5\n\
    \    if n % 2 == 0 {\n        return 2;\n    }\n    if n % 3 == 0 {\n        return\
    \ 3;\n    }\n    if n % 5 == 0 {\n        return 5;\n    }\n\n    let mut i =\
    \ 7;\n    let mut factor = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            factor = i;\n        }\n        i += 4;\n        if n % i == 0 {\n\
    \            factor = i;\n        }\n        i += 2;\n        if n % i == 0 {\n\
    \            factor = i;\n        }\n        i += 4;\n        if n % i == 0 {\n\
    \            factor = i;\n        }\n        i += 2;\n        if n % i == 0 {\n\
    \            factor = i;\n        }\n        i += 4;\n        if n % i == 0 {\n\
    \            factor = i;\n        }\n        i += 6;\n        if n % i == 0 {\n\
    \            factor = i;\n        }\n        i += 2;\n        if n % i == 0 {\n\
    \            factor = i;\n        }\n        i += 6;\n    }\n    factor\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpwlgqoghq.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 2;\n    let mut number = n;\n    while prime_factor <= number {\n        if\
    \ number % prime_factor == 0 {\n            number /= prime_factor;\n        }\
    \ else {\n            prime_factor += 1;\n        }\n    }\n    return prime_factor;\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n    let mut factor = n;\n    while !is_prime(factor)\
    \ {\n        for i in (2..factor + 1).rev() {\n            if factor % i == 0\
    \ {\n                factor = i;\n                break;\n            }\n    \
    \    }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmps3036q55.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmps3036q55.rs:11:12\n\
    \   |\n11 |     while !is_prime(factor) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..).take_while(|&x|\
    \ x * x <= n).find(|&x| n % x == 0).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmplx83dpus.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut k = n;\n    let\
    \ mut i = 2;\n    while i * i <= k {\n        if k % i == 0 {\n            k /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    k\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        panic!(\"\
    Invalid input: {}\", n);\n    }\n    for d in (2..).take_while(|&d| d * d <= n)\
    \ {\n        if n % d == 0 {\n            return largest_prime_factor(n / d);\n\
    \        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 2;\n    let mut num = n;\n    while num % 2 == 0 {\n        num /= 2;\n  \
    \  }\n    let mut divisor = 3;\n    while num > 1 {\n        while num % divisor\
    \ == 0 {\n            num /= divisor;\n            largest_factor = divisor;\n\
    \        }\n        divisor += 2;\n    }\n    largest_factor\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n\
    \    let mut prime = 2;\n    let mut n = n;\n    while n > 1 {\n        while\
    \ n % prime == 0 {\n            result = prime;\n            n /= prime;\n   \
    \     }\n        prime += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: Your code here!\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa1cwj6in.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    return i;\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut prime = 2;\n    while n > 1 {\n        if n % prime == 0 {\n           \
    \ n /= prime;\n        } else {\n            prime += 1;\n        }\n    }\n \
    \   prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: fix code here.\n\
    \    let mut n = n;\n    let mut max = n;\n    let mut i = 2;\n    while i < n\
    \ {\n        if n % i == 0 {\n            n /= i;\n            max = i;\n    \
    \    }\n        i += 1;\n    }\n    max\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp756qdw2q.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 2 {\n       \
    \ return 2;\n    }\n    if n % 2 == 0 {\n        return largest_prime_factor(n\
    \ / 2);\n    }\n    let sq = (n as f64).sqrt() as isize;\n    for i in (3..sq\
    \ + 1).step_by(2) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    return n;\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 1;\n    let mut remainder = n;\n    let mut factor = 2;\n    while remainder\
    \ > 1 {\n        if remainder % factor == 0 {\n            remainder /= factor;\n\
    \            prime_factor = factor;\n        } else {\n            factor += 1;\n\
    \        }\n    }\n    prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    1\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp5y6gmk4s.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n           \
    \ n /= i;\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpy8px3zxd.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut _n = n;\n    while _n > 1 {\n        if _n % f == 0 {\n            _n /=\
    \ f;\n        } else {\n            f += 1;\n        }\n    }\n    f\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     return largest_prime_factor(n / 2);\n    }\n\n    let mut i = 3;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n\n        i += 2;\n    }\n\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_helper(n,\
    \ 2)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factor_helper` in this\
    \ scope\n --> /tmp/tmp7cjfyj7n.rs:7:5\n  |\n7 |     largest_prime_factor_helper(n,\
    \ 2)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 0;\n\
    \    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ result = i;\n            n /= i;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpr30rt79d.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let\
    \ mut i = 2;\n    let mut factors = Vec::new();\n    while i * i <= x {\n    \
    \    if x % i == 0 {\n            factors.push(i);\n            x /= i;\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    if x > 1 {\n       \
    \ factors.push(x);\n    }\n    factors.sort();\n    factors.last().unwrap().clone()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut i = n;\n    let mut largest_factor = 1;\n    while i > 1 {\n    \
    \    while i % factor == 0 {\n            largest_factor = factor;\n         \
    \   i /= factor;\n        }\n        factor += 1;\n    }\n    largest_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut prime = 2;\n    while n % prime == 0 {\n        n /= prime;\n    }\n   \
    \ while n != 1 {\n        prime += 1;\n        while is_prime(prime) == false\
    \ {\n            prime += 1;\n        }\n        while n % prime == 0 {\n    \
    \        n /= prime;\n        }\n    }\n    prime\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmply3x03_g.rs:14:15\n\
    \   |\n14 |         while is_prime(prime) == false {\n   |               ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_prime = 1;\n    let mut p = 2;\n    while p * p <= n {\n       \
    \ if n % p == 0 {\n            n /= p;\n            largest_prime = p;\n     \
    \   } else {\n            p += 1;\n        }\n    }\n    if n > largest_prime\
    \ {\n        n\n    } else {\n        largest_prime\n    }\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = Primes::new();\n\
    \    let mut largest = 1;\n    while let Some(prime) = primes.next() {\n     \
    \   if n % prime == 0 {\n            largest = prime;\n        }\n        if prime\
    \ * prime > n {\n            break;\n        }\n    }\n    largest\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Primes`\n -->\
    \ /tmp/tmpec8ube2u.rs:7:22\n  |\n7 |     let mut primes = Primes::new();\n  |\
    \                      ^^^^^^ use of undeclared type `Primes`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n\n    let mut prime_factor: isize = n;\n    let mut k:\
    \ isize = 2;\n    let mut limit: isize = n;\n\n    while k <= limit {\n      \
    \  while prime_factor % k == 0 {\n            prime_factor = prime_factor / k;\n\
    \            limit = prime_factor;\n        }\n        k += 1;\n    }\n\n    prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpmun7pxre.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // 1 is not prime\n \
    \   if n == 1 {\n        return 0;\n    }\n\n    // 2 is the only even prime\n\
    \    if n % 2 == 0 {\n        return largest_prime_factor(n / 2);\n    }\n\n \
    \   // Now n is odd and n > 1, so it is not prime\n    // Find the largest odd\
    \ prime factor, p, of n\n    let mut p = 0;\n    let mut i = 3;\n    let mut quotient\
    \ = n;\n    while i * i <= n {\n        if quotient % i == 0 {\n            quotient\
    \ /= i;\n            p = i;\n        } else {\n            i += 2;\n        }\n\
    \    }\n\n    if quotient > 1 {\n        p = quotient;\n    }\n\n    p\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut d = 2;\n    while n > 1 {\n        while n % d == 0 {\n  \
    \          largest_factor = d;\n            n /= d;\n        }\n        d += 1;\n\
    \    }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphzj4j_x3.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= d;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let factors = prime_factors(n);\n\
    \    *factors.iter().max().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmp0zoq3ldp.rs:7:19\n  |\n7 |     let factors = prime_factors(n);\n  |\
    \                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut i = 2;\n    while i <= m {\n        if m % i == 0 {\n            m /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    return i;\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut n = n;\n    for divisor in 2..(n / 2 + 1) {\n        if n\
    \ % divisor == 0 {\n            n /= divisor;\n            largest_factor = divisor;\n\
    \        }\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmphgrz5zjl.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut k = n;\n    while k > p {\n        if k % p == 0 {\n            k /= p;\n\
    \        } else {\n            p += 1;\n        }\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor: isize\
    \ = n;\n    let mut n = n;\n    let mut i = 2;\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            factor = i;\n            n /= i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    if n > 1 {\n        factor = n;\n\
    \    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut d = 2;\n    let\
    \ mut m = n;\n    while d * d <= m {\n        if m % d == 0 {\n            m /=\
    \ d;\n        } else {\n            d += 1;\n        }\n    }\n    m\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut i = 2;\n    let mut p = 0;\n    while i < n {\n        if m % i == 0 {\n\
    \            p = i;\n            m = m / i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    p\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut divisor = 2;\n\
    \    let mut factor = n;\n    while divisor * divisor <= factor {\n        if\
    \ factor % divisor == 0 {\n            factor /= divisor;\n        } else {\n\
    \            divisor += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    unimplemented!()\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpygjz2t0w.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut divisor = 2;\n\
    \    let mut max_divisor = 1;\n    while n > 1 {\n        while n % divisor ==\
    \ 0 {\n            max_divisor = divisor;\n            n /= divisor;\n       \
    \ }\n        divisor += 1;\n    }\n    max_divisor\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp8lfea78g.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= divisor;\n   |             ^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let limit = (n as f64).sqrt()\
    \ as isize;\n    let mut factor = 2;\n    while factor <= limit {\n        if\
    \ n % factor == 0 {\n            return largest_prime_factor(n / factor);\n  \
    \      }\n        factor += 1;\n    }\n    return n;\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn helper(n: isize, divisor:\
    \ isize) -> isize {\n        if n <= divisor {\n            n\n        } else\
    \ if n % divisor == 0 {\n            helper(n / divisor, divisor)\n        } else\
    \ {\n            helper(n, divisor + 1)\n        }\n    }\n    helper(n, 2)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    match n {\n        _\
    \ if is_prime(n) => n,\n        _ => {\n            let mut divisor = 2;\n   \
    \         let mut largest_prime_factor = 1;\n            let mut temp = n;\n \
    \           while temp > 1 {\n                if temp % divisor == 0 {\n     \
    \               largest_prime_factor = divisor;\n                    temp /= divisor;\n\
    \                } else {\n                    divisor += 1;\n               \
    \ }\n            }\n            largest_prime_factor\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpysam9g57.rs:8:14\n\
    \  |\n8 |         _ if is_prime(n) => n,\n  |              ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor: isize\
    \ = 2;\n    let mut n = n;\n    while n != 1 {\n        if n % factor == 0 {\n\
    \            n /= factor;\n        } else {\n            factor += 1;\n      \
    \  }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let factors = prime_factors(n);\n\
    \    return factors[factors.len() - 1];\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpw5r0y9xr.rs:7:19\n  |\n7 |     let factors = prime_factors(n);\n  |\
    \                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut divisor = 2;\n\
    \    let mut quotient = n;\n    while divisor <= quotient {\n        if is_prime(divisor)\
    \ && quotient % divisor == 0 {\n            quotient /= divisor;\n        } else\
    \ {\n            divisor += 1;\n        }\n    }\n    divisor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpimd597vb.rs:10:12\n\
    \   |\n10 |         if is_prime(divisor) && quotient % divisor == 0 {\n   |  \
    \          ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = Vec::new();\n\
    \    let mut current = n;\n    let mut primes = PrimeIterator::new();\n    while\
    \ current > 1 {\n        match prime_factors(current) {\n            Ok(vec) =>\
    \ {\n                for factor in vec {\n                    factors.push(factor);\n\
    \                }\n                break;\n            }\n            Err(i)\
    \ => {\n                current = i;\n                let prime = primes.next().unwrap();\n\
    \                factors.push(prime);\n            }\n        }\n    }\n    let\
    \ mut largest = 0;\n    for i in factors {\n        if i > largest {\n       \
    \     largest = i;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `PrimeIterator`\n\
    \ --> /tmp/tmp0v75irdt.rs:9:22\n  |\n9 |     let mut primes = PrimeIterator::new();\n\
    \  |                      ^^^^^^^^^^^^^ use of undeclared type `PrimeIterator`\n\
    \nerror[E0425]: cannot find function `prime_factors` in this scope\n  --> /tmp/tmp0v75irdt.rs:11:15\n\
    \   |\n11 |         match prime_factors(current) {\n   |               ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_factor = 1;\n    while n % 2 == 0 {\n        largest_factor = 2;\n\
    \        n /= 2;\n    }\n    let mut factor = 3;\n    while n > 1 {\n        while\
    \ n % factor == 0 {\n            largest_factor = factor;\n            n /= factor;\n\
    \        }\n        factor += 2;\n    }\n    largest_factor\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n\
    \    let mut factor = 2;\n    let mut n = n;\n    while n > 1 {\n        if n\
    \ % factor == 0 {\n            n /= factor;\n            largest = factor;\n \
    \       } else {\n            factor += 1;\n        }\n    }\n    largest\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut n = n;\n    let mut i = 2;\n    while i <= n {\n        if n % i\
    \ == 0 {\n            factors.push(i);\n            n /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    factors.pop().unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 2;\n    let mut new_n = n;\n    for i in 2..n {\n        if new_n % i == 0\
    \ {\n            if is_prime(i) {\n                largest_prime_factor = i;\n\
    \            }\n            new_n = new_n / i;\n        }\n    }\n    largest_prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpnhkinrkb.rs:11:16\n\
    \   |\n11 |             if is_prime(i) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    factors.push(n);\n    factors.append(&mut prime_factors(n));\n    factors.sort();\n\
    \    factors.pop().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpxrczg0vi.rs:9:25\n  |\n9 |     factors.append(&mut prime_factors(n));\n\
    \  |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut ret = 0;\n  \
    \  let mut divisor = 2;\n    let mut remainder = n;\n    while remainder > 1 {\n\
    \        if remainder % divisor == 0 {\n            ret = divisor;\n         \
    \   remainder /= divisor;\n        } else {\n            divisor += 1;\n     \
    \   }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    match n {\n        1\
    \ => 1,\n        2 => 2,\n        _ => {\n            for x in (2..n).rev() {\n\
    \                if is_prime(x) && n % x == 0 {\n                    return x;\n\
    \                }\n            }\n            1\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1_hsz9s5.rs:12:20\n\
    \   |\n12 |                 if is_prime(x) && n % x == 0 {\n   |             \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     largest_prime_factor(n / 2)\n    } else {\n        // Find the next prime\
    \ factor (other than 2) of n.\n        let mut i = 3;\n        while n % i !=\
    \ 0 {\n            i += 2;\n        }\n        // Largest prime factor is the\
    \ larger of i and the largest prime factor of n / i.\n        let other_prime_factor\
    \ = largest_prime_factor(n / i);\n        if i > other_prime_factor {\n      \
    \      i\n        } else {\n            other_prime_factor\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976670
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ 1;\n    }\n    let mut n = n;\n    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            n /= i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut remaining = n;\n    let mut factor = 2;\n    while remaining\
    \ > 1 {\n        if remaining % factor == 0 {\n            largest_factor = factor;\n\
    \            remaining /= factor;\n            while remaining % factor == 0 {\n\
    \                remaining /= factor;\n            }\n        }\n        factor\
    \ += 1;\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Fill this in.\n  \
    \  let mut factor = 2;\n    let mut max_factor = 1;\n    while factor <= n {\n\
    \        if n % factor == 0 {\n            max_factor = factor;\n            n\
    \ /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n \
    \   max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpi24nglx4.rs:13:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \           n /= factor;\n   |             ^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ panic!(\"n must be greater than 1\")\n    }\n    let mut prime_factors = Vec::new();\n\
    \    let mut n_mut = n;\n    for i in 2..n {\n        if n_mut % i == 0 {\n  \
    \          n_mut /= i;\n            prime_factors.push(i);\n        }\n    }\n\
    \    *prime_factors.last().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpxk3ws5gu.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            largest_factor = i;\n            n /= i;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    largest_factor\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpyxa6t6om.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // A prime number is\
    \ any number greater than 1 whose only factors are 1 and itself.\n    // `is_prime`\
    \ is declared in `lib.rs`.\n    let mut result = 0;\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 && is_prime(i) {\n            result = i;\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptw_9at1p.rs:12:26\n\
    \   |\n12 |         if n % i == 0 && is_prime(i) {\n   |                     \
    \     ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let prime_factors = prime_factors(n);\n\
    \    *prime_factors.iter().max().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpavg9glyz.rs:7:25\n  |\n7 |     let prime_factors = prime_factors(n);\n\
    \  |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    return primes_less_than(n).iter().rev().next().unwrap();\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `primes_less_than` in this scope\n -->\
    \ /tmp/tmpnekr804o.rs:7:12\n  |\n7 |     return primes_less_than(n).iter().rev().next().unwrap();\n\
    \  |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n           \
    \ n /= i;\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpy8px3zxd.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822547
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut num = n;\n  \
    \  let mut max_prime = 2;\n    let mut p = 2;\n    while p * p <= num {\n    \
    \    if num % p == 0 {\n            max_prime = p;\n            num /= p;\n  \
    \      } else {\n            p += 1;\n        }\n    }\n    if num > max_prime\
    \ {\n        num\n    } else {\n        max_prime\n    }\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut i = 2;\n    while i <= m {\n        if m % i == 0 {\n            m /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    return i;\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut q = n;\n    while q > p {\n        if q % p == 0 {\n            q /= p;\n\
    \        } else {\n            p += 1;\n        }\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut candidate = 2;\n\
    \    let mut biggest = 1;\n    while candidate <= n {\n        if n % candidate\
    \ == 0 {\n            biggest = candidate;\n            while n % candidate ==\
    \ 0 {\n                n /= candidate;\n            }\n        }\n        candidate\
    \ += 1;\n    }\n    biggest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpohn4afpp.rs:13:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \               n /= candidate;\n   |                 ^^^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in 2.. {\n    \
    \    if n % i == 0 {\n            return largest_prime_factor(n / i);\n      \
    \  }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976671
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    let mut max = 1;\n    while i <= n / i {\n        while n %\
    \ i == 0 {\n            max = i;\n            n = n / i;\n        }\n        i\
    \ += 1;\n    }\n    if n > 1 {\n        max = n;\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors\
    \ = Vec::new();\n    let mut check = n;\n    let mut primes = prime_gen(n);\n\
    \    while check > 1 {\n        let p = primes.next().unwrap();\n        while\
    \ check % p == 0 {\n            prime_factors.push(p);\n            check /= p;\n\
    \        }\n    }\n    *prime_factors.iter().max().unwrap()\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_gen` in this scope\n --> /tmp/tmp7s9btql1.rs:9:22\n\
    \  |\n9 |     let mut primes = prime_gen(n);\n  |                      ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // A simple trial division\
    \ algorithm, optimized for n by stopping at sqrt(n).\n    // If n has a prime\
    \ factor of p, then either n = p or n/p is not a prime number.\n    let mut f\
    \ = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % f == 0 {\n     \
    \       n /= f;\n        } else {\n            f += 1;\n        }\n    }\n   \
    \ f\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut i = 2;\n    while i * i <= m {\n        if m % i == 0 {\n            m /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    m\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_factor = 1;\n    let mut i = 2;\n    while i * i <= n {\n      \
    \  if n % i == 0 {\n            largest_factor = i;\n            n /= i;\n   \
    \     } else {\n            i += 1;\n        }\n    }\n    if n > 1 {\n      \
    \  largest_factor = n;\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    for\
    \ x in 2..n / 2 {\n        if n % x == 0 {\n            n /= x;\n        }\n \
    \   }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n  \
    \  assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp9cakih5m.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    0\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpsvqxzfwz.rs:8:26\n\
    \  |\n8 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor: isize\
    \ = 2;\n    let mut n_modified = n;\n    while factor <= n_modified {\n      \
    \  if n_modified % factor == 0 {\n            n_modified /= factor;\n        }\
    \ else {\n            factor += 1;\n        }\n    }\n    return factor;\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 1 {\n        panic!(\"\
    n must be > 1. Found: {}\", n);\n    }\n    if is_prime(n) {\n        return n;\n\
    \    }\n    let mut lpf = 1;\n    for p in 2..=n {\n        if is_prime(p) &&\
    \ n % p == 0 {\n            lpf = p;\n        }\n    }\n    lpf\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpi7gw5478.rs:10:8\n\
    \   |\n10 |     if is_prime(n) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpi7gw5478.rs:15:12\n\
    \   |\n15 |         if is_prime(p) && n % p == 0 {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    let mut last_factor = 0;\n    while n > 1 {\n        if\
    \ n % factor == 0 {\n            last_factor = factor;\n            n /= factor;\n\
    \            while n % factor == 0 {\n                n /= factor;\n         \
    \   }\n        }\n        factor += 1;\n    }\n    last_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime\
    \ = 2;\n    let mut num = n;\n    while num > 1 {\n        for x in largest_prime..\
    \ {\n            if num % x == 0 {\n                largest_prime = x;\n     \
    \           num /= x;\n                break;\n            }\n        }\n    }\n\
    \    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: Implement\n\
    \    0\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmpcnq2zrrx.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            largest_factor = i;\n            n /= i;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    largest_factor\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpyxa6t6om.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    match n {\n        0\
    \ => -1,\n        1 => -1,\n        2 => 2,\n        _ => {\n            let mut\
    \ prime_factors = Vec::new();\n            for i in 2..n + 1 {\n             \
    \   if is_prime(i) && n % i == 0 {\n                    prime_factors.push(i);\n\
    \                }\n            }\n            *prime_factors.iter().max().unwrap()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpoypf4zvs.rs:14:20\n\
    \   |\n14 |                 if is_prime(i) && n % i == 0 {\n   |             \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime\
    \ = 0;\n    let mut n = n;\n    for i in 2..n {\n        while n % i == 0 {\n\
    \            n /= i;\n            largest_prime = i;\n        }\n    }\n    largest_prime\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    match is_prime(n) {\n\
    \        true => n,\n        false => largest_prime_factor(factor(n).1),\n   \
    \ }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp5mo5ancj.rs:7:11\n\
    \  |\n7 |     match is_prime(n) {\n  |           ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `factor` in this scope\n --> /tmp/tmp5mo5ancj.rs:9:39\n\
    \  |\n9 |         false => largest_prime_factor(factor(n).1),\n  |           \
    \                            ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_prime = -1;\n\
    \    let mut copy = n;\n\n    while copy % 2 == 0 {\n        max_prime = 2;\n\
    \        copy /= 2;\n    }\n\n    let mut i = 3;\n    while i <= (copy as f64).sqrt()\
    \ as isize {\n        while copy % i == 0 {\n            max_prime = i;\n    \
    \        copy /= i;\n        }\n        i += 2;\n    }\n\n    if copy > 2 {\n\
    \        max_prime = copy;\n    }\n\n    max_prime\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut last_prime = 2;\n    while n % 2 == 0 {\n        n /= 2;\n    }\n    let\
    \ mut f = 3;\n    while f * f <= n {\n        if n % f == 0 {\n            last_prime\
    \ = f;\n            while n % f == 0 {\n                n /= f;\n            }\n\
    \        }\n        f += 2;\n    }\n    if n > 1 {\n        last_prime = n;\n\
    \    }\n    last_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![2];\n\
    \    let mut num = n;\n    for i in 3..n {\n        if is_prime(i) {\n       \
    \     primes.push(i);\n        }\n    }\n    while !is_prime(num) {\n        let\
    \ mut found = false;\n        for p in primes.iter() {\n            if num % p\
    \ == 0 {\n                num = num / p;\n                found = true;\n    \
    \            break;\n            }\n        }\n        if !found {\n         \
    \   panic!(\"No prime factors found for {}\", n);\n        }\n    }\n    num\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpldvcdhgt.rs:10:12\n\
    \   |\n10 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n  -->\
    \ /tmp/tmpldvcdhgt.rs:14:12\n   |\n14 |     while !is_prime(num) {\n   |     \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n\
    \    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n   \
    \ assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut divisor = 2;\n\
    \    let mut largest_prime_factor = 0;\n    let mut remaining = n;\n    while\
    \ remaining > 1 {\n        if remaining % divisor == 0 {\n            largest_prime_factor\
    \ = divisor;\n            remaining /= divisor;\n        } else {\n          \
    \  divisor += 1;\n        }\n    }\n    largest_prime_factor\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 0;\n\
    \    for mut i in 2..=(n / 2) {\n        if i % 2 == 0 {\n            i += 1;\n\
    \        }\n        if n % i == 0 {\n            result = i;\n            while\
    \ n % i == 0 {\n                n /= i;\n            }\n        }\n    }\n   \
    \ if n > 1 {\n        result = n;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpvszkg00x.rs:15:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n15 |  \
    \               n /= i;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_prime = 2;\n    while n > 1 {\n        if is_prime(n) {\n      \
    \      return n;\n        }\n        while n % largest_prime == 0 {\n        \
    \    n /= largest_prime;\n        }\n        largest_prime += 1;\n    }\n    largest_prime\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp42yxpiv2.rs:10:12\n\
    \   |\n10 |         if is_prime(n) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = n /\
    \ 2;\n    while !is_prime(factor) {\n        if n % factor == 0 {\n          \
    \  return factor;\n        }\n        factor -= 1;\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpga6tezrf.rs:8:12\n\
    \  |\n8 |     while !is_prime(factor) {\n  |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest_prime = 1;\n    while i <= n / 2 {\n        if is_prime(i) && n\
    \ % i == 0 {\n            largest_prime = i;\n        }\n        i += 1;\n   \
    \ }\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4h36udef.rs:10:12\n\
    \   |\n10 |         if is_prime(i) && n % i == 0 {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut n = n;\n    let mut m = 2;\n    while n > 1 {\n        if n % m ==\
    \ 0 {\n            factors.push(m);\n            n /= m;\n        } else {\n \
    \           m += 1;\n        }\n    }\n    factors.iter().max().unwrap().clone()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = 0;\n  \
    \  let mut sq = (n as f64).sqrt() as isize;\n    while sq > 1 {\n        if n\
    \ % sq == 0 && is_prime(sq) {\n            res = sq;\n            break;\n   \
    \     }\n        sq -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyy5i382f.rs:10:27\n\
    \   |\n10 |         if n % sq == 0 && is_prime(sq) {\n   |                   \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    while n % factor != 0 {\n        factor += 1;\n    }\n\
    \    n /= factor;\n    if n == 1 {\n        factor\n    } else {\n        largest_prime_factor(n)\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Prime numbers less\
    \ than or equal to 10\n    let mut pset = vec![2, 3, 5, 7];\n    let mut result\
    \ = 0;\n    for i in 2..(n as f64).sqrt() as isize + 1 {\n        let is_prime\
    \ = if i <= 10 {\n            pset.contains(&i)\n        } else {\n          \
    \  is_prime_number(i)\n        };\n        if is_prime && n % i == 0 {\n     \
    \       result = i;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_number` in this scope\n  -->\
    \ /tmp/tmpaw771j4q.rs:14:13\n   |\n14 |             is_prime_number(i)\n   | \
    \            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let\
    \ mut i = 2;\n    while i * i <= x {\n        if x % i == 0 {\n            x /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    x\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // We start i at 3 since\
    \ even numbers can be divided by 2 and 1 is not a prime number.\n    for i in\
    \ (3..).step_by(2) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976671
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut d = 2;\n    while n > 1 {\n        while n % d == 0 {\n            n /=\
    \ d;\n        }\n        d += 1;\n    }\n    d - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 2;\n    while n != 1 {\n        while n % p == 0 {\n            n /=\
    \ p;\n        }\n        p += 1;\n    }\n    p - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    return 0;\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmp21411tbt.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest = 0;\n    while i <= n {\n        if n % i == 0 {\n            largest\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpq8glps5d.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut k = n;\n    let\
    \ mut i = 2;\n    while i * i <= k {\n        if k % i == 0 {\n            k /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    k\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // The largest prime\
    \ factor of n is no greater than n / 2.\n    for i in (2..=(n / 2)).rev() {\n\
    \        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n  \
    \  }\n    // In case of n is a prime.\n    return n;\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpkpc18v0g.rs:9:26\n\
    \  |\n9 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Can I prune the search\
    \ space?\n    // Don't want to waste time searching for numbers that are obviously\
    \ not going to be a\n    // factor of n.\n    //\n    // Could go through all\
    \ factors and keep track of which ones are prime?\n    // Well, just check if\
    \ it's a prime. Probably don't need to store the list of primes.\n    let mut\
    \ largest_prime_factor = 1;\n    for i in 2..(n/2) {\n        if n % i == 0 &&\
    \ is_prime(i) {\n            largest_prime_factor = i;\n        }\n    }\n   \
    \ largest_prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpi34yxfpd.rs:15:26\n\
    \   |\n15 |         if n % i == 0 && is_prime(i) {\n   |                     \
    \     ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 0;\n\
    \    let mut x = n;\n    let mut i = 2;\n    while i * i <= x {\n        if x\
    \ % i == 0 {\n            result = i;\n            x /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    if x > 1 {\n        result = x;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut max_prime = 2;\n    while i <= n {\n        while n % i == 0 {\n       \
    \     max_prime = i;\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    max_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppnyh_b0_.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest_prime = 2;\n    while i * i <= n {\n        if n % i == 0 {\n  \
    \          largest_prime = i;\n            while n % i == 0 {\n              \
    \  n /= i;\n            }\n        }\n        i += 1;\n    }\n    if n > largest_prime\
    \ {\n        n\n    } else {\n        largest_prime\n    }\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp0nm7v6av.rs:13:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \               n /= i;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: Implement the\
    \ function here\n    let mut new_n = n;\n    let mut largest_factor = 1;\n   \
    \ while new_n != 1 {\n        largest_factor = smallest_factor(new_n);\n     \
    \   new_n /= largest_factor;\n    }\n    largest_factor\n}\n\nfn main() {\n  \
    \  let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `smallest_factor` in this scope\n  -->\
    \ /tmp/tmpa0xfd0bx.rs:11:26\n   |\n11 |         largest_factor = smallest_factor(new_n);\n\
    \   |                          ^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `largest_factor`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut l: isize = 0;\n    let mut m = n;\n    while p * p <= m {\n        if m\
    \ % p == 0 {\n            l = p;\n            m /= p;\n        } else {\n    \
    \        p += 1;\n        }\n    }\n    if m > 1 {\n        l = m;\n    }\n  \
    \  l\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n\
    \    let mut num = n;\n    while num > 1 {\n        let mut factor = 2;\n    \
    \    while factor <= num {\n            if num % factor == 0 {\n             \
    \   result = factor;\n                num /= factor;\n                break;\n\
    \            }\n            factor += 1;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut num = n;\n  \
    \  let mut largest_factor = 2;\n    while num > largest_factor {\n        if num\
    \ % largest_factor == 0 {\n            num /= largest_factor;\n            largest_factor\
    \ = 2;\n        } else {\n            largest_factor += 1;\n        }\n    }\n\
    \    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut result = 1;\n    let mut n = n;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            result = i;\n            n /= i;\n        } else {\n \
    \           i += 1;\n        }\n    }\n    if n > 1 {\n        result = n;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factors = Vec::new();\n    let mut i = 2;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            n /= i;\n            factors.push(i);\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    factors.pop().unwrap()\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // We define a function\
    \ to do factorization.\n    // Note that for efficiency reasons, the code defines\
    \ a \"helper\" function,\n    // and we then use a Rust closure to wrap the function\
    \ and make it capture\n    // a mutable variable.\n    fn factor(n: isize, largest:\
    \ &mut isize) {\n        for i in 2..=(n / 2) {\n            if n % i == 0 {\n\
    \                *largest = if i > *largest { i } else { *largest };\n       \
    \         factor(n / i, largest);\n                break;\n            }\n   \
    \     }\n    }\n\n    let mut largest = 0;\n    factor(n, &mut largest);\n   \
    \ largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpud5suyzk.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // PENDING\n    0\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmpdg2qvedj.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut k = 2;\n    let\
    \ mut l: isize = 1;\n    while k * k <= n {\n        if n % k == 0 {\n       \
    \     n /= k;\n            l = k;\n        } else {\n            k += 1;\n   \
    \     }\n    }\n    if n > l {\n        n\n    } else {\n        l\n    }\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpeamne6j3.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n /= k;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n\n    for i in (2..).take_while(|&i| i * i <= n) {\n\
    \        if n % i == 0 {\n            return largest_prime_factor(n / i);\n  \
    \      }\n    }\n\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpl91a58g0.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_prime = 2;\n    while n > 1 {\n        largest_prime = next_prime(largest_prime);\n\
    \        while n % largest_prime == 0 {\n            n /= largest_prime;\n   \
    \     }\n    }\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_prime` in this scope\n  --> /tmp/tmpiwtn7b0f.rs:10:25\n\
    \   |\n10 |         largest_prime = next_prime(largest_prime);\n   |         \
    \                ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut max = 1;\n    for i in 2..n {\n        if n % i == 0 {\n            n /=\
    \ i;\n            max = i;\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpcrhyysd1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let limit = (n as f64).sqrt()\
    \ as isize;\n    let mut prime_factors = Vec::new();\n    let mut factor = 2;\n\
    \    let mut remainder = n;\n    while factor <= limit {\n        if remainder\
    \ % factor == 0 {\n            remainder /= factor;\n            prime_factors.push(factor);\n\
    \        } else {\n            factor += 1;\n        }\n    }\n    if remainder\
    \ != 1 {\n        prime_factors.push(remainder);\n    }\n    *prime_factors.iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 1;\n    while p < n {\n        p += 1;\n        while n % p == 0 {\n\
    \            n /= p;\n        }\n    }\n    p\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 0;\n    for i in 2..n / 2 {\n        if n % i == 0 && is_prime(i) {\n    \
    \        largest_factor = i;\n        }\n    }\n    largest_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpbv9r1vlm.rs:9:26\n\
    \  |\n9 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = n;\n    for\
    \ i in 2..n {\n        if n % i == 0 {\n            p = largest_prime_factor(n\
    \ / i);\n            break;\n        }\n    }\n    p\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut result = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            result = factor;\n            n /= factor;\n        }\n        factor\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1mv9yqb4.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= factor;\n   |             ^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![];\n\
    \    let mut fact = n;\n    for i in 2..n {\n        if fact % i == 0 {\n    \
    \        fact /= i;\n            primes.push(i);\n        }\n    }\n    *primes.last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmp9a5oq9xn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 0;\n    let mut lpf = 2;\n    let mut n = n;\n    while n > 1 {\n        if\
    \ n % lpf == 0 {\n            largest_prime_factor = lpf;\n            n /= lpf;\n\
    \        } else {\n            lpf += 1;\n        }\n    }\n    largest_prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 {\n       \
    \ return 1;\n    }\n    let mut n = n;\n    let mut i = 2;\n    while i <= n {\n\
    \        if n % i == 0 {\n            n /= i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut c = n;\n    let\
    \ mut i = 2;\n    while i * i <= c {\n        if c % i == 0 {\n            c /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    return c;\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut factor = 2;\n    let mut n = n;\n    while n != 1 {\n        if n\
    \ % factor == 0 {\n            factors.push(factor);\n            n /= factor;\n\
    \        } else {\n            factor += 1;\n        }\n    }\n    *factors.last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % largest_prime_factor\
    \ == 0 {\n            n /= largest_prime_factor;\n        } else {\n         \
    \   largest_prime_factor += 1;\n        }\n    }\n    largest_prime_factor\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors\
    \ = vec![];\n    let mut c = n;\n    for i in 2..c {\n        while c % i == 0\
    \ {\n            prime_factors.push(i);\n            c /= i;\n        }\n    }\n\
    \    if c > 1 {\n        prime_factors.push(c);\n    }\n    *prime_factors.iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 2;\n    while n % p == 0 {\n        n /= p;\n    }\n    p += 1;\n  \
    \  while n > 1 {\n        while n % p == 0 {\n            n /= p;\n        }\n\
    \        p += 2;\n    }\n    p - 2\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    n / 2\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpab4degcw.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut m = 2;\n    while n > 1 {\n        while n % m == 0 {\n            n /=\
    \ m;\n        }\n        m += 1;\n    }\n    m - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut k = n;\n    let\
    \ mut largest_prime = 1;\n    while k % 2 == 0 {\n        largest_prime = 2;\n\
    \        k /= 2;\n    }\n    let mut i = 3;\n    while i <= (k as f64).sqrt()\
    \ as isize {\n        if k % i == 0 {\n            largest_prime = i;\n      \
    \      k /= i;\n        } else {\n            i += 2;\n        }\n    }\n    if\
    \ k > 2 {\n        largest_prime = k;\n    }\n    largest_prime\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n\
    \    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     n /= i;\n            largest = i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    if n > largest {\n        largest = n;\n    }\n    largest\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmparchfv3z.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut n = n;\n    while n > 1 {\n        if n % f == 0 {\n            n /= f;\n\
    \        } else {\n            f += 1;\n        }\n    }\n    f\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 0;\n\
    \    let mut n = n;\n    while n % 2 == 0 {\n        largest = 2;\n        n /=\
    \ 2;\n    }\n    let mut p = 3;\n    while n > 1 {\n        while n % p == 0 {\n\
    \            largest = p;\n            n /= p;\n        }\n        p += 2;\n \
    \   }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    factor_sum(n)\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factor_sum` in this scope\n --> /tmp/tmp65pn01wa.rs:7:5\n\
    \  |\n7 |     factor_sum(n)\n  |     ^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut prime = 2;\n    let mut largest_prime = prime;\n    while n > 1 {\n    \
    \    if n % prime == 0 {\n            largest_prime = prime;\n            n /=\
    \ prime;\n            while n % prime == 0 {\n                n /= prime;\n  \
    \          }\n        }\n        prime += 1;\n    }\n    largest_prime\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors\
    \ = get_prime_factors(n);\n    prime_factors.sort();\n    prime_factors.last().unwrap().clone()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_prime_factors` in this scope\n\
    \ --> /tmp/tmpkur5__c3.rs:7:29\n  |\n7 |     let mut prime_factors = get_prime_factors(n);\n\
    \  |                             ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 0;\n    let mut n = n;\n    for prime in sieve_of_eratosthenes(n) {\n    \
    \    while n % prime == 0 {\n            largest_prime_factor = prime;\n     \
    \       n /= prime;\n        }\n    }\n    largest_prime_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sieve_of_eratosthenes` in this scope\n\
    \ --> /tmp/tmp3vvm7938.rs:9:18\n  |\n9 |     for prime in sieve_of_eratosthenes(n)\
    \ {\n  |                  ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let\
    \ mut i = 2;\n    let mut ret = 0;\n    while i * i <= x {\n        if x % i ==\
    \ 0 {\n            ret = i;\n            x /= i;\n        } else {\n         \
    \   i += 1;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmppuk6t97p.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|&x|\
    \ x * x <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let limit = (n as f64).sqrt()\
    \ as isize;\n    let mut m = 2;\n    let mut factors = vec![];\n    while m <=\
    \ limit {\n        if n % m == 0 {\n            factors.push(m);\n           \
    \ n /= m;\n        } else {\n            m += 1;\n        }\n    }\n    factors.push(n);\n\
    \    *factors.iter().max().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmprv9v5dzv.rs:13:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \           n /= m;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut k = n;\n    while i * i <= k {\n        if k % i == 0 {\n            k /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    k\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut max_factor = 1;\n    let mut factor = 2;\n    while n > 1 {\n        while\
    \ n % factor == 0 {\n            max_factor = factor;\n            n /= factor;\n\
    \        }\n        factor += 1;\n    }\n    max_factor\n}\n\nfn main() {\n  \
    \  let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 2;\n    while n % p == 0 {\n        n /= p;\n    }\n    let mut p =\
    \ 3;\n    while n > 1 {\n        while n % p == 0 {\n            n /= p;\n   \
    \     }\n        p += 2;\n    }\n    p - 2\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut candidate = 2;\n\
    \    let mut largest_factor = 1;\n    while candidate <= n {\n        if n % candidate\
    \ == 0 {\n            largest_factor = candidate;\n            while n % candidate\
    \ == 0 {\n                n /= candidate;\n            }\n        }\n        candidate\
    \ += 1;\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpll2m9a67.rs:13:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \               n /= candidate;\n   |                 ^^^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut d = 2;\n    while n > 1 {\n        while n % d == 0 {\n            n /=\
    \ d;\n        }\n        d += 1;\n    }\n    d - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..).filter(|&i| n %\
    \ i == 0).find(|&i| is_prime(i)).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpxkl44rzk.rs:7:45\n\
    \  |\n7 |     (2..).filter(|&i| n % i == 0).find(|&i| is_prime(i)).unwrap()\n\
    \  |                                             ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut cur = 2;\n  \
    \  let mut largest = 1;\n    while cur * cur <= n {\n        if n % cur == 0 {\n\
    \            largest = cur;\n            n /= cur;\n        } else {\n       \
    \     cur += 1;\n        }\n    }\n    if n > 1 {\n        n\n    } else {\n \
    \       largest\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpt3alfo0p.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= cur;\n   |             ^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest_prime = 1;\n    while i * i <= n {\n        if n % i == 0 {\n  \
    \          largest_prime = i;\n            n /= i;\n        } else {\n       \
    \     i += 1;\n        }\n    }\n    largest_prime\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfuo4ave6.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (min, max) = (2,\
    \ (n as f64).sqrt() as isize);\n    let factors = (min..max).filter(|&x| n % x\
    \ == 0);\n    let mut primes = factors.filter(|&x| is_prime(x));\n    let mut\
    \ largest = primes.next().unwrap();\n    for p in primes {\n        if p > largest\
    \ {\n            largest = p;\n        }\n    }\n    largest\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp37r_jf7s.rs:9:42\n\
    \  |\n9 |     let mut primes = factors.filter(|&x| is_prime(x));\n  |        \
    \                                  ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    primes_iter().take_while(|&i|\
    \ i <= n).rev().find(|&i| n % i == 0).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `primes_iter` in this scope\n --> /tmp/tmpwz0zl60e.rs:7:5\n\
    \  |\n7 |     primes_iter().take_while(|&i| i <= n).rev().find(|&i| n % i == 0).unwrap()\n\
    \  |     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut remaining = n;\n\
    \    let mut i = 2;\n    while i * i <= remaining {\n        if remaining % i\
    \ == 0 {\n            remaining /= i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    remaining\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut result = n;\n    while result > 1 {\n        if result % factor ==\
    \ 0 {\n            result /= factor;\n        } else {\n            factor +=\
    \ 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976667
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n\
    \    let mut factor = 2;\n    let mut num = n;\n    while num > 1 {\n        if\
    \ num % factor == 0 {\n            largest = factor;\n            num /= factor;\n\
    \            while num % factor == 0 {\n                num /= factor;\n     \
    \       }\n        }\n        factor += 1;\n    }\n    largest\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|&x|\
    \ x <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpg6okg710.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976667
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 0;\n    for i in 2..=(n / 2) {\n        if n % i == 0 && is_prime(i) {\n \
    \           largest_prime_factor = i;\n        }\n    }\n    largest_prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpr5tvssuu.rs:9:26\n\
    \  |\n9 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = prime_factors(n);\n\
    \    *factors.pop().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmp80np9y1_.rs:7:23\n  |\n7 |     let mut factors = prime_factors(n);\n\
    \  |                       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n\n    let max_factor = ((n as f64).sqrt().ceil() as isize)\
    \ + 1;\n    for i in 2..max_factor {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i);\n        }\n    }\n\n    panic!(\"Should have found\
    \ a factor.\");\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpiqd1z8mb.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_prime = 2;\n    while n % 2 == 0 {\n        n /= 2;\n    }\n   \
    \ let mut factor = 3;\n    while n > 1 {\n        while n % factor == 0 {\n  \
    \          n /= factor;\n            largest_prime = factor;\n        }\n    \
    \    factor += 2;\n    }\n    largest_prime\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut prime = 2;\n    while n % prime == 0 {\n        n /= prime;\n    }\n   \
    \ prime += 1;\n    while n > 1 {\n        while n % prime == 0 {\n           \
    \ n /= prime;\n        }\n        prime += 2;\n    }\n    prime - 2\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976667
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime = 1;\n\
    \    let mut remaining = n;\n    for p in primes() {\n        if p > remaining\
    \ {\n            break;\n        }\n        if remaining % p == 0 {\n        \
    \    remaining /= p;\n            prime = p;\n        }\n    }\n    prime\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `primes` in this scope\n --> /tmp/tmpj7yt5gb4.rs:9:14\n\
    \  |\n9 |     for p in primes() {\n  |              ^^^^^^ help: a local variable\
    \ with a similar name exists: `prime`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let upper_bound = isqrt(n);\n\
    \    let mut lpf = n;\n    for p in 2..upper_bound {\n        if is_prime(p) &&\
    \ n % p == 0 {\n            lpf = p;\n        }\n    }\n    lpf\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `isqrt` in this scope\n --> /tmp/tmpjkcq9mdh.rs:7:23\n\
    \  |\n7 |     let upper_bound = isqrt(n);\n  |                       ^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmpjkcq9mdh.rs:10:12\n   |\n10 |         if is_prime(p) &&\
    \ n % p == 0 {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976666
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let\
    \ mut f = 2;\n    while x != 1 {\n        while x % f == 0 {\n            x /=\
    \ f;\n        }\n        f += 1;\n    }\n    f - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976667
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_prime = 2;\n    let mut trial_factor = 2;\n    while n > 1 {\n \
    \       if n % trial_factor == 0 {\n            largest_prime = trial_factor;\n\
    \            n /= trial_factor;\n            while n % trial_factor == 0 {\n \
    \               n /= trial_factor;\n            }\n        }\n        trial_factor\
    \ += 1;\n    }\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976667
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO\n    n\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpjyq4ktky.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976667
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut prime = 2;\n    while n > 1 {\n        if n % prime == 0 {\n           \
    \ n /= prime;\n        } else {\n            prime += 1;\n        }\n    }\n \
    \   prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976665
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    for\
    \ i in 2..n {\n        if n % i == 0 {\n            n /= i;\n            while\
    \ n % i == 0 {\n                n /= i;\n            }\n        }\n    }\n   \
    \ n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpjzpx7rbk.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976667
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (mut n, mut factor)\
    \ = (n, 2);\n    while n > 1 {\n        if n % factor == 0 {\n            n /=\
    \ factor;\n        } else {\n            factor += 1;\n        }\n    }\n    factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976667
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // this function may\
    \ return 2, 3, 5 or 7 if prime number is given.\n    let mut prime = n;\n    while\
    \ prime % 2 == 0 {\n        prime /= 2;\n    }\n    while prime % 3 == 0 {\n \
    \       prime /= 3;\n    }\n    while prime % 5 == 0 {\n        prime /= 5;\n\
    \    }\n    while prime % 7 == 0 {\n        prime /= 7;\n    }\n    if prime >\
    \ 7 {\n        for i in (11..=prime).step_by(2) {\n            while prime % i\
    \ == 0 {\n                prime /= i;\n            }\n        }\n    }\n    prime\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpm9m_1clb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976667
