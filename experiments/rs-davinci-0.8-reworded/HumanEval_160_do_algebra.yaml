name: HumanEval_160_do_algebra
language: rs
prompt: "/// Given two vectors operator, and operand. The first vector has basic algebra\
  \ operations, and \n/// the second vector is a vector of integers. Use the two given\
  \ vectors to build the algebric \n/// expression and return the evaluation of this\
  \ expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction\
  \ ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation\
  \ ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// vector = [2, 3, 4, 5]\n\
  /// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator\
  \ vector is equal to the length of operand vector minus one.\n/// Operand is a vector\
  \ of of non-negative integers.\n/// Operator vector has at least one operator, and\
  \ operand vector has at least two operands.\nfn do_algebra(operator: Vec<String>,\
  \ operand: Vec<isize>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"\
  **\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"\
  +\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\
  //\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"
completions: ["    // Write your code here\n    let mut eval_result = operand[0];\n\
    \    for i in 0..operand.len() - 1 {\n        if operator[i] == \"+\" {\n    \
    \        eval_result += operand[i + 1];\n        } else if operator[i] == \"-\"\
    \ {\n            eval_result -= operand[i + 1];\n        } else if operator[i]\
    \ == \"*\" {\n            eval_result *= operand[i + 1];\n        } else if operator[i]\
    \ == \"//\" {\n            eval_result /= operand[i + 1];\n        } else if operator[i]\
    \ == \"**\" {\n            eval_result = eval_result.pow(operand[i + 1] as u32);\n\
    \        }\n    }\n    eval_result", "    let mut  stack: Vec<isize> = Vec::new();\n\
    \    for (i, op) in operator.iter().enumerate() {\n        match op.as_str() {\n\
    \            \"+\" => {\n                let b = stack.pop().unwrap();\n     \
    \           let a = stack.pop().unwrap();\n                stack.push(a + b);\n\
    \            },\n            \"-\" => {\n                let b = stack.pop().unwrap();\n\
    \                let a = stack.pop().unwrap();\n                stack.push(a -\
    \ b);\n            },\n            \"*\" => {\n                let b = stack.pop().unwrap();\n\
    \                let a = stack.pop().unwrap();\n                stack.push(a *\
    \ b);\n            },\n            \"//\" => {\n                let b = stack.pop().unwrap();\n\
    \                let a = stack.pop().unwrap();\n                stack.push(a /\
    \ b);\n            },\n            \"**\" => {\n                let b = stack.pop().unwrap();\n\
    \                let a = stack.pop().unwrap();\n                stack.push(a.pow(b\
    \ as u32));\n            },\n            _ => (),\n        }\n        stack.push(operand[i+1]);\n\
    \    }\n    stack.pop().unwrap()", "    let mut it = operand.iter();\n    let\
    \ mut result = *it.next().unwrap();\n    for op in operator {\n        let x =\
    \ *it.next().unwrap();\n        match op.as_str() {\n            \"+\" => result\
    \ += x,\n            \"-\" => result -= x,\n            \"*\" => result *= x,\n\
    \            \"//\" => result /= x,\n            \"**\" => result = result.pow(x\
    \ as u32),\n            _ => {}\n        }\n    }\n    result", "    let mut total\
    \ = operand[0];\n    for i in 0..operand.len() - 1 {\n        match operator[i].as_str()\
    \ {\n            \"+\" => total += operand[i + 1],\n            \"-\" => total\
    \ -= operand[i + 1],\n            \"*\" => total *= operand[i + 1],\n        \
    \    \"//\" => total /= operand[i + 1],\n            \"**\" => total = total.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Unknown operator: {}\", operator[i])\n\
    \        }\n    }\n    total", "    operand.iter().zip(operator.iter()).fold(\n\
    \        operand[0],\n        |acc, (operand, op)| match op.as_str() {\n     \
    \       \"+\" => acc + operand,\n            \"-\" => acc - operand,\n       \
    \     \"*\" => acc * operand,\n            \"//\" => acc / operand,\n        \
    \    \"**\" => acc.pow(*operand as u32),\n            _ => panic!(\"Unknown operator\"\
    ),\n        },\n    )", "    let operator: Vec<char> = operator.iter().map(|s|\
    \ s.chars().next().unwrap()).collect();\n    let mut stack: Vec<isize> = Vec::new();\n\
    \    let mut operand_iter = operand.iter();\n    let mut op_iter = operator.iter();\n\
    \    let mut curr_operand = operand_iter.next().unwrap();\n    while let Some(op)\
    \ = op_iter.next() {\n        match op {\n            '+' => stack.push(*curr_operand),\n\
    \            '-' => stack.push(-*curr_operand),\n            '*' => stack.push(stack.pop().unwrap()\
    \ * *curr_operand),\n            '//' => stack.push(stack.pop().unwrap() / *curr_operand),\n\
    \            '^' => stack.push(stack.pop().unwrap().pow(*curr_operand as u32)),\n\
    \            _ => unreachable!(),\n        }\n        curr_operand = operand_iter.next().unwrap();\n\
    \    }\n    stack.push(*curr_operand);\n    stack.iter().sum()", "    let mut\
    \ result = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => (),\n        }\n    }\n    result", "  if operand.len()\
    \ == 0 { return 0; }\n  if operand.len() == 1 { return operand[0]; }\n  let mut\
    \ result = operand[0];\n  for i in 0..operator.len() {\n    let oper = operator[i].clone();\n\
    \    let next_val = operand[i+1];\n    match oper.as_str() {\n      \"+\" => result\
    \ += next_val,\n      \"-\" => result -= next_val,\n      \"*\" => result *= next_val,\n\
    \      \"//\" => result /= next_val,\n      \"**\" => result = result.pow(next_val\
    \ as u32),\n      _ => {},\n    }\n  }\n  result", "    if operator.len() != operand.len()\
    \ - 1 {\n        return 0;\n    }\n    let mut stack: Vec<isize> = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < operand.len() {\n     \
    \   stack.push(operand[i]);\n        if j < operator.len() {\n            match\
    \ operator[j].as_str() {\n                \"+\" => {\n                    stack.push(stack.pop().unwrap()\
    \ + stack.pop().unwrap());\n                }\n                \"-\" => {\n  \
    \                  let v1 = stack.pop().unwrap();\n                    let v2\
    \ = stack.pop().unwrap();\n                    stack.push(v2 - v1);\n        \
    \        }\n                \"*\" => {\n                    stack.push(stack.pop().unwrap()\
    \ * stack.pop().unwrap());\n                }\n                \"//\" => {\n \
    \                   let v1 = stack.pop().unwrap();\n                    let v2\
    \ = stack.pop().unwrap();\n                    stack.push(v2 / v1);\n        \
    \        }\n                \"**\" => {\n                    let v1 = stack.pop().unwrap();\n\
    \                    let v2 = stack.pop().unwrap();\n                    stack.push(v2.pow(v1\
    \ as u32));\n                }\n                _ => {}\n            }\n     \
    \       j += 1;\n        }\n        i += 1;\n    }\n    stack.pop().unwrap()",
  "    let mut output = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => output += operand[i + 1],\n   \
    \         \"-\" => output -= operand[i + 1],\n            \"*\" => output *= operand[i\
    \ + 1],\n            \"//\" => output /= operand[i + 1],\n            \"**\" =>\
    \ output = output.pow(operand[i + 1] as u32),\n            _ => panic!(\"unexpected\
    \ operator\"),\n        }\n    }\n    output", "    // check if the operator vector\
    \ is one smaller than the operand vector\n    assert_eq!(operator.len(), operand.len()\
    \ - 1);\n    // check if the operator vector has at least one operator\n    assert!(operator.len()\
    \ > 0);\n    // check if the operand vector has at least two operands\n    assert!(operand.len()\
    \ > 1);\n    // check if the operand vector has all non-negative integers\n  \
    \  assert!(operand.iter().all(|&num| num >= 0));\n\n    let mut result = operand[0];\n\
    \    for (idx, op) in operator.iter().enumerate() {\n        let left = operand[idx];\n\
    \        let right = operand[idx + 1];\n        match op.as_str() {\n        \
    \    \"+\" => result = left + right,\n            \"-\" => result = left - right,\n\
    \            \"*\" => result = left * right,\n            \"//\" => result = left\
    \ / right,\n            \"**\" => result = left.pow(right as u32),\n         \
    \   _ => panic!(\"Wrong operator format!\"),\n        }\n    }\n    result", " \
    \   let mut index = 0;\n    let mut operators = Vec::new();\n    let mut operands\
    \ = Vec::new();\n    for op in &operator {\n        if op == \"+\" {\n       \
    \     operators.push(1);\n        } else if op == \"-\" {\n            operators.push(2);\n\
    \        } else if op == \"*\" {\n            operators.push(3);\n        } else\
    \ if op == \"//\" {\n            operators.push(4);\n        } else if op == \"\
    **\" {\n            operators.push(5);\n        }\n    }\n    for num in &operand\
    \ {\n        operands.push(*num);\n    }\n    for op in &operators {\n       \
    \ if *op == 5 {\n            // **\n            let a = operands[index];\n   \
    \         let b = operands[index + 1];\n            operands[index] = a.pow(b\
    \ as u32);\n            operands.remove(index + 1);\n            operators.remove(index);\n\
    \        } else if *op == 4 {\n            // //\n            let a = operands[index];\n\
    \            let b = operands[index + 1];\n            operands[index] = a / b;\n\
    \            operands.remove(index + 1);\n            operators.remove(index);\n\
    \        } else if *op == 3 {\n            // *\n            let a = operands[index];\n\
    \            let b = operands[index + 1];\n            operands[index] = a * b;\n\
    \            operands.remove(index + 1);\n            operators.remove(index);\n\
    \        }\n    }\n    for op in &operators {\n        if *op == 2 {\n       \
    \     // -\n            let a = operands[index];\n            let b = operands[index\
    \ + 1];\n            operands[index] = a - b;\n            operands.remove(index\
    \ + 1);\n            operators.remove(index);\n        } else if *op == 1 {\n\
    \            // +\n            let a = operands[index];\n            let b = operands[index\
    \ + 1];\n            operands[index] = a + b;\n            operands.remove(index\
    \ + 1);\n            operators.", "    if operator.len() == 0 {\n        return\
    \ operand[0];\n    }\n    let mut idx = 0;\n    let mut stack = vec![];\n    for\
    \ op in operator {\n        match op.as_str() {\n            \"+\" => {\n    \
    \            let l = stack.pop().unwrap();\n                let r = operand[idx\
    \ + 1];\n                stack.push(l + r);\n            }\n            \"-\"\
    \ => {\n                let l = stack.pop().unwrap();\n                let r =\
    \ operand[idx + 1];\n                stack.push(l - r);\n            }\n     \
    \       \"*\" => {\n                let l = stack.pop().unwrap();\n          \
    \      let r = operand[idx + 1];\n                stack.push(l * r);\n       \
    \     }\n            \"/\" => {\n                let l = stack.pop().unwrap();\n\
    \                let r = operand[idx + 1];\n                stack.push(l / r);\n\
    \            }\n            \"^\" => {\n                let l = stack.pop().unwrap();\n\
    \                let r = operand[idx + 1];\n                stack.push(l.pow(r\
    \ as u32));\n            }\n            _ => panic!(\"Invalid operator!\"),\n\
    \        }\n        idx += 1;\n    }\n    stack.pop().unwrap()", "    let mut\
    \ op = operator.iter();\n    let mut opd = operand.iter();\n    let mut result\
    \ = opd.next().unwrap();\n    for (op, opd) in op.zip(opd) {\n        let mut\
    \ opd = *opd;\n        if op == &\"//\" {\n            opd = opd.floor();\n  \
    \      }\n        result = match op.as_str() {\n            \"+\" => result +\
    \ opd,\n            \"-\" => result - opd,\n            \"*\" => result * opd,\n\
    \            \"//\" => result / opd,\n            \"**\" => result.pow(opd as\
    \ u32),\n            _ => result,\n        };\n    }\n    result", "    let mut\
    \ operand = operand;\n    let mut result = operand.remove(0);\n    for (op, num)\
    \ in operator.iter().zip(operand) {\n        match op.as_str() {\n           \
    \ \"+\" => result += num,\n            \"-\" => result -= num,\n            \"\
    *\" => result *= num,\n            \"//\" => result /= num,\n            \"**\"\
    \ => result = result.pow(*num as u32),\n            _ => panic!(\"unknown operator:\
    \ {}\", op),\n        }\n    }\n    result", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => {}\n        }\n    }\n    result", "    let\
    \ mut x = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => x += operand[i + 1],\n            \"-\" => x -= operand[i\
    \ + 1],\n            \"*\" => x *= operand[i + 1],\n            \"//\" => x /=\
    \ operand[i + 1],\n            \"**\" => x = x.pow(operand[i + 1] as u32),\n \
    \           _ => (),\n        }\n    }\n    x", "  let mut stack: Vec<isize> =\
    \ Vec::new();\n  let mut idx = 0;\n  for op in operator {\n    stack.push(operand[idx]);\n\
    \    match op.as_str() {\n      \"+\" => {\n        let a = stack.pop().unwrap();\n\
    \        let b = stack.pop().unwrap();\n        stack.push(a + b);\n      },\n\
    \      \"-\" => {\n        let a = stack.pop().unwrap();\n        let b = stack.pop().unwrap();\n\
    \        stack.push(b - a);\n      },\n      \"*\" => {\n        let a = stack.pop().unwrap();\n\
    \        let b = stack.pop().unwrap();\n        stack.push(a * b);\n      },\n\
    \      \"//\" => {\n        let a = stack.pop().unwrap();\n        let b = stack.pop().unwrap();\n\
    \        stack.push(b / a);\n      },\n      \"**\" => {\n        let a = stack.pop().unwrap();\n\
    \        let b = stack.pop().unwrap();\n        stack.push(b.pow(a as u32));\n\
    \      },\n      _ => panic!(\"Invalid operator!\"),\n    }\n    idx += 1;\n \
    \ }\n  stack.pop().unwrap()", "    let op_iter = operator.iter();\n    let mut\
    \ operand_iter = operand.iter();\n    let a = *operand_iter.next().unwrap();\n\
    \    let b = *operand_iter.next().unwrap();\n    let mut result = do_op(a, b,\
    \ op_iter.next().unwrap());\n    for op in op_iter {\n        result = do_op(result,\
    \ *operand_iter.next().unwrap(), op);\n    }\n    result", "    let mut operand\
    \ = operand;\n    for op in operator {\n        match op.as_str() {\n        \
    \    \"+\" => {\n                let operand_0 = operand.remove(0);\n        \
    \        let operand_1 = operand.remove(0);\n                operand.insert(0,\
    \ operand_0 + operand_1);\n            }\n            \"-\" => {\n           \
    \     let operand_0 = operand.remove(0);\n                let operand_1 = operand.remove(0);\n\
    \                operand.insert(0, operand_0 - operand_1);\n            }\n  \
    \          \"*\" => {\n                let operand_0 = operand.remove(0);\n  \
    \              let operand_1 = operand.remove(0);\n                operand.insert(0,\
    \ operand_0 * operand_1);\n            }\n            \"//\" => {\n          \
    \      let operand_0 = operand.remove(0);\n                let operand_1 = operand.remove(0);\n\
    \                operand.insert(0, operand_0 / operand_1);\n            }\n  \
    \          \"**\" => {\n                let operand_0 = operand.remove(0);\n \
    \               let operand_1 = operand.remove(0);\n                operand.insert(0,\
    \ operand_0.pow(operand_1 as u32));\n            }\n            _ => panic!(\"\
    invalid operator\"),\n        }\n    }\n    return operand[0];", "    // println!(\"\
    operator: {:?}\", operator);\n    // println!(\"operand: {:?}\", operand);\n \
    \   let mut operand = operand;\n    let mut acc: isize = operand.remove(0);\n\
    \    for (op, v) in operator.iter().zip(operand.iter()) {\n        match op.as_str()\
    \ {\n            \"+\" => acc += v,\n            \"-\" => acc -= v,\n        \
    \    \"*\" => acc *= v,\n            \"//\" => acc /= v,\n            \"**\" =>\
    \ acc = acc.pow(*v as u32),\n            _ => (),\n        }\n    }\n    acc",
  "    let mut result = operand[0];\n    for (op, operand) in operator.iter().zip(operand.iter().skip(1))\
    \ {\n        if op == \"+\" {\n            result += operand;\n        } else\
    \ if op == \"-\" {\n            result -= operand;\n        } else if op == \"\
    *\" {\n            result *= operand;\n        } else if op == \"//\" {\n    \
    \        result /= operand;\n        } else if op == \"**\" {\n            result\
    \ = result.pow(*operand as u32);\n        }\n    }\n    result", "    let mut\
    \ ops = operator.iter().map(|c| match c.as_str() {\n        \"+\" => Some(AddOp),\n\
    \        \"-\" => Some(SubOp),\n        \"*\" => Some(MulOp),\n        \"/\" =>\
    \ Some(DivOp),\n        \"^\" => Some(ExpOp),\n        _ => None,\n    });\n \
    \   let mut acc = operand[0];\n    for op in ops {\n        acc = match op {\n\
    \            Some(AddOp) => acc + operand[1],\n            Some(SubOp) => acc\
    \ - operand[1],\n            Some(MulOp) => acc * operand[1],\n            Some(DivOp)\
    \ => acc / operand[1],\n            Some(ExpOp) => acc.pow(operand[1] as u32),\n\
    \            None => panic!(\"No such operation!\"),\n        };\n    }\n    acc",
  "    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"\
    Unknown operator: {}\", op),\n        }\n    }\n    result", "    let mut result\
    \ = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => (),\n        }\n    }\n    result", "    match\
    \ operator.first() {\n        Some(item) => {\n            let new_operand = vec![operand[0],\
    \ operand[1]];\n            if item == &\"+\".to_string() {\n                do_algebra(\n\
    \                    operator[1..].to_vec(),\n                    [operand[2..].to_vec(),\
    \ vec![operand[0] + operand[1]]].concat(),\n                )\n            } else\
    \ if item == &\"-\".to_string() {\n                do_algebra(\n             \
    \       operator[1..].to_vec(),\n                    [operand[2..].to_vec(), vec![operand[0]\
    \ - operand[1]]].concat(),\n                )\n            } else if item == &\"\
    *\".to_string() {\n                do_algebra(\n                    operator[1..].to_vec(),\n\
    \                    [operand[2..].to_vec(), vec![operand[0] * operand[1]]].concat(),\n\
    \                )\n            } else if item == &\"//\".to_string() {\n    \
    \            do_algebra(\n                    operator[1..].to_vec(),\n      \
    \              [operand[2..].to_vec(), vec![operand[0] / operand[1]]].concat(),\n\
    \                )\n            } else if item == &\"**\".to_string() {\n    \
    \            do_algebra(\n                    operator[1..].to_vec(),\n      \
    \              [operand[2..].to_vec(), vec![operand[0].pow(operand[1] as u32)]].concat(),\n\
    \                )\n            } else {\n                0\n            }\n \
    \       }\n        None => operand[0],\n    }", "    let operand: Vec<isize> =\
    \ operand.iter().scan(None, |last, &curr| {\n        let new = *last.unwrap_or(&0)\
    \ + curr;\n        *last = Some(new);\n        Some(new)\n    }).collect();\n\
    \    // println!(\"{:?}\", operand);\n    (0..operator.len()).fold(operand[0],\
    \ |acc, i| {\n        let op = &operator[i];\n        let left = operand[i];\n\
    \        let right = operand[i + 1];\n        match op.as_str() {\n          \
    \  \"+\" => acc + right,\n            \"-\" => acc - right,\n            \"*\"\
    \ => acc * right,\n            \"//\" => acc / right,\n            \"**\" => acc.pow(right\
    \ as u32),\n            _ => unreachable!()\n        }\n    })", "    let mut\
    \ ans = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => ans += operand[i + 1],\n            \"-\" => ans -=\
    \ operand[i + 1],\n            \"*\" => ans *= operand[i + 1],\n            \"\
    //\" => ans /= operand[i + 1],\n            \"**\" => ans = ans.pow(operand[i\
    \ + 1] as u32),\n            _ => return 0,\n        }\n    }\n    ans", "   \
    \ let mut curr_operand = operand[0];\n    for i in 1..operand.len() {\n      \
    \  match operator[i - 1].as_str() {\n            \"+\" => curr_operand += operand[i],\n\
    \            \"-\" => curr_operand -= operand[i],\n            \"*\" => curr_operand\
    \ *= operand[i],\n            \"//\" => curr_operand /= operand[i],\n        \
    \    \"**\" => curr_operand = curr_operand.pow(operand[i] as u32),\n         \
    \   _ => panic!(\"Unexpected operator\"),\n        }\n    }\n    curr_operand",
  "    if operand.len() < 2 { return 0; }\n    let mut _operand = operand.to_vec();\n\
    \    let mut stack = vec![];\n    for op in operator {\n        match op.as_str()\
    \ {\n            \"+\" => {\n                let a = _operand.pop().unwrap();\n\
    \                let b = _operand.pop().unwrap();\n                _operand.push(a\
    \ + b);\n            },\n            \"-\" => {\n                let a = _operand.pop().unwrap();\n\
    \                let b = _operand.pop().unwrap();\n                _operand.push(b\
    \ - a);\n            },\n            \"*\" => {\n                let a = _operand.pop().unwrap();\n\
    \                let b = _operand.pop().unwrap();\n                _operand.push(a\
    \ * b);\n            },\n            \"//\" => {\n                let a = _operand.pop().unwrap();\n\
    \                let b = _operand.pop().unwrap();\n                _operand.push(b\
    \ / a);\n            },\n            \"**\" => {\n                let a = _operand.pop().unwrap();\n\
    \                let b = _operand.pop().unwrap();\n                _operand.push(b.pow(a\
    \ as u32));\n            },\n            \"(\" => {\n                stack.push(_operand.pop().unwrap());\n\
    \            },\n            \")\" => {\n                let a = _operand.pop().unwrap();\n\
    \                let b = stack.pop().unwrap();\n                _operand.push(a\
    \ + b);\n            },\n            _ => { }\n        }\n    }\n    return _operand.pop().unwrap();",
  "    let mut result = operand[0];\n    for (i, &o) in operand.iter().enumerate().skip(1)\
    \ {\n        match &operator[i - 1][..] {\n            \"+\" => result += o,\n\
    \            \"-\" => result -= o,\n            \"*\" => result *= o,\n      \
    \      \"//\" => result /= o,\n            \"**\" => result = result.pow(o as\
    \ u32),\n            _ => panic!(\"Unknown operator\"),\n        }\n    }\n  \
    \  result", "    let mut operand = operand;\n    let mut operator = operator;\n\
    \    let mut result = operand.remove(0);\n    loop {\n        let operand_current\
    \ = operand.remove(0);\n        let operator_current = operator.remove(0);\n \
    \       match operator_current.as_str() {\n            \"+\" => result += operand_current,\n\
    \            \"-\" => result -= operand_current,\n            \"*\" => result\
    \ *= operand_current,\n            \"//\" => result /= operand_current,\n    \
    \        \"**\" => result = result.pow(operand_current as u32),\n            _\
    \ => panic!(\"Unknown operator {}\", operator_current),\n        }\n        if\
    \ operator.is_empty() {\n            break;\n        }\n    }\n    result", " \
    \   // TODO: Your code here\n    0", "    let mut stack: Vec<isize> = Vec::new();\n\
    \    let mut operands: Vec<isize> = operand.clone();\n    let mut operators: Vec<String>\
    \ = operator.clone();\n    while operands.len() > 1 {\n        stack.push(operands.pop().unwrap());\n\
    \        let op = operators.pop().unwrap();\n        let left = operands.pop().unwrap();\n\
    \        let right = stack.pop().unwrap();\n        let result = evaluate(left,\
    \ right, op);\n        operands.push(result);\n    }\n    operands.pop().unwrap()",
  "    let mut _operand = operand.clone();\n    for (op, i) in operator.iter().zip(0..)\
    \ {\n        let left = _operand[i];\n        let right = _operand[i + 1];\n \
    \       _operand[i + 1] = match op.as_str() {\n            \"+\" => left + right,\n\
    \            \"-\" => left - right,\n            \"*\" => left * right,\n    \
    \        \"//\" => left / right,\n            \"**\" => left.pow(right as u32),\n\
    \            _ => panic!(\"Unknown operator\"),\n        };\n    }\n    _operand[operand.len()\
    \ - 1]", "    let mut iter = operand.iter();\n    iter.next()\n        .and_then(|initial|\
    \ {\n            operator\n                .iter()\n                .zip(iter)\n\
    \                .fold(Some(*initial), |acc, (op, operand)| {\n              \
    \      acc.and_then(|value| match op.as_str() {\n                        \"+\"\
    \ => Some(value + operand),\n                        \"-\" => Some(value - operand),\n\
    \                        \"*\" => Some(value * operand),\n                   \
    \     \"//\" => Some(value / operand),\n                        \"**\" => Some(value.pow(*operand\
    \ as u32)),\n                        _ => None,\n                    })\n    \
    \            })\n        })\n        .unwrap_or(0)", "    let mut s = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => s += operand[i + 1],\n            \"-\" => s -= operand[i +\
    \ 1],\n            \"*\" => s *= operand[i + 1],\n            \"//\" => s /= operand[i\
    \ + 1],\n            \"**\" => s = s.pow(operand[i + 1] as u32),\n           \
    \ _ => {}\n        }\n    }\n    s", "    let mut stack: Vec<isize> = Vec::new();\n\
    \    for i in 0..operand.len() {\n        match operator[i].as_str() {\n     \
    \       \"+\" => stack.push(stack.pop().unwrap() + operand[i]),\n            \"\
    -\" => stack.push(stack.pop().unwrap() - operand[i]),\n            \"*\" => stack.push(stack.pop().unwrap()\
    \ * operand[i]),\n            \"//\" => stack.push(stack.pop().unwrap() / operand[i]),\n\
    \            \"**\" => stack.push(stack.pop().unwrap().pow(operand[i] as u32)),\n\
    \            _ => panic!(\"Invalid operator\")\n        }\n    }\n    stack.pop().unwrap()",
  "    let mut stack: Vec<isize> = Vec::new();\n    let mut eval_stack: Vec<isize>\
    \ = Vec::new();\n    for x in operand {\n        stack.push(x);\n    }\n    for\
    \ x in operator {\n        if x == \"+\" {\n            let a = stack.pop().unwrap();\n\
    \            let b = stack.pop().unwrap();\n            eval_stack.push(a + b);\n\
    \        } else if x == \"-\" {\n            let a = stack.pop().unwrap();\n \
    \           let b = stack.pop().unwrap();\n            eval_stack.push(b - a);\n\
    \        } else if x == \"*\" {\n            let a = stack.pop().unwrap();\n \
    \           let b = stack.pop().unwrap();\n            eval_stack.push(a * b);\n\
    \        } else if x == \"//\" {\n            let a = stack.pop().unwrap();\n\
    \            let b = stack.pop().unwrap();\n            eval_stack.push(b / a);\n\
    \        } else if x == \"**\" {\n            let a = stack.pop().unwrap();\n\
    \            let b = stack.pop().unwrap();\n            eval_stack.push(b.pow(a\
    \ as u32));\n        }\n    }\n    eval_stack.pop().unwrap()", "    assert!(operator.len()\
    \ == operand.len() - 1);\n    assert!(operator.len() >= 1);\n    assert!(operand.len()\
    \ >= 2);\n    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"\
    Invalid operator {}\", op),\n        }\n    }\n    result", "    let mut stack:\
    \ Vec<isize> = vec![];\n    stack.push(operand[0]);\n    let n = operand.len();\n\
    \    for i in 1..n {\n        match operator[i - 1].as_str() {\n            \"\
    +\" => stack.push(stack.pop().unwrap() + operand[i]),\n            \"-\" => stack.push(stack.pop().unwrap()\
    \ - operand[i]),\n            \"*\" => stack.push(stack.pop().unwrap() * operand[i]),\n\
    \            \"//\" => stack.push(stack.pop().unwrap() / operand[i]),\n      \
    \      \"**\" => stack.push(stack.pop().unwrap().pow(operand[i] as u32)),\n  \
    \          _ => panic!(\"Unknown operator\"),\n        }\n    }\n    stack.pop().unwrap()",
  "  if operand.len() < 2 {\n    return 0;\n  }\n  let mut result = operand[0];\n\
    \  for i in 0..operator.len() {\n    match operator[i].as_str() {\n      \"+\"\
    \ => result += operand[i + 1],\n      \"-\" => result -= operand[i + 1],\n   \
    \   \"*\" => result *= operand[i + 1],\n      \"//\" => result /= operand[i +\
    \ 1],\n      \"**\" => result = result.pow(operand[i + 1] as u32),\n      _ =>\
    \ (),\n    }\n  }\n  result", "    let mut stack: Vec<isize> = Vec::new();\n \
    \   for (i, op) in operator.iter().enumerate() {\n        let num = match op.as_str()\
    \ {\n            \"+\" => operand[i] + operand[i + 1],\n            \"-\" => operand[i]\
    \ - operand[i + 1],\n            \"*\" => operand[i] * operand[i + 1],\n     \
    \       \"//\" => operand[i] / operand[i + 1],\n            \"**\" => operand[i].pow(operand[i\
    \ + 1] as u32),\n            _ => operand[i],\n        };\n        stack.push(num);\n\
    \    }\n    stack.pop().unwrap()", "    operand.iter().skip(1).zip(operator).fold(operand[0],\
    \ |acc, (&o, &ref op)| {\n        match op.as_ref() {\n            \"+\" => acc\
    \ + o,\n            \"-\" => acc - o,\n            \"*\" => acc * o,\n       \
    \     \"//\" => acc / o,\n            \"**\" => acc.pow(o as u32),\n         \
    \   _ => panic!(\"Unknown operator!\"),\n        }\n    })", "    // Write your\
    \ code here\n    let mut stack = Vec::new();\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        if op == \"//\" {\n            let op2 = stack.pop().unwrap();\n\
    \            let op1 = stack.pop().unwrap();\n            stack.push(op1 / op2);\n\
    \        } else if op == \"**\" {\n            let op2 = stack.pop().unwrap();\n\
    \            let op1 = stack.pop().unwrap();\n            stack.push(op1.pow(op2\
    \ as u32));\n        } else {\n            let op1 = operand[i];\n           \
    \ let op2 = operand[i + 1];\n            stack.push(match op.as_str() {\n    \
    \            \"+\" => op1 + op2,\n                \"-\" => op1 - op2,\n      \
    \          \"*\" => op1 * op2,\n                _ => 0,\n            });\n   \
    \     }\n    }\n    stack.pop().unwrap()", "    if operator.len() != operand.len()\
    \ - 1 {\n        panic!(\"operator vector is wrong length.\");\n    }\n    if\
    \ operand.len() < 2 {\n        panic!(\"operand vector is too short.\");\n   \
    \ }\n    let mut result = operand[0];\n    for i in 0..operator.len() {\n    \
    \    match operator[i].as_ref() {\n            \"+\" => result += operand[i +\
    \ 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" => result\
    \ *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n      \
    \      \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ =>\
    \ panic!(\"Invalid operator: {}\", operator[i]),\n        }\n    }\n    result",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        let\
    \ operator_ = &operator[i];\n        if operator_ == \"+\" {\n            result\
    \ += operand[i + 1];\n        } else if operator_ == \"-\" {\n            result\
    \ -= operand[i + 1];\n        } else if operator_ == \"*\" {\n            result\
    \ *= operand[i + 1];\n        } else if operator_ == \"//\" {\n            result\
    \ /= operand[i + 1];\n        } else if operator_ == \"**\" {\n            result\
    \ = result.pow(operand[i + 1] as u32);\n        }\n    }\n    result", "    let\
    \ mut i = 0;\n    let mut stack = vec![];\n    while i < operand.len() {\n   \
    \     stack.push(operand[i]);\n        if i != 0 {\n            let op = operator[i\
    \ - 1].as_str();\n            let b = stack.pop().unwrap();\n            let a\
    \ = stack.pop().unwrap();\n            let c = match op {\n                \"\
    +\" => a + b,\n                \"-\" => a - b,\n                \"*\" => a * b,\n\
    \                \"//\" => a / b,\n                \"**\" => a.pow(b as u32),\n\
    \                _ => panic!(\"Unknow operation: {}\", op),\n            };\n\
    \            stack.push(c);\n        }\n        i += 1;\n    }\n    stack.pop().unwrap()",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        let\
    \ tmp = match operator[i].as_str() {\n            \"+\" => result + operand[i\
    \ + 1],\n            \"-\" => result - operand[i + 1],\n            \"*\" => result\
    \ * operand[i + 1],\n            \"//\" => result / operand[i + 1],\n        \
    \    \"**\" => result.pow(operand[i + 1] as u32),\n            _ => 0,\n     \
    \   };\n        result = tmp;\n    }\n    result", "    let mut result = operand[0];\n\
    \    for (i, op) in operator.iter().enumerate() {\n        result = match op.as_str()\
    \ {\n            \"+\" => result + operand[i + 1],\n            \"-\" => result\
    \ - operand[i + 1],\n            \"*\" => result * operand[i + 1],\n         \
    \   \"//\" => result / operand[i + 1],\n            \"**\" => result.pow(operand[i\
    \ + 1] as u32),\n            _ => 0,\n        }\n    }\n    result", "    if operator.len()\
    \ != operand.len() - 1 {\n        panic!(\"Incorrect operator size\");\n    }\n\
    \    let mut result = 0;\n    for i in 0..operator.len() {\n        if i == 0\
    \ {\n            result = match operator[i].as_ref() {\n                \"+\"\
    \ => operand[i] + operand[i + 1],\n                \"-\" => operand[i] - operand[i\
    \ + 1],\n                \"*\" => operand[i] * operand[i + 1],\n             \
    \   \"//\" => operand[i] / operand[i + 1],\n                \"**\" => operand[i].pow(operand[i\
    \ + 1] as u32),\n                _ => panic!(\"Unknown operator\"),\n        \
    \    };\n        } else {\n            result = match operator[i].as_ref() {\n\
    \                \"+\" => result + operand[i + 1],\n                \"-\" => result\
    \ - operand[i + 1],\n                \"*\" => result * operand[i + 1],\n     \
    \           \"//\" => result / operand[i + 1],\n                \"**\" => result.pow(operand[i\
    \ + 1] as u32),\n                _ => panic!(\"Unknown operator\"),\n        \
    \    };\n        }\n    }\n    result", "    let mut operator_iter = operator.iter();\n\
    \    let mut operand_iter = operand.iter();\n    let first_operand = operand_iter.next().unwrap();\n\
    \    let mut result = *first_operand;\n    while let Some(opt) = operator_iter.next()\
    \ {\n        let operand = operand_iter.next().unwrap();\n        result = match\
    \ opt.as_str() {\n            \"+\" => result + operand,\n            \"-\" =>\
    \ result - operand,\n            \"*\" => result * operand,\n            \"//\"\
    \ => result / operand,\n            \"**\" => result.pow(*operand as u32),\n \
    \           _ => panic!(\"Unknown operation {}\", opt),\n        }\n    }\n  \
    \  result", "    let mut op_iter = operator.iter();\n    let mut num_iter = operand.iter();\n\
    \    let mut result = num_iter.next().unwrap();\n    for op in op_iter {\n   \
    \     match op.as_str() {\n            \"+\" => result += num_iter.next().unwrap(),\n\
    \            \"-\" => result -= num_iter.next().unwrap(),\n            \"*\" =>\
    \ result *= num_iter.next().unwrap(),\n            \"//\" => result /= num_iter.next().unwrap(),\n\
    \            \"**\" => result = result.pow(*num_iter.next().unwrap() as u32),\n\
    \            _ => panic!(\"unknown operator\"),\n        }\n    }\n    result",
  "  let mut last_n = 0;\n  for i in 0..operand.len() {\n    let n = operand[i];\n\
    \    if i == 0 {\n      last_n = n;\n    } else {\n      last_n = last_n.calc(&operator[i\
    \ - 1], n);\n    }\n  }\n  last_n", "    // Write your code here\n    let mut\
    \ result = operand[0];\n    for i in 0..operator.len() {\n        let o = &operator[i];\n\
    \        let l = &operand[i];\n        let r = &operand[i + 1];\n        result\
    \ = match o.as_str() {\n            \"+\" => result + r,\n            \"-\" =>\
    \ result - r,\n            \"*\" => result * r,\n            \"//\" => result\
    \ / r,\n            \"**\" => result.pow(*r as u32),\n            _ => 0,\n  \
    \      };\n    }\n    result", "    // Build a stack of operators\n    let mut\
    \ ops = Vec::new();\n    for op in operator {\n        match op.as_str() {\n \
    \           \"+\" => ops.push(Add),\n            \"-\" => ops.push(Sub),\n   \
    \         \"*\" => ops.push(Mul),\n            \"/\" => ops.push(Div),\n     \
    \       \"^\" => ops.push(Pow),\n            _ => panic!(\"Unknown operator\"\
    ),\n        }\n    }\n\n    // Reverse the operand array and use it to fold the\
    \ operators\n    let mut operand = operand.into_iter().rev().collect::<Vec<isize>>();\n\
    \    ops.into_iter().fold(operand.pop().unwrap(), |acc, op| op.eval(acc, operand.pop().unwrap()))",
  "    let mut answer = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        let current_operand = operand[i + 1];\n        match op.as_str()\
    \ {\n            \"+\" => answer += current_operand,\n            \"-\" => answer\
    \ -= current_operand,\n            \"*\" => answer *= current_operand,\n     \
    \       \"//\" => answer /= current_operand,\n            \"**\" => answer = answer.pow(current_operand\
    \ as u32),\n            _ => (),\n        }\n    }\n    answer", "    let mut\
    \ result = 0;\n    for (i, op) in operator.iter().enumerate() {\n        let next\
    \ = operand[i + 1];\n        match op.as_str() {\n            \"+\" => result\
    \ += next,\n            \"-\" => result -= next,\n            \"*\" => result\
    \ *= next,\n            \"//\" => result /= next,\n            \"**\" => result\
    \ = result.pow(next as u32),\n            _ => panic!(\"Invalid operator!\"),\n\
    \        }\n    }\n    result", "    let mut result = operand[0];\n    for i in\
    \ 0..operator.len() {\n        if operator[i] == \"+\" {\n            result +=\
    \ operand[i + 1];\n        } else if operator[i] == \"-\" {\n            result\
    \ -= operand[i + 1];\n        } else if operator[i] == \"*\" {\n            result\
    \ *= operand[i + 1];\n        } else if operator[i] == \"//\" {\n            result\
    \ /= operand[i + 1];\n        } else if operator[i] == \"**\" {\n            result\
    \ = result.pow(operand[i + 1] as u32);\n        }\n    }\n    result", "    let\
    \ mut result = operand[0];\n    for (op, operand) in operator.iter().zip(operand.iter().skip(1))\
    \ {\n        match op.as_str() {\n            \"+\" => result += operand,\n  \
    \          \"-\" => result -= operand,\n            \"*\" => result *= operand,\n\
    \            \"//\" => result /= operand,\n            \"**\" => result = result.pow(*operand\
    \ as u32),\n            _ => panic!(\"Invalid operator\"),\n        }\n    }\n\
    \    result", "    let mut i = 1;\n    let mut res = operand[0];\n    while i\
    \ < operand.len() {\n        match operator[i - 1].as_str() {\n            \"\
    +\" => res += operand[i],\n            \"-\" => res -= operand[i],\n         \
    \   \"*\" => res *= operand[i],\n            \"//\" => res /= operand[i],\n  \
    \          \"**\" => res = res.pow(operand[i] as u32),\n            _ => res =\
    \ 0,\n        }\n        i += 1;\n    }\n    res", "    let mut result = operand[0];\n\
    \    for (op, opand) in operator.iter().zip(operand.iter().skip(1)) {\n      \
    \  result = match op.as_str() {\n            \"+\" => result + opand,\n      \
    \      \"-\" => result - opand,\n            \"*\" => result * opand,\n      \
    \      \"//\" => result / opand,\n            \"**\" => result.pow(*opand as u32),\n\
    \            _ => panic!(\"Unknown operator: {}\", op),\n        }\n    }\n  \
    \  result", "    let mut stack: Vec<isize> = Vec::new();\n    let mut error =\
    \ false;\n    for (i, op) in operator.iter().enumerate() {\n        if op == \"\
    +\" {\n            stack.push(operand[i] + operand[i + 1]);\n        } else if\
    \ op == \"-\" {\n            stack.push(operand[i] - operand[i + 1]);\n      \
    \  } else if op == \"*\" {\n            stack.push(operand[i] * operand[i + 1]);\n\
    \        } else if op == \"//\" {\n            stack.push(operand[i] / operand[i\
    \ + 1]);\n        } else if op == \"**\" {\n            stack.push(operand[i].pow(operand[i\
    \ + 1] as u32));\n        } else {\n            error = true;\n            break;\n\
    \        }\n    }\n    if error {\n        -1\n    } else {\n        stack.pop().unwrap()\n\
    \    }", "    let mut result = operand[0];\n    for (index, operand) in operand.iter().enumerate().skip(1)\
    \ {\n        if index >= operator.len() {\n            break;\n        }\n   \
    \     match operator[index].as_str() {\n            \"+\" => result += operand,\n\
    \            \"-\" => result -= operand,\n            \"*\" => result *= operand,\n\
    \            \"//\" => result /= operand,\n            \"**\" => result = result.pow(*operand\
    \ as u32),\n            _ => panic!(\"Unexpected operator '{}'\", operator[index]),\n\
    \        }\n    }\n    result", "    let mut operand = operand;\n    for i in\
    \ (0..operator.len()).rev() {\n        let op = &operator[i];\n        let right\
    \ = operand.pop().unwrap();\n        let left = operand.pop().unwrap();\n    \
    \    let result = match op.as_str() {\n            \"+\" => left + right,\n  \
    \          \"-\" => left - right,\n            \"*\" => left * right,\n      \
    \      \"//\" => left / right,\n            \"**\" => left.pow(right as u32),\n\
    \            _ => panic!(\"invalid operation: {}\", op),\n        };\n       \
    \ operand.push(result);\n    }\n    operand[0]", "    let mut result = operand[0];\n\
    \    for (i, op) in operator.iter().enumerate() {\n        let op2 = operand[i\
    \ + 1];\n        match op.as_str() {\n            \"+\" => result += op2,\n  \
    \          \"-\" => result -= op2,\n            \"*\" => result *= op2,\n    \
    \        \"//\" => result /= op2,\n            \"**\" => result = result.pow(op2\
    \ as u32),\n            _ => unreachable!(),\n        }\n    }\n    result", '    return
    eval_postfix(infix_to_postfix(operator, operand));', "    let mut stack: Vec<isize>\
    \ = Vec::new();\n    let mut op = operator.into_iter();\n    let mut oper = operand.into_iter();\n\
    \    let first = oper.next().unwrap();\n    stack.push(first);\n    for v in oper\
    \ {\n        let op = op.next().unwrap();\n        match op.as_str() {\n     \
    \       \"+\" => stack.push(v),\n            \"-\" => stack.push(-v),\n      \
    \      \"*\" => stack.push(stack.pop().unwrap() * v),\n            \"//\" => stack.push(stack.pop().unwrap()\
    \ / v),\n            \"**\" => stack.push(stack.pop().unwrap().pow(v as u32)),\n\
    \            _ => {\n                println!(\"Wrong operator: {}\", op);\n \
    \               return 0;\n            }\n        }\n    }\n    stack.iter().sum()",
  "    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => continue,\n\
    \        }\n    }\n    result", "    let mut result = operand[0];\n    for i in\
    \ 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\"\
    \ => result += operand[i + 1],\n            \"-\" => result -= operand[i + 1],\n\
    \            \"*\" => result *= operand[i + 1],\n            \"//\" => result\
    \ /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i + 1]\
    \ as u32),\n            _ => result = result\n        }\n    }\n    result", " \
    \   operator.iter().zip(operand.iter()).fold(operand[0], |acc, (op, next)| match\
    \ op.as_str() {\n        \"+\" => acc + next,\n        \"-\" => acc - next,\n\
    \        \"*\" => acc * next,\n        \"//\" => acc / next,\n        \"**\" =>\
    \ acc.pow(*next as u32),\n        _ => unreachable!(),\n    })", "    // Write\
    \ your code here\n    let mut it = operand.iter();\n    let mut res = *it.next().unwrap();\n\
    \    for i in operator {\n        let next = *it.next().unwrap();\n        res\
    \ = match i.as_str() {\n            \"+\" => res + next,\n            \"-\" =>\
    \ res - next,\n            \"*\" => res * next,\n            \"//\" => res / next,\n\
    \            \"**\" => res.pow(next as u32),\n            _ => 0,\n        }\n\
    \    }\n    res", "    let mut iter = operand.iter();\n    let mut result = *iter.next().unwrap();\n\
    \    for (op, o) in operator.iter().zip(iter) {\n        result = match op.as_str()\
    \ {\n            \"+\" => result + o,\n            \"-\" => result - o,\n    \
    \        \"*\" => result * o,\n            \"//\" => result / o,\n           \
    \ \"**\" => result.pow(*o as u32),\n            _ => panic!(\"Unknown operator:\
    \ {}\", op),\n        };\n    }\n    result", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => (),\n        }\n    }\n    result", "    let\
    \ mut r: isize = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => r += operand[i + 1],\n        \
    \    \"-\" => r -= operand[i + 1],\n            \"*\" => r *= operand[i + 1],\n\
    \            \"//\" => r /= operand[i + 1],\n            \"**\" => r = r.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Unrecognized operator: {}\", operator[i]),\n\
    \        }\n    }\n    r", "    // Check that operand vector has at least two\
    \ operands.\n    if operand.len() < 2 {\n        panic!(\"Operand vector must\
    \ have at least two operands!\");\n    }\n\n    // Check that operator vector\
    \ has at least one operator.\n    if operator.len() < 1 {\n        panic!(\"Operator\
    \ vector must have at least one operator!\");\n    }\n\n    // Check that the\
    \ length of operator vector is equal to the length of operand vector minus one.\n\
    \    if operator.len() != operand.len() - 1 {\n        panic!(\"Operator vector\
    \ must have a length equal to operand vector length minus one!\");\n    }\n\n\
    \    // Get reference to first operator.\n    let op = &operator[0];\n\n    //\
    \ Get first operand.\n    let a = operand[0];\n\n    // Get second operand.\n\
    \    let b = operand[1];\n\n    // Get remaining operands and operators.\n   \
    \ let remaining_operand = &operand[2..];\n    let remaining_operator = &operator[1..];\n\
    \n    match op.as_str() {\n        \"+\" => return a + do_algebra(remaining_operator.to_vec(),\
    \ remaining_operand.to_vec()),\n        \"-\" => return a - do_algebra(remaining_operator.to_vec(),\
    \ remaining_operand.to_vec()),\n        \"*\" => return a * do_algebra(remaining_operator.to_vec(),\
    \ remaining_operand.to_vec()),\n        \"//\" => return a / do_algebra(remaining_operator.to_vec(),\
    \ remaining_operand.to_vec()),\n        \"**\" => return a.pow(do_algebra(remaining_operator.to_vec(),\
    \ remaining_operand.to_vec()) as u32),\n        _ => panic!(\"Invalid operator!\"\
    ),\n    }", "    let mut value: isize = operand[0];\n    for (i, o) in operator.iter().enumerate()\
    \ {\n        match o.as_str() {\n            \"+\" => value += operand[i + 1],\n\
    \            \"-\" => value -= operand[i + 1],\n            \"*\" => value *=\
    \ operand[i + 1],\n            \"//\" => value /= operand[i + 1],\n          \
    \  \"**\" => value = value.pow(operand[i + 1] as u32),\n            _ => value\
    \ = 0,\n        }\n    }\n    value", "    let mut operand = operand;\n    for\
    \ (i, op) in operator.iter().enumerate() {\n        let lhs = operand[i];\n  \
    \      let rhs = operand[i + 1];\n        match op.as_str() {\n            \"\
    +\" => operand[i + 1] = lhs + rhs,\n            \"-\" => operand[i + 1] = lhs\
    \ - rhs,\n            \"*\" => operand[i + 1] = lhs * rhs,\n            \"//\"\
    \ => operand[i + 1] = lhs / rhs,\n            \"**\" => operand[i + 1] = lhs.pow(rhs\
    \ as u32),\n            _ => unreachable!(),\n        }\n    }\n    operand[operand.len()\
    \ - 1]", "    let mut result = operand[0];\n    for i in 0..operator.len() {\n\
    \        let mut num = operand[i + 1];\n        match operator[i].as_str() {\n\
    \            \"+\" => result += num,\n            \"-\" => result -= num,\n  \
    \          \"*\" => result *= num,\n            \"//\" => result /= num,\n   \
    \         \"**\" => result = result.pow(num as u32),\n            _ => panic!(\"\
    unsupported operator {}\", operator[i]),\n        }\n    }\n    result", "   \
    \ let mut result = operand[0];\n    for (i, o) in operator.iter().enumerate()\
    \ {\n        match o.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => {}\n\
    \        }\n    }\n    result", "    let mut result = operand[0];\n    for i in\
    \ 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\"\
    \ => result += operand[i + 1],\n            \"-\" => result -= operand[i + 1],\n\
    \            \"*\" => result *= operand[i + 1],\n            \"//\" => result\
    \ /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i + 1]\
    \ as u32),\n            _ => {}\n        }\n    }\n    result", "    let mut answer\
    \ = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => answer += operand[i + 1],\n            \"-\" => answer\
    \ -= operand[i + 1],\n            \"*\" => answer *= operand[i + 1],\n       \
    \     \"//\" => answer /= operand[i + 1],\n            \"**\" => answer = answer.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Unsupported operator: {}\", operator[i]),\n\
    \        }\n    }\n    answer", "    let mut result = operand[0];\n    for i in\
    \ 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\"\
    \ => result += operand[i + 1],\n            \"-\" => result -= operand[i + 1],\n\
    \            \"*\" => result *= operand[i + 1],\n            \"//\" => result\
    \ /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i + 1]\
    \ as u32),\n            _ => panic!(\"unknown operator!\"),\n        }\n    }\n\
    \    result", "    let mut stack: Vec<isize> = Vec::new();\n    for i in 1..operand.len()\
    \ {\n        match operator[i - 1].as_str() {\n            \"+\" => stack.push(stack.pop().unwrap()\
    \ + operand[i]),\n            \"-\" => stack.push(stack.pop().unwrap() - operand[i]),\n\
    \            \"*\" => stack.push(stack.pop().unwrap() * operand[i]),\n       \
    \     \"//\" => stack.push(stack.pop().unwrap() / operand[i]),\n            \"\
    **\" => stack.push(stack.pop().unwrap().pow(operand[i] as u32)),\n           \
    \ _ => panic!(\"operator not recognized\"),\n        }\n    }\n    stack.pop().unwrap()",
  "    use std::convert::TryInto;\n    let mut result = operand[0];\n    for (i, o)\
    \ in operator.iter().enumerate() {\n        match o.as_str() {\n            \"\
    +\" => result += operand[i + 1],\n            \"-\" => result -= operand[i + 1],\n\
    \            \"*\" => result *= operand[i + 1],\n            \"//\" => result\
    \ /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i + 1].try_into().unwrap()),\n\
    \            _ => (),\n        }\n    }\n    result", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"unexpected operator\"),\n        }\n\
    \    }\n    result", "    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"\
    Unknown operator\"),\n        }\n    }\n    result", "    let mut operand = operand;\n\
    \    for (o, i) in operator.iter().zip(0..operator.len()) {\n        match o.as_str()\
    \ {\n            \"+\" => operand[i+1] = operand[i] + operand[i+1],\n        \
    \    \"-\" => operand[i+1] = operand[i] - operand[i+1],\n            \"*\" =>\
    \ operand[i+1] = operand[i] * operand[i+1],\n            \"//\" => operand[i+1]\
    \ = operand[i] / operand[i+1],\n            \"**\" => operand[i+1] = operand[i].pow(operand[i+1]\
    \ as u32),\n            _ => (),\n        }\n    }\n    operand[operand.len()-1]",
  "    assert!(operator.len() == operand.len() - 1);\n    assert!(!operator.is_empty());\n\
    \    assert!(operand.len() >= 2);\n\n    if operand.len() == 2 {\n        return\
    \ match operator[0].as_str() {\n            \"+\" => operand[0] + operand[1],\n\
    \            \"-\" => operand[0] - operand[1],\n            \"*\" => operand[0]\
    \ * operand[1],\n            \"//\" => operand[0] / operand[1],\n            \"\
    **\" => operand[0].pow(operand[1] as u32),\n            _ => panic!(\"Invalid\
    \ operator!\"),\n        };\n    }\n\n    let mut res = operand[0];\n    for i\
    \ in 0..operator.len() {\n        res = match operator[i].as_str() {\n       \
    \     \"+\" => res + operand[i + 1],\n            \"-\" => res - operand[i + 1],\n\
    \            \"*\" => res * operand[i + 1],\n            \"//\" => res / operand[i\
    \ + 1],\n            \"**\" => res.pow(operand[i + 1] as u32),\n            _\
    \ => panic!(\"Invalid operator!\"),\n        };\n    }\n    res", "    let mut\
    \ result = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"invalid operator\"),\n        }\n \
    \   }\n    result", "    assert!(operator.len() == operand.len() - 1);\n    assert!(operator.len()\
    \ >= 1);\n    assert!(operand.len() >= 2);\n    for op in &operator {\n      \
    \  assert!(op == \"+\" || op == \"-\" || op == \"*\" || op == \"//\" || op ==\
    \ \"**\");\n    }\n    assert!(operand.iter().all(|&x| x >= 0));\n    0", "  \
    \  let mut operand = operand;\n    let mut i = 0;\n    while i < operator.len()\
    \ {\n        if operator[i] == \"**\" {\n            operand[i] = operand[i].pow(operand[i\
    \ + 1] as u32);\n            operand.remove(i + 1);\n            operator.remove(i);\n\
    \        } else {\n            i += 1;\n        }\n    }\n    let result = operand.iter().zip(operator.iter()).fold(operand[0],\
    \ |acc, (&operand, operator)| {\n        match operator.as_ref() {\n         \
    \   \"+\" => acc + operand,\n            \"-\" => acc - operand,\n           \
    \ \"*\" => acc * operand,\n            \"//\" => acc / operand,\n            _\
    \ => unreachable!()\n        }\n    });\n    result", "    // we need to consider\
    \ the order of operations, so we need to get the operations\n    // with the highest\
    \ presidence first. then we can evaluate from left to right.\n    // we need to:\n\
    \    // 1. process all multiplications and divisions.\n    // 2. process all additions\
    \ and subtractions.\n    // we do this in reverse order so we only have to loop\
    \ through the list once\n    // so that we don't need to search for all of them\
    \ at once.\n    // we will also remove them from the list.\n    let mut operands\
    \ = operand;\n    let mut operators = operator;\n    loop {\n        // get last\
    \ element.\n        let op = operators.pop();\n        match op {\n          \
    \  Some(e) => {\n                let right = operands.pop().unwrap();\n      \
    \          let left = operands.pop().unwrap();\n                operands.push(do_calculation(left,\
    \ e, right));\n            }\n            None => {\n                break;\n\
    \            }\n        }\n    }\n    return operands[0];", "    let mut ans =\
    \ operand[0];\n    for i in 0..operator.len() {\n        if operator[i] == \"\
    +\" {\n            ans += operand[i + 1];\n        } else if operator[i] == \"\
    -\" {\n            ans -= operand[i + 1];\n        } else if operator[i] == \"\
    *\" {\n            ans *= operand[i + 1];\n        } else if operator[i] == \"\
    //\" {\n            ans /= operand[i + 1];\n        } else if operator[i] == \"\
    **\" {\n            ans = ans.pow(operand[i + 1] as u32);\n        }\n    }\n\
    \    ans", "    let mut op = operator;\n    let mut od = operand;\n    let mut\
    \ res = od.remove(0);\n    while let Some(opr) = op.pop() {\n        let operand\
    \ = od.pop().unwrap();\n        res = match opr.as_str() {\n            \"+\"\
    \ => res + operand,\n            \"-\" => res - operand,\n            \"*\" =>\
    \ res * operand,\n            \"//\" => res / operand,\n            \"**\" =>\
    \ res.pow(operand as u32),\n            _ => res\n        }\n    }\n    res",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        if\
    \ operator[i] == \"+\" {\n            result += operand[i + 1];\n        } else\
    \ if operator[i] == \"-\" {\n            result -= operand[i + 1];\n        }\
    \ else if operator[i] == \"*\" {\n            result *= operand[i + 1];\n    \
    \    } else if operator[i] == \"//\" {\n            result /= operand[i + 1];\n\
    \        } else if operator[i] == \"**\" {\n            result = result.pow(operand[i\
    \ + 1] as u32);\n        }\n    }\n    result", "    let mut iter = operand.iter();\n\
    \    let mut acc = *iter.next().unwrap();\n    for op in operator {\n        let\
    \ v = *iter.next().unwrap();\n        acc = match op.as_str() {\n            \"\
    +\" => acc + v,\n            \"-\" => acc - v,\n            \"*\" => acc * v,\n\
    \            \"//\" => acc / v,\n            \"**\" => acc.pow(v as u32),\n  \
    \          _ => unreachable!(),\n        };\n    }\n    acc", "    let mut iteration\
    \ = 0;\n    let mut operand_iter = operand.iter();\n    let mut acc = *operand_iter.next().unwrap();\n\
    \    for iter in operator.iter() {\n        iteration += 1;\n        let b = *operand_iter.next().unwrap();\n\
    \        match iter.as_str() {\n            \"+\" => acc += b,\n            \"\
    -\" => acc -= b,\n            \"*\" => acc *= b,\n            \"//\" => acc /=\
    \ b,\n            \"**\" => acc = acc.pow(b as u32),\n            _ => panic!(\"\
    invalid symbol. only + - * // ** are supported\"),\n        }\n    }\n    acc",
  "    let mut ops = operator.iter().peekable();\n    let mut opd = operand.iter().peekable();\n\
    \    let mut result = *opd.next().unwrap();\n    while let Some(op) = ops.next()\
    \ {\n        let rhs = *opd.next().unwrap();\n        result = match op.as_str()\
    \ {\n            \"+\" => result + rhs,\n            \"-\" => result - rhs,\n\
    \            \"*\" => result * rhs,\n            \"//\" => result / rhs,\n   \
    \         \"**\" => result.pow(rhs as u32),\n            _ => result,\n      \
    \  };\n    }\n    result", "  operator.iter().fold(operand[0], |result, &op| {\n\
    \    match op.as_str() {\n      \"+\" => result + operand[1],\n      \"-\" =>\
    \ result - operand[1],\n      \"*\" => result * operand[1],\n      \"//\" => result\
    \ / operand[1],\n      \"**\" => result.pow(operand[1] as u32),\n      _ => 0\n\
    \    }\n  })", "    operand\n        .iter()\n        .zip(operator.iter())\n\
    \        .scan(0, |acc, (x, op)| {\n            match op.as_str() {\n        \
    \        \"+\" => Some(*acc += x),\n                \"-\" => Some(*acc -= x),\n\
    \                \"*\" => Some(*acc *= x),\n                \"//\" => Some(*acc\
    \ /= x),\n                \"**\" => Some(*acc = x.pow(*acc as u32)),\n       \
    \         _ => None,\n            }\n        })\n        .last()\n        .unwrap()",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        if\
    \ operator[i] == \"+\" {\n            result += operand[i + 1];\n        } else\
    \ if operator[i] == \"-\" {\n            result -= operand[i + 1];\n        }\
    \ else if operator[i] == \"*\" {\n            result *= operand[i + 1];\n    \
    \    } else if operator[i] == \"//\" {\n            result /= operand[i + 1];\n\
    \        } else if operator[i] == \"**\" {\n            result = result.pow(operand[i\
    \ + 1] as u32);\n        }\n    }\n    result", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => println!(\"invalid operator\"),\n        }\n\
    \    }\n    result", "    let mut stack: Vec<isize> = vec![];\n    let mut operator_iter\
    \ = operator.iter();\n    let mut operand_iter = operand.iter();\n    let mut\
    \ operand = operand_iter.next().unwrap();\n    while let Some(opt) = operator_iter.next()\
    \ {\n        match opt.as_str() {\n            \"+\" => {\n                stack.push(*operand);\n\
    \                operand = operand_iter.next().unwrap();\n            }\n    \
    \        \"-\" => {\n                let x = *operand;\n                operand\
    \ = operand_iter.next().unwrap();\n                stack.push(x - *operand);\n\
    \                operand = operand_iter.next().unwrap();\n            }\n    \
    \        \"*\" => {\n                let x = *operand;\n                operand\
    \ = operand_iter.next().unwrap();\n                stack.push(x * *operand);\n\
    \                operand = operand_iter.next().unwrap();\n            }\n    \
    \        \"/\" => {\n                let x = *operand;\n                operand\
    \ = operand_iter.next().unwrap();\n                stack.push(x / *operand);\n\
    \                operand = operand_iter.next().unwrap();\n            }\n    \
    \        \"^\" => {\n                let x = *operand;\n                operand\
    \ = operand_iter.next().unwrap();\n                stack.push(x.pow(*operand as\
    \ u32));\n                operand = operand_iter.next().unwrap();\n          \
    \  }\n            _ => {}\n        }\n    }\n    stack.push(*operand);\n    stack.iter().sum()",
  "    let mut stack: Vec<isize> = vec![];\n    stack.push(operand[0]);\n    for i\
    \ in 1..operand.len() {\n        let mut value = operand[i];\n        match &operator[i\
    \ - 1][..] {\n            \"+\" => value = stack.pop().unwrap() + value,\n   \
    \         \"-\" => value = stack.pop().unwrap() - value,\n            \"*\" =>\
    \ value = stack.pop().unwrap() * value,\n            \"//\" => value = stack.pop().unwrap()\
    \ / value,\n            \"**\" => value = stack.pop().unwrap().pow(value as u32),\n\
    \            _ => println!(\"Error!\"),\n        }\n        stack.push(value);\n\
    \    }\n    stack.pop().unwrap()", "    assert!(operator.len() > 0 && operand.len()\
    \ > 1);\n    assert!(operator.len() == operand.len() - 1);\n    let mut result\
    \ = operand[0];\n    for (op, num) in operator.iter().zip(operand.iter().skip(1))\
    \ {\n        result = match op.as_str() {\n            \"+\" => result + num,\n\
    \            \"-\" => result - num,\n            \"*\" => result * num,\n    \
    \        \"//\" => result / num,\n            \"**\" => result.pow(*num as u32),\n\
    \            _ => panic!(\"Unrecognized operator: {}\", op),\n        };\n   \
    \ }\n    result", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i\
    \ + 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" =>\
    \ result *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n\
    \            \"**\" => result = result.pow(operand[i + 1] as u32),\n         \
    \   _ => println!(\"no match\"),\n        }\n    }\n    result", "    let mut\
    \ result = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => println!(\"operator not known\"),\n        }\n\
    \    }\n    result", "    let mut acc = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        let a = operand[i];\n        let b = operand[i + 1];\n        acc\
    \ = match op.as_str() {\n            \"+\" => a + b,\n            \"-\" => a -\
    \ b,\n            \"*\" => a * b,\n            \"//\" => a / b,\n            \"\
    **\" => a.pow(b as u32),\n            _ => 0,\n        };\n    }\n    acc", " \
    \   let mut result = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => result += operand[i + 1],\n   \
    \         \"-\" => result -= operand[i + 1],\n            \"*\" => result *= operand[i\
    \ + 1],\n            \"//\" => result /= operand[i + 1],\n            \"**\" =>\
    \ result = result.pow(operand[i + 1] as u32),\n            _ => {}\n        }\n\
    \    }\n    result", "    let mut result = operand[0];\n    for i in 0..operand.len()\
    \ - 1 {\n        match operator[i].as_str() {\n            \"+\" => result +=\
    \ operand[i + 1],\n            \"-\" => result -= operand[i + 1],\n          \
    \  \"*\" => result *= operand[i + 1],\n            \"//\" => result /= operand[i\
    \ + 1],\n            \"**\" => result = result.pow(operand[i + 1] as u32),\n \
    \           _ => {}\n        }\n    }\n    result", "    let mut result = 0;\n\
    \    let mut op = String::new();\n    let mut index = 0;\n    let mut calc = |op:\
    \ &str, first: isize, second: isize| {\n        match op {\n            \"+\"\
    \ => first + second,\n            \"-\" => first - second,\n            \"*\"\
    \ => first * second,\n            \"//\" => first / second,\n            \"**\"\
    \ => first.pow(second as u32),\n            _ => unimplemented!(),\n        }\n\
    \    };\n    for i in 0..operand.len() - 1 {\n        if op == \"\" {\n      \
    \      result = operand[index];\n            index += 1;\n            op = operator[i].clone();\n\
    \        } else {\n            result = calc(&op, result, operand[index]);\n \
    \           index += 1;\n            op = operator[i].clone();\n        }\n  \
    \  }\n    calc(&op, result, operand[index])", "    let mut value = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => value += operand[i + 1],\n            \"-\" => value -= operand[i\
    \ + 1],\n            \"*\" => value *= operand[i + 1],\n            \"//\" =>\
    \ value /= operand[i + 1],\n            \"**\" => value = value.pow(operand[i\
    \ + 1] as u32),\n            _ => {\n                panic!(\"Unknown operator:\
    \ {}\", operator[i]);\n            }\n        }\n    }\n    value", "  let mut\
    \ result = operand[0];\n  for i in 0..operator.len() {\n    match operator[i].as_str()\
    \ {\n      \"+\" => result += operand[i + 1],\n      \"-\" => result -= operand[i\
    \ + 1],\n      \"*\" => result *= operand[i + 1],\n      \"//\" => result /= operand[i\
    \ + 1],\n      \"**\" => result = result.pow(operand[i + 1] as u32),\n      _\
    \ => result += operand[i + 1],\n    }\n  }\n  result", "    //\n    let mut stack:\
    \ Vec<isize> = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    while i <\
    \ operand.len() && j < operator.len() {\n        match operator[j].as_str() {\n\
    \            \"+\" => {\n                stack.push(operand[i]);\n           \
    \     i += 1;\n                j += 1;\n            }\n            \"-\" => {\n\
    \                stack.push(operand[i]);\n                i += 1;\n          \
    \      j += 1;\n            }\n            \"*\" => {\n                let tmp\
    \ = stack.pop().unwrap();\n                stack.push(tmp * operand[i]);\n   \
    \             i += 1;\n                j += 1;\n            }\n            \"\
    /\" => {\n                let tmp = stack.pop().unwrap();\n                stack.push(tmp\
    \ / operand[i]);\n                i += 1;\n                j += 1;\n         \
    \   }\n            \"^\" => {\n                let tmp = stack.pop().unwrap();\n\
    \                stack.push(tmp.pow(operand[i] as u32));\n                i +=\
    \ 1;\n                j += 1;\n            }\n            _ => {}\n        }\n\
    \    }\n    let mut val = stack.pop().unwrap();\n    for i in stack {\n      \
    \  val += i;\n    }\n    val", "    let n = operand.len();\n    let mut res =\
    \ operand[0];\n    for i in 1..n {\n        res = match operator[i - 1].as_str()\
    \ {\n            \"+\" => res + operand[i],\n            \"-\" => res - operand[i],\n\
    \            \"*\" => res * operand[i],\n            \"//\" => res / operand[i],\n\
    \            \"**\" => res.pow(operand[i] as u32),\n            _ => panic!(\"\
    unknown operator {:?}\", operator[i - 1]),\n        };\n    }\n    res", '    operand.iter().fold1(|a,
    b| calc(b, a, operator.pop().unwrap())).unwrap()', "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => (),\n        }\n    }\n    result", '    unimplemented!();',
  "    let mut stack: Vec<isize> = Vec::new();\n    let mut op = 0;\n    let mut num\
    \ = operand[0];\n    while op < operator.len() {\n        let op_ch = operator[op].chars().next().unwrap();\n\
    \        match op_ch {\n            '+' => num += operand[op + 1],\n         \
    \   '-' => num -= operand[op + 1],\n            '*' => num *= operand[op + 1],\n\
    \            '/' => num /= operand[op + 1],\n            '^' => num = num.pow(operand[op\
    \ + 1] as u32),\n            _ => panic!(\"Unsupported operation.\"),\n      \
    \  }\n        op += 1;\n    }\n    num", "    let mut result = operand[0];\n \
    \   for i in 0..operator.len() {\n        match operator[i].as_str() {\n     \
    \       \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => {}\n        }\n    }\n    result", "    operand.iter().rev().fold(0,\
    \ |acc, x| {\n        let op = operator.pop().unwrap();\n        if op == \"+\"\
    \ {\n            x + acc\n        } else if op == \"-\" {\n            x - acc\n\
    \        } else if op == \"*\" {\n            x * acc\n        } else if op ==\
    \ \"//\" {\n            x / acc\n        } else if op == \"**\" {\n          \
    \  x.pow(acc as u32)\n        } else {\n            0\n        }\n    })", " \
    \   let mut expression = operand[0].to_string();\n    for i in 0..operator.len()\
    \ {\n        expression += &operator[i];\n        expression += &operand[i + 1].to_string();\n\
    \    }\n    let result = expression.parse::<isize>().unwrap();\n    result", " \
    \   let mut result = operand[0];\n    for i in 0..operator.len() {\n        if\
    \ operator[i] == \"+\" {\n            result += operand[i + 1];\n        } else\
    \ if operator[i] == \"-\" {\n            result -= operand[i + 1];\n        }\
    \ else if operator[i] == \"*\" {\n            result *= operand[i + 1];\n    \
    \    } else if operator[i] == \"//\" {\n            result /= operand[i + 1];\n\
    \        } else if operator[i] == \"**\" {\n            result = result.pow(operand[i\
    \ + 1] as u32);\n        }\n    }\n    result", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        if operator[i] == \"+\" {\n       \
    \     result += operand[i + 1];\n        } else if operator[i] == \"-\" {\n  \
    \          result -= operand[i + 1];\n        } else if operator[i] == \"*\" {\n\
    \            result *= operand[i + 1];\n        } else if operator[i] == \"//\"\
    \ {\n            result /= operand[i + 1];\n        } else if operator[i] == \"\
    **\" {\n            result = result.pow(operand[i + 1] as u32);\n        }\n \
    \   }\n    result", "    let mut exp = \"\".to_string();\n    for i in 0..operator.len()\
    \ {\n        exp.push_str(&format!(\"{} {}\", operand[i], operator[i]));\n   \
    \ }\n    exp.push_str(&format!(\"{}\", operand[operand.len() - 1]));\n    match\
    \ exp.parse::<isize>() {\n        Ok(n) => n,\n        Err(_) => 0,\n    }", " \
    \   let mut res = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => res += operand[i + 1],\n\
    \            \"-\" => res -= operand[i + 1],\n            \"*\" => res *= operand[i\
    \ + 1],\n            \"//\" => res /= operand[i + 1],\n            \"**\" => res\
    \ = res.pow(operand[i + 1] as u32),\n            _ => panic!(\"Unknown operator:\
    \ {}\", op),\n        }\n    }\n    res", "    let mut result = operand[0];\n\
    \    for (op, n) in operator.iter().zip(operand.iter().skip(1)) {\n        match\
    \ op.as_str() {\n            \"+\" => result += n,\n            \"-\" => result\
    \ -= n,\n            \"*\" => result *= n,\n            \"//\" => result /= n,\n\
    \            \"**\" => result = result.pow(*n as u32),\n            _ => panic!(\"\
    Unknown operator\"),\n        }\n    }\n    result", "    // println!(\"operator\
    \ = {:?}\", operator);\n    // println!(\"operand = {:?}\", operand);\n    let\
    \ mut result = operand[0];\n    let mut op_iter = operator.iter();\n    for op\
    \ in operand.iter().skip(1) {\n        let oper = op_iter.next().unwrap();\n \
    \       match oper.as_str() {\n            \"+\" => result += op,\n          \
    \  \"-\" => result -= op,\n            \"*\" => result *= op,\n            \"\
    //\" => result /= op,\n            \"**\" => result = result.pow(*op as u32),\n\
    \            _ => unreachable!(),\n        }\n    }\n    result", "    let mut\
    \ result = operand[0];\n    for i in 0..operator.len() {\n        if operator[i]\
    \ == \"+\" {\n            result += operand[i + 1];\n        } else if operator[i]\
    \ == \"-\" {\n            result -= operand[i + 1];\n        } else if operator[i]\
    \ == \"*\" {\n            result *= operand[i + 1];\n        } else if operator[i]\
    \ == \"//\" {\n            result /= operand[i + 1];\n        } else if operator[i]\
    \ == \"**\" {\n            result = result.pow(operand[i + 1] as u32);\n     \
    \   }\n    }\n    result", "    let mut result = operand[0];\n    for (i, op)\
    \ in operator.iter().enumerate() {\n        match op.as_str() {\n            \"\
    +\" => result += operand[i + 1],\n            \"-\" => result -= operand[i + 1],\n\
    \            \"*\" => result *= operand[i + 1],\n            \"//\" => result\
    \ /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i + 1]\
    \ as u32),\n            _ => {}\n        }\n    }\n    result", '    unimplemented!();',
  "    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"\
    invalid operator: {}\", op),\n        }\n    }\n    result", "    let mut o =\
    \ operand.clone();\n    for s in operator {\n        match s.as_str() {\n    \
    \        \"+\" => {\n                let a = o.remove(0);\n                let\
    \ b = o.remove(0);\n                o.insert(0, a + b);\n            }\n     \
    \       \"-\" => {\n                let a = o.remove(0);\n                let\
    \ b = o.remove(0);\n                o.insert(0, a - b);\n            }\n     \
    \       \"*\" => {\n                let a = o.remove(0);\n                let\
    \ b = o.remove(0);\n                o.insert(0, a * b);\n            }\n     \
    \       \"//\" => {\n                let a = o.remove(0);\n                let\
    \ b = o.remove(0);\n                o.insert(0, a / b);\n            }\n     \
    \       \"**\" => {\n                let a = o.remove(0);\n                let\
    \ b = o.remove(0);\n                o.insert(0, a.pow(b as u32));\n          \
    \  }\n            _ => unreachable!(),\n        }\n    }\n    o[0]", "    let\
    \ mut prev = operand[0];\n    for i in 1..operand.len() {\n        let op = operator[i\
    \ - 1].as_ref();\n        match op {\n            \"+\" => prev += operand[i],\n\
    \            \"-\" => prev -= operand[i],\n            \"*\" => prev *= operand[i],\n\
    \            \"//\" => prev /= operand[i],\n            \"**\" => prev = prev.pow(operand[i]\
    \ as u32),\n            _ => panic!(\"Invalid operator {}\", op),\n        }\n\
    \    }\n    prev", "    use self::Op::*;\n    let mut result = operand[0];\n \
    \   for i in 1..operand.len() {\n        result = match operator[i - 1].as_str()\
    \ {\n            \"+\" => result + operand[i],\n            \"-\" => result -\
    \ operand[i],\n            \"*\" => result * operand[i],\n            \"//\" =>\
    \ result / operand[i],\n            \"**\" => result.pow(operand[i] as u32),\n\
    \            _ => panic!(\"unknown operator\"),\n        };\n    }\n    result",
  "    let mut result = operand[0];\n    for (i, x) in operand.iter().enumerate().skip(1)\
    \ {\n        match operator[i - 1].as_str() {\n            \"+\" => result +=\
    \ x,\n            \"-\" => result -= x,\n            \"*\" => result *= x,\n \
    \           \"//\" => result /= x,\n            \"**\" => result = result.pow(*x\
    \ as u32),\n            _ => continue,\n        }\n    }\n    result", "    //Initialize\
    \ the result from the first operand.\n    let mut result = operand[0];\n    for\
    \ i in 0..operator.len() {\n        //Get the next operand and the operation.\n\
    \        let operand = operand[i + 1];\n        let operation = &operator[i];\n\
    \        //Perform the operation.\n        match operation.as_str() {\n      \
    \      \"+\" => result += operand,\n            \"-\" => result -= operand,\n\
    \            \"*\" => result *= operand,\n            \"//\" => result /= operand,\n\
    \            \"**\" => result = result.pow(operand as u32),\n            _ =>\
    \ panic!(\"Unknown operation!\"),\n        }\n    }\n    result", "    let (mut\
    \ operand, mut result) = (operand.into_iter(), operand[0]);\n    for (i, op) in\
    \ operator.into_iter().enumerate() {\n        result = match op.as_str() {\n \
    \           \"+\" => result + operand.next().unwrap(),\n            \"-\" => result\
    \ - operand.next().unwrap(),\n            \"*\" => result * operand.next().unwrap(),\n\
    \            \"//\" => result / operand.next().unwrap(),\n            \"**\" =>\
    \ result.pow(operand.next().unwrap() as u32),\n            _ => panic!(\"Unknown\
    \ operator: {}\", op),\n        };\n    }\n    result", "    let mut stack: Vec<isize>\
    \ = vec![];\n    for (i, val) in operand.iter().enumerate() {\n        stack.push(*val);\n\
    \        if i < operator.len() {\n            match operator[i].as_str() {\n \
    \               \"+\" => {\n                    let operand2 = stack.pop().unwrap();\n\
    \                    let operand1 = stack.pop().unwrap();\n                  \
    \  stack.push(operand1 + operand2);\n                }\n                \"-\"\
    \ => {\n                    let operand2 = stack.pop().unwrap();\n           \
    \         let operand1 = stack.pop().unwrap();\n                    stack.push(operand1\
    \ - operand2);\n                }\n                \"*\" => {\n              \
    \      let operand2 = stack.pop().unwrap();\n                    let operand1\
    \ = stack.pop().unwrap();\n                    stack.push(operand1 * operand2);\n\
    \                }\n                \"//\" => {\n                    let operand2\
    \ = stack.pop().unwrap();\n                    let operand1 = stack.pop().unwrap();\n\
    \                    stack.push(operand1 / operand2);\n                }\n   \
    \             \"**\" => {\n                    let operand2 = stack.pop().unwrap();\n\
    \                    let operand1 = stack.pop().unwrap();\n                  \
    \  stack.push(operand1.pow(operand2 as u32));\n                }\n           \
    \     _ => {}\n            }\n        }\n    }\n    stack.pop().unwrap()", " \
    \   let mut result = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => result += operand[i + 1],\n   \
    \         \"-\" => result -= operand[i + 1],\n            \"*\" => result *= operand[i\
    \ + 1],\n            \"//\" => result /= operand[i + 1],\n            \"**\" =>\
    \ result = result.pow(operand[i + 1] as u32),\n            _ => result,\n    \
    \    }\n    }\n    result", "    let mut result = operand[0];\n    for (o, p)\
    \ in operator.iter().zip(operand.iter().skip(1)) {\n        result = match o.as_str()\
    \ {\n            \"+\" => result + p,\n            \"-\" => result - p,\n    \
    \        \"*\" => result * p,\n            \"//\" => result / p,\n           \
    \ \"**\" => result.pow(*p as u32),\n            _ => 0,\n        }\n    }\n  \
    \  result", "    let mut result = operand[0];\n    for (op_idx, op) in operator.iter().enumerate()\
    \ {\n        let next_operand = operand[op_idx + 1];\n        match op.as_str()\
    \ {\n            \"+\" => result += next_operand,\n            \"-\" => result\
    \ -= next_operand,\n            \"*\" => result *= next_operand,\n           \
    \ \"//\" => result /= next_operand,\n            \"**\" => result = result.pow(next_operand\
    \ as u32),\n            _ => (),\n        }\n    }\n    result", '    unimplemented!();',
  "    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        let op2 = operand[i + 1];\n        match op.as_str() {\n        \
    \    \"+\" => result += op2,\n            \"-\" => result -= op2,\n          \
    \  \"*\" => result *= op2,\n            \"//\" => result /= op2,\n           \
    \ \"**\" => result = result.pow(op2 as u32),\n            _ => panic!(\"Invalid\
    \ operator\"),\n        }\n    }\n    result", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => unreachable!(),\n        }\n    }\n    result",
  "    (1..operator.len()).fold(operand[0], |prev, i| {\n        match operator[i\
    \ - 1].as_str() {\n            \"+\" => prev + operand[i],\n            \"-\"\
    \ => prev - operand[i],\n            \"*\" => prev * operand[i],\n           \
    \ \"//\" => prev / operand[i],\n            \"**\" => prev.pow(operand[i] as u32),\n\
    \            _ => prev,\n        }\n    })", "    let mut idx = 0;\n    let mut\
    \ result = operand[idx];\n    while idx < operator.len() {\n        idx += 1;\n\
    \        match operator[idx - 1].as_str() {\n            \"+\" => result += operand[idx],\n\
    \            \"-\" => result -= operand[idx],\n            \"*\" => result *=\
    \ operand[idx],\n            \"//\" => result /= operand[idx],\n            \"\
    **\" => result = result.pow(operand[idx] as u32),\n            _ => panic!(\"\
    invalid operation: {}\", operator[idx - 1]),\n        }\n    }\n    result", " \
    \ operand.iter().zip(operator.iter()).fold(None, |acc, (b, op)| {\n    match acc\
    \ {\n      Some(a) => {\n        match op.as_str() {\n          \"+\" => Some(a\
    \ + b),\n          \"-\" => Some(a - b),\n          \"*\" => Some(a * b),\n  \
    \        \"//\" => Some(a / b),\n          \"**\" => Some(a.pow(*b as u32)),\n\
    \          _ => None,\n        }\n      }\n      None => Some(*b),\n    }\n  }).unwrap()",
  "    let mut operators = operator.into_iter();\n    let mut operands = operand.into_iter();\n\
    \    let init = operands.next().unwrap();\n    return operators.fold(init, |acc,\
    \ item| {\n        let op2 = operands.next().unwrap();\n        match item.as_str()\
    \ {\n            \"+\" => acc + op2,\n            \"-\" => acc - op2,\n      \
    \      \"*\" => acc * op2,\n            \"//\" => acc / op2,\n            \"**\"\
    \ => acc.pow(op2 as u32),\n            _ => panic!(\"Not operator: {}\", item),\n\
    \        }\n    });", "    let mut op_eval = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => op_eval += operand[i\
    \ + 1],\n            \"-\" => op_eval -= operand[i + 1],\n            \"*\" =>\
    \ op_eval *= operand[i + 1],\n            \"//\" => op_eval /= operand[i + 1],\n\
    \            \"**\" => op_eval = op_eval.pow(operand[i + 1] as u32),\n       \
    \     _ => return -1,\n        }\n    }\n    op_eval", "    if operand.len() <\
    \ 2 {\n        return 0;\n    }\n    let mut result = operand[0];\n    for i in\
    \ 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\"\
    \ => result += operand[i + 1],\n            \"-\" => result -= operand[i + 1],\n\
    \            \"*\" => result *= operand[i + 1],\n            \"//\" => result\
    \ /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i + 1]\
    \ as u32),\n            _ => (),\n        }\n    }\n    result", "    let mut\
    \ operand = operand;\n    let mut result = operand.remove(0);\n    for (ref op,\
    \ val) in operator.iter().zip(operand) {\n        match op.as_ref() {\n      \
    \      \"+\" => result += val,\n            \"-\" => result -= val,\n        \
    \    \"*\" => result *= val,\n            \"/\" => result /= val,\n          \
    \  \"^\" => result = result.pow(val as u32),\n            _ => panic!(\"Unknown\
    \ operator\"),\n        }\n    }\n    result", "    let result = operand[0];\n\
    \    for (idx, op) in operator.iter().enumerate() {\n        let left = operand[idx];\n\
    \        let right = operand[idx + 1];\n        match op.as_str() {\n        \
    \    \"+\" => operand[idx + 1] = left + right,\n            \"-\" => operand[idx\
    \ + 1] = left - right,\n            \"*\" => operand[idx + 1] = left * right,\n\
    \            \"//\" => operand[idx + 1] = left / right,\n            \"**\" =>\
    \ operand[idx + 1] = left.pow(right as u32),\n            _ => {}\n        }\n\
    \    }\n    operand[operand.len() - 1]", "    use std::collections::HashMap;\n\
    \    let ops = {\n        let mut hm = HashMap::new();\n        hm.insert(\"+\"\
    , |x, y| x + y);\n        hm.insert(\"-\", |x, y| x - y);\n        hm.insert(\"\
    *\", |x, y| x * y);\n        hm.insert(\"//\", |x, y| x / y);\n        hm.insert(\"\
    **\", |x, y| x.pow(y as u32));\n        hm\n    };\n    let mut it = operand.iter();\n\
    \    let mut result = *it.next().unwrap();\n    for op in operator {\n       \
    \ let operand = *it.next().unwrap();\n        result = ops[&op](result, operand);\n\
    \    }\n    result", "    // TODO: implement this function\n    // unimplemented!();\n\
    \    let mut new_operand: Vec<isize> = Vec::new();\n    let mut result: isize\
    \ = 0;\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    let mut k: usize\
    \ = 0;\n    //print!(\"operator: {:?} \\n\", operator);\n    //print!(\"operand:\
    \ {:?} \\n\", operand);\n    for i in 0..operator.len() {\n        //println!(\"\
    operator: {:?} \\n\", operator[i]);\n        //println!(\"operand: {:?} and {:?}\
    \ \\n\", operand[j], operand[j+1]);\n        match operator[i].as_ref() {\n  \
    \          \"+\" => {\n                result = operand[j] + operand[j+1];\n \
    \               j += 1;\n            },\n            \"-\" => {\n            \
    \    result = operand[j] - operand[j+1];\n                j += 1;\n          \
    \  },\n            \"*\" => {\n                result = operand[j] * operand[j+1];\n\
    \                j += 1;\n            },\n            \"//\" => {\n          \
    \      result = operand[j] / operand[j+1];\n                j += 1;\n        \
    \    },\n            \"**\" => {\n                result = operand[j].pow(operand[j+1]\
    \ as u32);\n                j += 1;\n            },\n            _ => panic!(\"\
    error\")\n        }\n        new_operand.push(result);\n        //println!(\"\
    new_operand: {:?} \\n\", new_operand);\n    }\n    while k < new_operand.len()\
    \ {\n        result = new_operand[k];\n        k += 1;\n    }\n    //println!(\"\
    result: {:?} \\n\", result);\n    result", "    operator.iter().rev().fold(operand.last().unwrap().clone(),\
    \ |acc, op| {\n        match op.as_str() {\n            \"+\" => acc + operand[operand.len()\
    \ - 2],\n            \"-\" => acc - operand[operand.len() - 2],\n            \"\
    *\" => acc * operand[operand.len() - 2],\n            \"//\" => acc / operand[operand.len()\
    \ - 2],\n            \"**\" => acc.pow(operand[operand.len() - 2] as u32),\n \
    \           _ => acc,\n        }\n    })", "    let mut op = operator.iter();\n\
    \    let mut result = operand[0];\n    for i in 1..operand.len() {\n        let\
    \ op = op.next().unwrap();\n        match op.as_str() {\n            \"+\" =>\
    \ result += operand[i],\n            \"-\" => result -= operand[i],\n        \
    \    \"*\" => result *= operand[i],\n            \"//\" => result /= operand[i],\n\
    \            \"**\" => result = result.pow(operand[i] as u32),\n            _\
    \ => (),\n        }\n    }\n    result", "    let mut result = operand[0];\n \
    \   for i in 0..operator.len() {\n        match operator[i].as_str() {\n     \
    \       \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => unreachable!(),\n        }\n    }\n    result",
  "    let mut stack: Vec<isize> = Vec::new();\n    let mut i = 0;\n    let mut j\
    \ = 0;\n    while i < operand.len() {\n        if operator[j] == \"+\" {\n   \
    \         stack.push(operand[i] + operand[i + 1]);\n        } else if operator[j]\
    \ == \"-\" {\n            stack.push(operand[i] - operand[i + 1]);\n        }\
    \ else if operator[j] == \"*\" {\n            stack.push(operand[i] * operand[i\
    \ + 1]);\n        } else if operator[j] == \"//\" {\n            stack.push(operand[i]\
    \ / operand[i + 1]);\n        } else if operator[j] == \"**\" {\n            stack.push(operand[i].pow(operand[i\
    \ + 1] as u32));\n        } else {\n            return -1;\n        }\n      \
    \  i += 1;\n        j += 1;\n    }\n    let mut result = stack[0];\n    for i\
    \ in 1..stack.len() {\n        result = result.checked_add(stack[i]).unwrap();\n\
    \    }\n    result", "    let mut stack: Vec<isize> = Vec::new();\n    let mut\
    \ operand_iter = operand.iter();\n    let mut operator_iter = operator.iter();\n\
    \    stack.push(*operand_iter.next().unwrap());\n    while let Some(v) = operand_iter.next()\
    \ {\n        let op = operator_iter.next().unwrap();\n        match op.as_str()\
    \ {\n            \"+\" => stack.push(*v),\n            \"-\" => stack.push(-*v),\n\
    \            \"*\" => stack.push(stack.pop().unwrap() * *v),\n            \"//\"\
    \ => stack.push(stack.pop().unwrap() / *v),\n            \"**\" => stack.push(stack.pop().unwrap().pow(*v\
    \ as u32)),\n            _ => {}\n        }\n    }\n    stack.iter().sum()", " \
    \   let mut op = operand;\n    for (i, o) in operator.iter().enumerate() {\n \
    \       let l = op[i];\n        let r = op[i + 1];\n        op[i + 1] = match\
    \ o.as_str() {\n            \"+\" => l + r,\n            \"-\" => l - r,\n   \
    \         \"*\" => l * r,\n            \"//\" => l / r,\n            \"**\" =>\
    \ l.pow(r as u32),\n            _ => panic!(\"Unknown operation: {}\", o),\n \
    \       };\n    }\n    op[op.len() - 1]", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        let op1 = result;\n        let op2\
    \ = operand[i + 1];\n        result = match operator[i].as_str() {\n         \
    \   \"+\" => op1 + op2,\n            \"-\" => op1 - op2,\n            \"*\" =>\
    \ op1 * op2,\n            \"//\" => op1 / op2,\n            \"**\" => op1.pow(op2\
    \ as u32),\n            _ => 0,\n        };\n    }\n    result", "    let mut\
    \ op_iter = operator.iter();\n    let mut operand_iter = operand.iter();\n   \
    \ let left = *operand_iter.next().unwrap();\n    let mut result = left;\n    for\
    \ operand in operand_iter {\n        let op = op_iter.next().unwrap();\n     \
    \   match op.as_str() {\n            \"+\" => result += operand,\n           \
    \ \"-\" => result -= operand,\n            \"*\" => result *= operand,\n     \
    \       \"//\" => result /= operand,\n            \"**\" => result = result.pow(*operand\
    \ as u32),\n            _ => panic!(\"Invalid operator!\"),\n        }\n    }\n\
    \    result", "    let mut operand_iter = operand.iter();\n    let mut current_number\
    \ = *operand_iter.next().unwrap();\n    for (i, operator) in operator.iter().enumerate()\
    \ {\n        match operator.as_str() {\n            \"+\" => current_number +=\
    \ operand_iter.next().unwrap(),\n            \"-\" => current_number -= operand_iter.next().unwrap(),\n\
    \            \"*\" => current_number *= operand_iter.next().unwrap(),\n      \
    \      \"//\" => current_number /= operand_iter.next().unwrap(),\n           \
    \ \"**\" => current_number = num::pow(current_number, *operand_iter.next().unwrap()),\n\
    \            _ => panic!(\"Unknown operator\"),\n        }\n    }\n    current_number",
  "    let mut ops: Vec<fn(isize, isize) -> isize> = Vec::new();\n    for op in operator\
    \ {\n        match op.as_str() {\n            \"+\" => ops.push(add),\n      \
    \      \"-\" => ops.push(sub),\n            \"*\" => ops.push(mul),\n        \
    \    \"//\" => ops.push(div),\n            \"**\" => ops.push(pow),\n        \
    \    _ => (),\n        }\n    }\n    rpn(operand, ops)", "    let mut result =\
    \ operand[0];\n    for (i, oper) in operator.iter().enumerate() {\n        let\
    \ op2 = operand[i + 1];\n        match oper.as_str() {\n            \"+\" => result\
    \ += op2,\n            \"-\" => result -= op2,\n            \"*\" => result *=\
    \ op2,\n            \"//\" => result /= op2,\n            \"**\" => result = result.pow(op2\
    \ as u32),\n            _ => result = 0,\n        }\n    }\n    result", "   \
    \ let mut res = operand[0];\n    for i in 0..operand.len() - 1 {\n        match\
    \ operator[i].as_str() {\n            \"+\" => res += operand[i + 1],\n      \
    \      \"-\" => res -= operand[i + 1],\n            \"*\" => res *= operand[i\
    \ + 1],\n            \"//\" => res /= operand[i + 1],\n            \"**\" => res\
    \ = res.pow(operand[i + 1] as u32),\n            _ => panic!(\"Unrecognized operator:\
    \ {}\", operator[i]),\n        }\n    }\n    res", "    let mut result = operand[0];\n\
    \    for i in 0..operand.len()-1 {\n        match operator[i].as_str() {\n   \
    \         \"+\" => result += operand[i+1],\n            \"-\" => result -= operand[i+1],\n\
    \            \"*\" => result *= operand[i+1],\n            \"//\" => result /=\
    \ operand[i+1],\n            \"**\" => result = result.pow(operand[i+1] as u32),\n\
    \            _ => println!(\"unsupported operator!\"),\n        }\n    }\n   \
    \ result", "    operand.iter().fold1(|a, b| match operator.remove(0).as_str()\
    \ {\n        \"+\" => a + b,\n        \"-\" => a - b,\n        \"*\" => a * b,\n\
    \        \"//\" => a / b,\n        \"**\" => a.pow(*b as u32),\n        _ => panic!(\"\
    Not a valid operator\"),\n    })\n    .unwrap()", "    let mut ret = operand[0];\n\
    \    for (k, i) in operator.iter().enumerate() {\n        let a = ret;\n     \
    \   let b = operand[k + 1];\n        ret = match i.as_str() {\n            \"\
    +\" => a + b,\n            \"-\" => a - b,\n            \"*\" => a * b,\n    \
    \        \"//\" => a / b,\n            \"**\" => a.pow(b as u32),\n          \
    \  _ => unreachable!(),\n        };\n    }\n    ret", "    let mut stack: Vec<isize>\
    \ = Vec::new();\n    let mut operand_iter = operand.iter();\n    for op in operator\
    \ {\n        let left = *operand_iter.next().unwrap();\n        let right = *operand_iter.next().unwrap();\n\
    \        match op.as_str() {\n            \"+\" => stack.push(left + right),\n\
    \            \"-\" => stack.push(left - right),\n            \"*\" => stack.push(left\
    \ * right),\n            \"//\" => stack.push(left / right),\n            \"**\"\
    \ => stack.push(left.pow(right as u32)),\n            _ => unreachable!(),\n \
    \       }\n    }\n    stack.pop().unwrap()", "  // Write your code here\n  let\
    \ mut res = operand[0];\n  for i in 0..operator.len() {\n    match operator[i].as_str()\
    \ {\n      \"+\" => res += operand[i + 1],\n      \"-\" => res -= operand[i +\
    \ 1],\n      \"*\" => res *= operand[i + 1],\n      \"//\" => res /= operand[i\
    \ + 1],\n      \"**\" => res = res.pow(operand[i + 1] as u32),\n      _ => (),\n\
    \    }\n  }\n  res", "    (2..operand.len()).fold(operand[0], |acc, i| {\n   \
    \     acc.algebra(&operator[i - 1], operand[i])\n    })", "  let mut ret = 0;\n\
    \  let mut opr = 0;\n  let mut opr2 = 0;\n  let mut opr3 = 0;\n  let mut opr4\
    \ = 0;\n  let mut opr5 = 0;\n  let mut opr6 = 0;\n  let mut opr7 = 0;\n  let mut\
    \ opr8 = 0;\n  let mut opr9 = 0;\n  let mut opr10 = 0;\n  let mut opr11 = 0;\n\
    \  let mut opr12 = 0;\n  let mut opr13 = 0;\n  let mut opr14 = 0;\n  let mut opr15\
    \ = 0;\n  let mut opr16 = 0;\n  let mut opr17 = 0;\n  let mut opr18 = 0;\n  let\
    \ mut opr19 = 0;\n  let mut opr20 = 0;\n  let mut opr21 = 0;\n  let mut opr22\
    \ = 0;\n  let mut opr23 = 0;\n  let mut opr24 = 0;\n  let mut opr25 = 0;\n  let\
    \ mut opr26 = 0;\n  let mut opr27 = 0;\n  let mut opr28 = 0;\n  let mut opr29\
    \ = 0;\n  let mut opr30 = 0;\n  let mut opr31 = 0;\n  let mut opr32 = 0;\n  let\
    \ mut opr33 = 0;\n  let mut opr34 = 0;\n  let mut opr35 = 0;\n  let mut opr36\
    \ = 0;\n  let mut opr37 = 0;\n  let mut opr38 = 0;\n  let mut opr39 = 0;\n  let\
    \ mut opr40 = 0;\n  let mut opr41 = 0;\n  let mut opr42 = 0;\n  let mut opr43\
    \ = 0;\n  let mut opr44 = 0;\n  let mut opr45 = 0;\n  let mut opr46 = 0;\n  let\
    \ mut opr47 = 0;\n  let mut opr48 = 0;\n  let mut opr49 = 0;\n  let mut opr50\
    \ = 0;\n  let mut op", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i\
    \ + 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" =>\
    \ result *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n\
    \            \"**\" => result = result.pow(operand[i + 1] as u32),\n         \
    \   _ => (),\n        }\n    }\n    result", "    let mut result = operand[0];\n\
    \    for (i, op) in operator.iter().enumerate() {\n        match op.as_str() {\n\
    \            \"+\" => result += operand[i + 1],\n            \"-\" => result -=\
    \ operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n          \
    \  \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => result = 0,\n        }\n    }\n    result",
  "    let mut iter_operand = operand.iter();\n    iter_operand.next().unwrap().clone()",
  "    let mut operand = operand;\n    let mut result = operand.remove(0);\n    for\
    \ (i, op) in operator.iter().enumerate() {\n        match op.as_str() {\n    \
    \        \"+\" => result += operand[i],\n            \"-\" => result -= operand[i],\n\
    \            \"*\" => result *= operand[i],\n            \"//\" => result /= operand[i],\n\
    \            \"**\" => result = result.pow(operand[i] as u32),\n            _\
    \ => panic!(\"can not find op: {}\", op),\n        }\n    }\n    result", "  \
    \  let mut stack: Vec<isize> = Vec::new();\n    for i in 0..operand.len() - 1\
    \ {\n        let op = operator[i].as_str();\n        match op {\n            \"\
    +\" => {\n                let val = operand[i] + operand[i + 1];\n           \
    \     stack.push(val);\n            }\n            \"-\" => {\n              \
    \  let val = operand[i] - operand[i + 1];\n                stack.push(val);\n\
    \            }\n            \"*\" => {\n                let val = operand[i] *\
    \ operand[i + 1];\n                stack.push(val);\n            }\n         \
    \   \"//\" => {\n                let val = operand[i] / operand[i + 1];\n    \
    \            stack.push(val);\n            }\n            \"**\" => {\n      \
    \          let val = operand[i].pow(operand[i + 1] as u32);\n                stack.push(val);\n\
    \            }\n            _ => {\n                break;\n            }\n  \
    \      }\n    }\n    let mut sum = 0;\n    for i in 0..stack.len() {\n       \
    \ sum += stack[i];\n    }\n    sum", "    if operator.len() != operand.len() -\
    \ 1 {\n        panic!(\"The length of operator vector is equal to the length of\
    \ operand vector minus one\");\n    }\n    if operator.len() == 0 {\n        panic!(\"\
    Operator vector has at least one operator\");\n    }\n    if operand.len() < 2\
    \ {\n        panic!(\"Operand vector has at least two operands\");\n    }\n  \
    \  let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        if op == \"+\" {\n            result += operand[i + 1];\n       \
    \ } else if op == \"-\" {\n            result -= operand[i + 1];\n        } else\
    \ if op == \"*\" {\n            result *= operand[i + 1];\n        } else if op\
    \ == \"//\" {\n            result /= operand[i + 1];\n        } else if op ==\
    \ \"**\" {\n            result = result.pow(operand[i + 1] as u32);\n        }\
    \ else {\n            panic!(\"Unknown operation {:?}\", op);\n        }\n   \
    \ }\n    result", "    let ops = operator.iter().map(|s| match s.as_str() {\n\
    \        \"+\" => Operation::Add,\n        \"-\" => Operation::Sub,\n        \"\
    *\" => Operation::Mul,\n        \"/\" => Operation::Div,\n        \"^\" => Operation::Pow,\n\
    \        _ => unreachable!()\n    }).collect::<Vec<_>>();\n    (0..operand.len()\
    \ - 1).fold(operand[0], |acc, i| {\n        let op = ops[i];\n        let b =\
    \ operand[i + 1];\n        match op {\n            Operation::Add => acc + b,\n\
    \            Operation::Sub => acc - b,\n            Operation::Mul => acc * b,\n\
    \            Operation::Div => acc / b,\n            Operation::Pow => acc.pow(b\
    \ as u32),\n        }\n    })", "    if operator.len() != operand.len() - 1 {\n\
    \        return 0;\n    }\n    let mut n: isize = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => n += operand[i\
    \ + 1],\n            \"-\" => n -= operand[i + 1],\n            \"*\" => n *=\
    \ operand[i + 1],\n            \"//\" => n /= operand[i + 1],\n            \"\
    **\" => n = n.pow(operand[i + 1] as u32),\n            _ => return 0,\n      \
    \  }\n    }\n    n", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        if operator[i] == \"+\" {\n            result += operand[i + 1];\n\
    \        } else if operator[i] == \"-\" {\n            result -= operand[i + 1];\n\
    \        } else if operator[i] == \"*\" {\n            result *= operand[i + 1];\n\
    \        } else if operator[i] == \"//\" {\n            result /= operand[i +\
    \ 1];\n        } else if operator[i] == \"**\" {\n            result = result.pow(operand[i\
    \ + 1] as u32);\n        }\n    }\n    result", "    let mut operand = operand;\n\
    \    let mut result = operand.remove(0);\n    for (a, b) in operator.iter().zip(operand.iter())\
    \ {\n        result = match a.as_str() {\n            \"+\" => result + b,\n \
    \           \"-\" => result - b,\n            \"*\" => result * b,\n         \
    \   \"//\" => result / b,\n            \"**\" => result.pow(*b as u32),\n    \
    \        _ => 0,\n        }\n    }\n    result", "    operand.iter().fold(0, |acc,\
    \ x| {\n        acc.checked_add(x).and_then(|res| {\n            let op = operator.pop().unwrap();\n\
    \            if op == \"+\" {\n                Some(res)\n            } else if\
    \ op == \"-\" {\n                Some(-res)\n            } else if op == \"*\"\
    \ {\n                Some(res * operand.pop().unwrap())\n            } else if\
    \ op == \"//\" {\n                Some(res / operand.pop().unwrap())\n       \
    \     } else if op == \"**\" {\n                Some(res.pow(operand.pop().unwrap()\
    \ as u32))\n            } else {\n                None\n            }\n      \
    \  }).unwrap()\n    })", "    operand.into_iter().zip(operator.into_iter()).fold(0,\
    \ |acc, (a, b)| {\n        match b.as_str() {\n            \"+\" => acc + a,\n\
    \            \"-\" => acc - a,\n            \"*\" => acc * a,\n            \"\
    //\" => acc / a,\n            \"**\" => acc.pow(a as u32),\n            _ => acc,\n\
    \        }\n    })", "    let mut stack: Vec<isize> = Vec::new();\n    let mut\
    \ i = 0;\n    while i < operand.len() {\n        match &operator[i] as &str {\n\
    \            \"+\" => {\n                let op1 = stack.pop().unwrap();\n   \
    \             let op2 = operand[i + 1];\n                stack.push(op1 + op2);\n\
    \            }\n            \"-\" => {\n                let op1 = stack.pop().unwrap();\n\
    \                let op2 = operand[i + 1];\n                stack.push(op1 - op2);\n\
    \            }\n            \"*\" => {\n                let op1 = stack.pop().unwrap();\n\
    \                let op2 = operand[i + 1];\n                stack.push(op1 * op2);\n\
    \            }\n            \"//\" => {\n                let op1 = stack.pop().unwrap();\n\
    \                let op2 = operand[i + 1];\n                stack.push(op1 / op2);\n\
    \            }\n            \"**\" => {\n                let op1 = stack.pop().unwrap();\n\
    \                let op2 = operand[i + 1];\n                stack.push(op1.pow(op2\
    \ as u32));\n            }\n            _ => panic!(\"Unknown operator\"),\n \
    \       }\n        i += 1;\n    }\n    stack.pop().unwrap()", "    let mut result\
    \ = operand[0];\n    for i in 0..operator.len() {\n        let op = &operator[i];\n\
    \        let op2 = operand[i + 1];\n        match op.as_str() {\n            \"\
    +\" => result += op2,\n            \"-\" => result -= op2,\n            \"*\"\
    \ => result *= op2,\n            \"//\" => result /= op2,\n            \"**\"\
    \ => result = result.pow(op2 as u32),\n            _ => continue,\n        }\n\
    \    }\n    result", '    return 0;', '    unimplemented!();', "    let mut postfix:\
    \ Vec<String> = Vec::new();\n    let mut op_stack: Vec<String> = Vec::new();\n\
    \    let mut num_stack: Vec<isize> = Vec::new();\n    let mut result: isize =\
    \ 0;\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    let mut peek:\
    \ String = String::new();\n    let mut temp: String = String::new();\n    let\
    \ mut temp_num: isize = 0;\n    let mut temp_op: String = String::new();\n   \
    \ let precedence: HashMap<String, u8> = [(\"+\".to_string(), 1), (\"-\".to_string(),\
    \ 1), (\"*\".to_string(), 2), (\"/\".to_string(), 2), (\"%\".to_string(), 2),\
    \ (\"^\".to_string(), 3)].iter().cloned().collect();\n    while i < operator.len()\
    \ {\n        if operator[i] == \"(\" {\n            op_stack.push(operator[i].clone());\n\
    \        } else if operator[i] == \")\" {\n            while !op_stack.is_empty()\
    \ {\n                peek = op_stack.pop().unwrap();\n                if peek\
    \ == \"(\" {\n                    break;\n                }\n                postfix.push(peek.clone());\n\
    \            }\n        } else {\n            while !op_stack.is_empty() {\n \
    \               peek = op_stack.pop().unwrap();\n                if precedence[&peek]\
    \ > precedence[&operator[i]] {\n                    op_stack.push(peek.clone());\n\
    \                    break;\n                }\n                postfix.push(peek.clone());\n\
    \            }\n            op_stack.push(operator[i].clone());\n        }\n \
    \       i += 1;\n    }\n    while !op_stack.is_empty() {\n        peek = op_stack.pop().unwrap();\n\
    \        postfix.push(peek.clone());\n    }\n    while j < postfix.len() {\n \
    \       if postfix[j] == \"+\" {\n            num_stack.push(num_stack.pop().unwrap()\
    \ + num_stack.pop", "    if operator.len() != operand.len() - 1 {\n        panic!(\"\
    Invalid operand and operator\");\n    }\n    let mut counter = 0;\n    let mut\
    \ result = operand[counter];\n    while counter < operator.len() {\n        counter\
    \ += 1;\n        match operator[counter - 1].as_str() {\n            \"+\" =>\
    \ result += operand[counter],\n            \"-\" => result -= operand[counter],\n\
    \            \"*\" => result *= operand[counter],\n            \"//\" => result\
    \ /= operand[counter],\n            \"**\" => result = result.pow(operand[counter]\
    \ as u32),\n            _ => panic!(\"Invalid operator: {}\", operator[counter\
    \ - 1]),\n        }\n    }\n    result", "    let mut res = operand[0];\n    for\
    \ i in 0..operator.len() {\n        if operator[i] == \"+\" {\n            res\
    \ += operand[i + 1];\n        } else if operator[i] == \"-\" {\n            res\
    \ -= operand[i + 1];\n        } else if operator[i] == \"*\" {\n            res\
    \ *= operand[i + 1];\n        } else if operator[i] == \"//\" {\n            res\
    \ /= operand[i + 1];\n        } else if operator[i] == \"**\" {\n            res\
    \ = res.pow(operand[i + 1] as u32);\n        }\n    }\n    res", "    let mut\
    \ stack: Vec<isize> = Vec::new();\n    let mut result: isize = 0;\n    let op_list:\
    \ Vec<String> = vec![\"+\".to_string(), \"-\".to_string(), \"*\".to_string(),\
    \ \"//\".to_string(), \"**\".to_string()];\n    let operations: HashMap<&String,\
    \ &Fn(isize, isize) -> isize> = hashmap! {\n        \"+\" => &|first, second|\
    \ first + second,\n        \"-\" => &|first, second| first - second,\n       \
    \ \"*\" => &|first, second| first * second,\n        \"//\" => &|first, second|\
    \ first / second,\n        \"**\" => &|first, second| first.pow(second as u32)\n\
    \    };\n    stack.push(operand[0]);\n    for (i, v) in operator.iter().enumerate()\
    \ {\n        if !op_list.contains(v) {\n            continue;\n        }\n   \
    \     if stack.len() < 2 {\n            stack.push(operand[i+1]);\n          \
    \  continue;\n        }\n        let (first, second) = (stack.pop().unwrap(),\
    \ stack.pop().unwrap());\n        stack.push(operations[v](first, second));\n\
    \        stack.push(operand[i+1]);\n    }\n    while stack.len() > 1 {\n     \
    \   let (first, second) = (stack.pop().unwrap(), stack.pop().unwrap());\n    \
    \    stack.push(operations[\"+\"](first, second));\n    }\n    result = stack.pop().unwrap();\n\
    \    result", "    let mut r = operand[0];\n    for i in 0..operator.len() {\n\
    \        match operator[i].as_str() {\n            \"+\" => r += operand[i + 1],\n\
    \            \"-\" => r -= operand[i + 1],\n            \"*\" => r *= operand[i\
    \ + 1],\n            \"//\" => r /= operand[i + 1],\n            \"**\" => r =\
    \ r.pow(operand[i + 1] as u32),\n            _ => (),\n        }\n    }\n    r",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        let\
    \ op = &operator[i];\n        if op == \"+\" {\n            result += operand[i\
    \ + 1];\n        } else if op == \"-\" {\n            result -= operand[i + 1];\n\
    \        } else if op == \"*\" {\n            result *= operand[i + 1];\n    \
    \    } else if op == \"//\" {\n            result /= operand[i + 1];\n       \
    \ } else if op == \"**\" {\n            result = result.pow(operand[i + 1] as\
    \ u32);\n        }\n    }\n    result", "    // Build the algebra expression in\
    \ reverse polish notation\n    let mut expression = Vec::with_capacity(operand.len()\
    \ + operator.len());\n    for (i, _) in operand.iter().enumerate() {\n       \
    \ expression.push(operand[i]);\n        if i > 0 {\n            expression.push(match\
    \ operator[i - 1].as_str() {\n                \"+\" => Operator::Add,\n      \
    \          \"-\" => Operator::Sub,\n                \"*\" => Operator::Mul,\n\
    \                \"/\" => Operator::Div,\n                \"^\" => Operator::Pow,\n\
    \                _ => panic!(\"Wrong operator!\"),\n            });\n        }\n\
    \    }\n    // Evaluate the expression\n    expression.reverse();\n    let mut\
    \ stack = Vec::new();\n    for x in expression {\n        match x {\n        \
    \    Operator::Add => {\n                let v2 = stack.pop().unwrap();\n    \
    \            let v1 = stack.pop().unwrap();\n                stack.push(v1 + v2);\n\
    \            }\n            Operator::Sub => {\n                let v2 = stack.pop().unwrap();\n\
    \                let v1 = stack.pop().unwrap();\n                stack.push(v1\
    \ - v2);\n            }\n            Operator::Mul => {\n                let v2\
    \ = stack.pop().unwrap();\n                let v1 = stack.pop().unwrap();\n  \
    \              stack.push(v1 * v2);\n            }\n            Operator::Div\
    \ => {\n                let v2 = stack.pop().unwrap();\n                let v1\
    \ = stack.pop().unwrap();\n                stack.push(v1 / v2);\n            }\n\
    \            Operator::Pow => {\n                let v2 = stack.pop().unwrap();\n\
    \                let v1 = stack.pop().unwrap();\n                stack.push(v1.pow(v2\
    \ as u32));\n            }\n            Operand(x) => stack.push(x),\n       \
    \ }\n    }\n    stack.pop().unwrap()", "    let mut result = operand[0];\n   \
    \ for i in 0..operator.len() {\n        let op = &operator[i];\n        let op2\
    \ = operand[i + 1];\n        match op.as_str() {\n            \"+\" => result\
    \ += op2,\n            \"-\" => result -= op2,\n            \"*\" => result *=\
    \ op2,\n            \"//\" => result /= op2,\n            \"**\" => result = result.pow(op2\
    \ as u32),\n            _ => panic!(\"invalid operator '{}'\", op),\n        }\n\
    \    }\n    result", "    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"\
    Unknown operator\"),\n        }\n    }\n    result"]
stop_tokens:
- "\n}"
