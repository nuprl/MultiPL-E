name: HumanEval_160_do_algebra
language: rs
prompt: "/// Given two vectors operator, and operand. The first vector has basic algebra\
  \ operations, and \n/// the second vector is a vector of integers. Use the two given\
  \ vectors to build the algebric \n/// expression and return the evaluation of this\
  \ expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction\
  \ ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation\
  \ ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// vector = [2, 3, 4, 5]\n\
  /// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator\
  \ vector is equal to the length of operand vector minus one.\n/// Operand is a vector\
  \ of of non-negative integers.\n/// Operator vector has at least one operator, and\
  \ operand vector has at least two operands.\nfn do_algebra(operator: Vec<String>,\
  \ operand: Vec<isize>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"\
  **\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"\
  +\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\
  //\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"
completions: ["    // Write your code here\n    let mut eval_result = operand[0];\n\
    \    for i in 0..operand.len() - 1 {\n        if operator[i] == \"+\" {\n    \
    \        eval_result += operand[i + 1];\n        } else if operator[i] == \"-\"\
    \ {\n            eval_result -= operand[i + 1];\n        } else if operator[i]\
    \ == \"*\" {\n            eval_result *= operand[i + 1];\n        } else if operator[i]\
    \ == \"//\" {\n            eval_result /= operand[i + 1];\n        } else if operator[i]\
    \ == \"**\" {\n            eval_result = eval_result.pow(operand[i + 1] as u32);\n\
    \        }\n    }\n    eval_result", "    let mut  stack: Vec<isize> = Vec::new();\n\
    \    for (i, op) in operator.iter().enumerate() {\n        match op.as_str() {\n\
    \            \"+\" => {\n                let b = stack.pop().unwrap();\n     \
    \           let a = stack.pop().unwrap();\n                stack.push(a + b);\n\
    \            },\n            \"-\" => {\n                let b = stack.pop().unwrap();\n\
    \                let a = stack.pop().unwrap();\n                stack.push(a -\
    \ b);\n            },\n            \"*\" => {\n                let b = stack.pop().unwrap();\n\
    \                let a = stack.pop().unwrap();\n                stack.push(a *\
    \ b);\n            },\n            \"//\" => {\n                let b = stack.pop().unwrap();\n\
    \                let a = stack.pop().unwrap();\n                stack.push(a /\
    \ b);\n            },\n            \"**\" => {\n                let b = stack.pop().unwrap();\n\
    \                let a = stack.pop().unwrap();\n                stack.push(a.pow(b\
    \ as u32));\n            },\n            _ => (),\n        }\n        stack.push(operand[i+1]);\n\
    \    }\n    stack.pop().unwrap()", "    let mut it = operand.iter();\n    let\
    \ mut result = *it.next().unwrap();\n    for op in operator {\n        let x =\
    \ *it.next().unwrap();\n        match op.as_str() {\n            \"+\" => result\
    \ += x,\n            \"-\" => result -= x,\n            \"*\" => result *= x,\n\
    \            \"//\" => result /= x,\n            \"**\" => result = result.pow(x\
    \ as u32),\n            _ => {}\n        }\n    }\n    result", "    let mut total\
    \ = operand[0];\n    for i in 0..operand.len() - 1 {\n        match operator[i].as_str()\
    \ {\n            \"+\" => total += operand[i + 1],\n            \"-\" => total\
    \ -= operand[i + 1],\n            \"*\" => total *= operand[i + 1],\n        \
    \    \"//\" => total /= operand[i + 1],\n            \"**\" => total = total.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Unknown operator: {}\", operator[i])\n\
    \        }\n    }\n    total", "    operand.iter().zip(operator.iter()).fold(\n\
    \        operand[0],\n        |acc, (operand, op)| match op.as_str() {\n     \
    \       \"+\" => acc + operand,\n            \"-\" => acc - operand,\n       \
    \     \"*\" => acc * operand,\n            \"//\" => acc / operand,\n        \
    \    \"**\" => acc.pow(*operand as u32),\n            _ => panic!(\"Unknown operator\"\
    ),\n        },\n    )", "    let operator: Vec<char> = operator.iter().map(|s|\
    \ s.chars().next().unwrap()).collect();\n    let mut stack: Vec<isize> = Vec::new();\n\
    \    let mut operand_iter = operand.iter();\n    let mut op_iter = operator.iter();\n\
    \    let mut curr_operand = operand_iter.next().unwrap();\n    while let Some(op)\
    \ = op_iter.next() {\n        match op {\n            '+' => stack.push(*curr_operand),\n\
    \            '-' => stack.push(-*curr_operand),\n            '*' => stack.push(stack.pop().unwrap()\
    \ * *curr_operand),\n            '//' => stack.push(stack.pop().unwrap() / *curr_operand),\n\
    \            '^' => stack.push(stack.pop().unwrap().pow(*curr_operand as u32)),\n\
    \            _ => unreachable!(),\n        }\n        curr_operand = operand_iter.next().unwrap();\n\
    \    }\n    stack.push(*curr_operand);\n    stack.iter().sum()", "    let mut\
    \ result = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => (),\n        }\n    }\n    result", "  if operand.len()\
    \ == 0 { return 0; }\n  if operand.len() == 1 { return operand[0]; }\n  let mut\
    \ result = operand[0];\n  for i in 0..operator.len() {\n    let oper = operator[i].clone();\n\
    \    let next_val = operand[i+1];\n    match oper.as_str() {\n      \"+\" => result\
    \ += next_val,\n      \"-\" => result -= next_val,\n      \"*\" => result *= next_val,\n\
    \      \"//\" => result /= next_val,\n      \"**\" => result = result.pow(next_val\
    \ as u32),\n      _ => {},\n    }\n  }\n  result", "    if operator.len() != operand.len()\
    \ - 1 {\n        return 0;\n    }\n    let mut stack: Vec<isize> = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < operand.len() {\n     \
    \   stack.push(operand[i]);\n        if j < operator.len() {\n            match\
    \ operator[j].as_str() {\n                \"+\" => {\n                    stack.push(stack.pop().unwrap()\
    \ + stack.pop().unwrap());\n                }\n                \"-\" => {\n  \
    \                  let v1 = stack.pop().unwrap();\n                    let v2\
    \ = stack.pop().unwrap();\n                    stack.push(v2 - v1);\n        \
    \        }\n                \"*\" => {\n                    stack.push(stack.pop().unwrap()\
    \ * stack.pop().unwrap());\n                }\n                \"//\" => {\n \
    \                   let v1 = stack.pop().unwrap();\n                    let v2\
    \ = stack.pop().unwrap();\n                    stack.push(v2 / v1);\n        \
    \        }\n                \"**\" => {\n                    let v1 = stack.pop().unwrap();\n\
    \                    let v2 = stack.pop().unwrap();\n                    stack.push(v2.pow(v1\
    \ as u32));\n                }\n                _ => {}\n            }\n     \
    \       j += 1;\n        }\n        i += 1;\n    }\n    stack.pop().unwrap()",
  "    let mut output = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => output += operand[i + 1],\n   \
    \         \"-\" => output -= operand[i + 1],\n            \"*\" => output *= operand[i\
    \ + 1],\n            \"//\" => output /= operand[i + 1],\n            \"**\" =>\
    \ output = output.pow(operand[i + 1] as u32),\n            _ => panic!(\"unexpected\
    \ operator\"),\n        }\n    }\n    output", "    // check if the operator vector\
    \ is one smaller than the operand vector\n    assert_eq!(operator.len(), operand.len()\
    \ - 1);\n    // check if the operator vector has at least one operator\n    assert!(operator.len()\
    \ > 0);\n    // check if the operand vector has at least two operands\n    assert!(operand.len()\
    \ > 1);\n    // check if the operand vector has all non-negative integers\n  \
    \  assert!(operand.iter().all(|&num| num >= 0));\n\n    let mut result = operand[0];\n\
    \    for (idx, op) in operator.iter().enumerate() {\n        let left = operand[idx];\n\
    \        let right = operand[idx + 1];\n        match op.as_str() {\n        \
    \    \"+\" => result = left + right,\n            \"-\" => result = left - right,\n\
    \            \"*\" => result = left * right,\n            \"//\" => result = left\
    \ / right,\n            \"**\" => result = left.pow(right as u32),\n         \
    \   _ => panic!(\"Wrong operator format!\"),\n        }\n    }\n    result", " \
    \   let mut index = 0;\n    let mut operators = Vec::new();\n    let mut operands\
    \ = Vec::new();\n    for op in &operator {\n        if op == \"+\" {\n       \
    \     operators.push(1);\n        } else if op == \"-\" {\n            operators.push(2);\n\
    \        } else if op == \"*\" {\n            operators.push(3);\n        } else\
    \ if op == \"//\" {\n            operators.push(4);\n        } else if op == \"\
    **\" {\n            operators.push(5);\n        }\n    }\n    for num in &operand\
    \ {\n        operands.push(*num);\n    }\n    for op in &operators {\n       \
    \ if *op == 5 {\n            // **\n            let a = operands[index];\n   \
    \         let b = operands[index + 1];\n            operands[index] = a.pow(b\
    \ as u32);\n            operands.remove(index + 1);\n            operators.remove(index);\n\
    \        } else if *op == 4 {\n            // //\n            let a = operands[index];\n\
    \            let b = operands[index + 1];\n            operands[index] = a / b;\n\
    \            operands.remove(index + 1);\n            operators.remove(index);\n\
    \        } else if *op == 3 {\n            // *\n            let a = operands[index];\n\
    \            let b = operands[index + 1];\n            operands[index] = a * b;\n\
    \            operands.remove(index + 1);\n            operators.remove(index);\n\
    \        }\n    }\n    for op in &operators {\n        if *op == 2 {\n       \
    \     // -\n            let a = operands[index];\n            let b = operands[index\
    \ + 1];\n            operands[index] = a - b;\n            operands.remove(index\
    \ + 1);\n            operators.remove(index);\n        } else if *op == 1 {\n\
    \            // +\n            let a = operands[index];\n            let b = operands[index\
    \ + 1];\n            operands[index] = a + b;\n            operands.remove(index\
    \ + 1);\n            operators.", "    if operator.len() == 0 {\n        return\
    \ operand[0];\n    }\n    let mut idx = 0;\n    let mut stack = vec![];\n    for\
    \ op in operator {\n        match op.as_str() {\n            \"+\" => {\n    \
    \            let l = stack.pop().unwrap();\n                let r = operand[idx\
    \ + 1];\n                stack.push(l + r);\n            }\n            \"-\"\
    \ => {\n                let l = stack.pop().unwrap();\n                let r =\
    \ operand[idx + 1];\n                stack.push(l - r);\n            }\n     \
    \       \"*\" => {\n                let l = stack.pop().unwrap();\n          \
    \      let r = operand[idx + 1];\n                stack.push(l * r);\n       \
    \     }\n            \"/\" => {\n                let l = stack.pop().unwrap();\n\
    \                let r = operand[idx + 1];\n                stack.push(l / r);\n\
    \            }\n            \"^\" => {\n                let l = stack.pop().unwrap();\n\
    \                let r = operand[idx + 1];\n                stack.push(l.pow(r\
    \ as u32));\n            }\n            _ => panic!(\"Invalid operator!\"),\n\
    \        }\n        idx += 1;\n    }\n    stack.pop().unwrap()", "    let mut\
    \ op = operator.iter();\n    let mut opd = operand.iter();\n    let mut result\
    \ = opd.next().unwrap();\n    for (op, opd) in op.zip(opd) {\n        let mut\
    \ opd = *opd;\n        if op == &\"//\" {\n            opd = opd.floor();\n  \
    \      }\n        result = match op.as_str() {\n            \"+\" => result +\
    \ opd,\n            \"-\" => result - opd,\n            \"*\" => result * opd,\n\
    \            \"//\" => result / opd,\n            \"**\" => result.pow(opd as\
    \ u32),\n            _ => result,\n        };\n    }\n    result", "    let mut\
    \ operand = operand;\n    let mut result = operand.remove(0);\n    for (op, num)\
    \ in operator.iter().zip(operand) {\n        match op.as_str() {\n           \
    \ \"+\" => result += num,\n            \"-\" => result -= num,\n            \"\
    *\" => result *= num,\n            \"//\" => result /= num,\n            \"**\"\
    \ => result = result.pow(*num as u32),\n            _ => panic!(\"unknown operator:\
    \ {}\", op),\n        }\n    }\n    result", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => {}\n        }\n    }\n    result", "    let\
    \ mut x = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => x += operand[i + 1],\n            \"-\" => x -= operand[i\
    \ + 1],\n            \"*\" => x *= operand[i + 1],\n            \"//\" => x /=\
    \ operand[i + 1],\n            \"**\" => x = x.pow(operand[i + 1] as u32),\n \
    \           _ => (),\n        }\n    }\n    x", "  let mut stack: Vec<isize> =\
    \ Vec::new();\n  let mut idx = 0;\n  for op in operator {\n    stack.push(operand[idx]);\n\
    \    match op.as_str() {\n      \"+\" => {\n        let a = stack.pop().unwrap();\n\
    \        let b = stack.pop().unwrap();\n        stack.push(a + b);\n      },\n\
    \      \"-\" => {\n        let a = stack.pop().unwrap();\n        let b = stack.pop().unwrap();\n\
    \        stack.push(b - a);\n      },\n      \"*\" => {\n        let a = stack.pop().unwrap();\n\
    \        let b = stack.pop().unwrap();\n        stack.push(a * b);\n      },\n\
    \      \"//\" => {\n        let a = stack.pop().unwrap();\n        let b = stack.pop().unwrap();\n\
    \        stack.push(b / a);\n      },\n      \"**\" => {\n        let a = stack.pop().unwrap();\n\
    \        let b = stack.pop().unwrap();\n        stack.push(b.pow(a as u32));\n\
    \      },\n      _ => panic!(\"Invalid operator!\"),\n    }\n    idx += 1;\n \
    \ }\n  stack.pop().unwrap()", "    let op_iter = operator.iter();\n    let mut\
    \ operand_iter = operand.iter();\n    let a = *operand_iter.next().unwrap();\n\
    \    let b = *operand_iter.next().unwrap();\n    let mut result = do_op(a, b,\
    \ op_iter.next().unwrap());\n    for op in op_iter {\n        result = do_op(result,\
    \ *operand_iter.next().unwrap(), op);\n    }\n    result", "    let mut operand\
    \ = operand;\n    for op in operator {\n        match op.as_str() {\n        \
    \    \"+\" => {\n                let operand_0 = operand.remove(0);\n        \
    \        let operand_1 = operand.remove(0);\n                operand.insert(0,\
    \ operand_0 + operand_1);\n            }\n            \"-\" => {\n           \
    \     let operand_0 = operand.remove(0);\n                let operand_1 = operand.remove(0);\n\
    \                operand.insert(0, operand_0 - operand_1);\n            }\n  \
    \          \"*\" => {\n                let operand_0 = operand.remove(0);\n  \
    \              let operand_1 = operand.remove(0);\n                operand.insert(0,\
    \ operand_0 * operand_1);\n            }\n            \"//\" => {\n          \
    \      let operand_0 = operand.remove(0);\n                let operand_1 = operand.remove(0);\n\
    \                operand.insert(0, operand_0 / operand_1);\n            }\n  \
    \          \"**\" => {\n                let operand_0 = operand.remove(0);\n \
    \               let operand_1 = operand.remove(0);\n                operand.insert(0,\
    \ operand_0.pow(operand_1 as u32));\n            }\n            _ => panic!(\"\
    invalid operator\"),\n        }\n    }\n    return operand[0];"]
stop_tokens:
- "\n}"
