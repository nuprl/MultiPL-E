name: HumanEval_124_valid_date
language: rs
prompt: "/// You have to write a function which validates a given date string and\n\
  /// returns true if the date is valid otherwise false.\n/// The date is valid if\
  \ all of the following rules are satisfied:\n/// 1. The date string is not empty.\n\
  /// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\
  \ And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\
  \ And, the number of days is not less than 1 or higher than 29 for the month 2.\n\
  /// 3. The months should not be less than 1 or higher than 12.\n/// 4. The date\
  \ should be in the format: mm-dd-yyyy\n/// >>> valid_date(String::from(\"03-11-2000\"\
  ))\n/// true\n/// >>> valid_date(String::from(\"15-01-2012\"))\n/// false\n/// >>>\
  \ valid_date(String::from(\"04-0-2040\"))\n/// false\n/// >>> valid_date(String::from(\"\
  06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"06/04/2020\"))\n///\
  \ false\nfn valid_date(date: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
  03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
  \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
  06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
  \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
  \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
  \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
  21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")),\
  \ true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
  20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
  \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
  04-2003\")), false);\n}\n"
completions: ["    if date.is_empty() {\n        return false;\n    }\n    let date_split:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_split.len() != 3 {\n \
    \       return false;\n    }\n    let day: i32 = date_split[1].parse().unwrap();\n\
    \    let month: i32 = date_split[0].parse().unwrap();\n    let year: i32 = date_split[2].parse().unwrap();\n\
    \    if day <= 0 || day > 31 || month <= 0 || month > 12 || year <= 0 {\n    \
    \    return false;\n    }\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 |\
    \ 12 => return day <= 31,\n        4 | 6 | 9 | 11 => return day <= 30,\n     \
    \   2 => {\n            if year % 4 == 0 {\n                return day <= 29;\n\
    \            } else {\n                return day <= 28;\n            }\n    \
    \    }\n        _ => return false,\n    }", "    let mut v: Vec<&str> = date.split(\"\
    -\").collect();\n    let m = v.pop().unwrap();\n    let d = v.pop().unwrap();\n\
    \    let y = v.pop().unwrap();\n    if y.len() != 4 {\n        return false;\n\
    \    }\n    let m = match m.parse::<u32>() {\n        Ok(m) => m,\n        Err(_)\
    \ => return false,\n    };\n    let d = match d.parse::<u32>() {\n        Ok(d)\
    \ => d,\n        Err(_) => return false,\n    };\n    let y = match y.parse::<u32>()\
    \ {\n        Ok(y) => y,\n        Err(_) => return false,\n    };\n    if m <\
    \ 1 || m > 12 {\n        return false;\n    }\n    match m {\n        1 | 3 |\
    \ 5 | 7 | 8 | 10 | 12 => {\n            if d < 1 || d > 31 {\n               \
    \ return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n     \
    \       if d < 1 || d > 30 {\n                return false;\n            }\n \
    \       }\n        2 => {\n            if y % 4 == 0 {\n                if d <\
    \ 1 || d > 29 {\n                    return false;\n                }\n      \
    \      } else {\n                if d < 1 || d > 28 {\n                    return\
    \ false;\n                }\n            }\n        }\n        _ => return false,\n\
    \    }\n    true", "    use regex::Regex;\n    use std::cmp::Ordering;\n\n   \
    \ let re = Regex::new(r\"^(?P<month>0[1-9]|1[0-2])-(?P<day>0[1-9]|[12][0-9]|3[01])-(?P<year>[0-9]{4})$\"\
    ).unwrap();\n    let caps = re.captures(&date);\n    if caps.is_none() {\n   \
    \     return false;\n    }\n    let caps = caps.unwrap();\n    let month = caps.name(\"\
    month\").unwrap().as_str().parse::<u32>().unwrap();\n    let day = caps.name(\"\
    day\").unwrap().as_str().parse::<u32>().unwrap();\n    let year = caps.name(\"\
    year\").unwrap().as_str().parse::<u32>().unwrap();\n    let month_days = [31,\
    \ 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if month > 12 {\n        return\
    \ false;\n    }\n    let max_day = match month {\n        2 => {\n           \
    \ if year % 4 == 0 {\n                month_days[month as usize - 1]\n       \
    \     } else {\n                month_days[month as usize - 1] - 1\n         \
    \   }\n        }\n        _ => month_days[month as usize - 1],\n    };\n    if\
    \ day < 1 || day > max_day {\n        return false;\n    }\n    let current_date\
    \ = NaiveDate::from_ymd(Local::today().year(), Local::today().month(), Local::today().day());\n\
    \    let input_date = NaiveDate::from_ymd(year, month, day);\n    if input_date.cmp(&current_date)\
    \ == Ordering::Greater {\n        return false;\n    }\n    true", "    let input\
    \ = date.clone();\n    let date = date.replace(\"-\", \"/\");\n    let date =\
    \ date.replace(\" \", \"\");\n    let date = date.split(\"/\").collect::<Vec<&str>>();\n\
    \    // the date string is not empty\n    if date.len() < 3 {\n        return\
    \ false;\n    }\n    let day = date[1].parse::<i32>().unwrap();\n    let month\
    \ = date[0].parse::<i32>().unwrap();\n    let year = date[2].parse::<i32>().unwrap();\n\
    \    let mut months: Vec<i32> = vec![1, 3, 5, 7, 8, 10, 12];\n    if day > 31\
    \ || day < 1 {\n        return false;\n    }\n    if months.contains(&month) {\n\
    \        //the number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12\n        if day > 31 {\n            return false;\n        }\n\
    \    } else {\n        // the number of days is not less than 1 or higher than\
    \ 30 days for months 4,6,9,11\n        if !(vec![4, 6, 9, 11].contains(&month))\
    \ {\n            // the number of days is not less than 1 or higher than 29 for\
    \ the month 2\n            if day > 29 {\n                return false;\n    \
    \        }\n        } else {\n            if day > 30 {\n                return\
    \ false;\n            }\n        }\n    }\n    //the months should not be less\
    \ than 1 or higher than 12\n    if month > 12 || month < 1 {\n        return false;\n\
    \    }\n    // the date should be in the format: mm-dd-yyyy\n    if input.len()\
    \ != 10 {\n        return false;\n    }\n    return true;", "    let re = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\d{4}$\").unwrap();\n    if !re.is_match(&date)\
    \ {\n        return false;\n    }\n    let month = date[0..2].parse::<i32>().unwrap();\n\
    \    let day = date[3..5].parse::<i32>().unwrap();\n    match month {\n      \
    \  2 => {\n            if day > 29 {\n                return false;\n        \
    \    }\n        }\n        4 | 6 | 9 | 11 => {\n            if day > 30 {\n  \
    \              return false;\n            }\n        }\n        1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => {\n            if day > 31 {\n                return false;\n\
    \            }\n        }\n        _ => return false,\n    }\n    true", '    unimplemented!()',
  "    // Your code here\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n    if !re.is_match(&date) {\n        return false;\n    }\n\
    \    let date_vec: Vec<&str> = date.split(\"-\").collect();\n    let month = date_vec[0].parse::<u8>().unwrap();\n\
    \    let day = date_vec[1].parse::<u8>().unwrap();\n    let year = date_vec[2].parse::<u16>().unwrap();\n\
    \    if month == 2 {\n        if year % 4 == 0 && year % 100 != 0 || year % 400\
    \ == 0 {\n            return day <= 29;\n        } else {\n            return\
    \ day <= 28;\n        }\n    } else if month == 4 || month == 6 || month == 9\
    \ || month == 11 {\n        return day <= 30;\n    } else {\n        return day\
    \ <= 31;\n    }", "    if date.len() == 0 {\n        return false;\n    }\n  \
    \  let split_date: Vec<&str> = date.split(\"-\").collect();\n    if split_date.len()\
    \ != 3 {\n        return false;\n    }\n    let month = match split_date[0].parse::<i32>()\
    \ {\n        Ok(n) => n,\n        Err(_) => return false,\n    };\n    let day\
    \ = match split_date[1].parse::<i32>() {\n        Ok(n) => n,\n        Err(_)\
    \ => return false,\n    };\n    let year = match split_date[2].parse::<i32>()\
    \ {\n        Ok(n) => n,\n        Err(_) => return false,\n    };\n    if month\
    \ == 2 {\n        return day <= 29 && day >= 1;\n    }\n    if month % 2 == 0\
    \ {\n        return day <= 30 && day >= 1;\n    }\n    day <= 31 && day >= 1",
  "    // parse date string\n    let mut d = date.split(\"-\");\n    let m = d.next().unwrap().parse::<u32>().unwrap();\n\
    \    let d = d.next().unwrap().parse::<u32>().unwrap();\n    let y = d.next().unwrap().parse::<u32>().unwrap();\n\
    \n    // validate month\n    if m < 1 || m > 12 {\n        return false;\n   \
    \ }\n\n    // validate days\n    let d_max = match m {\n        1|3|5|7|8|10|12\
    \ => 31,\n        4|6|9|11 => 30,\n        2 => 29,\n        _ => 0,\n    };\n\
    \    if d < 1 || d > d_max {\n        return false;\n    }\n\n    true", "   \
    \ if date.len() != 10 {\n        return false;\n    }\n    if !date.contains(\"\
    -\") {\n        return false;\n    }\n    let parts: Vec<&str> = date.split(\"\
    -\").collect();\n    if parts.len() != 3 {\n        return false;\n    }\n   \
    \ let month: u32 = parts[0].parse().unwrap();\n    let day: u32 = parts[1].parse().unwrap();\n\
    \    let year: u32 = parts[2].parse().unwrap();\n    if !(1..=12).contains(&month)\
    \ {\n        return false;\n    }\n    if !(1..=31).contains(&day) {\n       \
    \ return false;\n    }\n    if (1..=12).contains(&month) {\n        match month\
    \ {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n                if day < 1\
    \ || day > 31 {\n                    return false;\n                }\n      \
    \      }\n            4 | 6 | 9 | 11 => {\n                if day < 1 || day >\
    \ 30 {\n                    return false;\n                }\n            }\n\
    \            2 => {\n                if day < 1 || day > 29 {\n              \
    \      return false;\n                }\n            }\n            _ => return\
    \ false,\n        }\n    }\n    true", "    // Write your code here\n    false",
  '    unimplemented!();', '    true', "    if date.len() != 10 {\n        return\
    \ false;\n    }\n    let str_arr: Vec<&str> = date.split(\"-\").collect();\n \
    \   let mm: i32 = str_arr[0].parse().unwrap();\n    let dd: i32 = str_arr[1].parse().unwrap();\n\
    \    let yyyy: i32 = str_arr[2].parse().unwrap();\n    if mm < 1 || mm > 12 {\n\
    \        return false;\n    }\n    if yyyy < 1000 || yyyy > 9999 {\n        return\
    \ false;\n    }\n    if dd < 1 || dd > 31 {\n        return false;\n    }\n  \
    \  if mm == 2 && dd > 29 {\n        return false;\n    }\n    if (mm == 4 || mm\
    \ == 6 || mm == 9 || mm == 11) && dd > 30 {\n        return false;\n    }\n  \
    \  true", "    // This is one way to split a string.\n    let date_fields: Vec<&str>\
    \ = date.split(\"-\").collect();\n    if date_fields.len() != 3 {\n        return\
    \ false;\n    }\n    // This is another way to split a string.\n    let date_fields:\
    \ Vec<u32> = date.split(\"-\").map(|x| x.parse::<u32>().unwrap()).collect();\n\
    \    if date_fields.len() != 3 {\n        return false;\n    }\n    // This is\
    \ the third way to split a string.\n    let date_fields: Vec<u32> = date.split(\"\
    -\").filter_map(|x| x.parse::<u32>().ok()).collect();\n    if date_fields.len()\
    \ != 3 {\n        return false;\n    }\n    let month = date_fields[0];\n    let\
    \ day = date_fields[1];\n    let year = date_fields[2];\n    if month > 12 ||\
    \ month < 1 {\n        return false;\n    }\n    if day > 31 || day < 1 {\n  \
    \      return false;\n    }\n    if month == 2 && day > 29 {\n        return false;\n\
    \    }\n    if month % 2 == 0 && day > 30 {\n        return false;\n    }\n  \
    \  if month % 2 == 1 && day > 31 {\n        return false;\n    }\n    if year\
    \ < 1900 || year > 2050 {\n        return false;\n    }\n    true", "    let v:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if v.len() != 3 {\n        return\
    \ false;\n    }\n    let d = v[0].parse::<i32>().unwrap();\n    let m = v[1].parse::<i32>().unwrap();\n\
    \    let y = v[2].parse::<i32>().unwrap();\n    if y < 0 {\n        return false;\n\
    \    }\n    if m < 1 || m > 12 {\n        return false;\n    }\n    if m == 2\
    \ {\n        if y % 4 == 0 {\n            if d < 1 || d > 29 {\n             \
    \   return false;\n            }\n        } else {\n            if d < 1 || d\
    \ > 28 {\n                return false;\n            }\n        }\n    } else\
    \ if m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 {\n\
    \        if d < 1 || d > 31 {\n            return false;\n        }\n    } else\
    \ {\n        if d < 1 || d > 30 {\n            return false;\n        }\n    }\n\
    \    true", '    unimplemented!()', "    let re = Regex::new(r\"((?P<day>\\d{2})-(?P<month>\\\
    d{2})-(?P<year>\\d{4}))\").unwrap();\n    let mut is_valid = true;\n    if re.is_match(&date)\
    \ {\n        let re_captures = re.captures(&date).unwrap();\n        let day =\
    \ re_captures[\"day\"].parse::<u32>().unwrap();\n        let month = re_captures[\"\
    month\"].parse::<u32>().unwrap();\n        let year = re_captures[\"year\"].parse::<u32>().unwrap();\n\
    \        let is_leap_year = year % 4 == 0;\n        if !((1..=12).contains(&month))\
    \ || !((1..=31).contains(&day)) {\n            is_valid = false;\n        } else\
    \ if !((1..=30).contains(&day) && (vec![4, 6, 9, 11]).contains(&month))\n    \
    \        && !((1..=29).contains(&day) && month == 2 && is_leap_year)\n       \
    \     && !((1..=28).contains(&day) && month == 2 && !is_leap_year)\n        {\n\
    \            is_valid = false;\n        }\n    } else {\n        is_valid = false;\n\
    \    }\n    is_valid", "    let mut it = date.split('-');\n    let date = it.next();\n\
    \    let month = it.next();\n    let year = it.next();\n    if date.is_none()\
    \ || month.is_none() || year.is_none() {\n        return false;\n    }\n    let\
    \ date = date.unwrap();\n    let month = month.unwrap();\n    let year = year.unwrap();\n\
    \    match date.parse::<u8>() {\n        Ok(date) => match month.parse::<u8>()\
    \ {\n            Ok(month) => match year.parse::<u16>() {\n                Ok(year)\
    \ => {\n                    let mut days = 30;\n                    if month ==\
    \ 2 {\n                        days = 29;\n                    } else if month\
    \ == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10\
    \ || month == 12 {\n                        days = 31;\n                    }\n\
    \                    if month < 1 || month > 12 {\n                        return\
    \ false;\n                    }\n                    if date < 1 || date > days\
    \ {\n                        return false;\n                    }\n          \
    \          return true;\n                }\n                Err(_) => false,\n\
    \            },\n            Err(_) => false,\n        },\n        Err(_) => false,\n\
    \    }", "    let mut v: Vec<&str> = date.split(\"-\").collect();\n    // date\
    \ string is not empty\n    if v.len() != 3 {\n        return false;\n    }\n \
    \   // valid date format\n    for i in 0..v.len() {\n        if v[i].len() !=\
    \ 2 {\n            return false;\n        }\n    }\n    let mut m = v[0].parse::<u8>().unwrap();\n\
    \    let mut d = v[1].parse::<u8>().unwrap();\n    let y = v[2].parse::<u32>().unwrap();\n\
    \    // valid year\n    if y < 1000 || y > 9999 {\n        return false;\n   \
    \ }\n    // months should not be less than 1 or higher than 12\n    if m < 1 ||\
    \ m > 12 {\n        return false;\n    }\n    // number of days is not less than\
    \ 1 or higher than 31 days for months 1,3,5,7,8,10,12\n    if m == 1 || m == 3\
    \ || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 {\n        if d < 1 || d\
    \ > 31 {\n            return false;\n        }\n    }\n    // the number of days\
    \ is not less than 1 or higher than 30 days for months 4,6,9,11\n    if m == 4\
    \ || m == 6 || m == 9 || m == 11 {\n        if d < 1 || d > 30 {\n           \
    \ return false;\n        }\n    }\n    // the number of days is not less than\
    \ 1 or higher than 29 for the month 2\n    if m == 2 {\n        if d < 1 || d\
    \ > 29 {\n            return false;\n        }\n    }\n    // for leap year\n\
    \    if m == 2 && d == 29 {\n        if y % 4 == 0 {\n            if y % 100 ==\
    \ 0 {\n                if y % 400 == 0 {\n                    return true;\n \
    \               } else {\n                    return false;\n                }\n\
    \            } else {\n                return true;\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n    true", '    unimplemented!();',
  "    lazy_static! {\n        static ref RE: Regex = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\"\
    ).unwrap();\n    }\n    if !RE.is_match(&date) {\n        return false;\n    }\n\
    \    let caps = RE.captures(&date).unwrap();\n    let month = caps[1].parse::<u32>().unwrap();\n\
    \    let day = caps[2].parse::<u32>().unwrap();\n    let year = caps[3].parse::<u32>().unwrap();\n\
    \    if month > 12 || month < 1 {\n        return false;\n    }\n    if month\
    \ == 2 {\n        if day > 29 || day < 1 {\n            return false;\n      \
    \  }\n    } else if month % 2 == 0 {\n        if day > 30 || day < 1 {\n     \
    \       return false;\n        }\n    } else {\n        if day > 31 || day < 1\
    \ {\n            return false;\n        }\n    }\n    if year < 1900 || year >\
    \ 9999 {\n        return false;\n    }\n    true", "    // TODO: Write your code\
    \ here\n    false", "    let mut result = true;\n    let date_split: Vec<_> =\
    \ date.split(\"-\").collect();\n    if date_split.len() != 3 {\n        result\
    \ = false;\n    } else {\n        let (day, month, year) = (date_split[0].parse::<i32>().unwrap(),\
    \ date_split[1].parse::<i32>().unwrap(), date_split[2].parse::<i32>().unwrap());\n\
    \        if day > 31 || day < 1 || month > 12 || month < 1 || year < 1 {\n   \
    \         result = false;\n        } else {\n            match month {\n     \
    \           4 | 6 | 9 | 11 => if day > 30 {\n                    result = false;\n\
    \                },\n                2 => if day > 29 {\n                    result\
    \ = false;\n                },\n                _ => (),\n            }\n    \
    \    }\n    }\n    result", "    date.is_empty()\n        || date.matches(r\"\
    ([0-2][0-9]|[3][0-1])\\-(0[1-9]|1[0-2])\\-\\d{4}\")\n            .count()\n  \
    \          == 0", "    if !date.contains(\"-\") {\n        return false;\n   \
    \ }\n    let vec: Vec<&str> = date.split(\"-\").collect();\n    if vec.len() !=\
    \ 3 {\n        return false;\n    }\n    let m: u32 = vec[0].parse().unwrap();\n\
    \    let d: u32 = vec[1].parse().unwrap();\n    let y: u32 = vec[2].parse().unwrap();\n\
    \    match m {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if d < 1\
    \ || d > 31 {\n                return false;\n            }\n        }\n     \
    \   4 | 6 | 9 | 11 => {\n            if d < 1 || d > 30 {\n                return\
    \ false;\n            }\n        }\n        2 => {\n            if y % 4 == 0\
    \ {\n                if d < 1 || d > 29 {\n                    return false;\n\
    \                }\n            } else {\n                if d < 1 || d > 28 {\n\
    \                    return false;\n                }\n            }\n       \
    \ }\n        _ => return false,\n    }\n    if m < 1 || m > 12 {\n        return\
    \ false;\n    }\n    return true;", '    true', "    if date.is_empty() {\n  \
    \      return false;\n    }\n    let parts: Vec<&str> = date.split('-').collect();\n\
    \    if parts.len() != 3 {\n        return false;\n    }\n    let month: i32 =\
    \ parts[0].parse().unwrap();\n    let day: i32 = parts[1].parse().unwrap();\n\
    \    let year: i32 = parts[2].parse().unwrap();\n    if month < 1 || month > 12\
    \ {\n        return false;\n    }\n    let max_day = if month == 2 {\n       \
    \ if year % 4 == 0 {\n            29\n        } else {\n            28\n     \
    \   }\n    } else if month == 1 || month == 3 || month == 5 || month == 7 || month\
    \ == 8 || month == 10 || month == 12 {\n        31\n    } else {\n        30\n\
    \    };\n    if day < 1 || day > max_day {\n        return false;\n    }\n   \
    \ true", "    if date.contains(\"/\") {\n        return false;\n    }\n    let\
    \ mut parts = date.split(\"-\");\n    let month: i32 = parts.next().unwrap().parse().unwrap();\n\
    \    let day: i32 = parts.next().unwrap().parse().unwrap();\n    let year: i32\
    \ = parts.next().unwrap().parse().unwrap();\n    if month < 1 || month > 12 {\n\
    \        return false;\n    }\n    if month == 2 {\n        if year % 4 == 0 {\n\
    \            if day < 1 || day > 29 {\n                return false;\n       \
    \     }\n        } else {\n            if day < 1 || day > 28 {\n            \
    \    return false;\n            }\n        }\n    } else if month == 4 || month\
    \ == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n    \
    \        return false;\n        }\n    } else {\n        if day < 1 || day > 31\
    \ {\n            return false;\n        }\n    }\n    true", "    // your code\
    \ here\n    let mut split = date.split(\"-\");\n    let year: i32 = split.next().unwrap().parse().unwrap();\n\
    \    let month: i32 = split.next().unwrap().parse().unwrap();\n    let day: i32\
    \ = split.next().unwrap().parse().unwrap();\n    if year < 0 || month < 1 || month\
    \ > 12 || day < 1 || day > 31 {\n        return false;\n    }\n    if month ==\
    \ 4 || month == 6 || month == 9 || month == 11 {\n        if day > 30 {\n    \
    \        return false;\n        }\n    }\n    if month == 2 {\n        if day\
    \ > 29 {\n            return false;\n        }\n    }\n    true", "    const MONTH_DAYS:\
    \ [i32; 12] = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut date_elems:\
    \ Vec<&str> = date.split('-').collect();\n    if date_elems.len() != 3 {\n   \
    \     return false;\n    }\n    let mut month = date_elems[0].parse::<i32>().unwrap();\n\
    \    let mut day = date_elems[1].parse::<i32>().unwrap();\n    let year = date_elems[2].parse::<i32>().unwrap();\n\
    \    if year < 0 {\n        return false;\n    }\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    if day < 1 || day > MONTH_DAYS[(month\
    \ - 1) as usize] {\n        return false;\n    }\n    month == day", "    if date.is_empty()\
    \ {\n        return false;\n    }\n    let v: Vec<_> = date.split('-').collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    if let Ok(m) = v[0].parse::<i64>()\
    \ {\n        if m < 1 || m > 12 {\n            return false;\n        }\n    }\
    \ else {\n        return false;\n    }\n    if let Ok(d) = v[1].parse::<i64>()\
    \ {\n        if d < 1 || d > 31 {\n            return false;\n        }\n    }\
    \ else {\n        return false;\n    }\n    if let Ok(y) = v[2].parse::<i64>()\
    \ {\n        if y < 0 {\n            return false;\n        }\n    } else {\n\
    \        return false;\n    }\n    true", "    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let dates = date.split(\"-\").collect::<Vec<&str>>();\n \
    \   if dates.len() != 3 {\n        return false;\n    }\n    let day = dates[1].parse::<i32>().unwrap();\n\
    \    let month = dates[0].parse::<i32>().unwrap();\n    let year = dates[2].parse::<i32>().unwrap();\n\
    \    let days = match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,\n  \
    \      4 | 6 | 9 | 11 => 30,\n        2 => 28,\n        _ => -1,\n    };\n   \
    \ if day < 1 || day > days || month < 1 || month > 12 {\n        return false;\n\
    \    }\n    if year < 1 {\n        return false;\n    }\n    return true;", " \
    \   let date = date.trim();\n    let length = date.len();\n    let mut is_valid\
    \ = false;\n    if length != 10 {\n        return is_valid;\n    }\n    let words:\
    \ Vec<&str> = date.split('-').collect();\n    let month: u32 = words[0].parse().unwrap();\n\
    \    let day: u32 = words[1].parse().unwrap();\n    let year: u32 = words[2].parse().unwrap();\n\
    \    if year < 2000 {\n        return is_valid;\n    }\n    if month > 12 {\n\
    \        return is_valid;\n    }\n    match month {\n        1 | 3 | 5 | 7 | 8\
    \ | 10 | 12 => {\n            if day < 32 {\n                is_valid = true;\n\
    \            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day < 31\
    \ {\n                is_valid = true;\n            }\n        }\n        2 =>\
    \ {\n            if day < 30 {\n                is_valid = true;\n           \
    \ }\n        }\n        _ => {}\n    }\n    is_valid", "    let v: Vec<&str> =\
    \ date.split(\"-\").collect();\n    if v.len() != 3 {\n        return false;\n\
    \    }\n    let month: u32 = v[0].parse().unwrap();\n    let day: u32 = v[1].parse().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    match month\
    \ {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day < 1 || day >\
    \ 31 {\n                return false;\n            }\n        }\n        4 | 6\
    \ | 9 | 11 => {\n            if day < 1 || day > 30 {\n                return\
    \ false;\n            }\n        }\n        2 => {\n            if day < 1 ||\
    \ day > 29 {\n                return false;\n            }\n        }\n      \
    \  _ => {}\n    }\n    true", "    let months = [\"31\", \"30\", \"29\", \"31\"\
    , \"30\", \"31\", \"31\", \"31\", \"30\", \"31\", \"30\", \"31\"];\n    let d:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date.len() == 0 || d.len()\
    \ != 3 {\n        return false;\n    }\n    let month = d[0].parse::<i64>().unwrap();\n\
    \    let day = d[1].parse::<i64>().unwrap();\n    let year = d[2].parse::<i64>().unwrap();\n\
    \    if month < 1 || month > 12 || day < 1 || day > 31 || year < 0 {\n       \
    \ return false;\n    }\n    let days = months[(month - 1) as usize];\n    days.parse::<i64>().unwrap()\
    \ >= day", "    if date.is_empty() {\n        return false;\n    }\n    let months\
    \ = [\n        \"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jul\",\
    \ \"aug\", \"sep\", \"oct\", \"nov\", \"dec\",\n    ];\n    let split: Vec<&str>\
    \ = date.split(\"-\").collect();\n    if split.len() != 3 {\n        return false;\n\
    \    }\n    let mm: String = split[0].to_string();\n    let dd: String = split[1].to_string();\n\
    \    let yyyy: String = split[2].to_string();\n    let mm_u32: u32 = match mm.parse()\
    \ {\n        Ok(num) => num,\n        Err(_) => {\n            return false;\n\
    \        }\n    };\n    let dd_u32: u32 = match dd.parse() {\n        Ok(num)\
    \ => num,\n        Err(_) => {\n            return false;\n        }\n    };\n\
    \    let yyyy_u32: u32 = match yyyy.parse() {\n        Ok(num) => num,\n     \
    \   Err(_) => {\n            return false;\n        }\n    };\n    if !months.contains(&mm.to_lowercase().as_str())\
    \ {\n        return false;\n    }\n    if yyyy_u32 < 2000 || yyyy_u32 > 2020 {\n\
    \        return false;\n    }\n    match mm_u32 {\n        1 | 3 | 5 | 7 | 8 |\
    \ 10 | 12 => {\n            if dd_u32 < 1 || dd_u32 > 31 {\n                return\
    \ false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if\
    \ dd_u32 < 1 || dd_u32 > 30 {\n                return false;\n            }\n\
    \        }\n        2 => {\n            if dd_u32 < 1 || dd_u32 > 29 {\n     \
    \           return false;\n            }\n        }\n        _ => return false,\n\
    \    }\n    true", "    let mut valid_date = false;\n    let mut valid_day = false;\n\
    \    let mut valid_month = false;\n    let mut valid_year = false;\n    let mut\
    \ is_leap_year = false;\n    let mut days_in_month = 0;\n    let mut valid_format\
    \ = false;\n    let mut tokens: Vec<&str> = Vec::new();\n    let mut chars: Vec<char>\
    \ = Vec::new();\n    let mut date_string = String::new();\n    let mut date_chars:\
    \ Vec<char> = Vec::new();\n    let mut year_string = String::new();\n    let mut\
    \ year_chars: Vec<char> = Vec::new();\n    let mut month_string = String::new();\n\
    \    let mut month_chars: Vec<char> = Vec::new();\n    let mut day_string = String::new();\n\
    \    let mut day_chars: Vec<char> = Vec::new();\n    if date.is_empty() {\n  \
    \      valid_date = false;\n    } else {\n        for i in date.chars() {\n  \
    \          chars.push(i);\n        }\n        for i in 0..chars.len() {\n    \
    \        if chars[i] == '-' {\n                valid_format = true;\n        \
    \    }\n        }\n        if valid_format {\n            tokens = date.split(\"\
    -\").collect();\n            for i in 0..tokens.len() {\n                for j\
    \ in 0..tokens[i].len() {\n                    date_string.push(tokens[i].chars().nth(j).unwrap());\n\
    \                }\n                if i == 0 {\n                    month_string\
    \ = date_string.clone();\n                } else if i == 1 {\n               \
    \     day_string = date_string.clone();\n                } else if i == 2 {\n\
    \                    year_string = date_string.clone();\n                }\n \
    \               date_string.clear();\n            }\n            for i in 0..month_string.len()\
    \ {\n                month_chars.push(month_string.chars().nth(i).unwrap());\n\
    \            }\n            for i in 0..day_string", "    lazy_static! {\n   \
    \     static ref DATE_REGEX: Regex = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-(\\\
    d{4})$\").unwrap();\n    }\n    DATE_REGEX.is_match(&date)", "    // the first\
    \ thing to do is to check if the string is empty.\n    if date.is_empty() {\n\
    \        return false;\n    }\n    // the second thing to do is to check if the\
    \ string is in the proper format: mm-dd-yyyy.\n    // we can get rid of the dashes\
    \ with the replace function,\n    // and then check if the string consists of\
    \ only numbers.\n    let numbers: Vec<char> = vec!['0', '1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9'];\n    if !date.replace(\"-\", \"\").chars().all(|x| numbers.contains(&x))\
    \ {\n        return false;\n    }\n    // now we need to extract the three numbers.\n\
    \    // first we need to split the string on the dashes,\n    // and then we can\
    \ parse each number.\n    let mut numbers = date.split(\"-\").map(|x| x.parse::<i32>().unwrap());\n\
    \    let month = numbers.next().unwrap();\n    let day = numbers.next().unwrap();\n\
    \    let year = numbers.next().unwrap();\n    // now we can check if the month\
    \ is within the valid range.\n    if month < 1 || month > 12 {\n        return\
    \ false;\n    }\n    // next we need to check if the day is within the valid range.\n\
    \    // first we check if the day is less than 1 or greater than 31.\n    if day\
    \ < 1 || day > 31 {\n        return false;\n    }\n    // next we need to check\
    \ if the day is valid for the given month.\n    //\n    // next we need to check\
    \ if the day is valid for the given month.\n    // for the months 1,3,5,7,8,10,12,\
    \ we need to check if the day is less than 1 or greater than 31.\n    // for the\
    \ months 4,6,9,11, we need to check if the day is less than 1 or greater than\
    \ 30.\n    // for the month 2, we need to check if the day is less than 1 or greater\
    \ than 29.\n    // we can use a match expression for this.\n    match month {\n\
    \        1", "    // Create a DateTime from date.\n    let date_time = DateTime::parse_from_str(&date,\
    \ \"%m-%d-%Y\");\n    // Check if the date_time is empty or not.\n    // If the\
    \ date_time is empty, it's invalid, otherwise it's valid.\n    if date_time.is_err()\
    \ {\n        return false;\n    }\n    // Get the parsed date_time.\n    let date_time\
    \ = date_time.unwrap();\n    // Create a DateTime from today.\n    let today =\
    \ Local::today();\n    // Check if the parsed date_time is after today.\n    //\
    \ If the parsed date_time is after today, it's invalid, otherwise it's valid.\n\
    \    if date_time.date() > today {\n        return false;\n    }\n    // If the\
    \ date_time is not empty and is not after today, it's valid.\n    true", "   \
    \ let mut params: Vec<&str> = date.split(\"-\").collect();\n    if params.len()\
    \ != 3 {\n        return false;\n    }\n    let year = params.pop().unwrap();\n\
    \    let mut dd = params.pop().unwrap();\n    let mm = params.pop().unwrap();\n\
    \    if year.len() != 4 || mm.len() != 2 || dd.len() != 2 {\n        return false;\n\
    \    }\n    if !year.parse::<i32>().is_ok() || !mm.parse::<i32>().is_ok() || !dd.parse::<i32>().is_ok()\
    \ {\n        return false;\n    }\n    if dd.starts_with(\"0\") {\n        dd\
    \ = &dd[1..];\n    }\n    let days = dd.parse::<i32>().unwrap();\n    let month\
    \ = mm.parse::<i32>().unwrap();\n    let months = [1, 3, 5, 7, 8, 10, 12];\n \
    \   if months.contains(&month) {\n        if days < 1 || days > 31 {\n       \
    \     return false;\n        }\n    } else if month == 2 {\n        if days <\
    \ 1 || days > 29 {\n            return false;\n        }\n    } else {\n     \
    \   if days < 1 || days > 30 {\n            return false;\n        }\n    }\n\
    \    true", "    //\n    // Write your code here.\n    //\n    let mut v = vec![];\n\
    \    let mut result = true;\n    let b = date.split(\"-\").collect::<Vec<&str>>();\n\
    \    for i in b {\n        let n = i.parse::<i32>().unwrap();\n        v.push(n);\n\
    \    }\n    //println!(\"{:?}\", v);\n    if date.len() == 10 {\n        if v[0]\
    \ < 1 || v[0] > 12 {\n            result = false;\n        } else if v[0] == 2\
    \ {\n            if v[1] < 1 || v[1] > 29 {\n                result = false;\n\
    \            }\n        } else if v[0] == 1 || v[0] == 3 || v[0] == 5 || v[0]\
    \ == 7 || v[0] == 8 || v[0] == 10 || v[0] == 12 {\n            if v[1] < 1 ||\
    \ v[1] > 31 {\n                result = false;\n            }\n        } else\
    \ if v[0] == 4 || v[0] == 6 || v[0] == 9 || v[0] == 11 {\n            if v[1]\
    \ < 1 || v[1] > 30 {\n                result = false;\n            }\n       \
    \ }\n    } else {\n        result = false;\n    }\n    result", "    lazy_static!\
    \ {\n        static ref RE: Regex = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\"\
    ).unwrap();\n    }\n    if !RE.is_match(&date) {\n        return false;\n    }\n\
    \    let caps = RE.captures(&date).unwrap();\n    let month = caps[1].parse::<i32>().unwrap();\n\
    \    let day = caps[2].parse::<i32>().unwrap();\n    if month < 1 || month > 12\
    \ {\n        return false;\n    }\n    match month {\n        1 | 3 | 5 | 7 |\
    \ 8 | 10 | 12 => if day < 1 || day > 31 {\n            return false;\n       \
    \ },\n        4 | 6 | 9 | 11 => if day < 1 || day > 30 {\n            return false;\n\
    \        },\n        2 => if day < 1 || day > 29 {\n            return false;\n\
    \        },\n        _ => panic!(\"impossible\"),\n    }\n    true", "    let\
    \ list: Vec<&str> = date.split(\"-\").collect();\n    if list.len() != 3 {\n \
    \       return false;\n    }\n    if list[0].parse::<i32>().unwrap() > 12 {\n\
    \        return false;\n    }\n    if list[1].parse::<i32>().unwrap() > 31 {\n\
    \        return false;\n    }\n    if list[2].parse::<i32>().unwrap() > 9999 {\n\
    \        return false;\n    }\n    true", "    let mut year = 0;\n    let mut\
    \ month = 0;\n    let mut day = 0;\n    let mut month_days: [u8; 12] = [31, 28,\
    \ 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut check_days = true;\n \
    \   let mut check_months = true;\n    let mut check_date_format = true;\n    let\
    \ mut date_separator = '-';\n    let mut date_parts: Vec<&str> = date.split(date_separator).collect();\n\
    \    if date_parts.len() != 3 {\n        date_separator = '/';\n        date_parts\
    \ = date.split(date_separator).collect();\n        if date_parts.len() != 3 {\n\
    \            check_date_format = false;\n        }\n    }\n    for x in date_parts\
    \ {\n        if x.len() == 0 {\n            check_date_format = false;\n     \
    \   }\n    }\n    if check_date_format {\n        let mut str_years: &str = date_parts[2];\n\
    \        let mut str_months: &str = date_parts[0];\n        let mut str_days:\
    \ &str = date_parts[1];\n        let mut years: u16 = str_years.parse().unwrap();\n\
    \        let mut months: u8 = str_months.parse().unwrap();\n        let mut days:\
    \ u8 = str_days.parse().unwrap();\n        if years % 4 == 0 {\n            month_days[1]\
    \ = 29;\n        }\n        if days < 1 || days > month_days[(months - 1) as usize]\
    \ {\n            check_days = false;\n        }\n        if months < 1 || months\
    \ > 12 {\n            check_months = false;\n        }\n    }\n    return check_days\
    \ && check_months && check_date_format;", "    let v: Vec<&str> = date.split(\"\
    -\").collect();\n    if v.len() == 3 {\n        let m = v[0].parse::<u32>().unwrap();\n\
    \        let d = v[1].parse::<u32>().unwrap();\n        let y = v[2].parse::<u32>().unwrap();\n\
    \        if m == 0 || d == 0 || y == 0 {\n            return false;\n        }\n\
    \        if m == 2 {\n            if d > 29 {\n                return false;\n\
    \            }\n        } else if m == 4 || m == 6 || m == 9 || m == 11 {\n  \
    \          if d > 30 {\n                return false;\n            }\n       \
    \ } else if m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m ==\
    \ 12 {\n            if d > 31 {\n                return false;\n            }\n\
    \        } else {\n            return false;\n        }\n        if m > 12 {\n\
    \            return false;\n        }\n        return true;\n    }\n    return\
    \ false;", "    let parts: Vec<&str> = date.split(\"-\").collect();\n    if parts.len()\
    \ != 3 {\n        return false;\n    }\n    let date = date.replace(\"-\", \"\"\
    );\n    if !date.chars().all(|x| x.is_digit(10)) {\n        return false;\n  \
    \  }\n    let date: i32 = date.parse().unwrap();\n    let year = date % 10000;\n\
    \    let month = (date / 10000) % 100;\n    let day = (date / 1000000) % 100;\n\
    \    if year < 0 || month < 1 || month > 12 || day < 1 {\n        return false;\n\
    \    }\n    if month == 2 {\n        if year % 4 == 0 && year % 100 != 0 {\n \
    \           return day <= 29;\n        }\n        return day <= 28;\n    }\n \
    \   if month == 4 || month == 6 || month == 9 || month == 11 {\n        return\
    \ day <= 30;\n    }\n    return day <= 31;", "    let vec: Vec<&str> = date.split(\"\
    -\").collect();\n    match vec.len() {\n        3 => {\n            match vec[0].parse::<u32>()\
    \ {\n                Ok(m) => {\n                    match vec[1].parse::<u32>()\
    \ {\n                        Ok(d) => {\n                            match vec[2].parse::<u32>()\
    \ {\n                                Ok(y) => {\n                            \
    \        if y % 4 == 0 && (y % 100 != 0 || y % 400 == 0) {\n                 \
    \                       match m {\n                                          \
    \  1 | 3 | 5 | 7 | 8 | 10 | 12 => d > 0 && d < 32,\n                         \
    \                   4 | 6 | 9 | 11 => d > 0 && d < 31,\n                     \
    \                       2 => d > 0 && d < 30,\n                              \
    \              _ => false,\n                                        }\n      \
    \                              } else {\n                                    \
    \    match m {\n                                            1 | 3 | 5 | 7 | 8\
    \ | 10 | 12 => d > 0 && d < 32,\n                                            4\
    \ | 6 | 9 | 11 => d > 0 && d < 31,\n                                         \
    \   2 => d > 0 && d < 29,\n                                            _ => false,\n\
    \                                        }\n                                 \
    \   }\n                                }\n                                Err(_)\
    \ => false,\n                            }\n                        }\n      \
    \                  Err(_) => false,\n                    }\n                }\n\
    \                Err(_) => false,\n            }\n        }\n        _ => false,\n\
    \    }", '    unimplemented!()', "    let mut date_chars = date.chars();\n   \
    \ let day = date_chars.by_ref().take(2).collect::<String>();\n    let month =\
    \ date_chars.by_ref().take(2).collect::<String>();\n    let year = date_chars.by_ref().take(4).collect::<String>();\n\
    \    match (day.parse::<u32>(), month.parse::<u32>(), year.parse::<u32>()) {\n\
    \        (Ok(day), Ok(month), Ok(year)) => {\n            let days_in_month =\
    \ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            if day > 0 &&\
    \ month > 0 && month <= 12 && year > 0 {\n                let days = match month\
    \ {\n                    2 => {\n                        if year % 4 == 0 {\n\
    \                            29\n                        } else {\n          \
    \                  28\n                        }\n                    }\n    \
    \                _ => days_in_month[(month - 1) as usize],\n                };\n\
    \                day <= days\n            } else {\n                false\n  \
    \          }\n        }\n        _ => false,\n    }", "    if date.is_empty()\
    \ {\n        return false;\n    }\n    let date_splitted: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_splitted.len() != 3 {\n        return false;\n  \
    \  }\n    let mm = date_splitted[0].parse::<u32>().unwrap();\n    let dd = date_splitted[1].parse::<u32>().unwrap();\n\
    \    let yyyy = date_splitted[2].parse::<u32>().unwrap();\n    if mm < 1 || mm\
    \ > 12 {\n        return false;\n    }\n    match mm {\n        1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => {\n            if dd < 1 || dd > 31 {\n                return\
    \ false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if\
    \ dd < 1 || dd > 30 {\n                return false;\n            }\n        }\n\
    \        2 => {\n            if dd < 1 || dd > 29 {\n                return false;\n\
    \            }\n        }\n        _ => return false,\n    }\n    return true;",
  "    let date_regex = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n    date_regex.is_match(&date)", "    let mut iter = date.split(\"\
    -\");\n    let mut month = iter.next().unwrap().parse::<u32>().unwrap();\n   \
    \ let mut day = iter.next().unwrap().parse::<u32>().unwrap();\n    let mut year\
    \ = iter.next().unwrap().parse::<u32>().unwrap();\n    let mut is_valid = true;\n\
    \    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day\
    \ > 31 {\n                is_valid = false;\n            }\n        }\n      \
    \  4 | 6 | 9 | 11 => {\n            if day > 30 {\n                is_valid =\
    \ false;\n            }\n        }\n        2 => {\n            if day > 29 {\n\
    \                is_valid = false;\n            }\n        }\n        _ => {\n\
    \            is_valid = false;\n        }\n    }\n    if year == 0 {\n       \
    \ is_valid = false;\n    }\n    is_valid", "    let re = Regex::new(r\"^(?P<m>[1-9]|1[0-2])-(?P<d>[1-9]|[12][0-9]|3[01])-(?P<y>\\\
    d{4})$\").unwrap();\n    let res = re.captures(&date);\n    if res.is_none() {\n\
    \        return false;\n    }\n    let caps = res.unwrap();\n    let m = caps.name(\"\
    m\").unwrap().as_str().parse::<i32>().unwrap();\n    let d = caps.name(\"d\").unwrap().as_str().parse::<i32>().unwrap();\n\
    \    if m == 2 {\n        if d > 29 {\n            return false;\n        }\n\
    \    } else if m % 2 == 0 {\n        if d > 30 {\n            return false;\n\
    \        }\n    } else {\n        if d > 31 {\n            return false;\n   \
    \     }\n    }\n    return true;", "    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n    let mut is_valid = false;\n    if re.is_match(&date) {\n    \
    \    let mut list: Vec<&str> = date.split(\"-\").collect();\n        let month\
    \ = list[0].parse::<i32>().unwrap();\n        let day = list[1].parse::<i32>().unwrap();\n\
    \        let year = list[2].parse::<i32>().unwrap();\n        if month == 1 ||\
    \ month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month\
    \ == 12 {\n            if day >= 1 && day <= 31 {\n                is_valid =\
    \ true;\n            }\n        } else if month == 4 || month == 6 || month ==\
    \ 9 || month == 11 {\n            if day >= 1 && day <= 30 {\n               \
    \ is_valid = true;\n            }\n        } else if month == 2 {\n          \
    \  if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {\n              \
    \  if day >= 1 && day <= 29 {\n                    is_valid = true;\n        \
    \        }\n            } else {\n                if day >= 1 && day <= 28 {\n\
    \                    is_valid = true;\n                }\n            }\n    \
    \    }\n    }\n    is_valid", "    let res = date.split('-').collect::<Vec<&str>>();\n\
    \    if res.len() == 3 && (res[0].parse::<i32>().is_ok() && res[1].parse::<i32>().is_ok()\
    \ && res[2].parse::<i32>().is_ok()) {\n        let day = res[1].parse::<i32>().unwrap();\n\
    \        let month = res[0].parse::<i32>().unwrap();\n        let year = res[2].parse::<i32>().unwrap();\n\
    \        if year > 0 && month > 0 && month < 13 && day > 0 {\n            if month\
    \ == 2 {\n                if day < 30 {\n                    return true;\n  \
    \              }\n            } else if month % 2 == 0 {\n                if day\
    \ < 32 {\n                    return true;\n                }\n            } else\
    \ if month % 2 != 0 {\n                if day < 31 {\n                    return\
    \ true;\n                }\n            }\n        }\n    }\n    false", "   \
    \ let mut is_valid = true;\n    let mut chars = date.chars();\n    if chars.len()\
    \ == 0 {\n        is_valid = false;\n    }\n    let mut count = 0;\n    let mut\
    \ date_parts: Vec<u32> = Vec::new();\n    while let Some(c) = chars.next() {\n\
    \        match c {\n            '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'\
    \ | '8' | '9' => {\n                count += 1;\n            }\n            '-'\
    \ => {\n                let num: u32 = count.to_string().parse().unwrap();\n \
    \               date_parts.push(num);\n                count = 0;\n          \
    \  }\n            _ => {\n                is_valid = false;\n            }\n \
    \       }\n    }\n    date_parts.push(count.to_string().parse().unwrap());\n \
    \   if date_parts.len() != 3 {\n        is_valid = false;\n    }\n    if date_parts[0]\
    \ < 1 || date_parts[0] > 12 {\n        is_valid = false;\n    }\n    let max_days\
    \ = match date_parts[0] {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,\n      \
    \  4 | 6 | 9 | 11 => 30,\n        2 => 28,\n        _ => 0,\n    };\n    if date_parts[1]\
    \ < 1 || date_parts[1] > max_days {\n        is_valid = false;\n    }\n    if\
    \ date_parts[2] < 0 {\n        is_valid = false;\n    }\n    is_valid", "    let\
    \ elements: Vec<&str> = date.split(\"-\").collect();\n    if elements.len() ==\
    \ 3 {\n        let days = elements[1].parse::<i32>().unwrap();\n        let month\
    \ = elements[0].parse::<i32>().unwrap();\n        if month == 1\n            ||\
    \ month == 3\n            || month == 5\n            || month == 7\n         \
    \   || month == 8\n            || month == 10\n            || month == 12\n  \
    \      {\n            return days >= 1 && days <= 31;\n        } else if month\
    \ == 4 || month == 6 || month == 9 || month == 11 {\n            return days >=\
    \ 1 && days <= 30;\n        } else if month == 2 {\n            return days >=\
    \ 1 && days <= 29;\n        }\n    }\n    false", "    date.is_empty()\n     \
    \   || date.len() != 10\n        || !&date.contains(\"-\")\n        || !date.chars().all(|c|\
    \ c.is_digit(10) || c == '-')\n        || date.chars().filter(|&c| c == '-').count()\
    \ != 2", "    let months = [\"\", \"January\", \"February\", \"March\", \"April\"\
    , \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\"\
    , \"December\"];\n    let days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,\
    \ 31];\n    let mut dates: Vec<&str> = date.split(\"-\").collect();\n    let mut\
    \ nums: Vec<i32> = vec![];\n    for i in 0..dates.len() {\n        if dates[i].parse::<i32>().is_ok()\
    \ {\n            nums.push(dates[i].parse::<i32>().unwrap());\n        } else\
    \ {\n            return false;\n        }\n    }\n    if months[nums[0] as usize]\
    \ == \"\" || months[nums[0] as usize] == \"February\" && nums[1] > 29 {\n    \
    \    return false;\n    }\n    if nums[0] > 12 || nums[1] > days[nums[0] as usize]\
    \ {\n        return false;\n    }\n    if nums[2] < 1 {\n        return false;\n\
    \    }\n    return true;", "    let v: Vec<&str> = date.split(\"-\").collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    match v[0].parse::<i32>()\
    \ {\n        Ok(m) => match v[1].parse::<i32>() {\n            Ok(d) => match\
    \ v[2].parse::<i32>() {\n                Ok(y) => {\n                    if m\
    \ > 12 || m < 1 {\n                        return false;\n                   \
    \ }\n                    if m == 2 {\n                        if d > 29 || d <\
    \ 1 {\n                            return false;\n                        }\n\
    \                    } else if d > 31 || d < 1 {\n                        return\
    \ false;\n                    }\n                    true\n                }\n\
    \                Err(_) => false,\n            },\n            Err(_) => false,\n\
    \        },\n        Err(_) => false,\n    }", "    let vec: Vec<&str> = date.split(\"\
    -\").collect();\n    let num = vec.len();\n    if num != 3 {\n        return false;\n\
    \    }\n    let month: i32 = vec[0].parse().unwrap();\n    let day: i32 = vec[1].parse().unwrap();\n\
    \    let year: i32 = vec[2].parse().unwrap();\n    if month > 12 || month < 1\
    \ {\n        return false;\n    }\n    match month {\n        1 | 3 | 5 | 7 |\
    \ 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n                return\
    \ false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if\
    \ day < 1 || day > 30 {\n                return false;\n            }\n      \
    \  }\n        2 => {\n            if year % 4 == 0 {\n                if day <\
    \ 1 || day > 29 {\n                    return false;\n                }\n    \
    \        } else {\n                if day < 1 || day > 28 {\n                \
    \    return false;\n                }\n            }\n        }\n        _ =>\
    \ return false,\n    }\n    true", "    if date.is_empty() {\n        return false;\n\
    \    }\n    let date_split: Vec<&str> = date.split(\"-\").collect();\n    if date_split.len()\
    \ != 3 {\n        return false;\n    }\n    let month = date_split[0].parse::<i32>().unwrap();\n\
    \    let day = date_split[1].parse::<i32>().unwrap();\n    let year = date_split[2].parse::<i32>().unwrap();\n\
    \    if year < 0 {\n        return false;\n    }\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    if (1..=31).contains(&day) {\n     \
    \   return true;\n    }\n    false", "    if date.is_empty() {\n        return\
    \ false;\n    }\n    let days_per_month = [0, 31, 29, 31, 30, 31, 30, 31, 31,\
    \ 30, 31, 30, 31];\n    let date_vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_vec.len() != 3 {\n        return false;\n    }\n    let day: i32\
    \ = match date_vec[1].parse() {\n        Ok(d) => d,\n        Err(_) => return\
    \ false,\n    };\n    let month: i32 = match date_vec[0].parse() {\n        Ok(m)\
    \ => m,\n        Err(_) => return false,\n    };\n    let year: i32 = match date_vec[2].parse()\
    \ {\n        Ok(y) => y,\n        Err(_) => return false,\n    };\n    if month\
    \ > 12 || month < 1 {\n        return false;\n    }\n    if day > days_per_month[month\
    \ as usize] || day < 1 {\n        return false;\n    }\n    if month == 2 && day\
    \ == 29 && (year % 4 != 0 || (year % 100 == 0 && year % 400 != 0)) {\n       \
    \ return false;\n    }\n    true", "    let mut months = vec![0, 31, 28, 31, 30,\
    \ 31, 30, 31, 31, 30, 31, 30, 31];\n    if date.is_empty() {\n        return false;\n\
    \    }\n    let dates: Vec<&str> = date.split(\"-\").collect();\n    if dates.len()\
    \ != 3 {\n        return false;\n    }\n    if dates[0].len() != 2 || dates[1].len()\
    \ != 2 || dates[2].len() != 4 {\n        return false;\n    }\n    let month:\
    \ u32 = dates[0].parse().unwrap();\n    let day: u32 = dates[1].parse().unwrap();\n\
    \    let year: u32 = dates[2].parse().unwrap();\n    if month < 1 || month > 12\
    \ {\n        return false;\n    }\n    if month == 2 && (year % 4 == 0 && year\
    \ % 100 != 0 || year % 400 == 0) {\n        months[2] = 29;\n    }\n    if day\
    \ < 1 || day > months[month as usize] {\n        return false;\n    }\n    true",
  '    unimplemented!();', "    // TODO: Implement this function\n    false", "  \
    \  let re = Regex::new(r\"(\\d{2})-(\\d{2})-(\\d{4})\").unwrap();\n    re.is_match(&date)",
  "    if date.is_empty() {\n        return false;\n    }\n    if date.chars().filter(|c|\
    \ c == &'-').count() != 2 {\n        return false;\n    }\n    let components:\
    \ Vec<u32> = date\n        .split('-')\n        .filter_map(|c| c.parse::<u32>().ok())\n\
    \        .collect();\n    if components.len() != 3 {\n        return false;\n\
    \    }\n    let [month, day, year] = components;\n    match month {\n        1\
    \ | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day > 31 {\n                return\
    \ false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if\
    \ day > 30 {\n                return false;\n            }\n        }\n      \
    \  2 => {\n            if day > 29 {\n                return false;\n        \
    \    }\n        }\n        _ => return false,\n    }\n    if year < 2000 {\n \
    \       return false;\n    }\n    true", "    // if let parts = date.split('-').collect::<Vec<&str>>()\
    \ {\n    //     if parts.len() == 3 {\n    //         if let month = parts[0].parse::<i32>()\
    \ {\n    //             if month >= 1 && month <= 12 {\n    //               \
    \  if let day = parts[1].parse::<i32>() {\n    //                     if day >=\
    \ 1 && day <= 31 {\n    //                         return true;\n    //      \
    \               }\n    //                 }\n    //             }\n    //    \
    \     }\n    //     }\n    // }\n    // false\n    let parts = date.split('-').collect::<Vec<&str>>();\n\
    \    if parts.len() == 3 {\n        let month = parts[0].parse::<i32>();\n   \
    \     let day = parts[1].parse::<i32>();\n        let year = parts[2].parse::<i32>();\n\
    \        if month.is_ok() && day.is_ok() && year.is_ok() {\n            let month\
    \ = month.unwrap();\n            let day = day.unwrap();\n            if month\
    \ >= 1 && month <= 12 {\n                if day >= 1 && day <= 31 {\n        \
    \            return true;\n                }\n            }\n        }\n    }\n\
    \    false", "    let date_regex = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\"\
    ).unwrap();\n    let date_captures = date_regex.captures(&date);\n    if let Some(captures)\
    \ = date_captures {\n        let mm = captures.get(1).unwrap().as_str().parse::<u32>().unwrap();\n\
    \        let dd = captures.get(2).unwrap().as_str().parse::<u32>().unwrap();\n\
    \        let yyyy = captures.get(3).unwrap().as_str().parse::<u32>().unwrap();\n\
    \        return month_valid(mm) && day_valid(dd, mm) && year_valid(yyyy);\n  \
    \  }\n    false", "    let mut characters = date.chars();\n    let m1 = match\
    \ characters.next() {\n        Some(m1) => m1,\n        None => { return false;\
    \ },\n    };\n    let m2 = match characters.next() {\n        Some(m2) => m2,\n\
    \        None => { return false; },\n    };\n    let _d1 = match characters.next()\
    \ {\n        Some(d1) => d1,\n        None => { return false; },\n    };\n   \
    \ let d2 = match characters.next() {\n        Some(d2) => d2,\n        None =>\
    \ { return false; },\n    };\n    let _d3 = match characters.next() {\n      \
    \  Some(d3) => d3,\n        None => { return false; },\n    };\n    let y1 = match\
    \ characters.next() {\n        Some(y1) => y1,\n        None => { return false;\
    \ },\n    };\n    let y2 = match characters.next() {\n        Some(y2) => y2,\n\
    \        None => { return false; },\n    };\n    let y3 = match characters.next()\
    \ {\n        Some(y3) => y3,\n        None => { return false; },\n    };\n   \
    \ let y4 = match characters.next() {\n        Some(y4) => y4,\n        None =>\
    \ { return false; },\n    };\n    let _ = match characters.next() {\n        Some(_)\
    \ => { return false; },\n        None => { return true; },\n    };\n    let m\
    \ = match m1.to_digit(10) {\n        Some(10) => 10,\n        Some(11) => 11,\n\
    \        Some(12) => 12,\n        Some(m) => m,\n        None => { return false;\
    \ },\n    };\n    let d = match d2.to_digit(10) {\n        Some(d) => d,\n   \
    \     None => { return false; },\n    };\n    let y = match (y1.to_digit(10),\
    \ y2.to_digit(10), y3.to_digit(10), y4.to_digit(10)) {\n        (Some(", "   \
    \ let re = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})\"\
    ).unwrap();\n    let date_vec: Vec<&str> = date.split(\"-\").collect();\n    if\
    \ date_vec.len() != 3 {\n        return false;\n    }\n    let date_num: Vec<u32>\
    \ = date_vec.iter().map(|x| x.parse::<u32>().unwrap()).collect();\n    if date_num[1]\
    \ > 31 || date_num[1] < 1 {\n        return false;\n    }\n    if date_num[0]\
    \ > 12 || date_num[0] < 1 {\n        return false;\n    }\n    if date_num[0]\
    \ == 1 || date_num[0] == 3 || date_num[0] == 5 || date_num[0] == 7 || date_num[0]\
    \ == 8 || date_num[0] == 10 || date_num[0] == 12 {\n        if date_num[1] > 31\
    \ {\n            return false;\n        }\n    }\n    if date_num[0] == 4 || date_num[0]\
    \ == 6 || date_num[0] == 9 || date_num[0] == 11 {\n        if date_num[1] > 30\
    \ {\n            return false;\n        }\n    }\n    if date_num[0] == 2 {\n\
    \        if date_num[1] > 29 {\n            return false;\n        }\n    }\n\
    \    re.is_match(&date)", "    if date.len() == 0 {\n        return false;\n \
    \   }\n    let pieces: Vec<&str> = date.split(\"-\").collect();\n    if pieces.len()\
    \ != 3 {\n        return false;\n    }\n    let day = match pieces[1].parse::<i32>()\
    \ {\n        Ok(d) => d,\n        Err(_) => return false,\n    };\n    let month\
    \ = match pieces[0].parse::<i32>() {\n        Ok(m) => m,\n        Err(_) => return\
    \ false,\n    };\n    let year = match pieces[2].parse::<i32>() {\n        Ok(y)\
    \ => y,\n        Err(_) => return false,\n    };\n    if day < 1 || day > 31 {\n\
    \        return false;\n    }\n    if month < 1 || month > 12 {\n        return\
    \ false;\n    }\n    if year < 0 {\n        return false;\n    }\n    match month\
    \ {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {}\n        4 | 6 | 9 | 11 => {\n\
    \            if day > 30 {\n                return false;\n            }\n   \
    \     }\n        2 => {\n            if day > 29 {\n                return false;\n\
    \            }\n        }\n        _ => {\n            return false;\n       \
    \ }\n    }\n    true", '    unimplemented!()', '    false', "    let mut months:\
    \ [u32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut leap_year\
    \ = false;\n    let mut is_valid = false;\n    let mut leap_year_check = 0;\n\
    \    let mut date_split: Vec<&str> = date.split(\"-\").collect();\n    let mut\
    \ date_valid = [false; 3];\n    let mut month_number: i32 = -1;\n    let mut day_number:\
    \ i32 = -1;\n    let mut year_number: i32 = -1;\n    for x in date_split.iter()\
    \ {\n        if !x.is_empty() {\n            is_valid = true;\n        }\n   \
    \ }\n    if is_valid {\n        if date_split.len() == 3 {\n            month_number\
    \ = date_split[0].parse::<i32>().unwrap();\n            day_number = date_split[1].parse::<i32>().unwrap();\n\
    \            year_number = date_split[2].parse::<i32>().unwrap();\n          \
    \  if (year_number % 4 == 0 && year_number % 100 != 0) || year_number % 400 ==\
    \ 0 {\n                leap_year = true;\n            }\n            for x in\
    \ date_split.iter() {\n                for y in x.chars() {\n                \
    \    if !y.is_numeric() {\n                        leap_year_check += 1;\n   \
    \                 }\n                }\n            }\n            if leap_year_check\
    \ == 0 {\n                date_valid[0] = true;\n            }\n            if\
    \ month_number >= 1 && month_number <= 12 {\n                date_valid[1] = true;\n\
    \            }\n            if day_number >= 1 && day_number <= 31 {\n       \
    \         date_valid[2] = true;\n            }\n            if leap_year {\n \
    \               months[1] = 29;\n            }\n            if month_number >=\
    \ 1 && month_number <= 12 {\n                if day_number >= 1 && day_number\
    \ <= months[(month_number - 1) as usize] {\n                    is_valid", " \
    \   let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\d{4}$\"\
    ).unwrap();\n    let days_in_month = |m: u32| {\n        match m {\n         \
    \   1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,\n            4 | 6 | 9 | 11 => 30,\n  \
    \          2 => 29,\n            _ => 0,\n        }\n    };\n    if re.is_match(&date)\
    \ {\n        let date_vec: Vec<&str> = date.split(\"-\").collect();\n        let\
    \ day = date_vec[1].parse::<u32>().unwrap();\n        let month = date_vec[0].parse::<u32>().unwrap();\n\
    \        let year = date_vec[2].parse::<u32>().unwrap();\n        if month < 1\
    \ || month > 12 {\n            return false;\n        }\n        if day < 1 ||\
    \ day > days_in_month(month) {\n            return false;\n        }\n       \
    \ if year % 4 == 0 && year % 100 != 0 || year % 400 == 0 {\n            if month\
    \ == 2 && day > days_in_month(month) {\n                return false;\n      \
    \      }\n        }\n        return true;\n    }\n    false", "    let split:\
    \ Vec<&str> = date.split(\"-\").collect();\n    let len = split.len();\n    let\
    \ mut is_leap = false;\n    if len != 3 {\n        return false;\n    }\n    if\
    \ split[2].len() != 4 {\n        return false;\n    }\n    let months: Vec<usize>\
    \ = split.iter().map(|x| x.parse::<usize>().unwrap()).collect();\n    if months[0]\
    \ > 12 || months[0] < 1 {\n        return false;\n    }\n    if months[0] == 2\
    \ {\n        if months[2] % 400 == 0 {\n            is_leap = true;\n        }\
    \ else if months[2] % 100 == 0 {\n            is_leap = false;\n        } else\
    \ if months[2] % 4 == 0 {\n            is_leap = true;\n        }\n        if\
    \ is_leap {\n            if months[1] > 29 || months[1] < 1 {\n              \
    \  return false;\n            }\n        } else {\n            if months[1] >\
    \ 28 || months[1] < 1 {\n                return false;\n            }\n      \
    \  }\n    } else if months[0] == 1 || months[0] == 3 || months[0] == 5 || months[0]\
    \ == 7 || months[0] == 8 || months[0] == 10 || months[0] == 12 {\n        if months[1]\
    \ > 31 || months[1] < 1 {\n            return false;\n        }\n    } else {\n\
    \        if months[1] > 30 || months[1] < 1 {\n            return false;\n   \
    \     }\n    }\n    true", '    unimplemented!()', "    if date.is_empty() {\n\
    \        return false;\n    }\n    let re = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\\
    d{4})$\").unwrap();\n    if !re.is_match(&date) {\n        return false;\n   \
    \ }\n    let date_strs: Vec<&str> = date.split(\"-\").collect();\n    let m: u32\
    \ = date_strs[0].parse().unwrap();\n    let d: u32 = date_strs[1].parse().unwrap();\n\
    \    if m < 1 || m > 12 {\n        return false;\n    }\n    if d < 1 {\n    \
    \    return false;\n    }\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m ==\
    \ 8 || m == 10 || m == 12) && d > 31 {\n        return false;\n    }\n    if (m\
    \ == 4 || m == 6 || m == 9 || m == 11) && d > 30 {\n        return false;\n  \
    \  }\n    if m == 2 && d > 29 {\n        return false;\n    }\n    true", "  \
    \  let parts: Vec<&str> = date.split(\"-\").collect();\n    if parts.len() !=\
    \ 3 {\n        return false;\n    }\n    if parts[0].len() != 2 || parts[1].len()\
    \ != 2 || parts[2].len() != 4 {\n        return false;\n    }\n    let month:\
    \ i32 = parts[0].parse().unwrap();\n    let day: i32 = parts[1].parse().unwrap();\n\
    \    let year: i32 = parts[2].parse().unwrap();\n    if month < 1 || month > 12\
    \ {\n        return false;\n    }\n    if day < 1 || day > 31 {\n        return\
    \ false;\n    }\n    if month == 2 && day > 29 {\n        return false;\n    }\n\
    \    if (month == 4 || month == 6 || month == 9 || month == 11) && day > 30 {\n\
    \        return false;\n    }\n    true", "    if !date.contains(\"-\") {\n  \
    \      return false;\n    }\n    let date_vec: Vec<i32> = date\n        .split(\"\
    -\")\n        .map(|s| s.parse::<i32>().unwrap())\n        .collect();\n    if\
    \ date_vec.len() != 3 {\n        return false;\n    }\n    let (month, day, year)\
    \ = (date_vec[0], date_vec[1], date_vec[2]);\n    if day < 1 || day > 31 || month\
    \ < 1 || month > 12 || year < 1 {\n        return false;\n    }\n    // leap year\n\
    \    if month == 2 && day == 29 && !(year % 4 == 0 && (year % 100 != 0 || year\
    \ % 400 == 0)) {\n        return false;\n    }\n    match month {\n        1 |\
    \ 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n        4 | 6 | 9 | 11 => day <= 30,\n\
    \        2 => day <= 28,\n        _ => false,\n    }", "    let mut date_value\
    \ = date.split(\"-\");\n    if date_value.clone().count() != 3 {\n        return\
    \ false;\n    }\n    let mut date_value: Vec<&str> = date_value.collect();\n \
    \   let month = match date_value[0].parse::<i32>() {\n        Ok(month) => month,\n\
    \        Err(_) => return false,\n    };\n    let day = match date_value[1].parse::<i32>()\
    \ {\n        Ok(day) => day,\n        Err(_) => return false,\n    };\n    let\
    \ year = match date_value[2].parse::<i32>() {\n        Ok(year) => year,\n   \
    \     Err(_) => return false,\n    };\n    if month < 1 || month > 12 {\n    \
    \    return false;\n    }\n    if day < 1 || day > 31 {\n        return false;\n\
    \    }\n    if day > 30 && (month == 4 || month == 6 || month == 9 || month ==\
    \ 11) {\n        return false;\n    }\n    if month == 2 && day > 29 {\n     \
    \   return false;\n    }\n    if year < 0 {\n        return false;\n    }\n  \
    \  true", '    unimplemented!()', "    lazy_static! {\n        static ref RE:\
    \ Regex = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\").unwrap();\n    }\n   \
    \ RE.is_match(&date)\n        && RE\n            .captures(&date)\n          \
    \  .map(|x| {\n                let month = x[1].parse::<u32>().unwrap();\n   \
    \             let day = x[2].parse::<u32>().unwrap();\n                let year\
    \ = x[3].parse::<u32>().unwrap();\n                let day_max = match month {\n\
    \                    2 => if year % 4 == 0 { 29 } else { 28 },\n             \
    \       4 | 6 | 9 | 11 => 30,\n                    _ => 31,\n                };\n\
    \                month <= 12 && day > 0 && day <= day_max\n            })\n  \
    \          .unwrap_or(false)", "    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n    if re.is_match(&date) {\n        let date: Vec<&str> =\
    \ date.split(\"-\").collect();\n        let y = date[2].parse::<i32>().unwrap();\n\
    \        let m = date[0].parse::<i32>().unwrap();\n        let d = date[1].parse::<i32>().unwrap();\n\
    \        match m {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => return d >= 1 &&\
    \ d <= 31,\n            4 | 6 | 9 | 11 => return d >= 1 && d <= 30,\n        \
    \    2 => return d >= 1 && d <= 29 && y % 4 == 0,\n            _ => return false,\n\
    \        }\n    }\n    false", "    if date.is_empty() {\n        return false;\n\
    \    }\n    let (_, months, days, _) = convert_date_str_to_digits(&date);\n  \
    \  if months > 12 || months < 1 {\n        return false;\n    }\n    if (months\
    \ == 1 || months == 3 || months == 5 || months == 7 || months == 8 || months ==\
    \ 10 || months == 12) && days > 31 {\n        return false;\n    }\n    if (months\
    \ == 4 || months == 6 || months == 9 || months == 11) && days > 30 {\n       \
    \ return false;\n    }\n    if months == 2 && days > 29 {\n        return false;\n\
    \    }\n    return true;", "    let mut days_of_the_month = [31, 29, 31, 30, 31,\
    \ 30, 31, 31, 30, 31, 30, 31];\n    let mut months = 0;\n    let mut days = 0;\n\
    \    let mut years = 0;\n    let mut result = true;\n    for (i, char) in date.chars().enumerate()\
    \ {\n        if i < 2 {\n            if char.is_numeric() {\n                months\
    \ = months * 10 + char.to_digit(10).unwrap();\n            } else {\n        \
    \        result = false;\n                break;\n            }\n        } else\
    \ if i < 4 {\n            if char.is_numeric() {\n                days = days\
    \ * 10 + char.to_digit(10).unwrap();\n            } else {\n                result\
    \ = false;\n                break;\n            }\n        } else if i < 8 {\n\
    \            if char.is_numeric() {\n                years = years * 10 + char.to_digit(10).unwrap();\n\
    \            } else {\n                result = false;\n                break;\n\
    \            }\n        } else {\n            result = false;\n            break;\n\
    \        }\n    }\n    if months == 0 || months > 12 || years == 0 || days ==\
    \ 0 {\n        result = false;\n    } else if days > days_of_the_month[months\
    \ - 1] {\n        result = false;\n    }\n    result", "    let date_regex = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\d{4}$\").unwrap();\n    return date_regex.is_match(&date);",
  "    // if date == \"\" {\n    //     return false;\n    // }\n    let mut splitted\
    \ = date.split(\"-\");\n    let mut vec: Vec<i32> = Vec::new();\n    for i in\
    \ splitted {\n        match i.parse::<i32>() {\n            Ok(number) => vec.push(number),\n\
    \            Err(_) => return false,\n        }\n    }\n    if vec.len() != 3\
    \ {\n        return false;\n    }\n    let mut days = 0;\n    match vec[0] {\n\
    \        1 | 3 | 5 | 7 | 8 | 10 | 12 => days = 31,\n        4 | 6 | 9 | 11 =>\
    \ days = 30,\n        2 => days = 29,\n        _ => return false,\n    }\n   \
    \ if vec[1] < 1 || vec[1] > days {\n        return false;\n    }\n    if vec[2]\
    \ < 1 {\n        return false;\n    }\n    true", "    lazy_static! {\n      \
    \  static ref DATE_PATTERN: Regex = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\"\
    ).unwrap();\n    }\n    if !DATE_PATTERN.is_match(&date) {\n        return false;\n\
    \    }\n    let caps = DATE_PATTERN.captures(&date).unwrap();\n    let month =\
    \ caps[1].parse::<u32>().unwrap();\n    let day = caps[2].parse::<u32>().unwrap();\n\
    \    let _year = caps[3].parse::<u32>().unwrap();\n    if month > 12 || day >\
    \ 31 {\n        return false;\n    }\n    if month % 2 == 0 && day > 30 {\n  \
    \      return false;\n    }\n    if month == 2 && day > 29 {\n        return false;\n\
    \    }\n    true", "    let mut t = date.split('-');\n    let mut m = t.next().unwrap().parse::<i32>().unwrap();\n\
    \    let mut d = t.next().unwrap().parse::<i32>().unwrap();\n    let y = t.next().unwrap().parse::<i32>().unwrap();\n\
    \    m > 0 && m < 13 && d > 0 && d < 32 && y > 999 && (m == 2 && d < 30 || m ==\
    \ 4 && d < 31 || m == 6 && d < 31 || m == 9 && d < 31 || m == 11 && d < 31 ||\
    \ d < 32)", "    let format = \"\\\\d{2}-\\\\d{2}-\\\\d{4}\";\n    let re = Regex::new(format).unwrap();\n\
    \    let date_pattern = re.is_match(&date);\n    if !date_pattern {\n        return\
    \ false;\n    }\n    let dates: Vec<&str> = date.split(\"-\").collect();\n   \
    \ let days = dates[1].parse::<i32>().unwrap();\n    let month = dates[0].parse::<i32>().unwrap();\n\
    \    let year = dates[2].parse::<i32>().unwrap();\n    let months = [\n      \
    \  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,\n    ];\n    if days < 1 ||\
    \ days > months[month as usize - 1] {\n        return false;\n    }\n    if month\
    \ < 1 || month > 12 {\n        return false;\n    }\n    if year < 1 {\n     \
    \   return false;\n    }\n    return true;", "    let mut d = date.split('-');\n\
    \    let c = d.clone();\n    if c.count() == 3 && date.chars().filter(|c| *c ==\
    \ '-').count() == 2 {\n        let mut s: Vec<u32> = d.map(|s| {\n           \
    \ match s.parse::<u32>() {\n                Ok(n) => n,\n                Err(_)\
    \ => return false,\n            }\n        }).collect();\n        if s[0] > 12\
    \ || s[1] > 31 || s[2] < 1000 || s[2] > 9999 {\n            return false;\n  \
    \      }\n        s.sort();\n        if s[1] > 28 && s[1] < 31 && s[0] == 2 {\n\
    \            return false;\n        }\n        if s[1] > 29 && s[0] == 2 {\n \
    \           return false;\n        }\n        if s[1] > 30 && s[0] % 2 == 0 &&\
    \ s[0] < 8 {\n            return false;\n        }\n        if s[1] > 30 && s[0]\
    \ % 2 == 1 && s[0] > 7 {\n            return false;\n        }\n        return\
    \ true;\n    }\n    false", "    if date.is_empty() {\n        return false;\n\
    \    }\n    let split: Vec<&str> = date.split(\"-\").collect();\n    if split.len()\
    \ != 3 {\n        return false;\n    }\n    let days: i64 = split[1].parse().unwrap();\n\
    \    let months: i64 = split[0].parse().unwrap();\n    let years: i64 = split[2].parse().unwrap();\n\
    \    if years < 1 {\n        return false;\n    }\n    if months < 1 || months\
    \ > 12 {\n        return false;\n    }\n    if days < 1 || days > 31 {\n     \
    \   return false;\n    }\n    if months == 2 {\n        if days > 29 {\n     \
    \       return false;\n        }\n    }\n    if months == 4 || months == 6 ||\
    \ months == 9 || months == 11 {\n        if days > 30 {\n            return false;\n\
    \        }\n    }\n    return true;", "    const MONTH_DAYS: [i32; 12] = [31,\
    \ 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let parts: Vec<i32> = date\n\
    \        .split('-')\n        .filter_map(|e| e.parse::<i32>().ok())\n       \
    \ .collect();\n    if parts.len() != 3 {\n        return false;\n    }\n    let\
    \ month = parts[0];\n    let day = parts[1];\n    let year = parts[2];\n    if\
    \ month < 1 || month > 12 {\n        return false;\n    }\n    if day < 1 || day\
    \ > MONTH_DAYS[(month - 1) as usize] {\n        return false;\n    }\n    if (month\
    \ == 2) && (day == 29) && ((year % 4) != 0) {\n        return false;\n    }\n\
    \    true", "    // your code here\n    let mut d: Vec<&str> = date.split(\"-\"\
    ).collect();\n    d.reverse();\n    //println!(\"{:?}\", d);\n    if d.len() !=\
    \ 3 {\n        return false;\n    }\n    let mut d_days: i32 = d[0].parse().unwrap();\n\
    \    let mut d_month: i32 = d[1].parse().unwrap();\n    let mut d_year: i32 =\
    \ d[2].parse().unwrap();\n    //let mut days: Vec<i32> = vec![31,28,31,30,31,30,31,31,30,31,30,31];\n\
    \    //println!(\"{:?}\", d_days);\n    if d_days > 31 || d_days < 1 || d_month\
    \ > 12 || d_month < 1 || d_year < 1 {\n        return false;\n    } else if d_days\
    \ > 28 && d_month == 2 {\n        return false;\n    } else if d_days > 30 &&\
    \ (d_month == 4 || d_month == 6 || d_month == 9 || d_month == 11) {\n        return\
    \ false;\n    } else {\n        return true;\n    }", "    let (m, d, y) = parse_date(date);\n\
    \    let is_leap = is_leap_year(y);\n    return match m {\n        1..=12 => {\n\
    \            match m {\n                1 | 3 | 5 | 7 | 8 | 10 | 12 => (1..=31).contains(&d),\n\
    \                4 | 6 | 9 | 11 => (1..=30).contains(&d),\n                2 =>\
    \ (1..=28 + is_leap).contains(&d),\n                _ => false,\n            }\n\
    \        }\n        _ => false,\n    };", "    lazy_static! {\n        static\
    \ ref RE: Regex = Regex::new(r\"^(0[1-9]|1[0-2])-([0-2][0-9]|3[0-1])-(20\\d{2})$\"\
    ).unwrap();\n    }\n    RE.is_match(&date)", "    let re = Regex::new(r\"(\\d\\\
    d)/(\\d\\d)/(\\d\\d\\d\\d)\").unwrap();\n    if let Some(captures) = re.captures(&date)\
    \ {\n        let month = captures.get(1).unwrap().as_str().parse::<u32>().unwrap();\n\
    \        let day = captures.get(2).unwrap().as_str().parse::<u32>().unwrap();\n\
    \        let year = captures.get(3).unwrap().as_str().parse::<u32>().unwrap();\n\
    \        if year < 1000 || year > 9999 {\n            return false;\n        }\n\
    \        if month == 0 || month > 12 {\n            return false;\n        }\n\
    \        if day == 0 {\n            return false;\n        }\n        if month\
    \ == 2 {\n            if year % 4 == 0 {\n                if day > 29 {\n    \
    \                return false;\n                }\n            } else {\n    \
    \            if day > 28 {\n                    return false;\n              \
    \  }\n            }\n        } else if month == 4 || month == 6 || month == 9\
    \ || month == 11 {\n            if day > 30 {\n                return false;\n\
    \            }\n        } else {\n            if day > 31 {\n                return\
    \ false;\n            }\n        }\n        return true;\n    }\n    return false;",
  "    let regex = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n    if !regex.is_match(&date)\
    \ {\n        return false;\n    }\n    let date_vec: Vec<&str> = date.split(\"\
    -\").collect();\n    let (month, day, year) = (date_vec[0].parse::<u8>().unwrap(),\
    \ date_vec[1].parse::<u8>().unwrap(), date_vec[2].parse::<u16>().unwrap());\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    match month\
    \ {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day < 1 || day >\
    \ 31 {\n                return false;\n            }\n        }\n        4 | 6\
    \ | 9 | 11 => {\n            if day < 1 || day > 30 {\n                return\
    \ false;\n            }\n        }\n        2 => {\n            if day < 1 ||\
    \ day > 29 {\n                return false;\n            }\n        }\n      \
    \  _ => return false,\n    }\n    true", "    // Write your code here\n    unimplemented!();",
  "    // The date is valid if all of the following rules are satisfied:\n    // 1.\
    \ The date string is not empty.\n    if date.is_empty() {\n        return false;\n\
    \    }\n    // 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n    let v: Vec<&str> = date.split('-').collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    // 3. The months should\
    \ not be less than 1 or higher than 12.\n    if v[0].len() > 2 || v[1].len() >\
    \ 2 || v[2].len() != 4 {\n        return false;\n    }\n    let day = v[1].parse::<i32>().unwrap();\n\
    \    let month = v[0].parse::<i32>().unwrap();\n    let year = v[2].parse::<i32>().unwrap();\n\
    \    if day > 31 || day < 1 || month > 12 || month < 1 || year < 0 {\n       \
    \ return false;\n    }\n    match month {\n        2 => {\n            if day\
    \ > 29 {\n                return false;\n            }\n        }\n        4 |\
    \ 6 | 9 | 11 => {\n            if day > 30 {\n                return false;\n\
    \            }\n        }\n        _ => (),\n    }\n    true", "    let date_vec:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_vec.len() != 3 {\n   \
    \     return false;\n    }\n    let month = date_vec[0].parse::<i32>().unwrap();\n\
    \    let day = date_vec[1].parse::<i32>().unwrap();\n    let year = date_vec[2].parse::<i32>().unwrap();\n\
    \    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day\
    \ < 1 || day > 31 {\n                return false;\n            }\n        }\n\
    \        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n         \
    \       return false;\n            }\n        }\n        2 => {\n            if\
    \ year % 4 == 0 {\n                if day < 1 || day > 29 {\n                \
    \    return false;\n                }\n            } else {\n                if\
    \ day < 1 || day > 28 {\n                    return false;\n                }\n\
    \            }\n        }\n        _ => return false,\n    }\n    if month < 1\
    \ || month > 12 {\n        return false;\n    }\n    true", "    if date.is_empty()\
    \ {\n        return false;\n    }\n    let split: Vec<&str> = date.split(\"-\"\
    ).collect();\n    if split.len() != 3 {\n        return false;\n    }\n    let\
    \ day = split[1].parse::<u8>().unwrap();\n    let month = split[0].parse::<u8>().unwrap();\n\
    \    let year = split[2].parse::<u32>().unwrap();\n    if day > 31 || month >\
    \ 12 {\n        return false;\n    }\n    match month {\n        1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => {\n            if day > 31 {\n                return false;\n\
    \            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day > 30\
    \ {\n                return false;\n            }\n        }\n        2 => {\n\
    \            if year % 4 == 0 {\n                if day > 29 {\n             \
    \       return false;\n                }\n            } else {\n             \
    \   if day > 28 {\n                    return false;\n                }\n    \
    \        }\n        }\n        _ => (),\n    }\n    true", "    lazy_static! {\n\
    \        static ref DATE_REGEX: Regex = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})\"\
    ).unwrap();\n    }\n    let valid_year = |year: i32| year >= 1900 && year <= 2100;\n\
    \    let valid_month = |month: i32| month >= 1 && month <= 12;\n    let valid_day\
    \ = |month: i32, day: i32| {\n        if month % 2 == 0 {\n            (month\
    \ != 2 || day != 30) && day >= 1 && day <= 30\n        } else {\n            (month\
    \ != 1 || day != 32) && day >= 1 && day <= 31\n        }\n    };\n    DATE_REGEX.is_match(&date)\n\
    \        && valid_year(date[6..10].parse::<i32>().unwrap())\n        && valid_month(date[0..2].parse::<i32>().unwrap())\n\
    \        && valid_day(date[0..2].parse::<i32>().unwrap(), date[3..5].parse::<i32>().unwrap())",
  "    match date.matches('-').count() {\n        2 => {\n            let date_vec:\
    \ Vec<&str> = date.split('-').collect();\n            let date_arr: [u32; 3] =\
    \ [\n                date_vec[0].parse::<u32>().unwrap(),\n                date_vec[1].parse::<u32>().unwrap(),\n\
    \                date_vec[2].parse::<u32>().unwrap(),\n            ];\n      \
    \      if date_arr[0] == 2 {\n                if (date_arr[2] % 4 == 0 && date_arr[2]\
    \ % 100 != 0) || date_arr[2] % 400 == 0 {\n                    if date_arr[1]\
    \ <= 29 {\n                        return true;\n                    }\n     \
    \           } else {\n                    if date_arr[1] <= 28 {\n           \
    \             return true;\n                    }\n                }\n       \
    \     } else if date_arr[0] % 2 == 0 {\n                if date_arr[1] <= 30 {\n\
    \                    return true;\n                }\n            } else if date_arr[0]\
    \ % 2 != 0 {\n                if date_arr[1] <= 31 {\n                    return\
    \ true;\n                }\n            }\n        }\n        _ => return false,\n\
    \    }\n    false", "    let mut date_chars = date.chars();\n    let mut date_digits\
    \ = Vec::new();\n    loop {\n        match date_chars.next() {\n            Some(c)\
    \ => {\n                let digit = c.to_digit(10);\n                if digit.is_some()\
    \ {\n                    date_digits.push(digit.unwrap());\n                }\
    \ else {\n                    return false;\n                }\n            }\n\
    \            None => break,\n        }\n    }\n    if date_digits.len() != 8 {\n\
    \        return false;\n    }\n    if date_digits[2] != 1 || date_digits[3] !=\
    \ 2 {\n        return false;\n    }\n    if date_digits[5] < 1 || date_digits[5]\
    \ > 12 {\n        return false;\n    }\n    let max_day = match date_digits[5]\
    \ {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,\n        4 | 6 | 9 | 11 => 30,\n\
    \        2 => 29,\n        _ => unreachable!(),\n    };\n    if date_digits[6]\
    \ < 1 || date_digits[6] > max_day {\n        return false;\n    }\n    true",
  "    let days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut iter\
    \ = date.split(\"-\");\n    let month: u32 = iter.next().unwrap().parse().unwrap();\n\
    \    let day: u32 = iter.next().unwrap().parse().unwrap();\n    let year: u32\
    \ = iter.next().unwrap().parse().unwrap();\n    if month < 1 || month > 12 {\n\
    \        return false;\n    }\n    if day < 1 || day > days[(month - 1) as usize]\
    \ {\n        return false;\n    }\n    if year < 0 {\n        return false;\n\
    \    }\n    true", "    if date.is_empty() {\n        return false;\n    }\n \
    \   let days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let str_vec:\
    \ Vec<&str> = date.split('-').collect();\n    if str_vec.len() != 3 {\n      \
    \  return false;\n    }\n    let month: i32 = str_vec[0].parse().unwrap();\n \
    \   let day: i32 = str_vec[1].parse().unwrap();\n    let year: i32 = str_vec[2].parse().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if day <\
    \ 1 || day > days[(month - 1) as usize] {\n        return false;\n    }\n    if\
    \ year < 1 {\n        return false;\n    }\n    true", "    let re = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\").unwrap();\n    if re.is_match(&date)\
    \ {\n        let v: Vec<&str> = date.split(\"-\").collect();\n        if let Ok(month)\
    \ = v[0].parse::<u32>() {\n            if let Ok(day) = v[1].parse::<u32>() {\n\
    \                if month < 1 || month > 12 {\n                    return false;\n\
    \                }\n                match month {\n                    1 | 3 |\
    \ 5 | 7 | 8 | 10 | 12 => {\n                        if day < 1 || day > 31 {\n\
    \                            return false;\n                        }\n      \
    \              }\n                    4 | 6 | 9 | 11 => {\n                  \
    \      if day < 1 || day > 30 {\n                            return false;\n \
    \                       }\n                    }\n                    2 => {\n\
    \                        if day < 1 || day > 29 {\n                          \
    \  return false;\n                        }\n                    }\n         \
    \           _ => return false,\n                }\n            } else {\n    \
    \            return false;\n            }\n        } else {\n            return\
    \ false;\n        }\n    } else {\n        return false;\n    }\n    true", '    unimplemented!();',
  "    let mut parts = date.split(\"-\");\n    if parts.clone().count() != 3 {\n \
    \       return false;\n    }\n    let mut numbers: Vec<i32> = Vec::new();\n  \
    \  for n in parts {\n        match n.parse::<i32>() {\n            Ok(num) =>\
    \ numbers.push(num),\n            Err(_) => return false,\n        }\n    }\n\
    \    if numbers[0] > 12 || numbers[0] < 1 {\n        return false;\n    }\n  \
    \  if numbers[0] == 2 {\n        if numbers[1] > 29 || numbers[1] < 1 {\n    \
    \        return false;\n        }\n    } else if numbers[0] == 4 || numbers[0]\
    \ == 6 || numbers[0] == 9 || numbers[0] == 11 {\n        if numbers[1] > 30 ||\
    \ numbers[1] < 1 {\n            return false;\n        }\n    } else {\n     \
    \   if numbers[1] > 31 || numbers[1] < 1 {\n            return false;\n      \
    \  }\n    }\n    true", "    // Your code here\n    let months = [\"January\"\
    , \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\"\
    , \"September\", \"October\", \"November\", \"December\"];\n    let mut fields\
    \ = date.split(\"-\");\n    let mut days = [\"\", \"\", \"\"];\n    let mut index\
    \ = 0;\n    let mut valid_date = true;\n    while let Some(element) = fields.next()\
    \ {\n        days[index] = element;\n        index += 1;\n    }\n    let year\
    \ = days[2].parse::<i32>().unwrap();\n    let month = days[0].parse::<i32>().unwrap();\n\
    \    let day = days[1].parse::<i32>().unwrap();\n    if month == 2 {\n       \
    \ valid_date = valid_date && day <= 29;\n    } else if month == 1 || month ==\
    \ 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12 {\n\
    \        valid_date = valid_date && day <= 31;\n    } else {\n        valid_date\
    \ = valid_date && day <= 30;\n    }\n    valid_date = valid_date && month >= 1\
    \ && month <= 12;\n    valid_date = valid_date && year > 0;\n    valid_date",
  "    let mut valid = true;\n    let mut expected_len = 9;\n    let mut chunks =\
    \ date.split('-');\n    let month = chunks.next().unwrap().to_string();\n    let\
    \ day = chunks.next().unwrap().to_string();\n    let year = chunks.next().unwrap().to_string();\n\
    \    if let Some(_) = chunks.next() {\n        valid = false;\n    }\n    if month.len()\
    \ != 2 || day.len() != 2 || year.len() != 4 {\n        valid = false;\n    }\n\
    \    if month.contains('/') || day.contains('/') || year.contains('/') {\n   \
    \     valid = false;\n    }\n    if !(month.parse::<i32>().is_ok() && day.parse::<i32>().is_ok()\
    \ && year.parse::<i32>().is_ok()) {\n        valid = false;\n    }\n    if !(month.parse::<i32>().unwrap()\
    \ >= 1 && month.parse::<i32>().unwrap() <= 12) {\n        valid = false;\n   \
    \ }\n    if (month.parse::<i32>().unwrap() == 2) && (day.parse::<i32>().unwrap()\
    \ >= 1 && day.parse::<i32>().unwrap() <= 29) {\n        valid = true;\n    } else\
    \ if (month.parse::<i32>().unwrap() == 2) && (day.parse::<i32>().unwrap() >= 1\
    \ && day.parse::<i32>().unwrap() <= 28) {\n        valid = true;\n    } else if\
    \ (month.parse::<i32>().unwrap() == 2) && (day.parse::<i32>().unwrap() < 1 ||\
    \ day.parse::<i32>().unwrap() > 29) {\n        valid = false;\n    }\n    if (month.parse::<i32>().unwrap()\
    \ == 1 || month.parse::<i32>().unwrap() == 3 || month.parse::<i32>().unwrap()\
    \ == 5 || month.parse::<i32>().unwrap()", "    let pattern = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n    pattern.is_match(&date)", "    let split_date: Vec<&str> = date.split(\"\
    -\").collect();\n    let mut result = true;\n    let mut m: i32 = 0;\n    let\
    \ mut d: i32 = 0;\n    let mut y: i32 = 0;\n    if split_date.len() == 3 {\n \
    \       if let Ok(mn) = split_date[0].parse::<i32>() {\n            m = mn;\n\
    \        } else {\n            result = false;\n        }\n        if let Ok(dy)\
    \ = split_date[1].parse::<i32>() {\n            d = dy;\n        } else {\n  \
    \          result = false;\n        }\n        if let Ok(yr) = split_date[2].parse::<i32>()\
    \ {\n            y = yr;\n        } else {\n            result = false;\n    \
    \    }\n    } else {\n        result = false;\n    }\n    result &= d >= 1 &&\
    \ d <= 31;\n    if m == 4 || m == 6 || m == 9 || m == 11 {\n        result &=\
    \ d <= 30;\n    }\n    if m == 2 {\n        if y % 4 == 0 {\n            result\
    \ &= d <= 29;\n        } else {\n            result &= d <= 28;\n        }\n \
    \   }\n    result &= m >= 1 && m <= 12;\n    result", "    if date.len() == 0\
    \ {\n        return false;\n    }\n    let (a, b, c) = date.split(\"-\").collect::<Vec<&str>>();\n\
    \    let (a, b, c) = (a.parse::<u8>().unwrap(), b.parse::<u8>().unwrap(), c.parse::<u16>().unwrap());\n\
    \    if a > 12 || a < 1 {\n        return false;\n    }\n    if a == 1 || a ==\
    \ 3 || a == 5 || a == 7 || a == 8 || a == 10 || a == 12 {\n        if b < 1 ||\
    \ b > 31 {\n            return false;\n        }\n    } else if a == 4 || a ==\
    \ 6 || a == 9 || a == 11 {\n        if b < 1 || b > 30 {\n            return false;\n\
    \        }\n    } else if a == 2 {\n        if b < 1 || b > 29 {\n           \
    \ return false;\n        }\n    }\n    true", "    let reg = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\"\
    ).unwrap();\n    let groups = reg.captures(&date).unwrap();\n    let month = groups[1].parse::<u32>().unwrap();\n\
    \    let day = groups[2].parse::<u32>().unwrap();\n    let year = groups[3].parse::<u32>().unwrap();\n\
    \    let mut result = true;\n    let days = vec![\n        31,\n        if year\
    \ % 4 == 0 { 29 } else { 28 },\n        31,\n        30,\n        31,\n      \
    \  30,\n        31,\n        31,\n        30,\n        31,\n        30,\n    \
    \    31,\n    ];\n    if month > 12 || day > days[(month - 1) as usize] {\n  \
    \      result = false;\n    }\n    result", "    lazy_static! {\n        static\
    \ ref RE: Regex = Regex::new(r\"^((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3[0-1]))-([0-9]{4})$\"\
    ).unwrap();\n    }\n    RE.is_match(&date)", "    if date.len() == 0 {\n     \
    \   return false;\n    }\n    let date_split: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_split.len() != 3 {\n        return false;\n    }\n    let year: usize\
    \ = date_split[2].parse().unwrap();\n    let month: usize = date_split[0].parse().unwrap();\n\
    \    let day: usize = date_split[1].parse().unwrap();\n    // months should not\
    \ be less than 1 or higher than 12\n    if month < 1 || month > 12 {\n       \
    \ return false;\n    }\n    // months 1,3,5,7,8,10,12\n    if (month == 1 || month\
    \ == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)\
    \ && (day < 1 || day > 31) {\n        return false;\n    }\n    // months 4,6,9,11\n\
    \    if (month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 ||\
    \ day > 30) {\n        return false;\n    }\n    // month 2\n    if month == 2\
    \ && year % 4 == 0 && (day < 1 || day > 29) {\n        return false;\n    }\n\
    \    if month == 2 && year % 4 != 0 && (day < 1 || day > 28) {\n        return\
    \ false;\n    }\n    true", "    let mut vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    if vec.len() != 3 {\n        return false;\n    }\n    if vec[0].len() !=\
    \ 2 || vec[1].len() != 2 || vec[2].len() != 4 {\n        return false;\n    }\n\
    \    vec[0] = vec[0].trim_start_matches('0');\n    vec[1] = vec[1].trim_start_matches('0');\n\
    \    if !vec[0].parse::<i32>().is_ok() || !vec[1].parse::<i32>().is_ok() || !vec[2].parse::<i32>().is_ok()\
    \ {\n        return false;\n    }\n    let mut mm: i32 = vec[0].parse::<i32>().unwrap();\n\
    \    let mut dd: i32 = vec[1].parse::<i32>().unwrap();\n    let mut yyyy: i32\
    \ = vec[2].parse::<i32>().unwrap();\n    match mm {\n        1 | 3 | 5 | 7 | 8\
    \ | 10 | 12 => {\n            if dd < 1 || dd > 31 {\n                return false;\n\
    \            }\n        }\n        4 | 6 | 9 | 11 => {\n            if dd < 1\
    \ || dd > 30 {\n                return false;\n            }\n        }\n    \
    \    2 => {\n            if yyyy % 4 == 0 {\n                if dd < 1 || dd >\
    \ 29 {\n                    return false;\n                }\n            } else\
    \ {\n                if dd < 1 || dd > 28 {\n                    return false;\n\
    \                }\n            }\n        }\n        _ => {\n            return\
    \ false;\n        }\n    }\n    return true;", "    let mut pattern = String::from(\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\");\n    for i in 1..4\
    \ {\n        pattern = pattern.replace(\"[\", &format!(\"[0-{}\", i));\n    }\n\
    \    pattern = pattern.replace(\"{4}\", \"9{4}\");\n    let regex = Regex::new(&pattern).unwrap();\n\
    \    regex.is_match(&date)", "    let mut result = true;\n    let months = vec![31,\
    \ 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let elements: Vec<&str> =\
    \ date.split(\"-\").collect();\n    let mut year: i32 = -1;\n    let mut month:\
    \ i32 = -1;\n    let mut day: i32 = -1;\n    if elements.len() == 3 {\n      \
    \  year = match elements[2].parse::<i32>() {\n            Ok(val) => val,\n  \
    \          Err(_) => -1,\n        };\n        month = match elements[0].parse::<i32>()\
    \ {\n            Ok(val) => val,\n            Err(_) => -1,\n        };\n    \
    \    day = match elements[1].parse::<i32>() {\n            Ok(val) => val,\n \
    \           Err(_) => -1,\n        };\n    }\n    if year <= 0 || year > 2050\
    \ || month <= 0 || month > 12 || day <= 0 || day > months[(month - 1) as usize]\
    \ {\n        result = false;\n    }\n    result", "    let parts: Vec<&str> =\
    \ date.split(\"-\").collect();\n    if parts.len() != 3 {\n        return false;\n\
    \    }\n    if parts[0].len() != 2 || parts[1].len() != 2 || parts[2].len() !=\
    \ 4 {\n        return false;\n    }\n    let month: u32 = parts[0].parse().unwrap();\n\
    \    let day: u32 = parts[1].parse().unwrap();\n    if month < 1 || month > 12\
    \ {\n        return false;\n    }\n    if month % 2 == 0 && month != 2 {\n   \
    \     if day < 1 || day > 30 {\n            return false;\n        }\n    } else\
    \ if month == 2 {\n        if day < 1 || day > 29 {\n            return false;\n\
    \        }\n    } else {\n        if day < 1 || day > 31 {\n            return\
    \ false;\n        }\n    }\n    return true;", "    let pattern = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\").unwrap();\n    return\
    \ pattern.is_match(&date);", "    if date.is_empty() {\n        return false;\n\
    \    }\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len()\
    \ != 3 {\n        return false;\n    }\n    let mut i = 0;\n    for part in parts\
    \ {\n        i += 1;\n        if i == 1 {\n            if part.len() != 2 {\n\
    \                return false;\n            }\n            let _: Result<u8, ParseIntError>\
    \ = part.parse();\n            if part.parse::<u8>().is_err() {\n            \
    \    return false;\n            }\n        }\n        if i == 2 {\n          \
    \  if part.len() != 2 {\n                return false;\n            }\n      \
    \      let _: Result<u8, ParseIntError> = part.parse();\n            if part.parse::<u8>().is_err()\
    \ {\n                return false;\n            }\n        }\n        if i ==\
    \ 3 {\n            if part.len() != 4 {\n                return false;\n     \
    \       }\n            let _: Result<u16, ParseIntError> = part.parse();\n   \
    \         if part.parse::<u16>().is_err() {\n                return false;\n \
    \           }\n        }\n    }\n    let month: u8 = parts[0].parse().unwrap();\n\
    \    let day: u8 = parts[1].parse().unwrap();\n    if (month == 1 || month ==\
    \ 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) &&\
    \ (day < 1 || day > 31) {\n        return false;\n    }\n    if (month == 4 ||\
    \ month == 6 || month == 9 || month == 11) && (day < 1 || day > 30) {\n      \
    \  return false;\n    }\n    if month == 2 && (day < 1 || day > 29) {\n      \
    \  return false;\n    }\n    true", "    if date.chars().count() != 10 {\n   \
    \     return false;\n    }\n    let date_vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    let month: i32 = date_vec[0].parse().unwrap();\n    let day: i32 = date_vec[1].parse().unwrap();\n\
    \    let year: i32 = date_vec[2].parse().unwrap();\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n    if day < 1 || day > 31 {\n       \
    \ return false;\n    }\n    if month == 2 && day == 29 {\n        if year % 400\
    \ == 0 || (year % 4 == 0 && year % 100 != 0) {\n            return true;\n   \
    \     }\n        return false;\n    }\n    if month == 2 && day > 29 {\n     \
    \   return false;\n    }\n    if day > 30 && (month == 4 || month == 6 || month\
    \ == 9 || month == 11) {\n        return false;\n    }\n    true", "    // your\
    \ code here\n    false", '    unimplemented!()', "    let y: u32 = date.split('-').collect::<Vec<&str>>()[2].parse().unwrap();\n\
    \    // Check if the year is a leap year.\n    let l = |y: u32| y % 4 == 0 &&\
    \ (y % 100 != 0 || y % 400 == 0);\n    if date.is_empty() {\n        return false;\n\
    \    } else if date.len() != 10 {\n        return false;\n    } else if date.contains('/')\
    \ {\n        return false;\n    }\n    let m: u32 = date.split('-').collect::<Vec<&str>>()[0].parse().unwrap();\n\
    \    let d: u32 = date.split('-').collect::<Vec<&str>>()[1].parse().unwrap();\n\
    \    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12)\
    \ && (d < 1 || d > 31) {\n        return false;\n    } else if (m == 4 || m ==\
    \ 6 || m == 9 || m == 11) && (d < 1 || d > 30) {\n        return false;\n    }\
    \ else if (m == 2) && ((d < 1 || d > 29) || (d == 29 && !l(y))) {\n        return\
    \ false;\n    } else if m < 1 || m > 12 {\n        return false;\n    }\n    true",
  "    // get separate the day, month and year from the date.\n    let mut d = date.split(\"\
    -\");\n    // if the date doesn't contain the above characters then return false.\n\
    \    if d.clone().count() != 3 {\n        return false;\n    }\n    // check that\
    \ the date format is in \"mm-dd-yyyy\" format\n    let _mm = d.nth(0).unwrap();\n\
    \    let _dd = d.nth(0).unwrap();\n    let _yyyy = d.nth(0).unwrap();\n    //\
    \ here we will implement the checks for the date.\n    if let Ok(mm) = _mm.parse::<i32>()\
    \ {\n        if mm < 1 || mm > 12 {\n            return false;\n        }\n  \
    \  } else {\n        return false;\n    }\n    if let Ok(dd) = _dd.parse::<i32>()\
    \ {\n        if dd < 1 || dd > 31 {\n            return false;\n        }\n  \
    \  } else {\n        return false;\n    }\n    if let Ok(yyyy) = _yyyy.parse::<i32>()\
    \ {\n        if yyyy > 3000 {\n            return false;\n        }\n    } else\
    \ {\n        return false;\n    }\n    // if all checks pass then return true.\n\
    \    true", "    if date.is_empty() {\n        return false;\n    }\n    if date.len()\
    \ != 10 {\n        return false;\n    }\n    let mut temp_date = date.clone();\n\
    \    temp_date.retain(|c| c != '-');\n    if !temp_date.chars().all(|c| c.is_numeric())\
    \ {\n        return false;\n    }\n    let mut date_vec: Vec<_> = date.split('-').collect();\n\
    \    if date_vec.len() != 3 {\n        return false;\n    }\n    let days = date_vec[1].parse::<i32>().unwrap();\n\
    \    let months = date_vec[0].parse::<i32>().unwrap();\n    let years = date_vec[2].parse::<i32>().unwrap();\n\
    \    if months > 12 || months < 1 {\n        return false;\n    }\n    match months\
    \ {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if days > 31 || days\
    \ < 1 {\n                return false;\n            }\n        }\n        4 |\
    \ 6 | 9 | 11 => {\n            if days > 30 || days < 1 {\n                return\
    \ false;\n            }\n        }\n        2 => {\n            if years % 4 ==\
    \ 0 {\n                if days > 29 || days < 1 {\n                    return\
    \ false;\n                }\n            } else {\n                if days > 28\
    \ || days < 1 {\n                    return false;\n                }\n      \
    \      }\n        }\n        _ => return false,\n    }\n    true", "    let re\
    \ = Regex::new(r\"^([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[1-2][0-9]|3[0-1])-(\\\
    d{4})$\").unwrap();\n    if re.is_match(&date) {\n        let re = Regex::new(r\"\
    ^(01|03|05|07|08|10|12)-([1-9]|0[1-9]|[1-2][0-9]|3[0-1])-(\\d{4})$\").unwrap();\n\
    \        if re.is_match(&date) {\n            return true;\n        }\n      \
    \  let re = Regex::new(r\"^(04|06|09|11)-([1-9]|0[1-9]|[1-2][0-9])-(\\d{4})$\"\
    ).unwrap();\n        if re.is_match(&date) {\n            return true;\n     \
    \   }\n        let re = Regex::new(r\"^02-([1-9]|0[1-9]|1[0-9]|2[0-9])-(\\d{4})$\"\
    ).unwrap();\n        if re.is_match(&date) {\n            return true;\n     \
    \   }\n    }\n    false", "    let (month, day, year) = get_date_details(date);\n\
    \    match (month, day, year) {\n        (Some(month), Some(day), Some(year))\
    \ => valid_date_number(month, day, year),\n        _ => false,\n    }", "    let\
    \ date_split: Vec<&str> = date.split(\"-\").collect();\n    if date_split.len()\
    \ != 3 {\n        return false;\n    }\n    let month: i32 = date_split[0].parse().unwrap();\n\
    \    let day: i32 = date_split[1].parse().unwrap();\n    let year: i32 = date_split[2].parse().unwrap();\n\
    \    if (month < 1 || month > 12) || (day < 1 || day > 31) || (year < 1) {\n \
    \       return false;\n    }\n    if month == 2 {\n        if (day < 1 || day\
    \ > 29) {\n            return false;\n        }\n    } else if (month == 4 ||\
    \ month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30)\
    \ {\n            return false;\n        }\n    }\n    return true;", "    let\
    \ re = Regex::new(r\"^([0-1]?[0-9])\\-([0-3]?[0-9])\\-([0-9]{4})$\").unwrap();\n\
    \    if re.is_match(&date) {\n        let numbers: Vec<&str> = date.split(\"-\"\
    ).collect();\n        let month: i32 = numbers[0].parse().unwrap();\n        let\
    \ day: i32 = numbers[1].parse().unwrap();\n        let year: i32 = numbers[2].parse().unwrap();\n\
    \        if year % 4 == 0 {\n            if month == 2 && day <= 29 {\n      \
    \          return true;\n            }\n        } else {\n            if month\
    \ == 2 && day <= 28 {\n                return true;\n            }\n        }\n\
    \        if (month == 1 || month == 3 || month == 5 || month == 7 || month ==\
    \ 8 || month == 10 || month == 12) && day <= 31 {\n            return true;\n\
    \        }\n        if (month == 4 || month == 6 || month == 9 || month == 11)\
    \ && day <= 30 {\n            return true;\n        }\n    }\n    false", "  \
    \  // unimplemented!();\n    return date.len() > 0 && date.starts_with(\"0\")\
    \ == false && date.starts_with(\"1\") == false;", '    unimplemented!()', "  \
    \  // check if not empty\n    if date.is_empty() {\n        return false;\n  \
    \  }\n\n    // split string by '-'\n    let split_date: Vec<&str> = date.split('-').collect();\n\
    \n    // check if valid\n    if split_date.len() != 3 {\n        return false;\n\
    \    }\n\n    // check if all components are numbers\n    let mut valid_numbers\
    \ = true;\n    for component in split_date {\n        if component.parse::<i32>().is_err()\
    \ {\n            valid_numbers = false;\n            break;\n        }\n    }\n\
    \n    if !valid_numbers {\n        return false;\n    }\n\n    // cast and check\
    \ all components\n    // month\n    let month = split_date[0].parse::<i32>().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n\n    // day\n\
    \    let day = split_date[1].parse::<i32>().unwrap();\n    if month == 2 {\n \
    \       if day < 1 || day > 29 {\n            return false;\n        }\n    }\
    \ else if month == 1 || month == 3 || month == 5 || month == 7 || month == 8 ||\
    \ month == 10 || month == 12 {\n        if day < 1 || day > 31 {\n           \
    \ return false;\n        }\n    } else {\n        if day < 1 || day > 30 {\n \
    \           return false;\n        }\n    }\n\n    // year\n    let year = split_date[2].parse::<i32>().unwrap();\n\
    \    if year < 0 {\n        return false;\n    }\n\n    true", "    let re = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\").unwrap();\n    if re.is_match(&date)\
    \ {\n        let mut components = date.split(\"-\");\n        let month = components.next().unwrap().parse::<i32>().unwrap();\n\
    \        let day = components.next().unwrap().parse::<i32>().unwrap();\n     \
    \   let year = components.next().unwrap().parse::<i32>().unwrap();\n        match\
    \ month {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31,\n\
    \            4 | 6 | 9 | 11 => day >= 1 && day <= 30,\n            2 => {\n  \
    \              if is_leap_year(year) {\n                    day >= 1 && day <=\
    \ 29\n                } else {\n                    day >= 1 && day <= 28\n  \
    \              }\n            }\n            _ => false,\n        }\n    } else\
    \ {\n        false\n    }", "    lazy_static! {\n        static ref RE: Regex\
    \ = Regex::new(r\"^(\\d\\d)-(\\d\\d)-(\\d\\d\\d\\d)$\").unwrap();\n    }\n   \
    \ match RE.captures(&date) {\n        Some(captures) => {\n            let days\
    \ = captures.get(2).unwrap().as_str().parse::<i64>().unwrap();\n            let\
    \ months = captures.get(1).unwrap().as_str().parse::<i64>().unwrap();\n      \
    \      let years = captures.get(3).unwrap().as_str().parse::<i64>().unwrap();\n\
    \            match months {\n                1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n\
    \                    if days >= 1 && days <= 31 {\n                        return\
    \ true;\n                    }\n                }\n                4 | 6 | 9 |\
    \ 11 => {\n                    if days >= 1 && days <= 30 {\n                \
    \        return true;\n                    }\n                }\n            \
    \    2 => {\n                    if days >= 1 && days <= 29 {\n              \
    \          return true;\n                    }\n                }\n          \
    \      _ => {\n                    return false;\n                }\n        \
    \    }\n            return false;\n        }\n        None => {\n            return\
    \ false;\n        }\n    }", "    use regex::Regex;\n    lazy_static! {\n    \
    \    static ref DATE_REGEX: Regex = Regex::new(r\"^((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3[0-1]))-([0-9]{4})$\"\
    ).unwrap();\n    }\n    if !DATE_REGEX.is_match(&date) {\n        return false;\n\
    \    }\n    let days = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\
    \    let mut split = date.split(\"-\");\n    let month = split.next().unwrap().parse::<u8>().unwrap();\n\
    \    let day = split.next().unwrap().parse::<u8>().unwrap();\n    let year = split.next().unwrap().parse::<u16>().unwrap();\n\
    \    if day == 0 || month == 0 || day > days[month as usize - 1] {\n        return\
    \ false;\n    }\n    if month == 2 && day == 29 {\n        let mut leap = false;\n\
    \        if year % 4 == 0 {\n            leap = true;\n            if year % 100\
    \ == 0 {\n                leap = false;\n                if year % 400 == 0 {\n\
    \                    leap = true;\n                }\n            }\n        }\n\
    \        if !leap {\n            return false;\n        }\n    }\n    true", " \
    \   let re = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n    let cap =\
    \ re.captures(&date);\n    if cap.is_none() {\n        return false;\n    }\n\
    \    let re_year = Regex::new(r\"^\\d{4}$\").unwrap();\n    let cap_year = re_year.captures(&cap.unwrap()[0]);\n\
    \    if cap_year.is_none() {\n        return false;\n    }\n    let re_month =\
    \ Regex::new(r\"^\\d{2}$\").unwrap();\n    let cap_month = re_month.captures(&cap.unwrap()[1]);\n\
    \    if cap_month.is_none() {\n        return false;\n    }\n    let re_day =\
    \ Regex::new(r\"^\\d{2}$\").unwrap();\n    let cap_day = re_day.captures(&cap.unwrap()[2]);\n\
    \    if cap_day.is_none() {\n        return false;\n    }\n    let mut year =\
    \ cap_year.unwrap()[0].parse::<i32>().unwrap();\n    let mut month = cap_month.unwrap()[0].parse::<i32>().unwrap();\n\
    \    let mut day = cap_day.unwrap()[0].parse::<i32>().unwrap();\n    if year %\
    \ 4 == 0 && year % 100 != 0 || year % 400 == 0 {\n        if month == 2 && day\
    \ > 29 {\n            return false;\n        }\n    } else {\n        if month\
    \ == 2 && day > 28 {\n            return false;\n        }\n    }\n    if month\
    \ == 4 || month == 6 || month == 9 || month == 11 {\n        if day > 30 {\n \
    \           return false;\n        }\n    }\n    if month > 12 {\n        return\
    \ false;\n    }\n    true", "    let re = Regex::new(r\"^(\\d\\d)-(\\d\\d)-(\\\
    d\\d\\d\\d)$\").unwrap();\n    if re.is_match(&date) {\n        let caps = re.captures(&date).unwrap();\n\
    \        let month = caps.get(1).unwrap().as_str().parse::<u32>().unwrap();\n\
    \        let day = caps.get(2).unwrap().as_str().parse::<u32>().unwrap();\n  \
    \      if !(1 <= month && month <= 12) {\n            return false;\n        }\n\
    \        match month {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n       \
    \         if !(1 <= day && day <= 31) {\n                    return false;\n \
    \               }\n            }\n            4 | 6 | 9 | 11 => {\n          \
    \      if !(1 <= day && day <= 30) {\n                    return false;\n    \
    \            }\n            }\n            2 => {\n                if !(1 <= day\
    \ && day <= 29) {\n                    return false;\n                }\n    \
    \        }\n            _ => return false,\n        }\n        return true;\n\
    \    }\n    false", "    let date_vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    let valid_date_format = date_vec.len() == 3;\n    let valid_month = valid_month_value(date_vec[0]);\n\
    \    let valid_day = valid_day_value(date_vec[1], date_vec[0]);\n    let valid_year\
    \ = valid_year_value(date_vec[2]);\n    valid_date_format && valid_month && valid_day\
    \ && valid_year", "    let re = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n\
    \    if !re.is_match(&date) {\n        return false;\n    }\n    let date_vec:\
    \ Vec<&str> = date.split(\"-\").collect();\n    let month: i32 = date_vec[0].parse().unwrap();\n\
    \    let day: i32 = date_vec[1].parse().unwrap();\n    let year: i32 = date_vec[2].parse().unwrap();\n\
    \    if year < 0 {\n        return false;\n    }\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    if month == 2 {\n        if year % 4\
    \ == 0 {\n            if day < 1 || day > 29 {\n                return false;\n\
    \            }\n        } else {\n            if day < 1 || day > 28 {\n     \
    \           return false;\n            }\n        }\n    } else if month == 4\
    \ || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30\
    \ {\n            return false;\n        }\n    } else {\n        if day < 1 ||\
    \ day > 31 {\n            return false;\n        }\n    }\n    true", "    let\
    \ arr: Vec<&str> = date.split(\"-\").collect();\n    if arr.len() != 3 {\n   \
    \     return false;\n    }\n    let month: i32 = arr[0].parse().unwrap();\n  \
    \  let day: i32 = arr[1].parse().unwrap();\n    let year: i32 = arr[2].parse().unwrap();\n\
    \    if year == 0 {\n        return false;\n    }\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    if day < 1 || day > 31 {\n        return\
    \ false;\n    }\n    if month == 2 {\n        if day > 29 {\n            return\
    \ false;\n        }\n    }\n    if (month == 4 || month == 6 || month == 9 ||\
    \ month == 11) && day > 30 {\n        return false;\n    }\n    true", "    if\
    \ date.len() != 10 {\n        return false;\n    }\n    for d in date.chars()\
    \ {\n        if d == '-' {\n            continue;\n        }\n        if !d.is_numeric()\
    \ {\n            return false;\n        }\n    }\n    let date_vec: Vec<_> = date.split('-').collect();\n\
    \    let month = date_vec[0].parse::<u32>().unwrap();\n    let day = date_vec[1].parse::<u32>().unwrap();\n\
    \    let year = date_vec[2].parse::<u32>().unwrap();\n    if year < 1900 || year\
    \ > 2020 {\n        return false;\n    }\n    if month > 12 || month < 1 {\n \
    \       return false;\n    }\n    if day > 31 || day < 1 {\n        return false;\n\
    \    }\n    if (month == 4 || month == 6 || month == 9 || month == 11) && day\
    \ > 30 {\n        return false;\n    }\n    if month == 2 && year % 4 == 0 &&\
    \ year % 100 != 0 && day > 29 {\n        return false;\n    }\n    if month ==\
    \ 2 && year % 100 == 0 && year % 400 == 0 && day > 29 {\n        return false;\n\
    \    }\n    if month == 2 && year % 4 != 0 && day > 28 {\n        return false;\n\
    \    }\n    true", '    unimplemented!()', "    let split: Vec<&str> = date.split(\"\
    -\").collect();\n    if split.len() != 3 {\n        return false;\n    }\n   \
    \ let month: u8 = split[0].parse().unwrap();\n    let day: u8 = split[1].parse().unwrap();\n\
    \    if day < 1 || day > 31 {\n        return false;\n    }\n    if month < 1\
    \ || month > 12 {\n        return false;\n    }\n    if (day > 29 && month ==\
    \ 2)\n        || (day > 30 && (month == 4 || month == 6 || month == 9 || month\
    \ == 11))\n    {\n        return false;\n    }\n    true", "    let date_vec:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_vec.len() != 3 {\n   \
    \     return false;\n    }\n    let month: &str = date_vec[0];\n    let day: &str\
    \ = date_vec[1];\n    let year: &str = date_vec[2];\n    let month: i32 = match\
    \ month.parse() {\n        Ok(num) => num,\n        Err(_) => return false,\n\
    \    };\n    let day: i32 = match day.parse() {\n        Ok(num) => num,\n   \
    \     Err(_) => return false,\n    };\n    let year: i32 = match year.parse()\
    \ {\n        Ok(num) => num,\n        Err(_) => return false,\n    };\n    if\
    \ month < 1 || month > 12 {\n        return false;\n    }\n    if (month == 1\
    \ || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month\
    \ == 12) && (day < 1 || day > 31) {\n        return false;\n    }\n    if (month\
    \ == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30) {\n\
    \        return false;\n    }\n    if month == 2 && (day < 1 || day > 29) {\n\
    \        return false;\n    }\n    true", "    let mut days = 0;\n    let mut\
    \ months = 0;\n    let mut years = 0;\n    if !date.is_empty() {\n        let\
    \ data = date.split(\"-\").collect::<Vec<&str>>();\n        if data.len() == 3\
    \ {\n            match data[0].parse::<u32>() {\n                Ok(m) => months\
    \ = m,\n                Err(_) => return false,\n            }\n            match\
    \ data[1].parse::<u32>() {\n                Ok(d) => days = d,\n             \
    \   Err(_) => return false,\n            }\n            match data[2].parse::<u32>()\
    \ {\n                Ok(y) => years = y,\n                Err(_) => return false,\n\
    \            }\n            if months < 1 || months > 12 {\n                return\
    \ false;\n            }\n            if months == 2 {\n                if days\
    \ < 1 || days > 29 {\n                    return false;\n                }\n \
    \           } else if months % 2 == 0 {\n                if days < 1 || days >\
    \ 30 {\n                    return false;\n                }\n            } else\
    \ {\n                if days < 1 || days > 31 {\n                    return false;\n\
    \                }\n            }\n            return true;\n        }\n    }\n\
    \    false", "    let splitted_date: Vec<&str> = date.split(\"-\").collect();\n\
    \    if splitted_date.len() != 3 {\n        return false;\n    }\n    let day\
    \ = splitted_date[1].parse::<u8>().unwrap();\n    let month = splitted_date[0].parse::<u8>().unwrap();\n\
    \    let year = splitted_date[2].parse::<u32>().unwrap();\n    if month < 1 ||\
    \ month > 12 {\n        return false;\n    }\n    match month {\n        1 | 3\
    \ | 5 | 7 | 8 | 10 | 12 => {\n            return day > 0 && day < 32;\n      \
    \  }\n        4 | 6 | 9 | 11 => {\n            return day > 0 && day < 31;\n \
    \       }\n        2 => {\n            if year % 4 == 0 {\n                return\
    \ day > 0 && day < 30;\n            } else {\n                return day > 0 &&\
    \ day < 29;\n            }\n        }\n        _ => false,\n    }", "    // Your\
    \ code here\n    false", "    use std::str::FromStr;\n    let mut parts = date.split('-');\n\
    \    let month = u32::from_str(parts.next().unwrap()).unwrap();\n    let day =\
    \ u32::from_str(parts.next().unwrap()).unwrap();\n    let year = u32::from_str(parts.next().unwrap()).unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if year <\
    \ 1 {\n        return false;\n    }\n    if day < 1 {\n        return false;\n\
    \    }\n    if month == 2 {\n        if day > 29 {\n            return false;\n\
    \        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11\
    \ {\n        if day > 30 {\n            return false;\n        }\n    } else {\n\
    \        if day > 31 {\n            return false;\n        }\n    }\n    true",
  "    date.split('-').count() == 3\n        && date\n            .split('-')\n  \
    \          .collect::<Vec<&str>>()\n            .iter()\n            .map(|x|\
    \ x.parse::<u32>().is_ok())\n            .collect::<Vec<bool>>()\n           \
    \ .iter()\n            .filter(|x| **x == false)\n            .count()\n     \
    \       == 0\n        && if date.split('-').collect::<Vec<&str>>()[0].parse::<u32>().unwrap()\
    \ > 12 {\n            false\n        } else {\n            true\n        }\n \
    \       && if [1, 3, 5, 7, 8, 10, 12].contains(&date.split('-').collect::<Vec<&str>>()[0].parse::<u32>().unwrap())\n\
    \            && date.split('-').collect::<Vec<&str>>()[1].parse::<u32>().unwrap()\
    \ > 31\n        {\n            false\n        } else if [4, 6, 9, 11].contains(&date.split('-').collect::<Vec<&str>>()[0].parse::<u32>().unwrap())\n\
    \            && date.split('-').collect::<Vec<&str>>()[1].parse::<u32>().unwrap()\
    \ > 30\n        {\n            false\n        } else if [2].contains(&date.split('-').collect::<Vec<&str>>()[0].parse::<u32>().unwrap())\n\
    \            && date.split('-').collect::<Vec<&str>>()[1].parse::<u32>().unwrap()\
    \ > 29\n        {\n            false\n        } else {\n            true\n   \
    \     }", "    let v: Vec<&str> = date.split(\"-\").collect();\n    let (day,\
    \ month, year) = (v[0].parse::<u32>().unwrap(), v[1].parse::<u32>().unwrap(),\
    \ v[2].parse::<u32>().unwrap());\n    if v.len() != 3 || year < 1900 || year >\
    \ 9999 {\n        return false;\n    }\n    match month {\n        1 | 3 | 5 |\
    \ 7 | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n               \
    \ return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n     \
    \       if day < 1 || day > 30 {\n                return false;\n            }\n\
    \        }\n        2 => {\n            if day < 1 || day > 29 {\n           \
    \     return false;\n            }\n        }\n        _ => return false,\n  \
    \  }\n    true", "    let date_iter = date.split(\"-\");\n    let mut date_vec:\
    \ Vec<&str> = Vec::new();\n    for d in date_iter {\n        date_vec.push(d);\n\
    \    }\n    if date_vec.len() != 3 {\n        return false;\n    }\n    if date_vec[0].len()\
    \ != 2 || date_vec[1].len() != 2 || date_vec[2].len() != 4 {\n        return false;\n\
    \    }\n    let month: u32 = match date_vec[0].parse() {\n        Ok(num) => num,\n\
    \        Err(_) => return false,\n    };\n    let day: u32 = match date_vec[1].parse()\
    \ {\n        Ok(num) => num,\n        Err(_) => return false,\n    };\n    let\
    \ year: u32 = match date_vec[2].parse() {\n        Ok(num) => num,\n        Err(_)\
    \ => return false,\n    };\n    if month < 1 || month > 12 {\n        return false;\n\
    \    }\n    if month == 2 {\n        if is_leap_year(year) {\n            if day\
    \ < 1 || day > 29 {\n                return false;\n            }\n        } else\
    \ {\n            if day < 1 || day > 28 {\n                return false;\n   \
    \         }\n        }\n    } else if month == 1 || month == 3 || month == 5 ||\
    \ month == 7 || month == 8 || month == 10 || month == 12 {\n        if day < 1\
    \ || day > 31 {\n            return false;\n        }\n    } else {\n        if\
    \ day < 1 || day > 30 {\n            return false;\n        }\n    }\n    true",
  "    let tokens: Vec<String> = date.split('-').map(|s| s.to_string()).collect();\n\
    \    if tokens.len() != 3 {\n        return false;\n    }\n    let days = tokens[1].parse::<u32>().unwrap();\n\
    \    let months = tokens[0].parse::<u32>().unwrap();\n    if months > 12 || months\
    \ < 1 {\n        return false;\n    }\n    match months {\n        1 | 3 | 5 |\
    \ 7 | 8 | 10 | 12 => {\n            if days > 31 || days < 1 {\n             \
    \   return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n   \
    \         if days > 30 || days < 1 {\n                return false;\n        \
    \    }\n        }\n        2 => {\n            if days > 29 || days < 1 {\n  \
    \              return false;\n            }\n        }\n        _ => return false,\n\
    \    }\n    true", "    let pattern = \"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ;\n    date.contains(pattern)", "    if date.is_empty() {\n        return false;\n\
    \    }\n    let tokens: Vec<&str> = date.split(\"-\").collect();\n    if tokens.len()\
    \ != 3 {\n        return false;\n    }\n    let month: i32 = tokens[0].parse().unwrap();\n\
    \    let day: i32 = tokens[1].parse().unwrap();\n    let year: i32 = tokens[2].parse().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if year <\
    \ 1 {\n        return false;\n    }\n    match month {\n        1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => {\n            if day > 31 || day < 1 {\n                return\
    \ false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if\
    \ day > 30 || day < 1 {\n                return false;\n            }\n      \
    \  }\n        2 => {\n            if year % 4 == 0 {\n                if day >\
    \ 29 || day < 1 {\n                    return false;\n                }\n    \
    \        } else {\n                if day > 28 || day < 1 {\n                \
    \    return false;\n                }\n            }\n        }\n        _ =>\
    \ return false,\n    }\n    true", "    let re = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\"\
    ).unwrap();\n    let parts: Vec<&str> = re.captures(&date).unwrap().iter().map(|m|\
    \ m.unwrap().as_str()).collect();\n    if let [_, month, day, year] = parts.as_slice()\
    \ {\n        match month.parse::<u32>().unwrap() {\n            1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => day.parse::<u32>().unwrap() > 0 && day.parse::<u32>().unwrap()\
    \ <= 31,\n            4 | 6 | 9 | 11 => day.parse::<u32>().unwrap() > 0 && day.parse::<u32>().unwrap()\
    \ <= 30,\n            2 => day.parse::<u32>().unwrap() > 0 && day.parse::<u32>().unwrap()\
    \ <= 29,\n            _ => false,\n        }\n    } else {\n        false\n  \
    \  }", "    if date.is_empty() {\n        return false;\n    }\n    let mut valid_date\
    \ = false;\n    let sp = String::from(\"-\");\n    let mut dt: Vec<&str> = date.split(sp.as_str()).collect();\n\
    \    if dt.len() != 3 {\n        return false;\n    }\n    let days = dt[1].parse::<i32>().unwrap();\n\
    \    let months = dt[0].parse::<i32>().unwrap();\n    let years = dt[2].parse::<i32>().unwrap();\n\
    \    if months == 1 || months == 3 || months == 5 || months == 7 || months ==\
    \ 8 || months == 10 || months == 12 {\n        if days <= 31 && days >= 1 {\n\
    \            valid_date = true;\n        }\n    } else if months == 4 || months\
    \ == 6 || months == 9 || months == 11 {\n        if days <= 30 && days >= 1 {\n\
    \            valid_date = true;\n        }\n    } else if months == 2 {\n    \
    \    if days <= 29 && days >= 1 {\n            valid_date = true;\n        }\n\
    \    }\n    if months <= 12 && months >= 1 {\n        valid_date = true;\n   \
    \ }\n    if valid_date {\n        if years >= 1950 && years <= 2040 {\n      \
    \      valid_date = true;\n        }\n    }\n    valid_date", "    let splits:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if splits.len() != 3 {\n     \
    \   return false;\n    }\n    let month = splits[0].parse::<i32>().unwrap();\n\
    \    let day = splits[1].parse::<i32>().unwrap();\n    let year = splits[2].parse::<i32>().unwrap();\n\
    \    if year < 0 {\n        return false;\n    }\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    if month == 2 {\n        if day < 1\
    \ || day > 29 {\n            return false;\n        }\n    } else if month ==\
    \ 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day >\
    \ 30 {\n            return false;\n        }\n    } else {\n        if day < 1\
    \ || day > 31 {\n            return false;\n        }\n    }\n    true", "   \
    \ let m = Regex::new(r\"(\\d{2})-(\\d{2})-(\\d{4})\").unwrap();\n    m.is_match(&date)",
  "    let re = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\").unwrap();\n  \
    \  let caps = re.captures(&date).unwrap();\n    if caps.get(0).is_none() {\n \
    \       return false;\n    }\n    let month = caps.get(1).unwrap().as_str().parse::<u32>().unwrap();\n\
    \    let day = caps.get(2).unwrap().as_str().parse::<u32>().unwrap();\n    let\
    \ year = caps.get(3).unwrap().as_str().parse::<u32>().unwrap();\n    if month\
    \ < 1 || month > 12 {\n        return false;\n    }\n    if month == 2 {\n   \
    \     if year % 4 == 0 {\n            return day >= 1 && day <= 29;\n        }\
    \ else {\n            return day >= 1 && day <= 28;\n        }\n    }\n    if\
    \ month == 4 || month == 6 || month == 9 || month == 11 {\n        return day\
    \ >= 1 && day <= 30;\n    }\n    return day >= 1 && day <= 31;", "    lazy_static!\
    \ {\n        static ref RE: Regex = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-(\\\
    d{4})$\").unwrap();\n    }\n    RE.is_match(&date)", "    let mut ds = date.split('-');\n\
    \    let mut months = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\
    \    let mut m: u32 = 0;\n    let mut d: u32 = 0;\n    let mut y: u32 = 0;\n \
    \   if let Some(ms) = ds.next() {\n        if let Ok(month) = ms.parse::<u32>()\
    \ {\n            m = month;\n        } else {\n            return false;\n   \
    \     }\n    } else {\n        return false;\n    }\n    if let Some(ds) = ds.next()\
    \ {\n        if let Ok(day) = ds.parse::<u32>() {\n            d = day;\n    \
    \    } else {\n            return false;\n        }\n    } else {\n        return\
    \ false;\n    }\n    if let Some(ys) = ds.next() {\n        if let Ok(year) =\
    \ ys.parse::<u32>() {\n            y = year;\n        } else {\n            return\
    \ false;\n        }\n    } else {\n        return false;\n    }\n    if m == 0\
    \ || m > 12 || d == 0 || d > 31 || y == 0 {\n        return false;\n    }\n  \
    \  if y % 4 == 0 {\n        months[1] = 29;\n    }\n    if d > months[(m - 1)\
    \ as usize] {\n        return false;\n    }\n    true", '    date.split("-").map(|x|
    x.parse::<u8>().is_ok()).all(|x| x)', "    let re = Regex::new(r\"(\\d{2})-(\\\
    d{2})-(\\d{4})\").unwrap();\n    let captures = re.captures(&date);\n    match\
    \ captures {\n        Some(cap) => {\n            let month = &cap[1];\n     \
    \       let day = &cap[2];\n            let year = &cap[3];\n            if year.parse::<i32>().unwrap()\
    \ > 0 {\n                if month.parse::<i32>().unwrap() > 0 && month.parse::<i32>().unwrap()\
    \ < 13 {\n                    if day.parse::<i32>().unwrap() > 0 {\n         \
    \               if month.parse::<i32>().unwrap() == 1 || month.parse::<i32>().unwrap()\
    \ == 3 || month.parse::<i32>().unwrap() == 5 || month.parse::<i32>().unwrap()\
    \ == 7 || month.parse::<i32>().unwrap() == 8 || month.parse::<i32>().unwrap()\
    \ == 10 || month.parse::<i32>().unwrap() == 12 {\n                           \
    \ if day.parse::<i32>().unwrap() < 32 {\n                                return\
    \ true;\n                            }\n                        } else if month.parse::<i32>().unwrap()\
    \ == 4 || month.parse::<i32>().unwrap() == 6 || month.parse::<i32>().unwrap()\
    \ == 9 || month.parse::<i32>().unwrap() == 11 {\n                            if\
    \ day.parse::<i32>().unwrap() < 31 {\n                                return true;\n\
    \                            }\n                        } else if month.parse::<i32>().unwrap()\
    \ == 2 {\n                            if day.parse::<i32>().unwrap() < 30 {\n\
    \                                return true;\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            false\n        }\n        None => false,\n    }", "    match\
    \ date.len() {\n        0 => false,\n        _ => {\n            let mut splits\
    \ = date.split(\"-\");\n            match (splits.next(), splits.next(), splits.next())\
    \ {\n                (Some(month), Some(day), Some(year)) => {\n             \
    \       match (\n                        month.parse::<u32>(),\n             \
    \           day.parse::<u32>(),\n                        year.parse::<u32>(),\n\
    \                    ) {\n                        (Ok(month), Ok(day), Ok(year))\
    \ => {\n                            if month == 0 || month > 12 {\n          \
    \                      return false;\n                            }\n\n      \
    \                      match month {\n                                1 | 3 |\
    \ 5 | 7 | 8 | 10 | 12 => {\n                                    day > 0 && day\
    \ <= 31\n                                }\n                                4\
    \ | 6 | 9 | 11 => {\n                                    day > 0 && day <= 30\n\
    \                                }\n                                2 => {\n \
    \                                   day > 0 && day <= 29\n                   \
    \             }\n                                _ => false,\n               \
    \             }\n                        }\n                        _ => false,\n\
    \                    }\n                }\n                _ => false,\n     \
    \       }\n        }\n    }", "    let months = vec![\n        \"January\", \"\
    February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"\
    September\",\n        \"October\", \"November\", \"December\",\n    ];\n    let\
    \ words: Vec<&str> = date.split(' ').collect();\n    if words.len() != 3 {\n \
    \       return false;\n    }\n    let months_vec: Vec<&str> = months.iter().map(|&x|\
    \ x).collect();\n    if !months_vec.contains(&words[0]) {\n        return false;\n\
    \    }\n    let date_vec: Vec<&str> = words[1].split(',').collect();\n    if date_vec.len()\
    \ != 2 {\n        return false;\n    }\n    let date_num: Vec<u32> = date_vec[0].split('\
    \ ').map(|x| x.parse().unwrap()).collect();\n    if date_num.len() != 1 {\n  \
    \      return false;\n    }\n    let year: Vec<u32> = date_vec[1].split(' ').map(|x|\
    \ x.parse().unwrap()).collect();\n    if year.len() != 1 {\n        return false;\n\
    \    }\n    let mut result = false;\n    for m in 0..months.len() {\n        if\
    \ words[0] == months[m] {\n            match m {\n                1 => {\n   \
    \                 if date_num[0] >= 1 && date_num[0] <= 28 {\n               \
    \         result = true;\n                    }\n                }\n         \
    \       3 | 5 | 8 | 10 => {\n                    if date_num[0] >= 1 && date_num[0]\
    \ <= 30 {\n                        result = true;\n                    }\n   \
    \             }\n                _ => {\n                    if date_num[0] >=\
    \ 1 && date_num[0] <= 31 {\n                        result = true;\n         \
    \           }\n                }\n            }\n        }\n    }\n    result",
  "    let numbers: Vec<i32> = date\n        .split('-')\n        .map(|x| x.parse::<i32>().unwrap())\n\
    \        .collect();\n    let months = [\n        31, 28, 31, 30, 31, 30, 31,\
    \ 31, 30, 31, 30, 31,\n    ];\n    let is_leap_year = |year: i32| -> bool {\n\
    \        if year % 4 == 0 {\n            if year % 100 == 0 {\n              \
    \  if year % 400 == 0 {\n                    true\n                } else {\n\
    \                    false\n                }\n            } else {\n        \
    \        true\n            }\n        } else {\n            false\n        }\n\
    \    };\n    let mut result = true;\n    if numbers.len() != 3 {\n        result\
    \ = false;\n    } else {\n        let month = numbers[0];\n        let day = numbers[1];\n\
    \        let year = numbers[2];\n        if month < 1 || month > 12 {\n      \
    \      result = false;\n        } else {\n            if day < 1 || day > months[(month\
    \ - 1) as usize] {\n                if is_leap_year(year) && month == 2 && day\
    \ == 29 {\n                    // do nothing\n                } else {\n     \
    \               result = false;\n                }\n            }\n        }\n\
    \    }\n    result", '    false', "    let mut result = false;\n    let valid_format\
    \ = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n    if valid_format.is_match(&date)\
    \ {\n        let date: Vec<i32> = date\n            .split(\"-\")\n          \
    \  .map(|s| s.parse::<i32>().unwrap())\n            .collect();\n        if date[0]\
    \ > 0 && date[0] < 13 && date[1] > 0 && date[2] > 0 {\n            if date[0]\
    \ % 2 == 0 {\n                if date[0] == 2 {\n                    if date[1]\
    \ <= 29 {\n                        result = true;\n                    }\n   \
    \             } else if date[0] < 8 {\n                    if date[1] <= 30 {\n\
    \                        result = true;\n                    }\n             \
    \   } else {\n                    if date[1] <= 31 {\n                       \
    \ result = true;\n                    }\n                }\n            } else\
    \ {\n                if date[0] == 1 || date[0] == 3 || date[0] == 5 || date[0]\
    \ == 7 || date[0] == 8\n                    || date[0] == 10 || date[0] == 12\n\
    \                {\n                    if date[1] <= 31 {\n                 \
    \       result = true;\n                    }\n                } else {\n    \
    \                if date[1] <= 30 {\n                        result = true;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   result", "    let mut result = true;\n    if !date.is_empty() {\n        let\
    \ mut parts: Vec<&str> = date.split(\"-\").collect();\n        if parts.len()\
    \ != 3 {\n            result = false;\n        } else {\n            let mut month:\
    \ i32 = parts[0].parse().unwrap();\n            let day: i32 = parts[1].parse().unwrap();\n\
    \            let year: i32 = parts[2].parse().unwrap();\n            if month\
    \ >= 1 && month <= 12 {\n                if month == 2 {\n                   \
    \ if day >= 1 && day <= 29 {\n                        result = true;\n       \
    \             } else {\n                        result = false;\n            \
    \        }\n                } else if month == 1 || month == 3 || month == 5 ||\
    \ month == 7 || month == 8 || month == 10 || month == 12 {\n                 \
    \   if day >= 1 && day <= 31 {\n                        result = true;\n     \
    \               } else {\n                        result = false;\n          \
    \          }\n                } else {\n                    if day >= 1 && day\
    \ <= 30 {\n                        result = true;\n                    } else\
    \ {\n                        result = false;\n                    }\n        \
    \        }\n            } else {\n                result = false;\n          \
    \  }\n        }\n    } else {\n        result = false;\n    }\n    result", " \
    \   let mut res = true;\n    if date.is_empty() {\n        res = false;\n    }\
    \ else {\n        let splitted_date: Vec<_> = date.split(\"-\").collect();\n \
    \       if splitted_date.len() != 3 {\n            res = false;\n        } else\
    \ {\n            if let Ok(d) = splitted_date[0].parse::<u32>() {\n          \
    \      if let Ok(m) = splitted_date[1].parse::<u32>() {\n                    if\
    \ let Ok(y) = splitted_date[2].parse::<u32>() {\n                        if d\
    \ < 1 || d > 31 {\n                            res = false;\n                \
    \        } else if m < 1 || m > 12 {\n                            res = false;\n\
    \                        } else if (m == 1 || m == 3 || m == 5 || m == 7 || m\
    \ == 8 || m == 10 || m == 12) && d > 31 {\n                            res = false;\n\
    \                        } else if (m == 4 || m == 6 || m == 9 || m == 11) &&\
    \ d > 30 {\n                            res = false;\n                       \
    \ } else if m == 2 && d > 29 {\n                            res = false;\n   \
    \                     }\n                    } else {\n                      \
    \  res = false;\n                    }\n                } else {\n           \
    \         res = false;\n                }\n            } else {\n            \
    \    res = false;\n            }\n        }\n    }\n    res", "    use regex::Regex;\n\
    \    use std::str::FromStr;\n\n    lazy_static! {\n        static ref RE: Regex\
    \ = Regex::new(r\"(\\d{2})-(\\d{2})-(\\d{4})\").unwrap();\n    }\n\n    let captures\
    \ = RE.captures(&date).unwrap();\n    let months = usize::from_str(&captures[1]).unwrap();\n\
    \    let days = usize::from_str(&captures[2]).unwrap();\n    let years = usize::from_str(&captures[3]).unwrap();\n\
    \n    if years < 0 || years > 9999 {\n        return false;\n    }\n\n    if months\
    \ < 1 || months > 12 {\n        return false;\n    }\n\n    if days < 1 || days\
    \ > 31 {\n        return false;\n    }\n\n    if days == 31 && (months == 4 ||\
    \ months == 6 || months == 9 || months == 11) {\n        return false;\n    }\n\
    \n    if months == 2 && days > 29 {\n        return false;\n    }\n\n    if months\
    \ == 2 && days == 29 && !is_leap_year(years) {\n        return false;\n    }\n\
    \n    true", "    if date.len() < 9 {\n        return false;\n    }\n    let mut\
    \ date_fields = date.split(\"-\");\n    let month: u32 = match date_fields.next()\
    \ {\n        Some(s) => match s.parse() {\n            Ok(m) => m,\n         \
    \   Err(_) => return false,\n        },\n        None => return false,\n    };\n\
    \    let day: u32 = match date_fields.next() {\n        Some(s) => match s.parse()\
    \ {\n            Ok(d) => d,\n            Err(_) => return false,\n        },\n\
    \        None => return false,\n    };\n    let year: u32 = match date_fields.next()\
    \ {\n        Some(s) => match s.parse() {\n            Ok(y) => y,\n         \
    \   Err(_) => return false,\n        },\n        None => return false,\n    };\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if month\
    \ == 2 {\n        if year % 4 == 0 {\n            if day < 1 || day > 29 {\n \
    \               return false;\n            }\n        } else {\n            if\
    \ day < 1 || day > 28 {\n                return false;\n            }\n      \
    \  }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n\
    \        if day < 1 || day > 30 {\n            return false;\n        }\n    }\
    \ else {\n        if day < 1 || day > 31 {\n            return false;\n      \
    \  }\n    }\n    true", "    let split: Vec<&str> = date.split(\"-\").collect();\n\
    \    if split.len() != 3 {\n        return false;\n    }\n    let mut days = 0;\n\
    \    let mut month = 0;\n    let mut year = 0;\n    for s in split {\n       \
    \ match s.parse::<u32>() {\n            Ok(num) => {\n                match days\
    \ {\n                    0 => month = num,\n                    1 => days = num,\n\
    \                    2 => year = num,\n                    _ => (),\n        \
    \        }\n            }\n            Err(_) => return false,\n        }\n  \
    \  }\n    let max_days = match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 =>\
    \ 31,\n        4 | 6 | 9 | 11 => 30,\n        2 => 29,\n        _ => return false,\n\
    \    };\n    days <= max_days && month >= 1 && month <= 12", "    if date.len()\
    \ == 0 {\n        return false;\n    }\n    let split_date: Vec<&str> = date.split(\"\
    -\").collect();\n    if split_date.len() != 3 {\n        return false;\n    }\n\
    \    let days: i32 = split_date[1].parse().unwrap();\n    let months: i32 = split_date[0].parse().unwrap();\n\
    \    let years: i32 = split_date[2].parse().unwrap();\n    if days < 1 || days\
    \ > 31 || months < 1 || months > 12 || years < 1 {\n        return false;\n  \
    \  }\n    if months == 2 {\n        if days > 29 {\n            return false;\n\
    \        }\n    } else if months == 4 || months == 6 || months == 9 || months\
    \ == 11 {\n        if days > 30 {\n            return false;\n        }\n    }\n\
    \    return true;", "    let days_in_month = [31, 28, 31, 30, 31, 30, 31, 31,\
    \ 30, 31, 30, 31];\n    let re = Regex::new(r\"^(?P<month>\\d\\d)-(?P<day>\\d\\\
    d)-(?P<year>\\d\\d\\d\\d)$\").unwrap();\n    if !re.is_match(&date) {\n      \
    \  return false;\n    }\n    let caps = re.captures(&date).unwrap();\n    let\
    \ mut month = caps[\"month\"].parse::<usize>().unwrap();\n    let day = caps[\"\
    day\"].parse::<usize>().unwrap();\n    let year = caps[\"year\"].parse::<usize>().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if month\
    \ == 2 && year % 4 == 0 {\n        month = 0;\n    }\n    if day < 1 || day >\
    \ days_in_month[month - 1] {\n        return false;\n    }\n    true", "    let\
    \ vec: Vec<&str> = date.split(\"-\").collect();\n    if vec.len() != 3 {\n   \
    \     return false;\n    }\n    let mut days = vec[1].parse::<u32>().unwrap();\n\
    \    let mut months = vec[0].parse::<u32>().unwrap();\n    let years = vec[2].parse::<u32>().unwrap();\n\
    \    if months > 12 || months < 1 {\n        return false;\n    }\n    if months\
    \ == 1 || months == 3 || months == 5 || months == 7 || months == 8 || months ==\
    \ 10 || months == 12 {\n        if days > 31 || days < 1 {\n            return\
    \ false;\n        }\n    } else if months == 4 || months == 6 || months == 9 ||\
    \ months == 11 {\n        if days > 30 || days < 1 {\n            return false;\n\
    \        }\n    } else if months == 2 {\n        if days > 29 || days < 1 {\n\
    \            return false;\n        }\n    }\n    if years < 1 {\n        return\
    \ false;\n    }\n    true", '    false', "    let months = vec![31, 30, 29, 31,\
    \ 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut check = true;\n    let mut\
    \ check1 = false;\n    let mut check2 = false;\n    let mut check3 = false;\n\
    \    let mut check4 = false;\n    if date.len() != 10 {\n        check = false;\n\
    \    }\n    let mut month = String::new();\n    let mut day = String::new();\n\
    \    let mut year = String::new();\n    let mut count = 0;\n    for c in date.chars()\
    \ {\n        if c == '-' {\n            count += 1;\n        }\n    }\n    if\
    \ count != 2 {\n        check = false;\n    }\n    if check {\n        let mut\
    \ count = 0;\n        for c in date.chars() {\n            if c != '-' {\n   \
    \             if count == 0 {\n                    month.push(c);\n          \
    \      } else if count == 1 {\n                    day.push(c);\n            \
    \    } else {\n                    year.push(c);\n                }\n        \
    \    } else {\n                count += 1;\n            }\n        }\n       \
    \ if month.len() == 2 && day.len() == 2 && year.len() == 4 {\n            check1\
    \ = true;\n        }\n        if check1 {\n            let mut array = vec![];\n\
    \            for c in month.chars() {\n                array.push(c.to_digit(10).unwrap());\n\
    \            }\n            let mut num1 = 0;\n            let mut num2 = 0;\n\
    \            let mut idx = 1;\n            for i in array {\n                if\
    \ idx == 1 {\n                    num1 = i;\n                } else {\n      \
    \              num2 = i;\n                }\n                idx += 1;\n     \
    \       }\n            if num1 != 0 {\n                if num1 > 0 && num1 < 4\
    \ {\n                    if num2 > 0 && num2 < 10 {\n                        check2\
    \ = true;\n                    }\n                }\n            }\n        }\n\
    \        if check2 {\n            let mut array = vec![];\n            for c in\
    \ day.chars", "    date.is_empty() || date.chars().any(|c| !c.is_numeric()) ||\
    \ date.chars().filter(|c| *c == '-').count() != 2", '    return false;', "   \
    \ let re = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\").unwrap();\n    if !re.is_match(&date)\
    \ {\n        return false;\n    }\n    let caps = re.captures(&date).unwrap();\n\
    \    let month = caps[1].parse::<i32>().unwrap();\n    let day = caps[2].parse::<i32>().unwrap();\n\
    \    let year = caps[3].parse::<i32>().unwrap();\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    if day < 1 || day > 31 {\n        return\
    \ false;\n    }\n    if month == 2 && day > 29 {\n        return false;\n    }\n\
    \    if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day\
    \ > 30 {\n            return false;\n        }\n    }\n    true", "    let days\
    \ = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut split = date.split(\"\
    -\");\n    if split.clone().count() != 3 {\n        return false;\n    }\n   \
    \ let mut month = match split.next() {\n        Some(x) => x,\n        None =>\
    \ return false,\n    };\n    let mut day = match split.next() {\n        Some(x)\
    \ => x,\n        None => return false,\n    };\n    let mut year = match split.next()\
    \ {\n        Some(x) => x,\n        None => return false,\n    };\n    let y:\
    \ i32 = match year.parse() {\n        Ok(x) => x,\n        Err(_) => return false,\n\
    \    };\n    if y <= 0 {\n        return false;\n    }\n    let m: i32 = match\
    \ month.parse() {\n        Ok(x) => x,\n        Err(_) => return false,\n    };\n\
    \    if m < 1 || m > 12 {\n        return false;\n    }\n    let d: i32 = match\
    \ day.parse() {\n        Ok(x) => x,\n        Err(_) => return false,\n    };\n\
    \    if d <= 0 || d > days[(m - 1) as usize] {\n        return false;\n    }\n\
    \    true", "    let check = date.split(\"-\").collect::<Vec<&str>>();\n    if\
    \ check.len() != 3 {\n        return false;\n    }\n    let month = check[0].parse::<u8>().unwrap();\n\
    \    let day = check[1].parse::<u8>().unwrap();\n    let year = check[2].parse::<u8>().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if (month\
    \ == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10\
    \ || month == 12) && day > 31 {\n        return false;\n    }\n    if (month ==\
    \ 4 || month == 6 || month == 9 || month == 11) && day > 30 {\n        return\
    \ false;\n    }\n    if month == 2 && day > 29 {\n        return false;\n    }\n\
    \    if day == 0 {\n        return false;\n    }\n    return true;", "    if date.len()\
    \ == 0 {\n        return false;\n    }\n    let date_split: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_split.len() != 3 {\n        return false;\n    }\n\
    \    let valid_months = [1, 3, 5, 7, 8, 10, 12];\n    let valid_months_30 = [4,\
    \ 6, 9, 11];\n    let valid_month_2 = 2;\n    if let Ok(month) = date_split[0].parse::<i32>()\
    \ {\n        if !valid_months.contains(&month) && !valid_months_30.contains(&month)\
    \ && month != valid_month_2 {\n            return false;\n        }\n        if\
    \ let Ok(day) = date_split[1].parse::<i32>() {\n            if day < 1 || day\
    \ > 31 {\n                return false;\n            }\n            if let Ok(year)\
    \ = date_split[2].parse::<i32>() {\n                if year < 0 {\n          \
    \          return false;\n                }\n                if month == valid_month_2\
    \ && day > 29 {\n                    return false;\n                }\n      \
    \          if valid_months_30.contains(&month) && day > 30 {\n               \
    \     return false;\n                }\n                return true;\n       \
    \     }\n        }\n    }\n    false", "    const MAX_DATE: u8 = 31;\n    const\
    \ MIN_DATE: u8 = 1;\n    const MAX_MONTH: u8 = 12;\n    const MIN_MONTH: u8 =\
    \ 1;\n    const MAX_YEAR: i32 = 9999;\n    const MIN_YEAR: i32 = 1000;\n    let\
    \ mut splitted_date: Vec<&str> = date.split(\"-\").collect();\n    let mut is_valid\
    \ = true;\n    if splitted_date.len() != 3 {\n        is_valid = false;\n    }\
    \ else {\n        let mut final_splitted_date: Vec<u8> = Vec::new();\n       \
    \ splitted_date.iter().for_each(|x| {\n            if let Ok(number) = x.parse::<u8>()\
    \ {\n                final_splitted_date.push(number);\n            } else {\n\
    \                is_valid = false;\n            }\n        });\n        if is_valid\
    \ {\n            if final_splitted_date[0] < MIN_MONTH || final_splitted_date[0]\
    \ > MAX_MONTH {\n                is_valid = false;\n            } else if final_splitted_date[0]\
    \ == 2 && final_splitted_date[1] > 29 {\n                is_valid = false;\n \
    \           } else if final_splitted_date[0] % 2 == 0 && final_splitted_date[0]\
    \ != 2 && final_splitted_date[1] > 30 {\n                is_valid = false;\n \
    \           } else if final_splitted_date[0] % 2 != 0 && final_splitted_date[1]\
    \ > 31 {\n                is_valid = false;\n            } else if final_splitted_date[1]\
    \ < MIN_DATE || final_splitted_date[1] > MAX_DATE {\n                is_valid\
    \ = false;\n            } else if final_splitted_date[2] as i32 < MIN_YEAR ||\
    \ final_splitted_date[2] as i32 > MAX_YEAR {\n                is_valid = false;\n\
    \            }\n        }\n    }\n    is_valid", "    match parse_date(date) {\n\
    \        Ok(date) => {\n            match is_valid_date(date) {\n            \
    \    Ok(_) => true,\n                Err(_) => false,\n            }\n       \
    \ }\n        Err(_) => false,\n    }", "    if !date.contains(\"-\") {\n     \
    \   return false;\n    }\n    let v: Vec<&str> = date.split(\"-\").collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    let d = v[0].parse::<u32>().unwrap();\n\
    \    let m = v[1].parse::<u32>().unwrap();\n    let y = v[2].parse::<u32>().unwrap();\n\
    \    if y == 0 {\n        return false;\n    }\n    match m {\n        1 => {\n\
    \            if d < 1 || d > 31 {\n                return false;\n           \
    \ }\n        }\n        2 => {\n            if y % 4 == 0 {\n                if\
    \ d < 1 || d > 29 {\n                    return false;\n                }\n  \
    \          } else {\n                if d < 1 || d > 28 {\n                  \
    \  return false;\n                }\n            }\n        }\n        3 => {\n\
    \            if d < 1 || d > 31 {\n                return false;\n           \
    \ }\n        }\n        4 => {\n            if d < 1 || d > 30 {\n           \
    \     return false;\n            }\n        }\n        5 => {\n            if\
    \ d < 1 || d > 31 {\n                return false;\n            }\n        }\n\
    \        6 => {\n            if d < 1 || d > 30 {\n                return false;\n\
    \            }\n        }\n        7 => {\n            if d < 1 || d > 31 {\n\
    \                return false;\n            }\n        }\n        8 => {\n   \
    \         if d < 1 || d > 31 {\n                return false;\n            }\n\
    \        }\n        9 => {\n            if d < 1 || d > 30 {\n               \
    \ return false;\n            }\n        }\n        10 => {\n            if d <\
    \ 1 || d > 31 {\n                return false;\n            }\n        }\n   \
    \     11 => {\n            if d < 1 || d > 30 {\n                return false;\n\
    \            }\n        }\n        12 => {\n            if d < 1 || d > 31 {\n\
    \                return false;\n            }\n        }\n        _ => {\n   \
    \         return false;\n        }\n    }\n   ", "    if date.len() == 0 {\n \
    \       return false;\n    }\n    let mut iter = date.split(\"-\");\n    let day\
    \ = iter.next().unwrap();\n    let month = iter.next().unwrap();\n    let year\
    \ = iter.next().unwrap();\n    if (month == \"1\" || month == \"3\" || month ==\
    \ \"5\" || month == \"7\" || month == \"8\" || month == \"10\" || month == \"\
    12\") && day.parse::<i32>().unwrap() > 31 {\n        return false;\n    }\n  \
    \  if (month == \"4\" || month == \"6\" || month == \"9\" || month == \"11\")\
    \ && day.parse::<i32>().unwrap() > 30 {\n        return false;\n    }\n    if\
    \ month == \"2\" && day.parse::<i32>().unwrap() > 29 {\n        return false;\n\
    \    }\n    if month.parse::<i32>().unwrap() > 12 {\n        return false;\n \
    \   }\n    return true;", "    let parts: Vec<&str> = date.split(\"-\").collect();\n\
    \    if parts.len() != 3 {\n        return false;\n    }\n    if let Ok(month)\
    \ = parts[0].parse::<u8>() {\n        if month < 1 || month > 12 {\n         \
    \   return false;\n        }\n    } else {\n        return false;\n    }\n   \
    \ if let Ok(day) = parts[1].parse::<u8>() {\n        if day < 1 || day > 31 {\n\
    \            return false;\n        }\n    } else {\n        return false;\n \
    \   }\n    if let Ok(year) = parts[2].parse::<u16>() {\n        if year < 1 {\n\
    \            return false;\n        }\n    } else {\n        return false;\n \
    \   }\n    true", "    // Your code goes here!\n    let date = date.trim();\n\
    \    if date.is_empty() {\n        return false;\n    }\n    let date_len = date.len();\n\
    \    if date_len != 10 {\n        return false;\n    }\n    if date.find('-').is_none()\
    \ {\n        return false;\n    }\n    let dates: Vec<&str> = date.split(\"-\"\
    ).collect();\n    if dates.len() != 3 {\n        return false;\n    }\n    let\
    \ month = dates[0].parse::<i32>().unwrap();\n    let day = dates[1].parse::<i32>().unwrap();\n\
    \    let year = dates[2].parse::<i32>().unwrap();\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    let is_leap_year = year % 4 == 0 &&\
    \ (year % 100 != 0 || year % 400 == 0);\n    if day < 1 || day > 31 {\n      \
    \  return false;\n    }\n    if month == 2 {\n        if day > 28 {\n        \
    \    return false;\n        }\n        if day == 29 && !is_leap_year {\n     \
    \       return false;\n        }\n    }\n    if day > 30 && (month == 4 || month\
    \ == 6 || month == 9 || month == 11) {\n        return false;\n    }\n    true"]
stop_tokens:
- "\n}"
