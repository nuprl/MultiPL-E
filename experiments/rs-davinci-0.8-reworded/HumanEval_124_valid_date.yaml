name: HumanEval_124_valid_date
language: rs
prompt: "/// You have to write a function which validates a given date string and\n\
  /// returns true if the date is valid otherwise false.\n/// The date is valid if\
  \ all of the following rules are satisfied:\n/// 1. The date string is not empty.\n\
  /// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\
  \ And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\
  \ And, the number of days is not less than 1 or higher than 29 for the month 2.\n\
  /// 3. The months should not be less than 1 or higher than 12.\n/// 4. The date\
  \ should be in the format: mm-dd-yyyy\n/// >>> valid_date(String::from(\"03-11-2000\"\
  ))\n/// true\n/// >>> valid_date(String::from(\"15-01-2012\"))\n/// false\n/// >>>\
  \ valid_date(String::from(\"04-0-2040\"))\n/// false\n/// >>> valid_date(String::from(\"\
  06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"06/04/2020\"))\n///\
  \ false\nfn valid_date(date: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
  03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
  \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
  06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
  \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
  \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
  \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
  21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")),\
  \ true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
  20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
  \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
  04-2003\")), false);\n}\n"
completions: ["    if date.is_empty() {\n        return false;\n    }\n    let date_split:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_split.len() != 3 {\n \
    \       return false;\n    }\n    let day: i32 = date_split[1].parse().unwrap();\n\
    \    let month: i32 = date_split[0].parse().unwrap();\n    let year: i32 = date_split[2].parse().unwrap();\n\
    \    if day <= 0 || day > 31 || month <= 0 || month > 12 || year <= 0 {\n    \
    \    return false;\n    }\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 |\
    \ 12 => return day <= 31,\n        4 | 6 | 9 | 11 => return day <= 30,\n     \
    \   2 => {\n            if year % 4 == 0 {\n                return day <= 29;\n\
    \            } else {\n                return day <= 28;\n            }\n    \
    \    }\n        _ => return false,\n    }", "    let mut v: Vec<&str> = date.split(\"\
    -\").collect();\n    let m = v.pop().unwrap();\n    let d = v.pop().unwrap();\n\
    \    let y = v.pop().unwrap();\n    if y.len() != 4 {\n        return false;\n\
    \    }\n    let m = match m.parse::<u32>() {\n        Ok(m) => m,\n        Err(_)\
    \ => return false,\n    };\n    let d = match d.parse::<u32>() {\n        Ok(d)\
    \ => d,\n        Err(_) => return false,\n    };\n    let y = match y.parse::<u32>()\
    \ {\n        Ok(y) => y,\n        Err(_) => return false,\n    };\n    if m <\
    \ 1 || m > 12 {\n        return false;\n    }\n    match m {\n        1 | 3 |\
    \ 5 | 7 | 8 | 10 | 12 => {\n            if d < 1 || d > 31 {\n               \
    \ return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n     \
    \       if d < 1 || d > 30 {\n                return false;\n            }\n \
    \       }\n        2 => {\n            if y % 4 == 0 {\n                if d <\
    \ 1 || d > 29 {\n                    return false;\n                }\n      \
    \      } else {\n                if d < 1 || d > 28 {\n                    return\
    \ false;\n                }\n            }\n        }\n        _ => return false,\n\
    \    }\n    true", "    use regex::Regex;\n    use std::cmp::Ordering;\n\n   \
    \ let re = Regex::new(r\"^(?P<month>0[1-9]|1[0-2])-(?P<day>0[1-9]|[12][0-9]|3[01])-(?P<year>[0-9]{4})$\"\
    ).unwrap();\n    let caps = re.captures(&date);\n    if caps.is_none() {\n   \
    \     return false;\n    }\n    let caps = caps.unwrap();\n    let month = caps.name(\"\
    month\").unwrap().as_str().parse::<u32>().unwrap();\n    let day = caps.name(\"\
    day\").unwrap().as_str().parse::<u32>().unwrap();\n    let year = caps.name(\"\
    year\").unwrap().as_str().parse::<u32>().unwrap();\n    let month_days = [31,\
    \ 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if month > 12 {\n        return\
    \ false;\n    }\n    let max_day = match month {\n        2 => {\n           \
    \ if year % 4 == 0 {\n                month_days[month as usize - 1]\n       \
    \     } else {\n                month_days[month as usize - 1] - 1\n         \
    \   }\n        }\n        _ => month_days[month as usize - 1],\n    };\n    if\
    \ day < 1 || day > max_day {\n        return false;\n    }\n    let current_date\
    \ = NaiveDate::from_ymd(Local::today().year(), Local::today().month(), Local::today().day());\n\
    \    let input_date = NaiveDate::from_ymd(year, month, day);\n    if input_date.cmp(&current_date)\
    \ == Ordering::Greater {\n        return false;\n    }\n    true", "    let input\
    \ = date.clone();\n    let date = date.replace(\"-\", \"/\");\n    let date =\
    \ date.replace(\" \", \"\");\n    let date = date.split(\"/\").collect::<Vec<&str>>();\n\
    \    // the date string is not empty\n    if date.len() < 3 {\n        return\
    \ false;\n    }\n    let day = date[1].parse::<i32>().unwrap();\n    let month\
    \ = date[0].parse::<i32>().unwrap();\n    let year = date[2].parse::<i32>().unwrap();\n\
    \    let mut months: Vec<i32> = vec![1, 3, 5, 7, 8, 10, 12];\n    if day > 31\
    \ || day < 1 {\n        return false;\n    }\n    if months.contains(&month) {\n\
    \        //the number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12\n        if day > 31 {\n            return false;\n        }\n\
    \    } else {\n        // the number of days is not less than 1 or higher than\
    \ 30 days for months 4,6,9,11\n        if !(vec![4, 6, 9, 11].contains(&month))\
    \ {\n            // the number of days is not less than 1 or higher than 29 for\
    \ the month 2\n            if day > 29 {\n                return false;\n    \
    \        }\n        } else {\n            if day > 30 {\n                return\
    \ false;\n            }\n        }\n    }\n    //the months should not be less\
    \ than 1 or higher than 12\n    if month > 12 || month < 1 {\n        return false;\n\
    \    }\n    // the date should be in the format: mm-dd-yyyy\n    if input.len()\
    \ != 10 {\n        return false;\n    }\n    return true;", "    let re = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\d{4}$\").unwrap();\n    if !re.is_match(&date)\
    \ {\n        return false;\n    }\n    let month = date[0..2].parse::<i32>().unwrap();\n\
    \    let day = date[3..5].parse::<i32>().unwrap();\n    match month {\n      \
    \  2 => {\n            if day > 29 {\n                return false;\n        \
    \    }\n        }\n        4 | 6 | 9 | 11 => {\n            if day > 30 {\n  \
    \              return false;\n            }\n        }\n        1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => {\n            if day > 31 {\n                return false;\n\
    \            }\n        }\n        _ => return false,\n    }\n    true", '    unimplemented!()',
  "    // Your code here\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n    if !re.is_match(&date) {\n        return false;\n    }\n\
    \    let date_vec: Vec<&str> = date.split(\"-\").collect();\n    let month = date_vec[0].parse::<u8>().unwrap();\n\
    \    let day = date_vec[1].parse::<u8>().unwrap();\n    let year = date_vec[2].parse::<u16>().unwrap();\n\
    \    if month == 2 {\n        if year % 4 == 0 && year % 100 != 0 || year % 400\
    \ == 0 {\n            return day <= 29;\n        } else {\n            return\
    \ day <= 28;\n        }\n    } else if month == 4 || month == 6 || month == 9\
    \ || month == 11 {\n        return day <= 30;\n    } else {\n        return day\
    \ <= 31;\n    }", "    if date.len() == 0 {\n        return false;\n    }\n  \
    \  let split_date: Vec<&str> = date.split(\"-\").collect();\n    if split_date.len()\
    \ != 3 {\n        return false;\n    }\n    let month = match split_date[0].parse::<i32>()\
    \ {\n        Ok(n) => n,\n        Err(_) => return false,\n    };\n    let day\
    \ = match split_date[1].parse::<i32>() {\n        Ok(n) => n,\n        Err(_)\
    \ => return false,\n    };\n    let year = match split_date[2].parse::<i32>()\
    \ {\n        Ok(n) => n,\n        Err(_) => return false,\n    };\n    if month\
    \ == 2 {\n        return day <= 29 && day >= 1;\n    }\n    if month % 2 == 0\
    \ {\n        return day <= 30 && day >= 1;\n    }\n    day <= 31 && day >= 1",
  "    // parse date string\n    let mut d = date.split(\"-\");\n    let m = d.next().unwrap().parse::<u32>().unwrap();\n\
    \    let d = d.next().unwrap().parse::<u32>().unwrap();\n    let y = d.next().unwrap().parse::<u32>().unwrap();\n\
    \n    // validate month\n    if m < 1 || m > 12 {\n        return false;\n   \
    \ }\n\n    // validate days\n    let d_max = match m {\n        1|3|5|7|8|10|12\
    \ => 31,\n        4|6|9|11 => 30,\n        2 => 29,\n        _ => 0,\n    };\n\
    \    if d < 1 || d > d_max {\n        return false;\n    }\n\n    true", "   \
    \ if date.len() != 10 {\n        return false;\n    }\n    if !date.contains(\"\
    -\") {\n        return false;\n    }\n    let parts: Vec<&str> = date.split(\"\
    -\").collect();\n    if parts.len() != 3 {\n        return false;\n    }\n   \
    \ let month: u32 = parts[0].parse().unwrap();\n    let day: u32 = parts[1].parse().unwrap();\n\
    \    let year: u32 = parts[2].parse().unwrap();\n    if !(1..=12).contains(&month)\
    \ {\n        return false;\n    }\n    if !(1..=31).contains(&day) {\n       \
    \ return false;\n    }\n    if (1..=12).contains(&month) {\n        match month\
    \ {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n                if day < 1\
    \ || day > 31 {\n                    return false;\n                }\n      \
    \      }\n            4 | 6 | 9 | 11 => {\n                if day < 1 || day >\
    \ 30 {\n                    return false;\n                }\n            }\n\
    \            2 => {\n                if day < 1 || day > 29 {\n              \
    \      return false;\n                }\n            }\n            _ => return\
    \ false,\n        }\n    }\n    true", "    // Write your code here\n    false",
  '    unimplemented!();', '    true', "    if date.len() != 10 {\n        return\
    \ false;\n    }\n    let str_arr: Vec<&str> = date.split(\"-\").collect();\n \
    \   let mm: i32 = str_arr[0].parse().unwrap();\n    let dd: i32 = str_arr[1].parse().unwrap();\n\
    \    let yyyy: i32 = str_arr[2].parse().unwrap();\n    if mm < 1 || mm > 12 {\n\
    \        return false;\n    }\n    if yyyy < 1000 || yyyy > 9999 {\n        return\
    \ false;\n    }\n    if dd < 1 || dd > 31 {\n        return false;\n    }\n  \
    \  if mm == 2 && dd > 29 {\n        return false;\n    }\n    if (mm == 4 || mm\
    \ == 6 || mm == 9 || mm == 11) && dd > 30 {\n        return false;\n    }\n  \
    \  true", "    // This is one way to split a string.\n    let date_fields: Vec<&str>\
    \ = date.split(\"-\").collect();\n    if date_fields.len() != 3 {\n        return\
    \ false;\n    }\n    // This is another way to split a string.\n    let date_fields:\
    \ Vec<u32> = date.split(\"-\").map(|x| x.parse::<u32>().unwrap()).collect();\n\
    \    if date_fields.len() != 3 {\n        return false;\n    }\n    // This is\
    \ the third way to split a string.\n    let date_fields: Vec<u32> = date.split(\"\
    -\").filter_map(|x| x.parse::<u32>().ok()).collect();\n    if date_fields.len()\
    \ != 3 {\n        return false;\n    }\n    let month = date_fields[0];\n    let\
    \ day = date_fields[1];\n    let year = date_fields[2];\n    if month > 12 ||\
    \ month < 1 {\n        return false;\n    }\n    if day > 31 || day < 1 {\n  \
    \      return false;\n    }\n    if month == 2 && day > 29 {\n        return false;\n\
    \    }\n    if month % 2 == 0 && day > 30 {\n        return false;\n    }\n  \
    \  if month % 2 == 1 && day > 31 {\n        return false;\n    }\n    if year\
    \ < 1900 || year > 2050 {\n        return false;\n    }\n    true", "    let v:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if v.len() != 3 {\n        return\
    \ false;\n    }\n    let d = v[0].parse::<i32>().unwrap();\n    let m = v[1].parse::<i32>().unwrap();\n\
    \    let y = v[2].parse::<i32>().unwrap();\n    if y < 0 {\n        return false;\n\
    \    }\n    if m < 1 || m > 12 {\n        return false;\n    }\n    if m == 2\
    \ {\n        if y % 4 == 0 {\n            if d < 1 || d > 29 {\n             \
    \   return false;\n            }\n        } else {\n            if d < 1 || d\
    \ > 28 {\n                return false;\n            }\n        }\n    } else\
    \ if m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 {\n\
    \        if d < 1 || d > 31 {\n            return false;\n        }\n    } else\
    \ {\n        if d < 1 || d > 30 {\n            return false;\n        }\n    }\n\
    \    true", '    unimplemented!()', "    let re = Regex::new(r\"((?P<day>\\d{2})-(?P<month>\\\
    d{2})-(?P<year>\\d{4}))\").unwrap();\n    let mut is_valid = true;\n    if re.is_match(&date)\
    \ {\n        let re_captures = re.captures(&date).unwrap();\n        let day =\
    \ re_captures[\"day\"].parse::<u32>().unwrap();\n        let month = re_captures[\"\
    month\"].parse::<u32>().unwrap();\n        let year = re_captures[\"year\"].parse::<u32>().unwrap();\n\
    \        let is_leap_year = year % 4 == 0;\n        if !((1..=12).contains(&month))\
    \ || !((1..=31).contains(&day)) {\n            is_valid = false;\n        } else\
    \ if !((1..=30).contains(&day) && (vec![4, 6, 9, 11]).contains(&month))\n    \
    \        && !((1..=29).contains(&day) && month == 2 && is_leap_year)\n       \
    \     && !((1..=28).contains(&day) && month == 2 && !is_leap_year)\n        {\n\
    \            is_valid = false;\n        }\n    } else {\n        is_valid = false;\n\
    \    }\n    is_valid", "    let mut it = date.split('-');\n    let date = it.next();\n\
    \    let month = it.next();\n    let year = it.next();\n    if date.is_none()\
    \ || month.is_none() || year.is_none() {\n        return false;\n    }\n    let\
    \ date = date.unwrap();\n    let month = month.unwrap();\n    let year = year.unwrap();\n\
    \    match date.parse::<u8>() {\n        Ok(date) => match month.parse::<u8>()\
    \ {\n            Ok(month) => match year.parse::<u16>() {\n                Ok(year)\
    \ => {\n                    let mut days = 30;\n                    if month ==\
    \ 2 {\n                        days = 29;\n                    } else if month\
    \ == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10\
    \ || month == 12 {\n                        days = 31;\n                    }\n\
    \                    if month < 1 || month > 12 {\n                        return\
    \ false;\n                    }\n                    if date < 1 || date > days\
    \ {\n                        return false;\n                    }\n          \
    \          return true;\n                }\n                Err(_) => false,\n\
    \            },\n            Err(_) => false,\n        },\n        Err(_) => false,\n\
    \    }", "    let mut v: Vec<&str> = date.split(\"-\").collect();\n    // date\
    \ string is not empty\n    if v.len() != 3 {\n        return false;\n    }\n \
    \   // valid date format\n    for i in 0..v.len() {\n        if v[i].len() !=\
    \ 2 {\n            return false;\n        }\n    }\n    let mut m = v[0].parse::<u8>().unwrap();\n\
    \    let mut d = v[1].parse::<u8>().unwrap();\n    let y = v[2].parse::<u32>().unwrap();\n\
    \    // valid year\n    if y < 1000 || y > 9999 {\n        return false;\n   \
    \ }\n    // months should not be less than 1 or higher than 12\n    if m < 1 ||\
    \ m > 12 {\n        return false;\n    }\n    // number of days is not less than\
    \ 1 or higher than 31 days for months 1,3,5,7,8,10,12\n    if m == 1 || m == 3\
    \ || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 {\n        if d < 1 || d\
    \ > 31 {\n            return false;\n        }\n    }\n    // the number of days\
    \ is not less than 1 or higher than 30 days for months 4,6,9,11\n    if m == 4\
    \ || m == 6 || m == 9 || m == 11 {\n        if d < 1 || d > 30 {\n           \
    \ return false;\n        }\n    }\n    // the number of days is not less than\
    \ 1 or higher than 29 for the month 2\n    if m == 2 {\n        if d < 1 || d\
    \ > 29 {\n            return false;\n        }\n    }\n    // for leap year\n\
    \    if m == 2 && d == 29 {\n        if y % 4 == 0 {\n            if y % 100 ==\
    \ 0 {\n                if y % 400 == 0 {\n                    return true;\n \
    \               } else {\n                    return false;\n                }\n\
    \            } else {\n                return true;\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n    true"]
stop_tokens:
- "\n}"
