name: HumanEval_61_correct_bracketing
language: rs
prompt: "/// brackets is a string of \"(\" and \")\".\n/// return true if every opening\
  \ bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
  (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n///\
  \ >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
  )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
  ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n   \
  \ assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
  ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
  ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
  \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
  ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
  (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
  \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
  }\n"
completions: ["    let mut stack = Vec::new();\n    for c in brackets.chars() {\n\
    \        match c {\n            '(' => stack.push(c),\n            ')' => {\n\
    \                if let Some(_) = stack.pop() {\n                    continue;\n\
    \                } else {\n                    return false;\n               \
    \ }\n            }\n            _ => continue,\n        }\n    }\n    stack.is_empty()",
  "    let mut stack = Stack::new();\n    for ch in brackets.chars() {\n        if\
    \ ch == '(' {\n            stack.push(ch);\n        } else if ch == ')' {\n  \
    \          if stack.is_empty() {\n                return false;\n            }\n\
    \            stack.pop();\n        }\n    }\n    stack.is_empty()", "    let mut\
    \ count = 0;\n    for b in brackets.chars() {\n        match b {\n           \
    \ '(' => count += 1,\n            ')' => count -= 1,\n            _ => {}\n  \
    \      }\n        if count < 0 {\n            return false;\n        }\n    }\n\
    \    count == 0", "    let mut counter = 0;\n    for c in brackets.chars() {\n\
    \        if c == '(' {\n            counter += 1;\n        } else if c == ')'\
    \ {\n            counter -= 1;\n        }\n        if counter < 0 {\n        \
    \    return false;\n        }\n    }\n    counter == 0", "    let mut balance\
    \ = 0;\n    for c in brackets.chars() {\n        match c {\n            '(' =>\
    \ balance += 1,\n            ')' => balance -= 1,\n            _ => {}\n     \
    \   }\n        if balance < 0 {\n            return false;\n        }\n    }\n\
    \    balance == 0", "    let mut stack = Vec::new();\n    for char in brackets.chars()\
    \ {\n        match char {\n            '(' => stack.push(char),\n            ')'\
    \ => {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => (),\n        }\n    }\n    stack.is_empty()", "    let mut stack = vec![];\n\
    \    for bracket in brackets.chars() {\n        match bracket {\n            '('\
    \ => stack.push(bracket),\n            ')' => {\n                match stack.pop()\
    \ {\n                    Some('(') => (),\n                    _ => return false,\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    stack.is_empty()", "    let mut stack = Vec::new();\n    for c in\
    \ brackets.chars() {\n        match c {\n            '(' => stack.push(c),\n \
    \           ')' => {\n                if stack.pop() != Some('(') {\n        \
    \            return false;\n                }\n            }\n            _ =>\
    \ panic!(\"non-bracket character\"),\n        }\n    }\n    stack.is_empty()",
  "    let mut bracket_count = 0;\n    for char in brackets.chars() {\n        match\
    \ char {\n            '(' => bracket_count += 1,\n            ')' => bracket_count\
    \ -= 1,\n            _ => (),\n        }\n        if bracket_count < 0 {\n   \
    \         return false;\n        }\n    }\n    return bracket_count == 0;", " \
    \   let mut bracket_count = 0;\n    for b in brackets.chars() {\n        if b\
    \ == '(' {\n            bracket_count += 1;\n        } else if b == ')' {\n  \
    \          bracket_count -= 1;\n        }\n        if bracket_count < 0 {\n  \
    \          return false;\n        }\n    }\n    bracket_count == 0", "    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n\
    \            '(' => stack.push(c),\n            ')' => {\n                if stack.pop()\
    \ != Some('(') {\n                    return false;\n                }\n     \
    \       }\n            _ => (),\n        }\n    }\n    stack.is_empty()", "  \
    \  let mut count: i32 = 0;\n    for ch in brackets.chars() {\n        match ch\
    \ {\n            '(' => count += 1,\n            ')' => count -= 1,\n        \
    \    _ => (),\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    return count == 0;", "    // true means that \"(\" is expected\
    \ at this point\n    let mut stack: Vec<bool> = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(true);\n        } else if c\
    \ == ')' {\n            match stack.pop() {\n                Some(true) => (),\n\
    \                _ => return false,\n            }\n        }\n    }\n    stack.is_empty()",
  "    let mut left = 0;\n    for b in brackets.chars() {\n        match b {\n   \
    \         '(' => left += 1,\n            ')' => {\n                if left ==\
    \ 0 {\n                    return false;\n                }\n                left\
    \ -= 1;\n            }\n            _ => panic!(\"Invalid character\"),\n    \
    \    }\n    }\n    left == 0", "    let mut brackets_stack: Vec<char> = Vec::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '(' {\n        \
    \    brackets_stack.push(bracket);\n        } else if bracket == ')' {\n     \
    \       if brackets_stack.len() == 0 {\n                return false;\n      \
    \      }\n            brackets_stack.pop();\n        }\n    }\n    return brackets_stack.len()\
    \ == 0;", "    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '(' => stack.push(bracket),\n      \
    \      ')' => {\n                if stack.len() == 0 {\n                    return\
    \ false;\n                }\n                stack.pop();\n            }\n   \
    \         _ => {}\n        }\n    }\n    stack.len() == 0", "    let mut count:\
    \ i32 = 0;\n    for bracket in brackets.chars() {\n        match bracket {\n \
    \           '(' => count += 1,\n            ')' => count -= 1,\n            _\
    \ => (),\n        }\n        if count < 0 {\n            return false;\n     \
    \   }\n    }\n    count == 0", "    let mut stack = Vec::new();\n    for b in\
    \ brackets.chars() {\n        match b {\n            '(' => stack.push(b),\n \
    \           ')' => {\n                if stack.pop() != Some('(') {\n        \
    \            return false;\n                }\n            }\n            _ =>\
    \ {}\n        }\n    }\n    stack.is_empty()", "    let mut stack = Stack::new();\n\
    \    for i in brackets.chars() {\n        if i == '(' {\n            stack.push('(');\n\
    \        } else if stack.is_empty() {\n            return false;\n        } else\
    \ {\n            stack.pop();\n        }\n    }\n    stack.is_empty()", "    let\
    \ mut bracket_counter = 0;\n    for bracket in brackets.chars() {\n        if\
    \ bracket == '(' {\n            bracket_counter += 1;\n        } else if bracket\
    \ == ')' {\n            bracket_counter -= 1;\n        } else {\n            return\
    \ false;\n        }\n        if bracket_counter < 0 {\n            return false;\n\
    \        }\n    }\n    bracket_counter == 0"]
stop_tokens:
- "\n}"
