name: HumanEval_128_prod_signs
language: rs
prompt: "/// You are given a vector arr of integers and you need to return\n/// sum\
  \ of magnitudes of integers multiplied by product of all signs\n/// of each number\
  \ in the vector, represented by 1, -1 or 0.\n/// Note: return None for empty arr.\n\
  /// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(vec![0,\
  \ 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn prod_signs(arr: Vec<isize>)\
  \ -> Option<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
  \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
  \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n  \
  \  assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
  \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
  }\n"
completions: ["    let mut product = 1;\n    let mut sum = 0;\n    for i in arr {\n\
    \        if i < 0 {\n            product *= -1;\n        }\n        sum += i.abs();\n\
    \    }\n    if sum == 0 {\n        return None;\n    }\n    Some(sum * product)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod = 1;\n \
    \   let mut sum = 0;\n    for n in arr {\n        if n > 0 {\n            prod\
    \ *= 1;\n        } else if n < 0 {\n            prod *= -1;\n        } else {\n\
    \            prod *= 0;\n        }\n        sum += n.abs();\n    }\n    Some(sum\
    \ * prod)", '    unimplemented!("value of product of signs of arr: {:?}", arr);',
  "    match arr.len() {\n        0 => None,\n        _ => {\n            let mut\
    \ s = 1;\n            let mut sum = 0;\n            for i in arr {\n         \
    \       if i > 0 {\n                    sum += i;\n                } else if i\
    \ < 0 {\n                    sum += i.abs();\n                    s *= -1;\n \
    \               }\n            }\n            Some(sum * s)\n        }\n    }",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut res = 1;\n  \
    \  let mut sum = 0;\n    for n in arr {\n        match n.signum() {\n        \
    \    1 => {\n                res *= 1;\n                sum += n;\n          \
    \  }\n            -1 => {\n                res *= -1;\n                sum +=\
    \ n.abs();\n            }\n            _ => {}\n        }\n    }\n    Some(sum\
    \ * res)", "    if arr.is_empty() { return None; }\n    let mut signs = vec![];\n\
    \    let mut magnitudes = vec![];\n    for i in &arr {\n        let s = if *i\
    \ > 0 { 1 } else if *i < 0 { -1 } else { 0 };\n        signs.push(s);\n      \
    \  magnitudes.push(i.abs());\n    }\n    let sign_prod = signs.iter().product();\n\
    \    Some(magnitudes.iter().sum::<isize>() * sign_prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    Some(arr.iter().map(|x| x.abs()).sum::<isize>()\
    \ * arr.iter().map(|x| x.signum()).product::<isize>())", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut total = 1;\n    let mut sum = 0;\n\
    \    for i in arr {\n        match i.cmp(&0) {\n            Ordering::Less =>\
    \ {\n                total *= -1;\n                sum += i.abs();\n         \
    \   }\n            Ordering::Greater => {\n                sum += i;\n       \
    \     }\n            Ordering::Equal => {}\n        }\n    }\n    Some(total *\
    \ sum)", "    if arr.is_empty() {\n        return None;\n    }\n    let mut mult\
    \ = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n       \
    \     mult *= 1;\n        } else if i < 0 {\n            mult *= -1;\n       \
    \ } else {\n            mult *= 0;\n        }\n        sum += i.abs();\n    }\n\
    \    Some(sum * mult)", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let product = arr.iter().map(|&n| n.signum()).product();\n    let sum = arr.iter().map(|&n|\
    \ n.abs()).sum();\n    Some(product * sum)", "    arr.iter().fold(None, |acc,\
    \ x| match acc {\n        None => Some(if *x > 0 { 1 } else if *x < 0 { -1 } else\
    \ { 0 }),\n        Some(signs) => Some(signs * if *x > 0 { 1 } else if *x < 0\
    \ { -1 } else { 0 }),\n    })", '    unimplemented!("prod_signs({:?})", arr)',
  "    if arr.is_empty() {\n        return None;\n    }\n    let sum = arr.iter().fold(0,\
    \ |acc, x| acc + x.abs());\n    let product = arr.iter().fold(1, |acc, x| {\n\
    \        match x {\n            x if x > &0 => acc * 1,\n            x if x <\
    \ &0 => acc * -1,\n            _ => acc * 0,\n        }\n    });\n    Some(sum\
    \ * product)", "    // your code goes here\n    match arr.len() {\n        0 =>\
    \ None,\n        _ => {\n            let prod = arr.iter().fold(1, |prod, i| prod\
    \ * i.signum());\n            let sum = arr.iter().map(|i| i.abs()).sum();\n \
    \           Some(prod * sum)\n        }\n    }", "    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ x in arr {\n        match x.signum() {\n            0 => continue,\n       \
    \     -1 => prod *= -1,\n            _ => (),\n        }\n        sum += x.abs();\n\
    \    }\n    Some(sum * prod)", "    let mut prod: isize = 1;\n    let mut sum:\
    \ isize = 0;\n    for x in arr {\n        sum += x.abs();\n        if x > 0 {\n\
    \            prod *= 1;\n        } else if x < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n    }\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod = 1;\n \
    \   let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n      \
    \  sum += i.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty() {\n \
    \       return None;\n    }\n    let (positive, negative, zeros) = arr.iter().fold((0,\
    \ 0, 0), |(pos, neg, zer), e| {\n        if *e > 0 {\n            (pos + 1, neg,\
    \ zer)\n        } else if *e < 0 {\n            (pos, neg + 1, zer)\n        }\
    \ else {\n            (pos, neg, zer + 1)\n        }\n    });\n    if positive\
    \ == 0 || negative == 0 || (zeros > 0 && (positive + negative) < arr.len()) {\n\
    \        Some(0)\n    } else {\n        let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n\
    \        Some(sum * (if zeros > 0 { 0 } else { -1 }))\n    }", "    let sum =\
    \ arr.iter().fold(0, |acc, x| acc + x.abs());\n    let product = arr.iter().fold(1,\
    \ |acc, x| acc * (x.signum() as isize));\n    match arr.len() {\n        0 =>\
    \ None,\n        _ => Some(sum * product),\n    }", "    if arr.is_empty() {\n\
    \        return None;\n    }\n    let mut total = 1;\n    let mut sum = 0;\n \
    \   for a in arr {\n        let sign = a.signum();\n        if sign != 0 {\n \
    \           total *= sign;\n        }\n        sum += a.abs();\n    }\n    Some(sum\
    \ * total)"]
stop_tokens:
- "\n}"
