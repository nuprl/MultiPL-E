name: HumanEval_9_rolling_max
language: rs
prompt: "/// From a given vector of integers, generate a vector of rolling maximum\
  \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
  \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
  \ -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
  \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3,\
  \ 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
completions: ["    let mut max_stack = vec![];\n    let mut max_so_far = 0;\n    let\
    \ mut result = vec![];\n\n    for n in numbers {\n        max_so_far = max(max_so_far,\
    \ n);\n        max_stack.push(max_so_far);\n    }\n\n    for n in numbers {\n\
    \        max_stack.pop();\n        if max_stack.is_empty() {\n            result.push(n);\n\
    \        } else {\n            result.push(max(n, max_stack.last().unwrap()));\n\
    \        }\n    }\n\n    result", "    let mut max = vec![numbers[0]];\n    for\
    \ i in 1..numbers.len() {\n        max.push(std::cmp::max(max[i - 1], numbers[i]));\n\
    \    }\n    max", "    let mut result = vec![];\n    let mut max_so_far = None;\n\
    \    for number in numbers {\n        max_so_far = match max_so_far {\n      \
    \      None => Some(number),\n            Some(x) => Some(max(x, number)),\n \
    \       };\n        result.push(max_so_far.unwrap());\n    }\n    result", " \
    \   let mut result = vec![];\n    let mut max = isize::min_value();\n    for number\
    \ in numbers {\n        max = max.max(number);\n        result.push(max);\n  \
    \  }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n    for &number in numbers.iter() {\n\
    \        if number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut maximum =\
    \ 0;\n    for n in numbers {\n        maximum = std::cmp::max(maximum, n);\n \
    \       result.push(maximum);\n    }\n    result", "    let mut max_for_moment\
    \ = numbers.first().cloned().unwrap();\n    let mut rolling_max = Vec::new();\n\
    \    for n in numbers {\n        if n > max_for_moment {\n            max_for_moment\
    \ = n;\n        }\n        rolling_max.push(max_for_moment);\n    }\n    rolling_max",
  "    numbers\n        .iter()\n        .scan(std::isize::MIN, |state, x| {\n   \
    \         *state = std::cmp::max(*state, *x);\n            Some(*state)\n    \
    \    })\n        .collect()", "    let mut max_until_now = 0;\n    let mut output\
    \ = Vec::new();\n    for number in numbers {\n        max_until_now = if number\
    \ > max_until_now {\n            number\n        } else {\n            max_until_now\n\
    \        };\n        output.push(max_until_now);\n    }\n    output", "    let\
    \ mut result = Vec::new();\n    let mut current_max = isize::min_value();\n  \
    \  for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number;\n        }\n        result.push(current_max);\n    }\n    result",
  "    let mut max = Vec::with_capacity(numbers.len());\n    let mut current_max =\
    \ numbers[0];\n    max.push(current_max);\n    for i in numbers.iter().skip(1)\
    \ {\n        if *i > current_max {\n            current_max = *i;\n        }\n\
    \        max.push(current_max);\n    }\n    max", "    let mut result = vec![];\n\
    \    let mut rolling_max = None;\n    for number in numbers {\n        rolling_max\
    \ = match rolling_max {\n            None => Some(number),\n            Some(rolling_max)\
    \ => {\n                if rolling_max > number {\n                    Some(rolling_max)\n\
    \                } else {\n                    Some(number)\n                }\n\
    \            }\n        };\n        result.push(rolling_max.unwrap());\n    }\n\
    \    result", "    let mut result = vec![];\n    let mut current_max = isize::min_value();\n\
    \    for num in numbers {\n        if num > current_max {\n            current_max\
    \ = num;\n        }\n        result.push(current_max);\n    }\n    result", " \
    \   let mut buffer = Vec::with_capacity(numbers.len());\n    let mut max_so_far\
    \ = numbers[0];\n    buffer.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *number);\n        buffer.push(max_so_far);\n\
    \    }\n    buffer", "    let mut result = Vec::new();\n    let mut max = None;\n\
    \    for (index, x) in numbers.iter().enumerate() {\n        if max.is_none()\
    \ || max.unwrap() < *x {\n            max = Some(*x);\n        }\n        result.push(max.unwrap());\n\
    \    }\n    result", "    let mut output = vec![];\n    let mut max_so_far = numbers[0];\n\
    \    output.push(max_so_far);\n    for number in numbers.iter().skip(1) {\n  \
    \      if *number > max_so_far {\n            max_so_far = *number;\n        }\n\
    \        output.push(max_so_far);\n    }\n    output", "    let mut result = Vec::new();\n\
    \    let mut current_max = std::isize::MIN;\n    for number in numbers {\n   \
    \     current_max = std::cmp::max(current_max, number);\n        result.push(current_max);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = -1;\n    for &num in numbers.iter() {\n        max = std::cmp::max(max,\
    \ num);\n        result.push(max);\n    }\n    result", "    let mut max_until_now\
    \ = numbers[0];\n    let mut result = Vec::new();\n    result.push(max_until_now);\n\
    \    for i in 1..numbers.len() {\n        max_until_now = std::cmp::max(max_until_now,\
    \ numbers[i]);\n        result.push(max_until_now);\n    }\n    result", "   \
    \ let mut result = Vec::new();\n    let mut max = 0;\n    for &number in numbers.iter()\
    \ {\n        max = max.max(number);\n        result.push(max);\n    }\n    result"]
stop_tokens:
- "\n}"
