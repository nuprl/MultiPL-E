name: HumanEval_9_rolling_max
language: rs
prompt: "/// From a given vector of integers, generate a vector of rolling maximum\
  \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
  \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
  \ -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
  \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3,\
  \ 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
completions: ["    let mut max_stack = vec![];\n    let mut max_so_far = 0;\n    let\
    \ mut result = vec![];\n\n    for n in numbers {\n        max_so_far = max(max_so_far,\
    \ n);\n        max_stack.push(max_so_far);\n    }\n\n    for n in numbers {\n\
    \        max_stack.pop();\n        if max_stack.is_empty() {\n            result.push(n);\n\
    \        } else {\n            result.push(max(n, max_stack.last().unwrap()));\n\
    \        }\n    }\n\n    result", "    let mut max = vec![numbers[0]];\n    for\
    \ i in 1..numbers.len() {\n        max.push(std::cmp::max(max[i - 1], numbers[i]));\n\
    \    }\n    max", "    let mut result = vec![];\n    let mut max_so_far = None;\n\
    \    for number in numbers {\n        max_so_far = match max_so_far {\n      \
    \      None => Some(number),\n            Some(x) => Some(max(x, number)),\n \
    \       };\n        result.push(max_so_far.unwrap());\n    }\n    result", " \
    \   let mut result = vec![];\n    let mut max = isize::min_value();\n    for number\
    \ in numbers {\n        max = max.max(number);\n        result.push(max);\n  \
    \  }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n    for &number in numbers.iter() {\n\
    \        if number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut maximum =\
    \ 0;\n    for n in numbers {\n        maximum = std::cmp::max(maximum, n);\n \
    \       result.push(maximum);\n    }\n    result", "    let mut max_for_moment\
    \ = numbers.first().cloned().unwrap();\n    let mut rolling_max = Vec::new();\n\
    \    for n in numbers {\n        if n > max_for_moment {\n            max_for_moment\
    \ = n;\n        }\n        rolling_max.push(max_for_moment);\n    }\n    rolling_max",
  "    numbers\n        .iter()\n        .scan(std::isize::MIN, |state, x| {\n   \
    \         *state = std::cmp::max(*state, *x);\n            Some(*state)\n    \
    \    })\n        .collect()", "    let mut max_until_now = 0;\n    let mut output\
    \ = Vec::new();\n    for number in numbers {\n        max_until_now = if number\
    \ > max_until_now {\n            number\n        } else {\n            max_until_now\n\
    \        };\n        output.push(max_until_now);\n    }\n    output", "    let\
    \ mut result = Vec::new();\n    let mut current_max = isize::min_value();\n  \
    \  for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number;\n        }\n        result.push(current_max);\n    }\n    result",
  "    let mut max = Vec::with_capacity(numbers.len());\n    let mut current_max =\
    \ numbers[0];\n    max.push(current_max);\n    for i in numbers.iter().skip(1)\
    \ {\n        if *i > current_max {\n            current_max = *i;\n        }\n\
    \        max.push(current_max);\n    }\n    max", "    let mut result = vec![];\n\
    \    let mut rolling_max = None;\n    for number in numbers {\n        rolling_max\
    \ = match rolling_max {\n            None => Some(number),\n            Some(rolling_max)\
    \ => {\n                if rolling_max > number {\n                    Some(rolling_max)\n\
    \                } else {\n                    Some(number)\n                }\n\
    \            }\n        };\n        result.push(rolling_max.unwrap());\n    }\n\
    \    result", "    let mut result = vec![];\n    let mut current_max = isize::min_value();\n\
    \    for num in numbers {\n        if num > current_max {\n            current_max\
    \ = num;\n        }\n        result.push(current_max);\n    }\n    result", " \
    \   let mut buffer = Vec::with_capacity(numbers.len());\n    let mut max_so_far\
    \ = numbers[0];\n    buffer.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *number);\n        buffer.push(max_so_far);\n\
    \    }\n    buffer", "    let mut result = Vec::new();\n    let mut max = None;\n\
    \    for (index, x) in numbers.iter().enumerate() {\n        if max.is_none()\
    \ || max.unwrap() < *x {\n            max = Some(*x);\n        }\n        result.push(max.unwrap());\n\
    \    }\n    result", "    let mut output = vec![];\n    let mut max_so_far = numbers[0];\n\
    \    output.push(max_so_far);\n    for number in numbers.iter().skip(1) {\n  \
    \      if *number > max_so_far {\n            max_so_far = *number;\n        }\n\
    \        output.push(max_so_far);\n    }\n    output", "    let mut result = Vec::new();\n\
    \    let mut current_max = std::isize::MIN;\n    for number in numbers {\n   \
    \     current_max = std::cmp::max(current_max, number);\n        result.push(current_max);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = -1;\n    for &num in numbers.iter() {\n        max = std::cmp::max(max,\
    \ num);\n        result.push(max);\n    }\n    result", "    let mut max_until_now\
    \ = numbers[0];\n    let mut result = Vec::new();\n    result.push(max_until_now);\n\
    \    for i in 1..numbers.len() {\n        max_until_now = std::cmp::max(max_until_now,\
    \ numbers[i]);\n        result.push(max_until_now);\n    }\n    result", "   \
    \ let mut result = Vec::new();\n    let mut max = 0;\n    for &number in numbers.iter()\
    \ {\n        max = max.max(number);\n        result.push(max);\n    }\n    result",
  "    let mut max_found_so_far = numbers[0];\n    let mut rolling_max = Vec::new();\n\
    \    rolling_max.push(max_found_so_far);\n\n    for num in numbers[1..].iter()\
    \ {\n        max_found_so_far = std::cmp::max(max_found_so_far, *num);\n     \
    \   rolling_max.push(max_found_so_far);\n    }\n\n    rolling_max", "    let mut\
    \ result = vec![];\n    let mut max = numbers[0];\n    for &x in numbers.iter()\
    \ {\n        if x > max {\n            max = x;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut running_max\
    \ = isize::min_value();\n    for n in numbers {\n        if n > running_max {\n\
    \            running_max = n;\n        }\n        result.push(running_max);\n\
    \    }\n    result", "    let mut max = 0;\n    let mut res = Vec::new();\n  \
    \  for el in numbers {\n        if el > max {\n            max = el;\n       \
    \ }\n        res.push(max);\n    }\n    res", "    let mut result = Vec::new();\n\
    \    let mut max = std::isize::MIN;\n    for number in numbers {\n        max\
    \ = std::cmp::max(max, number);\n        result.push(max);\n    }\n    result",
  "    numbers\n        .iter()\n        .scan(0, |state, x| {\n            *state\
    \ = cmp::max(*state, *x);\n            Some(*state)\n        })\n        .collect()",
  "    if numbers.is_empty() {\n        return Vec::new();\n    }\n\n    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    let mut current_max = numbers[0];\n\
    \    result.push(current_max);\n\n    for num in numbers.iter().skip(1) {\n  \
    \      current_max = max(current_max, *num);\n        result.push(current_max);\n\
    \    }\n\n    result", "    let mut result = vec![];\n    let mut max = numbers[0];\n\
    \    for i in 0..numbers.len() {\n        if numbers[i] > max {\n            max\
    \ = numbers[i];\n        }\n        result.push(max);\n    }\n    result", " \
    \   let mut max_numbers = Vec::new();\n    let mut current_max = None;\n    for\
    \ num in numbers {\n        match current_max {\n            None => current_max\
    \ = Some(num),\n            Some(val) => {\n                if num > val {\n \
    \                   current_max = Some(num);\n                }\n            }\n\
    \        }\n        max_numbers.push(current_max.unwrap());\n    }\n    max_numbers",
  "    numbers\n        .into_iter()\n        .scan(std::isize::MIN, |state, x| {\n\
    \            if x > *state {\n                *state = x;\n            }\n   \
    \         Some(*state)\n        })\n        .collect()", "    let mut rolling_max\
    \ = Vec::with_capacity(numbers.len());\n    let mut max_element = std::isize::MIN;\n\
    \    for element in numbers {\n        if element > max_element {\n          \
    \  max_element = element;\n        }\n        rolling_max.push(max_element);\n\
    \    }\n    rolling_max", "    numbers\n        .into_iter()\n        .scan(None,\
    \ |acc, x| {\n            *acc = if let Some(a) = acc {\n                Some(std::cmp::max(a,\
    \ x))\n            } else {\n                Some(x)\n            };\n       \
    \     Some(*acc)\n        })\n        .map(|x| x.unwrap())\n        .collect()",
  "    let mut result = Vec::with_capacity(numbers.len());\n    result.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        result.push(max(result[i - 1], numbers[i]));\n\
    \    }\n    result", "    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |prev_max, n| {\n            *prev_max = cmp::max(*prev_max, *n);\n        \
    \    Some(*prev_max)\n        })\n        .collect()", "    // use -INF to signify\
    \ starting point\n    let mut result = Vec::with_capacity(numbers.len());\n  \
    \  let mut curr_max = -INF;\n    for num in numbers {\n        curr_max = curr_max.max(num);\n\
    \        result.push(curr_max);\n    }\n    result", "    let mut result = vec![];\n\
    \    let mut max = numbers[0];\n    for &number in numbers.iter() {\n        max\
    \ = max.max(number);\n        result.push(max);\n    }\n    result", "    numbers\n\
    \        .iter()\n        .scan(None, |state, &x| {\n            *state = Some(state.map_or(x,\
    \ |s| s.max(x)));\n            Some(*state.unwrap())\n        })\n        .collect()",
  "    if numbers.is_empty() {\n        return Vec::new();\n    }\n\n    let mut max_until_now\
    \ = numbers[0];\n    let mut output = Vec::with_capacity(numbers.len());\n   \
    \ output.push(max_until_now);\n\n    for i in 1..numbers.len() {\n        max_until_now\
    \ = max(max_until_now, numbers[i]);\n        output.push(max_until_now);\n   \
    \ }\n\n    output", "    let mut rmax: Vec<isize> = Vec::new();\n    let mut max:\
    \ isize = *numbers.first().unwrap();\n    for n in numbers {\n        if n > max\
    \ {\n            max = n;\n        }\n        rmax.push(max);\n    }\n    rmax",
  "    let mut numbers_iter = numbers.iter();\n    let mut result = Vec::new();\n\
    \    let mut current_max = *numbers_iter.next().unwrap();\n    result.push(current_max);\n\
    \    for num in numbers_iter {\n        if num > &current_max {\n            current_max\
    \ = *num;\n        }\n        result.push(current_max);\n    }\n    result", " \
    \   let mut maximums = Vec::with_capacity(numbers.len());\n    let mut current_max\
    \ = None;\n    for n in numbers {\n        current_max = match current_max {\n\
    \            None => Some(n),\n            Some(value) => Some(std::cmp::max(value,\
    \ n)),\n        };\n        maximums.push(current_max.unwrap());\n    }\n    maximums",
  "    let mut result = Vec::with_capacity(numbers.len());\n    let mut max = isize::min_value();\n\
    \    for n in numbers {\n        max = max.max(n);\n        result.push(max);\n\
    \    }\n    result", "    numbers\n        .iter()\n        .scan(0, |max, &x|\
    \ {\n            if x > *max {\n                *max = x;\n            }\n   \
    \         Some(*max)\n        })\n        .collect()", "    let mut max: isize\
    \ = 0;\n    let mut result: Vec<isize> = Vec::new();\n    for n in numbers {\n\
    \        if n > max {\n            max = n;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut result = vec![numbers[0]];\n    for number in\
    \ numbers[1..].iter() {\n        let prev_max = result.last().unwrap();\n    \
    \    result.push(cmp::max(*prev_max, *number));\n    }\n    result", "    let\
    \ mut maxes = Vec::new();\n    maxes.push(numbers[0]);\n    for &n in numbers.iter().skip(1)\
    \ {\n        let max = maxes.last().unwrap();\n        if n > *max {\n       \
    \     maxes.push(n);\n        } else {\n            maxes.push(*max);\n      \
    \  }\n    }\n    maxes", "    let mut current_max = 0;\n    let mut answer = Vec::new();\n\
    \    for x in numbers {\n        current_max = std::cmp::max(current_max, x);\n\
    \        answer.push(current_max);\n    }\n    answer", "    let mut result =\
    \ Vec::with_capacity(numbers.len());\n    let mut current_max = 0;\n    for &n\
    \ in numbers.iter() {\n        if n > current_max {\n            current_max =\
    \ n;\n        }\n        result.push(current_max);\n    }\n    result", "    let\
    \ mut result = Vec::with_capacity(numbers.len());\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for v in numbers.iter().skip(1) {\n        if *v >\
    \ max {\n            max = *v;\n        }\n        result.push(max);\n    }\n\
    \    result", "    let mut result = vec![];\n    let mut current_max = 0;\n  \
    \  for number in numbers {\n        current_max = std::cmp::max(current_max, number);\n\
    \        result.push(current_max);\n    }\n    result", "    let mut maxes = Vec::new();\n\
    \    let mut current_max = numbers[0];\n    maxes.push(current_max);\n    for\
    \ n in numbers.iter().skip(1) {\n        current_max = max(current_max, *n);\n\
    \        maxes.push(current_max);\n    }\n    maxes", "    let mut result = Vec::new();\n\
    \    let mut max = std::isize::MIN;\n    for number in numbers {\n        if number\
    \ > max {\n            max = number;\n        }\n        result.push(max);\n \
    \   }\n    result", "    let mut rolling_max = Vec::new();\n    let mut max =\
    \ 0;\n    for number in numbers {\n        max = std::cmp::max(max, number);\n\
    \        rolling_max.push(max);\n    }\n    rolling_max", "    let mut v = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n    for x in numbers {\n        max =\
    \ max.max(x);\n        v.push(max);\n    }\n    v", "    let mut rolling_max =\
    \ vec![];\n    let mut max_value = isize::min_value();\n    for number in numbers\
    \ {\n        if number > max_value {\n            max_value = number;\n      \
    \  }\n        rolling_max.push(max_value);\n    }\n    rolling_max", "    let\
    \ mut rolling_max = Vec::with_capacity(numbers.len());\n    let mut max = std::isize::MIN;\n\
    \    for i in 0..numbers.len() {\n        if numbers[i] > max {\n            max\
    \ = numbers[i];\n        }\n        rolling_max.push(max);\n    }\n    rolling_max",
  "    numbers\n        .iter()\n        .scan(0, |state, x| {\n            *state\
    \ = (*state).max(*x);\n            Some(*state)\n        })\n        .collect()",
  "    let mut rolling_maxes = vec![];\n    let mut current_max = numbers[0];\n  \
    \  rolling_maxes.push(current_max);\n    for i in numbers[1..].iter() {\n    \
    \    if i > &current_max {\n            current_max = *i;\n        }\n       \
    \ rolling_maxes.push(current_max);\n    }\n    rolling_maxes", "    let mut rolling_max\
    \ = Vec::new();\n    let mut max = numbers[0];\n    rolling_max.push(max);\n \
    \   for i in numbers.iter().skip(1) {\n        if i > &max {\n            max\
    \ = *i;\n        }\n        rolling_max.push(max);\n    }\n    rolling_max", " \
    \   let mut max_so_far = isize::min_value();\n    let mut result = Vec::new();\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number);\n\
    \        result.push(max_so_far);\n    }\n    result", "    let mut res = Vec::new();\n\
    \    let mut max = isize::min_value();\n    for n in numbers {\n        if n >\
    \ max {\n            max = n;\n        }\n        res.push(max);\n    }\n    res",
  "    let mut res = Vec::with_capacity(numbers.len());\n    res.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        res.push(std::cmp::max(res[i - 1], numbers[i]));\n\
    \    }\n    res", "    let mut max = 0;\n    let mut result = Vec::new();\n  \
    \  for number in numbers {\n        max = std::cmp::max(max, number);\n      \
    \  result.push(max);\n    }\n    result", "    let mut max_until_moment = Vec::new();\n\
    \    let mut max_so_far = isize::min_value();\n    for num in numbers {\n    \
    \    max_so_far = isize::max(max_so_far, num);\n        max_until_moment.push(max_so_far);\n\
    \    }\n    max_until_moment", "    let mut ret = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for n in numbers {\n        if n > max\
    \ {\n            max = n;\n        }\n        ret.push(max);\n    }\n    ret",
  "    let mut result = Vec::with_capacity(numbers.len());\n    let mut cursor = 0;\n\
    \    while cursor < numbers.len() {\n        let max = numbers[cursor..].iter().max().unwrap();\n\
    \        result.push(*max);\n        cursor += 1;\n    }\n    result", "    let\
    \ mut result = Vec::new();\n    for i in 0..numbers.len() {\n        result.push(\n\
    \            *numbers\n                .iter()\n                .take(i + 1)\n\
    \                .max()\n                .expect(\"Could not get max from vector\"\
    ),\n        );\n    }\n    result", "    let mut result = Vec::new();\n    let\
    \ mut max_so_far = numbers[0];\n    result.push(max_so_far);\n    for number in\
    \ numbers.iter().skip(1) {\n        max_so_far = std::cmp::max(max_so_far, *number);\n\
    \        result.push(max_so_far);\n    }\n    result", "    let mut maxes = Vec::new();\n\
    \    let mut max = numbers[0];\n    maxes.push(max);\n    for number in numbers.iter().skip(1)\
    \ {\n        max = max.max(*number);\n        maxes.push(max);\n    }\n    maxes",
  "    let mut acc: Vec<isize> = vec![];\n    for n in numbers {\n        if acc.is_empty()\
    \ {\n            acc.push(n);\n        } else {\n            acc.push(acc.last().unwrap().max(n));\n\
    \        }\n    }\n    acc", "    let mut result = vec![];\n    let mut max_number\
    \ = numbers[0];\n    for number in numbers {\n        max_number = max(max_number,\
    \ number);\n        result.push(max_number);\n    }\n    result", "    let mut\
    \ result = Vec::with_capacity(numbers.len());\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result", "    numbers\n        .iter()\n        .scan(0, |max, &x|\
    \ {\n            if x > *max {\n                *max = x;\n            }\n   \
    \         Some(*max)\n        })\n        .collect()", "    if numbers.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut solution = vec![numbers[0]];\n\
    \    for number in numbers.iter().skip(1) {\n        let previous_max = solution.last().cloned().unwrap();\n\
    \        solution.push(max(previous_max, *number));\n    }\n\n    solution", " \
    \   let mut res = Vec::with_capacity(numbers.len());\n    res.push(numbers[0]);\n\
    \    for (i, &a) in numbers.iter().enumerate().skip(1) {\n        res.push(max(res[i-1],\
    \ a));\n    }\n    res", "    let mut roll_max = Vec::new();\n    let mut current_max\
    \ = numbers[0];\n    roll_max.push(current_max);\n    for num in numbers.iter().skip(1)\
    \ {\n        if num > &current_max {\n            current_max = *num;\n      \
    \  }\n        roll_max.push(current_max);\n    }\n    roll_max", "    let mut\
    \ maximums = Vec::with_capacity(numbers.len());\n    let mut next_maximum = None;\n\
    \    for &number in numbers.iter().rev() {\n        next_maximum = match next_maximum\
    \ {\n            None => Some(number),\n            Some(max) => Some(number.max(max)),\n\
    \        };\n    }\n    for number in numbers {\n        maximums.push(next_maximum.unwrap());\n\
    \        next_maximum = match next_maximum {\n            None => None,\n    \
    \        Some(max) => Some(number.max(max)),\n        };\n    }\n    maximums",
  "    let mut rolling_max = Vec::new();\n    let mut maximum = 0;\n    for number\
    \ in numbers {\n        maximum = std::cmp::max(maximum, number);\n        rolling_max.push(maximum);\n\
    \    }\n    rolling_max", "    let mut result = vec![];\n    let mut largest =\
    \ std::isize::MIN;\n    for n in numbers {\n        if n > largest {\n       \
    \     largest = n;\n        }\n        result.push(largest);\n    }\n    result",
  "    let mut result = Vec::with_capacity(numbers.len());\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for &x in numbers.iter().skip(1) {\n        max =\
    \ max.max(x);\n        result.push(max);\n    }\n    result", "    let mut res\
    \ = Vec::new();\n    let mut current_max = std::isize::MIN;\n    for n in numbers\
    \ {\n        current_max = current_max.max(n);\n        res.push(current_max);\n\
    \    }\n    res", "    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for &number in numbers.iter().skip(1) {\n        if\
    \ number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut roll_max = Vec::new();\n    let mut curr_max\
    \ = isize::min_value();\n    for num in numbers {\n        curr_max = max(curr_max,\
    \ num);\n        roll_max.push(curr_max);\n    }\n    roll_max", "    let mut\
    \ result = vec![];\n    let mut max_value = std::isize::MIN;\n    for number in\
    \ numbers {\n        if number > max_value {\n            max_value = number;\n\
    \        }\n        result.push(max_value);\n    }\n    result", "    let mut\
    \ max: isize = numbers[0];\n    let mut output: Vec<isize> = Vec::new();\n   \
    \ output.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i] >\
    \ max {\n            max = numbers[i];\n        }\n        output.push(max);\n\
    \    }\n    output", "    numbers\n        .into_iter()\n        .scan(0, |max,\
    \ elem| {\n            *max = cmp::max(*max, elem);\n            Some(*max)\n\
    \        })\n        .collect()", "    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut max = numbers[0];\n    rolling_max.push(max);\n    for number in\
    \ numbers.iter().skip(1) {\n        if number > &max {\n            max = *number;\n\
    \        }\n        rolling_max.push(max);\n    }\n    rolling_max", "    let\
    \ mut maxes = Vec::new();\n    let mut max = std::isize::MIN;\n    for num in\
    \ numbers {\n        max = std::cmp::max(max, num);\n        maxes.push(max);\n\
    \    }\n    maxes", "    let mut max_values = Vec::new();\n    let mut max_value\
    \ = numbers[0];\n    max_values.push(max_value);\n    for i in 1..numbers.len()\
    \ {\n        max_value = std::cmp::max(max_value, numbers[i]);\n        max_values.push(max_value);\n\
    \    }\n    max_values", "    let mut result = Vec::new();\n    let mut max =\
    \ isize::min_value();\n    for &number in numbers.iter() {\n        max = max.max(number);\n\
    \        result.push(max);\n    }\n    result", "    let mut result = vec![];\n\
    \    let mut max = 0;\n    for number in numbers {\n        if number > max {\n\
    \            max = number;\n        }\n        result.push(max);\n    }\n    result",
  "    let mut num_stack = Vec::new();\n    let mut result = Vec::new();\n\n    for\
    \ number in numbers {\n        while !num_stack.is_empty() && num_stack.last().unwrap()\
    \ < &number {\n            num_stack.pop();\n        }\n        num_stack.push(number);\n\
    \        result.push(num_stack.last().unwrap().clone());\n    }\n\n    result",
  "    let mut max: Vec<isize> = vec![];\n    let mut current_max = numbers[0];\n\
    \    max.push(current_max);\n    for x in numbers {\n        current_max = if\
    \ x > current_max { x } else { current_max };\n        max.push(current_max);\n\
    \    }\n    max", "    numbers\n        .into_iter()\n        .scan(0, |state,\
    \ next| {\n            *state = cmp::max(*state, next);\n            Some(*state)\n\
    \        })\n        .collect()", "    let len = numbers.len();\n    let mut result\
    \ = Vec::with_capacity(len);\n    let mut max_value = std::isize::MIN;\n    for\
    \ value in numbers {\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n        result.push(max_value);\n    }\n    result", "  \
    \  let mut max = -1;\n    let mut list = Vec::new();\n    for &number in numbers.iter()\
    \ {\n        if number > max {\n            max = number;\n        }\n       \
    \ list.push(max);\n    }\n    list", "    numbers\n        .into_iter()\n    \
    \    .scan(None, |acc, x| {\n            *acc = Some(acc.unwrap_or(x).max(x));\n\
    \            Some(acc.unwrap())\n        })\n        .collect()", "    let mut\
    \ max_element = 0;\n    let mut result = Vec::new();\n    for n in numbers {\n\
    \        max_element = if n > max_element { n } else { max_element };\n      \
    \  result.push(max_element);\n    }\n    result", "    let mut max = numbers[0];\n\
    \    let mut maxes = Vec::new();\n    maxes.push(max);\n    for &x in numbers.iter().skip(1)\
    \ {\n        max = max.max(x);\n        maxes.push(max);\n    }\n    maxes", " \
    \   let mut result = Vec::new();\n    let mut current_max = std::isize::MIN;\n\
    \    for number in numbers {\n        current_max = std::cmp::max(current_max,\
    \ number);\n        result.push(current_max);\n    }\n    result", "    let mut\
    \ result = Vec::new();\n    let mut max_so_far = std::isize::MIN;\n    for &num\
    \ in numbers.iter() {\n        max_so_far = std::cmp::max(max_so_far, num);\n\
    \        result.push(max_so_far);\n    }\n    result", "    let mut rolling_maxes\
    \ = Vec::new();\n    let mut max_yet = isize::min_value();\n    for number in\
    \ numbers {\n        max_yet = std::cmp::max(max_yet, number);\n        rolling_maxes.push(max_yet);\n\
    \    }\n    rolling_maxes", "    let mut rmax: Vec<isize> = Vec::new();\n    let\
    \ mut max: isize = 0;\n    for n in numbers {\n        max = max.max(n);\n   \
    \     rmax.push(max);\n    }\n    rmax", "    let mut max_so_far = numbers[0];\n\
    \    let mut rolling_max = Vec::new();\n    rolling_max.push(max_so_far);\n  \
    \  for number in numbers.iter().skip(1) {\n        if *number > max_so_far {\n\
    \            max_so_far = *number;\n        }\n        rolling_max.push(max_so_far);\n\
    \    }\n    rolling_max", "    let mut accumulator = 0;\n    let mut rolling_max\
    \ = Vec::new();\n    for i in numbers {\n        if i > accumulator {\n      \
    \      accumulator = i;\n        }\n        rolling_max.push(accumulator);\n \
    \   }\n    rolling_max", "    let mut result = vec![];\n    let mut curr_max =\
    \ isize::min_value();\n    for num in numbers {\n        curr_max = std::cmp::max(curr_max,\
    \ num);\n        result.push(curr_max);\n    }\n    result", "    numbers\n  \
    \      .iter()\n        .scan(std::isize::MIN, |state, x| {\n            *state\
    \ = std::cmp::max(*state, *x);\n            Some(*state)\n        })\n       \
    \ .collect()", "    let mut max: isize = *numbers.first().unwrap();\n    let mut\
    \ result: Vec<isize> = Vec::new();\n    for n in numbers {\n        max = std::cmp::max(max,\
    \ n);\n        result.push(max);\n    }\n    result", "    let mut result = Vec::new();\n\
    \    let mut max = 0;\n    for n in numbers {\n        if n > max {\n        \
    \    max = n;\n        }\n        result.push(max);\n    }\n    result", "   \
    \ let mut max_so_far = numbers[0];\n    let mut maxes = vec![max_so_far];\n  \
    \  for number in numbers.iter().skip(1) {\n        max_so_far = std::cmp::max(max_so_far,\
    \ *number);\n        maxes.push(max_so_far);\n    }\n    maxes", "    let mut\
    \ result = vec![];\n    let mut max = numbers[0];\n    for number in numbers {\n\
    \        if number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut ret = Vec::new();\n    let mut current_max =\
    \ numbers[0];\n    ret.push(current_max);\n    for i in 1..numbers.len() {\n \
    \       current_max = if numbers[i] > current_max {\n            numbers[i]\n\
    \        } else {\n            current_max\n        };\n        ret.push(current_max);\n\
    \    }\n    ret", "    let mut rolling_max_num = numbers[0];\n    let mut rolling_max_sequence\
    \ = Vec::with_capacity(numbers.len());\n    rolling_max_sequence.push(rolling_max_num);\n\
    \n    for i in 1..numbers.len() {\n        rolling_max_num = rolling_max_num.max(numbers[i]);\n\
    \        rolling_max_sequence.push(rolling_max_num);\n    }\n\n    rolling_max_sequence",
  "    let mut result = vec![numbers[0]];\n    for number in numbers.iter().skip(1)\
    \ {\n        result.push(result.last().unwrap().max(*number));\n    }\n    result",
  "    let mut maxes = Vec::new();\n    for number in numbers {\n        maxes.push(maxes.last().unwrap_or(&0).clone()\
    \ + number);\n    }\n    maxes", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = None;\n    for num in numbers {\n        match max {\n    \
    \        None => {\n                max = Some(num);\n            }\n        \
    \    Some(current_max) => {\n                max = Some(std::cmp::max(current_max,\
    \ num));\n            }\n        }\n        result.push(max.unwrap());\n    }\n\
    \    result", "    let mut vec = vec![];\n    let mut max = 0;\n    for i in numbers\
    \ {\n        max = if i > max { i } else { max };\n        vec.push(max);\n  \
    \  }\n    vec", "    let mut result = Vec::with_capacity(numbers.len());\n   \
    \ let mut current_max = numbers[0];\n    result.push(current_max);\n    for number\
    \ in numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max,\
    \ *number);\n        result.push(current_max);\n    }\n    result", "    let mut\
    \ idx = 0;\n    let mut numbers_len = numbers.len();\n    let mut out: Vec<isize>\
    \ = Vec::with_capacity(numbers_len);\n    let mut max_so_far = numbers[0];\n \
    \   while idx < numbers_len {\n        out.push(max_so_far);\n        if numbers[idx]\
    \ > max_so_far {\n            max_so_far = numbers[idx];\n        }\n        idx\
    \ += 1;\n    }\n    out", "    let mut maxes = vec![];\n    let mut current_max\
    \ = numbers[0];\n    maxes.push(current_max);\n    for number in numbers.iter().skip(1)\
    \ {\n        current_max = current_max.max(*number);\n        maxes.push(current_max);\n\
    \    }\n    maxes", "    let mut max: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for i in numbers {\n        max = max.max(i);\n        result.push(max);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut curr_max = numbers[0];\n    result.push(curr_max);\n    for &number\
    \ in numbers.iter().skip(1) {\n        curr_max = std::cmp::max(curr_max, number);\n\
    \        result.push(curr_max);\n    }\n    result", "    let mut max = numbers[0];\n\
    \    let mut results = Vec::new();\n    results.push(max);\n    for number in\
    \ numbers.iter().skip(1) {\n        max = std::cmp::max(max, *number);\n     \
    \   results.push(max);\n    }\n    results", "    let mut result = vec![];\n \
    \   let mut current_max = isize::min_value();\n    for item in numbers {\n   \
    \     if item > current_max {\n            current_max = item;\n        }\n  \
    \      result.push(current_max);\n    }\n    result", "    let mut max_sequence\
    \ = Vec::with_capacity(numbers.len());\n    let mut current_max = 0;\n    for\
    \ number in numbers {\n        if number > current_max {\n            current_max\
    \ = number;\n        }\n        max_sequence.push(current_max);\n    }\n    max_sequence",
  "    let mut i = 0;\n    let mut current_max = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(current_max);\n    while i < numbers.len() - 1\
    \ {\n        i += 1;\n        if numbers[i] > current_max {\n            current_max\
    \ = numbers[i];\n        }\n        result.push(current_max);\n    }\n    result",
  "    let mut rolling_max = vec![];\n    let mut max_number = isize::min_value();\n\
    \    for number in numbers {\n        if number > max_number {\n            max_number\
    \ = number;\n        }\n        rolling_max.push(max_number);\n    }\n    rolling_max",
  "    let mut result = Vec::with_capacity(numbers.len());\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result", "    let mut max = numbers[0];\n\
    \    let mut maxes = Vec::new();\n    maxes.push(max);\n    for number in numbers.iter().skip(1)\
    \ {\n        max = cmp::max(max, *number);\n        maxes.push(max);\n    }\n\
    \    maxes", "    let mut max_so_far = std::isize::MIN;\n    let mut rolling_max:\
    \ Vec<isize> = Vec::new();\n    for i in numbers {\n        if i > max_so_far\
    \ {\n            max_so_far = i;\n        }\n        rolling_max.push(max_so_far);\n\
    \    }\n    rolling_max", "    let mut rolling_max_elements = Vec::new();\n  \
    \  let mut max_element = isize::min_value();\n    for number in numbers {\n  \
    \      max_element = cmp::max(max_element, number);\n        rolling_max_elements.push(max_element);\n\
    \    }\n    rolling_max_elements", "    let mut ans = vec![numbers[0]];\n    for\
    \ i in 1..numbers.len() {\n        ans.push(std::cmp::max(ans[i - 1], numbers[i]));\n\
    \    }\n    ans", "    let mut max_elements = vec![];\n    let mut current_max\
    \ = numbers[0];\n    max_elements.push(current_max);\n    for num in numbers.iter().skip(1)\
    \ {\n        if num > &current_max {\n            current_max = *num;\n      \
    \  }\n        max_elements.push(current_max);\n    }\n    max_elements", "   \
    \ let mut rolling_max = Vec::new();\n    let mut current_max = -1;\n    for x\
    \ in numbers {\n        if x > current_max {\n            current_max = x;\n \
    \       }\n        rolling_max.push(current_max);\n    }\n    rolling_max", " \
    \   if numbers.is_empty() {\n        return vec![];\n    }\n\n    let mut rolling_max_sofar\
    \ = numbers[0];\n    let mut out = vec![rolling_max_sofar];\n\n    for i in 1..numbers.len()\
    \ {\n        rolling_max_sofar = std::cmp::max(rolling_max_sofar, numbers[i]);\n\
    \        out.push(rolling_max_sofar);\n    }\n\n    out", "    let mut rolling_max_numbers\
    \ = Vec::with_capacity(numbers.len());\n    let mut max_number = numbers[0];\n\
    \    rolling_max_numbers.push(max_number);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_number = if *number > max_number {\n            *number\n   \
    \     } else {\n            max_number\n        };\n        rolling_max_numbers.push(max_number);\n\
    \    }\n    rolling_max_numbers", "    let mut current_max = numbers[0];\n   \
    \ let mut result = Vec::new();\n    result.push(current_max);\n    for number\
    \ in numbers {\n        if number > current_max {\n            current_max = number;\n\
    \        }\n        result.push(current_max);\n    }\n    result", "    let mut\
    \ max_number = std::isize::MIN;\n    let mut max_numbers = Vec::new();\n    for\
    \ &number in numbers.iter() {\n        max_number = std::cmp::max(max_number,\
    \ number);\n        max_numbers.push(max_number);\n    }\n    max_numbers", " \
    \   let mut maxes = Vec::new();\n    let mut current_max = isize::min_value();\n\
    \    for number in numbers {\n        current_max = std::cmp::max(current_max,\
    \ number);\n        maxes.push(current_max);\n    }\n    maxes", "    if numbers.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut maximum = numbers[0];\n    let\
    \ mut result = vec![];\n    for number in numbers {\n        if number > maximum\
    \ {\n            maximum = number;\n        }\n        result.push(maximum);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut running_max = numbers[0];\n    result.push(running_max);\n    for\
    \ i in numbers.iter().skip(1) {\n        running_max = std::cmp::max(running_max,\
    \ *i);\n        result.push(running_max);\n    }\n    result", "    let mut rolling_max\
    \ = Vec::new();\n    let mut max_so_far = numbers[0];\n    rolling_max.push(max_so_far);\n\
    \    for next_number in numbers.iter().skip(1) {\n        max_so_far = if max_so_far\
    \ > *next_number {\n            max_so_far\n        } else {\n            *next_number\n\
    \        };\n        rolling_max.push(max_so_far);\n    }\n    rolling_max", " \
    \   if numbers.is_empty() {\n        return vec![];\n    }\n\n    let mut result\
    \ = vec![];\n    let mut current_max = numbers[0];\n    result.push(current_max);\n\
    \n    for num in numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max,\
    \ *num);\n        result.push(current_max);\n    }\n\n    result", "    let mut\
    \ result = Vec::with_capacity(numbers.len());\n    let mut current_max = numbers[0];\n\
    \    result.push(current_max);\n    for &number in numbers.iter().skip(1) {\n\
    \        current_max = std::cmp::max(current_max, number);\n        result.push(current_max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut current_max\
    \ = std::isize::MIN;\n    for number in numbers {\n        current_max = current_max.max(number);\n\
    \        result.push(current_max);\n    }\n    result", "    let mut max_sum =\
    \ 0;\n    let mut max_number = 0;\n    let mut ans = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        let local_max = max(number, max_number +\
    \ number);\n        max_number = max(0, local_max);\n        max_sum = max(max_sum,\
    \ max_number);\n        ans.push(max_sum);\n    }\n    ans", "    let mut max_elems\
    \ = Vec::with_capacity(numbers.len());\n    let mut max_until_now = isize::min_value();\n\
    \    for &num in numbers.iter() {\n        max_until_now = max(max_until_now,\
    \ num);\n        max_elems.push(max_until_now);\n    }\n    max_elems", "    numbers\n\
    \        .iter()\n        .scan(0, |state, x| {\n            *state = isize::max(*state,\
    \ *x);\n            Some(*state)\n        })\n        .collect()", "    if numbers.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut rolling_max_sequence = vec![numbers[0]];\n\
    \    for i in 1..numbers.len() {\n        rolling_max_sequence.push(std::cmp::max(rolling_max_sequence[i\
    \ - 1], numbers[i]));\n    }\n\n    rolling_max_sequence", "    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    let mut max_val = std::isize::MIN;\n\
    \    for num in numbers {\n        max_val = max_val.max(num);\n        result.push(max_val);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ i in 1..numbers.len() {\n        current_max = std::cmp::max(current_max, numbers[i]);\n\
    \        result.push(current_max);\n    }\n    result", "    let mut rng_max =\
    \ vec![numbers[0]];\n    for i in 1..numbers.len() {\n        rng_max.push(rng_max[i\
    \ - 1].max(numbers[i]));\n    }\n    rng_max", "    let mut result = Vec::new();\n\
    \    let mut current_max = isize::min_value();\n    for num in numbers {\n   \
    \     if num > current_max {\n            current_max = num;\n        }\n    \
    \    result.push(current_max);\n    }\n    result", "    let mut max = 0;\n  \
    \  let mut result = Vec::new();\n    for num in numbers {\n        max = max.max(num);\n\
    \        result.push(max);\n    }\n    result", "    let mut output = Vec::with_capacity(numbers.len());\n\
    \    if let Some(&first) = numbers.first() {\n        output.push(first);\n  \
    \  }\n    for i in 1..numbers.len() {\n        let max = std::cmp::max(output[i\
    \ - 1], numbers[i]);\n        output.push(max);\n    }\n    output", "    let\
    \ mut result = vec![];\n    let mut curr_max = numbers[0];\n    for &number in\
    \ numbers.iter() {\n        if number > curr_max {\n            curr_max = number;\n\
    \        }\n        result.push(curr_max);\n    }\n    result", "    let mut result\
    \ = Vec::new();\n    let mut max = numbers[0];\n    result.push(max);\n    for\
    \ number in numbers.iter().skip(1) {\n        if number > &max {\n           \
    \ max = *number;\n        }\n        result.push(max);\n    }\n    result", " \
    \   let mut result = Vec::new();\n    let mut max_so_far = isize::min_value();\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number);\n\
    \        result.push(max_so_far);\n    }\n    result", "    let mut max_found_so_far\
    \ = numbers[0];\n    let mut maxima = Vec::new();\n    maxima.push(max_found_so_far);\n\
    \    for n in numbers.iter().skip(1) {\n        if n > &max_found_so_far {\n \
    \           max_found_so_far = *n;\n        }\n        maxima.push(max_found_so_far);\n\
    \    }\n    maxima", "    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut max_until_now = 0;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for current in numbers {\n        if current > max_until_now {\n        \
    \    max_until_now = current;\n        }\n        result.push(max_until_now);\n\
    \    }\n    result", "    let mut maxes = Vec::new();\n    let mut max = 0;\n\
    \    for n in numbers {\n        max = max.max(n);\n        maxes.push(max);\n\
    \    }\n    maxes", "    let mut maxes = vec![];\n    let mut current_max = 0;\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number;\n        }\n        maxes.push(current_max);\n    }\n    maxes", " \
    \   let mut max = numbers[0];\n    let mut maxes = Vec::new();\n    maxes.push(max);\n\
    \    for i in numbers {\n        if i > max {\n            max = i;\n        }\n\
    \        maxes.push(max);\n    }\n    maxes", "    let mut rolling_max_list =\
    \ Vec::new();\n    let mut current_max = -1;\n    for number in numbers {\n  \
    \      current_max = std::cmp::max(current_max, number);\n        rolling_max_list.push(current_max);\n\
    \    }\n    rolling_max_list", "    let mut maximum = 0;\n    let mut result =\
    \ Vec::new();\n    for number in numbers {\n        maximum = maximum.max(number);\n\
    \        result.push(maximum);\n    }\n    result", "    let mut rmax = vec![];\n\
    \    let mut max = std::isize::MIN;\n    for n in numbers {\n        max = max.max(n);\n\
    \        rmax.push(max);\n    }\n    rmax", "    let mut result = Vec::new();\n\
    \    let mut max_so_far = numbers[0];\n    result.push(max_so_far);\n    for i\
    \ in 1..numbers.len() {\n        max_so_far = numbers[i].max(max_so_far);\n  \
    \      result.push(max_so_far);\n    }\n    result", "    let mut max_seen_by_now\
    \ = vec![0; numbers.len()];\n    let mut current_max = isize::min_value();\n \
    \   for i in 0..numbers.len() {\n        if numbers[i] > current_max {\n     \
    \       current_max = numbers[i];\n        }\n        max_seen_by_now[i] = current_max;\n\
    \    }\n    max_seen_by_now", "    let mut rmax = vec![numbers[0]];\n    for i\
    \ in 1..numbers.len() {\n        rmax.push(std::cmp::max(rmax[i - 1], numbers[i]));\n\
    \    }\n    rmax", "    let mut max_so_far = numbers[0];\n    let mut output =\
    \ Vec::new();\n    output.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = number.max(max_so_far);\n        output.push(max_so_far);\n\
    \    }\n    output", "    numbers\n        .iter()\n        .scan(|state, &x|\
    \ {\n            *state = Some(if let Some(max) = state {\n                x.max(max)\n\
    \            } else {\n                x\n            });\n            Some(*state)\n\
    \        })\n        .collect::<Vec<_>>()\n        .iter()\n        .map(|x| x.unwrap())\n\
    \        .collect()", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    if numbers.is_empty() {\n        return result;\n    }\n    let mut current_max\
    \ = numbers[0];\n    result.push(current_max);\n    for &x in numbers.iter().skip(1)\
    \ {\n        if x > current_max {\n            current_max = x;\n        }\n \
    \       result.push(current_max);\n    }\n    result", "    let mut maximum =\
    \ 0;\n    let mut result = Vec::with_capacity(numbers.len());\n    for number\
    \ in numbers {\n        maximum = maximum.max(number);\n        result.push(maximum);\n\
    \    }\n    result", "    let mut result = vec![];\n    let mut max_seen = std::isize::MIN;\n\
    \    for number in numbers {\n        if number > max_seen {\n            max_seen\
    \ = number;\n        }\n        result.push(max_seen);\n    }\n    result", " \
    \   let mut max = numbers[0];\n    let mut res = Vec::new();\n    res.push(max);\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] > max {\n            max\
    \ = numbers[i];\n        }\n        res.push(max);\n    }\n    res", "    let\
    \ mut max = vec![];\n    let mut current_max = std::isize::MIN;\n    for i in\
    \ numbers {\n        if i > current_max {\n            current_max = i;\n    \
    \    }\n        max.push(current_max);\n    }\n    max", "    let mut max_value\
    \ = std::isize::MIN;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        max_value = std::cmp::max(max_value, number);\n\
    \        result.push(max_value);\n    }\n    result", "    let mut max_numbers\
    \ = Vec::new();\n    let mut current_max = std::isize::MIN;\n    for n in numbers\
    \ {\n        current_max = std::cmp::max(current_max, n);\n        max_numbers.push(current_max);\n\
    \    }\n    max_numbers", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max_seen = numbers[0];\n    result.push(max_seen);\n    for number\
    \ in numbers.iter().skip(1) {\n        if *number > max_seen {\n            max_seen\
    \ = *number;\n        }\n        result.push(max_seen);\n    }\n    result", " \
    \   let mut maximum = 0;\n    let mut result = Vec::new();\n    for number in\
    \ numbers {\n        maximum = std::cmp::max(maximum, number);\n        result.push(maximum);\n\
    \    }\n    result", "    let mut rolling_max = vec![];\n    for &number in numbers.iter()\
    \ {\n        let max = match rolling_max.last() {\n            Some(x) => x.max(number),\n\
    \            None => number,\n        };\n        rolling_max.push(max);\n   \
    \ }\n    rolling_max", "    let mut maximum = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(maximum);\n    for i in 1..numbers.len() {\n\
    \        maximum = maximum.max(numbers[i]);\n        result.push(maximum);\n \
    \   }\n    result", "    numbers\n        .iter()\n        .scan(0, |max, &x|\
    \ {\n            *max = std::cmp::max(*max, x);\n            Some(*max)\n    \
    \    })\n        .collect()", "    let mut result = vec![];\n    let mut current_max\
    \ = std::isize::MIN;\n    for n in numbers {\n        current_max = current_max.max(n);\n\
    \        result.push(current_max);\n    }\n    result", "    let mut r: Vec<isize>\
    \ = Vec::new();\n    r.push(numbers[0]);\n    for (i, _) in numbers.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        r.push(\n\
    \            if r[i - 1] > numbers[i] {\n                r[i - 1]\n          \
    \  } else {\n                numbers[i]\n            },\n        );\n    }\n \
    \   r", "    let mut res = vec![numbers[0]];\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        if i > 0 {\n            let max = std::cmp::max(res[i - 1], *n);\n\
    \            res.push(max);\n        }\n    }\n    res", "    let mut res = Vec::with_capacity(numbers.len());\n\
    \    let mut max_current = numbers[0];\n    res.push(max_current);\n    for n\
    \ in numbers.iter().skip(1) {\n        max_current = max_current.max(*n);\n  \
    \      res.push(max_current);\n    }\n    res", "    let mut max_elems = Vec::with_capacity(numbers.len());\n\
    \    let mut max_elem = 0;\n    for number in numbers {\n        max_elem = max(max_elem,\
    \ number);\n        max_elems.push(max_elem);\n    }\n    max_elems", "    //\
    \ TODO: write code here\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut max: isize = -1;\n    for n in numbers {\n        if n > max {\n       \
    \     max = n;\n        }\n        result.push(max);\n    }\n    result", "  \
    \  let mut result = Vec::with_capacity(numbers.len());\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result", "    let mut max_so_far\
    \ = numbers[0];\n    let mut running_max = Vec::with_capacity(numbers.len());\n\
    \    running_max.push(max_so_far);\n\n    for n in numbers.iter().skip(1) {\n\
    \        if n > &max_so_far {\n            max_so_far = *n;\n        }\n     \
    \   running_max.push(max_so_far);\n    }\n\n    running_max", "    let mut rolling_max\
    \ = Vec::new();\n    let mut max_so_far = std::isize::MIN;\n    for number in\
    \ numbers {\n        max_so_far = std::cmp::max(max_so_far, number);\n       \
    \ rolling_max.push(max_so_far);\n    }\n    rolling_max", "    let mut sequence\
    \ = vec![];\n    let mut max = 0;\n    for n in numbers {\n        max = std::cmp::max(max,\
    \ n);\n        sequence.push(max);\n    }\n    sequence", "    let mut result\
    \ = Vec::new();\n    let mut max = std::isize::MIN;\n    for n in numbers {\n\
    \        max = std::cmp::max(max, n);\n        result.push(max);\n    }\n    result",
  "    let mut rolling_max = Vec::new();\n    let mut max = numbers[0];\n    rolling_max.push(max);\n\
    \    for n in numbers.iter().skip(1) {\n        max = std::cmp::max(max, *n);\n\
    \        rolling_max.push(max);\n    }\n    rolling_max", "    let mut current_max\
    \ = std::isize::MIN;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        current_max = number.max(current_max);\n\
    \        result.push(current_max);\n    }\n    result", "    let mut max_found\
    \ = numbers[0];\n    let mut rolling_max_numbers = Vec::with_capacity(numbers.len());\n\
    \    rolling_max_numbers.push(max_found);\n\n    for i in 1..numbers.len() {\n\
    \        max_found = numbers[i].max(max_found);\n        rolling_max_numbers.push(max_found);\n\
    \    }\n\n    rolling_max_numbers", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ number in numbers.iter().skip(1) {\n        if *number > current_max {\n   \
    \         current_max = *number;\n        }\n        result.push(current_max);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max_so_far = numbers[0];\n    result.push(max_so_far);\n    for item\
    \ in numbers[1..].iter() {\n        max_so_far = cmp::max(max_so_far, *item);\n\
    \        result.push(max_so_far);\n    }\n    result"]
stop_tokens:
- "\n}"
