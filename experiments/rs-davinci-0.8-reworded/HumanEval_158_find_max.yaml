name: HumanEval_158_find_max
language: rs
prompt: "/// Write a function that accepts a vector of strings.\n/// The vector contains\
  \ different words. Return the word with maximum number\n/// of unique characters.\
  \ If multiple strings have maximum number of unique\n/// characters, return the\
  \ one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
  name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\"\
  )\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"\
  game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"\
  ), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\n\
  fn find_max(words: Vec<String>) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
  name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
  ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
  ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
  aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
  ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]),\
  \ String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
  \ String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
  footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
  we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
  \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"),\
  \ String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
  nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
  this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"\
  this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"\
  b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"\
  ), String::from(\"play\")]), String::from(\"play\"));\n}\n"
completions: ['    unimplemented!();', "    let mut max = 0;\n    let mut max_word\
    \ = String::new();\n    for word in words {\n        let v = uniq_chars(word.clone());\n\
    \        if v.len() > max {\n            max = v.len();\n            max_word\
    \ = word;\n        }\n    }\n    max_word", "    let res = words.iter().fold(None,\
    \ |result, x| match result {\n        None => Some((x.len(), x)),\n        Some((cnt,\
    \ y)) => {\n            let x_cnt = x.chars().collect::<HashSet<_>>().len();\n\
    \            if x_cnt > cnt {\n                Some((x_cnt, x))\n            }\
    \ else if x_cnt == cnt {\n                if x < y {\n                    Some((x_cnt,\
    \ x))\n                } else {\n                    Some((cnt, y))\n        \
    \        }\n            } else {\n                Some((cnt, y))\n           \
    \ }\n        }\n    });\n    res.unwrap().1.to_string()", "    // TODO: Implement\
    \ me!\n    unimplemented!()", "    let mut max_word = String::new();\n    let\
    \ mut max_count = 0;\n    for word in words {\n        let mut seen_chars = HashSet::new();\n\
    \        for char in word.chars() {\n            seen_chars.insert(char);\n  \
    \      }\n        if seen_chars.len() > max_count || (seen_chars.len() == max_count\
    \ && word < max_word) {\n            max_count = seen_chars.len();\n         \
    \   max_word = word;\n        }\n    }\n    max_word", "    words.iter().max_by_key(|word|\
    \ {\n        let mut chars = HashSet::new();\n        for c in word.chars() {\n\
    \            chars.insert(c);\n        }\n        chars.len()\n    }).unwrap().to_string()",
  "    let mut max_unique_chars = 0;\n    let mut max_word = \"\".to_string();\n \
    \   for word in words {\n        let unique_chars = word.chars().collect::<HashSet<char>>().len();\n\
    \        if unique_chars > max_unique_chars ||\n            (unique_chars == max_unique_chars\
    \ && word < max_word) {\n            max_unique_chars = unique_chars;\n      \
    \      max_word = word;\n        }\n    }\n    max_word", "    let mut max_len\
    \ = 0;\n    let mut max_string = String::new();\n    for word in words {\n   \
    \     let mut chars = HashSet::new();\n        for c in word.chars() {\n     \
    \       chars.insert(c);\n        }\n        if chars.len() > max_len {\n    \
    \        max_len = chars.len();\n            max_string = word;\n        }\n \
    \   }\n    max_string", "    let mut max = 0;\n    let mut max_string = String::new();\n\
    \    for word in words {\n        let mut char_set = HashSet::new();\n       \
    \ for c in word.chars() {\n            char_set.insert(c);\n        }\n      \
    \  if char_set.len() > max {\n            max = char_set.len();\n            max_string\
    \ = word;\n        }\n    }\n    max_string", "    let mut max = (String::from(\"\
    \"), 0);\n    for word in words {\n        let mut chars = HashSet::new();\n \
    \       for c in word.chars() {\n            chars.insert(c);\n        }\n   \
    \     if chars.len() > max.1 {\n            max = (word, chars.len());\n     \
    \   }\n    }\n    max.0", '    unimplemented!()', "    let mut max_word = words[0].clone();\n\
    \    let mut max_set_size = unique_chars(&max_word).len();\n    for i in 1..words.len()\
    \ {\n        let set_size = unique_chars(&words[i]).len();\n        if set_size\
    \ > max_set_size {\n            max_set_size = set_size;\n            max_word\
    \ = words[i].clone();\n        }\n    }\n    max_word", "    let mut max_word\
    \ = String::new();\n    let mut max_unique_chars = 0;\n    for word in words {\n\
    \        let unique_chars = unique_chars(&word);\n        if unique_chars > max_unique_chars\
    \ {\n            max_unique_chars = unique_chars;\n            max_word = word;\n\
    \        } else if unique_chars == max_unique_chars && word < max_word {\n   \
    \         max_word = word;\n        }\n    }\n    max_word", "    let mut res:\
    \ String = String::from(\"\");\n    let mut max: usize = 0;\n    for word in words\
    \ {\n        let len = set(word.clone()).len();\n        if len > max {\n    \
    \        max = len;\n            res = word;\n        }\n    }\n    res", "  \
    \  let mut max_unique = 0;\n    let mut unique_index = 0;\n    for (index, word)\
    \ in words.iter().enumerate() {\n        let mut letters = HashSet::new();\n \
    \       for letter in word.chars() {\n            letters.insert(letter);\n  \
    \      }\n        if letters.len() > max_unique {\n            max_unique = letters.len();\n\
    \            unique_index = index;\n        }\n    }\n    words[unique_index].clone()",
  "    let mut max_count = 0;\n    let mut max_word = \"\".to_string();\n    for word\
    \ in words {\n        let mut map = HashMap::new();\n        for c in word.chars()\
    \ {\n            if map.contains_key(&c) {\n                let n = map.get_mut(&c).unwrap();\n\
    \                *n += 1;\n            } else {\n                map.insert(c,\
    \ 1);\n            }\n        }\n        let count = map.len();\n        if count\
    \ > max_count {\n            max_count = count;\n            max_word = word;\n\
    \        } else if count == max_count && word < max_word {\n            max_word\
    \ = word;\n        }\n    }\n    max_word", "    let mut len = 0;\n    let mut\
    \ max = String::new();\n    for word in words {\n        let curr_len = word.len();\n\
    \        if curr_len > len {\n            len = curr_len;\n            max = word;\n\
    \        }\n    }\n    max", "    // TODO\n    unimplemented!()", '    unimplemented!();',
  '    words.iter().max_by_key(|word| word.chars().unique().count()).unwrap().to_string()']
stop_tokens:
- "\n}"
