name: HumanEval_141_file_name_check
language: rs
results:
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    if file_name.matches('.').count()\
    \ != 1 {\n        return String::from(\"No\");\n    }\n    let file_name_split:\
    \ Vec<&str> = file_name.split('.').collect();\n    if file_name_split[0].is_empty()\
    \ || !file_name_split[0].chars().next().unwrap().is_alphabetic() {\n        return\
    \ String::from(\"No\");\n    }\n    match file_name_split[1] {\n        \"txt\"\
    \ | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _ => String::from(\"\
    No\"),\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    // Take care of the\
    \ following case: when the input is an empty string,\n    // the file name is\
    \ valid.\n    if file_name.is_empty() {\n        return String::from(\"Yes\");\n\
    \    }\n\n    // Check if there are more than three digits in the file name.\n\
    \    if file_name.matches(char::is_numeric).count() > 3 {\n        return String::from(\"\
    No\");\n    }\n\n    // Check if the file's name contains exactly one dot '.'\n\
    \    let mut num_of_dots = 0;\n    for ch in file_name.chars() {\n        if ch\
    \ == '.' {\n            num_of_dots += 1;\n        }\n    }\n    if num_of_dots\
    \ != 1 {\n        return String::from(\"No\");\n    }\n\n    // Check if the substring\
    \ before the dot start with a latin letter.\n    let sub_str_before_dot: Vec<char>\
    \ = file_name.chars().take_while(|ch| *ch != '.').collect();\n    if !sub_str_before_dot.is_empty()\
    \ && sub_str_before_dot[0].is_ascii_alphabetic() {\n        // Check if the substring\
    \ after the dot is one of the following:\n        // ['txt', 'exe', 'dll']\n \
    \       let sub_str_after_dot: Vec<char> = file_name.chars().skip_while(|ch| *ch\
    \ != '.').collect();\n        if sub_str_after_dot.len() > 1 && (sub_str_after_dot[1]\
    \ == 't' || sub_str_after_dot[1] == 'e' || sub_str_after_dot[1] == 'd') {\n  \
    \          return String::from(\"Yes\");\n        }\n    }\n\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp80t6uks6.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let file_name_chars:\
    \ Vec<char> = file_name.chars().collect();\n    let mut has_dot = false;\n   \
    \ let mut name_char_count = 0;\n    let mut digit_count = 0;\n    let mut last_dot_index\
    \ = 0;\n    for (i, c) in file_name_chars.iter().enumerate() {\n        match\
    \ c {\n            '.' => {\n                has_dot = true;\n               \
    \ last_dot_index = i;\n            },\n            _ => {},\n        }\n     \
    \   if c.is_ascii_digit() {\n            digit_count += 1;\n        }\n      \
    \  if c.is_ascii_alphabetic() {\n            name_char_count += 1;\n        }\n\
    \    }\n    if !has_dot ||\n        digit_count > 3 ||\n        name_char_count\
    \ == 0 ||\n        file_name_chars[last_dot_index + 1..].len() != 3 {\n      \
    \  return String::from(\"No\");\n    }\n    let file_type: Vec<char> = file_name_chars[last_dot_index\
    \ + 1..].to_vec();\n    let file_type_str: String = file_type.into_iter().collect();\n\
    \    match file_type_str.as_str() {\n        \"txt\" | \"exe\" | \"dll\" => return\
    \ String::from(\"Yes\"),\n        _ => return String::from(\"No\"),\n    }\n}\n\
    \nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpp4ubviiq.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let patterns = vec![\n\
    \        Regex::new(r\"^[a-zA-Z]+[\\w]*\\.[a-zA-Z]+$\").unwrap(),\n        Regex::new(r\"\
    ^[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\w]*\\.[a-zA-Z]+$\").unwrap(),\n        Regex::new(r\"\
    ^[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\w]*\\.[a-zA-Z]+$\").unwrap(),\n\
    \    ];\n    if patterns.iter().any(|pattern| pattern.is_match(&file_name)) {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp0ao32714.rs:17:9\n   |\n17 |         Regex::new(r\"^[a-zA-Z]+[\\w]*\\\
    .[a-zA-Z]+$\").unwrap(),\n   |         ^^^^^ use of undeclared type `Regex`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Regex`\n  --> /tmp/tmp0ao32714.rs:18:9\n\
    \   |\n18 |         Regex::new(r\"^[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\w]*\\.[a-zA-Z]+$\"\
    ).unwrap(),\n   |         ^^^^^ use of undeclared type `Regex`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Regex`\n  --> /tmp/tmp0ao32714.rs:19:9\n\
    \   |\n19 |         Regex::new(r\"^[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\w]*\\.[a-zA-Z]+[\\\
    w]*\\.[a-zA-Z]+$\").unwrap(),\n   |         ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkf0__00f.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    lazy_static! {\n   \
    \     static ref VALID_SUFFIXES: HashSet<&'static str> = {\n            let mut\
    \ suffixes = HashSet::new();\n            suffixes.insert(\"txt\");\n        \
    \    suffixes.insert(\"exe\");\n            suffixes.insert(\"dll\");\n      \
    \      suffixes\n        };\n    }\n\n    // As per the spec, it's guaranteed\
    \ that the file name contains exactly one dot '.'.\n    let dot_index = file_name.find('.').unwrap();\n\
    \    let pre_dot = &file_name[..dot_index];\n    let post_dot = &file_name[dot_index\
    \ + 1..];\n\n    // Check if the prefix is empty.\n    if pre_dot.is_empty() {\n\
    \        return String::from(\"No\");\n    }\n\n    // Check if the prefix contains\
    \ any digits.\n    if !pre_dot.chars().all(|ch| !ch.is_digit(10)) {\n        return\
    \ String::from(\"No\");\n    }\n\n    // Check if the prefix starts with a letter\
    \ in the latin alphabet.\n    if !pre_dot.chars().next().unwrap().is_ascii_alphabetic()\
    \ {\n        return String::from(\"No\");\n    }\n\n    // Check if the suffix\
    \ is valid.\n    if !VALID_SUFFIXES.contains(post_dot) {\n        return String::from(\"\
    No\");\n    }\n\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `lazy_static` in this scope\n  --> /tmp/tmpfib47mka.rs:16:5\n\
    \   |\n16 |     lazy_static! {\n   |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `VALID_SUFFIXES` in this scope\n  --> /tmp/tmpfib47mka.rs:47:9\n   |\n\
    47 |     if !VALID_SUFFIXES.contains(post_dot) {\n   |         ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpd2apat_9.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let mut digits_found\
    \ = 0;\n    let mut dot_found = false;\n    let mut valid_extensions = vec![\"\
    txt\", \"exe\", \"dll\"];\n    for c in file_name.chars() {\n        match c {\n\
    \            '0'...'9' => digits_found += 1,\n            '.' => dot_found = true,\n\
    \            _ => (),\n        }\n    }\n    if digits_found > 3 || !dot_found\
    \ {\n        return String::from(\"No\");\n    }\n    let parts: Vec<&str> = file_name.split('.').collect();\n\
    \    if parts.len() != 2 {\n        return String::from(\"No\");\n    }\n    if\
    \ parts[0].len() == 0 || !(parts[0].chars().next().unwrap().is_alphabetic()) {\n\
    \        return String::from(\"No\");\n    }\n    if valid_extensions.iter().find(|&s|\
    \ s == parts[1]).is_none() {\n        return String::from(\"No\");\n    }\n  \
    \  String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmp6lva67qf.rs:21:16\n\
    \   |\n21 |             '0'...'9' => digits_found += 1,\n   |                ^^^\
    \ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp6lva67qf.rs:36:44\n\
    \   |\n36 |     if valid_extensions.iter().find(|&s| s == parts[1]).is_none()\
    \ {\n   |                                            ^^ no implementation for\
    \ `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return String::from(\"No\");\n    }\n    let mut dot_idx = 0;\n\
    \    for (idx, ch) in file_name.chars().enumerate() {\n        if ch == '.' {\n\
    \            dot_idx = idx;\n            break;\n        }\n    }\n    let mut\
    \ after_dot = file_name[dot_idx + 1..].to_string();\n    if file_name.matches('.').count()\
    \ != 1 || after_dot.len() > 3 || dot_idx == 0 {\n        return String::from(\"\
    No\");\n    }\n    after_dot = after_dot.chars().take(3).collect();\n    if !((after_dot\
    \ == \"txt\") || (after_dot == \"exe\") || (after_dot == \"dll\")) {\n       \
    \ return String::from(\"No\");\n    }\n    let mut before_dot = file_name[..dot_idx].to_string();\n\
    \    before_dot = before_dot.chars().take(1).collect();\n    if !((before_dot\
    \ >= \"a\" && before_dot <= \"z\") || (before_dot >= \"A\" && before_dot <= \"\
    Z\")) {\n        return String::from(\"No\");\n    }\n    return String::from(\"\
    Yes\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm43kkgbx.rs:36:25\n   |\n\
    36 |     if !((before_dot >= \"a\" && before_dot <= \"z\") || (before_dot >= \"\
    A\" && before_dot <= \"Z\")) {\n   |                         ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                         |\n   |  \
    \                       expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm43kkgbx.rs:36:46\n   |\n36 |     if !((before_dot\
    \ >= \"a\" && before_dot <= \"z\") || (before_dot >= \"A\" && before_dot <= \"\
    Z\")) {\n   |                                              ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \            |\n   |                                              expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm43kkgbx.rs:36:69\n\
    \   |\n36 |     if !((before_dot >= \"a\" && before_dot <= \"z\") || (before_dot\
    \ >= \"A\" && before_dot <= \"Z\")) {\n   |                                  \
    \                                   ^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                                                       \
    \              |\n   |                                                       \
    \              expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm43kkgbx.rs:36:90\n   |\n36 |     if !((before_dot >= \"\
    a\" && before_dot <= \"z\") || (before_dot >= \"A\" && before_dot <= \"Z\")) {\n\
    \   |                                                                        \
    \                  ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                                                        \
    \                  |\n   |                                                   \
    \                                       expected struct `String`, found `&str`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let mut digits_count\
    \ = 0;\n    let mut dot_count = 0;\n    let mut file_type_check = false;\n   \
    \ let file_type_check_list = [\"txt\", \"exe\", \"dll\"];\n    let mut char_iter\
    \ = file_name.chars();\n    let mut char_count = 0;\n    let mut alpha_digit_count\
    \ = 0;\n    let mut first_dot_pos = 0;\n    let mut second_dot_pos = 0;\n    let\
    \ mut alpha_valid = false;\n    for c in char_iter {\n        if !file_type_check\
    \ {\n            if c.is_ascii_digit() {\n                if char_count == 0 {\n\
    \                    return String::from(\"No\");\n                }\n       \
    \         digits_count += 1;\n                if digits_count > 3 {\n        \
    \            return String::from(\"No\");\n                }\n            } else\
    \ if c == '.' {\n                dot_count += 1;\n                if dot_count\
    \ == 1 {\n                    first_dot_pos = char_count;\n                } else\
    \ if dot_count == 2 {\n                    second_dot_pos = char_count;\n    \
    \            } else {\n                    return String::from(\"No\");\n    \
    \            }\n            } else if c.is_ascii_alphabetic() {\n            \
    \    alpha_digit_count += 1;\n                if char_count == 0 {\n         \
    \           alpha_valid = true;\n                }\n            } else {\n   \
    \             return String::from(\"No\");\n            }\n            if dot_count\
    \ == 2 {\n                if second_dot_pos - first_dot_pos == 4 {\n         \
    \           let mut file_type_check_str = String::new();\n                   \
    \ file_type_check_str.push(file_name.chars().nth(first_dot_pos + 1).unwrap());\n\
    \                    file_type_check_str.push(file_name.chars().nth(first_dot_pos\
    \ + 2).unwrap());\n                    file_type_check_str.push(file_name.chars().nth(first_dot_pos\
    \ + 3).unwrap());\n                    for i in file_type_check_list.iter() {\n\
    \                        if file_\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuxv4lun3.rs:91:3\n\
    \   |\n15 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n26 |     for\
    \ c in char_iter {\n   |                        - unclosed delimiter\n27 |   \
    \      if !file_type_check {\n   |                             - unclosed delimiter\n\
    ...\n53 |             if dot_count == 2 {\n   |                              \
    \ - unclosed delimiter\n54 |                 if second_dot_pos - first_dot_pos\
    \ == 4 {\n   |                                                        - unclosed\
    \ delimiter\n...\n59 |                     for i in file_type_check_list.iter()\
    \ {\n   |                                                          - this delimiter\
    \ might not be properly closed...\n60 |                         if file_\n61 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n91 |\
    \ }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpuxv4lun3.rs:61:1\n\
    \   |\n60 |                         if file_\n   |                         --\
    \ this `if` expression has a condition, but no block\n61 | }\n   | ^ expected\
    \ `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuxv4lun3.rs:26:5\n   |\n\
    15 |   fn file_name_check(file_name: String) -> String {\n   |               \
    \                             ------ expected `String` because of return type\n\
    ...\n26 | /     for c in char_iter {\n27 | |         if !file_type_check {\n28\
    \ | |             if c.is_ascii_digit() {\n29 | |                 if char_count\
    \ == 0 {\n...  |\n90 | |     assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n91 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    if file_name.len() <\
    \ 3 {\n        return String::from(\"No\");\n    }\n    let file_name_chars: Vec<char>\
    \ = file_name.chars().collect();\n    let mut count_digits = 0;\n    let mut dot_pos\
    \ = 0;\n    for (i, char) in file_name_chars.iter().enumerate() {\n        if\
    \ char.is_digit(10) {\n            count_digits += 1;\n        }\n        if *char\
    \ == '.' {\n            dot_pos = i;\n        }\n    }\n    if count_digits >\
    \ 3 {\n        return String::from(\"No\");\n    }\n    if dot_pos == 0 || dot_pos\
    \ == file_name.len() - 1 {\n        return String::from(\"No\");\n    }\n    let\
    \ extension = file_name_chars[dot_pos + 1..].iter().collect::<String>();\n   \
    \ if extension != \"txt\" && extension != \"exe\" && extension != \"dll\" {\n\
    \        return String::from(\"No\");\n    }\n    if file_name_chars[..dot_pos].iter().all(|c|\
    \ c.is_alphabetic()) {\n        return String::from(\"Yes\");\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpuyr7pr93.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let mut digits_counter\
    \ = 0;\n    let mut dot_counter = 0;\n    let mut char_counter = 0;\n    let mut\
    \ file_start_with_letter = false;\n    let mut file_end_with_txt_exe_dll = false;\n\
    \    let mut char_iter = file_name.chars();\n    let mut char_before_dot = Vec::new();\n\
    \    let mut char_after_dot = Vec::new();\n    for c in char_iter {\n        char_counter\
    \ += 1;\n        if c.is_digit(10) {\n            digits_counter += 1;\n     \
    \   } else if c == '.' {\n            dot_counter += 1;\n        } else if dot_counter\
    \ == 0 {\n            char_before_dot.push(c);\n        } else if dot_counter\
    \ == 1 {\n            char_after_dot.push(c);\n        }\n    }\n    let after_dot_str\
    \ = char_after_dot.iter().collect::<String>();\n    if char_counter <= 3 {\n \
    \       file_start_with_letter = true;\n    } else if char_before_dot[0].is_ascii_alphabetic()\
    \ {\n        file_start_with_letter = true;\n    }\n    if after_dot_str == \"\
    txt\" || after_dot_str == \"exe\" || after_dot_str == \"dll\" {\n        file_end_with_txt_exe_dll\
    \ = true;\n    }\n    if digits_counter <= 3 && dot_counter == 1 && file_start_with_letter\
    \ && file_end_with_txt_exe_dll {\n        return String::from(\"Yes\");\n    }\
    \ else {\n        return String::from(\"No\");\n    }\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpb0kqchxz.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let mut counter = 0;\n\
    \    let mut dot_location = 0;\n    let mut is_invalid = false;\n    for (i, ch)\
    \ in file_name.chars().enumerate() {\n        if (ch as u8) >= 0x30 && (ch as\
    \ u8) <= 0x39 {\n            counter += 1;\n        } else if ch == '.' {\n  \
    \          dot_location = i;\n        } else if i == 0 && !(ch >= 'a' && ch <=\
    \ 'z' || ch >= 'A' && ch <= 'Z') {\n            is_invalid = true;\n        }\n\
    \    }\n    if counter > 3 || dot_location == 0 || is_invalid {\n        return\
    \ String::from(\"No\");\n    }\n    let mut valid_extensions = vec![\"txt\", \"\
    exe\", \"dll\"];\n    valid_extensions.sort();\n    let actual_extension = &file_name[dot_location\
    \ + 1..];\n    if valid_extensions.binary_search(&actual_extension).is_err() {\n\
    \        return String::from(\"No\");\n    }\n    String::from(\"Yes\")\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpau0zblrx.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let vec: Vec<&str> =\
    \ file_name.split(\".\").collect();\n    if vec.len() > 2 {\n        return String::from(\"\
    No\");\n    }\n    let first_part = vec[0];\n    let last_part = vec[1];\n   \
    \ if first_part.len() > 255 {\n        return String::from(\"No\");\n    }\n \
    \   if last_part != \"txt\" && last_part != \"exe\" && last_part != \"dll\" {\n\
    \        return String::from(\"No\");\n    }\n    let mut is_digit = false;\n\
    \    let mut count = 0;\n    for i in first_part.chars() {\n        if i.is_digit(10)\
    \ {\n            is_digit = true;\n            count += 1;\n        }\n    }\n\
    \    if count > 3 {\n        return String::from(\"No\");\n    }\n    if is_digit\
    \ {\n        return String::from(\"No\");\n    }\n    String::from(\"Yes\")\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp5yfdq541.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let mut digits_count\
    \ = 0;\n    let mut dot_cnt = 0;\n    let mut ext_found = false;\n    let mut\
    \ upper_found = false;\n    let mut valid_ext = false;\n    let mut valid_name\
    \ = false;\n    let mut name_found = false;\n    for c in file_name.chars() {\n\
    \        if c.is_digit(10) {\n            digits_count += 1;\n        }\n    \
    \    if c == '.' {\n            dot_cnt += 1;\n        }\n        if c == '.'\
    \ && !ext_found {\n            ext_found = true;\n        }\n        if c == '.'\
    \ && ext_found {\n            valid_ext = false;\n        }\n        if ext_found\
    \ && (c == 'e' || c == 'x' || c == 'd') {\n            valid_ext = true;\n   \
    \     }\n        if c.is_ascii_uppercase() {\n            upper_found = true;\n\
    \        }\n        if c.is_ascii_lowercase() {\n            name_found = true;\n\
    \        }\n    }\n    if digits_count <= 3 && dot_cnt == 1 && valid_ext && name_found\
    \ && !upper_found {\n        valid_name = true;\n    }\n    if valid_name {\n\
    \        return String::from(\"Yes\");\n    }\n    return String::from(\"No\"\
    );\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpjnskntv6.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    String::from(\"Yes\"\
    )\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmplcxbs3on.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    if file_name.len() <\
    \ 4 {\n        return String::from(\"No\");\n    }\n    let mut count = 0;\n \
    \   let mut dot_count = 0;\n    let mut valid_after_dot = false;\n    for i in\
    \ 0..file_name.len() {\n        let c = file_name.chars().nth(i).unwrap();\n \
    \       if c.is_digit(10) {\n            count += 1;\n        }\n        if c\
    \ == '.' {\n            dot_count += 1;\n        }\n        if dot_count == 1\
    \ {\n            if c == 't' || c == 'e' || c == 'd' {\n                valid_after_dot\
    \ = true;\n            }\n        }\n    }\n    if count > 3 || dot_count != 1\
    \ || !valid_after_dot {\n        return String::from(\"No\");\n    } else {\n\
    \        return String::from(\"Yes\");\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmprympy6fo.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let (first_part, last_part)\
    \ = get_parts(file_name);\n    if !is_first_part_valid(first_part) {\n       \
    \ return String::from(\"No\");\n    }\n    if !is_last_part_valid(last_part) {\n\
    \        return String::from(\"No\");\n    }\n    String::from(\"Yes\")\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_parts` in this scope\n  --> /tmp/tmpl3eq7ibg.rs:16:35\n\
    \   |\n16 |     let (first_part, last_part) = get_parts(file_name);\n   |    \
    \                               ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_first_part_valid` in this scope\n  --> /tmp/tmpl3eq7ibg.rs:17:9\n\
    \   |\n17 |     if !is_first_part_valid(first_part) {\n   |         ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_last_part_valid`\
    \ in this scope\n  --> /tmp/tmpl3eq7ibg.rs:20:9\n   |\n20 |     if !is_last_part_valid(last_part)\
    \ {\n   |         ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let re = Regex::new(r\"\
    ^[a-zA-Z]{1}[a-zA-Z0-9]{0,2}\\.(txt|exe|dll)$\").unwrap();\n    if re.is_match(&file_name)\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpuwf027tf.rs:16:14\n   |\n16 |     let re = Regex::new(r\"^[a-zA-Z]{1}[a-zA-Z0-9]{0,2}\\\
    .(txt|exe|dll)$\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>>\
    \ file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n\
    /// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\"\
    )\nfn file_name_check(file_name: String) -> String {\n    let mut is_valid: bool\
    \ = true;\n    let mut has_dot: bool = false;\n    let mut has_digit: bool = false;\n\
    \    let mut has_non_digit: bool = false;\n    let mut has_letter: bool = false;\n\
    \    let mut has_txt: bool = false;\n    let mut has_exe: bool = false;\n    let\
    \ mut has_dll: bool = false;\n    let mut dot_index: usize = 0;\n    let mut dot_count:\
    \ usize = 0;\n    let mut extension_index: usize = 0;\n    let mut digit_count:\
    \ usize = 0;\n    let mut extension_count: usize = 0;\n    let mut letter_count:\
    \ usize = 0;\n    for (i, c) in file_name.chars().enumerate() {\n        if has_digit\
    \ && !c.is_digit(10) {\n            has_non_digit = true;\n        }\n       \
    \ if c.is_digit(10) {\n            has_digit = true;\n            digit_count\
    \ += 1;\n        }\n        if !has_dot && c == '.' {\n            has_dot = true;\n\
    \            dot_index = i;\n            dot_count += 1;\n        }\n        if\
    \ !has_letter && c.is_alphabetic() {\n            has_letter = true;\n       \
    \     letter_count += 1;\n        }\n        if has_dot && i > dot_index && c.is_alphabetic()\
    \ {\n            extension_index = i;\n            extension_count += 1;\n   \
    \     }\n        if extension_count == 3 && c == 't' {\n            has_txt =\
    \ true;\n        }\n        if extension_count == 3 && c == 'e' {\n          \
    \  has_exe = true;\n        }\n        if extension_count == 3 && c == 'd' {\n\
    \            has_dll = true;\n        }\n    }\n    is_valid = has_dot && !has_digit\
    \ && has_non_digit && has_letter && (has_txt || has_exe || has_dll) && dot_count\
    \ == 1 && extension_count == 3 && letter_count >= 1 && digit\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `digit` in this scope\n  --> /tmp/tmpkc7cbqoi.rs:61:170\n\
    \   |\n61 | ...= 1 && extension_count == 3 && letter_count >= 1 && digit\n   |\
    \                                                        ^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkc7cbqoi.rs:61:5\n  \
    \ |\n15 | fn file_name_check(file_name: String) -> String {\n   |            \
    \                              ------ expected `String` because of return type\n\
    ...\n61 |     is_valid = has_dot && !has_digit && has_non_digit && has_letter\
    \ && (has_txt || has_exe || has_dll) && dot_count == 1 && extension_count == 3\
    \ && letter_count >= 1 && digit\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
