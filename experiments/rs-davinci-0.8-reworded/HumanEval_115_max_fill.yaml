name: HumanEval_115_max_fill
language: rs
prompt: "/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
  \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
  \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
  \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
  /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <=\
  \ grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\n\
  fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n   \
  \ assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
  \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1,\
  \ 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
completions: ["    let n_rows = grid.len();\n    let n_cols = grid[0].len();\n   \
    \ let mut fill_count = 0;\n    let mut max_height = 0;\n    let mut tallest_col\
    \ = 0;\n    let mut height_map = vec![0; n_cols];\n    let mut is_row_empty =\
    \ vec![true; n_rows];\n    for i in 0..n_rows {\n        for j in 0..n_cols {\n\
    \            if grid[i][j] == 1 {\n                height_map[j] += 1;\n     \
    \           if height_map[j] > max_height {\n                    max_height =\
    \ height_map[j];\n                    tallest_col = j;\n                }\n  \
    \              is_row_empty[i] = false;\n            }\n        }\n    }\n   \
    \ let mut i = 0;\n    let mut j = tallest_col;\n    while i < n_rows {\n     \
    \   if is_row_empty[i] {\n            i += 1;\n            continue;\n       \
    \ }\n        let bucket_fill = std::cmp::min(capacity, max_height - height_map[j]);\n\
    \        height_map[j] += bucket_fill;\n        fill_count += bucket_fill;\n \
    \       if bucket_fill == capacity {\n            i += 1;\n            continue;\n\
    \        }\n        j += 1;\n        if j == n_cols {\n            j = 0;\n  \
    \      }\n    }\n    fill_count", "    let mut max = 0;\n    let mut result =\
    \ 0;\n    let num_row = grid.len();\n    for i in 0..num_row {\n        for j\
    \ in 0..grid[i].len() {\n            max = grid[i][j].max(max);\n        }\n \
    \       result += max;\n        max = 0;\n    }\n    result * capacity", "   \
    \ let height = grid.len();\n    let width = grid[0].len();\n    let mut new_grid\
    \ = vec![vec![0; width]; height];\n    let mut moves = 0;\n    // row loop\n \
    \   'row: for row in 0..height {\n        // First check if the entire row can\
    \ be filled with a single move\n        let mut can_fill = true;\n        for\
    \ water in grid[row].iter() {\n            if *water == 0 {\n                can_fill\
    \ = false;\n                break;\n            }\n        }\n        if can_fill\
    \ {\n            moves += 1;\n            for col in 0..width {\n            \
    \    new_grid[row][col] = capacity;\n            }\n            continue 'row;\n\
    \        }\n        // column loop\n        for col in 0..width {\n          \
    \  if grid[row][col] == 0 {\n                continue;\n            }\n      \
    \      let mut water_to_fill = grid[row][col];\n            let mut remaining_water\
    \ = capacity - new_grid[row][col];\n            let mut filled = 0;\n        \
    \    while remaining_water > 0 && water_to_fill > 0 {\n                if remaining_water\
    \ >= water_to_fill {\n                    filled += water_to_fill;\n         \
    \           water_to_fill = 0;\n                } else {\n                   \
    \ filled += remaining_water;\n                    water_to_fill -= remaining_water;\n\
    \                }\n                remaining_water = capacity - filled;\n   \
    \         }\n            new_grid[row][col] += filled;\n            if water_to_fill\
    \ > 0 {\n                moves += 1;\n                let new_remaining_water\
    \ = capacity - new_grid[row][col];\n                if new_remaining_water >=\
    \ water_to_fill {\n                    new_grid[row][col] += water_to_fill;\n\
    \                } else {\n                    new_grid[row][col] += new_remaining_water;\n\
    \                }\n            }\n        }\n    }\n    moves", '    unimplemented!();',
  "    if grid.len() == 0 {\n        return 0;\n    }\n    let mut queue = VecDeque::new();\n\
    \    let mut visited = vec![vec![false; grid[0].len()]; grid.len()];\n    let\
    \ mut result = 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[0].len()\
    \ {\n            if grid[i][j] == 1 {\n                queue.push_back((i, j));\n\
    \                visited[i][j] = true;\n            }\n        }\n    }\n    let\
    \ mut row_dirs = vec![-1, 0, 1, 0];\n    let mut col_dirs = vec![0, 1, 0, -1];\n\
    \    while !queue.is_empty() {\n        let mut _size = queue.len();\n       \
    \ while _size > 0 {\n            let curr = queue.pop_front().unwrap();\n    \
    \        let (row, col) = curr;\n            for k in 0..4 {\n               \
    \ let new_row = row + row_dirs[k];\n                let new_col = col + col_dirs[k];\n\
    \                if new_row >= 0 && new_row < grid.len() && new_col >= 0 && new_col\
    \ < grid[0].len() && !visited[new_row][new_col] {\n                    visited[new_row][new_col]\
    \ = true;\n                    queue.push_back((new_row, new_col));\n        \
    \        }\n            }\n            _size -= 1;\n        }\n        result\
    \ += 1;\n    }\n    (result-1) * capacity", "    let mut count = 0;\n    // let\
    \ mut grid = grid;\n    let height = grid.len();\n    let width = grid[0].len();\n\
    \    let mut visited = vec![vec![false; width]; height];\n    let offsets = vec![\n\
    \        vec![-1, 0],\n        vec![1, 0],\n        vec![0, -1],\n        vec![0,\
    \ 1],\n    ];\n    for i in 0..height {\n        for j in 0..width {\n       \
    \     if !visited[i][j] && grid[i][j] == 1 {\n                visited[i][j] =\
    \ true;\n                let mut queue = vec![vec![i, j]];\n                let\
    \ mut max_depth = 0;\n                while !queue.is_empty() {\n            \
    \        let current = queue.pop().unwrap();\n                    let current_depth\
    \ = grid[current[0]][current[1]];\n                    max_depth = max_depth.max(current_depth);\n\
    \                    for offset in offsets.iter() {\n                        let\
    \ new_i = current[0] as isize + offset[0];\n                        let new_j\
    \ = current[1] as isize + offset[1];\n                        if 0 <= new_i &&\
    \ new_i < height as isize\n                            && 0 <= new_j && new_j\
    \ < width as isize\n                            && !visited[new_i as usize][new_j\
    \ as usize]\n                            && grid[new_i as usize][new_j as usize]\
    \ == 1\n                        {\n                            visited[new_i as\
    \ usize][new_j as usize] = true;\n                            queue.push(vec![new_i\
    \ as usize, new_j as usize]);\n                        }\n                   \
    \ }\n                }\n                count += max_depth / capacity;\n     \
    \           if max_depth % capacity != 0 {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    count", "    let mut\
    \ count = 0;\n    // the height of the water in each well\n    let mut water =\
    \ vec![0; grid[0].len()];\n    // the number of 1's in the current row\n    let\
    \ mut ones = 0;\n    for row in grid {\n        for (col, &item) in row.iter().enumerate()\
    \ {\n            // if there is a 1, keep track of it\n            if item ==\
    \ 1 {\n                ones += 1;\n            }\n            // otherwise fill\
    \ the well with water from the bucket\n            else {\n                //\
    \ calculate the amount of water in the bucket as the \n                // capacity\
    \ minus the height of the water in the well\n                let fill = capacity\
    \ - water[col];\n                // if there is water in the bucket\n        \
    \        if fill > 0 {\n                    // add the water to the well\n   \
    \                 water[col] += fill;\n                    // add the amount of\
    \ water added to the total count\n                    count += fill;\n       \
    \         }\n            }\n        }\n        // if there are 1's in the row,\
    \ empty the wells\n        if ones > 0 {\n            // empty the wells by replacing\
    \ the height of the water with 0\n            water = vec![0; grid[0].len()];\n\
    \            // add 1 to the total count as we need to lower the bucket\n    \
    \        count += 1;\n        }\n        // reset the count of 1's in the row\n\
    \        ones = 0;\n    }\n    count", "    let (m, n) = (grid.len(), grid[0].len());\n\
    \    let mut sum = 0;\n    for i in 0..m {\n        let idx = grid[i].iter().rposition(|&x|\
    \ x == 1).unwrap();\n        let x = idx as isize;\n        let y = m as isize\
    \ - i as isize - 1;\n        sum += x * y;\n    }\n    sum / capacity", "    let\
    \ row_len = grid.len();\n    let col_len = grid[0].len();\n    let mut res = 0;\n\
    \    for j in 0..col_len {\n        let mut total = 0;\n        for i in 0..row_len\
    \ {\n            if grid[i][j] == 1 {\n                total += 1;\n         \
    \   }\n        }\n        let mut added = 0;\n        for i in 0..row_len {\n\
    \            if grid[i][j] == 1 {\n                total -= 1;\n             \
    \   if total > 0 {\n                    if capacity - added >= total {\n     \
    \                   added += total;\n                        res += 1;\n     \
    \               } else {\n                        res += 1;\n                \
    \        added = capacity;\n                    }\n                }\n       \
    \     }\n        }\n    }\n    res", "    if grid.is_empty() {\n        return\
    \ 0;\n    }\n    let mut rows = Vec::new();\n    for row in grid {\n        let\
    \ mut wells = Vec::new();\n        for c in row {\n            wells.push(Well\
    \ { full: c == 1, fill: 0 });\n        }\n        rows.push(WellRow { wells: wells\
    \ });\n    }\n    let mut count = 0;\n    loop {\n        let mut water_remaining\
    \ = false;\n        let mut water_overflow = false;\n        for well_row in &mut\
    \ rows {\n            for well in &mut well_row.wells {\n                if well.full\
    \ {\n                    well.fill += 1;\n                    if well.fill > capacity\
    \ {\n                        water_overflow = true;\n                    }\n \
    \                   water_remaining = true;\n                }\n            }\n\
    \        }\n        if !water_remaining {\n            break;\n        }\n   \
    \     if water_overflow {\n            count += 1;\n            let mut water_remaining\
    \ = false;\n            for well_row in &mut rows {\n                for well\
    \ in &mut well_row.wells {\n                    if well.fill > capacity {\n  \
    \                      well.fill -= capacity;\n                        water_remaining\
    \ = true;\n                    }\n                }\n            }\n         \
    \   if !water_remaining {\n                break;\n            }\n        }\n\
    \    }\n    count", "    let mut vector = Vec::with_capacity(grid.len());\n  \
    \  for i in 0..grid.len() {\n        let sum = grid[i].iter().sum();\n       \
    \ vector.push(sum);\n    }\n    let sum = vector.iter().sum();\n    if sum < capacity\
    \ {\n        0\n    } else {\n        (sum as f64 / capacity as f64).ceil() as\
    \ isize\n    }", "    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut max_fill = 0;\n    for row in 0..rows {\n        for col in 0..cols\
    \ {\n            max_fill += fill_one(grid.clone(), capacity, row, col);\n   \
    \     }\n    }\n    max_fill", "    let mut min = isize::max_value();\n    let\
    \ mut count = 0;\n    let mut max_arr = Vec::new();\n    for row in grid {\n \
    \       let mut max = isize::min_value();\n        for col in row {\n        \
    \    if col > max {\n                max = col;\n            }\n        }\n  \
    \      max_arr.push(max);\n    }\n    for i in 0..max_arr.len() {\n        let\
    \ val = max_arr[i];\n        if val < min {\n            min = val;\n        }\n\
    \    }\n    for i in 0..max_arr.len() {\n        let val = max_arr[i];\n     \
    \   if val > min {\n            let diff = val - min;\n            if diff > capacity\
    \ {\n                let mut rem = diff % capacity;\n                count +=\
    \ (diff - rem) / capacity;\n                count += if rem > 0 { 1 } else { 0\
    \ };\n            } else {\n                count += 1;\n            }\n     \
    \   }\n    }\n    count", "    let mut count = 0;\n    let mut max_well = 0;\n\
    \    for row in grid {\n        for &col in row.iter() {\n            max_well\
    \ = max(max_well, col);\n        }\n    }\n    for _ in 0..max_well {\n      \
    \  for row in grid.iter() {\n            for &col in row.iter() {\n          \
    \      if col > 0 {\n                    count += 1;\n                }\n    \
    \        }\n        }\n        for row in grid.iter_mut() {\n            for col\
    \ in row.iter_mut() {\n                if *col > 0 {\n                    *col\
    \ -= 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut wells = grid.iter().map(|x| x.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut steps = 0;\n    while wells.iter().any(|x| *x > 0) {\n        let\
    \ max_val = wells.iter().max().unwrap();\n        for x in wells.iter_mut() {\n\
    \            if *x == *max_val {\n                *x -= capacity;\n          \
    \  }\n        }\n        steps += 1;\n    }\n    steps", "    let mut max_fill\
    \ = 0;\n    let mut total_fill = 0;\n    let mut fill_count = 0;\n    let height\
    \ = grid.len();\n    let width = grid[0].len();\n    let mut grid_iter = grid.iter();\n\
    \    while max_fill < height {\n        let mut row_iter = grid_iter.next().unwrap().iter();\n\
    \        while total_fill < capacity && row_iter.any(|n| *n == 1) {\n        \
    \    let mut col_iter = row_iter.take(capacity as usize);\n            let row_fill\
    \ = col_iter.fold(0, |acc, n| acc + n);\n            total_fill += row_fill;\n\
    \            fill_count += 1;\n        }\n        max_fill += 1;\n        total_fill\
    \ = 0;\n    }\n    fill_count", "    let mut count = 0;\n    let mut waters: Vec<usize>\
    \ = Vec::new();\n    for row in grid {\n        for item in row {\n          \
    \  if item == 1 {\n                waters.push(1);\n            } else {\n   \
    \             waters.push(0);\n            }\n        }\n    }\n    let row_length\
    \ = waters.len() / grid.len();\n    for row in 0..grid.len() {\n        for index\
    \ in 0..row_length {\n            if waters[row * row_length + index] == 1 {\n\
    \                count += 1;\n                for x in 0..capacity {\n       \
    \             if (index + x + 1) < row_length {\n                        waters[row\
    \ * row_length + index + x + 1] = 0;\n                    }\n                }\n\
    \            }\n        }\n    }\n    count", "    let mut answer = 0;\n    let\
    \ height = grid.len();\n    let width = grid[0].len();\n    let mut well = vec![vec![0;\
    \ width]; height];\n    for row in 0..height {\n        for col in 0..width {\n\
    \            if grid[row][col] == 1 {\n                well[row][col] = capacity;\n\
    \            }\n        }\n    }\n    let mut bucket = capacity;\n    while bucket\
    \ > 0 {\n        for row in 0..height {\n            for col in 0..width {\n \
    \               if bucket > 0 && well[row][col] > 0 {\n                    bucket\
    \ -= 1;\n                    well[row][col] -= 1;\n                }\n       \
    \     }\n        }\n        answer += 1;\n    }\n    return answer;", "    let\
    \ mut times = 0;\n    let mut n = 0;\n    while n < grid.len() {\n        let\
    \ max_wells = grid[n].iter().filter(|&&x| x == 1).count();\n        let mut i\
    \ = 0;\n        for well in grid[n].iter() {\n            if well == &1 {\n  \
    \              i += 1;\n            }\n            if i == max_wells {\n     \
    \           break;\n            }\n        }\n        if i > 0 {\n           \
    \ let wells_to_fill = grid[n].iter().take(i).filter(|&&x| x == 0).count();\n \
    \           times += wells_to_fill;\n            if n + 1 < grid.len() {\n   \
    \             for well in grid[n+1].iter_mut().take(i) {\n                   \
    \ if *well == 0 {\n                        *well = 1;\n                    }\n\
    \                }\n            }\n        }\n        n += 1;\n    }\n    times",
  "    let m = grid.len();\n    let n = grid[0].len();\n    let mut buckets = vec![0;\
    \ m];\n    let mut fill = 0;\n    for _ in 0..n {\n        for i in 0..m {\n \
    \           if grid[i][n] == 1 {\n                buckets[i] += 1;\n         \
    \   }\n        }\n        let capacity = *buckets.iter().min().unwrap();\n   \
    \     fill += capacity;\n        buckets = buckets.iter().map(|x| x - capacity).collect();\n\
    \    }\n    fill"]
stop_tokens:
- "\n}"
