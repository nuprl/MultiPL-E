name: HumanEval_83_starts_one_ends
language: rs
prompt: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) ->\
  \ isize {\n"
tests: "}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
  \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n \
  \   assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
completions: ["    if n == 1 {\n        return 2;\n    }\n    let x = 10isize.pow(n\
    \ as u32 - 1);\n    starts_one_ends(n - 1) + starts_one_ends(n - 2) * (x + x /\
    \ 10)", "    if n == 1 {\n        1\n    } else {\n        starts_one_ends(n -\
    \ 1) + 10 * starts_one_ends(n - 2)\n    }", "    if n <= 1 {\n        return 0;\n\
    \    }\n    let mut res = 0;\n    for i in 1..n {\n        res += starts_one_ends(i)\
    \ + 1;\n    }\n    res", "    let mut start = 1;\n    let mut end = 0;\n    for\
    \ _ in 0..n {\n        let temp = start;\n        start = start + end;\n     \
    \   end = temp;\n    }\n    start + end", "    // The number of starts with 1.\n\
    \    let n_starts_one = starts_one(n);\n    // The number of ends with 1.\n  \
    \  let n_ends_one = starts_one(n - 1);\n    n_starts_one + n_ends_one", "    if\
    \ n == 1 {\n        return 10;\n    }\n    if n == 2 {\n        return 55;\n \
    \   }\n    let mut a = 1;\n    let mut b = 1;\n    let mut c = 0;\n    for _ in\
    \ 0..n - 2 {\n        a = c + b;\n        c = b;\n        b = a;\n    }\n    (a\
    \ + b) * 10", "    // todo: implement, using starts_one_ends_digit\n    0", " \
    \   let mut high = 9;\n    let mut low = 1;\n    for _ in 1..n {\n        high\
    \ = high * 10 + 9;\n        low = low * 10;\n    }\n    high - low + 1", '    n
    - (n / 2)', "    let mut prev = 0;\n    let mut curr = 1;\n    for _ in 0..n {\n\
    \        let next = curr + prev;\n        prev = curr;\n        curr = next;\n\
    \    }\n    2 * curr", '    (2..n + 1).fold(0, |acc, x| acc + x * 10isize.pow(x
    - 1))', "    assert!(n > 0);\n    if n == 1 {\n        return 1;\n    }\n    isize::pow(10,\
    \ n - 1) + 9 * starts_one_ends(n - 1)", "    if n == 1 {\n        return 2;\n\
    \    }\n    let mut total = 0;\n    for i in 1..n {\n        total += starts_one_ends(i)\
    \ * 9;\n    }\n    return total + 9;", "    if n <= 0 {\n        return 0;\n \
    \   }\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return\
    \ 10;\n    }\n    let mut w = 1;\n    let mut count = 10;\n    for _ in 1..n {\n\
    \        count += 9 * 10i64.pow(w - 1) as isize;\n        w += 1;\n    }\n   \
    \ count", "    let mut i = 1;\n    let mut pow = 1;\n    let mut pre = 0;\n  \
    \  while i < n {\n        pre = pow;\n        pow *= 10;\n        i += 1;\n  \
    \  }\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return\
    \ 10;\n    }\n    pow - pre + 1 + starts_one_ends(n - 1)", "    match n {\n  \
    \      1 => 2,\n        2 => 3,\n        _ => starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2),\n    }", "    if n == 1 {\n        return 1;\n    }\n    let count = starts_one_ends(n\
    \ - 1);\n    let mut count = count * 9;\n    if n >= 2 {\n        count += starts_one_ends(n\
    \ - 2);\n    }\n    count", "    if n == 1 {\n        return 10;\n    }\n\n  \
    \  let mut result = 10 * starts_one_ends(n - 1);\n    if n > 2 {\n        let\
    \ zeros = (n - 2) * 9;\n        result += 9 * starts_one_ends(zeros);\n    }\n\
    \n    result", "    if n == 1 {\n        return 10;\n    }\n    let mut a = 1;\n\
    \    let mut b = 0;\n    let mut c = 0;\n    let mut d = 1;\n    for _ in 1..n\
    \ {\n        a = b;\n        b = c;\n        c = d;\n        d = 10 * b + a;\n\
    \    }\n    c + d", "    let limit = 10_isize.pow(n as u32) - 1;\n    let mut\
    \ prev = 1;\n    let mut curr = 1;\n    let mut next = 0;\n    let mut res = 0;\n\
    \    for i in 1..limit {\n        next = (prev + curr) % limit;\n        if next\
    \ == 1 {\n            res += 1;\n        }\n        prev = curr;\n        curr\
    \ = next;\n    }\n    res", "    let mut count = 0;\n    let mut i = 1;\n    while\
    \ i <= n {\n        count += starts_one_ends_helper(i);\n        i += 1;\n   \
    \ }\n    count", "    // For example, if n = 3, the result is\n    // 111 + 1110\
    \ + 111 + 111 + 111 = 5666.\n    let n = n as usize;\n    let mut array = vec![0;\
    \ n];\n    for i in 0..n {\n        let j = n - i - 1;\n        array[i] =\n \
    \           (array[i] + (if i == 0 { 1 } else { 0 }) + (if j == n - 1 { 1 } else\
    \ { 0})) % 10007;\n        if i > 0 {\n            array[i] = (array[i] + array[i\
    \ - 1]) % 10007;\n        }\n        if j < n - 1 {\n            array[i] = (array[i]\
    \ + array[i]) % 10007;\n        }\n    }\n    array[n - 1]", "    if n <= 1 {\n\
    \        return n;\n    }\n    (1..n + 1).map(|i| 10i64.pow(i - 1) as isize).sum()",
  "    let mut count = 0;\n    for i in 1..n {\n        count += pow(10, i) * 9 +\
    \ pow(10, n - i - 1);\n    }\n    count + 1", "    // If n is even, then the result\
    \ is zeros(n / 2) * 9 * 9.\n    // If n is odd, then the result is zeros((n -\
    \ 1) / 2) * 9 * 9 +\n    //    count_of_n_digits_start_or_end_with_one(n - 1).\n\
    \    if n == 1 {\n        return 10;\n    }\n    if n == 2 {\n        return 19;\n\
    \    }\n    if n == 3 {\n        return 28;\n    }\n    if n % 2 == 0 {\n    \
    \    return starts_one_ends(n - 2) * 9 * 9;\n    }\n    starts_one_ends(n - 2)\
    \ * 9 * 9 + starts_one_ends(n - 1)", "    let mut cnt = 0;\n    let mut ten_pow\
    \ = 1;\n    for _ in 0..n {\n        ten_pow *= 10;\n    }\n    let mut limit\
    \ = ten_pow / 10;\n    for i in 1..10 {\n        cnt += 1;\n        let mut start\
    \ = i;\n        let mut end = i;\n        while start * i < limit {\n        \
    \    cnt += 1;\n            start *= i;\n            end = start * i;\n      \
    \  }\n        while end % 10 == 0 {\n            end /= 10;\n        }\n     \
    \   if end == 1 {\n            cnt += 1;\n        }\n    }\n    cnt", "    let\
    \ mut total = 1;\n    for _ in 1..n {\n        total = (total * 10) + 1;\n   \
    \ }\n    total", "    if n <= 0 {\n        return 0;\n    }\n\n    if n <= 2 {\n\
    \        return 9;\n    }\n\n    if n == 3 {\n        return 7;\n    }\n\n   \
    \ let mut result = 10 * starts_one_ends(n - 1) - starts_one_ends(n - 3);\n   \
    \ result -= n - 4;\n    result", "    let mut dp = vec![0; (n + 1) as usize];\n\
    \    dp[1] = 1;\n    for i in 2..=n {\n        dp[i as usize] = dp[(i - 1) as\
    \ usize] * 9 + dp[(i - 2) as usize];\n    }\n    dp[n as usize]", "    // Note\
    \ that this starts with 10, not 1.\n    let mut ending_ones = 10;\n    let mut\
    \ ending_zeros = 9;\n    for _ in 1..n {\n        ending_ones = ending_ones +\
    \ ending_zeros;\n        ending_zeros = ending_zeros * 10;\n    }\n    ending_ones",
  "    if n == 1 {\n        return 10;\n    }\n    if n == 2 {\n        return 55;\n\
    \    }\n    10 * (10 * starts_one_ends(n - 2) + 9 * starts_one_ends(n - 1))",
  "    let mut dp = vec![0; (n + 1) as usize];\n    dp[1] = 1;\n    for i in 2..=n\
    \ {\n        dp[i as usize] = dp[(i - 1) as usize] * 10 + 1;\n    }\n    dp[n\
    \ as usize]", "    if n == 1 {\n        return 2;\n    }\n\n    let start = starts_one_ends(n\
    \ - 1);\n    let mut start_with_one = start;\n    let mut end_with_one = start;\n\
    \    for i in 1..n {\n        start_with_one = start_with_one * 9 + end_with_one;\n\
    \        end_with_one = end_with_one * 10;\n    }\n\n    start_with_one + end_with_one",
  "    let mut count = 0;\n    for i in 1..n {\n        let start = ten_power(i -\
    \ 1);\n        let end = ten_power(n - i);\n        count += start * end;\n  \
    \  }\n    count * 2", "    if n == 1 {\n        return 2;\n    }\n    if n ==\
    \ 2 {\n        return 4;\n    }\n    starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)", "    if n == 1 {\n        return 10;\n    }\n    if n == 2 {\n      \
    \  return 55;\n    }\n    let mut a = 55;\n    let mut b = 180;\n    for _ in\
    \ 3..n {\n        let c = 9 * a + b;\n        a = b;\n        b = c;\n    }\n\
    \    b", "    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n       \
    \ return 9 + starts_one_ends(1);\n    }\n    let mut res = 0;\n    for i in 1..n\
    \ {\n        res += starts_one_ends(i) * (n - i);\n    }\n    starts_one_ends(n\
    \ - 1) + res", "    assert!(n > 0);\n    if n == 1 {\n        return 1;\n    }\n\
    \n    10 - 1 // 10^n - 1\n        + 10 - 1 // 10^(n-1) - 1\n        + 10 - 1 //\
    \ 10^(n-2) - 1\n        + starts_one_ends(n - 1)", '    1', "    if n == 1 {\n\
    \        return 2;\n    }\n    let mut res = 0;\n    for i in 1..n {\n       \
    \ res += starts_one_ends(i);\n    }\n    res + 9 * (n - 1)", "    if n == 1 {\n\
    \        return 2;\n    }\n    if n == 2 {\n        return 9;\n    }\n    let\
    \ mut sum = 9;\n    let mut prev = 9;\n    for _ in 3..=n {\n        let next\
    \ = prev * 10 - 9;\n        sum += next;\n        prev = next;\n    }\n    sum",
  "    let mut digits = vec![];\n    let mut num = n;\n    while num > 0 {\n     \
    \   digits.push(num % 10);\n        num /= 10;\n    }\n    let mut start = 0;\n\
    \    let mut end = 0;\n    for i in 1..digits.len() {\n        start += 9 * 10i64.pow(i\
    \ as u32 - 1) as isize;\n        end += 9 * 10i64.pow(i as u32 - 1) as isize;\n\
    \    }\n    if digits.len() > 1 {\n        start += digits[0] - 1;\n        end\
    \ += 9 - digits[digits.len() - 1];\n    }\n    if digits.len() == 1 {\n      \
    \  start += 1;\n        end += 1;\n    }\n    start + end", "    let mut cache\
    \ = HashMap::new();\n    starts_one_ends_helper(n, &mut cache)", "    if n <=\
    \ 1 {\n        return n;\n    }\n    //\n    // There are 10 numbers ending in\
    \ 1, and the rest don't matter.\n    // There are 9*10^(n-2) numbers starting\
    \ with 1, and the rest don't matter.\n    //\n    10 + 9 * 10f64.powi(n as i32\
    \ - 2) as isize", "    let n = n as usize;\n    let mut tmp = vec![0; n];\n  \
    \  for i in 0..n {\n        tmp[i] = 9 * 10i64.pow(i as u32 - 1) as isize;\n \
    \   }\n    let mut dp = vec![0; n];\n    dp[0] = 10;\n    dp[1] = 91;\n    for\
    \ i in 2..n {\n        dp[i] = dp[i - 1] * 10 - tmp[i - 1];\n    }\n    dp[n -\
    \ 1]", "    let mut start = 9;\n    let mut end = 9;\n    let mut start_cnt =\
    \ 10;\n    let mut end_cnt = 10;\n    let mut total = 0;\n    let mut idx = 1;\n\
    \    while idx < n {\n        start = start * 10;\n        end = end * 10;\n \
    \       start_cnt = start_cnt * 10;\n        end_cnt = end_cnt * 10;\n       \
    \ total += start * idx + end_cnt;\n        idx += 1;\n    }\n    total", "   \
    \ if n == 1 {\n        return 1;\n    }\n\n    let mut s = 0;\n    for i in 1..n+1\
    \ {\n        s += starts_one_ends(i-1) * starts_one_ends(n-i);\n    }\n    s",
  "    match n {\n        0 => 0,\n        1 => 1,\n        2 => 12,\n        _ =>\
    \ 10 * starts_one_ends(n - 1) - (n - 2) * starts_one_ends(n - 2),\n    }", " \
    \   let mut result = 0;\n    let mut count = 1;\n    let mut multiplier = 1;\n\
    \    while count < n {\n        result += 9 * multiplier;\n        multiplier\
    \ *= 10;\n        count += 1;\n    }\n    result += multiplier;\n    result",
  "    if n <= 1 {\n        return 0;\n    }\n    let mut m = n / 2;\n    let mut\
    \ r = n % 2;\n    if r == 1 {\n        m += 1;\n    }\n    let mut result = 0;\n\
    \    for i in 1..m + 1 {\n        result += i * (10isize.pow(i - 1))\n    }\n\
    \    if r == 1 {\n        result += 9 * (10isize.pow(m) - 1) / 9;\n    }\n   \
    \ result", "    if n <= 0 {\n        return 0;\n    }\n    let mut dp = vec![0;\
    \ n as usize + 1];\n    dp[1] = 1;\n    for i in 2..n + 1 {\n        dp[i as usize]\
    \ = dp[(i - 1) as usize] * 9 + dp[(i - 2) as usize];\n    }\n    dp[n as usize]",
  "    if n == 1 {\n        return 10;\n    }\n    let mut result = ends_one_ends(n\
    \ - 1) + ends_one_starts(n - 1);\n    if n == 2 {\n        result -= 9;\n    }\n\
    \    result", "    // The number starts with 1, it leaves n-1 digits to choose\n\
    \    let first = 9 * combinations(9, n - 1);\n    // The number ends with 1, it\
    \ leaves n-1 digits to choose\n    let last = 9 * combinations(9, n - 1);\n  \
    \  // A number which either starts or ends with 1,\n    // it leaves n-2 digits\
    \ to choose\n    let both = 9 * combinations(9, n - 2);\n    // The total combinations\
    \ is the sum of cases\n    first + last - both", "    // TODO: It might be faster\
    \ to run 2 loops, one to the left and one to the\n    // right.\n    if n == 1\
    \ {\n        return 1;\n    }\n\n    let mut count = 0;\n    let mut m = n;\n\
    \    let mut n_count = n - 1;\n    let mut n_m = n - 1;\n    while m > 0 {\n \
    \       count += n_count * (10isize.pow(m) - 10isize.pow(m - 1));\n        n_count\
    \ *= n_m;\n        m -= 1;\n        n_m -= 1;\n    }\n\n    count", "    let mut\
    \ result = 0;\n    let mut power = 1;\n    let mut n = n;\n    while n > 0 {\n\
    \        result += power;\n        power *= 10;\n        n -= 1;\n    }\n    result",
  "    let x = &mut vec![0; n as usize + 1];\n    if n <= 1 {\n        return 1;\n\
    \    }\n    x[0] = 1;\n    for i in 1..n {\n        x[i as usize] = 9 * sum(x,\
    \ i);\n    }\n    x[n as usize] = 10 * sum(x, n - 1);\n    x[n as usize]", " \
    \   let mut result = 0;\n    for i in 0..n {\n        result += (n - i) * 9 *\
    \ power_of_ten(i);\n    }\n    result", "    assert!(n > 0);\n    if n <= 1 {\n\
    \        return n;\n    }\n    let sum = |a, b| a + b;\n    let sum_ten = sum(10,\
    \ 0);\n    let modulo = |a, b| (a + b) % 9;\n    let mul = |a, b| a * b;\n   \
    \ let p = (1..n).fold(sum_ten, modulo);\n    let q = (1..(n + 1)).fold(1, mul);\n\
    \    sum(p, q)", "    // We know if n == 1, the only valid number is 1.\n    if\
    \ n == 1 {\n        return 1;\n    }\n\n    // For all other n, we know that the\
    \ valid numbers for n-1 are valid.\n    // Also, any number that doesn't start\
    \ with a 1, but ends with one is\n    // valid. For example, 1, 12, 123, 1234,\
    \ 12345, ..., 123456789. These are\n    // all valid numbers. We know there are\
    \ nine digits between 1 and 9, so\n    // there are 9 of these numbers. We also\
    \ know that 10, 100, 1000, ...\n    // would give us another (n - 1) valid numbers.\n\
    \    starts_one_ends(n - 1) + (n - 1) * 9", "    if n == 1 {\n        return 10;\n\
    \    }\n    // n >= 2\n    let nminus1 = n - 1;\n    let nminus2 = n - 2;\n  \
    \  (nminus1 * 9 * 9usize.pow(nminus2 as u32) + 9 * 9usize.pow(nminus1 as u32))\
    \ as isize", "    let ten = isize::pow(10, n - 1);\n    ten + 9 * ten / 10", '    (start_with_one(n)
    + ends_with_one(n))', "    if n <= 1 {\n        return 1;\n    }\n    if n ==\
    \ 2 {\n        return 10;\n    }\n    let mut res = 4;\n    let mut power = 8;\n\
    \    let mut ten = 100;\n    for _ in 3..n {\n        res += power;\n        power\
    \ *= 9;\n        ten *= 10;\n    }\n    res += power;\n    let num = ten * 9;\n\
    \    return num - res;", "    let (mut ones, mut tens) = (1, 1);\n    for _ in\
    \ 1..n {\n        let tmp = ones;\n        ones = tens;\n        tens = 9 * tens\
    \ + tmp;\n    }\n    ones + tens", "    if n == 1 {\n        return 1;\n    }\n\
    \n    if n == 2 {\n        return 10;\n    }\n\n    let mut dp = vec![0; n as\
    \ usize];\n    dp[0] = 1;\n    dp[1] = 10;\n\n    for i in 2..n {\n        dp[i\
    \ as usize] = dp[(i - 1) as usize] + dp[(i - 2) as usize];\n    }\n\n    dp[(n\
    \ - 1) as usize] * 2", "    let mut last_digit = 1;\n    let mut before_last_digit\
    \ = 1;\n    let mut count = 0;\n    let mut power = 1;\n    while n > power {\n\
    \        power *= 10;\n        count += last_digit * power;\n        let tmp =\
    \ last_digit;\n        last_digit = last_digit + before_last_digit;\n        before_last_digit\
    \ = tmp;\n    }\n    count", "    if n == 1 {\n        return 1;\n    }\n    if\
    \ n == 2 {\n        return 10;\n    }\n    let mut a = 9;\n    let mut b = 9;\n\
    \    let mut c = 9;\n    for _ in 3..n {\n        c = (b + a) * 10 - a;\n    \
    \    a = b;\n        b = c;\n    }\n    c", "    if n == 1 {\n        return 2;\n\
    \    }\n    starts_one_ends(n - 1) + ends_one_ends(n - 1)", '    starts_one_ends_rec(n,
    0)', "    // Special cases:\n    //\n    // If n == 1, the number is 1 and there's\
    \ only one such number.\n    // If n == 2, the numbers are:\n    //  1, 10, 11,\
    \ 100.\n    // There are 4 numbers in total.\n    if n <= 2 {\n        return\
    \ n;\n    }\n\n    // Figure out the number of n-digit positive integers that\
    \ start with one.\n    // Let's say the starting number is one million. This number\
    \ would\n    // increase every time we add an extra digit.\n    //\n    // For\
    \ example,\n    //\n    // 1,000,000,000\n    // 1,000,000,001\n    // 1,000,000,002\n\
    \    // 1,000,000,003\n    // ...\n    // 1,000,000,009\n    // 1,000,000,010\n\
    \    // 1,000,000,011\n    // 1,000,000,012\n    // ...\n    // 1,000,000,099\n\
    \    // 1,000,000,100\n    // 1,000,000,101\n    // 1,000,000,102\n    // ...\n\
    \    //\n    // Here we notice that every time a number with the same number of\
    \ digits\n    // ends, a new number with the same number of digits starts. There\
    \ are\n    // 999,999,999 numbers ending in 999,999,999.\n    //\n    // In general,\
    \ n-digit positive integers that start with one takes up\n    // the space of\
    \ (10^n - 1) / 9.\n    let s = (10isize.pow(n) - 1) / 9;\n\n    // Figure out\
    \ the number of n-digit positive integers that end with one.\n    // We do this\
    \ in a similar way by ignoring the most significant digit\n    // and find the\
    \ number of n-1 digit positive integers that start with one.\n    // There are\
    \ (n - 1) such numbers.\n    let e = n - 1;\n\n    // Sum up the results to get\
    \ the number of n-digit positive integers that\n    // start or end with one.\n\
    \    s + e", "    // Given n-digit number, we need to pick the n-1 digits for\
    \ the middle.\n    // For n > 1, there are n ways to choose the initial or final\
    \ digit.\n    if n < 1 {\n        0\n    } else if n == 1 {\n        1\n    }\
    \ else {\n        n * starts_one_ends(n - 1)\n    }", "    if n <= 1 {\n     \
    \   return 1;\n    }\n\n    let mut first = 0;\n    let mut tenth = 1;\n    let\
    \ mut digit = 0;\n    for _ in 0..n {\n        let temp = first;\n        first\
    \ = tenth;\n        tenth = (9 * temp + tenth * 10) % MOD;\n        digit = (10\
    \ * digit + 1) % MOD;\n    }\n\n    return (first + tenth + digit) % MOD;", " \
    \   // If n is 1, we have 2 choices, else 2 times the number of possible\n   \
    \ // numbers of length n - 1.\n    if n == 1 {\n        2\n    } else {\n    \
    \    2 * starts_one_ends(n - 1)\n    }", "    if n == 1 {\n        return 2;\n\
    \    }\n    let mut n = n - 1;\n    let mut res = 2;\n    while n > 0 {\n    \
    \    res = res * 5;\n        n = n - 1;\n    }\n    res", "    // (n-1) - has_zero_digits\n\
    \    // 0     - 1\n    // ...\n    // 9     - 10^(n-1) - 1\n    let has_zero_digits\
    \ = if n > 1 { n - 1 } else { 0 };\n    let num_one_digits = 10_f64.powi(n as\
    \ i32 - 1) as isize - 1;\n    let num_other_digits = has_zero_digits + num_one_digits;\n\
    \    num_other_digits * 10 + 9", "    if n == 1 {\n        return 1;\n    }\n\n\
    \    if n == 2 {\n        return 10;\n    }\n\n    let mut ends_one = 1;\n   \
    \ let mut no_ends_one = 9;\n\n    for _ in 2..n {\n        let ends_one_next =\
    \ ends_one * 1 + no_ends_one * 9;\n        let no_ends_one_next = ends_one * 9\
    \ + no_ends_one * 9;\n\n        ends_one = ends_one_next;\n        no_ends_one\
    \ = no_ends_one_next;\n    }\n\n    ends_one + no_ends_one", "    let mut dp =\
    \ vec![0; n as usize + 1];\n    dp[1] = 10;\n    for i in 2..n + 1 {\n       \
    \ dp[i as usize] = dp[(i - 1) as usize] * 9 + 10;\n    }\n    dp[n as usize]",
  "    if n == 1 {\n        return 2;\n    }\n    return starts_one_ends(n - 1) +\
    \ starts_one_ends(n - 2);", "    let mut ret = 0;\n    let base = 10.pow(n - 1);\n\
    \    for i in 1..(10 - base) + 1 {\n        let num = base + i;\n        if (1..n).any(|e|\
    \ num % 10_isize.pow(e) == 1) {\n            ret += 1;\n        }\n    }\n   \
    \ ret", "    if n == 1 {\n        return 1;\n    }\n    let mut s = 9;\n    let\
    \ mut f = 9;\n    for _ in 2..n {\n        s = s * 10 + 1;\n        f = f * 10;\n\
    \    }\n    let result = s + (n - 1) * f;\n    if n > 2 {\n        result + starts_one_ends(n\
    \ - 1)\n    } else {\n        result\n    }", "    if n == 1 {\n        return\
    \ 1;\n    }\n\n    let mut sum = 0;\n    for i in 1..n {\n        let a = start_one(i);\n\
    \        let b = end_one(n - i);\n        sum += a * b;\n    }\n\n    sum", " \
    \   // Note: This solution is essentially a brute force solution.\n    // We should\
    \ be able to come up with a better solution than this.\n    let mut count = 0;\n\
    \    for i in 1..10_isize.pow(n as u32) {\n        let start = i.to_string().get(0..1).unwrap();\n\
    \        let end = i.to_string().get((n - 1)..n).unwrap();\n        if start ==\
    \ \"1\" || end == \"1\" {\n            count += 1;\n        }\n    }\n    count",
  "    let mut ans = (n - 1) * 9;\n    let mut t = 9;\n    for _ in 0..n - 1 {\n \
    \       ans += t;\n        t *= 10;\n    }\n    ans", "    if n == 1 {\n     \
    \   return 1;\n    }\n    let mut n = n;\n    n -= 1;\n    let mut res = 0;\n\
    \    let mut base = 9;\n    while n > 0 {\n        res += n * base;\n        base\
    \ *= 10;\n        n -= 1;\n    }\n    res", "    if n == 1 {\n        return 10;\n\
    \    }\n    if n == 2 {\n        return 55;\n    }\n    let euler = Euler::new(Pow::new(10,\
    \ n), 10, 55);\n    euler.run(Pow::new(10, n - 1))", "    if n == 1 {\n      \
    \  return 10;\n    }\n\n    let mut sum = 0;\n    let mut count = 0;\n    let\
    \ mut leading_one = true;\n    for i in 1..10 {\n        let mut num = i;\n  \
    \      count = 1;\n        while count < n {\n            if !leading_one && count\
    \ + 1 == n {\n                sum += i;\n            }\n            num = num\
    \ * 10 + i;\n            count += 1;\n        }\n        sum += num;\n       \
    \ leading_one = false;\n    }\n    sum", "    let mut table = vec![vec![0; 10];\
    \ n as usize];\n    table[0] = vec![1; 10];\n    for i in 1..n as usize {\n  \
    \      for j in 0..10 {\n            table[i][j] = table[i - 1].iter().sum();\n\
    \        }\n    }\n    table[n as usize - 1].iter().sum()", "    let (mut a, mut\
    \ b) = (0, 1);\n    for _ in 0..n {\n        let a_new = b;\n        let b_new\
    \ = a + b;\n        a = a_new;\n        b = b_new;\n    }\n    a", "    let l\
    \ = (n - 1) / 2;\n    let r = n - l;\n    let mut res = 0;\n    let mut x = 1;\n\
    \    for _ in 0..l {\n        x *= 10;\n    }\n    res += x;\n    let mut x =\
    \ 1;\n    for _ in 0..r {\n        x *= 10;\n    }\n    res += x;\n    res - 2",
  '    (1..=9).fold(0, |acc, digit| acc + starts_one_ends_(n - 1, digit))', "    let\
    \ mut count = 1;\n\n    for _ in 1..n {\n        count = count * 10 + 1;\n   \
    \ }\n\n    count", "    if n <= 1 {\n        return 1;\n    }\n    starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2)", "    // We can form n-digit numbers by taking\
    \ n-1 digits from a pool of 9 digits\n    // and placing a 1 at the front or back.\n\
    \    (1..n).fold(2, |acc, _| acc * 10)", "    let zeros = 10isize.pow(n as u32\
    \ - 1);\n    let ones = 9 * zeros;\n    let other = starts_one_ends(n - 1);\n\
    \    ones + other", "    let base = 10;\n    // The number of ways to get a number\
    \ with 1 as the last digit.\n    let mut one_ways = 1;\n    // The number of ways\
    \ to get a number with 1 as the first digit.\n    let mut non_one_ways = 9;\n\
    \    // Inclusive start and end of the number.\n    let (start, end) = (0, n);\n\
    \    // Iterate from the penultimate digit to the first digit.\n    for i in (start..end\
    \ - 1).rev() {\n        one_ways += non_one_ways;\n        non_one_ways *= base\
    \ - 1;\n    }\n    // Total ways minus `non_one_ways` because we don't want the\
    \ start\n    // and end both being 1.\n    one_ways - non_one_ways", "    let\
    \ mut a: isize = 9;\n    let mut b: isize = 1;\n    let mut sum: isize = 0;\n\
    \    for _ in 1..n {\n        sum += a * b;\n        a *= 10;\n        b *= 10;\n\
    \    }\n    sum += a;\n    sum", "    let mut dp = vec![0; 101];\n    dp[1] =\
    \ 1;\n    dp[2] = 20;\n    for i in 3..=n {\n        dp[i as usize] = 10 * dp[(i\
    \ - 1) as usize] - dp[(i - 2) as usize];\n    }\n    dp[n as usize]", '    n -
    1', "    if n == 1 {\n        return 10;\n    }\n    let mut result = 9;\n   \
    \ let mut base = 9;\n    for _ in 2..n {\n        result *= base;\n        base\
    \ -= 1;\n    }\n    result", "    if n == 1 {\n        return 10;\n    }\n\n \
    \   let n_minus_1 = n - 1;\n    let nine_pow = 9_isize.pow(n_minus_1);\n    let\
    \ nine_pow_times_n = nine_pow * n;\n    ten_pow(n_minus_1) + nine_pow_times_n",
  "    if n <= 0 {\n        0\n    } else if n == 1 {\n        2\n    } else {\n \
    \       starts_one_ends(n - 1) + starts_one_ends(n - 2)\n    }", "    if n ==\
    \ 1 {\n        1\n    } else {\n        9 * starts_one_ends(n - 1) + 10_isize.pow(n\
    \ - 1)\n    }", "    let n = n as usize;\n    let mut dp = vec![0; n + 1];\n \
    \   dp[1] = 10;\n    for i in 2..n + 1 {\n        dp[i] = dp[i - 1] * 9 + 10;\n\
    \    }\n    dp[n]", "    if n == 1 {\n        return 1;\n    }\n    if n == 2\
    \ {\n        return 10;\n    }\n    2 * starts_one_ends(n - 1) + (10_isize.pow(n\
    \ - 2) - starts_one_ends(n - 2))", "    let mut count = 0;\n    let p = isize::pow(10,\
    \ n - 1);\n    for a in 1..9 {\n        count += a * p;\n    }\n    count", " \
    \   let mut digits: Vec<isize> = vec![1];\n    let base = 10;\n    for _ in 1..n\
    \ {\n        let mut new_digits = vec![];\n        for digit in &digits {\n  \
    \          new_digits.push(digit * base);\n            new_digits.push(digit *\
    \ base + 1);\n        }\n        digits = new_digits;\n    }\n    digits.len()\
    \ as isize", "    if n == 1 {\n        return 1;\n    }\n    let mut nums = vec![0;\
    \ n as usize];\n    nums[0] = 1;\n    nums[1] = 1;\n    let mut m = n as usize;\n\
    \    while m > 2 {\n        nums[m - 1] = nums[m - 2] + nums[m - 3];\n       \
    \ m -= 1;\n    }\n    let mut sum = 0;\n    for num in nums {\n        sum +=\
    \ num;\n    }\n    sum", "    match n {\n        1 => 1,\n        2 => 9,\n  \
    \      n => n_ones(n - 1) + 9 * n_ones(n - 2),\n    }", "    if n == 1 {\n   \
    \     return 2;\n    }\n\n    let base = 10;\n    base.pow(n - 1) - base.pow(n\
    \ - 2)", "    let mut start_count = 0;\n    let mut end_count = 0;\n    let mut\
    \ result = 0;\n    for i in 0..n {\n        if i == 0 {\n            start_count\
    \ = 1;\n            end_count = 1;\n        } else {\n            start_count\
    \ = start_count * 10 + 1;\n            end_count = end_count * 10;\n        }\n\
    \        result += start_count + end_count;\n    }\n    result", "    // These\
    \ special cases are a little tricky to understand. Basically,\n    // the algorithm\
    \ below only works for n >= 3. But, there are 4 one-digit\n    // numbers that\
    \ are divisible by 10, and 3 two-digit numbers that are\n    // divisible by 10.\n\
    \    if n < 3 {\n        return n;\n    }\n\n    let mut last: isize = 1;\n  \
    \  let mut current: isize = 1;\n    for _ in 3..(n + 1) {\n        let new_current\
    \ = 2 * current + last;\n        last = current;\n        current = new_current;\n\
    \    }\n    current", "    let mut start_cache = vec![0; n as usize + 1];\n  \
    \  let mut end_cache = vec![0; n as usize + 1];\n    let mut x = 9;\n    for _\
    \ in 0..n - 1 {\n        x *= 10;\n    }\n    start_cache[1] = 1;\n    start_cache[2]\
    \ = 10;\n    end_cache[1] = 1;\n    end_cache[2] = 10;\n    return start_one_ends_helper(n,\
    \ &mut start_cache, &mut end_cache, x);", "    let mut result = 0;\n    let mut\
    \ l = 1;\n    let mut m = 1;\n    let mut r = 0;\n    for _ in 1..n {\n      \
    \  result = l + m + r;\n        l = m;\n        m = r;\n        r = result;\n\
    \    }\n    result", "    if n == 1 {\n        return 10;\n    }\n\n    let mut\
    \ p = 1;\n    for _ in 1..n {\n        p *= 10;\n    }\n\n    let mut n = n -\
    \ 1;\n    let mut r = 10;\n    while n > 0 {\n        r *= 10;\n        n -= 1;\n\
    \    }\n\n    return r - p;", "    if n == 1 {\n        return 1;\n    }\n   \
    \ let mut result = 0;\n    for i in 1..(n+1) {\n        result += 9 * f64::powi(10.0,\
    \ i-1) as isize;\n    }\n    result", "    let mut count = 1;\n    for _ in 0..n\
    \ {\n        count = count * 9 + 1;\n    }\n    count", "    if n <= 1 {\n   \
    \     return n;\n    }\n    let mut dp = vec![vec![0; 10]; n as usize];\n    dp[0][1]\
    \ = 1;\n    for i in 1..n {\n        for j in 0..10 {\n            for k in 0..10\
    \ {\n                if j == 1 || k == 1 {\n                    dp[i as usize][j]\
    \ += dp[(i - 1) as usize][k];\n                }\n            }\n        }\n \
    \   }\n    dp[(n - 1) as usize].iter().sum()", "    let mut count = 0;\n    for\
    \ x in 0..n {\n        let y = n - x;\n        count += power(10, x) * (power(9,\
    \ y) - power(8, y));\n    }\n    count", "    let mut n = n;\n    let mut res\
    \ = 0;\n    let mut cur = 9;\n    while n > 1 {\n        res += cur;\n       \
    \ cur *= 10;\n        n -= 1;\n    }\n    res += cur;\n    res", "    let mut\
    \ result = 0;\n    let mut start = 1;\n    let mut end = 1;\n    let mut base\
    \ = 1;\n    while n > 0 {\n        result += start + end;\n        let new_start\
    \ = end * 9 + start;\n        let new_end = base * 10;\n        start = new_start;\n\
    \        end = new_end;\n        base *= 10;\n        n -= 1;\n    }\n    result",
  "    let mut count = 0;\n    if n == 1 {\n        return 9;\n    }\n\n    for i\
    \ in 1..10 {\n        count += count_starts_one_ends_one(i, n - 1);\n    }\n\n\
    \    count", "    if n == 1 {\n        return 10;\n    }\n\n    let ten = 10_isize.pow(n\
    \ - 1);\n    // -1 for the starts with one, -10 for all the ends with one\n  \
    \  starts_one_ends(n - 1) * 9 - ten - 1", "    if n == 1 {\n        return 2;\n\
    \    }\n    if n == 2 {\n        return 4;\n    }\n    (starts_one_ends(n - 1)\
    \ - starts_one_ends(n - 2)) * 10 + starts_one_ends(n - 1)", "    // base cases\n\
    \    if n == 1 {\n        return 10;\n    }\n    if n == 2 {\n        return 55;\n\
    \    }\n\n    // compute 10^(n-1)\n    let mut ten_power = 1;\n    for _ in 0..n-1\
    \ {\n        ten_power *= 10;\n    }\n\n    // recursively compute number of n-digit\
    \ positive integers that starts with 1\n    // s(n) = 10^(n-1) - 9*10^(n-2) +\
    \ s(n-1)\n    // s(n) = 10^(n-1) - 9*10^(n-2) + s(n-2)\n    let mut s1 = ten_power\
    \ - 9*(ten_power/10) + starts_one_ends(n-1);\n    let mut s2 = ten_power - 9*(ten_power/10)\
    \ + starts_one_ends(n-2);\n\n    // recursively compute number of n-digit positive\
    \ integers that ends with 1\n    // e(n) = 10^(n-1) - 9*10^(n-2) + e(n-1)\n  \
    \  // e(n) = 10^(n-1) - 9*10^(n-2) + e(n-2)\n    let mut e1 = ten_power - 9*(ten_power/10)\
    \ + ends_one_ends(n-1);\n    let mut e2 = ten_power - 9*(ten_power/10) + ends_one_ends(n-2);\n\
    \n    // add them up\n    s1 + s2 + e1 + e2", "    if n == 1 {\n        return\
    \ 1;\n    }\n    10 * starts_one_ends(n - 1) - 9 * starts_one_ends(n - 2)", " \
    \   // The recursive function.\n    fn _s(n: isize) -> isize {\n        if n ==\
    \ 1 {\n            // Base case.\n            return 10;\n        }\n        let\
    \ mut count = _s(n - 1);\n        // If a number starts with 1, then it has (n\
    \ - 1) digit.\n        count += (n - 1) * 9;\n        // If a number ends with\
    \ 1, then it has (n - 1) digit.\n        count += (n - 1) * 9;\n        count\n\
    \    }\n    _s(n)", '    (1..n + 1).map(|i| starts_one_ends_i(i)).sum()', '    unimplemented!();',
  "    use std::convert::TryInto;\n    (n - 1).try_into().unwrap() * 10_isize.pow((n\
    \ - 2).try_into().unwrap())", "    if n <= 0 {\n        return 0;\n    }\n   \
    \ let mut res = 0;\n    let mut i = 0;\n    while i < n {\n        res += 9 *\
    \ (10_isize.pow(i)) * (10_isize.pow(n - i - 1));\n        i += 1;\n    }\n   \
    \ return res;", "    if n == 1 {\n        return 2;\n    }\n\n    if n == 2 {\n\
    \        return 6;\n    }\n\n    starts_one_ends(n - 1) + starts_one_ends(n -\
    \ 2)", "    let mut count = 0;\n    let mut i = 0;\n    while i < n {\n      \
    \  count += zeros(n - i - 1);\n        i += 1;\n    }\n    return count * 2;",
  "    if n == 1 {\n        return 10;\n    }\n    if n == 2 {\n        return 90;\n\
    \    }\n    let mut sum = 100;\n    for i in 2..n {\n        sum += (9 * 9i64.pow(i\
    \ - 1) as isize);\n    }\n    sum", "    if n == 1 {\n        return 2;\n    }\n\
    \    starts_one_ends(n - 1) + starts_one_ends(n - 2) * 3", "    let mut s = vec![0;\
    \ (n + 1) as usize];\n    s[1] = 10;\n    s[2] = 91;\n    let mut x = 3;\n   \
    \ while x <= n {\n        s[x as usize] = s[(x - 1) as usize] + s[(x - 2) as usize];\n\
    \        x += 1;\n    }\n    s[n as usize]", '    (n - 1) * 9 * 10_isize.pow(n
    - 2)', "    // Count all numbers with n-1 or fewer digits.\n    let mut max_n_minus_one\
    \ = 1;\n    for _ in 0..n-1 {\n        max_n_minus_one *= 10;\n    }\n    let\
    \ ones_n_minus_one = starts_one_ends(n-1);\n    let ends_one_n_minus_one = ends_one(n-1);\n\
    \    max_n_minus_one * 10 - (max_n_minus_one - ones_n_minus_one) -\n        (max_n_minus_one\
    \ - ends_one_n_minus_one)", "    let mut count = 0;\n    for i in 1..n {\n   \
    \     count += startswith_one(i) * pow10(n - i);\n    }\n    count + pow10(n -\
    \ 1)", "    let mut dp = vec![0; (n + 1) as usize];\n    let mut p10 = vec![0;\
    \ (n + 1) as usize];\n    let mut i = 0;\n    while i <= n {\n        if i ==\
    \ 0 {\n            dp[i as usize] = 0;\n            p10[i as usize] = 1;\n   \
    \     } else if i == 1 {\n            dp[i as usize] = 10;\n            p10[i\
    \ as usize] = 10;\n        } else {\n            dp[i as usize] = 9 * p10[(i -\
    \ 1) as usize] + dp[(i - 1) as usize];\n            p10[i as usize] = 10 * p10[(i\
    \ - 1) as usize];\n        }\n        i += 1;\n    }\n    dp[n as usize]", " \
    \   let mut dp = vec![0; n as usize + 1];\n    dp[1] = 10;\n\n    for i in 2..n\
    \ + 1 {\n        let j = (i - 1) as usize;\n        let k = i as usize;\n    \
    \    dp[k] = dp[j] * 9 + dp[j];\n    }\n\n    return dp[n as usize];", "    let\
    \ mut sum = 0;\n    let mut m = 1;\n    for _ in 0..n {\n        sum += 9 * m;\n\
    \        m *= 10;\n    }\n    sum", "    assert!(n > 0);\n    if n == 1 {\n  \
    \      return 2;\n    }\n    let n = n as usize;\n    let mut dp = vec![0; n +\
    \ 1];\n    dp[1] = 2;\n    let m = 10i32.pow(9) + 7;\n    for i in 2..=n {\n \
    \       dp[i] = dp[i - 1] + 9;\n        dp[i] %= m;\n    }\n    dp[n]", "    let\
    \ size = n as usize;\n    let mut front = vec![0isize; size];\n    let mut back\
    \ = vec![0isize; size];\n    front[0] = 1;\n    back[0] = 1;\n    for idx in 1..size\
    \ {\n        front[idx] = 9 * front[idx - 1];\n        back[idx] = front[idx]\
    \ + back[idx - 1];\n    }\n    back[size - 1]", "    if n <= 1 {\n        return\
    \ n;\n    }\n    starts_one_ends(n - 1) + starts_one_ends(n - 2)", "    // base\
    \ case\n    if n == 1 {\n        return 2;\n    }\n\n    // dynamic programming\
    \ recursion\n    2 * starts_one_ends(n - 1) + std::cmp::max(0, 10 - n)", "   \
    \ // For a n-digit number, there are 9 choices for the number that it could\n\
    \    // start or end with.\n\n    // No. of digits in resulting number = n - 1\n\
    \    9 * count_digits(n - 1)", "    // It's a good idea to have a wrapper that\
    \ calls a recursive function to\n    // make sure you don't go negative, and it's\
    \ much easier to think about\n    // the base case\n    count_recursive(n)", " \
    \   if n <= 0 {\n        return 0;\n    }\n\n    if n == 1 {\n        return 10;\n\
    \    }\n\n    let mut dp = vec![0; n as usize];\n    dp[0] = 10;\n    for i in\
    \ 1..n as usize {\n        dp[i] = (dp[i - 1] * 9) + dp[i - 1];\n    }\n\n   \
    \ dp[n as usize - 1]", '    n * n', "    if n <= 0 {\n        return 0;\n    }\n\
    \n    // If a number starts with 1, we can have any number of digits after it,\n\
    \    // so we subtract 1 so as not to double count in the next case.\n    let\
    \ start_one = nines(n - 1);\n\n    // If a number ends with 1, we must have exactly\
    \ n - 1 digits after it.\n    let end_one = nines(n - 2) * 8;\n\n    start_one\
    \ + end_one", "    // Construct a vector with the digits of n\n    let n: Vec<char>\
    \ = n.to_string().chars().collect();\n\n    // Create a vector to store the resulting\
    \ digits\n    let mut digits: Vec<char> = Vec::new();\n\n    // Add the first\
    \ digit\n    digits.push('1');\n\n    // Add the remaining digits\n    for _ in\
    \ 1..n.len() {\n        digits.push('0');\n    }\n\n    // Recurse on the digits\n\
    \    recurse_digits(&n, &digits, 0)", "    if n == 1 {\n        return 10;\n \
    \   }\n    if n < 1 {\n        return 0;\n    }\n    let mut count = 1;\n    let\
    \ mut temp = 10;\n    for _ in 2..n {\n        temp *= 10;\n        count += 9\
    \ * temp;\n    }\n    count", "    let mut s = 1;\n    for i in 0..n - 1 {\n \
    \       s = s * 10 + 1;\n    }\n    s", "    if n == 1 {\n        return 2;\n\
    \    }\n\n    let mut num = 10;\n    let mut count = 11;\n    for _ in 2..n {\n\
    \        num *= 10;\n        count += num + num / 10;\n    }\n\n    count", " \
    \   if n <= 1 {\n        return 1;\n    }\n    let mut count = 0;\n    for i in\
    \ 0..n {\n        count += starts_one_ends(i) * starts_one_ends(n - i - 1);\n\
    \    }\n    count", "    let mut result = 0;\n    let mut start = 10_isize.pow(n\
    \ - 1);\n    let mut end = 10_isize.pow(n);\n    let mut count = 0;\n    while\
    \ start < end {\n        count += 1;\n        result += 1;\n        if count %\
    \ 10 == 0 {\n            start /= 10;\n            end /= 10;\n            count\
    \ = 0;\n        }\n        start *= 10;\n        end *= 10;\n    }\n    result",
  "    if n == 1 {\n        return 1;\n    }\n    let mut sum = 10;\n    for _ in\
    \ 2..n {\n        sum *= 9;\n    }\n    return sum;", "    if n == 1 {\n     \
    \   return 1;\n    }\n\n    let x = (1..10).fold(0, |sum, x| sum + starts_one_ends(n\
    \ - 1));\n    2 * x - 9", '    n - 11 + 1', "    if n <= 0 {\n        return 0;\n\
    \    }\n    if n <= 2 {\n        return 1;\n    }\n    let mut res = 1 + 9;\n\
    \    for _ in 3..=n {\n        res = 10 * res - 9;\n    }\n    res", "    let\
    \ n = n as u64;\n    if n == 1 {\n        return 10;\n    }\n    let mut count\
    \ = 9;\n    for i in 2..=n {\n        count = count * (10 - i + 1);\n    }\n \
    \   count", "    let mut sum = 0;\n    for i in 1..n {\n        let temp = ends_one(i)\
    \ * (std::isize::MAX - 1);\n        sum += temp;\n    }\n    ends_one(n) + sum",
  "    if n == 1 {\n        return 1;\n    }\n\n    // This is a little hacky.  The\
    \ outer, recursive call to itself will set up\n    // the call to itself inside\
    \ of it.  It's a neat little trick, but is\n    // almost certainly not worth\
    \ the effort.  The function would probably be\n    // better off just having two\
    \ loops in it.\n    let mut count = 0;\n    let mut i = 2;\n    while i <= n {\n\
    \        count += starts_one_ends(n - i);\n        i += 1;\n    }\n\n    count",
  "    let mut count = 0;\n    for i in 1..n {\n        count += start_1(i) * ends_1(n\
    \ - i);\n    }\n    count", "    let mut count = 1;\n\n    for i in 1..n {\n \
    \       count *= 9;\n    }\n\n    return count;", "    if n == 1 {\n        return\
    \ 2;\n    }\n\n    let mut dp = vec![0; n as usize];\n    dp[0] = 1;\n    dp[1]\
    \ = 2;\n\n    for i in 2..n {\n        dp[i as usize] = dp[(i - 1) as usize] +\
    \ dp[(i - 2) as usize];\n    }\n\n    return dp[(n - 1) as usize] * 2;", "   \
    \ let mut tn = 1;\n    for _ in 1..n {\n        tn *= 10;\n    }\n    let mut\
    \ c = 0;\n    for i in 1..tn {\n        if i / 10 == 1 || i % 10 == 1 {\n    \
    \        c += 1;\n        }\n    }\n    c", "    if n <= 0 {\n        return 0;\n\
    \    }\n\n    let mut counts = vec![0; n as usize + 1];\n    counts[1] = 1;\n\
    \    counts[2] = 10;\n\n    for i in 3..=n {\n        counts[i as usize] =\n \
    \           counts[(i - 1) as usize] + counts[(i - 2) as usize] + counts[(i -\
    \ 3) as usize];\n    }\n\n    return counts[n as usize];", "    assert!(n > 0);\n\
    \    if n == 1 {\n        1\n    } else {\n        starts_one_ends(n - 1) + all_nonzero(n\
    \ - 1)\n    }", "    let (mut ends, mut starts, mut total) = (0, 0, 0);\n    for\
    \ _ in 0..n {\n        total = total * 9 + ends;\n        ends = starts + 1;\n\
    \        starts = total;\n    }\n    total", "    fn starts_one_ends_rec(n: isize,\
    \ acc: isize) -> isize {\n        match n {\n            0 => acc,\n         \
    \   _ => starts_one_ends_rec(n - 1, acc * 10 + 1),\n        }\n    }\n\n    starts_one_ends_rec(n\
    \ - 1, 11)", '    unimplemented!();', "    let mut count = 0;\n    // We do not\
    \ care about the first and last digits of the number.\n    let mut number = 10_isize.pow(n\
    \ as u32 - 1);\n    let upper_bound = 10_isize.pow(n as u32);\n    while number\
    \ < upper_bound {\n        let mut temp = number;\n        let left_digit = temp\
    \ % 10;\n        temp /= 10;\n        let mut right_digit = 0;\n        while\
    \ temp > 0 {\n            right_digit = temp % 10;\n            temp /= 10;\n\
    \        }\n        if left_digit == 1 || right_digit == 1 {\n            count\
    \ += 1;\n        }\n        number += 1;\n    }\n    count", "    assert!(n >\
    \ 0);\n    let mut a = 1;\n    let mut b = 1;\n    for _ in 2..n {\n        let\
    \ tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    b + a", "    if n\
    \ <= 1 {\n        return 0;\n    }\n\n    let mut res = 1;\n    for _ in 1..n\
    \ {\n        res = res * 9 + 1;\n    }\n\n    res", "    let mut count = 0;\n\
    \    let mut i = 1;\n    while i < n {\n        count += if i == 1 {\n       \
    \     9\n        } else {\n            10\n        };\n        i += 1;\n    }\n\
    \    count + 1", "    assert!(n > 0);\n    if n == 1 {\n        return 1;\n  \
    \  }\n    return 9 * (10isize.pow(n as u32 - 1) - 10isize.pow(n as u32 - 2));",
  "    let end_with_one = ends_one(n);\n    let start_with_one = ends_one(n - 1);\n\
    \    end_with_one + start_with_one", "    let m = (n - 1) / 2;\n    (power(10,\
    \ m) - power(9, m)) as isize", "    // P(n) = P(n-1) + (n-1) * P(n-2)\n    //\
    \ P(1) = 2\n    // P(2) = 4\n    // P(3) = P(2) + 2 * P(1) = 6\n    // P(4) =\
    \ P(3) + 3 * P(2) = 11\n    // P(5) = P(4) + 4 * P(3) = 25\n    if n == 1 {\n\
    \        return 2;\n    }\n    if n == 2 {\n        return 4;\n    }\n    let\
    \ mut n1 = 2;\n    let mut n2 = 4;\n    let mut result = 0;\n    for _ in 3..=n\
    \ {\n        result = n2 + (n - 1) * n1;\n        n1 = n2;\n        n2 = result;\n\
    \    }\n    result", "    if n == 1 {\n        return 2;\n    }\n    return starts_one_ends(n\
    \ - 1) + 9 * (10 as isize).pow(n - 2);", "    let mut sum = 0;\n    for i in 1..n+1\
    \ {\n        sum += starts_one_ends_helper(i);\n    }\n    sum", "    let mut\
    \ dp = vec![0; n as usize + 1];\n    dp[1] = 1;\n    for i in 2..n + 1 {\n   \
    \     dp[i as usize] = 10 * dp[(i - 1) as usize] + 10_isize.pow(i - 1);\n    }\n\
    \    dp[n as usize]", "    if n == 1 {\n        return 10;\n    }\n    let mut\
    \ prev_starts = 10;\n    let mut prev_ends = 10;\n    let mut count = prev_starts\
    \ + prev_ends;\n    for _ in 2..n + 1 {\n        let starts = prev_ends;\n   \
    \     let ends = (9 * prev_ends) + prev_starts;\n        count += starts + ends;\n\
    \        prev_starts = starts;\n        prev_ends = ends;\n    }\n    count",
  "    let mut v = vec![1; n as usize];\n    for i in 1..n {\n        v[i as usize]\
    \ = v[(i - 1) as usize] * 9 + v[i as usize - 1];\n    }\n    v[(n - 1) as usize]\
    \ * 2", "    if n == 1 {\n        1\n    } else {\n        count_ones(n - 1) +\
    \ 9 * count_ones(n - 2)\n    }", "    if n <= 0 {\n        return 0;\n    }\n\
    \    if n == 1 {\n        return 10;\n    }\n    let ones = starts_one_ends(n\
    \ - 1);\n    ones * 9 + 10i64.pow(n as u32 - 1) as isize", "    if n == 1 {\n\
    \        return 2;\n    }\n\n    let mut sum = 2;\n    let mut pow = 10;\n   \
    \ for _ in 1..n - 1 {\n        pow *= 10;\n        sum += pow + pow;\n    }\n\n\
    \    sum", "    if n == 1 {\n        return 2;\n    }\n    let mut a: isize =\
    \ 9;\n    let mut b: isize = 1;\n    let mut c: isize = 0;\n    let mut l: isize\
    \ = 1;\n    while l < n {\n        l += 1;\n        a = a * 10 - b;\n        b\
    \ = b * 9;\n        c = a + b;\n    }\n    c", "    let ones = count_ones(n);\n\
    \    let leadings = count_leadings(n);\n    ones + leadings", "    if n == 1 {\n\
    \        return 2;\n    }\n    starts_one_ends(n - 1) + count_digits(n - 1)",
  "    let mut c = 1;\n\n    for i in 1..n {\n        c = 10 * c + 1;\n    }\n\n \
    \   c * n", "    match n {\n        0 => 1,\n        1 => 1,\n        2 => 1,\n\
    \        _ => (n - 1) * (starts_one_ends(n - 1) + starts_one_ends(n - 2)),\n \
    \   }", "    if n == 1 {\n        return 1;\n    }\n\n    let (mut start, mut\
    \ end) = (0, 1);\n    for _ in 1..n {\n        start = end;\n        end = start\
    \ * 9 + (end * 10);\n    }\n\n    start + end", "    // Start with the simple\
    \ case.\n    if n <= 2 {\n        return n;\n    }\n\n    // Solve this problem\
    \ by induction.\n    let mut result = starts_one_ends(n - 1) + 9 * starts_one_ends(n\
    \ - 2);\n\n    // We have to exclude the numbers that have 1 as the second digit.\n\
    \    // This will happen when the number of digits is even.\n    if n % 2 == 0\
    \ {\n        let m = n / 2;\n        result -= 9 * starts_one_ends(m - 1) * starts_one_ends(m\
    \ - 1);\n    }\n\n    result", "    if n == 1 {\n        return 2;\n    }\n\n\
    \    let mut start = vec![1, 1];\n    let mut end = vec![1, 1];\n\n    for _ in\
    \ 2..=n {\n        start.push(end[0]);\n        end.push(start.iter().sum());\n\
    \    }\n\n    start.iter().sum()", "    use std::cmp::min;\n    // If a number\
    \ starts with 1 and is also 10^(n-1), we can't remove the\n    // starting 1.\
    \ So there is 1 number.\n    let n_ones = n - 1;\n    let n_tens = n - 1;\n  \
    \  // If a number starts with 1, but is not 10^(n-1), then we can remove the\n\
    \    // leading 1 and have a number that has n-1 digits and starts with 1. This\n\
    \    // gives us an additional 10^(n-2) numbers.\n    let extra_tens = n_tens.pow(10)\
    \ - 1;\n    // If a number does not start with 1, then we can put a 1 at the end,\n\
    \    // giving us 9 * 10^(n-2) numbers.\n    let extra_nines = (n_tens - 1).pow(9);\n\
    \    // If a number doesn't start with 1 and has 1 digit, we can't put a 1 at\n\
    \    // the end. So there are 9 numbers that don't start with 1 and only have\
    \ 1\n    // digit.\n    let extra_ones = 9;\n    // If a number ends with 1, we\
    \ can remove the ending 1 and have a number\n    // that has n-1 digits and ends\
    \ with 1. This gives us 10^(n-2) numbers.\n    let extra_endings = n_tens.pow(10);\n\
    \    // The only numbers that can have a 1 at the end and only have 1 digit is\n\
    \    // 1 itself. So we have one more number.\n    let extra_ending_ones = 1;\n\
    \    // In total, we have:\n    // 1 number that starts with 1 and is also 10^(n-1),\n\
    \    // 10^(n-2) numbers that start with 1 and aren't 10^(n-1),\n    // 9 * 10^(n-2)\
    \ numbers that don't start with 1, but have more than 1\n    // digit,\n    //\
    \ 9 numbers that don't start with 1 and only have 1 digit,\n    // 10^(n-2) numbers\
    \ that end with 1 and have more than 1 digit, and\n    // 1 number that ends with\
    \ 1 and only has 1", "    let dp = vec![vec![0; 11]; n as usize + 1];\n    dp_starts_one_ends(n,\
    \ &dp)", "    let mut start_one = 0;\n    let mut end_one = 0;\n    let mut one\
    \ = 0;\n    let mut two = 0;\n    let mut three = 0;\n    let mut four = 0;\n\
    \    let mut five = 0;\n    let mut six = 0;\n    let mut seven = 0;\n    let\
    \ mut eight = 0;\n    let mut nine = 0;\n    let mut zero = 0;\n    let mut all\
    \ = 0;\n    if n == 1 {\n        all = 1;\n    } else if n == 2 {\n        all\
    \ = 2;\n    } else if n == 3 {\n        start_one = 9;\n        end_one = 9;\n\
    \        all = 18;\n    } else if n == 4 {\n        start_one = 10;\n        end_one\
    \ = 10;\n        all = 21;\n    } else if n == 5 {\n        start_one = 100;\n\
    \        end_one = 100;\n        all = 201;\n    } else if n == 6 {\n        start_one\
    \ = 100;\n        end_one = 100;\n        all = 201;\n    } else if n == 7 {\n\
    \        start_one = 110;\n        end_one = 110;\n        all = 221;\n    } else\
    \ if n == 8 {\n        start_one = 140;\n        end_one = 140;\n        all =\
    \ 281;\n    } else if n == 9 {\n        start_one = 190;\n        end_one = 190;\n\
    \        all = 361;\n    } else if n == 10 {\n        start_one = 210;\n     \
    \   end_one = 210;\n        all = 421;\n    } else if n == 11 {\n        start_one\
    \ = 270;\n        end_one = 270;\n        all = 531;\n    } else if n == 12 {\n\
    \        start_one = 290;\n        end_one = 290;\n        all = 591;\n    } else\
    \ if n == 13 {\n        start_one = 330;\n        end_one = 330;\n        all\
    \ = 661;\n    } else if n == 14 {\n        start_one = 400;\n        end_one =\
    \ 400;\n        all = 801;", "    let mut count = 0;\n    let mut i = 1;\n   \
    \ while i <= n {\n        let (mut num_zeros, mut num_ones) = (0, 0);\n      \
    \  if i % 2 == 0 {\n            num_zeros = i / 2 - 1;\n            num_ones =\
    \ 1;\n        } else {\n            num_zeros = i / 2;\n            num_ones =\
    \ 1;\n        }\n        count += (10 as isize).pow(num_zeros) * num_ones;\n \
    \       i += 1;\n    }\n    count"]
stop_tokens:
- "\n}"
