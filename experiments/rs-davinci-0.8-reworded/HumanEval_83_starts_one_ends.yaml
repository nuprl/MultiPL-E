name: HumanEval_83_starts_one_ends
language: rs
prompt: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) ->\
  \ isize {\n"
tests: "}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
  \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n \
  \   assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
completions: ["    if n == 1 {\n        return 2;\n    }\n    let x = 10isize.pow(n\
    \ as u32 - 1);\n    starts_one_ends(n - 1) + starts_one_ends(n - 2) * (x + x /\
    \ 10)", "    if n == 1 {\n        1\n    } else {\n        starts_one_ends(n -\
    \ 1) + 10 * starts_one_ends(n - 2)\n    }", "    if n <= 1 {\n        return 0;\n\
    \    }\n    let mut res = 0;\n    for i in 1..n {\n        res += starts_one_ends(i)\
    \ + 1;\n    }\n    res", "    let mut start = 1;\n    let mut end = 0;\n    for\
    \ _ in 0..n {\n        let temp = start;\n        start = start + end;\n     \
    \   end = temp;\n    }\n    start + end", "    // The number of starts with 1.\n\
    \    let n_starts_one = starts_one(n);\n    // The number of ends with 1.\n  \
    \  let n_ends_one = starts_one(n - 1);\n    n_starts_one + n_ends_one", "    if\
    \ n == 1 {\n        return 10;\n    }\n    if n == 2 {\n        return 55;\n \
    \   }\n    let mut a = 1;\n    let mut b = 1;\n    let mut c = 0;\n    for _ in\
    \ 0..n - 2 {\n        a = c + b;\n        c = b;\n        b = a;\n    }\n    (a\
    \ + b) * 10", "    // todo: implement, using starts_one_ends_digit\n    0", " \
    \   let mut high = 9;\n    let mut low = 1;\n    for _ in 1..n {\n        high\
    \ = high * 10 + 9;\n        low = low * 10;\n    }\n    high - low + 1", '    n
    - (n / 2)', "    let mut prev = 0;\n    let mut curr = 1;\n    for _ in 0..n {\n\
    \        let next = curr + prev;\n        prev = curr;\n        curr = next;\n\
    \    }\n    2 * curr", '    (2..n + 1).fold(0, |acc, x| acc + x * 10isize.pow(x
    - 1))', "    assert!(n > 0);\n    if n == 1 {\n        return 1;\n    }\n    isize::pow(10,\
    \ n - 1) + 9 * starts_one_ends(n - 1)", "    if n == 1 {\n        return 2;\n\
    \    }\n    let mut total = 0;\n    for i in 1..n {\n        total += starts_one_ends(i)\
    \ * 9;\n    }\n    return total + 9;", "    if n <= 0 {\n        return 0;\n \
    \   }\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return\
    \ 10;\n    }\n    let mut w = 1;\n    let mut count = 10;\n    for _ in 1..n {\n\
    \        count += 9 * 10i64.pow(w - 1) as isize;\n        w += 1;\n    }\n   \
    \ count", "    let mut i = 1;\n    let mut pow = 1;\n    let mut pre = 0;\n  \
    \  while i < n {\n        pre = pow;\n        pow *= 10;\n        i += 1;\n  \
    \  }\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return\
    \ 10;\n    }\n    pow - pre + 1 + starts_one_ends(n - 1)", "    match n {\n  \
    \      1 => 2,\n        2 => 3,\n        _ => starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2),\n    }", "    if n == 1 {\n        return 1;\n    }\n    let count = starts_one_ends(n\
    \ - 1);\n    let mut count = count * 9;\n    if n >= 2 {\n        count += starts_one_ends(n\
    \ - 2);\n    }\n    count", "    if n == 1 {\n        return 10;\n    }\n\n  \
    \  let mut result = 10 * starts_one_ends(n - 1);\n    if n > 2 {\n        let\
    \ zeros = (n - 2) * 9;\n        result += 9 * starts_one_ends(zeros);\n    }\n\
    \n    result", "    if n == 1 {\n        return 10;\n    }\n    let mut a = 1;\n\
    \    let mut b = 0;\n    let mut c = 0;\n    let mut d = 1;\n    for _ in 1..n\
    \ {\n        a = b;\n        b = c;\n        c = d;\n        d = 10 * b + a;\n\
    \    }\n    c + d", "    let limit = 10_isize.pow(n as u32) - 1;\n    let mut\
    \ prev = 1;\n    let mut curr = 1;\n    let mut next = 0;\n    let mut res = 0;\n\
    \    for i in 1..limit {\n        next = (prev + curr) % limit;\n        if next\
    \ == 1 {\n            res += 1;\n        }\n        prev = curr;\n        curr\
    \ = next;\n    }\n    res"]
stop_tokens:
- "\n}"
