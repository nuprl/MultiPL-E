name: HumanEval_151_double_the_difference
language: rs
prompt: "/// Given a vector of numbers, return the sum of squares of the numbers\n\
  /// in the vector that are odd. Ignore numbers that are negative or not integers.\n\
  /// >>> double_the_difference(vec![1, 3, 2, 0])\n/// 10\n/// >>> double_the_difference(vec![-1,\
  \ -2, 0])\n/// 0\n/// >>> double_the_difference(vec![9, -2])\n/// 81\n/// >>> double_the_difference(vec![0])\n\
  /// 0\n/// If the input vector is empty, return 0.\nfn double_the_difference(lst:\
  \ Vec<f64>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()),\
  \ 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1,\
  \ 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n  \
  \  assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2,\
  \ 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0,\
  \ 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n"
completions: ['    unimplemented!()', "    let mut sum: isize = 0;\n    for i in lst\
    \ {\n        if i > 0.0 && i % 2.0 == 1.0 {\n            sum += (i * i) as isize;\n\
    \        }\n    }\n    sum", "    lst.iter()\n        .filter(|&n| {\n       \
    \     if n < &0.0 {\n                return false;\n            }\n          \
    \  let temp: f64 = n.round();\n            if temp == *n {\n                return\
    \ true;\n            }\n            return false;\n        })\n        .map(|&n|\
    \ {\n            if n % 2.0 == 0.0 {\n                return (n * n) as isize;\n\
    \            }\n            return n as isize;\n        })\n        .sum()", " \
    \   // let mut s = 0;\n    // for i in lst {\n    //     if i < 0 || i.floor()\
    \ != i {\n    //         continue;\n    //     }\n    //     if i % 2.0 == 1.0\
    \ {\n    //         s += i.powi(2) as isize;\n    //     }\n    // }\n    // s\
    \ * 2\n    // lst.iter().filter(|x| *x < 0 && x.floor() != *x).sum::<isize>()\n\
    \n    if lst.len() == 0 {\n        return 0;\n    }\n    let mut s = 0;\n    for\
    \ i in lst {\n        if i < 0 || i.floor() != i {\n            continue;\n  \
    \      }\n        if i % 2.0 == 1.0 {\n            s += i.powi(2) as isize;\n\
    \        }\n    }\n    s * 2", '    unimplemented!();', "    lst.iter()\n    \
    \    .filter(|&x| x.round() == *x && *x >= 0.0)\n        .filter(|&x| (x.round()\
    \ as isize) % 2 == 1)\n        .map(|x| (x.round() as isize).pow(2))\n       \
    \ .sum()", "    // TODO: Implement me!\n    1", '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!();', "    // TODO: Implement this function, and implement the\
    \ tests for it in tests.rs\n    return 0;", '    unimplemented!()', '    0', " \
    \   // use a for loop to iterate over the list\n    let mut sum = 0;\n    for\
    \ x in lst {\n        // modulo the number to check if it is odd\n        if x\
    \ % 2.0 == 1.0 {\n            // if so add the square of the number to our result\n\
    \            sum += x.powi(2) as isize;\n        }\n    }\n    // return the result\n\
    \    return sum;", "    // TODO: Implement this function.\n    return 0;", " \
    \   let mut sum = 0;\n    for i in lst {\n        if i.is_sign_positive() && i.fract()\
    \ == 0.0 {\n            sum += i as isize;\n        }\n    }\n    sum * 2", " \
    \   let sum_of_squares_of_odds = lst.iter().filter(|x| (x % 2) == 1).map(|x| x.powi(2)).sum();\n\
    \    (sum_of_squares_of_odds * 2) as isize", "    if lst.len() == 0 {\n      \
    \  return 0;\n    }\n    let mut sum = 0;\n    for i in lst {\n        if i %\
    \ 2.0 == 1.0 && i > 0.0 {\n            sum += i.powi(2) as isize;\n        }\n\
    \    }\n    return sum * 2;", "    if lst.len() == 0 {\n        return 0;\n  \
    \  }\n\n    let mut output = 0;\n    for i in lst {\n        if i >= 0.0 && i\
    \ == i.round() {\n            if i.round() % 2 == 1 {\n                output\
    \ += (i * i) as isize;\n            }\n        }\n    }\n    return output * 2;",
  "    let lst = lst.into_iter().filter(|x| *x >= 0.0 && *x.fract() == 0.0).collect::<Vec<f64>>();\n\
    \    if lst.len() == 0 {\n        return 0;\n    }\n    let mut res = 0;\n   \
    \ for num in lst {\n        let num = num as isize;\n        if num % 2 == 1 {\n\
    \            res += num * num;\n        }\n    }\n    return res * 2;"]
stop_tokens:
- "\n}"
