name: HumanEval_151_double_the_difference
language: rs
prompt: "/// Given a vector of numbers, return the sum of squares of the numbers\n\
  /// in the vector that are odd. Ignore numbers that are negative or not integers.\n\
  /// >>> double_the_difference(vec![1, 3, 2, 0])\n/// 10\n/// >>> double_the_difference(vec![-1,\
  \ -2, 0])\n/// 0\n/// >>> double_the_difference(vec![9, -2])\n/// 81\n/// >>> double_the_difference(vec![0])\n\
  /// 0\n/// If the input vector is empty, return 0.\nfn double_the_difference(lst:\
  \ Vec<f64>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()),\
  \ 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1,\
  \ 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n  \
  \  assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2,\
  \ 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0,\
  \ 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n"
completions: ['    unimplemented!()', "    let mut sum: isize = 0;\n    for i in lst\
    \ {\n        if i > 0.0 && i % 2.0 == 1.0 {\n            sum += (i * i) as isize;\n\
    \        }\n    }\n    sum", "    lst.iter()\n        .filter(|&n| {\n       \
    \     if n < &0.0 {\n                return false;\n            }\n          \
    \  let temp: f64 = n.round();\n            if temp == *n {\n                return\
    \ true;\n            }\n            return false;\n        })\n        .map(|&n|\
    \ {\n            if n % 2.0 == 0.0 {\n                return (n * n) as isize;\n\
    \            }\n            return n as isize;\n        })\n        .sum()", " \
    \   // let mut s = 0;\n    // for i in lst {\n    //     if i < 0 || i.floor()\
    \ != i {\n    //         continue;\n    //     }\n    //     if i % 2.0 == 1.0\
    \ {\n    //         s += i.powi(2) as isize;\n    //     }\n    // }\n    // s\
    \ * 2\n    // lst.iter().filter(|x| *x < 0 && x.floor() != *x).sum::<isize>()\n\
    \n    if lst.len() == 0 {\n        return 0;\n    }\n    let mut s = 0;\n    for\
    \ i in lst {\n        if i < 0 || i.floor() != i {\n            continue;\n  \
    \      }\n        if i % 2.0 == 1.0 {\n            s += i.powi(2) as isize;\n\
    \        }\n    }\n    s * 2", '    unimplemented!();', "    lst.iter()\n    \
    \    .filter(|&x| x.round() == *x && *x >= 0.0)\n        .filter(|&x| (x.round()\
    \ as isize) % 2 == 1)\n        .map(|x| (x.round() as isize).pow(2))\n       \
    \ .sum()", "    // TODO: Implement me!\n    1", '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!();', "    // TODO: Implement this function, and implement the\
    \ tests for it in tests.rs\n    return 0;", '    unimplemented!()', '    0', " \
    \   // use a for loop to iterate over the list\n    let mut sum = 0;\n    for\
    \ x in lst {\n        // modulo the number to check if it is odd\n        if x\
    \ % 2.0 == 1.0 {\n            // if so add the square of the number to our result\n\
    \            sum += x.powi(2) as isize;\n        }\n    }\n    // return the result\n\
    \    return sum;", "    // TODO: Implement this function.\n    return 0;", " \
    \   let mut sum = 0;\n    for i in lst {\n        if i.is_sign_positive() && i.fract()\
    \ == 0.0 {\n            sum += i as isize;\n        }\n    }\n    sum * 2", " \
    \   let sum_of_squares_of_odds = lst.iter().filter(|x| (x % 2) == 1).map(|x| x.powi(2)).sum();\n\
    \    (sum_of_squares_of_odds * 2) as isize", "    if lst.len() == 0 {\n      \
    \  return 0;\n    }\n    let mut sum = 0;\n    for i in lst {\n        if i %\
    \ 2.0 == 1.0 && i > 0.0 {\n            sum += i.powi(2) as isize;\n        }\n\
    \    }\n    return sum * 2;", "    if lst.len() == 0 {\n        return 0;\n  \
    \  }\n\n    let mut output = 0;\n    for i in lst {\n        if i >= 0.0 && i\
    \ == i.round() {\n            if i.round() % 2 == 1 {\n                output\
    \ += (i * i) as isize;\n            }\n        }\n    }\n    return output * 2;",
  "    let lst = lst.into_iter().filter(|x| *x >= 0.0 && *x.fract() == 0.0).collect::<Vec<f64>>();\n\
    \    if lst.len() == 0 {\n        return 0;\n    }\n    let mut res = 0;\n   \
    \ for num in lst {\n        let num = num as isize;\n        if num % 2 == 1 {\n\
    \            res += num * num;\n        }\n    }\n    return res * 2;", '    unimplemented!()',
  '    unimplemented!()', "    // YOUR CODE HERE\n    return 0;", "    let mut sum\
    \ = 0;\n    for n in lst {\n        if n.round() == n && n > 0.0 {\n         \
    \   sum += n.round() as isize;\n        }\n    }\n    sum * 2", "    //unimplemented!()\n\
    \    let mut sq = 0;\n    for i in lst {\n        if i > 0.0 && i.trunc() == i\
    \ {\n            if i % 2.0 == 1.0 {\n                sq += i * i;\n         \
    \   }\n        }\n    }\n    return sq as isize;", "    let mut even = 0;\n  \
    \  let mut odd = 0;\n    for i in lst.into_iter() {\n        if i.trunc() == i\
    \ {\n            if i.trunc() % 2 == 0 && i > 0 {\n                even += i.trunc()\
    \ as isize;\n            } else if i.trunc() % 2 != 0 && i > 0 {\n           \
    \     odd += i.trunc() as isize;\n            }\n        }\n    }\n    (odd -\
    \ even) * 2", "    lst.iter()\n        .filter(|n| n.fract() == 0.0 && *n > 0.0)\n\
    \        .map(|n| (n.round() as i64).pow(2))\n        .sum::<i64>() as isize",
  '    unimplemented!()', '    0', '    unimplemented!()', "    let odds = lst.iter().filter(|a|\
    \ *a as i32 % 2 == 1).map(|&a| a as isize).collect::<Vec<isize>>();\n    let evens\
    \ = lst.iter().filter(|a| *a as i32 % 2 == 0).map(|&a| a as isize).collect::<Vec<isize>>();\n\
    \    if odds.len() == 0 || evens.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut odd_sum = 0;\n    let mut even_sum = 0;\n    for i in odds {\n        odd_sum\
    \ += i;\n    }\n    for i in evens {\n        even_sum += i;\n    }\n    odd_sum\
    \ * odd_sum - even_sum * even_sum", '    unimplemented!();', "    let mut sum:\
    \ isize = 0;\n    for i in lst {\n        if i > 0f64 && i % 2f64 == 1f64 {\n\
    \            sum += i as isize;\n        }\n    }\n    sum * 2", '    0', '    0',
  "    if lst.len() == 0 {\n        return 0;\n    }\n    let mut sum = 0;\n    for\
    \ num in lst {\n        if num > 0.0 && (num as isize) % 2 == 1 {\n          \
    \  sum += (num * num) as isize;\n        }\n    }\n    return sum * 2;", "   \
    \ let mut result = 0.0;\n    for el in lst {\n        if el.floor() == el && el\
    \ >= 0.0 {\n            if el.floor() % 2.0 == 1.0 {\n                result +=\
    \ el * el;\n            }\n        }\n    }\n    (result * 2.0) as isize", " \
    \   let mut ret: isize = 0;\n    for i in lst {\n        if i.is_sign_positive()\
    \ && i.fract() == 0.0 {\n            if i % 2.0 == 1.0 {\n                ret\
    \ += i as isize;\n            }\n        }\n    }\n    return ret * 2;", "   \
    \ let mut res = 0;\n    for x in lst {\n        if (x % 2.0).abs() > 0.01 && x\
    \ > 0.0 {\n            res += (x * x) as isize;\n        }\n    }\n    res", " \
    \   // TODO\n    0", '    0', "    let mut sum = 0;\n    for i in lst {\n    \
    \    if (i % 2.0) == 1.0 && i >= 0.0 {\n            sum += i.powi(2) as isize;\n\
    \        }\n    }\n    sum * 2", "    // TODO: your code here!\n    0", "    //\
    \ TODO\n    unimplemented!()", "    let mut result = 0;\n    for x in lst {\n\
    \        if x.fract() == 0.0 && x > 0.0 {\n            if x % 2.0 == 1.0 {\n \
    \               result += (x * x) as isize;\n            }\n        }\n    }\n\
    \    result * 2", '    unimplemented!();', '    0', "    let mut double_sum =\
    \ 0;\n    for num in lst {\n        if num > 0.0 && num as isize == num {\n  \
    \          if num as isize % 2 == 1 {\n                double_sum += num as isize\
    \ * num as isize;\n            }\n        }\n    }\n    return double_sum;", '    0',
  '    unimplemented!()', "    let sum_of_squares_of_odds = lst.iter().filter(|&x|\
    \ x % 2.0 == 1.0).fold(0.0, |acc, x| x * x + acc);\n    let sum_of_squares_of_evens\
    \ = lst.iter().filter(|&x| x % 2.0 == 0.0).fold(0.0, |acc, x| x * x + acc);\n\
    \    (sum_of_squares_of_odds - sum_of_squares_of_evens) as isize", "    // First,\
    \ let's get the sum of squares of odd numbers\n    let s: f64 = lst.iter().filter(|&x|\
    \ {\n        (*x).floor() == *x\n            && *x != 0.0\n            && *x >\
    \ 0.0\n            && (*x % 2.0).floor() == 1.0\n    }).map(|x| x.powi(2)).sum();\n\
    \n    // Now, let's get the sum of squares of even numbers\n    let d: f64 = lst.iter().filter(|&x|\
    \ {\n        (*x).floor() == *x\n            && *x != 0.0\n            && *x >\
    \ 0.0\n            && (*x % 2.0).floor() == 0.0\n    }).map(|x| x.powi(2)).sum();\n\
    \n    // Now we can return their difference times 2\n    return (s - d) as isize;",
  "    // For a closed-form solution to this, we can just use the square\n    // of\
    \ the sum of the odd numbers, which we can find with the formula\n    // (2n+1)^2\
    \ = 4n^2 + 4n + 1.\n    // We can easily obtain the sum of all odd numbers in\
    \ the list\n    // by iterating through the list and summing the odd numbers and\n\
    \    // subtracting the sum of the even numbers.\n    //\n    // This is a little\
    \ more elegant in theory but it also requires\n    // iterating through the list\
    \ twice (once to get the odds and once\n    // to get the evens), which is more\
    \ of a waste of time than computing\n    // the sum of the squares of the evens\
    \ and subtracting that from the\n    // sum of the squares of the odds.\n    let\
    \ odds: f64 = lst.iter().filter(|&x| x % 2.0 != 0.0 && x % 2.0 == *x).sum();\n\
    \    let evens: f64 = lst.iter().filter(|&x| x % 2.0 == 0.0 && x % 2.0 == *x).sum();\n\
    \    (odds * odds - evens * evens) as isize", "    if lst.len() == 0 {\n     \
    \   return 0;\n    }\n\n    let mut lst: Vec<f64> = lst.into_iter().filter(|x|\
    \ x.is_sign_positive() && x.fract() == 0.0).collect();\n    lst.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n\n    return if lst.len() < 2 {\n        0\n  \
    \  } else {\n        let min = lst[0] as isize;\n        let max = lst[lst.len()\
    \ - 1] as isize;\n        2 * (max - min)\n    };", "    lst.iter()\n        .filter(|x|\
    \ *x >= 0.0 && *x % 2.0 == 1.0)\n        .map(|x| x.powi(2))\n        .sum::<f64>()\
    \ as isize", '    unimplemented!();', '    unimplemented!();', '    0', '    0',
  '    unimplemented!();', "    let mut result = 0;\n    for item in lst {\n     \
    \   if item > 0 && item.is_integer() {\n            let item = item as isize;\n\
    \            if item % 2 == 1 {\n                result += item * item;\n    \
    \        }\n        }\n    }\n    result * 2", "    let mut sum: f64 = 0.0;\n\
    \    for x in lst {\n        if x < 0.0 {\n            continue;\n        }\n\
    \        if x % 2.0 == 1.0 {\n            sum += x * x;\n        }\n    }\n  \
    \  return (sum * 2.0) as isize;", "  match lst.iter().fold(0, |acc, n| {\n   \
    \ if n.fract() != 0.0 || *n < 0.0 {\n      acc\n    } else {\n      acc + (*n\
    \ as isize).pow(2)\n    }\n  }) {\n    0 => 0,\n    a => a * 2,\n  }", "    let\
    \ mut sum: isize = 0;\n    for value in lst {\n        if value > 0. && value\
    \ % 2. == 1. {\n            sum += value as isize * value as isize;\n        }\n\
    \    }\n    sum * 2", "    let mut total = 0;\n    for number in lst {\n     \
    \   if number.is_sign_positive() && number.is_sign_positive() {\n            if\
    \ number % 2.0 == 1.0 {\n                total += number.powi(2) as isize;\n \
    \           }\n        }\n    }\n    return total * 2;", "    let mut sum = 0;\n\
    \    for i in lst {\n        if i > 0.0 && i.floor() == i {\n            sum +=\
    \ (i as i32) % 2;\n        }\n    }\n    sum * 2", '    unimplemented!()', " \
    \ let pos_ints = lst.iter().filter(|n| **n >= 0.0).filter(|n| **n % 1.0 == 0.0);\n\
    \  let odd_ints = pos_ints.filter(|n| **n % 2.0 == 1.0);\n  (odd_ints.map(|n|\
    \ n * n).sum() as isize) * 2", "    if lst.len() == 0 {\n        return 0;\n \
    \   }\n\n    let mut sum = 0;\n    for i in lst {\n        if i.floor() == i &&\
    \ i.ceil() == i && i >= 0 {\n            if i % 2 == 1 {\n                sum\
    \ += i.powi(2) as isize;\n            }\n        }\n    }\n    2 * sum", "   \
    \ let is_pos_num = |x: &f64| (x > &0.0) && (*x as i64) == *x as i64;\n    let\
    \ mut sum = 0;\n    for num in lst {\n        if is_pos_num(&num) && (num as i64)\
    \ % 2 == 1 {\n            sum += ((num as i64) * (num as i64)) as isize;\n   \
    \     }\n    }\n    sum * 2", '    unimplemented!()', "    let sum: isize = lst.iter().filter(|x|\
    \ x % 2 != 0 && x > 0).map(|x| x.pow(2) as isize).sum();\n    sum * 2", "    let\
    \ mut sum = 0;\n    for i in lst {\n        if (i > 0.0) && (i - (i as i64) as\
    \ f64) == 0.0 {\n            sum += ((i as i64) * (i as i64)) as isize;\n    \
    \    }\n    }\n    sum * 2", '    0', '    unimplemented!()', "    let mut squares\
    \ = vec![];\n    for i in lst {\n        if i.floor() == i && i >= 0.0 {\n   \
    \         squares.push(i.powi(2));\n        }\n    }\n    let mut sum = 0;\n \
    \   for i in squares {\n        sum += i as isize;\n    }\n    sum * 2", "   \
    \ // Implement function here\n    unimplemented!();", "    lst.iter()\n      \
    \  .map(|x| x.round() as isize)\n        .filter(|x| *x >= 0 && *x % 2 == 1)\n\
    \        .map(|x| x * x)\n        .sum()", '  unimplemented!()', "    // SOLUTION\n\
    \    lst.iter()\n        .filter(|x| x.is_sign_positive() && *x % 2.0 == 1.0)\n\
    \        .map(|x| (x * x) as isize)\n        .sum()", "  //YOUR CODE HERE\n  0",
  "    lst.iter()\n        .filter(|i| i.fract() == 0.0 && *i > 0.0)\n        .map(|i|\
    \ i.trunc() as isize)\n        .fold(0, |acc, i| acc + i * i) as isize", '    unimplemented!();',
  "    let result: isize = lst.iter().filter(|&x| (x % 2.0) == 1.0 && x > &0.0).map(|&x|\
    \ x as isize).sum();\n    result * 2", "    let mut res = 0;\n    for i in lst\
    \ {\n        if i.is_sign_positive() && (i % 2.0).abs() == 1.0 {\n           \
    \ res += i as isize;\n        }\n    }\n    res * 2", '    unimplemented!();',
  '    unimplemented!()', '    unimplemented!()', "    // TODO\n    0", "    let res:\
    \ isize = 0;\n    for num in lst {\n        if num > 0 && num.fract() == 0.0 {\n\
    \            if num % 2 != 0 {\n                return res + ((num * num) as isize);\n\
    \            }\n        }\n    }\n    res", "    let odds: Vec<f64> = lst.into_iter().filter(|x|\
    \ x % 2.0 == 1.0).collect();\n    let sum: f64 = odds.iter().sum();\n    (sum\
    \ * sum) as isize", '    unimplemented!()', "    // your code here\n    unimplemented!();",
  "    let mut sum = 0isize;\n    for i in lst {\n        if i % 2.0 != 0.0 && i >\
    \ 0.0 {\n            sum += (i * i) as isize;\n        }\n    }\n    sum * 2",
  '    0', "    return lst.iter().fold(0, |sum, x| {\n        if (*x).floor() != *x\
    \ || *x < 0.0 {\n            return sum;\n        }\n        if (*x as isize)\
    \ % 2 == 0 {\n            return sum;\n        }\n        return sum + (*x as\
    \ isize) * (*x as isize);\n    }) as isize;", "    // TODO 2\n    unimplemented!()",
  "    let mut sum = 0;\n    for x in lst {\n        if x.is_sign_positive() && x.fract()\
    \ == 0.0 {\n            sum += (x as isize) * (x as isize);\n        }\n    }\n\
    \    return sum * 2;", '    unimplemented!()', '    unimplemented!();', '    unimplemented!();',
  '    0', '    unimplemented!();', "    lst.iter()\n        .filter(|n| **n as isize\
    \ % 2 == 1)\n        .fold(0, |acc, x| (x.powi(2) as isize + acc) - x.powi(2)\
    \ as isize)", "    let odds: Vec<_> = lst.iter().filter(|&n| n.fract() == 0.0\
    \ && n.is_sign_positive() && n % 2.0 == 1.0).collect();\n    let evens: Vec<_>\
    \ = lst.iter().filter(|&n| n.fract() == 0.0 && n.is_sign_positive() && n % 2.0\
    \ == 0.0).collect();\n    let odds_squared: Vec<_> = odds.iter().map(|&n| n *\
    \ n).collect();\n    let evens_squared: Vec<_> = evens.iter().map(|&n| n * n).collect();\n\
    \    if odds_squared.len() == 0 || evens_squared.len() == 0 {\n        return\
    \ 0;\n    }\n    let odds_sum: f64 = odds_squared.iter().sum();\n    let evens_sum:\
    \ f64 = evens_squared.iter().sum();\n    (odds_sum - evens_sum).round() as isize",
  "    match lst.is_empty() {\n        true => 0,\n        false => {\n          \
    \  let difference = lst.iter().filter(|&x| (x % 2.0) == 1.0).fold(0.0, |acc, x|\
    \ acc + x.powi(2)) as isize;\n            return difference * 2;\n        }\n\
    \    }", "    let mut result = 0;\n    for x in lst {\n        if (x % 2.0 ==\
    \ 1.0) && (x > 0.0) {\n            result += (x * x) as isize;\n        }\n  \
    \  }\n    result", "    let mut sum = 0;\n    for num in lst {\n        if num.fract()\
    \ != 0.0 && num.is_sign_positive() {\n            if num % 2.0 != 0.0 {\n    \
    \            sum += num.powi(2) as isize;\n            }\n        }\n    }\n \
    \   sum * 2", '    unimplemented!();', "    let mut _sum = 0;\n    for _num in\
    \ lst {\n        if _num.is_sign_positive() && _num.fract() == 0.0 {\n       \
    \     _sum += (_num % 2.0) as isize;\n        }\n    }\n    _sum * 2", "    //\n\
    \    0", "    let mut x = 0;\n    let mut y = 0;\n    for elem in lst {\n    \
    \    if elem > 0.0 && elem.floor() == elem {\n            if elem % 2.0 == 1.0\
    \ {\n                x += elem as isize;\n            } else {\n             \
    \   y += elem as isize;\n            }\n        }\n    }\n    if x == 0 {\n  \
    \      return 0;\n    } else {\n        return (x - y) * 2;\n    }", "    lst.iter()\n\
    \        .filter(|i| i.is_sign_positive() && i.is_integer())\n        .map(|i|\
    \ i.powi(2))\n        .sum::<f64>() as isize", "    // Find the difference between\
    \ the odd and even elements of the\n    // list, then double the result.\n   \
    \ if lst.len() == 0 {\n        return 0;\n    }\n    let mut difference = 0;\n\
    \    for i in 0..lst.len() {\n        if lst[i] % 2.0 == 1.0 {\n            difference\
    \ += lst[i] as isize;\n        } else {\n            difference -= lst[i] as isize;\n\
    \        }\n    }\n    return difference * 2;", "    let mut sum = 0;\n    for\
    \ num in lst {\n        if num.trunc() == num && num.trunc() % 2.0 == 1.0 {\n\
    \            sum += (num * num) as isize;\n        }\n    }\n    2 * sum", '    unimplemented!()',
  '    panic!("unimplemented")', "    let square_sum = lst.iter().filter(|&num| (*num\
    \ % 2.) != 0.0 && *num > 0.0)\n        .map(|&num| num * num)\n        .fold(0f64,\
    \ |acc, x| acc + x);\n    (square_sum * 2.) as isize", '    unimplemented!()',
  "    lst.iter()\n        .filter(|&e| f64::round(*e) - *e == 0.0 && *e >= 0.0)\n\
    \        .map(|&e| e as isize)\n        .filter(|&e| e % 2 == 1)\n        .map(|e|\
    \ e * e)\n        .sum()", "    let mut sum = 0;\n    for i in lst {\n       \
    \ if i.floor() == i && i.is_sign_positive() {\n            if i % 2.0 == 1.0 {\n\
    \                sum += i as isize;\n            }\n        }\n    }\n    2 *\
    \ sum", "    let mut odd_sum = 0;\n    for i in lst {\n        if i % 2.0 == 1.0\
    \ && i >= 0.0 {\n            odd_sum += i * i;\n        }\n    }\n    odd_sum\
    \ * 2", "    let mut sum = 0;\n    for num in lst {\n        if num.is_sign_positive()\
    \ && num % 2.0 == 1.0 {\n            sum += (num * num) as isize;\n        }\n\
    \    }\n    sum * 2", '    unimplemented!()', '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!();', "    let mut lst = lst;\n    lst.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut difference = 0;\n    let mut i = 1;\n    let mut j = 0;\n    while\
    \ j < lst.len() && i < lst.len() {\n        if lst[i] < 0.0 || lst[i] > lst[i].floor()\
    \ {\n            lst.remove(i);\n        } else if lst[j] < 0.0 || lst[j] > lst[j].floor()\
    \ {\n            lst.remove(j);\n        } else if (lst[i] - lst[j]).abs() ==\
    \ 0.0 {\n            j += 1;\n            i += 1;\n        } else if (lst[i] -\
    \ lst[j]).abs() < 1.0 {\n            difference += (lst[i] - lst[j]).abs() as\
    \ isize;\n            j += 1;\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    difference * 2", "    // YOUR CODE HERE\n\
    \    unimplemented!()", '    0', "    let mut sum: isize = 0;\n    for num in\
    \ lst {\n        if num.round() == num && num > 0.0 {\n            let rounded_num\
    \ = num.round() as isize;\n            if rounded_num % 2 == 1 {\n           \
    \     sum += rounded_num.pow(2);\n            }\n        }\n    }\n    sum * 2",
  "    let squares: Vec<isize> = lst.iter().map(|x| x.floor() as isize).filter(|x|\
    \ x % 2 != 0).map(|x| x * x).collect();\n    return squares.iter().sum();", '    0',
  '    unimplemented!();', '    unimplemented!();', "    // TODO: Implement the function\
    \ here\n    0", "  let lst = lst.into_iter().filter(|n| n.is_sign_positive() &&\
    \ n.is_integer());\n  lst.filter(|n| (n as isize) % 2 == 1).fold(0, |acc, n| acc\
    \ + (n * n) as isize) as isize", '    unimplemented!();', '    return 0;', " \
    \   let mut sum: isize = 0;\n    for x in lst {\n        if (x as isize) % 2 ==\
    \ 1 {\n            sum += x.powi(2) as isize;\n        }\n    }\n    sum * 2",
  "    let sum_of_square_of_odds =\n        lst.iter()\n           .filter(|&x| (x\
    \ % 2.0).abs() == 1.0 && x.is_normal())\n           .map(|x| x * x)\n        \
    \   .sum::<f64>();\n    return (sum_of_square_of_odds * 2.0) as isize;", "   \
    \ // REPLACE THIS LINE WITH YOUR CODE\n    0", "    let mut sum = 0;\n    for\
    \ x in lst {\n        if x.is_sign_positive() && x.is_integer() {\n          \
    \  sum += x as isize;\n        }\n    }\n    sum", '    unimplemented!();', " \
    \   lst.iter()\n        .filter(|&num| num.is_sign_positive() && num.fract() ==\
    \ 0.0)\n        .filter(|&num| num % 2.0 == 1.0)\n        .map(|&num| num * num)\n\
    \        .sum::<f64>() as isize", "    let mut total = 0;\n    for e in lst {\n\
    \        if e > 0.0 && e.trunc() == e {\n            if e % 2.0 == 1.0 {\n   \
    \             total += e as isize * e as isize;\n            }\n        }\n  \
    \  }\n    total", "    lst.iter()\n        .map(|&x| if x.is_sign_positive() &&\
    \ x.fract() == 0.0 {\n                           (x as isize).pow(2)\n       \
    \                } else {\n                           0\n                    \
    \   })\n        .sum()", '    0', "    let sum: isize = lst.iter().map(|x| {\n\
    \        if *x % 2.0 == 1.0 && *x > 0.0 {\n            (*x * *x) as isize\n  \
    \      } else {\n            0\n        }\n    }).sum();\n    sum * 2", "    let\
    \ mut sum: isize = 0;\n    for i in lst {\n        if (i % 2.0) == 1.0 && i >\
    \ 0.0 {\n            sum += (i * i) as isize;\n        }\n    }\n    sum", '    0',
  '    unimplemented!();', "    let mut result = 0;\n    for num in lst {\n      \
    \  if num > 0f64 && num as isize as f64 == num {\n            result += (num as\
    \ isize - 1) * (num as isize - 1);\n        }\n    }\n    result", "    let mut\
    \ total = 0;\n    for i in lst {\n        let mut j = i % 2.0;\n        if j !=\
    \ 0.0 {\n            total += i * i;\n        }\n    }\n    return (total * 2)\
    \ as isize;", "    let mut sum = 0;\n    for n in lst {\n        if n.is_sign_positive()\
    \ && n.fract() == 0.0 {\n            sum += n as isize;\n        }\n    }\n  \
    \  (sum - sum * 2) as isize", '    return 0;', '    0', '  unimplemented!();',
  "    let mut sum = 0;\n    for i in lst {\n        if i.is_sign_positive() && i.fract()\
    \ == 0.0 {\n            sum += i as isize;\n        }\n    }\n    sum", '    unimplemented!()',
  "    let mut result = 0;\n    for n in lst {\n        let n_int = n as isize;\n\
    \        if n_int >= 0 && n_int % 2 == 1 {\n            result += n_int * n_int;\n\
    \        }\n    }\n    result * 2", "    let mut sum = 0;\n    for num in lst\
    \ {\n        if num.trunc() == num && num > 0.0 {\n            if num.trunc()\
    \ % 2.0 == 1.0 {\n                sum += num.powi(2) as isize;\n            }\n\
    \        }\n    }\n    sum * 2", "  let mut positive_ints = lst.into_iter().filter(|x|\
    \ (*x).is_sign_positive() && (*x).is_integer());\n  let sum_of_squares =  positive_ints.map(|x|\
    \ x.powi(2)).sum::<f64>();\n  let sum_of_odd_squares =  positive_ints.filter(|x|\
    \ (*x) % 2.0 != 0.0).map(|x| x.powi(2)).sum::<f64>();\n  ((sum_of_squares - sum_of_odd_squares)\
    \ * 2.0) as isize", "    let mut count = 0;\n    let mut ans = 0;\n    for num\
    \ in lst {\n        if num < 0.0 {\n            continue;\n        }\n       \
    \ let ipart = num.trunc();\n        if ipart != num {\n            continue;\n\
    \        }\n        let ipart: isize = ipart as isize;\n        if ipart % 2 ==\
    \ 1 {\n            ans += ipart * ipart;\n            count += 1;\n        }\n\
    \    }\n    count * ans", '    0', "    let odds = lst.iter().filter(|&v| v.fract()\
    \ == 0.0 && *v > 0.0 && *v % 2.0 == 1.0);\n    let squares = odds.map(|&v| v.powi(2));\n\
    \    let sum = squares.sum::<f64>();\n    (sum * 2.0) as isize", "    // TODO:\
    \ Implement solution\n    let mut sum = 0;\n    for num in lst {\n        if num.fract()\
    \ == 0.0 && num > 0.0 {\n            sum += (num * num) as isize;\n        }\n\
    \    }\n    sum * 2", "    // The isize type indicates a signed integer that has\
    \ a size of 64 bits\n    // on most systems. It is one of the primitive integral\
    \ types, i.e. it\n    // is represented by the Rust keyword \"isize\". For this\
    \ task, we convert\n    // a vector of floating point numbers to a vector of integers.\n\
    \    let nums = lst.iter().filter_map(|&x| {\n        if x.is_sign_positive()\
    \ && x.fract() == 0.0 {\n            Some(x as isize)\n        } else {\n    \
    \        None\n        }\n    }).collect::<Vec<isize>>();\n\n    let difference\
    \ = nums.iter().fold(0, |acc, &x| acc + x);\n    return difference * 2;", "  \
    \  let mut sum = 0;\n    for i in lst {\n        if (i % 2.0 != 0.0) && (i.is_sign_positive())\
    \ && (i.floor() == i) {\n            sum += i as isize;\n        }\n    }\n  \
    \  sum * 2", '    unimplemented!()', "    lst.iter()\n        .filter(|n| n.is_sign_positive()\
    \ && n.floor() == *n)\n        .map(|n| n.powi(2))\n        .fold(0, |acc, x|\
    \ acc + x as isize)\n        * 2", "    let mut sum = 0;\n    for i in &lst {\n\
    \        if i < &0.0 {\n            continue;\n        }\n        if i.floor()\
    \ == *i {\n            if i.floor() % 2.0 == 1.0 {\n                sum += i.powi(2)\
    \ as isize;\n            }\n        }\n    }\n    sum * 2", "    let mut sum =\
    \ 0;\n    for i in lst {\n        if i.fract() != 0.0 && i > 0.0 {\n         \
    \   sum += (i as isize).pow(2);\n        }\n    }\n    sum * 2", '    unimplemented!()',
  '    unimplemented!()', "    // fn double_the_difference(lst: Vec<f64>) -> isize\
    \ {\n    //     let mut return_val = 0;\n    //     for num in lst {\n    // \
    \        if num.is_sign_positive() && num.is_sign_positive() {\n    //       \
    \      if num.trunc() == num {\n    //                 return_val += (num * num)\
    \ as isize;\n    //             }\n    //         }\n    //     }\n    //    \
    \ return_val * 2\n    // }\n    return lst.iter().fold(0, |acc, num| {\n     \
    \   if num.is_sign_positive() && num.is_sign_positive() {\n            if num.trunc()\
    \ == *num {\n                acc + (*num * *num) as isize\n            } else\
    \ {\n                acc\n            }\n        } else {\n            acc\n \
    \       }\n    }) * 2;", "    let mut result = 0;\n    for item in lst {\n   \
    \     if f64::fract(item) == 0.0 && item > 0.0 {\n            if item % 2.0 ==\
    \ 1.0 {\n                result += (item * item) as isize;\n            }\n  \
    \      }\n    }\n    result * 2", "    let mut sum = 0;\n    for i in lst {\n\
    \        if (i % 2.0) == 1.0 && i >= 0.0 {\n            sum += i as isize * i\
    \ as isize;\n        }\n    }\n    sum * 2", '    0', "    // YOUR CODE HERE\n\
    \    unimplemented!()", "    let mut odds = 0;\n    for item in lst {\n      \
    \  if is_odd(item) {\n            odds += item;\n        }\n    }\n    2 * (odds\
    \ - lst.len() as f64) as isize", '    unimplemented!();', "    // YOUR CODE HERE\n\
    \    let mut sum: isize = 0;\n    for i in lst {\n        if (i > 0.0) && (i.is_sign_positive())\
    \ && (i.fract() == 0.0) {\n            sum += i as isize;\n        }\n    }\n\
    \    sum * sum", "    let mut result = 0;\n    for i in lst {\n        if (i %\
    \ 2.0) == 1.0 && i > 0.0 {\n            result += (i * i) as isize;\n        }\n\
    \    }\n    result * 2", '    unimplemented!()', "    let mut sum: isize = 0;\n\
    \    for num in lst {\n        if num % 2.0 == 1.0 && num.is_normal() {\n    \
    \        sum += (num as isize) * (num as isize);\n        }\n    }\n    sum",
  "    let mut sum = 0;\n    for i in lst {\n        if i.trunc() == i && i > 0.0\
    \ {\n            if i % 2.0 == 1.0 {\n                sum += (i * i) as isize;\n\
    \            }\n        }\n    }\n    sum * 2", "    // your code here\n    unimplemented!();",
  '    unimplemented!();', "    let mut new_list: Vec<f64> = vec![];\n    for i in\
    \ lst {\n        if i.floor() != i || i < 0.0 {\n            continue;\n     \
    \   }\n        if i.floor() % 2.0 == 0.0 {\n            new_list.push(i * i);\n\
    \        }\n    }\n    new_list.iter().fold(0.0, |sum, &x| sum + x) as isize",
  "    lst.iter()\n        .filter(|&n| (n % 2.0 == 1.0) && (*n > 0.0))\n        .map(|&n|\
    \ (n * n) as isize)\n        .sum()", "    let mut sum = 0.0;\n    for x in lst\
    \ {\n        if x.is_sign_positive() && x.fract() == 0.0 {\n            sum +=\
    \ x.powi(2);\n        }\n    }\n    (sum * 2.0) as isize", "    lst.iter()\n \
    \       .filter(|&x| x.is_integer() && x.round() > 0.0)\n        .map(|x| x.round()\
    \ as isize)\n        .fold(0, |sum, x| sum + x.pow(2))", '    0', "    let mut\
    \ total: isize = 0;\n    for num in lst {\n        if num.floor() != num || num\
    \ < 0.0 {\n            continue;\n        } else if num % 2.0 == 1.0 {\n     \
    \       total += (num * num) as isize;\n        }\n    }\n    return total * 2;",
  "    let mut sum = 0;\n    for i in lst {\n        if (i - i.floor()).abs() < 1e-8\
    \ && i.floor() % 2.0 == 1.0 {\n            sum += (i.floor() as isize).pow(2);\n\
    \        }\n    }\n    return sum;", "    // YOUR CODE HERE\n    0", '    0',
  '    unimplemented!();', "    let positive_odds = lst.iter().filter(|&n| n.is_sign_positive()\
    \ && n.is_integer() && n.is_odd()).collect::<Vec<_>>();\n    let sum_of_squares\
    \ = positive_odds.iter().map(|&n| n.powi(2)).fold(0.0, |acc, x| acc + x);\n  \
    \  (sum_of_squares * 2.0) as isize"]
stop_tokens:
- "\n}"
