name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    let xored = xor(Vec::from(a.as_bytes()), Vec::from(b.as_bytes()));\n\
    \    String::from_utf8(xored).unwrap()", "    let a_bytes = a.into_bytes();\n\
    \    let b_bytes = b.into_bytes();\n    let c_bytes = xor(&a_bytes, &b_bytes);\n\
    \    String::from_utf8(c_bytes).unwrap()", "    let mut result = String::new();\n\
    \    let n = a.len();\n    assert_eq!(n, b.len());\n    for i in 0..n {\n    \
    \    let bit_a = a.chars().nth(i).unwrap();\n        let bit_b = b.chars().nth(i).unwrap();\n\
    \        let bit_c = match (bit_a, bit_b) {\n            ('0', '0') => '0',\n\
    \            ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"invalid input\"),\n        };\n    \
    \    result.push(bit_c);\n    }\n    result", "    a.into_bytes()\n        .iter()\n\
    \        .zip(b.into_bytes().iter())\n        .map(|(x, y)| x ^ y)\n        .map(|i|\
    \ i.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\")", " \
    \   let mut out = Vec::with_capacity(a.len());\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        out.push(match (c1, c2) {\n            ('0', '0') => '0',\n     \
    \       ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"invalid input\"),\n        });\n   \
    \ }\n    out.iter().collect()", "    let mut a = a.into_bytes();\n    let mut\
    \ b = b.into_bytes();\n    let mut max_size = a.len();\n    if b.len() > max_size\
    \ {\n        max_size = b.len();\n    }\n    let mut res = Vec::with_capacity(max_size);\n\
    \    for i in 0..max_size {\n        let (a_byte, b_byte) = if i >= a.len() {\n\
    \            (0, b[i])\n        } else if i >= b.len() {\n            (a[i], 0)\n\
    \        } else {\n            (a[i], b[i])\n        };\n        let out = match\
    \ (a_byte, b_byte) {\n            (48, 48) => String::from(\"0\"),\n         \
    \   (48, 49) => String::from(\"1\"),\n            (49, 48) => String::from(\"\
    1\"),\n            (49, 49) => String::from(\"0\"),\n            (_, _) => panic!(\"\
    WAT?\"),\n        };\n        res.push(out.as_bytes()[0]);\n    }\n    return\
    \ String::from_utf8(res).unwrap();", "    let mut ret = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        let x = c1.to_digit(2).unwrap()\
    \ ^ c2.to_digit(2).unwrap();\n        ret.push_str(&x.to_string());\n    }\n \
    \   ret", "    let a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8> = b.into_bytes();\n\
    \    let c: Vec<u8> = a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect();\n\
    \    String::from_utf8(c).unwrap()", "    let mut result = String::new();\n  \
    \  for (c1, c2) in a.chars().zip(b.chars()) {\n        let v1 = c1.to_digit(10).unwrap();\n\
    \        let v2 = c2.to_digit(10).unwrap();\n        result.push_str(&(v1 ^ v2).to_string());\n\
    \    }\n    result", "    if a.len() != b.len() {\n        return String::from(\"\
    error\");\n    }\n    let mut r = String::new();\n    for c in a.chars().zip(b.chars())\
    \ {\n        r.push(match c {\n            (x, y) if x == y => '0',\n        \
    \    _ => '1',\n        });\n    }\n    r", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(l, r)| if l == r { '0' } else { '1' })\n        .collect()", " \
    \   let x = hex::decode(a).unwrap();\n    let y = hex::decode(b).unwrap();\n \
    \   hex::encode(xor(&x, &y))", "    let mut result = String::new();\n    for (i,\
    \ j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n     \
    \       ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => '0',\n      \
    \  });\n    }\n    result", "    let mut result = String::new();\n    let a =\
    \ a.as_bytes();\n    let b = b.as_bytes();\n    for (a, b) in a.iter().zip(b.iter())\
    \ {\n        result.push(format!(\"{:x}\", a ^ b)[3..4].to_string());\n    }\n\
    \    result", '    unimplemented!();', "    let mut binary = String::new();\n\
    \    let a_chars: Vec<char> = a.chars().collect();\n    let b_chars: Vec<char>\
    \ = b.chars().collect();\n    for i in 0..a_chars.len() {\n        if a_chars[i]\
    \ == b_chars[i] {\n            binary.push('0');\n        } else {\n         \
    \   binary.push('1');\n        }\n    }\n    binary", "    let mut res = String::new();\n\
    \    for (i, j) in a.chars().zip(b.chars()) {\n        res.push(if i == j { '0'\
    \ } else { '1' });\n    }\n    res", "    let a_bytes = a.into_bytes();\n    let\
    \ b_bytes = b.into_bytes();\n    let length = a_bytes.len();\n    let mut output\
    \ = Vec::with_capacity(length);\n    for i in 0..length {\n        let result\
    \ = a_bytes[i] ^ b_bytes[i];\n        output.push(result);\n    }\n    String::from_utf8(output).unwrap()",
  "    if a.len() != b.len() {\n        panic!(\"Sizes do not match!\");\n    }\n\
    \    let mut output = Vec::new();\n    for (bit_a, bit_b) in a.chars().zip(b.chars())\
    \ {\n        if bit_a == bit_b {\n            output.push('0');\n        } else\
    \ {\n            output.push('1');\n        }\n    }\n    return output.iter().collect();",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(if a == b { '0' } else { '1' });\n    }\n    result",
  "    let mut a_chars = a.chars();\n    let mut b_chars = b.chars();\n    let mut\
    \ xor_str = String::new();\n    loop {\n        let a_char = a_chars.next();\n\
    \        let b_char = b_chars.next();\n        match (a_char, b_char) {\n    \
    \        (Some(a_char), Some(b_char)) => {\n                xor_str.push(match\
    \ (a_char, b_char) {\n                    ('0', '0') => '0',\n               \
    \     ('0', '1') => '1',\n                    ('1', '0') => '1',\n           \
    \         ('1', '1') => '0',\n                    _ => unreachable!(),\n     \
    \           });\n            }\n            (None, None) => break,\n         \
    \   _ => panic!(),\n        }\n    }\n    xor_str", "    let mut v1 = a.chars().map(|c|\
    \ c.to_digit(10).unwrap());\n    let mut v2 = b.chars().map(|c| c.to_digit(10).unwrap());\n\
    \    let mut v = Vec::new();\n    while let (Some(x), Some(y)) = (v1.next(), v2.next())\
    \ {\n        v.push(x ^ y);\n    }\n    v.iter().map(|&i| i.to_string()).collect()",
  "    let mut bin_a = String::new();\n    let mut bin_b = String::new();\n    let\
    \ mut res = String::new();\n\n    for i in a.chars() {\n        bin_a.push(i);\n\
    \    }\n    for i in b.chars() {\n        bin_b.push(i);\n    }\n\n    for i in\
    \ 0..bin_a.len() {\n        if bin_a.chars().nth(i) == bin_b.chars().nth(i) {\n\
    \            res.push('0');\n        } else {\n            res.push('1');\n  \
    \      }\n    }\n\n    res", "    assert_eq!(a.len(), b.len());\n    assert!(a.is_ascii());\n\
    \    assert!(b.is_ascii());\n    assert!(a.len() > 0);\n    let mut res = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n         \
    \   res.push('0');\n        } else {\n            res.push('1');\n        }\n\
    \    }\n    res", "    a.chars()\n        .zip(b.chars())\n        .map(|(x, y)|\
    \ (x, y).into())\n        .collect()", "    let mut result = \"\".to_string();\n\
    \    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let mut res = String::new();\n    for (x,\
    \ y) in a.chars().zip(b.chars()) {\n        res.push(match (x, y) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Both a and\
    \ b must be string with only 1s and 0s\"),\n        });\n    }\n    res", "  \
    \  assert_eq!(a.len(), b.len());\n    let mut xor = String::new();\n    for (ab,\
    \ bb) in a.chars().zip(b.chars()) {\n        match (ab, bb) {\n            ('0',\
    \ '0') => xor.push('0'),\n            ('0', '1') => xor.push('1'),\n         \
    \   ('1', '0') => xor.push('1'),\n            ('1', '1') => xor.push('0'),\n \
    \           _ => panic!(\"Invalid input found.\"),\n        }\n    }\n    xor",
  "    let as_bytes = a.into_bytes();\n    let bs_bytes = b.into_bytes();\n    let\
    \ mut result = Vec::new();\n    let mut index = 0;\n    while index < as_bytes.len()\
    \ {\n        let a_byte = as_bytes[index];\n        let b_byte = bs_bytes[index];\n\
    \        let result_byte = a_byte ^ b_byte;\n        result.push(result_byte);\n\
    \        index += 1;\n    }\n    let result_string = String::from_utf8(result).unwrap();\n\
    \    result_string", "    if a.len() == b.len() {\n        a.chars()\n       \
    \     .zip(b.chars())\n            .map(|(a, b)| if a == b { '0' } else { '1'\
    \ })\n            .collect()\n    } else {\n        panic!(\"Strings must be of\
    \ equal length.\");\n    }", "    let a = a.chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n\
    \    let b = b.chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n\
    \    let mut r = String::new();\n    for i in 0..a.len() {\n        let xor =\
    \ a[i] ^ b[i];\n        r.push_str(&xor.to_string());\n    }\n    r", "    let\
    \ n = a.len();\n    let m = b.len();\n    let mut res = String::new();\n    if\
    \ n != m {\n        panic!(\"invalid inputs\");\n    }\n    for i in 0..n {\n\
    \        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n       \
    \     res.push('0');\n        } else {\n            res.push('1');\n        }\n\
    \    }\n    res", '    unimplemented!();', "    // TODO\n    let len = a.len();\n\
    \    let mut result = String::new();\n    for i in 0..len {\n        let x = a.chars().nth(i).unwrap();\n\
    \        let y = b.chars().nth(i).unwrap();\n        if x == y {\n           \
    \ result.push('0');\n        } else {\n            result.push('1');\n       \
    \ }\n    }\n    result", "    let mut result = \"\".to_string();\n    for (i,\
    \ j) in a.chars().zip(b.chars()) {\n        let mut xor = i.to_digit(10).unwrap()\
    \ ^ j.to_digit(10).unwrap();\n        result.push_str(&xor.to_string());\n   \
    \ }\n    result", "    let result = (0..a.len())\n        .map(|i| {\n       \
    \     let a_bit = a.chars().nth(i).unwrap();\n            let b_bit = b.chars().nth(i).unwrap();\n\
    \            (a_bit, b_bit)\n        })\n        .map(|(a_bit, b_bit)| {\n   \
    \         let a_bit = a_bit.to_digit(10).unwrap();\n            let b_bit = b_bit.to_digit(10).unwrap();\n\
    \            format!(\"{}\", a_bit ^ b_bit)\n        })\n        .collect::<String>();\n\
    \    result", "    let mut ret = String::new();\n    let mut a_iter = a.chars();\n\
    \    let mut b_iter = b.chars();\n    while let (Some(a_digit), Some(b_digit))\
    \ = (a_iter.next(), b_iter.next()) {\n        ret.push(match (a_digit, b_digit)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"\
    malformed input string\"),\n        });\n    }\n    ret", "    a.chars()\n   \
    \     .zip(b.chars())\n        .map(|(x, y)| if x == y { '0' } else { '1' })\n\
    \        .collect()", "    if a.len() != b.len() {\n        panic!(\"Inputs are\
    \ not equal length\");\n    }\n    a.chars()\n        .zip(b.chars())\n      \
    \  .map(|(a, b)| {\n            if a == b {\n                '0'\n           \
    \ } else {\n                '1'\n            }\n        })\n        .collect()",
  "    let a = a.chars().collect::<Vec<char>>();\n    let b = b.chars().collect::<Vec<char>>();\n\
    \    let mut result = Vec::new();\n    let c = a.len().min(b.len());\n    for\
    \ i in 0..c {\n        let x = a[i].to_digit(10).unwrap();\n        let y = b[i].to_digit(10).unwrap();\n\
    \        result.push((x ^ y).to_string());\n    }\n    result.join(\"\")", " \
    \   let a = bin2int(a);\n    let b = bin2int(b);\n    int2bin(a ^ b)", "    a.bytes()\n\
    \        .zip(b.bytes())\n        .map(|(a, b)| (a ^ b).to_string())\n       \
    \ .collect::<Vec<String>>()\n        .join(\"\")", "    let mut res = String::new();\n\
    \    let mut last_a = '0';\n    let mut last_b = '0';\n    let mut i = 0;\n  \
    \  while i < a.len() || i < b.len() {\n        if i < a.len() {\n            last_a\
    \ = a.chars().nth(i).unwrap();\n        }\n        if i < b.len() {\n        \
    \    last_b = b.chars().nth(i).unwrap();\n        }\n        let c = if last_a\
    \ == last_b {\n            '0'\n        } else {\n            '1'\n        };\n\
    \        res.push(c);\n        i += 1;\n    }\n    res", "    let mut a_chars\
    \ = a.chars();\n    let mut b_chars = b.chars();\n    let mut result = String::new();\n\
    \    loop {\n        let a_c = a_chars.next();\n        let b_c = b_chars.next();\n\
    \        if a_c.is_none() || b_c.is_none() {\n            break;\n        }\n\
    \        let a_c = a_c.unwrap();\n        let b_c = b_c.unwrap();\n        if\
    \ a_c == b_c {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let a_bytes = a.into_bytes();\n    let b_bytes\
    \ = b.into_bytes();\n    let res = a_bytes\n        .iter()\n        .zip(b_bytes.iter())\n\
    \        .map(|(x, y)| *x ^ *y)\n        .collect::<Vec<u8>>();\n    String::from_utf8(res).unwrap()",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(x, y)| ((x == '1') ^ (y\
    \ == '1')).to_string())\n        .collect()", '    unimplemented!()', "    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    let mut result:\
    \ String = String::new();\n    loop {\n        let a_val = a_iter.next();\n  \
    \      let b_val = b_iter.next();\n        match (a_val, b_val) {\n          \
    \  (Some(a), Some(b)) => {\n                if a == b {\n                    result.push('0');\n\
    \                } else {\n                    result.push('1');\n           \
    \     }\n            }\n            (Some(_), None) => {\n                result.push('0');\n\
    \            }\n            (None, Some(_)) => {\n                result.push('0');\n\
    \            }\n            (None, None) => {\n                break;\n      \
    \      }\n        }\n    }\n    result", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    a.chars()\n        .zip(b.chars())\n    \
    \    .map(|(a, b)| match (a == '1', b == '1') {\n            (true, true) => '0',\n\
    \            (false, false) => '0',\n            _ => '1',\n        })\n     \
    \   .collect()", '    format!("{:b}", a.parse::<u32>().unwrap() ^ b.parse::<u32>().unwrap())',
  "    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    assert_eq!(a_bytes.len(),\
    \ b_bytes.len());\n    let mut result = String::new();\n    for i in 0..a_bytes.len()\
    \ {\n        let a_chr = a_bytes[i];\n        let b_chr = b_bytes[i];\n      \
    \  result.push(if a_chr == b_chr { '0' } else { '1' });\n    }\n    result", " \
    \   let mut result = String::new();\n    let a_vec: Vec<u8> = a.into_bytes();\n\
    \    let b_vec: Vec<u8> = b.into_bytes();\n    for i in 0..a_vec.len() {\n   \
    \     let result_char = (a_vec[i] ^ b_vec[i]) as char;\n        result.push(result_char);\n\
    \    }\n    result", "    let mut res = Vec::new();\n    let mut a_iter = a.chars();\n\
    \    let mut b_iter = b.chars();\n    while let (Some(a_c), Some(b_c)) = (a_iter.next(),\
    \ b_iter.next()) {\n        res.push(\n            if a_c == b_c {\n         \
    \       '0'\n            } else {\n                '1'\n            }\n      \
    \  );\n    }\n    res.iter().collect()", "    let mut result = String::from(\"\
    \");\n    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let s: String = a\n        .chars()\n   \
    \     .zip(b.chars())\n        .map(|(ac, bc)| if ac == bc { '0' } else { '1'\
    \ })\n        .collect();\n    String::from(s)", "    if a.len() != b.len() {\n\
    \        return String::from(\"\");\n    }\n    let mut new_str = String::new();\n\
    \    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            new_str.push('0');\n        } else {\n            new_str.push('1');\n\
    \        }\n    }\n    new_str", "    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(char::from(digit_xor(i,\
    \ j)));\n    }\n    result", "    let a = a.into_bytes();\n    let b = b.into_bytes();\n\
    \    let res = a.iter().zip(b.iter()).map(|(&x, &y)| x ^ y).collect::<Vec<u8>>();\n\
    \    String::from_utf8(res).unwrap()", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(c1, c2)| (c1 == '1') ^ (c2 == '1'))\n        .map(|b| if b { '1'\
    \ } else { '0' })\n        .collect()", "    assert_eq!(a.len(), b.len());\n \
    \   a.chars()\n        .zip(b.chars())\n        .map(|(a, b)| format!(\"{}\",\
    \ if a == b { 0 } else { 1 }))\n        .collect()", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(c1, c2)| (c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap()).to_string())\n\
    \        .collect()", "    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| if x == y { '0' } else { '1' })\n        .collect()", "    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    let mut res = String::from(\"\
    \");\n    let mut a = 0;\n    let mut b = 0;\n    while a_iter.as_str().len()\
    \ > 0 && b_iter.as_str().len() > 0 {\n        a = char_to_int(a_iter.next().unwrap());\n\
    \        b = char_to_int(b_iter.next().unwrap());\n        res.push(int_to_char(a\
    \ ^ b));\n    }\n    if a_iter.as_str().len() > 0 {\n        res.push_str(a_iter.as_str());\n\
    \    } else if b_iter.as_str().len() > 0 {\n        res.push_str(b_iter.as_str());\n\
    \    }\n    res", "    // Make sure the string are of equal length.\n    if a.len()\
    \ != b.len() {\n        panic!(\"Cannot xor strings of different length\");\n\
    \    }\n\n    // Convert the string to Vec<u8> and xor.\n    let a_bytes = a.into_bytes();\n\
    \    let b_bytes = b.into_bytes();\n    let result_bytes = xor(&a_bytes, &b_bytes);\n\
    \n    // Convert the result to a String.\n    String::from_utf8(result_bytes).unwrap()",
  "    let a = a.as_bytes();\n    let b = b.as_bytes();\n    let mut xor = vec![0u8;\
    \ a.len()];\n    for (i, (ai, bi)) in a.iter().zip(b.iter()).enumerate() {\n \
    \       xor[i] = ai ^ bi;\n    }\n    return String::from_utf8(xor).unwrap();",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(aa, bb)| (aa == '1') ^ (bb\
    \ == '1'))\n        .map(|b| if b { '1' } else { '0' })\n        .collect()",
  "    let mut c = String::from(\"\");\n    for (i, (x, y)) in a.chars().zip(b.chars()).enumerate()\
    \ {\n        let x = x.to_digit(10).unwrap();\n        let y = y.to_digit(10).unwrap();\n\
    \        let z = x ^ y;\n        c.push_str(&z.to_string());\n    }\n    c", " \
    \   a.chars()\n        .zip(b.chars())\n        .map(|(x, y)| match (x, y) {\n\
    \            ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"a and\
    \ b must consist only of 1s and 0s\"),\n        })\n        .collect()", "   \
    \ let mut c = String::from(\"\");\n    for i in 0..a.len() {\n        c += &xor_strings(&a[i..i+1],\
    \ &b[i..i+1]).to_string();\n    }\n    c", "    let mut output: String = String::new();\n\
    \    for i in 0..a.len() {\n        output.push(if a.chars().nth(i).unwrap() ==\
    \ b.chars().nth(i).unwrap() {\n            '0'\n        } else {\n           \
    \ '1'\n        });\n    }\n    output", "    let char_list: Vec<char> = a.chars().zip(b.chars()).map(|(a,\
    \ b)| {\n        if a == b {\n            '0'\n        } else {\n            '1'\n\
    \        }\n    }).collect();\n    char_list.iter().cloned().collect()", "   \
    \ let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (a, b) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Invalid characters in string\"),\n \
    \       });\n    }\n    result", "    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n       \
    \ let b_char = b.chars().nth(i).unwrap();\n        if a_char == b_char {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    a.bytes()\n        .zip(b.bytes())\n    \
    \    .map(|(a, b)| a ^ b)\n        .map(|a| a.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")", "    let a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8>\
    \ = b.into_bytes();\n    let mut result = Vec::with_capacity(std::cmp::max(a.len(),\
    \ b.len()));\n    // Pad the shorter string with 0's\n    if a.len() < b.len()\
    \ {\n        result.extend(std::iter::repeat(b'0').take(b.len() - a.len()));\n\
    \        result.extend(a);\n    } else {\n        result.extend(std::iter::repeat(b'0').take(a.len()\
    \ - b.len()));\n        result.extend(b);\n    }\n    // Perform binary XOR on\
    \ each character\n    for i in 0..result.len() {\n        let val = result[i]\
    \ ^ result[i];\n        result[i] = val + 48;\n    }\n    String::from_utf8(result).unwrap()",
  "    let result = xor(&string_to_bytes(&a), &string_to_bytes(&b));\n    hex::encode(result)",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(a, b)| format!(\"{}\", a\
    \ ^ b))\n        .collect()", "    let result: String = a\n        .chars()\n\
    \        .zip(b.chars())\n        .map(|(c1, c2)| if c1 == c2 { '0' } else { '1'\
    \ })\n        .collect();\n    result", "    let mut s = String::new();\n    for\
    \ pair in a.chars().zip(b.chars()) {\n        s.push(\n            match pair\
    \ {\n                (x, y) if x == y => '0',\n                _ => '1',\n   \
    \         }\n        );\n    }\n    s", '    unimplemented!()', "    // TODO\n\
    \    unimplemented!()", "    let chars_a: Vec<char> = a.chars().collect();\n \
    \   let chars_b: Vec<char> = b.chars().collect();\n    let mut result: String\
    \ = String::new();\n    for i in 0..chars_a.len() {\n        if chars_a[i] ==\
    \ chars_b[i] {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let mut ret = String::new();\n    let a_bytes\
    \ = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    assert_eq!(a_bytes.len(),\
    \ b_bytes.len());\n    for i in 0..a_bytes.len() {\n        ret.push(char::from(a_bytes[i]\
    \ ^ b_bytes[i]));\n    }\n    ret", "    assert_eq!(a.len(), b.len());\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| xor(a, b))\n        .collect()",
  "    let mut res = String::new();\n    let mut iter = a.chars().zip(b.chars());\n\
    \    while let Some((a, b)) = iter.next() {\n        if a == b {\n           \
    \ res.push('0');\n        } else {\n            res.push('1');\n        }\n  \
    \  }\n    res", "    // TODO: implement your function body\n    let mut c = String::from(\"\
    \");\n    for i in 0..a.len() {\n        c.push(match (a.chars().nth(i), b.chars().nth(i))\
    \ {\n            (Some('0'), Some('0')) => '0',\n            (Some('0'), Some('1'))\
    \ => '1',\n            (Some('1'), Some('0')) => '1',\n            (Some('1'),\
    \ Some('1')) => '0',\n            _ => ' ',\n        });\n    }\n    c", "   \
    \ a.chars()\n        .zip(b.chars())\n        .map(|(i, j)| match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        })\n        .collect()", "    let a_bytes = a.as_bytes();\n\
    \    let b_bytes = b.as_bytes();\n    if a_bytes.len() != b_bytes.len() {\n  \
    \      return String::from(\"\");\n    }\n    let mut result = String::new();\n\
    \    for i in 0..a_bytes.len() {\n        let a_byte = a_bytes[i];\n        let\
    \ b_byte = b_bytes[i];\n        let a_char = char::from(a_byte);\n        let\
    \ b_char = char::from(b_byte);\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result",
  "    let mut output = String::new();\n    let mut a_chars = a.chars();\n    let\
    \ mut b_chars = b.chars();\n    while let (Some(a_val), Some(b_val)) = (a_chars.next(),\
    \ b_chars.next()) {\n        if a_val == b_val {\n            output.push('0');\n\
    \        } else {\n            output.push('1');\n        }\n    }\n    output",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(n1, n2)| match (n1, n2)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => '0',\n\
    \        })\n        .collect()", "    let mut result = String::new();\n    let\
    \ min_len = min(a.len(), b.len());\n    for i in 0..min_len {\n        let mut\
    \ a_char: Vec<char> = a.chars().collect();\n        let mut b_char: Vec<char>\
    \ = b.chars().collect();\n        result.push(\n            if a_char[i] == b_char[i]\
    \ {\n                '0'\n            } else {\n                '1'\n        \
    \    }\n        );\n    }\n    result", "    let v1: Vec<u8> = a.into_bytes();\n\
    \    let v2: Vec<u8> = b.into_bytes();\n    let mut xor: Vec<u8> = Vec::new();\n\
    \    for (i, j) in v1.iter().zip(v2.iter()) {\n        if *i == b'0' && *j ==\
    \ b'0' {\n            xor.push(b'0');\n        } else if *i == b'1' && *j == b'1'\
    \ {\n            xor.push(b'0');\n        } else {\n            xor.push(b'1');\n\
    \        }\n    }\n    let xor: String = xor.iter().collect();\n    xor", '    unimplemented!()',
  "    let mut result = String::new();\n    if a.len() != b.len() {\n        return\
    \ result;\n    }\n    for (a_char, b_char) in a.chars().zip(b.chars()) {\n   \
    \     result.push(match (a_char, b_char) {\n            ('0', '0') => '0',\n \
    \           ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => '0',\n        });\n    }\n    result", "    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| if a == b { '0' } else { '1' })\n\
    \        .collect()", "    let mut output = String::new();\n    let a_chars =\
    \ a.chars();\n    let b_chars = b.chars();\n    for (a_char, b_char) in a_chars.zip(b_chars)\
    \ {\n        output.push(if a_char == b_char { '0' } else { '1' });\n    }\n \
    \   output", "    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        result.push_str(&format!(\"{}\", c1.to_digit(10).unwrap() ^ c2.to_digit(10).unwrap()));\n\
    \    }\n    result", "    let a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n\
    \    a_bytes\n        .iter()\n        .zip(b_bytes.iter())\n        .map(|(a,\
    \ b)| a ^ b)\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")", "    let res = xor(a.as_bytes(), b.as_bytes());\n    String::from_utf8(res).unwrap()",
  "    fn binary_xor(a: u8, b: u8) -> u8 {\n        // If a is equal to b, return\
    \ 0.\n        if a == b {\n            0\n        } else {\n            1\n  \
    \      }\n    }\n\n    // Convert to bytes, perform XOR and return as a string\n\
    \    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    a_bytes\n\
    \        .iter()\n        .zip(b_bytes)\n        .map(|(a, b)| binary_xor(*a,\
    \ *b))\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n \
    \       .join(\"\")", "    // First convert inputs to byte arrays.\n    let a_bytes\
    \ = a.into_bytes();\n    let b_bytes = b.into_bytes();\n\n    // Then XOR together,\
    \ perform to_string on each element, then join.\n    a_bytes\n        .iter()\n\
    \        .zip(b_bytes.iter())\n        .map(|(a, b)| (a ^ b).to_string())\n  \
    \      .collect::<Vec<String>>()\n        .join(\"\")", "    let mut result =\
    \ String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n\
    \    while let (Some(a_ch), Some(b_ch)) = (a_iter.next(), b_iter.next()) {\n \
    \       let a_bit = if a_ch == '1' { 1 } else { 0 };\n        let b_bit = if b_ch\
    \ == '1' { 1 } else { 0 };\n        let result_bit = (a_bit ^ b_bit) as u8;\n\
    \        result.push(result_bit.to_string().chars().next().unwrap());\n    }\n\
    \    result", "    /// This implementation iterates over the bytes of the strings\
    \ and then\n    /// bitwise xors them together.\n    let mut result = String::new();\n\
    \    for (a, b) in a.bytes().zip(b.bytes()) {\n        result.push_str(&format!(\"\
    {:01b}\", a ^ b));\n    }\n    result", "    // TODO\n    String::from(\"\")",
  "    assert_eq!(a.len(), b.len());\n    let mut output = String::with_capacity(a.len());\n\
    \    for (ch_a, ch_b) in a.chars().zip(b.chars()) {\n        let xor = match (ch_a,\
    \ ch_b) {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n  \
    \          ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ =>\
    \ panic!(\"Unhandled character found: {} or {}\", ch_a, ch_b),\n        };\n \
    \       output.push(xor);\n    }\n    output", '    "0110100100011010010101001010101101010101".to_string()',
  "    // Convert the strings to byte vectors\n    let mut bytes_a = Vec::new();\n\
    \    for b in a.chars() {\n        bytes_a.push(b as u8 - '0' as u8);\n    }\n\
    \    let mut bytes_b = Vec::new();\n    for b in b.chars() {\n        bytes_b.push(b\
    \ as u8 - '0' as u8);\n    }\n\n    // Ensure they are the same length\n    while\
    \ bytes_a.len() < bytes_b.len() {\n        bytes_a.insert(0, 0);\n    }\n    while\
    \ bytes_b.len() < bytes_a.len() {\n        bytes_b.insert(0, 0);\n    }\n\n  \
    \  // Compute the xor\n    let mut bytes_c = Vec::new();\n    for i in 0..bytes_a.len()\
    \ {\n        bytes_c.push(bytes_a[i] ^ bytes_b[i]);\n    }\n\n    // Convert back\
    \ to a string\n    let mut result = String::new();\n    for b in bytes_c {\n \
    \       result.push((b + '0' as u8) as char);\n    }\n    result", "    // TODO:\
    \ Implement here\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        let a_char = a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        let a_value = match a_char {\n            '0' => false,\n           \
    \ '1' => true,\n            _ => false,\n        };\n        let b_value = match\
    \ b_char {\n            '0' => false,\n            '1' => true,\n            _\
    \ => false,\n        };\n        let mut xor_value = a_value ^ b_value;\n    \
    \    if xor_value {\n            result.push('1');\n        } else {\n       \
    \     result.push('0');\n        }\n    }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            result.push('0');\n        } else\
    \ {\n            result.push('1');\n        }\n    }\n    result", "    let mut\
    \ result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n    \
    \    let c = match (a, b) {\n            ('0', '0') => '0',\n            ('0',\
    \ '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n\
    \            _ => panic!(\"Unexpected input\"),\n        };\n        result.push(c);\n\
    \    }\n    result", "    let mut ret = String::new();\n    for i in 0..a.len()\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         ret.push('0');\n        } else {\n            ret.push('1');\n     \
    \   }\n    }\n    ret", "    let mut out = String::new();\n    for (c1, c2) in\
    \ a.chars().zip(b.chars()) {\n        out.push(match (c1, c2) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"),\n\
    \        });\n    }\n    out", "    let mut s = String::new();\n    for (ai, bi)\
    \ in a.chars().zip(b.chars()) {\n        let ai = ai.to_digit(10).unwrap();\n\
    \        let bi = bi.to_digit(10).unwrap();\n        s.push_str(&(ai ^ bi).to_string());\n\
    \    }\n    s", "    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        if c1 == c2 {\n            result.push('0');\n        } else {\n\
    \            result.push('1');\n        }\n    }\n    result", "    let length\
    \ = std::cmp::max(a.len(), b.len());\n    let mut a_iter = a.chars().rev();\n\
    \    let mut b_iter = b.chars().rev();\n    let mut result = String::new();\n\
    \    for _ in 0..length {\n        let mut a_char = '0';\n        if let Some(c)\
    \ = a_iter.next() {\n            a_char = c;\n        }\n        let mut b_char\
    \ = '0';\n        if let Some(c) = b_iter.next() {\n            b_char = c;\n\
    \        }\n        result.push(xor(a_char, b_char));\n    }\n    result.chars().rev().collect()",
  "    let mut xored = vec![];\n    let chars_a = a.chars();\n    let chars_b = b.chars();\n\
    \    for (a, b) in chars_a.zip(chars_b) {\n        let xor = match (a, b) {\n\
    \            ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input.\"),\n        };\n        xored.push(xor);\n    }\n    xored.iter().collect()",
  '    unimplemented!()', "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let a_len = a.len();\n    let b_len = b.len();\n\
    \    if a_len != b_len {\n        panic!(\"Inconsistent input lengths {} {}\"\
    , a_len, b_len);\n    }\n    let mut res = String::new();\n    for i in 0..a_len\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         res.push('0');\n        } else {\n            res.push('1');\n     \
    \   }\n    }\n    res", '    String::from("")', "    let mut a_chars = a.chars();\n\
    \    let mut b_chars = b.chars();\n    let mut result = String::from(\"\");\n\
    \    loop {\n        match (a_chars.next(), b_chars.next()) {\n            (Some(a_char),\
    \ Some(b_char)) => {\n                let xor_result = if a_char == b_char {\n\
    \                    '0'\n                } else {\n                    '1'\n\
    \                };\n                result.push(xor_result);\n            }\n\
    \            _ => break,\n        }\n    }\n    result", "    let mut out: String\
    \ = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n        if x\
    \ == y {\n            out.push('0');\n        } else {\n            out.push('1');\n\
    \        }\n    }\n    out", "    a.chars()\n        .zip(b.chars())\n       \
    \ .map(|(a, b)| (a, b).into())\n        .collect()", "    let a_bytes = a.into_bytes();\n\
    \    let b_bytes = b.into_bytes();\n    assert_eq!(a_bytes.len(), b_bytes.len());\n\
    \    let mut xor_result: Vec<u8> = Vec::new();\n    for i in 0..a_bytes.len()\
    \ {\n        let xor_res = a_bytes[i] ^ b_bytes[i];\n        xor_result.push(xor_res);\n\
    \    }\n    String::from_utf8(xor_result).unwrap()", "    // convert both strings\
    \ to u8\n    let a_u8 = bit_string_to_u8(&a);\n    let b_u8 = bit_string_to_u8(&b);\n\
    \n    // xor both u8s and convert back to bitstring\n    let xor_u8 = a_u8 ^ b_u8;\n\
    \    let xor_string = u8_to_bit_string(xor_u8);\n\n    xor_string", "    // TODO:\
    \ Implement here!\n    unimplemented!();", "    let mut s = String::new();\n \
    \   for (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n          \
    \  s.push('0');\n        } else {\n            s.push('1');\n        }\n    }\n\
    \    s", "    a.chars()\n        .zip(b.chars())\n        .map(|(c1, c2)| {\n\
    \            if c1 == c2 {\n                '0'\n            } else {\n      \
    \          '1'\n            }\n        })\n        .collect()", "    let mut result\
    \ = String::new();\n    let a = a.as_bytes();\n    let b = b.as_bytes();\n   \
    \ for (byte_a, byte_b) in a.iter().zip(b.iter()) {\n        if *byte_a != *byte_b\
    \ {\n            result.push('1');\n        } else {\n            result.push('0');\n\
    \        }\n    }\n    result", "    let mut result = String::from(\"\");\n  \
    \  for c in a.chars().zip(b.chars()) {\n        result.push_str(&(c.0 ^ c.1).to_string());\n\
    \    }\n    result", "    assert_eq!(a.len(), b.len());\n    a.chars()\n     \
    \   .zip(b.chars())\n        .map(|(aa, bb)| match (aa, bb) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"a or b contains a non-binary\
    \ value\"),\n        })\n        .collect()", "    let a_bytes = a.as_bytes();\n\
    \    let b_bytes = b.as_bytes();\n    let mut ret = String::with_capacity(a_bytes.len());\n\
    \    for (a, b) in a_bytes.iter().zip(b_bytes.iter()) {\n        ret.push_str(&format!(\"\
    {}\", (a ^ b) & 1));\n    }\n    ret", '    unimplemented!();', "    let mut a_bytes\
    \ = a.into_bytes();\n    let mut b_bytes = b.into_bytes();\n    let max_len =\
    \ std::cmp::max(a_bytes.len(), b_bytes.len());\n    a_bytes.resize(max_len, b'0');\n\
    \    b_bytes.resize(max_len, b'0');\n    let mut result: Vec<u8> = Vec::with_capacity(max_len);\n\
    \    for i in 0..max_len {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n  \
    \  }\n    std::str::from_utf8(&result).unwrap().to_string()", "    let mut s =\
    \ String::new();\n    for (ai, bi) in a.chars().zip(b.chars()) {\n        if ai\
    \ == bi {\n            s.push('0');\n        } else {\n            s.push('1');\n\
    \        }\n    }\n    s", "    assert_eq!(a.len(), b.len());\n    let mut ret\
    \ = String::new();\n    for i in 0..a.len() {\n        ret.push(if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            '0'\n        } else {\n        \
    \    '1'\n        });\n    }\n    ret", "    let mut res = String::from(\"\");\n\
    \    for i in 0..a.len() {\n        res.push_str(&match a.chars().nth(i).unwrap()\
    \ {\n            '0' => match b.chars().nth(i).unwrap() {\n                '0'\
    \ => \"0\",\n                '1' => \"1\",\n                _ => \"\",\n     \
    \       },\n            '1' => match b.chars().nth(i).unwrap() {\n           \
    \     '0' => \"1\",\n                '1' => \"0\",\n                _ => \"\"\
    ,\n            },\n            _ => \"\",\n        });\n    }\n    res", "   \
    \ a.bytes()\n        .zip(b.bytes())\n        .map(|(x, y)| (x ^ y).to_string())\n\
    \        .collect::<Vec<String>>()\n        .join(\"\")", "    assert_eq!(a.len(),\
    \ b.len());\n    a.chars()\n        .zip(b.chars())\n        .map(|(x, y)| match\
    \ (x, y) {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n \
    \           ('1', '0') => '1',\n            ('1', '1') => '0',\n            _\
    \ => unreachable!(),\n        })\n        .collect()", "    let zipped = a.chars().zip(b.chars());\n\
    \    zipped.map(|(a, b)| (a != b) as char).collect()", "    a.chars()\n      \
    \  .zip(b.chars())\n        .map(|(a, b)| match (a, b) {\n            ('0', '0')\
    \ => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n  \
    \          ('1', '1') => '0',\n            _ => '0',\n        })\n        .collect()",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(x, y)| {\n            if\
    \ x == y {\n                '0'\n            } else {\n                '1'\n \
    \           }\n        })\n        .collect()", "    let mut ret: String = String::from(\"\
    \");\n    let mut i = 0;\n    for c in a.chars() {\n        if c == b.chars().nth(i).unwrap()\
    \ {\n            ret.push('0');\n        } else {\n            ret.push('1');\n\
    \        }\n        i += 1;\n    }\n    ret", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()", " \
    \   a.into_bytes()\n        .iter()\n        .zip(b.into_bytes().iter())\n   \
    \     .map(|(a, b)| (a ^ b) as char)\n        .collect()", "    let a_vec: Vec<u8>\
    \ = a.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n    let b_vec:\
    \ Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n    return\
    \ a_vec\n        .iter()\n        .zip(b_vec.iter())\n        .map(|(a, b)| (a\
    \ ^ b).to_string())\n        .collect::<Vec<String>>()\n        .join(\"\");",
  "    assert_eq!(a.len(), b.len());\n    let mut a = a.into_bytes();\n    let mut\
    \ b = b.into_bytes();\n    for (x, y) in a.iter_mut().zip(b.iter_mut()) {\n  \
    \      *x ^= *y;\n    }\n    String::from_utf8(a).unwrap()", "    let mut result\
    \ = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n\
    \    loop {\n        match (a_iter.next(), b_iter.next()) {\n            (Some(a_char),\
    \ Some(b_char)) => {\n                result.push(match (a_char, b_char) {\n \
    \                   ('0', '0') => '0',\n                    ('0', '1') => '1',\n\
    \                    ('1', '0') => '1',\n                    ('1', '1') => '0',\n\
    \                    _ => unreachable!(),\n                });\n            }\n\
    \            (None, None) => break,\n            _ => panic!(\"String lengths\
    \ must be equal\"),\n        }\n    }\n    result", "    let a: Vec<_> = a.chars().collect();\n\
    \    let b: Vec<_> = b.chars().collect();\n    a.iter()\n        .zip(b.iter())\n\
    \        .map(|(x, y)| match (x, y) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => ' ',\n        })\n        .collect()", '    format!("{:?}",
    xor(a.into_bytes(), b.into_bytes()))', "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(c1, c2)| if c1 == c2 { '0' } else { '1' })\n        .collect()",
  "    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (c1, c2) {\n            ('0', '0') => '0',\n  \
    \          ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"invalid input!\"),\n        });\n  \
    \  }\n    result", '    String::from("")', "    let mut c = String::new();\n \
    \   let mut a_chars = a.chars();\n    let mut b_chars = b.chars();\n    while\
    \ let (Some(a_i), Some(b_i)) = (a_chars.next(), b_chars.next()) {\n        let\
    \ a_int = a_i.to_digit(10).unwrap();\n        let b_int = b_i.to_digit(10).unwrap();\n\
    \        c.push_str(&xor(a_int, b_int).to_string());\n    }\n    c", "    let\
    \ a_int = i32::from_str_radix(&a, 2).unwrap();\n    let b_int = i32::from_str_radix(&b,\
    \ 2).unwrap();\n    let result = a_int ^ b_int;\n    return format!(\"{:b}\",\
    \ result);", "    let mut ret = String::new();\n    let a = a.as_bytes();\n  \
    \  let b = b.as_bytes();\n    for i in 0..a.len() {\n        let x = if a[i] ==\
    \ b'0' {\n            b'0'\n        } else {\n            b'1'\n        };\n \
    \       let y = if b[i] == b'0' {\n            b'0'\n        } else {\n      \
    \      b'1'\n        };\n        let z = x ^ y;\n        ret.push(z as char);\n\
    \    }\n    ret", "    let a_vec: Vec<u8> = a.as_bytes().iter().map(|a| char::from(*a).to_digit(10).unwrap()\
    \ as u8).collect();\n    let b_vec: Vec<u8> = b.as_bytes().iter().map(|b| char::from(*b).to_digit(10).unwrap()\
    \ as u8).collect();\n    let xor_iter = a_vec.iter().zip(b_vec.iter()).map(|(a,\
    \ b)| a ^ b);\n    let xor_string: String = xor_iter.map(|x| x.to_string()).collect();\n\
    \    xor_string", "    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    let mut result: Vec<u8> = Vec::new();\n    for i in 0..a_bytes.len() {\n\
    \        result.push(a_bytes[i] ^ b_bytes[i]);\n    }\n    String::from_utf8(result).unwrap()",
  '    unimplemented!()', "    let binary_a = u8::from_str_radix(&a, 2).unwrap();\n\
    \    let binary_b = u8::from_str_radix(&b, 2).unwrap();\n    let binary_c = binary_a\
    \ ^ binary_b;\n    format!(\"{:b}\", binary_c)", "    let mut ret = String::from(\"\
    \");\n    for i in 0..a.len() {\n        let a_bit = a.chars().nth(i).unwrap();\n\
    \        let b_bit = b.chars().nth(i).unwrap();\n        ret.push(match (a_bit,\
    \ b_bit) {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n \
    \           ('1', '0') => '1',\n            ('1', '1') => '0',\n            _\
    \ => panic!(\"string_xor: invalid bit sequence\"),\n        });\n    }\n    ret",
  "    // ...\n    unimplemented!()", "    if a.len() != b.len() {\n        panic!(\"\
    strings are not equal\");\n    }\n    let a_bytes = hex::decode(a).unwrap();\n\
    \    let b_bytes = hex::decode(b).unwrap();\n    let mut result = Vec::new();\n\
    \    for i in 0..a_bytes.len() {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n\
    \    }\n    hex::encode(result)", "    a.chars()\n        .zip(b.chars())\n  \
    \      .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()", " \
    \   // get lengths of strings\n    let mut la = a.len();\n    let mut lb = b.len();\n\
    \    // calculate lengths of new string\n    let mut l = if la > lb { la } else\
    \ { lb };\n    // make new string\n    let mut c = String::new();\n    // set\
    \ cursor to end of strings\n    let mut ca = a.chars().rev();\n    let mut cb\
    \ = b.chars().rev();\n    // get next char from string\n    let mut x = ca.next();\n\
    \    let mut y = cb.next();\n    // while we have some chars\n    while x.is_some()\
    \ || y.is_some() {\n        // if we have both chars\n        if x.is_some() &&\
    \ y.is_some() {\n            // get them and calculate xor\n            let (a,\
    \ b) = (x.unwrap(), y.unwrap());\n            let r = if a == b { '0' } else {\
    \ '1' };\n            // push result to new string\n            c.push(r);\n \
    \           // get next char\n            x = ca.next();\n            y = cb.next();\n\
    \        } else if x.is_some() {\n            // only we have char from a\n  \
    \          let a = x.unwrap();\n            c.push(a);\n            x = ca.next();\n\
    \        } else if y.is_some() {\n            // only we have char from b\n  \
    \          let b = y.unwrap();\n            c.push(b);\n            y = cb.next();\n\
    \        }\n    }\n    // reverse to normal string and return\n    c.chars().rev().collect()",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push_str(&format!(\"{}\", a ^ b));\n    }\n    result", " \
    \   let mut result = String::new();\n    for (ch_a, ch_b) in a.chars().zip(b.chars())\
    \ {\n        let mut a = ch_a.to_digit(10).unwrap();\n        let mut b = ch_b.to_digit(10).unwrap();\n\
    \        a ^= b;\n        result.push_str(&a.to_string());\n    }\n    result",
  "    let a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n    if a_bytes.len()\
    \ != b_bytes.len() {\n        return String::from(\"ERROR\");\n    }\n    let\
    \ mut out = String::new();\n    for (a, b) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        let value = *a ^ *b;\n        out.push(char::from(value));\n    }\n\
    \    out", "    a.bytes()\n        .zip(b.bytes())\n        .map(|(c1, c2)| c1\
    \ ^ c2)\n        .map(|c| c.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")", "    a.chars()\n        .zip(b.chars())\n        .map(|(aa,\
    \ bb)| (aa.to_digit(2).unwrap() ^ bb.to_digit(2).unwrap()).to_string())\n    \
    \    .collect()", "    let mut result = String::from(\"\");\n    for i in 0..a.len()\
    \ {\n        let a_char = a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        let new_char = match (a_char, b_char) {\n            ('0', '0') => '0',\n\
    \            ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => '0',\n        };\n        result.push(new_char);\n\
    \    }\n    result", "    let mut a = a.chars();\n    let mut b = b.chars();\n\
    \    let mut output = String::new();\n    loop {\n        match (a.next(), b.next())\
    \ {\n            (Some(c1), Some(c2)) => {\n                if c1 == c2 {\n  \
    \                  output.push('0');\n                } else {\n             \
    \       output.push('1');\n                }\n            }\n            _ =>\
    \ break,\n        }\n    }\n    output", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| char_xor(a, b))\n        .collect()", "    // unimplemented!()\n\
    \    let a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8> = b.into_bytes();\n\
    \    let mut c: Vec<u8> = Vec::new();\n    for i in 0..a.len() {\n        if a[i]\
    \ == b[i] {\n            c.push(48);\n        } else {\n            c.push(49);\n\
    \        }\n    }\n    let c: String = String::from_utf8(c).unwrap();\n    return\
    \ c;", '    format!("{:0b}", u8::from_str_radix(&a, 2) ^ u8::from_str_radix(&b,
    2))', "    let mut ret = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        ret.push(match (c1, c2) {\n            ('0', '0') => '0',\n     \
    \       ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Illegal characters in strings a and\
    \ b\"),\n        });\n    }\n    ret", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| xor(a, b))\n        .collect()", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        result.push_str(&format!(\"\
    {}\", a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap()));\n    }\n    result",
  "    let mut res = String::from(\"\");\n    let mut a: Vec<char> = a.chars().collect();\n\
    \    let mut b: Vec<char> = b.chars().collect();\n    let mut len = if a.len()\
    \ > b.len() { a.len() } else { b.len() };\n    a.reverse();\n    b.reverse();\n\
    \    for i in 0..len {\n        if i < a.len() && i < b.len() {\n            if\
    \ a[i] == b[i] {\n                res.push('0');\n            } else {\n     \
    \           res.push('1');\n            }\n        } else if i < a.len() {\n \
    \           res.push(a[i]);\n        } else {\n            res.push(b[i]);\n \
    \       }\n    }\n    res.chars().rev().collect()", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(x, y)| match (x, y) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"There should be only 1s and 0s!\"),\n   \
    \     })\n        .collect()", '    format!("{:0>1$b}", parse_binary(a) ^ parse_binary(b),
    a.len())', "    assert_eq!(a.len(), b.len());\n    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(c1, c2)| (c1 == '1') ^ (c2 == '1'))\n        .map(|b| if b { '1'\
    \ } else { '0' })\n        .collect()", "    // Transform to Vec<u8>\n    let\
    \ a = hex::decode(a).unwrap();\n    let b = hex::decode(b).unwrap();\n\n    //\
    \ XOR\n    let mut bytes = Vec::new();\n    for i in 0..a.len() {\n        bytes.push(a[i]\
    \ ^ b[i]);\n    }\n\n    // Transform to String\n    let result = String::from_utf8(bytes).unwrap();\n\
    \    hex::encode(result)", "    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| format!(\"{}\", num_xor(a.to_digit(2).unwrap(), b.to_digit(2).unwrap())))\n\
    \        .collect()", "    // check if lengths are the same\n    if a.len() !=\
    \ b.len() {\n        panic!(\"Different lengths! Error!\");\n    }\n\n    // initialize\
    \ vector\n    let mut result: Vec<u8> = Vec::new();\n\n    // convert strings\
    \ to chars and XOR\n    for i in 0..a.len() {\n        let a = a.chars().nth(i).unwrap();\n\
    \        let b = b.chars().nth(i).unwrap();\n        let c = match (a, b) {\n\
    \            ('0', '0') => \"0\",\n            ('0', '1') => \"1\",\n        \
    \    ('1', '0') => \"1\",\n            ('1', '1') => \"0\",\n            _ =>\
    \ panic!(\"Error! Not a binary string!\"),\n        };\n        result.push(c.as_bytes()[0]);\n\
    \    }\n\n    // convert vector to string\n    String::from_utf8(result).unwrap()",
  "    let a = a.into_bytes();\n    let b = b.into_bytes();\n    let mut result =\
    \ Vec::new();\n    for i in 0..a.len() {\n        let value = if a[i] == 48 &&\
    \ b[i] == 48 { 48 } else if a[i] == 49 && b[i] == 49 { 48 } else { 49 };\n   \
    \     result.push(value);\n    }\n    String::from_utf8(result).unwrap()", " \
    \   let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut\
    \ output = Vec::new();\n    for i in 0..a_bytes.len() {\n        let a_char =\
    \ if a_bytes[i] == b'0' { false } else { true };\n        let b_char = if b_bytes[i]\
    \ == b'0' { false } else { true };\n        let res = a_char ^ b_char;\n     \
    \   output.push(if res { b'1' } else { b'0' });\n    }\n    String::from_utf8(output).unwrap()",
  "    let mut result = String::new();\n    let mut a = a.into_bytes();\n    let mut\
    \ b = b.into_bytes();\n    let len = a.len().max(b.len());\n    a.resize(len,\
    \ 0x30);\n    b.resize(len, 0x30);\n    for i in 0..len {\n        if a[i] ==\
    \ b[i] {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let a_bytes = a.into_bytes();\n    let b_bytes\
    \ = b.into_bytes();\n    let max_len = max(a_bytes.len(), b_bytes.len());\n  \
    \  let mut result = Vec::with_capacity(max_len);\n    for i in 0..max_len {\n\
    \        let a_byte = a_bytes.get(i).unwrap_or(&0);\n        let b_byte = b_bytes.get(i).unwrap_or(&0);\n\
    \        result.push(a_byte ^ b_byte);\n    }\n    String::from_utf8(result).unwrap()",
  "    let mut result = String::from(\"\");\n    for i in 0..a.len() {\n        let\
    \ a_i = match a.get(i..i + 1) {\n            Some(s) => s,\n            None =>\
    \ \"\",\n        };\n        let b_i = match b.get(i..i + 1) {\n            Some(s)\
    \ => s,\n            None => \"\",\n        };\n        if a_i == b_i {\n    \
    \        result.push_str(\"0\");\n        } else {\n            result.push_str(\"\
    1\");\n        }\n    }\n    result", "    let mut result = String::from(\"\"\
    );\n    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let res = (0..a.len())\n        .map(|i|\
    \ {\n            let a_ch = a.chars().nth(i).unwrap();\n            let b_ch =\
    \ b.chars().nth(i).unwrap();\n            if a_ch == b_ch {\n                \"\
    0\"\n            } else {\n                \"1\"\n            }\n        })\n\
    \        .collect::<String>();\n    res", "    let a_u8: Vec<u8> = a.chars().map(|c|\
    \ c.to_digit(10).unwrap() as u8).collect();\n    let b_u8: Vec<u8> = b.chars().map(|c|\
    \ c.to_digit(10).unwrap() as u8).collect();\n    let a_b_u8: Vec<u8> = a_u8.iter().zip(b_u8.iter()).map(|(x,\
    \ y)| x ^ y).collect();\n    a_b_u8.iter().map(|x| x.to_string()).collect()",
  "    let mut result = String::new();\n    let len = if a.len() < b.len() { a.len()\
    \ } else { b.len() };\n    for i in 0..len {\n        let c = a.chars().nth(i).unwrap();\n\
    \        let d = b.chars().nth(i).unwrap();\n        let xor = xor(c, d);\n  \
    \      result.push(xor);\n    }\n    result", "    let a = a.into_bytes();\n \
    \   let b = b.into_bytes();\n    let mut result = String::new();\n    for i in\
    \ 0..a.len() {\n        result.push(if a[i] == b[i] { '0' } else { '1' });\n \
    \   }\n    result", "    a.chars()\n        .zip(b.chars())\n        .map(|(ac,\
    \ bc)| match (ac, bc) {\n            ('0', '0') => '0',\n            ('0', '1')\
    \ => '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n  \
    \          _ => panic!(\"Unexpected input\"),\n        })\n        .collect()",
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        let a_char\
    \ = a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        result.push(if a_char == b_char { '0' } else { '1' });\n    }\n    result",
  "    let mut v = vec![];\n    let mut iter = a.chars().zip(b.chars());\n    while\
    \ let Some((x, y)) = iter.next() {\n        v.push(x.to_digit(2).unwrap() ^ y.to_digit(2).unwrap());\n\
    \    }\n    v.iter().map(|&x| x.to_string()).collect()", '    unimplemented!()']
stop_tokens:
- "\n}"
