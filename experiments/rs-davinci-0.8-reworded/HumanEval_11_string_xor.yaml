name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    let xored = xor(Vec::from(a.as_bytes()), Vec::from(b.as_bytes()));\n\
    \    String::from_utf8(xored).unwrap()", "    let a_bytes = a.into_bytes();\n\
    \    let b_bytes = b.into_bytes();\n    let c_bytes = xor(&a_bytes, &b_bytes);\n\
    \    String::from_utf8(c_bytes).unwrap()", "    let mut result = String::new();\n\
    \    let n = a.len();\n    assert_eq!(n, b.len());\n    for i in 0..n {\n    \
    \    let bit_a = a.chars().nth(i).unwrap();\n        let bit_b = b.chars().nth(i).unwrap();\n\
    \        let bit_c = match (bit_a, bit_b) {\n            ('0', '0') => '0',\n\
    \            ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"invalid input\"),\n        };\n    \
    \    result.push(bit_c);\n    }\n    result", "    a.into_bytes()\n        .iter()\n\
    \        .zip(b.into_bytes().iter())\n        .map(|(x, y)| x ^ y)\n        .map(|i|\
    \ i.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\")", " \
    \   let mut out = Vec::with_capacity(a.len());\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        out.push(match (c1, c2) {\n            ('0', '0') => '0',\n     \
    \       ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"invalid input\"),\n        });\n   \
    \ }\n    out.iter().collect()", "    let mut a = a.into_bytes();\n    let mut\
    \ b = b.into_bytes();\n    let mut max_size = a.len();\n    if b.len() > max_size\
    \ {\n        max_size = b.len();\n    }\n    let mut res = Vec::with_capacity(max_size);\n\
    \    for i in 0..max_size {\n        let (a_byte, b_byte) = if i >= a.len() {\n\
    \            (0, b[i])\n        } else if i >= b.len() {\n            (a[i], 0)\n\
    \        } else {\n            (a[i], b[i])\n        };\n        let out = match\
    \ (a_byte, b_byte) {\n            (48, 48) => String::from(\"0\"),\n         \
    \   (48, 49) => String::from(\"1\"),\n            (49, 48) => String::from(\"\
    1\"),\n            (49, 49) => String::from(\"0\"),\n            (_, _) => panic!(\"\
    WAT?\"),\n        };\n        res.push(out.as_bytes()[0]);\n    }\n    return\
    \ String::from_utf8(res).unwrap();", "    let mut ret = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        let x = c1.to_digit(2).unwrap()\
    \ ^ c2.to_digit(2).unwrap();\n        ret.push_str(&x.to_string());\n    }\n \
    \   ret", "    let a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8> = b.into_bytes();\n\
    \    let c: Vec<u8> = a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect();\n\
    \    String::from_utf8(c).unwrap()", "    let mut result = String::new();\n  \
    \  for (c1, c2) in a.chars().zip(b.chars()) {\n        let v1 = c1.to_digit(10).unwrap();\n\
    \        let v2 = c2.to_digit(10).unwrap();\n        result.push_str(&(v1 ^ v2).to_string());\n\
    \    }\n    result", "    if a.len() != b.len() {\n        return String::from(\"\
    error\");\n    }\n    let mut r = String::new();\n    for c in a.chars().zip(b.chars())\
    \ {\n        r.push(match c {\n            (x, y) if x == y => '0',\n        \
    \    _ => '1',\n        });\n    }\n    r", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(l, r)| if l == r { '0' } else { '1' })\n        .collect()", " \
    \   let x = hex::decode(a).unwrap();\n    let y = hex::decode(b).unwrap();\n \
    \   hex::encode(xor(&x, &y))", "    let mut result = String::new();\n    for (i,\
    \ j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n     \
    \       ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => '0',\n      \
    \  });\n    }\n    result", "    let mut result = String::new();\n    let a =\
    \ a.as_bytes();\n    let b = b.as_bytes();\n    for (a, b) in a.iter().zip(b.iter())\
    \ {\n        result.push(format!(\"{:x}\", a ^ b)[3..4].to_string());\n    }\n\
    \    result", '    unimplemented!();', "    let mut binary = String::new();\n\
    \    let a_chars: Vec<char> = a.chars().collect();\n    let b_chars: Vec<char>\
    \ = b.chars().collect();\n    for i in 0..a_chars.len() {\n        if a_chars[i]\
    \ == b_chars[i] {\n            binary.push('0');\n        } else {\n         \
    \   binary.push('1');\n        }\n    }\n    binary", "    let mut res = String::new();\n\
    \    for (i, j) in a.chars().zip(b.chars()) {\n        res.push(if i == j { '0'\
    \ } else { '1' });\n    }\n    res", "    let a_bytes = a.into_bytes();\n    let\
    \ b_bytes = b.into_bytes();\n    let length = a_bytes.len();\n    let mut output\
    \ = Vec::with_capacity(length);\n    for i in 0..length {\n        let result\
    \ = a_bytes[i] ^ b_bytes[i];\n        output.push(result);\n    }\n    String::from_utf8(output).unwrap()",
  "    if a.len() != b.len() {\n        panic!(\"Sizes do not match!\");\n    }\n\
    \    let mut output = Vec::new();\n    for (bit_a, bit_b) in a.chars().zip(b.chars())\
    \ {\n        if bit_a == bit_b {\n            output.push('0');\n        } else\
    \ {\n            output.push('1');\n        }\n    }\n    return output.iter().collect();",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(if a == b { '0' } else { '1' });\n    }\n    result"]
stop_tokens:
- "\n}"
