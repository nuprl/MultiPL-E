name: HumanEval_58_common
language: rs
prompt: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
  \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n///\
  \ >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
  \ l2: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
  \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
  \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
  \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n}\n"
completions: ["    let mut x = l1.clone();\n    let mut y = l2.clone();\n    x.sort();\n\
    \    y.sort();\n    let mut a = Vec::new();\n    let mut b = Vec::new();\n   \
    \ for i in 0..x.len() {\n        for j in 0..y.len() {\n            if x[i] ==\
    \ y[j] {\n                a.push(x[i]);\n                y.remove(j);\n      \
    \          break;\n            }\n        }\n    }\n    for i in 0..a.len() {\n\
    \        if i == 0 {\n            b.push(a[i]);\n        } else {\n          \
    \  if a[i] != a[i - 1] {\n                b.push(a[i]);\n            }\n     \
    \   }\n    }\n    b", "    let mut v1 = l1;\n    let mut v2 = l2;\n    v1.sort();\n\
    \    v2.sort();\n    v1.dedup();\n    v2.dedup();\n    let mut common = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    loop {\n        if i >= v1.len()\
    \ || j >= v2.len() {\n            break;\n        }\n        if v1[i] == v2[j]\
    \ {\n            common.push(v1[i]);\n            i += 1;\n            j += 1;\n\
    \        } else if v1[i] < v2[j] {\n            i += 1;\n        } else {\n  \
    \          j += 1;\n        }\n    }\n    common", '    unimplemented!();', " \
    \   let mut v = Vec::new();\n    for i in l1 {\n        if l2.contains(&i) {\n\
    \            v.push(i);\n        }\n    }\n    v.sort();\n    v.dedup();\n   \
    \ v", "    let mut tmp = l1.clone();\n    let mut result = vec![];\n    for element\
    \ in l2 {\n        if tmp.contains(&element) {\n            result.push(element);\n\
    \            tmp.remove_item(&element);\n        }\n    }\n    result.sort();\n\
    \    result.dedup();\n    result", '    unimplemented!();', "    let mut res =\
    \ Vec::new();\n    let (m, n) = (l1.len(), l2.len());\n    let (mut i, mut j)\
    \ = (0, 0);\n    while i < m && j < n {\n        if l1[i] < l2[j] {\n        \
    \    i += 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n       \
    \ } else {\n            res.push(l1[i]);\n            i += 1;\n            j +=\
    \ 1;\n        }\n    }\n    res", "    let mut uniq_l1 = l1.into_iter().collect::<HashSet<isize>>();\n\
    \    let mut uniq_l2 = l2.into_iter().collect::<HashSet<isize>>();\n    uniq_l1.retain(|x|\
    \ uniq_l2.contains(x));\n    uniq_l1.into_iter().collect::<Vec<isize>>()", " \
    \   let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n \
    \   let mut res = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    let mut res = Vec::new();\n    let mut iter1 = l1.iter();\n    let mut iter2\
    \ = l2.iter();\n    let mut v1 = iter1.next();\n    let mut v2 = iter2.next();\n\
    \    while v1.is_some() && v2.is_some() {\n        let a = v1.unwrap();\n    \
    \    let b = v2.unwrap();\n        if a == b {\n            res.push(*a);\n  \
    \          v1 = iter1.next();\n            v2 = iter2.next();\n        } else\
    \ if a < b {\n            v1 = iter1.next();\n        } else {\n            v2\
    \ = iter2.next();\n        }\n    }\n    res", "    // TODO: implement this function\n\
    \    let len1 = l1.len();\n    let len2 = l2.len();\n    let mut unique = vec![];\n\
    \    let mut common = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    if\
    \ len1 > len2 {\n        while i < len1 {\n            if !unique.contains(&l1[i])\
    \ {\n                unique.push(l1[i]);\n            }\n            i += 1;\n\
    \        }\n        while j < len2 {\n            if unique.contains(&l2[j]) {\n\
    \                common.push(l2[j]);\n            }\n            j += 1;\n   \
    \     }\n    } else {\n        while i < len2 {\n            if !unique.contains(&l2[i])\
    \ {\n                unique.push(l2[i]);\n            }\n            i += 1;\n\
    \        }\n        while j < len1 {\n            if unique.contains(&l1[j]) {\n\
    \                common.push(l1[j]);\n            }\n            j += 1;\n   \
    \     }\n    }\n    common.sort();\n    common", "    // let mut answer = Vec::new();\n\
    \    // for i in l1 {\n    //     if l2.contains(&i) {\n    //         answer.push(i);\n\
    \    //     }\n    // }\n    // answer.sort();\n    // answer.dedup();\n    //\
    \ answer\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let l1 = l1.into_iter().unique().collect::<Vec<isize>>();\n    let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut answer = Vec::new();\n  \
    \  while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n       \
    \     answer.push(l1[i]);\n            i += 1;\n            j += 1;\n        }\
    \ else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n           \
    \ j += 1;\n        }\n    }\n    answer", "    let mut set1: HashSet<isize> =\
    \ HashSet::new();\n    let mut set2: HashSet<isize> = HashSet::new();\n    let\
    \ mut res: Vec<isize> = Vec::new();\n\n    for n in l1 {\n        set1.insert(n);\n\
    \    }\n    for n in l2 {\n        set2.insert(n);\n    }\n\n    for n in set1\
    \ {\n        if set2.contains(&n) {\n            res.push(n);\n        }\n   \
    \ }\n\n    res.sort();\n    res", '    l1.into_iter().filter(|x| l2.contains(x)).collect()',
  "    let mut v1 = l1;\n    let mut v2 = l2;\n    v1.sort();\n    v2.sort();\n  \
    \  let mut common = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < v1.len() && j < v2.len() {\n        if v1[i] == v2[j] {\n            common.push(v1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if v1[i] < v2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    common", "    let mut result = Vec::new();\n    let mut temp1 = l1.clone();\n\
    \    let mut temp2 = l2.clone();\n    temp1.sort();\n    temp2.sort();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < temp1.len() && j < temp2.len()\
    \ {\n        if temp1[i] == temp2[j] {\n            result.push(temp1[i]);\n \
    \           i += 1;\n            j += 1;\n        } else if temp1[i] < temp2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    result", "    let mut res = Vec::new();\n    let mut l1 = l1;\n   \
    \ let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j]\
    \ {\n            res.push(l1[i]);\n            i += 1;\n            j += 1;\n\
    \        } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n  \
    \          j += 1;\n        }\n    }\n    res", "    // Sort vectors\n    let\
    \ mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\n    //\
    \ Walk through vectors, comparing elements\n    let mut i1 = 0;\n    let mut i2\
    \ = 0;\n    let mut out = Vec::new();\n    while i1 < l1.len() && i2 < l2.len()\
    \ {\n        let e1 = l1[i1];\n        let e2 = l2[i2];\n        if e1 == e2 {\n\
    \            out.push(e1);\n            i1 += 1;\n            i2 += 1;\n     \
    \   } else if e1 < e2 {\n            i1 += 1;\n        } else {\n            i2\
    \ += 1;\n        }\n    }\n\n    out", "    let mut vec1 = l1.clone();\n    let\
    \ mut vec2 = l2.clone();\n    vec1.sort();\n    vec2.sort();\n    let mut vec1_iter\
    \ = vec1.into_iter();\n    let mut vec2_iter = vec2.into_iter();\n    let mut\
    \ vec1_next = vec1_iter.next();\n    let mut vec2_next = vec2_iter.next();\n \
    \   let mut intersection = Vec::new();\n    while vec1_next.is_some() && vec2_next.is_some()\
    \ {\n        if vec1_next.unwrap() == vec2_next.unwrap() {\n            intersection.push(vec1_next.unwrap());\n\
    \            vec1_next = vec1_iter.next();\n            vec2_next = vec2_iter.next();\n\
    \        } else if vec1_next.unwrap() < vec2_next.unwrap() {\n            vec1_next\
    \ = vec1_iter.next();\n        } else {\n            vec2_next = vec2_iter.next();\n\
    \        }\n    }\n    intersection"]
stop_tokens:
- "\n}"
