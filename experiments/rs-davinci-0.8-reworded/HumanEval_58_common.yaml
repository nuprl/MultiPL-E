name: HumanEval_58_common
language: rs
prompt: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
  \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n///\
  \ >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
  \ l2: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
  \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
  \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
  \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n}\n"
completions: ["    let mut x = l1.clone();\n    let mut y = l2.clone();\n    x.sort();\n\
    \    y.sort();\n    let mut a = Vec::new();\n    let mut b = Vec::new();\n   \
    \ for i in 0..x.len() {\n        for j in 0..y.len() {\n            if x[i] ==\
    \ y[j] {\n                a.push(x[i]);\n                y.remove(j);\n      \
    \          break;\n            }\n        }\n    }\n    for i in 0..a.len() {\n\
    \        if i == 0 {\n            b.push(a[i]);\n        } else {\n          \
    \  if a[i] != a[i - 1] {\n                b.push(a[i]);\n            }\n     \
    \   }\n    }\n    b", "    let mut v1 = l1;\n    let mut v2 = l2;\n    v1.sort();\n\
    \    v2.sort();\n    v1.dedup();\n    v2.dedup();\n    let mut common = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    loop {\n        if i >= v1.len()\
    \ || j >= v2.len() {\n            break;\n        }\n        if v1[i] == v2[j]\
    \ {\n            common.push(v1[i]);\n            i += 1;\n            j += 1;\n\
    \        } else if v1[i] < v2[j] {\n            i += 1;\n        } else {\n  \
    \          j += 1;\n        }\n    }\n    common", '    unimplemented!();', " \
    \   let mut v = Vec::new();\n    for i in l1 {\n        if l2.contains(&i) {\n\
    \            v.push(i);\n        }\n    }\n    v.sort();\n    v.dedup();\n   \
    \ v", "    let mut tmp = l1.clone();\n    let mut result = vec![];\n    for element\
    \ in l2 {\n        if tmp.contains(&element) {\n            result.push(element);\n\
    \            tmp.remove_item(&element);\n        }\n    }\n    result.sort();\n\
    \    result.dedup();\n    result", '    unimplemented!();', "    let mut res =\
    \ Vec::new();\n    let (m, n) = (l1.len(), l2.len());\n    let (mut i, mut j)\
    \ = (0, 0);\n    while i < m && j < n {\n        if l1[i] < l2[j] {\n        \
    \    i += 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n       \
    \ } else {\n            res.push(l1[i]);\n            i += 1;\n            j +=\
    \ 1;\n        }\n    }\n    res", "    let mut uniq_l1 = l1.into_iter().collect::<HashSet<isize>>();\n\
    \    let mut uniq_l2 = l2.into_iter().collect::<HashSet<isize>>();\n    uniq_l1.retain(|x|\
    \ uniq_l2.contains(x));\n    uniq_l1.into_iter().collect::<Vec<isize>>()", " \
    \   let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n \
    \   let mut res = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    let mut res = Vec::new();\n    let mut iter1 = l1.iter();\n    let mut iter2\
    \ = l2.iter();\n    let mut v1 = iter1.next();\n    let mut v2 = iter2.next();\n\
    \    while v1.is_some() && v2.is_some() {\n        let a = v1.unwrap();\n    \
    \    let b = v2.unwrap();\n        if a == b {\n            res.push(*a);\n  \
    \          v1 = iter1.next();\n            v2 = iter2.next();\n        } else\
    \ if a < b {\n            v1 = iter1.next();\n        } else {\n            v2\
    \ = iter2.next();\n        }\n    }\n    res", "    // TODO: implement this function\n\
    \    let len1 = l1.len();\n    let len2 = l2.len();\n    let mut unique = vec![];\n\
    \    let mut common = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    if\
    \ len1 > len2 {\n        while i < len1 {\n            if !unique.contains(&l1[i])\
    \ {\n                unique.push(l1[i]);\n            }\n            i += 1;\n\
    \        }\n        while j < len2 {\n            if unique.contains(&l2[j]) {\n\
    \                common.push(l2[j]);\n            }\n            j += 1;\n   \
    \     }\n    } else {\n        while i < len2 {\n            if !unique.contains(&l2[i])\
    \ {\n                unique.push(l2[i]);\n            }\n            i += 1;\n\
    \        }\n        while j < len1 {\n            if unique.contains(&l1[j]) {\n\
    \                common.push(l1[j]);\n            }\n            j += 1;\n   \
    \     }\n    }\n    common.sort();\n    common", "    // let mut answer = Vec::new();\n\
    \    // for i in l1 {\n    //     if l2.contains(&i) {\n    //         answer.push(i);\n\
    \    //     }\n    // }\n    // answer.sort();\n    // answer.dedup();\n    //\
    \ answer\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let l1 = l1.into_iter().unique().collect::<Vec<isize>>();\n    let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut answer = Vec::new();\n  \
    \  while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n       \
    \     answer.push(l1[i]);\n            i += 1;\n            j += 1;\n        }\
    \ else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n           \
    \ j += 1;\n        }\n    }\n    answer", "    let mut set1: HashSet<isize> =\
    \ HashSet::new();\n    let mut set2: HashSet<isize> = HashSet::new();\n    let\
    \ mut res: Vec<isize> = Vec::new();\n\n    for n in l1 {\n        set1.insert(n);\n\
    \    }\n    for n in l2 {\n        set2.insert(n);\n    }\n\n    for n in set1\
    \ {\n        if set2.contains(&n) {\n            res.push(n);\n        }\n   \
    \ }\n\n    res.sort();\n    res", '    l1.into_iter().filter(|x| l2.contains(x)).collect()',
  "    let mut v1 = l1;\n    let mut v2 = l2;\n    v1.sort();\n    v2.sort();\n  \
    \  let mut common = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < v1.len() && j < v2.len() {\n        if v1[i] == v2[j] {\n            common.push(v1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if v1[i] < v2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    common", "    let mut result = Vec::new();\n    let mut temp1 = l1.clone();\n\
    \    let mut temp2 = l2.clone();\n    temp1.sort();\n    temp2.sort();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < temp1.len() && j < temp2.len()\
    \ {\n        if temp1[i] == temp2[j] {\n            result.push(temp1[i]);\n \
    \           i += 1;\n            j += 1;\n        } else if temp1[i] < temp2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    result", "    let mut res = Vec::new();\n    let mut l1 = l1;\n   \
    \ let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j]\
    \ {\n            res.push(l1[i]);\n            i += 1;\n            j += 1;\n\
    \        } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n  \
    \          j += 1;\n        }\n    }\n    res", "    // Sort vectors\n    let\
    \ mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\n    //\
    \ Walk through vectors, comparing elements\n    let mut i1 = 0;\n    let mut i2\
    \ = 0;\n    let mut out = Vec::new();\n    while i1 < l1.len() && i2 < l2.len()\
    \ {\n        let e1 = l1[i1];\n        let e2 = l2[i2];\n        if e1 == e2 {\n\
    \            out.push(e1);\n            i1 += 1;\n            i2 += 1;\n     \
    \   } else if e1 < e2 {\n            i1 += 1;\n        } else {\n            i2\
    \ += 1;\n        }\n    }\n\n    out", "    let mut vec1 = l1.clone();\n    let\
    \ mut vec2 = l2.clone();\n    vec1.sort();\n    vec2.sort();\n    let mut vec1_iter\
    \ = vec1.into_iter();\n    let mut vec2_iter = vec2.into_iter();\n    let mut\
    \ vec1_next = vec1_iter.next();\n    let mut vec2_next = vec2_iter.next();\n \
    \   let mut intersection = Vec::new();\n    while vec1_next.is_some() && vec2_next.is_some()\
    \ {\n        if vec1_next.unwrap() == vec2_next.unwrap() {\n            intersection.push(vec1_next.unwrap());\n\
    \            vec1_next = vec1_iter.next();\n            vec2_next = vec2_iter.next();\n\
    \        } else if vec1_next.unwrap() < vec2_next.unwrap() {\n            vec1_next\
    \ = vec1_iter.next();\n        } else {\n            vec2_next = vec2_iter.next();\n\
    \        }\n    }\n    intersection", "    let mut l1 = l1;\n    let mut l2 =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let\
    \ mut l3 = vec![];\n    for i in l1 {\n        if l2.contains(&i) {\n        \
    \    l3.push(i);\n        }\n    }\n    l3", "    let mut rv = Vec::new();\n \
    \   let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n    v1.sort();\n \
    \   v2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < v1.len()\
    \ && j < v2.len() {\n        if v1[i] == v2[j] {\n            rv.push(v1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if v1[i] < v2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    rv", "    // Convert both lists to hash sets.\n    let h1: HashSet<isize>\
    \ = l1.into_iter().collect();\n    let h2: HashSet<isize> = l2.into_iter().collect();\n\
    \n    // Compute the intersection of the two hash sets.\n    let intersection:\
    \ HashSet<isize> = h1.intersection(&h2).cloned().collect();\n\n    // Transform\
    \ the set into a vector and sort it.\n    let mut result: Vec<isize> = intersection.into_iter().collect();\n\
    \    result.sort();\n\n    result", "    let mut result = vec![];\n    let mut\
    \ v1 = l1.clone();\n    let mut v2 = l2.clone();\n    v1.sort();\n    v2.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len()\
    \ {\n        if v1[i] == v2[j] {\n            result.push(v1[i]);\n          \
    \  i += 1;\n            j += 1;\n        } else if v1[i] < v2[j] {\n         \
    \   i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    result",
  "  let mut l3 = l1.iter().collect::<Vec<&isize>>();\n  l3.sort();\n  let mut l4\
    \ = l2.iter().collect::<Vec<&isize>>();\n  l4.sort();\n  let mut l5 = l3.iter().cloned().collect::<Vec<isize>>();\n\
    \  l5.retain(|x| l4.binary_search(&x).is_ok());\n  l5.sort();\n  l5.dedup();\n\
    \  l5", "    let mut res = Vec::new();\n    let mut l1 = l1;\n    let mut l2 =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    let (mut i, mut j) = (0, 0);\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            if\
    \ res.len() == 0 || res[res.len() - 1] != l1[i] {\n                res.push(l1[i]);\n\
    \            }\n            i += 1;\n            j += 1;\n        } else if l1[i]\
    \ < l2[j] {\n            i += 1;\n        } else {\n            j += 1;\n    \
    \    }\n    }\n    res", '    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()',
  "    let mut common_elements: Vec<isize> = Vec::new();\n    let mut sorted_unique_list1\
    \ = sorted_unique(l1);\n    let mut sorted_unique_list2 = sorted_unique(l2);\n\
    \    while sorted_unique_list1.len() > 0 && sorted_unique_list2.len() > 0 {\n\
    \        let value1 = sorted_unique_list1[0];\n        let value2 = sorted_unique_list2[0];\n\
    \        if value1 < value2 {\n            sorted_unique_list1.remove(0);\n  \
    \      } else if value1 > value2 {\n            sorted_unique_list2.remove(0);\n\
    \        } else {\n            common_elements.push(value1);\n            sorted_unique_list1.remove(0);\n\
    \            sorted_unique_list2.remove(0);\n        }\n    }\n    common_elements",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut res = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res", "    let set1: HashSet<_> = l1.iter().collect();\n    let set2: HashSet<_>\
    \ = l2.iter().collect();\n    let result = set1.intersection(&set2).cloned().collect::<Vec<isize>>();\n\
    \    result.sort();\n    result", "    let mut result = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] == l2[j] {\n            if result.len() == 0 || result[result.len()\
    \ - 1] != l1[i] {\n                result.push(l1[i]);\n            }\n      \
    \      i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n     \
    \       i += 1;\n        } else {\n            j += 1;\n        }\n    }\n   \
    \ result", '    l1.iter().cloned().filter(|x| l2.contains(x)).collect()', "  \
    \  let mut t1 = l1.clone();\n    let mut t2 = l2.clone();\n    t1.sort();\n  \
    \  t2.sort();\n    let mut t3 = Vec::new();\n    let mut i = 0;\n    let mut j\
    \ = 0;\n    while i < t1.len() && j < t2.len() {\n        if t1[i] < t2[j] {\n\
    \            i += 1;\n        } else if t1[i] > t2[j] {\n            j += 1;\n\
    \        } else {\n            t3.push(t1[i]);\n            i += 1;\n        \
    \    j += 1;\n        }\n    }\n    t3", "    let mut result = l1\n        .iter()\n\
    \        .filter(|&x| l2.contains(x))\n        .cloned()\n        .collect::<Vec<isize>>();\n\
    \    result.sort();\n    result.dedup();\n    result", "    let mut result = Vec::new();\n\
    \    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    let mut l1idx = 0;\n    let mut l2idx = 0;\n    while l1idx < l1.len() &&\
    \ l2idx < l2.len() {\n        if l1[l1idx] == l2[l2idx] {\n            result.push(l1[l1idx]);\n\
    \            l1idx += 1;\n            l2idx += 1;\n        } else if l1[l1idx]\
    \ < l2[l2idx] {\n            l1idx += 1;\n        } else {\n            l2idx\
    \ += 1;\n        }\n    }\n    result", '    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()',
  "    let mut result = Vec::new();\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let mut\
    \ iter1 = l1.iter();\n    let mut iter2 = l2.iter();\n    let mut item1 = iter1.next();\n\
    \    let mut item2 = iter2.next();\n    while item1.is_some() && item2.is_some()\
    \ {\n        if item1.unwrap() < item2.unwrap() {\n            item1 = iter1.next();\n\
    \        } else if item1.unwrap() > item2.unwrap() {\n            item2 = iter2.next();\n\
    \        } else {\n            result.push(*item1.unwrap());\n            item1\
    \ = iter1.next();\n            item2 = iter2.next();\n        }\n    }\n    result",
  '    unimplemented!();', "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let mut uniqued = l1.clone();\n    uniqued.dedup();\n   \
    \ uniqued.retain(|x| l2.contains(x));\n    uniqued", '    vec![]', "    let mut\
    \ l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> = l2;\n    l1.sort();\n   \
    \ l2.sort();\n    let mut l: Vec<isize> = Vec::new();\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ == l2[j] {\n            l.push(l1[i]);\n            i += 1;\n            j +=\
    \ 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    l", "    let mut ht: HashMap<isize,\
    \ bool> = HashMap::new();\n    let mut result: Vec<isize> = Vec::new();\n    for\
    \ elem in l1 {\n        ht.insert(elem, true);\n    }\n    for elem in l2 {\n\
    \        if ht.contains_key(&elem) {\n            result.push(elem);\n       \
    \ }\n    }\n    result.sort();\n    result.dedup();\n    result", '    unimplemented!();',
  "    let mut v: Vec<isize> = Vec::new();\n    let mut h1: HashSet<isize> = HashSet::new();\n\
    \    let mut h2: HashSet<isize> = HashSet::new();\n    for i in l1 {\n       \
    \ h1.insert(i);\n    }\n    for i in l2 {\n        h2.insert(i);\n    }\n    for\
    \ i in h1 {\n        if h2.contains(&i) {\n            v.push(i);\n        }\n\
    \    }\n    v.sort();\n    v", "    let mut list1 = l1.clone();\n    let mut list2\
    \ = l2.clone();\n    list1.sort();\n    list2.sort();\n    let mut l1_i = 0;\n\
    \    let mut l2_i = 0;\n    let mut common_list = Vec::new();\n    while l1_i\
    \ < list1.len() && l2_i < list2.len() {\n        if list1[l1_i] == list2[l2_i]\
    \ {\n            common_list.push(list1[l1_i]);\n            l1_i += 1;\n    \
    \        l2_i += 1;\n        } else if list1[l1_i] < list2[l2_i] {\n         \
    \   l1_i += 1;\n        } else {\n            l2_i += 1;\n        }\n    }\n \
    \   common_list", "    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize>\
    \ = l2;\n    l1.sort();\n    l2.sort();\n    let mut res: Vec<isize> = Vec::new();\n\
    \    let mut a = 0;\n    let mut b = 0;\n    while a < l1.len() && b < l2.len()\
    \ {\n        if l1[a] < l2[b] {\n            a += 1;\n        } else if l1[a]\
    \ > l2[b] {\n            b += 1;\n        } else {\n            res.push(l1[a]);\n\
    \            a += 1;\n            b += 1;\n        }\n    }\n    res", "    let\
    \ mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let\
    \ mut r: Vec<isize> = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n\
    \    loop {\n        if i1 == l1.len() || i2 == l2.len() {\n            break;\n\
    \        }\n        if l1[i1] == l2[i2] {\n            r.push(l1[i1]);\n     \
    \       i1 += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2] {\n\
    \            i1 += 1;\n        } else {\n            i2 += 1;\n        }\n   \
    \ }\n    r", "    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> = l2;\n\
    \    let mut output: Vec<isize> = Vec::new();\n    l1.sort();\n    l2.sort();\n\
    \    let mut it1 = l1.iter();\n    let mut it2 = l2.iter();\n    let mut e1 =\
    \ it1.next();\n    let mut e2 = it2.next();\n    while e1.is_some() && e2.is_some()\
    \ {\n        if e1.unwrap() < e2.unwrap() {\n            e1 = it1.next();\n  \
    \      } else if e1.unwrap() > e2.unwrap() {\n            e2 = it2.next();\n \
    \       } else {\n            output.push(*e1.unwrap());\n            e1 = it1.next();\n\
    \            e2 = it2.next();\n        }\n    }\n    output", "    let mut set1:\
    \ HashSet<isize> = HashSet::new();\n    let mut set2: HashSet<isize> = HashSet::new();\n\
    \    for i in l1 {\n        set1.insert(i);\n    }\n    for i in l2 {\n      \
    \  set2.insert(i);\n    }\n    let mut result: Vec<isize> = Vec::new();\n    for\
    \ i in set1.intersection(&set2) {\n        result.push(*i);\n    }\n    result.sort();\n\
    \    result", '    unimplemented!()', "    let mut result = Vec::new();\n    let\
    \ mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let len1 = l1.len();\n    let len2 = l2.len();\n\
    \    while i < len1 && j < len2 {\n        if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n        } else {\n\
    \            result.push(l1[i]);\n            i += 1;\n            j += 1;\n \
    \       }\n    }\n    result", '    unimplemented!()', "    let mut v: Vec<isize>\
    \ = l1.iter().cloned().collect();\n    v.extend(l2.iter().cloned());\n    v.sort();\n\
    \    v.dedup();\n    v", '    l1.into_iter().filter(|x| l2.contains(x)).collect()',
  "    let mut uniq = HashSet::new();\n    for &x in &l1 {\n        uniq.insert(x);\n\
    \    }\n    for &x in &l2 {\n        uniq.insert(x);\n    }\n    uniq.iter().cloned().collect()",
  "    let mut nums1 = l1;\n    let mut nums2 = l2;\n    nums1.sort();\n    nums2.sort();\n\
    \    let mut nums1_it = nums1.iter();\n    let mut nums2_it = nums2.iter();\n\
    \    let mut nums1_element = nums1_it.next();\n    let mut nums2_element = nums2_it.next();\n\
    \    let mut out = Vec::new();\n    while nums1_element != None && nums2_element\
    \ != None {\n        let a = nums1_element.unwrap();\n        let b = nums2_element.unwrap();\n\
    \        if a == b {\n            out.push(*a);\n            nums1_element = nums1_it.next();\n\
    \            nums2_element = nums2_it.next();\n        } else if a < b {\n   \
    \         nums1_element = nums1_it.next();\n        } else {\n            nums2_element\
    \ = nums2_it.next();\n        }\n    }\n    out", "    // TODO\n    unimplemented!()",
  "    fn cmp(x: &isize, y: &isize) -> Ordering {\n        if x < y {\n          \
    \  Ordering::Less\n        } else if x > y {\n            Ordering::Greater\n\
    \        } else {\n            Ordering::Equal\n        }\n    }\n\n    let mut\
    \ l3 = l1.clone();\n    l3.extend(l2.clone());\n    l3.sort_by(cmp);\n    let\
    \ mut l4 = Vec::new();\n    let mut last_x = None;\n    for x in l3 {\n      \
    \  if x == last_x.unwrap_or(0) {\n            l4.push(x);\n        }\n       \
    \ last_x = Some(x);\n    }\n    l4", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut result = Vec::new();\n    let mut\
    \ a1 = l1.iter();\n    let mut a2 = l2.iter();\n    let mut e1 = a1.next();\n\
    \    let mut e2 = a2.next();\n    while e1.is_some() && e2.is_some() {\n     \
    \   let v1 = e1.unwrap();\n        let v2 = e2.unwrap();\n        if v1 == v2\
    \ {\n            result.push(*v1);\n            e1 = a1.next();\n            e2\
    \ = a2.next();\n        } else if v1 < v2 {\n            e1 = a1.next();\n   \
    \     } else {\n            e2 = a2.next();\n        }\n    }\n    result", " \
    \   let mut set1: HashSet<isize> = HashSet::new();\n    let mut set2: HashSet<isize>\
    \ = HashSet::new();\n    let mut new_list: Vec<isize> = Vec::new();\n\n    for\
    \ item in l1 {\n        set1.insert(item);\n    }\n\n    for item in l2 {\n  \
    \      set2.insert(item);\n    }\n\n    for item in set1 {\n        if set2.contains(&item)\
    \ {\n            new_list.push(item);\n        }\n    }\n\n    new_list.sort();\n\
    \    new_list", '    l1.into_iter().filter(|x| l2.contains(x)).collect()', " \
    \   let set1: HashSet<isize> = l1.into_iter().collect();\n    let set2: HashSet<isize>\
    \ = l2.into_iter().collect();\n    let commons = set1.intersection(&set2);\n \
    \   let mut sorted_commons: Vec<isize> = commons.cloned().collect();\n    sorted_commons.sort();\n\
    \    sorted_commons", '    vec![]', "    // build intersections\n    let mut l1_s\
    \ = l1.clone();\n    let mut l2_s = l2.clone();\n    l1_s.sort();\n    l2_s.sort();\n\
    \    l1_s.dedup();\n    l2_s.dedup();\n    let mut l1_s = l1_s.iter();\n    let\
    \ mut l2_s = l2_s.iter();\n    let mut l1_s_cur = l1_s.next();\n    let mut l2_s_cur\
    \ = l2_s.next();\n    let mut res = Vec::new();\n    loop {\n        match (l1_s_cur,\
    \ l2_s_cur) {\n            (Some(v1), Some(v2)) => {\n                if v1 <\
    \ v2 {\n                    l1_s_cur = l1_s.next();\n                } else if\
    \ v1 > v2 {\n                    l2_s_cur = l2_s.next();\n                } else\
    \ {\n                    res.push(*v1);\n                    l1_s_cur = l1_s.next();\n\
    \                    l2_s_cur = l2_s.next();\n                }\n            }\n\
    \            _ => break,\n        }\n    }\n    res", "    let mut res = vec![];\n\
    \    for x in l1 {\n        if l2.contains(&x) {\n            res.push(x);\n \
    \       }\n    }\n    res.sort();\n    res.dedup();\n    res", "    let mut common_vec:\
    \ Vec<isize> = Vec::new();\n    let mut first_iter = l1.iter();\n    let mut second_iter\
    \ = l2.iter();\n    loop {\n        let mut el1 = first_iter.next();\n       \
    \ let mut el2 = second_iter.next();\n        match (el1, el2) {\n            (Some(first),\
    \ Some(second)) => {\n                if first == second {\n                 \
    \   common_vec.push(*first);\n                } else if first < second {\n   \
    \                 el2 = second_iter.next();\n                } else {\n      \
    \              el1 = first_iter.next();\n                }\n            }\n  \
    \          _ => break,\n        }\n    }\n    common_vec", "    // These are ordered\
    \ arrays\n    // We should sort and then return the sorted unique elements\n \
    \   let mut l3 = vec![];\n    let mut p1 = 0;\n    let mut p2 = 0;\n    let len1\
    \ = l1.len();\n    let len2 = l2.len();\n    while p1 < len1 && p2 < len2 {\n\
    \        if l1[p1] < l2[p2] {\n            p1 += 1;\n        } else if l1[p1]\
    \ > l2[p2] {\n            p2 += 1;\n        } else {\n            l3.push(l1[p1]);\n\
    \            p1 += 1;\n            p2 += 1;\n        }\n    }\n    l3", "    let\
    \ mut result = vec![];\n    let mut l1_clone = l1.clone();\n    let mut l2_clone\
    \ = l2.clone();\n    for i in l1_clone {\n        for j in l2_clone.clone() {\n\
    \            if i == j {\n                result.push(i);\n                let\
    \ index = l2_clone.iter().position(|&x| x == j).unwrap();\n                l2_clone.remove(index);\n\
    \            }\n        }\n    }\n    result.sort();\n    result.dedup();\n  \
    \  result", "    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> = l2;\n\
    \    let mut common: Vec<isize> = Vec::new();\n    l1.sort();\n    l2.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len()\
    \ {\n        if l1[i] == l2[j] {\n            common.push(l1[i]);\n          \
    \  i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n         \
    \   i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    common",
  "    let mut common_values: Vec<isize> = vec![];\n    let mut set2: HashSet<isize>\
    \ = HashSet::new();\n    for val in l2 {\n        set2.insert(val);\n    }\n \
    \   for val in l1 {\n        if set2.contains(&val) {\n            common_values.push(val);\n\
    \        }\n    }\n    common_values.sort();\n    common_values.dedup();\n   \
    \ common_values", '    unimplemented!()', "    let mut result = Vec::new();\n\
    \    let mut a = l1.clone();\n    let mut b = l2.clone();\n    a.sort();\n   \
    \ b.sort();\n    while a.len() > 0 && b.len() > 0 {\n        if a[0] == b[0] {\n\
    \            result.push(a[0]);\n            a.remove(0);\n            b.remove(0);\n\
    \        } else if a[0] < b[0] {\n            a.remove(0);\n        } else {\n\
    \            b.remove(0);\n        }\n    }\n    result", "    let mut unique\
    \ = vec![];\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    let (mut i, mut j) = (0, 0);\n    while i < l1.len() && j < l2.len() {\n\
    \        if l1[i] == l2[j] {\n            if unique.is_empty() || unique[unique.len()\
    \ - 1] != l1[i] {\n                unique.push(l1[i]);\n            }\n      \
    \      i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n     \
    \       i += 1;\n        } else {\n            j += 1;\n        }\n    }\n   \
    \ unique", "    let mut common_vector: Vec<isize> = Vec::new();\n    let mut current_left_pointer\
    \ = 0;\n    let mut current_right_pointer = 0;\n    let mut left_vector = l1.clone();\n\
    \    let mut right_vector = l2.clone();\n    left_vector.sort();\n    right_vector.sort();\n\
    \    left_vector.dedup();\n    right_vector.dedup();\n    while current_left_pointer\
    \ < left_vector.len() && current_right_pointer < right_vector.len() {\n      \
    \  let current_left_element = left_vector[current_left_pointer];\n        let\
    \ current_right_element = right_vector[current_right_pointer];\n        if current_left_element\
    \ == current_right_element {\n            common_vector.push(current_left_element);\n\
    \            current_left_pointer += 1;\n            current_right_pointer +=\
    \ 1;\n        } else if current_left_element < current_right_element {\n     \
    \       current_left_pointer += 1;\n        } else {\n            current_right_pointer\
    \ += 1;\n        }\n    }\n    common_vector", "    let mut v1 = l1;\n    let\
    \ mut v2 = l2;\n    v1.sort();\n    v2.sort();\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len()\
    \ {\n        if v1[i] < v2[j] {\n            i += 1;\n        } else if v1[i]\
    \ > v2[j] {\n            j += 1;\n        } else {\n            if result.is_empty()\
    \ || v1[i] != result[result.len() - 1] {\n                result.push(v1[i]);\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n    }\n \
    \   result", "  let mut l1 = l1;\n  let mut l2 = l2;\n  l1.sort();\n  l2.sort();\n\
    \  let mut common: Vec<isize> = Vec::new();\n  for n in l1 {\n    if l2.contains(&n)\
    \ {\n      common.push(n);\n    }\n  }\n  common.sort();\n  common.dedup();\n\
    \  common", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    let mut common = vec![];\n    let mut last = None;\n    for i in l1.iter()\
    \ {\n        for j in l2.iter() {\n            if i == j && last != Some(*i) {\n\
    \                common.push(*i);\n                last = Some(*i);\n        \
    \    }\n        }\n    }\n    common", "    let mut result = l1.clone();\n   \
    \ result.extend(l2.clone());\n    result.sort();\n    result.dedup();\n    result.iter().filter(|&x|\
    \ l1.contains(x) && l2.contains(x)).cloned().collect()", "    let mut v = Vec::new();\n\
    \    let mut s = BTreeSet::new();\n    for i in l1 {\n        s.insert(i);\n \
    \   }\n    for i in l2 {\n        if s.contains(&i) {\n            v.push(i);\n\
    \        }\n    }\n    v.sort();\n    v", "    let mut v = l1.clone();\n    v.sort();\n\
    \    let mut v_u = v.clone();\n    v_u.dedup();\n    let mut v2 = l2.clone();\n\
    \    v2.sort();\n    let mut v2_u = v2.clone();\n    v2_u.dedup();\n    let mut\
    \ a = Vec::new();\n    for i in v_u {\n        for j in v2_u {\n            if\
    \ i == j {\n                a.push(i);\n            }\n        }\n    }\n    a",
  "    let mut v = l1.into_iter().collect::<Vec<isize>>();\n    v.sort();\n    v.dedup();\n\
    \    let mut v2 = l2.into_iter().collect::<Vec<isize>>();\n    v2.sort();\n  \
    \  v2.dedup();\n    v.into_iter().filter(|&x| v2.contains(&x)).collect()", " \
    \   let mut res = vec![];\n    for i in l1 {\n        if l2.contains(&i) {\n \
    \           res.push(i);\n        }\n    }\n    res.sort();\n    res.dedup();\n\
    \    res", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    let mut set1 = BTreeSet::new();\n    let mut set2 = BTreeSet::new();\n  \
    \  let mut result = Vec::new();\n    for elem in l1 {\n        set1.insert(elem);\n\
    \    }\n    for elem in l2 {\n        set2.insert(elem);\n    }\n    for elem\
    \ in set1.intersection(&set2) {\n        result.push(*elem);\n    }\n    result",
  "    let mut result = vec![];\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while\
    \ i1 < l1.len() && i2 < l2.len() {\n        let el1 = l1[i1];\n        let el2\
    \ = l2[i2];\n        if el1 == el2 {\n            result.push(el1);\n        \
    \    i1 += 1;\n            i2 += 1;\n        } else if el1 < el2 {\n         \
    \   i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n    result",
  "    let mut v = l1.iter().cloned().collect::<Vec<isize>>();\n    v.sort();\n  \
    \  v.dedup();\n    let mut v2 = l2.iter().cloned().collect::<Vec<isize>>();\n\
    \    v2.sort();\n    v2.dedup();\n    let mut intersection = vec![];\n    for\
    \ el in v {\n        if v2.contains(&el) {\n            intersection.push(el);\n\
    \        }\n    }\n    intersection", "    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    for v in l1 {\n        set1.insert(v);\n    }\n    let mut set2: HashSet<isize>\
    \ = HashSet::new();\n    for v in l2 {\n        set2.insert(v);\n    }\n    let\
    \ mut result: Vec<isize> = vec![];\n    for v in set1.intersection(&set2) {\n\
    \        result.push(*v);\n    }\n    result.sort();\n    result", '    unimplemented!()',
  "    let mut result = vec![];\n    for i in l1 {\n        if let Ok(_) = l2.binary_search(&i)\
    \ {\n            result.push(i);\n        }\n    }\n    result.sort();\n    result.dedup();\n\
    \    result", "    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n  \
    \  v1.sort();\n    v2.sort();\n    v1.dedup();\n    v2.dedup();\n    let mut l\
    \ = vec![];\n    for x in v1 {\n        if v2.contains(&x) {\n            l.push(x);\n\
    \        }\n    }\n    l", "    let mut a = l1.clone();\n    let mut b = l2.clone();\n\
    \    a.sort();\n    b.sort();\n    a.into_iter().filter(|x| b.contains(x)).collect()",
  '    unimplemented!()', "    let mut res = Vec::new();\n    let mut l1 = l1;\n \
    \   let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut idx1 = 0;\n\
    \    let mut idx2 = 0;\n    let len1 = l1.len();\n    let len2 = l2.len();\n \
    \   loop {\n        if idx1 == len1 || idx2 == len2 {\n            break;\n  \
    \      }\n        if l1[idx1] == l2[idx2] {\n            res.push(l1[idx1]);\n\
    \            idx1 += 1;\n            idx2 += 1;\n        } else if l1[idx1] <\
    \ l2[idx2] {\n            idx1 += 1;\n        } else {\n            idx2 += 1;\n\
    \        }\n    }\n    res", '    unimplemented!()', "    let mut v1 = l1.clone();\n\
    \    let mut v2 = l2.clone();\n    v1.sort();\n    v2.sort();\n    let mut v3\
    \ = Vec::new();\n    let mut v4 = Vec::new();\n    v1.dedup();\n    v2.dedup();\n\
    \    for i in v1 {\n        for j in v2.clone() {\n            if i == j {\n \
    \               v3.push(i);\n            }\n        }\n    }\n    for i in v3\
    \ {\n        v4.push(i);\n    }\n    v4", "    l1.into_iter().collect::<HashSet<isize>>()\n\
    \        .intersection(&l2.into_iter().collect::<HashSet<isize>>())\n        .map(|x|\
    \ *x)\n        .collect::<Vec<isize>>()", '    l1.iter().filter(|&i| l2.contains(i)).map(|i|
    *i).collect::<Vec<isize>>()', "    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut l: Vec<isize>\
    \ = Vec::new();\n\n    for i in l1 {\n        set1.insert(i);\n    }\n    for\
    \ i in l2 {\n        set2.insert(i);\n    }\n\n    for i in set1 {\n        if\
    \ set2.contains(&i) {\n            l.push(i);\n        }\n    }\n\n    l.sort();\n\
    \    l", "    let mut list = l1.clone();\n    list.extend(l2.clone());\n    let\
    \ mut list = list.into_iter().collect::<HashSet<isize>>();\n    list.retain(|&x|\
    \ l1.contains(&x) && l2.contains(&x));\n    list.into_iter().collect::<Vec<isize>>()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|x| l2.contains(x)).cloned().collect()",
  "    let mut set1: HashSet<isize> = HashSet::new();\n    let mut set2: HashSet<isize>\
    \ = HashSet::new();\n    for i in l1 {\n        set1.insert(i);\n    }\n    for\
    \ i in l2 {\n        set2.insert(i);\n    }\n    let mut set3: HashSet<isize>\
    \ = HashSet::new();\n    for i in set1 {\n        if set2.contains(&i) {\n   \
    \         set3.insert(i);\n        }\n    }\n    let mut ret: Vec<isize> = Vec::new();\n\
    \    for i in set3 {\n        ret.push(i);\n    }\n    ret.sort();\n    ret",
  "    let mut s1 = l1.into_iter().collect::<BTreeSet<_>>();\n    let mut s2 = l2.into_iter().collect::<BTreeSet<_>>();\n\
    \    s1.retain(|&x| s2.contains(&x));\n    s1.into_iter().collect()", "    let\
    \ mut ll1 = l1.clone();\n    let mut ll2 = l2.clone();\n    ll1.sort();\n    ll2.sort();\n\
    \    let mut l = Vec::new();\n    let mut j = 0;\n    for i in 0..ll1.len() {\n\
    \        while j < ll2.len() && ll2[j] < ll1[i] {\n            j += 1;\n     \
    \   }\n        if j < ll2.len() && ll2[j] == ll1[i] {\n            l.push(ll2[j]);\n\
    \        }\n    }\n    l", "    l1.into_iter().sorted().collect::<HashSet<isize>>()\n\
    \        .intersection(&l2.into_iter().sorted().collect::<HashSet<isize>>())\n\
    \        .cloned().collect::<Vec<isize>>()", '    unimplemented!();', "    let\
    \ mut res = vec![];\n    for i in 0..l1.len() {\n        for j in 0..l2.len()\
    \ {\n            if l1[i] == l2[j] {\n                res.push(l1[i]);\n     \
    \       }\n        }\n    }\n    res.sort();\n    res.dedup();\n    res", "  \
    \  let mut l3 = l1;\n    l3.sort();\n    l3.dedup();\n    let mut l4 = l2;\n \
    \   l4.sort();\n    l4.dedup();\n    let mut l5 = Vec::new();\n    for i in l3\
    \ {\n        if l4.contains(&i) {\n            l5.push(i);\n        }\n    }\n\
    \    l5", "    let mut set1: HashSet<isize> = HashSet::new();\n    for i in l1\
    \ {\n        set1.insert(i);\n    }\n    let mut set2: HashSet<isize> = HashSet::new();\n\
    \    for i in l2 {\n        set2.insert(i);\n    }\n    let intersection: HashSet<isize>\
    \ = set1.intersection(&set2).map(|x| *x).collect();\n    let mut ret: Vec<isize>\
    \ = Vec::new();\n    for i in intersection {\n        ret.push(i);\n    }\n  \
    \  ret.sort();\n    ret", "    let mut result = Vec::new();\n    let mut l1 =\
    \ l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.retain(|x| l2.contains(x));\n    result.extend(l1);\n\
    \    result", "    let mut res = vec![];\n    let mut l1 = l1;\n    let mut l2\
    \ = l2;\n    l1.sort();\n    l2.sort();\n    // TODO: Implement me!\n    let mut\
    \ a = 0;\n    let mut b = 0;\n    while a < l1.len() && b < l2.len() {\n     \
    \   if l1[a] == l2[b] {\n            if !res.contains(&l1[a]) {\n            \
    \    res.push(l1[a]);\n            }\n            a += 1;\n            b += 1;\n\
    \        } else if l1[a] < l2[b] {\n            a += 1;\n        } else {\n  \
    \          b += 1;\n        }\n    }\n    res", "    let mut l1 = l1;\n    let\
    \ mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len()\
    \ {\n        if l1[i] == l2[j] {\n            if res.len() == 0 || res[res.len()\
    \ - 1] != l1[i] {\n                res.push(l1[i]);\n            }\n         \
    \   i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n        \
    \    i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    res",
  "    let mut result = Vec::new();\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    for el\
    \ in l1 {\n        if l2.contains(&el) {\n            result.push(el);\n     \
    \   }\n    }\n    result", "  let mut l1 = l1;\n  let mut l2 = l2;\n  l1.sort();\n\
    \  l2.sort();\n  let mut i = 0;\n  let mut j = 0;\n  let mut common = Vec::new();\n\
    \  while i < l1.len() && j < l2.len() {\n    if l1[i] < l2[j] {\n      i += 1;\n\
    \    } else if l1[i] > l2[j] {\n      j += 1;\n    } else {\n      common.push(l1[i]);\n\
    \      i += 1;\n      j += 1;\n    }\n  }\n  common", "    let mut v1 = l1;\n\
    \    let mut v2 = l2;\n    v1.sort();\n    v2.sort();\n    let mut res = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len()\
    \ {\n        if v1[i] < v2[j] {\n            i += 1;\n        } else if v1[i]\
    \ > v2[j] {\n            j += 1;\n        } else {\n            res.push(v1[i]);\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    res", "    //\
    \ TODO\n    let mut v = Vec::new();\n    for i in l1 {\n        for j in l2 {\n\
    \            if i == j {\n                v.push(i);\n            }\n        }\n\
    \    }\n    v.sort();\n    v.dedup();\n    v", "    let set1: HashSet<isize> =\
    \ l1.into_iter().collect();\n    let set2: HashSet<isize> = l2.into_iter().collect();\n\
    \    let result: HashSet<isize> = set1.intersection(&set2).cloned().collect();\n\
    \    let mut vec = result.into_iter().collect::<Vec<isize>>();\n    vec.sort();\n\
    \    vec", "    let mut l3 = l1.into_iter().collect::<Vec<isize>>();\n    let\
    \ mut l4 = l2.into_iter().collect::<Vec<isize>>();\n    l3.sort();\n    l4.sort();\n\
    \    let mut l5 = Vec::new();\n    let mut j = 0;\n    for i in 0..l3.len() {\n\
    \        if j < l4.len() && l3[i] == l4[j] {\n            l5.push(l3[i]);\n  \
    \          j += 1;\n        } else if j < l4.len() && l3[i] > l4[j] {\n      \
    \      j += 1;\n            i -= 1;\n        }\n    }\n    l5", "    let set1:\
    \ HashSet<isize> = l1.into_iter().collect();\n    let set2: HashSet<isize> = l2.into_iter().collect();\n\
    \    let mut res: Vec<isize> = set1.intersection(&set2).cloned().collect();\n\
    \    res.sort();\n    res", '    vec![]', "    let mut set1: HashSet<isize> =\
    \ HashSet::new();\n    let mut set2: HashSet<isize> = HashSet::new();\n    for\
    \ i in l1 {\n        set1.insert(i);\n    }\n    for i in l2 {\n        set2.insert(i);\n\
    \    }\n    let mut common: Vec<isize> = Vec::new();\n    for i in set1.intersection(&set2)\
    \ {\n        common.push(*i);\n    }\n    common.sort();\n    common", "    let\
    \ mut s1 = l1.clone();\n    let mut s2 = l2.clone();\n    s1.sort();\n    s2.sort();\n\
    \    let mut unique_list: Vec<isize> = Vec::new();\n    for i in s1.iter() {\n\
    \        if s2.contains(i) {\n            if !unique_list.contains(i) {\n    \
    \            unique_list.push(*i);\n            }\n        }\n    }\n    unique_list",
  "    let mut common_vec: Vec<isize> = Vec::new();\n    for i in l1 {\n        if\
    \ l2.contains(&i) {\n            common_vec.push(i);\n        }\n    }\n    common_vec.sort();\n\
    \    common_vec.dedup();\n    common_vec", '    unimplemented!()', "    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ res = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            if res.len() ==\
    \ 0 || l1[i] != res[res.len() - 1] {\n                res.push(l1[i]);\n     \
    \       }\n            i += 1;\n            j += 1;\n        } else if l1[i] <\
    \ l2[j] {\n            i += 1;\n        } else {\n            j += 1;\n      \
    \  }\n    }\n    res", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let mut l1_set = HashSet::new();\n    let mut common = Vec::new();\n\
    \    for i in l1 {\n        l1_set.insert(i);\n    }\n    for i in l2 {\n    \
    \    if l1_set.contains(&i) {\n            common.push(i);\n        }\n    }\n\
    \    common.sort();\n    common.dedup();\n    common", "    let mut iter = l1.iter().cloned().filter(|&x|\
    \ l2.contains(&x));\n    let mut l = Vec::new();\n    for e in iter {\n      \
    \  l.push(e);\n    }\n    l.sort();\n    l.dedup();\n    l", '    l1.into_iter().filter(|&i|
    l2.contains(&i)).collect()', "    let mut s1 = HashSet::new();\n    let mut s2\
    \ = HashSet::new();\n    let mut out = HashSet::new();\n    for i in l1 {\n  \
    \      s1.insert(i);\n    }\n    for i in l2 {\n        s2.insert(i);\n    }\n\
    \    for i in s1 {\n        if s2.contains(&i) {\n            out.insert(i);\n\
    \        }\n    }\n    let mut out: Vec<isize> = out.into_iter().collect();\n\
    \    out.sort();\n    out", "    let mut v = Vec::new();\n    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    for x in l1 {\n        if l2.contains(&x) {\n            v.push(x);\n   \
    \     }\n    }\n    v", "    let mut r = vec![];\n    let l1s = l1.clone();\n\
    \    let l2s = l2.clone();\n    for i in l1s {\n        if l2s.contains(&i) {\n\
    \            r.push(i);\n        }\n    }\n    r.sort();\n    let mut s = vec![];\n\
    \    let rs = r.clone();\n    for i in rs {\n        if !s.contains(&i) {\n  \
    \          s.push(i);\n        }\n    }\n    s", "    let mut result = vec![];\n\
    \    for n in l1 {\n        if l2.contains(&n) {\n            result.push(n);\n\
    \        }\n    }\n    result.sort();\n    result.dedup();\n    result", "   \
    \ let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n   \
    \ let mut v: Vec<isize> = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n\
    \    while i1 < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n \
    \           v.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n    \
    \    } else if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n   \
    \         i2 += 1;\n        }\n    }\n    v", "    let mut res = vec![];\n   \
    \ let mut i = 0;\n    let mut j = 0;\n    let mut n1 = l1.len();\n    let mut\
    \ n2 = l2.len();\n    while i < n1 && j < n2 {\n        if l1[i] == l2[j] {\n\
    \            res.push(l1[i]);\n            i += 1;\n            j += 1;\n    \
    \    } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n      \
    \      j += 1;\n        }\n    }\n    res", "    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut common = vec![];\n   \
    \ let mut i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n\
    \        if l1[i] == l2[j] {\n            common.push(l1[i]);\n            i +=\
    \ 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    common", " \
    \   let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n \
    \   l1.retain(|x| l2.contains(x));\n    let mut l3 = l1.clone();\n    l3.dedup();\n\
    \    l3", "    let mut u1 = l1.clone();\n    let mut u2 = l2.clone();\n    u1.sort();\n\
    \    u2.sort();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    let mut c: Vec<isize>\
    \ = Vec::new();\n    while i1 < u1.len() && i2 < u2.len() {\n        if u1[i1]\
    \ == u2[i2] {\n            c.push(u1[i1]);\n            i1 += 1;\n           \
    \ i2 += 1;\n        } else if u1[i1] < u2[i2] {\n            i1 += 1;\n      \
    \  } else {\n            i2 += 1;\n        }\n    }\n    c", "    let mut l1 =\
    \ l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut result = Vec::new();\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            result.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    result", '    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()',
  "    let mut x: Vec<isize> = l1.into_iter().collect();\n    let mut y: Vec<isize>\
    \ = l2.into_iter().collect();\n    x.sort();\n    y.sort();\n    let mut result:\
    \ Vec<isize> = Vec::new();\n    let mut i: usize = 0;\n    let mut j: usize =\
    \ 0;\n    while i < x.len() && j < y.len() {\n        if x[i] == y[j] {\n    \
    \        result.push(x[i]);\n            i += 1;\n            j += 1;\n      \
    \  } else if x[i] < y[j] {\n            i += 1;\n        } else {\n          \
    \  j += 1;\n        }\n    }\n    result", "    let mut res = Vec::new();\n  \
    \  let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut set = HashSet::new();\n    let mut i = 0;\n    let mut j = 0;\n   \
    \ let mut len1 = l1.len();\n    let mut len2 = l2.len();\n    while i < len1 &&\
    \ j < len2 {\n        if l1[i] == l2[j] {\n            if !set.contains(&l1[i])\
    \ {\n                res.push(l1[i]);\n                set.insert(l1[i]);\n  \
    \          }\n            i += 1;\n            j += 1;\n        } else if l1[i]\
    \ < l2[j] {\n            i += 1;\n        } else {\n            j += 1;\n    \
    \    }\n    }\n    res", "    let mut v1 = l1;\n    let mut v2 = l2;\n    v1.sort();\n\
    \    v2.sort();\n    let mut res = Vec::new();\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < v1.len() && j < v2.len() {\n        if v1[i] < v2[j] {\n\
    \            i += 1;\n        } else if v1[i] > v2[j] {\n            j += 1;\n\
    \        } else {\n            res.push(v1[i]);\n            i += 1;\n       \
    \     j += 1;\n        }\n    }\n    res", "    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut common = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len()\
    \ {\n        if l1[i] == l2[j] {\n            common.push(l1[i]);\n          \
    \  i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n         \
    \   i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    common",
  "    let mut res = Vec::new();\n    for i in l1 {\n        for j in l2.clone() {\n\
    \            if i == j {\n                res.push(i);\n            }\n      \
    \  }\n    }\n    res.sort();\n    res.dedup();\n    res", "    let mut set1: HashSet<isize>\
    \ = HashSet::new();\n    let mut set2: HashSet<isize> = HashSet::new();\n    let\
    \ mut ret: Vec<isize> = Vec::new();\n\n    for v in l1 {\n        set1.insert(v);\n\
    \    }\n    for v in l2 {\n        set2.insert(v);\n    }\n\n    let inter = set1.intersection(&set2);\n\
    \    for v in inter {\n        ret.push(*v);\n    }\n    ret.sort();\n    ret",
  '    l1.iter().filter(|x| l2.contains(x)).map(|&x| x).collect()', '    l1.into_iter().intersect(l2.into_iter()).cloned().collect()',
  "    let v1: HashSet<isize> = l1.into_iter().collect();\n    let v2: HashSet<isize>\
    \ = l2.into_iter().collect();\n    v1.intersection(&v2).map(|i| *i).collect()",
  "    let s1: Vec<isize> = l1.iter().cloned().collect();\n    let s2: Vec<isize>\
    \ = l2.iter().cloned().collect();\n    let mut v1: Vec<isize> = s1.iter().cloned().collect();\n\
    \    let mut v2: Vec<isize> = s2.iter().cloned().collect();\n    v1.sort();\n\
    \    v2.sort();\n    return v1.iter().cloned().filter(|x| v2.contains(x)).collect();",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  // use cursor pattern to step through two vectors at the same time\n    let\
    \ mut res = Vec::new();\n    let mut l1_cursor = 0;\n    let mut l2_cursor = 0;\n\
    \    while l1_cursor < l1.len() && l2_cursor < l2.len() {\n        let el1 = l1[l1_cursor];\n\
    \        let el2 = l2[l2_cursor];\n        if el1 < el2 {\n            l1_cursor\
    \ += 1;\n        } else if el1 > el2 {\n            l2_cursor += 1;\n        }\
    \ else {\n            // el1 == el2\n            res.push(el1);\n            l1_cursor\
    \ += 1;\n            l2_cursor += 1;\n        }\n    }\n    res", "    let mut\
    \ res = vec![];\n    for i in l1 {\n        if l2.contains(&i) {\n           \
    \ res.push(i);\n        }\n    }\n    res.sort();\n    res.dedup();\n    res",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut result = Vec::new();\n    for v in l1.iter() {\n        if l2.contains(v)\
    \ {\n            result.push(*v);\n        }\n    }\n    result.sort();\n    result.dedup();\n\
    \    result", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n  \
    \  l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|x| l2.contains(x)).cloned().collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut c = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            c.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    c", "    let mut fvec = Vec::new();\n    let mut bvec = Vec::new();\n   \
    \ if l1.len() >= l2.len() {\n        fvec = l1;\n        bvec = l2;\n    } else\
    \ {\n        fvec = l2;\n        bvec = l1;\n    }\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for i in 0..bvec.len() {\n        for j in 0..fvec.len()\
    \ {\n            if bvec[i] == fvec[j] {\n                result.push(bvec[i]);\n\
    \            }\n        }\n    }\n    result.sort();\n    result.dedup();\n  \
    \  result", '    unimplemented!()', "    let mut c = l1.clone();\n    let mut\
    \ d = l2.clone();\n    c.sort();\n    d.sort();\n    c.dedup();\n    d.dedup();\n\
    \    let mut com: Vec<isize> = Vec::new();\n    for v in c {\n        if d.contains(&v)\
    \ {\n            com.push(v);\n        }\n    }\n    com", "    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len()\
    \ {\n        if l1[i] < l2[j] {\n            i += 1;\n        } else if l1[i]\
    \ > l2[j] {\n            j += 1;\n        } else {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    res", "    let\
    \ set1: HashSet<isize> = l1.into_iter().collect();\n    let set2: HashSet<isize>\
    \ = l2.into_iter().collect();\n    let vec: Vec<isize> = set1.intersection(&set2).map(|x|\
    \ *x).collect();\n    let mut v_sorted = vec.clone();\n    v_sorted.sort();\n\
    \    v_sorted", "    let mut l: Vec<isize> = l1.clone();\n    l.extend(l2.clone());\n\
    \    let mut s: Vec<isize> = l.clone();\n    s.sort();\n    s.dedup();\n    s.into_iter().filter(|n|\
    \ l1.contains(n) && l2.contains(n)).collect()", "    let mut res = Vec::new();\n\
    \    let mut li1 = l1.clone();\n    let mut li2 = l2.clone();\n    li1.sort();\n\
    \    li2.sort();\n    if li1.contains(&li2[0]) {\n        res.push(li2[0]);\n\
    \    }\n    li2.remove(0);\n    li1.retain(|x| x != &res[0]);\n    li2.retain(|x|\
    \ x != &res[0]);\n    for elem in li1 {\n        if li2.contains(&elem) {\n  \
    \          res.push(elem);\n        }\n    }\n    res.sort();\n    res.dedup();\n\
    \    res", '    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()',
  '    unimplemented!();', "    let mut l3 = Vec::new();\n    for i in l1 {\n    \
    \    for j in l2.clone() {\n            if i == j {\n                l3.push(i);\n\
    \            }\n        }\n    }\n    l3.sort();\n    l3.dedup();\n    l3", '    l1.into_iter().filter(|x|
    l2.contains(x)).collect()', "    let mut sorted1 = l1.clone();\n    let mut sorted2\
    \ = l2.clone();\n    sorted1.sort();\n    sorted2.sort();\n    sorted1.retain(|&x|\
    \ sorted2.contains(&x));\n    sorted1.dedup();\n    sorted1", "    let mut vec:\
    \ Vec<isize> = Vec::new();\n    for num in l1 {\n        for num1 in l2.clone()\
    \ {\n            if num == num1 {\n                vec.push(num)\n           \
    \ }\n        }\n    }\n    vec.sort();\n    vec.dedup();\n    vec", "    let l1\
    \ = set(l1);\n    let l2 = set(l2);\n    let mut result = Vec::new();\n    for\
    \ item in l1 {\n        if l2.contains(&item) {\n            result.push(item);\n\
    \        }\n    }\n    result.sort();\n    result", "    let mut l1 = l1;\n  \
    \  let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let length1 = l1.len();\n    let\
    \ length2 = l2.len();\n    while i < length1 && j < length2 {\n        if l1[i]\
    \ == l2[j] {\n            result.push(l1[i]);\n            i += 1;\n         \
    \   j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n        }\
    \ else {\n            j += 1;\n        }\n    }\n    result", "    let mut l1\
    \ = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut res\
    \ = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res", "    let mut result = vec![];\n    for n in l1 {\n        if l2.contains(&n)\
    \ {\n            result.push(n);\n        }\n    }\n    result.sort();\n    result.dedup();\n\
    \    result", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n  \
    \  l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut r = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    while i <\
    \ l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            if r.is_empty()\
    \ || l1[i] != r[r.len() - 1] {\n                r.push(l1[i]);\n            }\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    r", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut output = Vec::new();\n  \
    \  while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n       \
    \     output.push(l1[i]);\n            i += 1;\n            j += 1;\n        }\
    \ else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n           \
    \ j += 1;\n        }\n    }\n    output", "    // TODO: Implement the function.\n\
    \    let mut sorted_l1 = l1.clone();\n    sorted_l1.sort();\n    let mut sorted_l2\
    \ = l2.clone();\n    sorted_l2.sort();\n    let mut results: Vec<isize> = Vec::new();\n\
    \    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < sorted_l1.len() && i2\
    \ < sorted_l2.len() {\n        if sorted_l1[i1] == sorted_l2[i2] {\n         \
    \   results.push(sorted_l1[i1]);\n            i1 += 1;\n            i2 += 1;\n\
    \        } else if sorted_l1[i1] < sorted_l2[i2] {\n            i1 += 1;\n   \
    \     } else {\n            i2 += 1;\n        }\n    }\n    results", '    l1.intersect(&l2).cloned().collect()',
  '    unimplemented!();', "    let (mut l1, mut l2) = (l1, l2);\n    l1.sort();\n\
    \    l2.sort();\n    let mut res = Vec::new();\n    let (mut l1i, mut l2i) = (0,\
    \ 0);\n    while l1i < l1.len() && l2i < l2.len() {\n        if l1[l1i] < l2[l2i]\
    \ {\n            l1i += 1;\n        } else if l1[l1i] > l2[l2i] {\n          \
    \  l2i += 1;\n        } else {\n            res.push(l1[l1i]);\n            l1i\
    \ += 1;\n            l2i += 1;\n        }\n    }\n    res", "    let mut l3 =\
    \ l1.clone();\n    l3.sort();\n    let mut l4 = l2.clone();\n    l4.sort();\n\
    \    l3.into_iter().filter(|x| l4.contains(x)).collect()", "    // Implement your\
    \ solution here\n    l1.iter().cloned().collect::<HashSet<isize>>().intersection(&l2.iter().cloned().collect::<HashSet<isize>>()).cloned().collect::<Vec<isize>>()",
  "    let mut result = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n        } else {\n\
    \            result.push(l1[i]);\n            i += 1;\n            j += 1;\n \
    \       }\n    }\n    result", "  let mut new: Vec<isize> = vec![];\n  let mut\
    \ index = 1;\n  let mut v1 = l1.clone();\n  let mut v2 = l2.clone();\n  v1.sort();\n\
    \  v2.sort();\n  v1.dedup();\n  v2.dedup();\n  for _elem in v1 {\n    if v2.contains(&_elem)\
    \ {\n      new.push(_elem);\n    }\n  }\n  new.sort();\n  new.dedup();\n  new",
  "    let mut ll1 = l1.clone();\n    let mut ll2 = l2.clone();\n    ll1.sort();\n\
    \    ll2.sort();\n    let mut res = Vec::new();\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let ll1_len = ll1.len();\n    let ll2_len = ll2.len();\n    while\
    \ i < ll1_len && j < ll2_len {\n        if ll1[i] == ll2[j] {\n            res.push(ll1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if ll1[i] < ll2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res", "    let mut v: Vec<isize> = l1.into_iter().filter(|x| l2.contains(x)).collect();\n\
    \    v.sort();\n    v.dedup();\n    v", '    unimplemented!()', "    let mut common_list:\
    \ Vec<isize> = vec![];\n    for l in l1 {\n        if l2.contains(&l) {\n    \
    \        common_list.push(l);\n        }\n    }\n    common_list.sort();\n   \
    \ common_list.dedup();\n    common_list", '    l1.into_iter().filter(|x| l2.contains(x)).collect()',
  "    let mut res = Vec::new();\n    let mut tmp = Vec::new();\n    for e in l1 {\n\
    \        if l2.contains(&e) {\n            tmp.push(e);\n        }\n    }\n  \
    \  for e in l2 {\n        if l1.contains(&e) {\n            tmp.push(e);\n   \
    \     }\n    }\n    for t in tmp {\n        if !res.contains(&t) {\n         \
    \   res.push(t);\n        }\n    }\n    res.sort();\n    res", "    let mut v:\
    \ Vec<isize> = vec![];\n    for x in l1 {\n        for y in l2.clone() {\n   \
    \         if x == y {\n                v.push(x);\n            }\n        }\n\
    \    }\n    v.sort();\n    v.dedup();\n    v", "    let mut l1 = l1;\n    let\
    \ mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let l1 = l1.into_iter().unique().collect::<Vec<isize>>();\n\
    \    let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n    let mut result\
    \ = Vec::new();\n    for i in 0..l1.len() {\n        for j in 0..l2.len() {\n\
    \            if l1[i] == l2[j] {\n                result.push(l1[i]);\n      \
    \      }\n        }\n    }\n    result", "    let mut ret: Vec<isize> = Vec::new();\n\
    \    let mut set: HashSet<isize> = HashSet::new();\n    for v in l1 {\n      \
    \  set.insert(v);\n    }\n    for v in l2 {\n        if set.contains(&v) {\n \
    \           ret.push(v);\n        }\n    }\n    ret.sort();\n    ret.dedup();\n\
    \    ret", "    let mut v = l1.iter().chain(l2.iter()).cloned().collect::<Vec<isize>>();\n\
    \    v.sort();\n    v.dedup();\n    v", "    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut res: Vec<isize>\
    \ = Vec::new();\n\n    for i in l1 {\n        set1.insert(i);\n    }\n    for\
    \ i in l2 {\n        set2.insert(i);\n    }\n\n    let set3: HashSet<_> = set1.intersection(&set2).collect();\n\
    \    for i in set3 {\n        res.push(*i);\n    }\n    res.sort();\n    res",
  "    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> = l2;\n    l1.sort();\n\
    \    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let mut v = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len()\
    \ {\n        if l1[i] < l2[j] {\n            i += 1;\n        } else if l1[i]\
    \ > l2[j] {\n            j += 1;\n        } else {\n            v.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    v", "    let\
    \ l1_set: HashSet<isize> = l1.iter().cloned().collect();\n    let l2_set: HashSet<isize>\
    \ = l2.iter().cloned().collect();\n    let mut res: Vec<isize> = l1_set.intersection(&l2_set).cloned().collect();\n\
    \    res.sort();\n    res", "    let mut res = Vec::new();\n    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n            j\
    \ += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    res", '    unimplemented!()',
  '    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()', " \
    \   let mut res = Vec::new();\n    let mut cnt = 0;\n    for i in l1 {\n     \
    \   for j in l2.iter() {\n            if i == *j {\n                res.push(i);\n\
    \                break;\n            }\n        }\n    }\n    res.sort();\n  \
    \  res.dedup();\n    res", '    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()',
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.dedup();\n    l2.dedup();\n    let mut result = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] < l2[j] {\n            i += 1;\n        } else if l1[i] > l2[j] {\n\
    \            j += 1;\n        } else {\n            result.push(l1[i]);\n    \
    \        i += 1;\n            j += 1;\n        }\n    }\n    result", "    let\
    \ mut common = Vec::new();\n    let mut copy = l2.clone();\n    for i in l1 {\n\
    \        if copy.contains(&i) {\n            common.push(i);\n            copy.remove_item(&i);\n\
    \        }\n    }\n    return common;"]
stop_tokens:
- "\n}"
