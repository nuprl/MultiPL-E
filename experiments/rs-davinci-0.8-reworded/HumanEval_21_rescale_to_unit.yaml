name: HumanEval_21_rescale_to_unit
language: rs
prompt: "/// Given vector of numbers (of at least two elements), apply a linear transform\
  \ to that vector,\n/// such that the smallest number will become 0 and the largest\
  \ will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n/// vec![0.0,\
  \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n"
tests: "}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
  \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
  \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
  \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
  \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
  \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
completions: ["    let min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n    let\
    \ n = numbers.len();\n    if min == max {\n        return vec![0.0; n];\n    }\n\
    \    numbers.iter().map(|number| (*number - min) / (max - min)).collect()", " \
    \   let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| n / max).collect()", "    let min = numbers.iter().cloned().fold(numbers[0],\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(numbers[0], f64::max);\n\
    \    let scaled_numbers = numbers.iter().map(|x| (x - min) / (max - min)).collect();\n\
    \    scaled_numbers", "    assert!(numbers.len() >= 2);\n    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n    for &number in numbers.iter()\
    \ {\n        if number < smallest {\n            smallest = number;\n        }\n\
    \        if number > largest {\n            largest = number;\n        }\n   \
    \ }\n    let scale = 1.0 / (largest - smallest);\n    numbers.iter().map(|number|\
    \ (number - smallest) * scale).collect()", "    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()", "    let mut\
    \ numbers = numbers;\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let normalized_numbers = numbers.iter().map(|n| (n - min) / (max - min)).collect();\n\
    \    normalized_numbers", "    // Find the maximum and minimum\n    let (min,\
    \ max) = numbers.iter().fold((f64::MAX, f64::MIN), |(min, max), &n| {\n      \
    \  if n < min {\n            (n, max)\n        } else if n > max {\n         \
    \   (min, n)\n        } else {\n            (min, max)\n        }\n    });\n\n\
    \    // If the max and min are the same, then all the numbers are the same.\n\
    \    // Just return the same array.\n    if min == max {\n        return numbers;\n\
    \    }\n\n    // return the rescaled numbers\n    let factor = 1.0 / (max - min);\n\
    \    numbers.iter().map(|n| (n - min) * factor).collect()", "    let (min, max)\
    \ = numbers.iter().fold((numbers[0], numbers[0]), |(min, max), x| {\n        (min.min(*x),\
    \ max.max(*x))\n    });\n    let max_dif = max - min;\n    numbers.iter().map(|x|\
    \ (*x - min) / max_dif).collect()", "    let max = *numbers.iter().max().unwrap();\n\
    \    let min = *numbers.iter().min().unwrap();\n    numbers.iter().map(|n| (*n\
    \ - min) / (max - min)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    if *min == *max {\n       \
    \ return numbers;\n    }\n    let scale = 1.0 / (max - min);\n    let shift =\
    \ -min;\n    numbers.iter().map(|x| (x + shift) * scale).collect()", "    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let mut ret_val\
    \ = Vec::new();\n    for i in numbers {\n        ret_val.push((i - min) / (max\
    \ - min));\n    }\n    ret_val", "    // Ensure that we have at least two elements,\
    \ or else we can't do anything\n    if numbers.len() < 2 {\n        panic!(\"\
    rescale_to_unit requires a vector of at least two elements!\");\n    }\n\n   \
    \ // Find smallest and largest elements\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    // Compute range\n    let\
    \ range = max - min;\n\n    // Do the rescaling\n    let mut result = vec![];\n\
    \    for &number in numbers.iter() {\n        let rescaled = (number - min) /\
    \ range;\n        result.push(rescaled);\n    }\n\n    result", "    let min =\
    \ numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| {\n        (x - min) /\
    \ range\n    }).collect()", "    let min = numbers.iter().min().unwrap();\n  \
    \  let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (*x -\
    \ min) / (max - min)).collect()", "    if numbers.len() == 0 {\n        return\
    \ vec![];\n    }\n\n    let smallest = numbers.iter().fold(numbers[0], |memo,\
    \ &x| cmp::min(memo, x));\n    let range = numbers.iter().fold(numbers[0], |memo,\
    \ &x| cmp::max(memo, x)) - smallest;\n\n    if range == 0.0 {\n        return\
    \ vec![];\n    }\n\n    numbers.iter().map(|x| (x - smallest) / range).collect()",
  "    assert!(numbers.len() >= 2);\n    let n = numbers.len();\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  (0..n).map(|i| (numbers[i] - min) / range).collect()", "    let mut result\
    \ = numbers.clone();\n    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    for x in result.iter_mut() {\n       \
    \ *x = (*x - min) / (max - min);\n    }\n    result", "    let mut numbers = numbers;\n\
    \    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let min = numbers[0];\n\
    \    let max = numbers[numbers.len() - 1];\n    let range = max - min;\n    numbers.iter().map(|x|\
    \ (x - min) / range).collect()", "    let min_number = numbers.iter().min().unwrap();\n\
    \    let max_number = numbers.iter().max().unwrap();\n    let mut result = vec![];\n\
    \    for number in numbers {\n        result.push((number - min_number) / (max_number\
    \ - min_number));\n    }\n    result", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let delta = max - min;\n    numbers.iter().map(|n| (n - min) / delta).collect()"]
stop_tokens:
- "\n}"
