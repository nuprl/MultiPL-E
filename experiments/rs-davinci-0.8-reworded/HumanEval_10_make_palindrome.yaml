name: HumanEval_10_make_palindrome
language: rs
prompt: "/// Find the shortest palindrome that begins with a supplied string.\n///\
  \ Algorithm idea is simple:\n/// - Find the longest postfix of supplied string that\
  \ is a palindrome.\n/// - Append to the end of the string reverse of a string prefix\
  \ that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
  \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n///\
  \ String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n///\
  \ String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
  \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
  x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
  ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
  \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
  }\n"
completions: ["    let mut palindrome = string.clone();\n    palindrome.push_str(&string.chars().rev().collect::<String>());\n\
    \    palindrome", "    if string.is_empty() {\n        return string;\n    }\n\
    \    let mut suffix_len = string.len();\n    while suffix_len > 0 {\n        let\
    \ prefix_len = string.len() - suffix_len;\n        let prefix = &string[..prefix_len];\n\
    \        let suffix = &string[prefix_len..];\n        if prefix == suffix.chars().rev().collect::<String>()\
    \ {\n            break;\n        }\n        suffix_len -= 1;\n    }\n    let mut\
    \ result = string.clone();\n    for c in string.chars().take(string.len() - suffix_len).rev()\
    \ {\n        result.push(c);\n    }\n    result", "    let chars: Vec<char> =\
    \ string.chars().collect();\n    let mut palindrome_suffix = find_longest_palindrome(&chars);\n\
    \    let mut reverse = chars.clone();\n    reverse.reverse();\n    let mut new_string\
    \ = palindrome_suffix.to_string();\n    let mut to_append = reverse[palindrome_suffix.len()..].to_vec();\n\
    \    to_append.reverse();\n    new_string.push_str(&to_append.iter().collect::<String>());\n\
    \    new_string", "    let mut long: String = long_palindrome_postfix(string.clone());\n\
    \    let mut short: String = short_palindrome_prefix(string.clone());\n    let\
    \ _ = long.append(&mut short);\n    long", "    if string.is_empty() {\n     \
    \   return string;\n    }\n    let mut longest_postfix = String::from(\"\");\n\
    \    let mut longest_prefix = String::from(\"\");\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_prefix_length = 0;\n    let mut longest_palindrome_start\
    \ = 0;\n    let mut longest_palindrome_end = 0;\n    for center in 0..string.len()\
    \ {\n        let (mut postfix_length, mut prefix_length) = (0, 0);\n        if\
    \ center + 1 < string.len() && string.chars().nth(center).unwrap() == string.chars().nth(center\
    \ + 1).unwrap() {\n            postfix_length = 1;\n            prefix_length\
    \ = 1;\n            let mut palindrome_start = center;\n            let mut palindrome_end\
    \ = center + 1;\n            while palindrome_start - 1 >= 0 && palindrome_end\
    \ + 1 < string.len() {\n                if string.chars().nth(palindrome_start\
    \ - 1).unwrap() == string.chars().nth(palindrome_end + 1).unwrap() {\n       \
    \             postfix_length += 1;\n                    prefix_length += 1;\n\
    \                    palindrome_start -= 1;\n                    palindrome_end\
    \ += 1;\n                } else {\n                    break;\n              \
    \  }\n            }\n            if postfix_length > longest_postfix_length {\n\
    \                longest_postfix_length = postfix_length;\n                longest_prefix_length\
    \ = prefix_length;\n                longest_palindrome_start = palindrome_start;\n\
    \                longest_palindrome_end = palindrome_end;\n            }\n   \
    \     }\n        postfix_length = 0;\n        prefix_length = 0;\n        let\
    \ mut palindrome_start = center;\n        let mut palindrome_end = center;\n \
    \       while palindrome_start - 1 >= 0 && palindrome_end + 1 < string.len() {\n\
    \            if string.chars().nth(palindrome_start - 1).unwrap() == string.chars().n",
  "    let chars: Vec<char> = string.chars().collect();\n    let length = chars.len();\n\
    \    if length == 0 {\n        return string;\n    }\n    let mut start = 0;\n\
    \    let mut end = length - 1;\n    while start < end {\n        if chars[start]\
    \ != chars[end] {\n            break;\n        }\n        start += 1;\n      \
    \  end -= 1;\n    }\n    let mut new_string = String::from(&string[start..]);\n\
    \    new_string.push_str(&string[..start].chars().rev().collect::<String>());\n\
    \    new_string", "    let mut result = string.clone();\n    let l = longest_palindrome_suffix(string);\n\
    \    result.push_str(&string[..string.len() - l].chars().rev().collect::<String>());\n\
    \    result", "    if string.is_empty() {\n        return string;\n    }\n   \
    \ let mut reversed = string.chars().rev().collect::<String>();\n    reversed.push_str(&string);\n\
    \    let mut z_array = z_algorithm(&reversed);\n    if z_array[string.len()] ==\
    \ 0 {\n        string.push('a');\n        return string;\n    }\n    let prefix_begin\
    \ = string.len() - z_array[string.len()];\n    let mut prefix = String::from(&string[..prefix_begin]);\n\
    \    prefix.push_str(&string);\n    prefix", "    if is_palindrome(&string) {\n\
    \        return string;\n    }\n    // possible palindromic suffixes of string.\n\
    \    let suffixes = (0..string.len()).map(|i| string.chars().skip(i).collect::<String>());\n\
    \    // find the longest palindromic suffix.\n    let longest_suffix = suffixes.rev().find(|s|\
    \ is_palindrome(s));\n    // build the prefix to append to the end.\n    let prefix\
    \ = match longest_suffix {\n        Some(s) => string.chars().take(string.len()\
    \ - s.len()).collect::<String>(),\n        None => string.chars().take(string.len()\
    \ - 1).collect::<String>(),\n    };\n    let mut palindrome = string;\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome", "    let mut chars = string.chars().collect::<Vec<char>>();\n\
    \    let mut suffix_length = 0;\n    // We iterate over the string and match the\
    \ following cases:\n    // 1. Char at [i] is identical to char at [len - 1 - i].\n\
    \    // 2. Char at [i] is identical to char at [len - 2 - i].\n    //\n    //\
    \ In the first case we know that substring [i, len - 1] is a palindrome,\n   \
    \ // In the second case we know that substring [i + 1, len - 1] is a palindrome.\n\
    \    for i in 0..chars.len() {\n        let len = chars.len();\n        if chars[i]\
    \ == chars[len - 1 - i] {\n            suffix_length = len - i;\n        } else\
    \ if chars[i] == chars[len - 2 - i] {\n            suffix_length = len - 1 - i;\n\
    \        }\n    }\n    if suffix_length == chars.len() {\n        // A trivial\
    \ case, the string is already a palindrome.\n        return string;\n    }\n \
    \   // We can use slicing to add the prefix.\n    let prefix = chars[0..chars.len()\
    \ - suffix_length].iter().rev();\n    // Prefix is added to the end of the string,\
    \ then we add the suffix (which is a palindrome).\n    let mut res = String::new();\n\
    \    res.extend(chars);\n    res.extend(prefix);\n    res", "    let mut res =\
    \ string.clone();\n    let mut rev = string.chars().rev().collect::<String>();\n\
    \    let common_len = string.len() - longest_common_suffix(string, rev);\n   \
    \ res.push_str(&rev[..common_len]);\n    res", "    let mut prefix = String::from(&string[..string.len()\
    \ - find_palindrome_suffix(&string)]);\n    let mut reversed_prefix = prefix.clone();\n\
    \    reversed_prefix.chars().rev().collect()", "    let mut string = string;\n\
    \    if string.is_empty() {\n        return string;\n    }\n    let mut longest_palindrome_postfix\
    \ = string.chars().nth(0).unwrap().to_string();\n    let string_len = string.len();\n\
    \    let mut i = 1;\n    while i < string_len {\n        let curr_char = string.chars().nth(i).unwrap();\n\
    \        let mut postfix = curr_char.to_string();\n        postfix.push_str(&longest_palindrome_postfix);\n\
    \        let mut prefix = curr_char.to_string();\n        prefix.push_str(&string[0..i]);\n\
    \        if prefix == postfix {\n            longest_palindrome_postfix = postfix;\n\
    \        }\n        i += 1;\n    }\n    let reverse_prefix = string[0..string_len\
    \ - longest_palindrome_postfix.len()].chars().rev().collect::<String>();\n   \
    \ string.push_str(&reverse_prefix);\n    string", "    if string.is_empty() {\n\
    \        return string;\n    }\n    let mut string = string;\n    let mut len_longest_palindrome\
    \ = longest_palindrome_suffix(&string);\n    let (string_prefix, string_palindrome)\
    \ = string.split_at(string.len() - len_longest_palindrome);\n    let string_reverse\
    \ = string_prefix.chars().rev().collect::<String>();\n    string_reverse + string_palindrome",
  "    let mut reversed = string.clone();\n    reversed.chars().rev().collect::<String>();\n\
    \    // TODO: implement this function\n    unimplemented!()", "    if string.is_empty()\
    \ {\n        return string;\n    }\n    let length = string.len();\n    let mut\
    \ expand = 1;\n    for i in (0..length).rev() {\n        if string[i..].chars().eq(string[..length\
    \ - i].chars().rev()) {\n            expand = length - i;\n            break;\n\
    \        }\n    }\n    let mut result = string.clone();\n    let prefix = string[..expand].chars().rev().collect::<String>();\n\
    \    result.push_str(&prefix);\n    result", "    let mut reversed = string.clone();\n\
    \    reversed.chars().rev().collect::<String>();\n    let mut palindrome = string.clone();\n\
    \    for i in 1..string.len() {\n        if is_palindrome(&string[i..]) {\n  \
    \          palindrome.push_str(&reversed[..string.len() - i]);\n            break;\n\
    \        }\n    }\n    palindrome", "    let mut output = string.chars().collect::<Vec<char>>();\n\
    \    let reverse = output.clone();\n    let len = output.len();\n    let mut pal_len\
    \ = 0;\n    let mut i = 0;\n    while i < len {\n        if pal_len + i >= len\
    \ {\n            break;\n        }\n        let mut pal = true;\n        for j\
    \ in 0..len - i - pal_len {\n            if output[i + j] != reverse[len - j -\
    \ 1] {\n                pal = false;\n                break;\n            }\n\
    \        }\n        if pal {\n            pal_len = len - i;\n        }\n    \
    \    i += 1;\n    }\n    while let Some(c) = output.pop() {\n        output.push(c);\n\
    \    }\n    output.truncate(pal_len);\n    let mut prefix = output.clone();\n\
    \    output.extend(string.chars());\n    while let Some(c) = prefix.pop() {\n\
    \        output.push(c);\n    }\n    output.iter().collect()", "    // If a string\
    \ is empty or a palindrome, then we have done.\n    if string.is_empty() || is_palindrome(&string)\
    \ {\n        return string;\n    }\n\n    // Find longest palindromic suffix.\n\
    \    let suffix = longest_palindromic_suffix(&string);\n\n    // Append the prefix\
    \ reverse to the end of the string.\n    let prefix = string.chars().rev().collect::<String>();\n\
    \    string + &prefix[suffix.len()..]", "    let str_length = string.len();\n\
    \    if str_length == 0 {\n        return string;\n    }\n    if str_length ==\
    \ 1 {\n        return string + &string;\n    }\n    let str_bytes = string.as_bytes();\n\
    \    for palindrome_length in (1..str_length).rev() {\n        let palindrome_bytes\
    \ = &str_bytes[str_length - palindrome_length..];\n        let reversed_prefix\
    \ = &str_bytes[..str_length - palindrome_length];\n        if is_palindrome(palindrome_bytes)\
    \ {\n            return string.clone() + &reverse_string(reversed_prefix);\n \
    \       }\n    }\n    string.clone() + &reverse_string(&str_bytes[..1])"]
stop_tokens:
- "\n}"
