language: rs
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = String::new();\n\
    \    let mut max_strength = 0;\n    for ext in extensions {\n        let strength\
    \ = calc_strength(&ext);\n        if strength > max_strength {\n            max_strength\
    \ = strength;\n            strongest = ext;\n        }\n    }\n    return format!(\"\
    {}.{}\", class_name, strongest);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `calc_strength` in this scope\n  -->\
    \ /tmp/tmpqe0km5co.rs:21:24\n   |\n21 |         let strength = calc_strength(&ext);\n\
    \   |                        ^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `max_strength`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = &extensions[0];\n    let mut strongest_extension_strength = calculate_strength(&extensions[0]);\n\
    \    for x in extensions.iter() {\n        let strength = calculate_strength(x);\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension\
    \ = x;\n            strongest_extension_strength = strength;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `calculate_strength` in this scope\n\
    \  --> /tmp/tmp3jt42e8i.rs:19:44\n   |\n19 |     let mut strongest_extension_strength\
    \ = calculate_strength(&extensions[0]);\n   |                                \
    \            ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `calculate_strength` in this scope\n  --> /tmp/tmp3jt42e8i.rs:21:24\n\
    \   |\n21 |         let strength = calculate_strength(x);\n   |              \
    \          ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = \"\";\n\
    \    let mut strength = -100.0;\n    for ext in extensions {\n        let cap\
    \ = ext.chars().filter(|x| x.is_uppercase()).count();\n        let sm = ext.chars().filter(|x|\
    \ x.is_lowercase()).count();\n        let s = cap as f64 - sm as f64;\n      \
    \  if s > strength {\n            strength = s;\n            strongest = ext.as_str();\n\
    \        }\n    }\n    return format!(\"{}.{}\", class_name, strongest);\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `ext` does not live long enough\n  --> /tmp/tmp0s0pm4_e.rs:26:25\n\
    \   |\n26 |             strongest = ext.as_str();\n   |                      \
    \   ^^^^^^^^^^^^ borrowed value does not live long enough\n27 |         }\n28\
    \ |     }\n   |     - `ext` dropped here while still borrowed\n29 |     return\
    \ format!(\"{}.{}\", class_name, strongest);\n   |                           \
    \              --------- borrow later used here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0597`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_idx = 0;\n\
    \    let mut strongest_score = 0.0;\n    for (idx, ext) in extensions.iter().enumerate()\
    \ {\n        let mut score = 0.0;\n        for c in ext.chars() {\n          \
    \  if c.is_lowercase() {\n                score -= 1.0;\n            } else {\n\
    \                score += 1.0;\n            }\n        }\n        if score > strongest_score\
    \ {\n            strongest_score = score;\n            strongest_idx = idx;\n\
    \        }\n    }\n    return format!(\"{}.{}\", class_name, extensions[strongest_idx]);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.123NoooneB321\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpupbwr7_t.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // First, calculate the strength\
    \ for each extension.\n    let mut extension_strengths: Vec<(String, i32)> = Vec::new();\n\
    \    for extension in extensions {\n        let mut upper_count = 0;\n       \
    \ let mut lower_count = 0;\n        for character in extension.chars() {\n   \
    \         if character.is_lowercase() {\n                lower_count += 1;\n \
    \           } else {\n                upper_count += 1;\n            }\n     \
    \   }\n        let strength = upper_count - lower_count;\n        extension_strengths.push((extension,\
    \ strength));\n    }\n    // Then, sort the strengths.\n    extension_strengths.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    // Finally, choose the top extension.\n    let top_extension\
    \ = extension_strengths[0].0;\n    let mut result = class_name.clone();\n    result.push('.');\n\
    \    result.push_str(&top_extension);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<(String, i32)>`\n  --> /tmp/tmpnbz05kn1.rs:36:25\n\
    \   |\n36 |     let top_extension = extension_strengths[0].0;\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^\n   |                         |\n   |\
    \                         move occurs because value has type `String`, which does\
    \ not implement the `Copy` trait\n   |                         help: consider\
    \ borrowing here: `&extension_strengths[0].0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\".to_string();\n    let mut strongest_extension_strength = 0;\n    for\
    \ extension in extensions {\n        let mut extension_strength = 0;\n       \
    \ for c in extension.chars() {\n            if c.is_uppercase() {\n          \
    \      extension_strength += 1;\n            } else {\n                extension_strength\
    \ -= 1;\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength;\n        \
    \    strongest_extension = extension;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpwujypwkq.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\";\n    let mut strongest_strength = 0f64;\n    for ext in extensions {\n\
    \        let strength = (ext.matches(char::is_uppercase).count() as f64) - (ext.matches(char::is_lowercase).count()\
    \ as f64);\n        if strength > strongest_strength {\n            strongest_strength\
    \ = strength;\n            strongest_extension = &ext;\n        }\n    }\n   \
    \ return format!(\"{}.{}\", class_name, strongest_extension);\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `ext` does not live long enough\n  --> /tmp/tmp__q22x45.rs:24:35\n\
    \   |\n24 |             strongest_extension = &ext;\n   |                    \
    \               ^^^^ borrowed value does not live long enough\n25 |         }\n\
    26 |     }\n   |     - `ext` dropped here while still borrowed\n27 |     return\
    \ format!(\"{}.{}\", class_name, strongest_extension);\n   |                 \
    \                        ------------------- borrow later used here\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0597`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\";\n    let mut strongest_strength = 0.0;\n    for extension in extensions\
    \ {\n        let extension_strength = Calc_Extension_Strength(extension);\n  \
    \      if extension_strength > strongest_strength {\n            strongest_strength\
    \ = extension_strength;\n            strongest_extension = extension.as_str();\n\
    \        }\n    }\n    let ret_str = format!(\"{}.{}\", class_name, strongest_extension);\n\
    \    ret_str\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Calc_Extension_Strength`\
    \ in this scope\n  --> /tmp/tmp3l66ecl0.rs:21:34\n   |\n21 |         let extension_strength\
    \ = Calc_Extension_Strength(extension);\n   |                                \
    \  ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_name: String =\
    \ String::from(\"\");\n    let mut max_strength: f64 = 0.0;\n    for ext in extensions\
    \ {\n        let strength = extension_strength(&ext);\n        if strength > max_strength\
    \ {\n            max_strength = strength;\n            max_name = ext;\n     \
    \   }\n    }\n    class_name + \".\" + &max_name\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `extension_strength` in this scope\n\
    \  --> /tmp/tmplursygi2.rs:21:24\n   |\n21 |         let strength = extension_strength(&ext);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\".to_string();\n    let mut strongest_strength = 0f64;\n    for extension\
    \ in extensions {\n        let strength = extension.chars().filter(|&c| c.is_uppercase()).count()\
    \ as f64 - extension.chars().filter(|&c| c.is_lowercase()).count() as f64;\n \
    \       if strength > strongest_strength {\n            strongest_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return format!(\"\
    {}.{}\", class_name, strongest_extension);\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmp6q_3d5zu.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n\tlet mut strongest_extension\
    \ = String::new();\n\tlet mut strength = 0.0;\n\tfor extension in extensions {\n\
    \t\tlet upper_count = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \t\tlet lower_count = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \t\tlet tmp_strength = (upper_count as f64 - lower_count as f64) / extension.len()\
    \ as f64;\n\t\tif tmp_strength > strength {\n\t\t\tstrength = tmp_strength;\n\t\
    \t\tstrongest_extension = extension;\n\t\t}\n\t}\n\tformat!(\"{}.{}\", class_name,\
    \ strongest_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpom62bo23.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code goes here\n \
    \   return String::from(\"\");\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpfass0_29.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // get the lowercase count\
    \ for each letter\n    let mut sum_lowercase_letter = HashMap::new();\n    //\
    \ get the uppercase count for each letter\n    let mut sum_uppercase_letter =\
    \ HashMap::new();\n    // get the strength for each extension\n    let mut strength_extension\
    \ = HashMap::new();\n    // get the result for each extension\n    let mut result_extension\
    \ = HashMap::new();\n    // get the initial result\n    let mut initial_result\
    \ = String::from(\"\");\n    // get the weakest strength\n    let mut weakest_strength\
    \ = 0.0;\n    // get the strongest strength\n    let mut strongest_strength =\
    \ 0.0;\n    // get the strongest index\n    let mut strongest_index = 0;\n   \
    \ // get the strongest result\n    let mut strongest_result = String::from(\"\"\
    );\n    // get the count length of the class name\n    let class_count = class_name.len();\n\
    \    // calculate the lowercase and uppercase count for each letter in the class\
    \ name\n    for i in 0..class_count {\n        let temp_class_letter = class_name.chars().nth(i).unwrap();\n\
    \        let mut temp_class_count = 0;\n        if sum_lowercase_letter.contains_key(&temp_class_letter)\
    \ {\n            temp_class_count = *sum_lowercase_letter.get(&temp_class_letter).unwrap();\n\
    \        }\n        sum_lowercase_letter.insert(temp_class_letter, temp_class_count\
    \ + 1);\n    }\n    // calculate the lowercase and uppercase count for each letter\
    \ in the extension\n    for i in 0..extensions.len() {\n        let temp_extension\
    \ = extensions[i].clone();\n        let temp_extension_count = temp_extension.len();\n\
    \        for j in 0..temp_extension_count {\n            let temp_extension_letter\
    \ = temp_extension.chars().nth(j).unwrap();\n            let mut temp_lowercase_count\
    \ = 0;\n            let mut temp_uppercase_count = 0;\n            if sum_lowercase_letter.contains_key(&temp\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpi48k9wux.rs:69:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n48 |     for i in 0..extensions.len()\
    \ {\n   |                                  - unclosed delimiter\n...\n51 |   \
    \      for j in 0..temp_extension_count {\n   |                              \
    \            - this delimiter might not be properly closed...\n...\n56 | }\n \
    \  | - ...as it matches this but it has different indentation\n...\n69 | }\n \
    \  |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpi48k9wux.rs:56:1\n \
    \  |\n55 |             if sum_lowercase_letter.contains_key(&temp\n   |      \
    \       -- this `if` expression has a condition, but no block\n56 | }\n   | ^\
    \ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpi48k9wux.rs:55:49\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - closing delimiter possibly meant for this\n...\n55 | \
    \            if sum_lowercase_letter.contains_key(&temp\n   |                \
    \                                 ^ unclosed delimiter\n56 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashMap`\n  --> /tmp/tmpi48k9wux.rs:19:36\n   |\n19 |     let mut sum_lowercase_letter\
    \ = HashMap::new();\n   |                                    ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpi48k9wux.rs:21:36\n   |\n21 |     let mut sum_uppercase_letter =\
    \ HashMap::new();\n   |                                    ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpi48k9wux.rs:2"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + \n  \
    \  extensions.iter()\n        .max_by(|&a, &b| {\n            let a_upper = a.chars().filter(|&c|\
    \ c.is_uppercase()).count();\n            let a_lower = a.chars().filter(|&c|\
    \ c.is_lowercase()).count();\n            let b_upper = b.chars().filter(|&c|\
    \ c.is_uppercase()).count();\n            let b_lower = b.chars().filter(|&c|\
    \ c.is_lowercase()).count();\n            let a_strength = a_upper - a_lower;\n\
    \            let b_strength = b_upper - b_lower;\n            a_strength.cmp(&b_strength)\n\
    \        })\n        .unwrap()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpun_6fd_h.rs:25:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strong_extension:\
    \ String = \"\".to_string();\n    let mut strong_strength: i32 = 0;\n    for ext\
    \ in extensions {\n        let mut cap_counter: i32 = 0;\n        let mut sm_counter:\
    \ i32 = 0;\n        for ch in ext.chars() {\n            if ch.is_uppercase()\
    \ {\n                cap_counter += 1;\n            } else if ch.is_lowercase()\
    \ {\n                sm_counter += 1;\n            }\n        }\n        let strength:\
    \ i32 = cap_counter - sm_counter;\n        if strength > strong_strength {\n \
    \           strong_strength = strength;\n            strong_extension = ext;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, strong_extension)\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmp65xas0k3.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = \"\".to_string();\n\
    \    let mut strength = std::f64::NEG_INFINITY;\n    for ext in extensions {\n\
    \        let mut cap = 0;\n        let mut sm = 0;\n        for c in ext.chars()\
    \ {\n            if c.is_uppercase() {\n                cap += 1;\n          \
    \  } else {\n                sm += 1;\n            }\n        }\n        let ratio\
    \ = cap as f64 - sm as f64;\n        if ratio > strength {\n            strength\
    \ = ratio;\n            strongest = ext;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, strongest)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpathltjlq.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    //Your code here!\n    let\
    \ mut strongest_extension = \"\";\n    let mut strongest_strength = 0;\n    for\
    \ extension in extensions {\n        let mut upper_case_count = 0;\n        let\
    \ mut lower_case_count = 0;\n        for character in extension.chars() {\n  \
    \          if character.is_uppercase() {\n                upper_case_count +=\
    \ 1;\n            } else if character.is_lowercase() {\n                lower_case_count\
    \ += 1;\n            }\n        }\n        let strength = upper_case_count - lower_case_count;\n\
    \        if strength > strongest_strength {\n            strongest_strength =\
    \ strength;\n            strongest_extension = &extension;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `extension` does not live long enough\n  --> /tmp/tmphq2alj7l.rs:34:35\n\
    \   |\n34 |             strongest_extension = &extension;\n   |              \
    \                     ^^^^^^^^^^ borrowed value does not live long enough\n35\
    \ |         }\n36 |     }\n   |     - `extension` dropped here while still borrowed\n\
    37 |     format!(\"{}.{}\", class_name, strongest_extension)\n   |           \
    \                       ------------------- borrow later used here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0597`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Determine strength of extension\n\
    \    fn strength(extension: &String) -> f64 {\n        let upper = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let lower = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        (upper as f64) - (lower as f64)\n    }\n\
    \n    // Get the strongest extension and its strength\n    let (index, strongest)\
    \ = extensions.iter().enumerate().fold((0, 0.), |a, b| {\n        let (i, str1)\
    \ = a;\n        let (ni, str2) = b;\n        if strength(&extensions[i]) > strength(&extensions[ni])\
    \ {\n            (i, str1)\n        } else {\n            (ni, str2)\n       \
    \ }\n    });\n\n    // Return string\n    format!(\"{}.{}\", class_name, extensions[index])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiz3o67kc.rs:32:18\n   |\n\
    32 |             (ni, str2)\n   |                  ^^^^ expected floating-point\
    \ number, found `&String`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = 0.0;\n\
    \    let mut result = class_name.clone();\n    for extension in extensions {\n\
    \        let upper = extension.chars().filter(|x| x.is_uppercase()).count();\n\
    \        let lower = extension.chars().filter(|x| x.is_lowercase()).count();\n\
    \        let strn = (upper as f64 - lower as f64) / extension.len() as f64;\n\
    \        if strn > strongest {\n            strongest = strn;\n            result\
    \ = format!(\"{}.{}\", class_name, extension);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpuqrrbzkj.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_strength\
    \ = 0;\n    let mut strongest_extension_name = \"\";\n    for ext in extensions\
    \ {\n        let mut caps_count = 0;\n        let mut sm_count = 0;\n        for\
    \ c in ext.chars() {\n            if c.is_uppercase() {\n                caps_count\
    \ += 1;\n            } else {\n                sm_count += 1;\n            }\n\
    \        }\n        let strength = caps_count - sm_count;\n        if strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ strength;\n            strongest_extension_name = &ext;\n        }\n    }\n\
    \    class_name + \".\" + strongest_extension_name\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `ext` does not live long enough\n  --> /tmp/tmph96l3749.rs:33:40\n\
    \   |\n33 |             strongest_extension_name = &ext;\n   |               \
    \                         ^^^^ borrowed value does not live long enough\n34 |\
    \         }\n35 |     }\n   |     - `ext` dropped here while still borrowed\n\
    36 |     class_name + \".\" + strongest_extension_name\n   |                 \
    \       ------------------------ borrow later used here\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0597`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let class_name = class_name;\n\
    \    let mut strongest_extension = (extensions[0].clone(), Strength(&extensions[0]));\n\
    \    let mut strongest_extension_index = 0;\n    for (index, extension) in extensions.iter().enumerate()\
    \ {\n        if Strength(extension) > strongest_extension.1 {\n            strongest_extension\
    \ = (extension.clone(), Strength(extension));\n            strongest_extension_index\
    \ = index;\n        }\n    }\n    let strongest_extension = &extensions[strongest_extension_index];\n\
    \    class_name + \".\" + strongest_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Strength`\
    \ in this scope\n  --> /tmp/tmpl9vkfbum.rs:19:59\n   |\n19 |     let mut strongest_extension\
    \ = (extensions[0].clone(), Strength(&extensions[0]));\n   |                 \
    \                                          ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function, tuple struct or tuple variant `Strength` in\
    \ this scope\n  --> /tmp/tmpl9vkfbum.rs:22:12\n   |\n22 |         if Strength(extension)\
    \ > strongest_extension.1 {\n   |            ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function, tuple struct or tuple variant `Strength`\
    \ in this scope\n  --> /tmp/tmpl9vkfbum.rs:23:55\n   |\n23 |             strongest_extension\
    \ = (extension.clone(), Strength(extension));\n   |                          \
    \                             ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    //code\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_extension_str = 0.0;\n    for e in extensions\
    \ {\n        let mut cap = 0;\n        let mut sm = 0;\n        for c in e.chars()\
    \ {\n            if c.is_uppercase() {\n                cap += 1;\n          \
    \  } else {\n                sm += 1;\n            }\n        }\n        let strength\
    \ = cap as f64 - sm as f64;\n        if strength > strongest_extension_str {\n\
    \            strongest_extension_str = strength;\n            strongest_extension\
    \ = e;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp97aj1azd.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut class_name = class_name;\n\
    \    let mut max_strength = 0.0;\n    let mut strongest_extension = String::new();\n\
    \    let mut ref_value = 0;\n    for (i, s) in extensions.iter().enumerate() {\n\
    \        let mut cap = 0;\n        let mut sm = 0;\n        for c in s.chars()\
    \ {\n            if c.is_uppercase() {\n                cap += 1;\n          \
    \  } else {\n                sm += 1;\n            }\n        }\n        let strength\
    \ = cap as f64 - sm as f64;\n        if strength > max_strength {\n          \
    \  max_strength = strength;\n            ref_value = i;\n        }\n    }\n  \
    \  if max_strength != 0.0 {\n        class_name.push_str(\".\");\n        class_name.push_str(&extensions[ref_value]);\n\
    \    }\n    class_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp_udy9rnz.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_list: Vec<(String,\
    \ String)> = Vec::new();\n    for item in extensions {\n        let mut cap =\
    \ 0;\n        let mut small = 0;\n        for ch in item.chars() {\n         \
    \   if ch.is_uppercase() {\n                cap += 1;\n            } else {\n\
    \                small += 1;\n            }\n        }\n        let strength =\
    \ (cap - small) as f64 / item.len() as f64;\n        let index = extension_list.binary_search_by(|probe|\
    \ {\n            probe.1.partial_cmp(&strength.to_string()).unwrap()\n       \
    \ });\n        match index {\n            Ok(i) => {\n                extension_list.insert(i,\
    \ (item, strength.to_string()));\n            },\n            Err(e) => {\n  \
    \              extension_list.insert(e, (item, strength.to_string()));\n     \
    \       }\n        }\n    }\n    format!(\"{}.{}\", class_name, extension_list[0].0)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.niNE\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmplkxl7kz4.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = String::new();\n    let mut strongest_extension_strength = 0.0;\n    for extension\
    \ in extensions {\n        let mut upper_case_letter_count = 0;\n        let mut\
    \ lower_case_letter_count = 0;\n        for c in extension.chars() {\n       \
    \     if c.is_ascii_uppercase() {\n                upper_case_letter_count +=\
    \ 1;\n            } else if c.is_ascii_lowercase() {\n                lower_case_letter_count\
    \ += 1;\n            }\n        }\n        let curr_extension_strength = upper_case_letter_count\
    \ as f64 - lower_case_letter_count as f64;\n        if curr_extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ curr_extension_strength;\n            strongest_extension_name = extension;\n\
    \        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension_name);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpj6ikst4z.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n\tlet mut extension_vector = extensions;\n\
    \textension_vector.sort_by(|a, b| {\n\t\tlet mut a_strength = 0.0;\n\t\tlet mut\
    \ b_strength = 0.0;\n\t\tfor letter in a.chars() {\n\t\t\tif letter.is_uppercase()\
    \ {\n\t\t\t\ta_strength += 1.0;\n\t\t\t} else {\n\t\t\t\ta_strength -= 1.0;\n\t\
    \t\t}\n\t\t}\n\t\tfor letter in b.chars() {\n\t\t\tif letter.is_uppercase() {\n\
    \t\t\t\tb_strength += 1.0;\n\t\t\t} else {\n\t\t\t\tb_strength -= 1.0;\n\t\t\t\
    }\n\t\t}\n\t\tb_strength.partial_cmp(&a_strength).unwrap()\n\t});\n\tlet mut result\
    \ = String::from(class_name);\n\tresult.push('.');\n\tresult.push_str(&extension_vector[0]);\n\
    \tresult\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpcsecs8yz.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // your code here\n    let\
    \ mut strongest_extension = String::from(\"\");\n    let mut strongest_extension_strength\
    \ = 0f64;\n    for extension in extensions {\n        let strength = calculate_strength(&extension);\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `calculate_strength` in this scope\n\
    \  --> /tmp/tmp_sn2xl17.rs:22:24\n   |\n22 |         let strength = calculate_strength(&extension);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_strength\
    \ = 0;\n    let mut strongest_extension = String::new();\n    for extension in\
    \ extensions {\n        let mut char_vec: Vec<char> = extension.chars().collect();\n\
    \        let caps = char_vec.iter().filter(|c| c.is_uppercase()).count();\n  \
    \      let smalls = char_vec.iter().filter(|c| c.is_lowercase()).count();\n  \
    \      let strength = caps - smalls;\n        if strength > extension_strength\
    \ {\n            extension_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpypf9e5lo.rs:24:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut highest_strength =\
    \ 0;\n    let mut strongest_extension = \"\";\n    for extension in extensions\
    \ {\n        let (upper, lower) = extension.split_whitespace().filter(|w| w.chars().all(|c|\
    \ c.is_alphabetic())).fold((0, 0), |(upper, lower), word| {\n            (upper\
    \ + word.chars().filter(|c| c.is_uppercase()).count(), lower + word.chars().filter(|c|\
    \ c.is_lowercase()).count())\n        });\n        let strength = upper - lower;\n\
    \        if strength >= highest_strength {\n            highest_strength = strength;\n\
    \            strongest_extension = extension.as_str();\n        }\n    }\n   \
    \ class_name + \".\" + strongest_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `extension` does not live long enough\n  --> /tmp/tmp00pqzh4p.rs:27:35\n\
    \   |\n27 |             strongest_extension = extension.as_str();\n   |      \
    \                             ^^^^^^^^^^^^^^^^^^ borrowed value does not live\
    \ long enough\n28 |         }\n29 |     }\n   |     - `extension` dropped here\
    \ while still borrowed\n30 |     class_name + \".\" + strongest_extension\n  \
    \ |                        ------------------- borrow later used here\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0597`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpl52f6mth.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let (strongest_name, strongest_strength)\
    \ = extensions.iter().enumerate().fold((String::new(), 0.0), |(strongest_name,\
    \ strongest_strength), (i, extension)| {\n        let (capital_letters, small_letters)\
    \ = extension.chars().fold((0, 0), |(capital_letters, small_letters), c| {\n \
    \           if c.is_uppercase() { (capital_letters + 1, small_letters) }\n   \
    \         else if c.is_lowercase() { (capital_letters, small_letters + 1) }\n\
    \            else { (capital_letters, small_letters) }\n        });\n        let\
    \ strength = (capital_letters as f64) - (small_letters as f64);\n        if strength\
    \ > strongest_strength { (extension.clone(), strength) }\n        else if strength\
    \ == strongest_strength {\n            let mut strongest_name_chars = strongest_name.chars();\n\
    \            let mut extension_chars = extension.chars();\n            let mut\
    \ i = 0;\n            while strongest_name_chars.next() == extension_chars.next()\
    \ { i += 1; }\n            if i < strongest_name.len() && i < extension.len()\
    \ {\n                if extension_chars.next().unwrap() < strongest_name_chars.next().unwrap()\
    \ {\n                    (extension.clone(), strength)\n                }\n  \
    \              else { (strongest_name, strongest_strength) }\n            }\n\
    \            else {\n                if extension.len() < strongest_name.len()\
    \ { (extension.clone(), strength) }\n                else { (strongest_name, strongest_strength)\
    \ }\n            }\n        }\n        else { (strongest_name, strongest_strength)\
    \ }\n    });\n    format!(\"{}.{}\", class_name, strongest_name)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmp5s6bdgau.rs:51:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut top_score = 0;\n \
    \   let mut top_ext = String::new();\n    for ext in extensions {\n        let\
    \ mut cap = 0;\n        let mut sm = 0;\n        for c in ext.chars() {\n    \
    \        if c.is_ascii_uppercase() {\n                cap += 1;\n            }\
    \ else {\n                sm += 1;\n            }\n        }\n        let score\
    \ = cap - sm;\n        if score > top_score {\n            top_score = score;\n\
    \            top_ext = ext;\n        }\n    }\n    let mut new_class = class_name;\n\
    \    new_class.push('.');\n    new_class.push_str(&top_ext);\n    new_class\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpnasbds5p.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_strengths:\
    \ HashMap<String, f64> = HashMap::new();\n    for extension in extensions {\n\
    \        let mut strength: f64 = 0.0;\n        for c in extension.chars() {\n\
    \            if c.is_uppercase() {\n                strength += 1.0;\n       \
    \     } else if c.is_lowercase() {\n                strength -= 1.0;\n       \
    \     }\n        }\n        extension_strengths.insert(extension, strength);\n\
    \    }\n    let strongest_extension: &String = extension_strengths.iter().max_by_key(|x|\
    \ OrderedFloat(x.1)).unwrap().0;\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp1g4py_00.rs:18:34\n\
    \   |\n18 |     let mut extension_strengths: HashMap<String, f64> = HashMap::new();\n\
    \   |                                  ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp1g4py_00.rs:18:57\n   |\n18 |     let mut extension_strengths: HashMap<String,\
    \ f64> = HashMap::new();\n   |                                               \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]: cannot\
    \ find function, tuple struct or tuple variant `OrderedFloat` in this scope\n\
    \  --> /tmp/tmp1g4py_00.rs:30:82\n   |\n30 |     let strongest_extension: &String\
    \ = extension_strengths.iter().max_by_key(|x| OrderedFloat(x.1)).unwrap().0;\n\
    \   |                                                                        \
    \          ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_strength\
    \ = -10_000;\n    let mut strongest_name = \"\".to_string();\n    for ext in extensions\
    \ {\n        let strength = (ext.chars().filter(|&ch| ch.is_uppercase()).count()\
    \ as i32) - (ext.chars().filter(|&ch| ch.is_lowercase()).count() as i32);\n  \
    \      if strength > strongest_strength {\n            strongest_strength = strength;\n\
    \            strongest_name = ext;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ strongest_name)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_strength = 0;\n    for extension in\
    \ extensions {\n        let mut strength = 0;\n        for character in extension.chars()\
    \ {\n            if character.is_uppercase() {\n                strength += 1;\n\
    \            } else {\n                strength -= 1;\n            }\n       \
    \ }\n        if strength > strongest_strength {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    class_name + \".\" + &strongest_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp0621ists.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: Vec<f64>\
    \ = Vec::new();\n    let mut strongest_extension = 0.0;\n    let mut strongest_index\
    \ = 0;\n    for x in 0..extensions.len() {\n        let mut sm = 0;\n        let\
    \ mut cap = 0;\n        for letter in extensions[x].chars() {\n            if\
    \ letter.is_ascii_uppercase() {\n                cap += 1;\n            } else\
    \ {\n                sm += 1;\n            }\n        }\n        strength.push(cap\
    \ as f64 - sm as f64);\n        if strength[x] > strongest_extension {\n     \
    \       strongest_extension = strength[x];\n            strongest_index = x;\n\
    \        }\n    }\n    let mut output = class_name.clone();\n    output.push('.');\n\
    \    output.push_str(&extensions[strongest_index]);\n    output\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpwk7ff212.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result = class_name;\n\
    \    let mut max_strength = 0;\n    for extension in extensions {\n        let\
    \ (cap, small) = count_cap_small(&extension);\n        let strength = cap - small;\n\
    \        if strength > max_strength {\n            max_strength = strength;\n\
    \            result = String::from(&format!(\"{}.{}\", class_name, extension));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_cap_small` in this scope\n  -->\
    \ /tmp/tmpct05xbuv.rs:21:28\n   |\n21 |         let (cap, small) = count_cap_small(&extension);\n\
    \   |                            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strength: f64 = 0.0;\n    for i in extensions\
    \ {\n        let temp_strength = strength_of_extension(&i);\n        if temp_strength\
    \ > strength {\n            strength = temp_strength;\n            strongest_extension\
    \ = i;\n        }\n    }\n    let mut s = String::from(class_name);\n    s.push_str(\"\
    .\");\n    s.push_str(&strongest_extension);\n    s\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `strength_of_extension` in this scope\n\
    \  --> /tmp/tmpyfbr88ns.rs:21:29\n   |\n21 |         let temp_strength = strength_of_extension(&i);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `strongest_extension`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = extensions[0].clone();\n\
    \    let mut strength = 0.0;\n    for extension in extensions {\n        let (cap,\
    \ sm) = CAP_SM(&extension);\n        let curr_strength = cap as f64 - sm as f64;\n\
    \        if curr_strength > strength {\n            strength = curr_strength;\n\
    \            strongest = extension;\n        }\n    }\n    format!(\"{}.{}\",\
    \ class_name, strongest)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `CAP_SM`\
    \ in this scope\n  --> /tmp/tmp46yyzi66.rs:21:25\n   |\n21 |         let (cap,\
    \ sm) = CAP_SM(&extension);\n   |                         ^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0;\n  \
    \  let mut strongest_ext = String::new();\n    for ext in extensions {\n     \
    \   let ext_str = ext.clone();\n        let ext_str = ext_str.to_lowercase();\n\
    \        let mut curr_strength = 0;\n        for c in ext.chars() {\n        \
    \    if c.is_uppercase() {\n                curr_strength += 1;\n            }\
    \ else {\n                curr_strength -= 1;\n            }\n        }\n    \
    \    if curr_strength > strength {\n            strength = curr_strength;\n  \
    \          strongest_ext = ext;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ strongest_ext)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpd5kykoyv.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut ans = class_name.clone();\n\
    \    let mut str_ext = 0;\n    for extension in extensions {\n        let str_cur\
    \ = strength(&extension);\n        if str_cur >= str_ext {\n            str_ext\
    \ = str_cur;\n            ans = class_name.clone() + \".\" + &extension;\n   \
    \     }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `strength` in this scope\n  --> /tmp/tmp9504_2ao.rs:21:23\n\
    \   |\n21 |         let str_cur = strength(&extension);\n   |                \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpl52f6mth.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let (strongest_extension,\
    \ _) = extensions.iter().fold((String::new(), 0), |(strongest_extension, max_strength),\
    \ current_extension| {\n        let current_extension_strength = {\n         \
    \   let count_lowercase_letter = current_extension.chars().filter(|&c| c.is_lowercase()).count();\n\
    \            let count_uppercase_letter = current_extension.chars().filter(|&c|\
    \ c.is_uppercase()).count();\n            count_uppercase_letter - count_lowercase_letter\n\
    \        };\n        if current_extension_strength > max_strength {\n        \
    \    (current_extension.clone(), current_extension_strength)\n        } else {\n\
    \            (strongest_extension, max_strength)\n        }\n    });\n    format!(\"\
    {}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp3hj65drs.rs:22:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_name = String::from(\"\
    \");\n    let mut strongest_strength = 0;\n    for i in 0..extensions.len() {\n\
    \        let mut CAP = 0;\n        let mut SM = 0;\n        for j in 0..extensions[i].len()\
    \ {\n            if extensions[i].as_bytes()[j] >= 65 && extensions[i].as_bytes()[j]\
    \ <= 90 {\n                CAP += 1;\n            } else {\n                SM\
    \ += 1;\n            }\n        }\n        if CAP - SM > strongest_strength {\n\
    \            strongest_strength = CAP - SM;\n            strongest_name = extensions[i].clone();\n\
    \        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_name);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpujm1ay1l.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_ext: String\
    \ = String::from(\"\");\n    let mut strongest_ext_strength: i32 = 0;\n    for\
    \ ext in extensions {\n        let mut small_letters: i32 = 0;\n        let mut\
    \ big_letters: i32 = 0;\n        for ch in ext.chars() {\n            if ch.is_lowercase()\
    \ {\n                small_letters += 1;\n            } else if ch.is_uppercase()\
    \ {\n                big_letters += 1;\n            }\n        }\n        let\
    \ ext_strength: i32 = big_letters - small_letters;\n        if ext_strength >\
    \ strongest_ext_strength {\n            strongest_ext_strength = ext_strength;\n\
    \            strongest_ext = ext;\n        }\n    }\n    return format!(\"{}.{}\"\
    , class_name, strongest_ext);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpldk8hvd9.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: Vec<String>\
    \ = Vec::new();\n    for (i, element) in extensions.iter().enumerate() {\n   \
    \     let mut caps = 0;\n        let mut smalls = 0;\n        for character in\
    \ element.chars() {\n            if character.is_uppercase() {\n             \
    \   caps += 1;\n            } else {\n                smalls += 1;\n         \
    \   }\n        }\n        strength.push(format!(\"{}.{}\", i, caps - smalls));\n\
    \    }\n    let mut max = 0;\n    let mut max_index = 0;\n    for i in 0..strength.len()\
    \ {\n        let temp: Vec<&str> = strength[i].split('.').collect();\n       \
    \ if temp[1].parse::<i32>().unwrap() > max {\n            max = temp[1].parse::<i32>().unwrap();\n\
    \            max_index = i;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extensions[max_index])\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmphb9kdg4t.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result = String::from(\"\
    \");\n    let mut strength = std::f64::MIN;\n    for i in extensions {\n     \
    \   let length = i.len();\n        let mut counter = 0;\n        for j in i.chars()\
    \ {\n            if j.is_uppercase() {\n                counter += 1;\n      \
    \      }\n        }\n        let num = counter as f64 / length as f64;\n     \
    \   if num > strength {\n            strength = num;\n            result = String::from(i);\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, result)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp1yirhshx.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_strength\
    \ = 0;\n    let mut strongest_extension = \"\";\n    for ext in extensions {\n\
    \        let strength = CAP_Extension_Strength(&ext) - SM_Extension_Strength(&ext);\n\
    \        if strength > strongest_strength {\n            strongest_strength =\
    \ strength;\n            strongest_extension = &ext;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `CAP_Extension_Strength`\
    \ in this scope\n  --> /tmp/tmpqmuuy384.rs:21:24\n   |\n21 |         let strength\
    \ = CAP_Extension_Strength(&ext) - SM_Extension_Strength(&ext);\n   |        \
    \                ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function, tuple struct or tuple variant `SM_Extension_Strength`\
    \ in this scope\n  --> /tmp/tmpqmuuy384.rs:21:55\n   |\n21 |         let strength\
    \ = CAP_Extension_Strength(&ext) - SM_Extension_Strength(&ext);\n   |        \
    \                                               ^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut max_cap = 0;\n    let mut max_sm = 0;\n    for\
    \ ext in extensions {\n        let mut cap = 0;\n        let mut sm = 0;\n   \
    \     for ch in ext.chars() {\n            if ch.is_uppercase() {\n          \
    \      cap += 1;\n            } else if ch.is_lowercase() {\n                sm\
    \ += 1;\n            }\n        }\n        if (cap - sm > max_cap - max_sm) ||\
    \ (cap - sm == max_cap - max_sm && ext < strongest_extension) {\n            max_cap\
    \ = cap;\n            max_sm = sm;\n            strongest_extension = ext;\n \
    \       }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpi4igo8bu.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: f64 = -1.0;\n\
    \    let mut strength_extension = String::new();\n    for ext in extensions {\n\
    \        let mut curr_strength: f64 = 0.0;\n        for c in ext.chars() {\n \
    \           if c.is_uppercase() {\n                curr_strength += 1.0;\n   \
    \         } else {\n                curr_strength -= 1.0;\n            }\n   \
    \     }\n        if curr_strength > strength {\n            strength = curr_strength;\n\
    \            strength_extension = ext;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, strength_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp3p6lq0sf.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut upper = 0;\n    let\
    \ mut lower = 0;\n    let mut strong = 0;\n    let mut res = \"no extension\"\
    ;\n    for i in extensions {\n        for j in i.chars() {\n            if j.is_uppercase()\
    \ {\n                upper += 1;\n            } else {\n                lower\
    \ += 1;\n            }\n        }\n        if (upper - lower) > strong {\n   \
    \         strong = upper - lower;\n            res = &i;\n        }\n        upper\
    \ = 0;\n        lower = 0;\n    }\n    return format!(\"{}.{}\", class_name, res);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `i` does not live long enough\n  --> /tmp/tmpev2selsl.rs:32:19\n\
    \   |\n32 |             res = &i;\n   |                   ^^ borrowed value does\
    \ not live long enough\n...\n36 |     }\n   |     - `i` dropped here while still\
    \ borrowed\n37 |     return format!(\"{}.{}\", class_name, res);\n   |       \
    \                                  --- borrow later used here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0597`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strength: f64 = 0.0;\n    for ext in extensions\
    \ {\n        let cap = ext.chars().filter(|c| c.is_uppercase()).count();\n   \
    \     let sm = ext.chars().filter(|c| c.is_lowercase()).count();\n        let\
    \ s = (cap as f64) - (sm as f64);\n        if s > strength {\n            strength\
    \ = s;\n            strongest_extension = ext;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpde56s4nm.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = 0f64;\n\
    \    let mut strongest_extension = String::new();\n    for ext in extensions {\n\
    \        let strength = ext.chars().fold(0f64, |acc, c| {\n            if c.is_uppercase()\
    \ {\n                acc + 1f64\n            } else {\n                acc - 1f64\n\
    \            }\n        });\n        if strength > max_strength {\n          \
    \  max_strength = strength;\n            strongest_extension = ext;\n        }\n\
    \    }\n    return format!(\"{}.{}\", class_name, strongest_extension);\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmplcevul7b.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strong = -10.;\n \
    \   let mut strong_name = \"\".to_string();\n    for i in extensions {\n     \
    \   let mut up = 0;\n        let mut low = 0;\n        for j in i.as_bytes() {\n\
    \            if *j >= 65 && *j <= 90 {\n                up += 1;\n           \
    \ } else if *j >= 97 && *j <= 122 {\n                low += 1;\n            }\n\
    \        }\n        let mut new_strong = up as f64 - low as f64;\n        if new_strong\
    \ > strong {\n            strong = new_strong;\n            strong_name = i;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, strong_name)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_strength\
    \ = 0;\n    let mut strongest_name = String::new();\n    for extension in extensions\
    \ {\n        let strength = Strongest_Extension_Helper(extension);\n        if\
    \ strength > strongest_strength {\n            strongest_strength = strength;\n\
    \            strongest_name = extension;\n        }\n    }\n    class_name + \"\
    .\" + &strongest_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Strongest_Extension_Helper`\
    \ in this scope\n  --> /tmp/tmpnzwk5wgl.rs:21:24\n   |\n21 |         let strength\
    \ = Strongest_Extension_Helper(extension);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    format!(\"{}.{}\", class_name,\
    \ *extensions.iter().max_by_key(|x| strength(*x)).unwrap())\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `strength` in this scope\n  --> /tmp/tmpwwlunj4b.rs:18:68\n\
    \   |\n18 |     format!(\"{}.{}\", class_name, *extensions.iter().max_by_key(|x|\
    \ strength(*x)).unwrap())\n   |                                              \
    \                      ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = (0.0, 0);\n\
    \    for i in 0..extensions.len() {\n        let cap = extensions[i].chars().filter(|&x|\
    \ x.is_uppercase()).count();\n        let sm = extensions[i].chars().filter(|&x|\
    \ x.is_lowercase()).count();\n        let current_strength = (cap as f64 - sm\
    \ as f64, i);\n        if current_strength > strength {\n            strength\
    \ = current_strength;\n        }\n    }\n    return format!(\"{}.{}\", class_name,\
    \ extensions[strength.1]);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.-_-\"`,\n right: `\"__HAHA.123\"`', /tmp/tmpwt_1vaxw.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_strength:\
    \ Vec<(String, i32)> = Vec::new();\n    for extension in extensions {\n      \
    \  let mut upper_count = 0;\n        let mut lower_count = 0;\n        for ch\
    \ in extension.chars() {\n            if ch.is_lowercase() {\n               \
    \ lower_count += 1;\n            } else {\n                upper_count += 1;\n\
    \            }\n        }\n        extension_strength.push((extension, upper_count\
    \ - lower_count));\n    }\n    let mut most_negative = std::i32::MAX;\n    let\
    \ mut most_negative_string = String::new();\n    for extension in extension_strength\
    \ {\n        if extension.1 < most_negative {\n            most_negative = extension.1;\n\
    \            most_negative_string = extension.0;\n        }\n    }\n    return\
    \ class_name + \".\" + &most_negative_string;\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.niNE\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp6t5puxgc.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // your code here\n    let\
    \ mut strong = 0;\n    let mut strong_extension = String::new();\n    for extension\
    \ in extensions {\n        let mut count_cap = 0;\n        let mut count_small\
    \ = 0;\n        for c in extension.chars() {\n            if c.is_uppercase()\
    \ {\n                count_cap += 1;\n            } else {\n                count_small\
    \ += 1;\n            }\n        }\n        let strength = count_cap - count_small;\n\
    \        if strength < strong {\n            strong = strength;\n            strong_extension\
    \ = extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, strong_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpi7tcf3wm.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code goes here...\n\
    \    let mut all_strength: Vec<(i32, String)> = Vec::new();\n    for extension\
    \ in extensions {\n        let mut cap = 0;\n        let mut small = 0;\n    \
    \    for letter in extension.chars() {\n            if letter.is_uppercase() {\n\
    \                cap += 1;\n            } else {\n                small += 1;\n\
    \            }\n        }\n        all_strength.push((cap - small, extension));\n\
    \    }\n    all_strength.sort_by(|a, b| a.0.cmp(&b.0));\n    format!(\"{}.{}\"\
    , class_name, all_strength.pop().unwrap().1)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.eMptY\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpj5uudgtd.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + &extensions.iter().max_by_key(|s|\
    \ (s.as_str().chars().filter(|c| c.is_uppercase()).count() as i32) - (s.as_str().chars().filter(|c|\
    \ c.is_lowercase()).count() as i32)).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.-_-\"`,\n right: `\"__HAHA.123\"`', /tmp/tmp5uiti2ch.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" +\n   \
    \ extensions.iter()\n        .max_by_key(|s| (s.chars().filter(|c| c.is_uppercase()).count(),\
    \ s.chars().filter(|c| c.is_lowercase()).count()))\n        .unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.123NoooneB321\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpk4gsu20z.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\";\n    let mut strongest_extension_strength = 0.0;\n    for extension\
    \ in extensions {\n        let mut capital_letters = 0;\n        let mut small_letters\
    \ = 0;\n        for letter in extension.chars() {\n            if letter.is_uppercase()\
    \ {\n                capital_letters += 1;\n            } else {\n           \
    \     small_letters += 1;\n            }\n        }\n        let extension_strength\
    \ = capital_letters as f64 - small_letters as f64;\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength;\n            strongest_extension = &extension;\n       \
    \ }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `extension` does not live long enough\n  --> /tmp/tmpo89lmuo5.rs:33:35\n\
    \   |\n33 |             strongest_extension = &extension;\n   |              \
    \                     ^^^^^^^^^^ borrowed value does not live long enough\n34\
    \ |         }\n35 |     }\n   |     - `extension` dropped here while still borrowed\n\
    36 |     format!(\"{}.{}\", class_name, strongest_extension)\n   |           \
    \                       ------------------- borrow later used here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0597`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + &extensions.iter().fold((\"\
    \", 100), |acc, ex| {\n        let cap = ex.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = ex.chars().filter(|c| c.is_lowercase()).count();\n        let\
    \ strength = (cap - sm) as f64 / ex.len() as f64;\n        if strength < acc.1\
    \ { (ex, strength) } else { acc }\n    }).0\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_rj0w7sk.rs:22:23\n   |\n\
    22 |         if strength < acc.1 { (ex, strength) } else { acc }\n   |       \
    \                ^^^^^ expected `f64`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_rj0w7sk.rs:22:36\n   |\n22 |         if strength < acc.1\
    \ { (ex, strength) } else { acc }\n   |                                    ^^^^^^^^\
    \ expected integer, found `f64`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_strength = 0.0;\n    for extension in\
    \ extensions {\n        let mut strength = 0.0;\n        for character in extension.chars()\
    \ {\n            if character.is_uppercase() {\n                strength += 1.0;\n\
    \            } else {\n                strength -= 1.0;\n            }\n     \
    \   }\n        if strength > strongest_strength {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpxjon3i2r.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut ext_vec: Vec<(String,\
    \ f64)> = Vec::new();\n    let mut strongest_ext = String::new();\n    let mut\
    \ strongest_ext_strength = 0.0;\n    for extension in extensions {\n        let\
    \ mut uppercase_count = 0;\n        let mut lowercase_count = 0;\n        for\
    \ c in extension.chars() {\n            if c.is_uppercase() {\n              \
    \  uppercase_count += 1;\n            } else if c.is_lowercase() {\n         \
    \       lowercase_count += 1;\n            }\n        }\n        let strength\
    \ = uppercase_count as f64 - lowercase_count as f64;\n        ext_vec.push((extension,\
    \ strength));\n    }\n    ext_vec.sort_by(|x, y| x.1.partial_cmp(&y.1).unwrap());\n\
    \    for (extension, strength) in ext_vec {\n        if strength > strongest_ext_strength\
    \ {\n            strongest_ext_strength = strength;\n            strongest_ext\
    \ = extension;\n        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_ext);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmphvuzn77e.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = -100.0;\n\
    \    let mut extension_name = String::from(\" \");\n    for extension in extensions\
    \ {\n        let mut strength = 0.0;\n        for letter in extension.chars()\
    \ {\n            if letter.is_uppercase() {\n                strength += 1.0;\n\
    \            } else {\n                strength -= 1.0;\n            }\n     \
    \   }\n        if strength > max_strength {\n            max_strength = strength;\n\
    \            extension_name = extension;\n        }\n    }\n    class_name + \"\
    .\" + &extension_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpo7pojuwh.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = None;\n    let mut strongest_extension_strength = None;\n    for extension\
    \ in extensions {\n        let strength = extension.chars().filter(|c| c.is_uppercase()).count()\
    \ as i32 -\n            extension.chars().filter(|c| c.is_lowercase()).count()\
    \ as i32;\n        if strongest_extension_strength.is_none() || strength > strongest_extension_strength.unwrap()\
    \ {\n            strongest_extension = Some(extension);\n            strongest_extension_strength\
    \ = Some(strength);\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension.unwrap())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        return class_name;\n    }\n    let mut max = 0;\n    let mut ret = class_name.clone();\n\
    \    let mut index = 0;\n    for i in 0..extensions.len() {\n        let mut uppercase\
    \ = 0;\n        let mut lowercase = 0;\n        for j in 0..extensions[i].len()\
    \ {\n            if extensions[i].chars().nth(j).unwrap().is_uppercase() {\n \
    \               uppercase += 1;\n            } else {\n                lowercase\
    \ += 1;\n            }\n        }\n        if uppercase - lowercase > max {\n\
    \            max = uppercase - lowercase;\n            ret = class_name.clone()\
    \ + \".\" + &extensions[i];\n            index = i;\n        }\n    }\n    let\
    \ mut index_of_lowest = 0;\n    for i in 0..extensions.len() {\n        let mut\
    \ uppercase = 0;\n        let mut lowercase = 0;\n        for j in 0..extensions[i].len()\
    \ {\n            if extensions[i].chars().nth(j).unwrap().is_uppercase() {\n \
    \               uppercase += 1;\n            } else {\n                lowercase\
    \ += 1;\n            }\n        }\n        if uppercase - lowercase == max {\n\
    \            index_of_lowest = i;\n            break;\n        }\n    }\n    return\
    \ ret.replace(extensions[index].as_str(), extensions[index_of_lowest].as_str());\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpons6h0he.rs:61:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = \"\";\n\
    \    let mut result = \"\";\n    let mut strength = 0;\n    for ext in extensions\
    \ {\n        let ext_strength = count_upper(&ext) - count_lower(&ext);\n     \
    \   if ext_strength > strength {\n            strongest = &ext;\n            strength\
    \ = ext_strength;\n        }\n    }\n    result = format!(\"{}.{}\", class_name,\
    \ strongest);\n    result.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper` in this scope\n  --> /tmp/tmpuf58oxuq.rs:22:28\n\
    \   |\n22 |         let ext_strength = count_upper(&ext) - count_lower(&ext);\n\
    \   |                            ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `count_lower` in this scope\n  --> /tmp/tmpuf58oxuq.rs:22:48\n\
    \   |\n22 |         let ext_strength = count_upper(&ext) - count_lower(&ext);\n\
    \   |                                                ^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuf58oxuq.rs:28:14\n\
    \   |\n28 |     result = format!(\"{}.{}\", class_name, strongest);\n   |    \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `String`\n   |\n   = note: this error originates in the macro `format` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_strength = 100000;\n\
    \    let mut best_extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut lowercase_letters = 0;\n        let mut uppercase_letters\
    \ = 0;\n        for letter in extension.chars() {\n            if letter.is_uppercase()\
    \ {\n                uppercase_letters += 1;\n            } else {\n         \
    \       lowercase_letters += 1;\n            }\n        }\n        let strength\
    \ = uppercase_letters - lowercase_letters;\n        if strength < best_strength\
    \ {\n            best_strength = strength;\n            best_extension = extension;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, best_extension)\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.niNE\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpdkzkf2na.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Calculate the strength\
    \ of an extension\n    let strength = |extension: &String| -> i32 {\n        extension.chars().fold(0,\
    \ |a, b| {\n            if b.is_lowercase() { a - 1 } else { a + 1 }\n       \
    \ })\n    };\n    // Find the strongest extension, if there are more than one,\
    \ take the first\n    let mut strongest_extension: &String = &extensions[0];\n\
    \    let mut strongest_strength: i32 = strength(&strongest_extension);\n    for\
    \ i in 1..extensions.len() {\n        let strength: i32 = strength(&extensions[i]);\n\
    \        if strength > strongest_strength {\n            strongest_extension =\
    \ &extensions[i];\n            strongest_strength = strength;\n        }\n   \
    \ }\n    // Return the formatted string\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.123NoooneB321\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpkwzmn1wt.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = 0.0;\n\
    \    let mut chosen_class = class_name.clone();\n    for (i, extension) in extensions.iter().enumerate()\
    \ {\n        let num_caps = extension.chars().filter(|&c| c.is_uppercase()).count();\n\
    \        let num_smalls = extension.chars().filter(|&c| c.is_lowercase()).count();\n\
    \        let strength = (num_caps as f64) - (num_smalls as f64);\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n            chosen_class\
    \ = format!(\"{}.{}\", class_name, extension);\n        }\n    }\n    chosen_class\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmplv9ogjbp.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_extension = String::from(\"\
    \");\n    let mut best_extension_strength = 0.0;\n    for ext in extensions {\n\
    \        let mut upper_count = 0;\n        let mut lower_count = 0;\n        for\
    \ c in ext.chars() {\n            if c.is_ascii_uppercase() {\n              \
    \  upper_count += 1;\n            } else if c.is_ascii_lowercase() {\n       \
    \         lower_count += 1;\n            }\n        }\n        let strength =\
    \ (upper_count as f64) - (lower_count as f64);\n        if strength > best_extension_strength\
    \ {\n            best_extension_strength = strength;\n            best_extension\
    \ = ext;\n        }\n    }\n    let mut fqcn = class_name;\n    fqcn.push('.');\n\
    \    fqcn.push_str(&best_extension);\n    fqcn\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpt0213_lc.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut best_strength = 0.0;\n    for extension in extensions\
    \ {\n        let strength = Strength(&extension);\n        if strength > best_strength\
    \ {\n            best_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    class_name + \".\" + &strongest_extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Strength`\
    \ in this scope\n  --> /tmp/tmpgmh1weue.rs:21:24\n   |\n21 |         let strength\
    \ = Strength(&extension);\n   |                        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_extension_strength = 0;\n    for extension\
    \ in extensions {\n        let mut cap = 0;\n        let mut sm = 0;\n       \
    \ for c in extension.chars() {\n            if c.is_uppercase() {\n          \
    \      cap += 1;\n            } else {\n                sm += 1;\n           \
    \ }\n        }\n        let extension_strength = cap - sm;\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength;\n            strongest_extension = extension;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp1n1ub6to.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    String::from(\"unimplemented\"\
    )\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"unimplemented\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpgx6x2li6.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strength = 0.0;\n    for extension in extensions\
    \ {\n        let mut caps = 0;\n        let mut smalls = 0;\n        for ch in\
    \ extension.chars() {\n            if ch.is_ascii_uppercase() {\n            \
    \    caps += 1;\n            } else if ch.is_ascii_lowercase() {\n           \
    \     smalls += 1;\n            }\n        }\n        let current_strength = caps\
    \ as f64 - smalls as f64;\n        if current_strength > strength {\n        \
    \    strength = current_strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    let mut result = class_name;\n    result.push('.');\n \
    \   result.push_str(&strongest_extension);\n    result\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpza8mr_5f.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut map = BTreeMap::new();\n\
    \    for extension in extensions {\n        let upper = extension.to_uppercase();\n\
    \        let lower = extension.to_lowercase();\n        let upper_count = upper.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let lower_count = lower.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let strength = upper_count as i32 - lower_count\
    \ as i32;\n        map.insert(strength, extension);\n    }\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_strength = std::i32::MIN;\n    for (strength,\
    \ extension) in map {\n        if strength > strongest_strength {\n          \
    \  strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeMap`\n  -->\
    \ /tmp/tmpd62jjc_f.rs:18:19\n   |\n18 |     let mut map = BTreeMap::new();\n \
    \  |                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeMap;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_exte: String\
    \ = \"\".to_string();\n    let mut strongest_exte_strength: f64 = -std::f64::MAX;\n\
    \    for exte in extensions {\n        let mut upper_count: u32 = 0;\n       \
    \ let mut lower_count: u32 = 0;\n        for c in exte.chars() {\n           \
    \ if c.is_uppercase() {\n                upper_count += 1;\n            } else\
    \ if c.is_lowercase() {\n                lower_count += 1;\n            }\n  \
    \      }\n        let ext_strength: f64 = upper_count as f64 - lower_count as\
    \ f64;\n        if ext_strength > strongest_exte_strength {\n            strongest_exte_strength\
    \ = ext_strength;\n            strongest_exte = exte;\n        }\n    }\n    class_name\
    \ + \".\" + &strongest_exte\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = 0f64;\n\
    \    let mut max_extension = \"\";\n    for extension in extensions {\n      \
    \  let strength = num_uppercase_letters(&extension) as f64 - num_lowercase_letters(&extension)\
    \ as f64;\n        if strength > max_strength {\n            max_strength = strength;\n\
    \            max_extension = &extension;\n        }\n    }\n    class_name + \"\
    .\" + max_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_uppercase_letters` in this scope\n\
    \  --> /tmp/tmplh_auluu.rs:21:24\n   |\n21 |         let strength = num_uppercase_letters(&extension)\
    \ as f64 - num_lowercase_letters(&extension) as f64;\n   |                   \
    \     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `num_lowercase_letters` in this scope\n  --> /tmp/tmplh_auluu.rs:21:67\n\
    \   |\n21 |         let strength = num_uppercase_letters(&extension) as f64 -\
    \ num_lowercase_letters(&extension) as f64;\n   |                            \
    \                                       ^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_strength = 0.0;\n\
    \    let mut best_ext = String::new();\n    for ext in extensions {\n        let\
    \ mut cap = 0;\n        let mut small = 0;\n        for ch in ext.chars() {\n\
    \            if ch.is_uppercase() {\n                cap += 1;\n            }\
    \ else {\n                small += 1;\n            }\n        }\n        let strength\
    \ = (cap as f64) - (small as f64);\n        if strength > best_strength {\n  \
    \          best_strength = strength;\n            best_ext = ext;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, best_ext)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpyl43p2u1.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = String::new();\n    let mut strongest_extension_strength = 0.0;\n    for extension\
    \ in extensions {\n        let (caps, smalls) = caps_and_smalls(extension);\n\
    \        let strength = (caps as f64) - (smalls as f64);\n        if strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ strength;\n            strongest_extension_name = extension;\n        }\n  \
    \  }\n    format!(\"{}.{}\", class_name, strongest_extension_name)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `caps_and_smalls` in this scope\n  -->\
    \ /tmp/tmp984ch796.rs:21:30\n   |\n21 |         let (caps, smalls) = caps_and_smalls(extension);\n\
    \   |                              ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strengths: Vec<(f64,\
    \ String)> = vec![];\n    for x in extensions {\n        let strength = x.chars().fold((0_f64,\
    \ 0_f64), |sum, c| {\n            if c.is_ascii_uppercase() {\n              \
    \  (sum.0 + 1.0, sum.1)\n            } else {\n                (sum.0, sum.1 +\
    \ 1.0)\n            }\n        });\n        strengths.push((strength.0 - strength.1,\
    \ x));\n    }\n    let mut sorted = strengths.clone();\n    sorted.sort_by(|a,\
    \ b| b.partial_cmp(a).unwrap());\n    format!(\"{}.{}\", class_name, strengths.iter().position(|x|\
    \ *x == sorted[0]).unwrap())\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.0\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp34xc8plk.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut max_strength = 0.0;\n    for s in extensions {\n\
    \        let lowercase = s.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let uppercase = s.chars().filter(|c| c.is_uppercase()).count();\n      \
    \  let strength = (uppercase as f64) - (lowercase as f64);\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n            strongest_extension\
    \ = s;\n        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpsslyf76d.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let strong = extensions.iter().map(|e|\
    \ {\n        let strength = (e.chars().filter(|c| c.is_uppercase()).count() as\
    \ f64) - (e.chars().filter(|c| c.is_lowercase()).count() as f64);\n        (e,\
    \ strength)\n    }).max_by(|a, b| a.1.partial_cmp(&b.1).unwrap()).unwrap();\n\
    \    format!(\"{}.{}\", class_name, strong.0)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.-_-\"`,\n right: `\"__HAHA.123\"`', /tmp/tmpk0ytfm9k.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let class_name = class_name;\n\
    \    let mut strongest_name = \"\".to_string();\n    let mut max_strength = 0.0;\n\
    \    for ext in extensions {\n        let strength = Calculate_Strength(ext);\n\
    \        if strength > max_strength {\n            max_strength = strength;\n\
    \            strongest_name = ext;\n        }\n    }\n    let class_extension\
    \ = format!(\"{}.{}\", class_name, strongest_name);\n    return class_extension;\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Calculate_Strength`\
    \ in this scope\n  --> /tmp/tmpfd_a7_in.rs:22:24\n   |\n22 |         let strength\
    \ = Calculate_Strength(ext);\n   |                        ^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = (class_name.clone(),\
    \ 0);\n    for extension in extensions {\n        let (up, low) = extension.chars().fold((0,\
    \ 0), |acc, c| match c {\n            'A'...'Z' => (acc.0 + 1, acc.1),\n     \
    \       'a'...'z' => (acc.0, acc.1 + 1),\n            _ => acc,\n        });\n\
    \        let strength = up - low;\n        if strongest.1 < strength {\n     \
    \       strongest = (extension, strength);\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, strongest.0)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.__YESIMHERE\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpt___xae3.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = extensions[0].clone();\n    let mut strength: f64 = 0.0;\n    for extension\
    \ in extensions {\n        let ext_strength = (extension.matches(char::is_uppercase).count()\
    \ as f64) - \n                           (extension.matches(char::is_lowercase).count()\
    \ as f64);\n        if ext_strength > strength {\n            strength = ext_strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.t\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmp1nemf6lf.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let class_name_clone = class_name.clone();\n\
    \    let mut strongest_extension_name = class_name_clone;\n    let mut strongest_extension_strength\
    \ = 0;\n    for extension in extensions {\n        let strength = extension\n\
    \            .chars()\n            .filter(|c| c.is_uppercase())\n           \
    \ .count() as isize\n            - extension\n                .chars()\n     \
    \           .filter(|c| c.is_lowercase())\n                .count() as isize;\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension_name\
    \ = format!(\"{}.{}\", class_name, extension);\n            strongest_extension_strength\
    \ = strength;\n        }\n    }\n    strongest_extension_name\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpjf9hv0jb.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = (0, String::from(\"\
    \"));\n    for item in extensions {\n        let mut cap = 0;\n        let mut\
    \ sm = 0;\n        for c in item.chars() {\n            if c.is_uppercase() {\n\
    \                cap += 1;\n            } else {\n                sm += 1;\n \
    \           }\n        }\n        if (cap - sm) > strongest.0 {\n            strongest\
    \ = (cap - sm, item);\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest.1)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpsjvkob1y.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    format!(\"{}.{}\",\n     \
    \       class_name,\n            extensions.iter()\n                .fold(None,\
    \ |prev, curr| {\n                    let score = curr.chars()\n             \
    \           .fold((0, 0), |acc, x| {\n                            if x.is_uppercase()\
    \ {\n                                (acc.0 + 1, acc.1)\n                    \
    \        } else {\n                                (acc.0, acc.1 + 1)\n      \
    \                      }\n                        });\n                    match\
    \ prev {\n                        None => Some((curr, score)),\n             \
    \           Some((prev_str, prev_score)) => if prev_score.0 as f32 / prev_score.1\
    \ as f32 > score.0 as f32 / score.1 as f32 { Some((prev_str, prev_score)) } else\
    \ { Some((curr, score)) }\n                    }\n                })\n       \
    \         .unwrap()\n                .0)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp8n7ce7wl.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: f64 = -999.0;\n\
    \    let mut current_strength: f64 = 0.0;\n    let mut strongest_extension: String\
    \ = String::from(\"\");\n    for extension in extensions {\n        for letter\
    \ in extension.chars() {\n            if letter.is_uppercase() {\n           \
    \     current_strength += 1.0;\n            } else {\n                current_strength\
    \ -= 1.0;\n            }\n        }\n        if current_strength > strength {\n\
    \            strength = current_strength;\n            strongest_extension = extension;\n\
    \        }\n        current_strength = 0.0;\n    }\n    format!(\"{}.{}\", class_name,\
    \ strongest_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp5o6lh8wt.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut the_strongest_extension:\
    \ String = String::from(\"None\");\n    let mut strongest_extension_strength:\
    \ f64 = 0.0;\n    let length_of_extensions = extensions.len();\n    for i in 0..length_of_extensions\
    \ {\n        let mut strength_of_the_extension: f64 = 0.0;\n        let mut strength_of_the_extension_upper:\
    \ f64 = 0.0;\n        let mut strength_of_the_extension_lower: f64 = 0.0;\n  \
    \      let characters_in_extension = extensions[i].chars();\n        for j in\
    \ characters_in_extension {\n            if j.is_uppercase() {\n             \
    \   strength_of_the_extension_upper += 1.0;\n            } else if j.is_lowercase()\
    \ {\n                strength_of_the_extension_lower += 1.0;\n            }\n\
    \        }\n        strength_of_the_extension = strength_of_the_extension_upper\
    \ - strength_of_the_extension_lower;\n        if strength_of_the_extension > strongest_extension_strength\
    \ {\n            strongest_extension_strength = strength_of_the_extension;\n \
    \           the_strongest_extension = extensions[i].clone();\n        }\n    }\n\
    \    return format!(\"{}.{}\", class_name, the_strongest_extension);\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.None\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpiw4jdv8q.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut answer = class_name.clone();\n\
    \    let mut max_extension = String::from(\"\");\n    let mut max_strength = std::f64::MIN;\n\
    \    for extension in extensions {\n        let lowercase_letter_count = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let uppercase_letter_count = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let strength = uppercase_letter_count as\
    \ f64 - lowercase_letter_count as f64;\n        if strength > max_strength {\n\
    \            max_strength = strength;\n            max_extension = extension;\n\
    \        }\n    }\n    answer.push('.');\n    answer.push_str(&max_extension);\n\
    \    answer\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // first find the strongest\
    \ extension, return it in a format\n    let mut strongest_extension = String::new();\n\
    \    let mut strongest_extension_strength = 0;\n    for ext in extensions {\n\
    \        let strength = Strength(&ext);\n        if strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = strength;\n            strongest_extension\
    \ = ext;\n        }\n    }\n    // then return the strongest extension in a format:\n\
    \    let extension_with_class_name = format!(\"{}.{}\", class_name, strongest_extension);\n\
    \    extension_with_class_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Strength`\
    \ in this scope\n  --> /tmp/tmpsmbse54s.rs:22:24\n   |\n22 |         let strength\
    \ = Strength(&ext);\n   |                        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = 0;\n \
    \   let mut ext = String::new();\n    for extension in extensions {\n        let\
    \ mut upper_count = 0;\n        let mut lower_count = 0;\n        for c in extension.chars()\
    \ {\n            if c.is_uppercase() {\n                upper_count += 1;\n  \
    \          } else {\n                lower_count += 1;\n            }\n      \
    \  }\n        let strength = (upper_count as f64) - (lower_count as f64);\n  \
    \      if strength > strongest {\n            strongest = strength;\n        \
    \    ext = extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, ext)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_c709870.rs:31:23\n   |\n\
    31 |         if strength > strongest {\n   |                       ^^^^^^^^^ expected\
    \ `f64`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_c709870.rs:32:25\n\
    \   |\n18 |     let mut strongest = 0;\n   |                         - expected\
    \ due to this value\n...\n32 |             strongest = strength;\n   |       \
    \                  ^^^^^^^^ expected integer, found `f64`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0;\n  \
    \  let mut strongest_extension = String::new();\n    for extension in extensions\
    \ {\n        let (capital_letters, small_letters) = count_letters(extension);\n\
    \        let current_strength = capital_letters - small_letters;\n        if current_strength\
    \ > strength {\n            strength = current_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_letters` in this scope\n  -->\
    \ /tmp/tmp2fjqiq8x.rs:21:48\n   |\n21 |         let (capital_letters, small_letters)\
    \ = count_letters(extension);\n   |                                          \
    \      ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + &extensions.iter().max_by_key(|x|\
    \ (x.to_ascii_uppercase().len() as i32) - (x.to_ascii_lowercase().len() as i32)).unwrap()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Boku123.32145tggg\"`,\n right: `\"Boku123.YEs.WeCaNe\"`', /tmp/tmpfrl1g9ze.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = (0,0,class_name.clone());\n    for extension in extensions {\n        let\
    \ cap_count = extension.chars().filter(|&c| c.is_uppercase()).count();\n     \
    \   let sm_count = extension.chars().filter(|&c| c.is_lowercase()).count();\n\
    \        let strength = cap_count as f64 - sm_count as f64;\n        if strength\
    \ > strongest_extension.0 {\n            strongest_extension = (strength, cap_count,\
    \ extension);\n        } else if strength == strongest_extension.0 {\n       \
    \     if cap_count > strongest_extension.1 {\n                strongest_extension\
    \ = (strength, cap_count, extension);\n            }\n        }\n    }\n    let\
    \ mut result = class_name.clone();\n    result.push('.');\n    result.push_str(&strongest_extension.2);\n\
    \    result\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0f08e_l0.rs:23:23\n   |\n\
    23 |         if strength > strongest_extension.0 {\n   |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0f08e_l0.rs:24:36\n   |\n24 |             strongest_extension\
    \ = (strength, cap_count, extension);\n   |                                  \
    \  ^^^^^^^^ expected integer, found `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0f08e_l0.rs:25:31\n   |\n25 |         } else if strength == strongest_extension.0\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^ expected `f64`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0f08e_l0.rs:27:40\n\
    \   |\n27 |                 strongest_extension = (strength, cap_count, extension);\n\
    \   |                                        ^^^^^^^^ expected integer, found\
    \ `f64`\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_extension_strength = std::f64::NEG_INFINITY;\n\
    \    for extension in extensions {\n        let strength = extension.to_uppercase().len()\
    \ as f64 - extension.len() as f64;\n        if strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp11gfoz3m.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + &*extensions.iter().max_by_key(|item|\
    \ Strongness(*item)).unwrap()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Strongness`\
    \ in this scope\n  --> /tmp/tmpv4yks0_z.rs:18:62\n   |\n18 |     class_name +\
    \ \".\" + &*extensions.iter().max_by_key(|item| Strongness(*item)).unwrap()\n\
    \   |                                                              ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut max_strength = 0;\n    for extension in extensions\
    \ {\n        let strength = extension.chars().fold((0, 0), |(upper, lower), c|\
    \ if c.is_uppercase() { (upper + 1, lower) } else { (upper, lower + 1) });\n \
    \       if strength.0 - strength.1 > max_strength {\n            max_strength\
    \ = strength.0 - strength.1;\n            strongest_extension = extension;\n \
    \       }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpup2i0w4n.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0;\n  \
    \  let mut strongest_extension = \"\";\n    for extension in extensions {\n  \
    \      let cap_letter = extension.chars().filter(|&x| x.is_uppercase()).count();\n\
    \        let sm_letter = extension.chars().filter(|&x| x.is_lowercase()).count();\n\
    \        let current_strength = cap_letter - sm_letter;\n        if current_strength\
    \ > strength {\n            strength = current_strength;\n            strongest_extension\
    \ = &extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `extension` does not live long enough\n  --> /tmp/tmp96kfy7vh.rs:26:35\n\
    \   |\n26 |             strongest_extension = &extension;\n   |              \
    \                     ^^^^^^^^^^ borrowed value does not live long enough\n27\
    \ |         }\n28 |     }\n   |     - `extension` dropped here while still borrowed\n\
    29 |     format!(\"{}.{}\", class_name, strongest_extension)\n   |           \
    \                       ------------------- borrow later used here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0597`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + &extensions.iter().max_by_key(|e|\
    \ e.bytes().map(|c| c.is_ascii_uppercase() as i32 - c.is_ascii_lowercase() as\
    \ i32).sum::<i32>()).unwrap()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.-_-\"`,\n right: `\"__HAHA.123\"`', /tmp/tmpwxxjzhpo.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let strength_a: (f64, &String)\
    \ = extensions.iter().map(|s| { \n        let caps = s.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let smalls = s.chars().filter(|c| c.is_lowercase()).count();\n      \
    \  (caps as f64 - smalls as f64, s)\n    }).max().unwrap();\n    class_name +\
    \ \".\" + strength_a.1\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1oqinuwh.rs:22:8\n\
    \     |\n22   |     }).max().unwrap();\n     |        ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `(f64, &String)`\nnote: required\
    \ by a bound in `std::iter::Iterator::max`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\".to_string();\n    let mut strength = -1.0;\n    for i in 0..extensions.len()\
    \ {\n        let mut cap = 0;\n        let mut sm = 0;\n        for j in 0..extensions[i].len()\
    \ {\n            if extensions[i].chars().nth(j).unwrap().is_uppercase() {\n \
    \               cap += 1;\n            } else {\n                sm += 1;\n  \
    \          }\n        }\n        let current_strength = cap as f64 - sm as f64;\n\
    \        if current_strength > strength {\n            strength = current_strength;\n\
    \            strongest_extension = extensions[i].clone();\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpxepdia21.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = String::new();\n    let mut strongest_extension_strength = 0.0;\n    for extension\
    \ in extensions {\n        let strength = extension.chars().fold((0, 0), |(cap,\
    \ sm), c| {\n            if c.is_uppercase() {\n                (cap + 1, sm)\n\
    \            } else {\n                (cap, sm + 1)\n            }\n        });\n\
    \        let fraction = (strength.0 - strength.1) as f64 / extension.len() as\
    \ f64;\n        if fraction > strongest_extension_strength {\n            strongest_extension_strength\
    \ = fraction;\n            strongest_extension_name = extension;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, strongest_extension_name)\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmppt53q4yh.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut current_max = -999;\n\
    \    let mut strongest_extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut cap = 0;\n        let mut sm = 0;\n        for c in extension.chars()\
    \ {\n            if c.is_uppercase() {\n                cap += 1;\n          \
    \  } else {\n                sm += 1;\n            }\n        }\n        let current_strength\
    \ = cap - sm;\n        if current_strength > current_max {\n            current_max\
    \ = current_strength;\n            strongest_extension = extension;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp2enszyvn.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_ratio = 0.0;\n    for extension in extensions\
    \ {\n        let mut upper_chars = 0;\n        let mut lower_chars = 0;\n    \
    \    for ch in extension.chars() {\n            if ch.is_uppercase() {\n     \
    \           upper_chars += 1;\n            } else {\n                lower_chars\
    \ += 1;\n            }\n        }\n        let ratio = upper_chars as f64 - lower_chars\
    \ as f64;\n        if ratio > strongest_ratio {\n            strongest_ratio =\
    \ ratio;\n            strongest_extension = extension;\n        }\n    }\n   \
    \ return format!(\"{}.{}\", class_name, strongest_extension);\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpgk54ap7_.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = String::new();\n\
    \    let mut ratio = -10000.0;\n    for ext in extensions {\n        let mut lower\
    \ = 0;\n        let mut upper = 0;\n        for c in ext.chars() {\n         \
    \   if c.is_lowercase() {\n                lower += 1;\n            } else {\n\
    \                upper += 1;\n            }\n        }\n        let r = (upper\
    \ as f64) / (lower as f64);\n        if r > ratio {\n            ratio = r;\n\
    \            strongest = ext;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ strongest)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp94e0gob9.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_index\
    \ = 0;\n    let mut strongest_extension_strength = 0.0;\n    for i in 0..extensions.len()\
    \ {\n        let mut caps_count = 0;\n        let mut smalls_count = 0;\n    \
    \    for c in extensions[i].chars() {\n            if c.is_alphabetic() {\n  \
    \              if c.is_uppercase() {\n                    caps_count += 1;\n \
    \               } else {\n                    smalls_count += 1;\n           \
    \     }\n            }\n        }\n        let strength = (caps_count as f64)\
    \ - (smalls_count as f64);\n        if strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = strength;\n            strongest_extension_index\
    \ = i;\n        }\n    }\n    let mut result = class_name.clone();\n    result.push('.');\n\
    \    result.push_str(&extensions[strongest_extension_index]);\n    result\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.t\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpl9p43rsa.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\".to_string();\n    let mut strongest_strength = 0;\n    for extension\
    \ in extensions {\n        let strength = extension.chars().filter(|ch| ch.is_uppercase()).count()\
    \ as i32 - extension.chars().filter(|ch| ch.is_lowercase()).count() as i32;\n\
    \        if strength > strongest_strength {\n            strongest_strength =\
    \ strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpvkw653mp.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0;\n  \
    \  let mut strongest_ext = \"\".to_string();\n    for i in extensions {\n    \
    \    let mut uppercase = 0;\n        let mut lowercase = 0;\n        for char\
    \ in i.chars() {\n            if char.is_uppercase() {\n                uppercase\
    \ += 1;\n            } else {\n                lowercase += 1;\n            }\n\
    \        }\n        let new_strength = uppercase - lowercase;\n        if new_strength\
    \ > strength {\n            strength = new_strength;\n            strongest_ext\
    \ = i;\n        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_ext);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpvjfw7ezd.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_value =\
    \ 0.0;\n    let mut strongest_extension = String::new();\n    for extension in\
    \ extensions {\n        let current_value = extension.chars().filter(|&c| c.is_uppercase()).count()\
    \ as f64 -\n                            extension.chars().filter(|&c| c.is_lowercase()).count()\
    \ as f64;\n        if current_value > strongest_value {\n            strongest_value\
    \ = current_value;\n            strongest_extension = extension;\n        }\n\
    \    }\n    class_name + \".\" + &strongest_extension\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpudbvjgwq.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_extension_strength = f64::MIN;\n   \
    \ for extension in extensions {\n        let strength = strength_of_extension(&extension);\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return format!(\"{}.{}\", class_name, strongest_extension);\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `strength_of_extension` in this scope\n\
    \  --> /tmp/tmpipf1psm4.rs:21:24\n   |\n21 |         let strength = strength_of_extension(&extension);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `strongest_extension`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = String::new();\n\
    \    let mut highest = -1000;\n    for ext in extensions {\n        let cap =\
    \ ext.chars().filter(|c| c.is_uppercase()).count();\n        let sm = ext.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let val = cap - sm;\n        if val > highest\
    \ {\n            highest = val;\n            strongest = ext;\n        }\n   \
    \ }\n    format!(\"{}.{}\", class_name, strongest)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2z2v245k.rs:19:23\n\
    \   |\n19 |     let mut highest = -1000;\n   |                       ^^^^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = 0;\n \
    \   let mut strongest_ext = \"\";\n    for ext in extensions {\n        let mut\
    \ caps = 0;\n        let mut lowers = 0;\n        for c in ext.chars() {\n   \
    \         if c.is_uppercase() { caps += 1; }\n            else { lowers += 1;\
    \ }\n        }\n        let strength = caps - lowers;\n        if strength > strongest\
    \ { strongest = strength; strongest_ext = &ext; }\n    }\n    format!(\"{}.{}\"\
    , class_name, strongest_ext)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `ext` does not live long enough\n  --> /tmp/tmp7p5d7_lm.rs:28:73\n\
    \   |\n28 |         if strength > strongest { strongest = strength; strongest_ext\
    \ = &ext; }\n   |                                                            \
    \             ^^^^ borrowed value does not live long enough\n29 |     }\n   |\
    \     - `ext` dropped here while still borrowed\n30 |     format!(\"{}.{}\", class_name,\
    \ strongest_ext)\n   |                                  ------------- borrow later\
    \ used here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0597`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result = String::from(class_name);\n\
    \    let mut strongest_extension_name = String::from(\"\");\n    let mut strongest_extension_strength\
    \ = 0;\n    for i in extensions {\n        let capital_letters_count = i.matches(char::is_uppercase).count();\n\
    \        let small_letters_count = i.matches(char::is_lowercase).count();\n  \
    \      let current_extension_strength = capital_letters_count - small_letters_count;\n\
    \        if current_extension_strength > strongest_extension_strength {\n    \
    \        strongest_extension_strength = current_extension_strength;\n        \
    \    strongest_extension_name = i;\n        }\n    }\n    result.push_str(\".\"\
    );\n    result.push_str(&strongest_extension_name);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp8q7ry5qc.rs:24:42

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut count_strength: Vec<(f64,\
    \ String)> = Vec::new();\n    let class_name = &class_name;\n    let mut strongest_extension:\
    \ String = String::new();\n    let mut strongest_strength: f64 = 0.0;\n    for\
    \ extension in extensions {\n        let mut count_cap = 0;\n        let mut count_sm\
    \ = 0;\n        for ch in extension.chars() {\n            if ch.is_ascii_uppercase()\
    \ {\n                count_cap += 1;\n            } else if ch.is_ascii_lowercase()\
    \ {\n                count_sm += 1;\n            }\n        }\n        let strength\
    \ = (count_cap - count_sm) as f64;\n        if strength >= strongest_strength\
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension.clone();\n        }\n        count_strength.push((strength, extension));\n\
    \    }\n    let string_to_return = format!(\"{}.{}\", class_name, strongest_extension);\n\
    \    string_to_return\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.-_-\"`,\n right: `\"__HAHA.123\"`', /tmp/tmpwqse6gsy.rs:49:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_strength\
    \ = Vec::new();\n    for extension in extensions {\n        let mut strength:\
    \ i32 = 0;\n        for c in extension.chars() {\n            if c.is_ascii_uppercase()\
    \ {\n                strength += 1;\n            } else {\n                strength\
    \ -= 1;\n            }\n        }\n        extension_strength.push((extension,\
    \ strength));\n    }\n    let strongest = extension_strength.iter().max_by_key(|t|\
    \ t.1).unwrap();\n    format!(\"{}.{}\", class_name, strongest.0)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.eMptY\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpq26jjyo4.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = class_name.clone();\n\
    \    let mut max = -2.0;\n    for ext in extensions {\n        let mut strength\
    \ = 0.0;\n        for c in ext.chars() {\n            if c.is_lowercase() {\n\
    \                strength -= 1.0;\n            } else {\n                strength\
    \ += 1.0;\n            }\n        }\n        if strength > max {\n           \
    \ max = strength;\n            strongest = class_name.clone() + \".\" + &ext;\n\
    \        }\n    }\n    strongest\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.123NoooneB321\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpxr3e6iju.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpl52f6mth.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0;\n  \
    \  let mut strongest = \"\";\n    for ext in extensions {\n        let cap = ext.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let small = ext.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let curr_strength = cap - small;\n        if curr_strength > strength\
    \ {\n            strength = curr_strength;\n            strongest = ext.as_str();\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, strongest)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `ext` does not live long enough\n  --> /tmp/tmpzwesz72p.rs:26:25\n\
    \   |\n26 |             strongest = ext.as_str();\n   |                      \
    \   ^^^^^^^^^^^^ borrowed value does not live long enough\n27 |         }\n28\
    \ |     }\n   |     - `ext` dropped here while still borrowed\n29 |     format!(\"\
    {}.{}\", class_name, strongest)\n   |                                  ---------\
    \ borrow later used here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0597`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Returns a tuple with the\
    \ count of uppercase letters and the count of lowercase letters.\n    let case_count\
    \ = |s: &String| {\n        s.chars().fold((0, 0), |mut acc, c| {\n          \
    \  if c.is_ascii_uppercase() {\n                acc.0 += 1;\n            } else\
    \ if c.is_ascii_lowercase() {\n                acc.1 += 1;\n            }\n  \
    \          acc\n        })\n    };\n\n    // Finds the strongest extension, returning\
    \ None if no extension has a\n    // negative strength.\n    let strongest_extension\
    \ = extensions.iter().fold(None, |strongest, ext| {\n        let (cap, sm) = case_count(ext);\n\
    \        let strength = cap as i32 - sm as i32;\n        if strength < 0 {\n \
    \           match strongest {\n                Some((strongest_strength, strongest_index))\
    \ => {\n                    if strength > strongest_strength {\n             \
    \           Some((strength, ext.len()))\n                    } else if strength\
    \ == strongest_strength && ext.len() < strongest_index {\n                   \
    \     Some((strength, ext.len()))\n                    } else {\n            \
    \            Some((strongest_strength, strongest_index))\n                   \
    \ }\n                },\n                None => Some((strength, ext.len()))\n\
    \            }\n        } else {\n            strongest\n        }\n    });\n\n\
    \    match strongest_extension {\n        Some((_, index)) => format!(\"{}.{}\"\
    , class_name, &extensions[index]),\n        None => class_name\n    }\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpwmlz0t8h.rs:61:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = \"\";\n    let mut strongest_extension_strength = 0.0;\n    for extension\
    \ in extensions {\n        let mut lowercase_letters = 0;\n        let mut uppercase_letters\
    \ = 0;\n        for character in extension.chars() {\n            if character.is_lowercase()\
    \ {\n                lowercase_letters += 1;\n            } else if character.is_uppercase()\
    \ {\n                uppercase_letters += 1;\n            }\n        }\n     \
    \   let strength = (uppercase_letters as f64) - (lowercase_letters as f64);\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = strength;\n            strongest_extension_name = &extension;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, strongest_extension_name)\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `extension` does not live long enough\n  --> /tmp/tmprc9dhhkk.rs:33:40\n\
    \   |\n33 |             strongest_extension_name = &extension;\n   |         \
    \                               ^^^^^^^^^^ borrowed value does not live long enough\n\
    34 |         }\n35 |     }\n   |     - `extension` dropped here while still borrowed\n\
    36 |     format!(\"{}.{}\", class_name, strongest_extension_name)\n   |      \
    \                            ------------------------ borrow later used here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0597`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_ext: String\
    \ = String::from(\"\");\n    let mut strongest_ext_power: f64 = -999999999.9;\n\
    \    for ext in extensions {\n        let mut capital_letters = 0;\n        let\
    \ mut small_letters = 0;\n        for c in ext.chars() {\n            if c.is_uppercase()\
    \ {\n                capital_letters += 1;\n            } else if c.is_lowercase()\
    \ {\n                small_letters += 1;\n            }\n        }\n        let\
    \ ext_power = (capital_letters as f64) - (small_letters as f64);\n        if ext_power\
    \ > strongest_ext_power {\n            strongest_ext_power = ext_power;\n    \
    \        strongest_ext = ext;\n        }\n    }\n    let format_class_name = class_name.replace(\"\
    _\", \".\");\n    format!(\"{}.{}\", format_class_name, strongest_ext)\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"..YESIMHERE.NuLl__\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmphcirn0cm.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = String::new();\n    let mut strongest_extension_strength = 0.0;\n    for extension\
    \ in extensions {\n        let mut caps_count = 0;\n        let mut smalls_count\
    \ = 0;\n        for c in extension.chars() {\n            if c.is_uppercase()\
    \ {\n                caps_count += 1;\n            } else if c.is_lowercase()\
    \ {\n                smalls_count += 1;\n            }\n        }\n        let\
    \ extension_strength = caps_count as f64 - smalls_count as f64;\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength;\n            strongest_extension_name = extension;\n   \
    \     }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension_name)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpf80qlwy6.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // create a vector to store\
    \ the strength of all extensions\n    let mut strength_list: Vec<f64> = Vec::new();\n\
    \    for extension in extensions {\n        let mut caps = 0;\n        let mut\
    \ sms = 0;\n        for x in extension.chars() {\n            if x.is_uppercase()\
    \ { caps += 1; }\n            else { sms += 1; }\n        }\n        strength_list.push(caps\
    \ as f64 - sms as f64);\n    }\n    let max_strength = strength_list.iter().max();\n\
    \    let index = strength_list.iter().position(|&x| x == *max_strength.unwrap()).unwrap();\n\
    \    let class_name_string = String::from(class_name);\n    format!(\"{}.{}\"\
    , class_name_string, extensions[index])\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"\
    tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"\
    Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpu5ee43_q.rs:29:45\n\
    \     |\n29   |     let max_strength = strength_list.iter().max();\n     |   \
    \                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strength = 0;\n    for extension in extensions\
    \ {\n        let cap_vec: Vec<char> = extension.chars().filter(|c| c.is_uppercase()).collect();\n\
    \        let small_vec: Vec<char> = extension.chars().filter(|c| c.is_lowercase()).collect();\n\
    \        let cap = cap_vec.len();\n        let small = small_vec.len();\n    \
    \    let ext_strength = cap - small;\n        if ext_strength > strength {\n \
    \           strength = ext_strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp_z811fae.rs:25:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_ind:\
    \ usize = 0;\n    let mut strongest_extension_strength: i32 = 0;\n    for i in\
    \ 0..extensions.len() {\n        let ext = &extensions[i];\n        let strength\
    \ = Letter_Strength(ext);\n        if strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = strength;\n            strongest_extension_ind\
    \ = i;\n        }\n    }\n    return format!(\"{}.{}\", class_name, extensions[strongest_extension_ind]);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Letter_Strength`\
    \ in this scope\n  --> /tmp/tmpgas4ocd_.rs:22:24\n   |\n22 |         let strength\
    \ = Letter_Strength(ext);\n   |                        ^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let (min_diff, min_index)\
    \ = extensions.iter().enumerate().map(|(i, extension)| {\n        let mut small_letter_count\
    \ = 0;\n        let mut cap_letter_count = 0;\n        for ch in extension.chars()\
    \ {\n            if ch.is_uppercase() {\n                cap_letter_count += 1;\n\
    \            } else {\n                small_letter_count += 1;\n            }\n\
    \        }\n        (cap_letter_count - small_letter_count, i)\n    }).min().unwrap();\n\
    \    let extension = extensions[min_index].to_string();\n    format!(\"{}.{}\"\
    , class_name, extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.niNE\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpb4wqxq1n.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\";\n    let mut strength: f64 = 0.0;\n    for extension in extensions {\n\
    \        let mut upper_count = 0;\n        let mut lower_count = 0;\n        for\
    \ letter in extension.chars() {\n            if letter.is_ascii_uppercase() {\n\
    \                upper_count += 1;\n            } else if letter.is_ascii_lowercase()\
    \ {\n                lower_count += 1;\n            }\n        }\n        let\
    \ extension_strength = upper_count as f64 - lower_count as f64;\n        if extension_strength\
    \ > strength {\n            strength = extension_strength;\n            strongest_extension\
    \ = &extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `extension` does not live long enough\n  --> /tmp/tmppjs0amxp.rs:33:35\n\
    \   |\n33 |             strongest_extension = &extension;\n   |              \
    \                     ^^^^^^^^^^ borrowed value does not live long enough\n34\
    \ |         }\n35 |     }\n   |     - `extension` dropped here while still borrowed\n\
    36 |     format!(\"{}.{}\", class_name, strongest_extension)\n   |           \
    \                       ------------------- borrow later used here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0597`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = f64::MIN;\n\
    \    let mut name = String::new();\n    for ext in extensions {\n        let caps\
    \ = ext.chars().filter(|&x| x.is_uppercase()).count();\n        let sm = ext.chars().filter(|&x|\
    \ x.is_lowercase()).count();\n        let s = (caps as f64) - (sm as f64);\n \
    \       if s > strength {\n            strength = s;\n            name = ext;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, name)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = \"\".to_string();\n    let mut strongest_extension_strength = 0.0;\n    for\
    \ extension in extensions {\n        let (uppercase_letters, lowercase_letters)\
    \ = get_num_letters(extension);\n        let strength = ((uppercase_letters as\
    \ f64) - (lowercase_letters as f64)) / ((uppercase_letters + lowercase_letters)\
    \ as f64);\n        if strength > strongest_extension_strength {\n           \
    \ strongest_extension_name = extension;\n            strongest_extension_strength\
    \ = strength;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension_name)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_num_letters` in this scope\n  -->\
    \ /tmp/tmpxdb_qcui.rs:21:54\n   |\n21 |         let (uppercase_letters, lowercase_letters)\
    \ = get_num_letters(extension);\n   |                                        \
    \              ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Write code here\n    String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp1skoq9pj.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = None;\n\
    \    let mut max_strength = std::f64::NEG_INFINITY;\n    for x in extensions {\n\
    \        let caps = x.chars().filter(|y| y.is_uppercase()).count();\n        let\
    \ smals = x.chars().filter(|y| y.is_lowercase()).count();\n        let strength\
    \ = caps as f64 - smals as f64;\n        if strength > max_strength {\n      \
    \      max_strength = strength;\n            strongest = Some(x);\n        }\n\
    \    }\n    if let Some(x) = strongest {\n        return format!(\"{}.{}\", class_name,\
    \ x);\n    }\n    else {\n        return class_name;\n    }\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = String::new();\n\
    \    let mut max_strength = -9999999999;\n    for ex in extensions {\n       \
    \ let num_uppercase = ex.chars().filter(|c| c.is_uppercase()).count();\n     \
    \   let num_lowercase = ex.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = num_uppercase - num_lowercase;\n        if strength > max_strength\
    \ {\n            max_strength = strength;\n            strongest = ex;\n     \
    \   }\n    }\n    format!(\"{}.{}\", class_name, strongest)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpn_lr1ark.rs:19:28\n\
    \   |\n19 |     let mut max_strength = -9999999999;\n   |                    \
    \        ^^^^^^^^^^^ the trait `Neg` is not implemented for `usize`\n   |\n  \
    \ = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut r = String::from(class_name);\n\
    \    r.push('.');\n    if extensions.len() > 0 {\n        let mut res = &extensions[0];\n\
    \        let mut max = -1;\n        for i in 0..extensions.len() {\n         \
    \   let mut up = 0;\n            let mut lo = 0;\n            for c in extensions[i].chars()\
    \ {\n                if c.is_ascii_uppercase() {\n                    up += 1;\n\
    \                } else {\n                    lo += 1;\n                }\n \
    \           }\n            if up - lo > max {\n                max = up - lo;\n\
    \                res = &extensions[i];\n            }\n        }\n        r.push_str(res);\n\
    \    }\n    r\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpfwbtlcsa.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n\t// get the strongest extension\n\
    \tlet mut strongest_extension = String::new();\n\tlet mut max_strength = -1.0;\n\
    \tfor extension in extensions {\n\t\tlet strength = get_strength(extension);\n\
    \t\tif strength > max_strength {\n\t\t\tmax_strength = strength;\n\t\t\tstrongest_extension\
    \ = extension;\n\t\t}\n\t}\n\treturn format!(\"{}.{}\", class_name, strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_strength` in this scope\n  -->\
    \ /tmp/tmpi4utz9lw.rs:22:18\n   |\n22 |         let strength = get_strength(extension);\n\
    \   |                        ^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `max_strength`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_extension_strength = 0;\n    for ext\
    \ in extensions {\n        let mut caps = 0;\n        let mut smalls = 0;\n  \
    \      for c in ext.chars() {\n            if c.is_ascii_uppercase() {\n     \
    \           caps += 1;\n            } else {\n                smalls += 1;\n \
    \           }\n        }\n        let strength = caps - smalls;\n        if strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ strength;\n            strongest_extension = ext;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp6hcmdpkv.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // if there are no extensions,\
    \ just return the class name\n    if extensions.len() == 0 {\n        return class_name;\n\
    \    }\n    // get the strength of the strongest extension\n    let mut best_strength\
    \ = get_strength(&extensions[0]);\n    // track the index of the strongest extension\n\
    \    let mut best_index = 0;\n    // loop through all the extensions and get the\
    \ strongest one\n    for (i, ext) in extensions.iter().enumerate() {\n       \
    \ // get the strength of the current extension\n        let curr_strength = get_strength(ext);\n\
    \        // if the current extension has a better strength, update the best strength\
    \ and index\n        if curr_strength > best_strength {\n            best_strength\
    \ = curr_strength;\n            best_index = i;\n        }\n    }\n    // return\
    \ the best extension\n    format!(\"{}.{}\", class_name, extensions[best_index])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_strength` in this scope\n  -->\
    \ /tmp/tmpjjpm74rp.rs:23:29\n   |\n23 |     let mut best_strength = get_strength(&extensions[0]);\n\
    \   |                             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_strength` in this scope\n  --> /tmp/tmpjjpm74rp.rs:29:29\n\
    \   |\n29 |         let curr_strength = get_strength(ext);\n   |             \
    \                ^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `best_strength`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0.0;\n\
    \    let mut extension = String::new();\n    for ext in extensions {\n       \
    \ let ext_strength = ext.chars().filter(|x| *x >= 'A' && *x <= 'Z').count() as\
    \ f64 - ext.chars().filter(|x| *x >= 'a' && *x <= 'z').count() as f64;\n     \
    \   if ext_strength > strength {\n            strength = ext_strength;\n     \
    \       extension = ext;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmp8nhews52.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = String::new();\n    let mut max_strength = 0.0;\n    for extension in extensions\
    \ {\n        let caps = extension.matches(char::is_uppercase).count();\n     \
    \   let smalls = extension.matches(char::is_lowercase).count();\n        let strength\
    \ = (caps as f64 - smalls as f64) / extension.len() as f64;\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n            strongest_extension_name\
    \ = extension;\n        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension_name);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpykakz91y.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        return class_name;\n    }\n    let mut max_strength = 0.0;\n    let mut\
    \ max_extension = \"\";\n    for extension in extensions {\n        let mut strength\
    \ = 0.0;\n        for letter in extension.chars() {\n            if letter.is_uppercase()\
    \ {\n                strength += 1.0;\n            } else {\n                strength\
    \ -= 1.0;\n            }\n        }\n        if strength > max_strength {\n  \
    \          max_strength = strength;\n            max_extension = extension.as_str();\n\
    \        }\n    }\n    let mut output = class_name;\n    output.push('.');\n \
    \   output.push_str(max_extension);\n    output\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `extension` does not live long enough\n  --> /tmp/tmprqg4sw1y.rs:34:29\n\
    \   |\n34 |             max_extension = extension.as_str();\n   |            \
    \                 ^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n\
    35 |         }\n36 |     }\n   |     - `extension` dropped here while still borrowed\n\
    ...\n39 |     output.push_str(max_extension);\n   |                     -------------\
    \ borrow later used here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0597`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = Vec::new();\n\
    \    let mut strength: f64 = 0.0;\n    for ex in extensions {\n        let mut\
    \ sum_up = 0;\n        let mut sum_low = 0;\n        for ch in ex.chars() {\n\
    \            if ch.is_uppercase() {\n                sum_up += 1;\n          \
    \  } else {\n                sum_low += 1;\n            }\n        }\n       \
    \ let temp = sum_up as f64 - sum_low as f64;\n        if temp > strength {\n \
    \           strength = temp;\n            strongest.clear();\n            strongest.push(ex);\n\
    \        } else if temp == strength {\n            strongest.push(ex);\n     \
    \   }\n    }\n    format!(\"{}.{}\", class_name, strongest[0])\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpr887h5qo.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strengths: Vec<i32>\
    \ = Vec::new();\n    for x in extensions {\n        let mut caps: i32 = 0;\n \
    \       let mut smalls: i32 = 0;\n        for c in x.chars() {\n            if\
    \ c.is_uppercase() {\n                caps += 1;\n            } else {\n     \
    \           smalls += 1;\n            }\n        }\n        strengths.push(caps\
    \ - smalls);\n    }\n    let mut max_index: usize = 0;\n    let mut max_value:\
    \ i32 = strengths[0];\n    for i in 1..strengths.len() {\n        if strengths[i]\
    \ > max_value {\n            max_index = i;\n            max_value = strengths[i];\n\
    \        }\n    }\n    return format!(\"{}.{}\", class_name, extensions[max_index]);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `extensions`\n   --> /tmp/tmpxkhye77f.rs:39:41\n\
    \    |\n17  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                            ---------- move\
    \ occurs because `extensions` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n18  |     let mut strengths: Vec<i32> = Vec::new();\n19  |\
    \     for x in extensions {\n    |              ---------- `extensions` moved\
    \ due to this implicit call to `.into_iter()`\n...\n39  |     return format!(\"\
    {}.{}\", class_name, extensions[max_index]);\n    |                          \
    \               ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `extensions`\nhelp: consider\
    \ iterating over a slice of the `Vec<String>`'s content to avoid moving into the\
    \ `for` loop\n    |\n19  |     for x in &extensions {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + & extensions.iter().map(|x|\
    \ (x.chars().filter(|x| x.is_uppercase()).count() - x.chars().filter(|x| x.is_lowercase()).count(),\
    \ x)).max().unwrap().1\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgvsuwo47.rs:18:53

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // split the extensions into\
    \ their individual components by their upper and lower case letters\n    let mut\
    \ up_down_split: Vec<(String, String)> = vec![];\n    for extension in extensions\
    \ {\n        let x = extension.split(|c| c.is_uppercase()).map(|s| s.to_string()).collect::<Vec<String>>();\n\
    \        let y = extension.split(|c| c.is_lowercase()).map(|s| s.to_string()).collect::<Vec<String>>();\n\
    \        up_down_split.push((x.join(\"\"), y.join(\"\")));\n    }\n    // find\
    \ the extension with the strongest strength\n    let strongest = extensions.iter().enumerate().fold((0,\
    \ 0.0), |(prev_idx, prev_str), (curr_idx, curr_str)| {\n        let cap = (curr_str.chars().filter(|c|\
    \ c.is_uppercase()).count() as f64);\n        let sm = (curr_str.chars().filter(|c|\
    \ c.is_lowercase()).count() as f64);\n        let str_frac = cap/sm;\n       \
    \ if str_frac > prev_str { (curr_idx, str_frac) } else { (prev_idx, prev_str)\
    \ }\n    });\n    format!(\"{}.{}\", class_name, extensions[strongest.0])\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp1law2em4.rs:27:19\n\
    \   |\n27 |         let cap = (curr_str.chars().filter(|c| c.is_uppercase()).count()\
    \ as f64);\n   |                   ^                                         \
    \                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n27 -         let cap = (curr_str.chars().filter(|c|\
    \ c.is_uppercase()).count() as f64);\n27 +         let cap = curr_str.chars().filter(|c|\
    \ c.is_uppercase()).count() as f64;\n   | \n\nwarning: unnecessary parentheses\
    \ around assigned value\n  --> /tmp/tmp1law2em4.rs:28:18\n   |\n28 |         let\
    \ sm = (curr_str.chars().filter(|c| c.is_lowercase()).count() as f64);\n   | \
    \                 ^                                                          \
    \  ^\n   |\nhelp: remove these parentheses\n   |\n28 -         let sm = (curr_str.chars().filter(|c|\
    \ c.is_lowercase()).count() as f64);\n28 +         let sm = curr_str.chars().filter(|c|\
    \ c.is_lowercase()).count() as f64;\n   | \n\nerror[E0282]: type annotations needed\n\
    \  --> /tmp/tmp1law2em4.rs:21:34\n   |\n21 |         let x = extension.split(|c|\
    \ c.is_uppercase()).map(|s| s.to_string()).collect::<Vec<String>>();\n   |   \
    \                               ^ consider giving this closure parameter a type\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error; 2 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = &String::from(\"\");\n    let mut highest_strength = 0.0;\n    for extension\
    \ in extensions {\n        let mut caps = 0;\n        let mut smalls = 0;\n  \
    \      for c in extension.chars() {\n            if c.is_uppercase() {\n     \
    \           caps += 1;\n            } else {\n                smalls += 1;\n \
    \           }\n        }\n        let strength = (caps as f64) - (smalls as f64);\n\
    \        if strength > highest_strength {\n            highest_strength = strength;\n\
    \            strongest_extension = &extension;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `extension` does not live long enough\n  --> /tmp/tmp68xsvfbv.rs:33:35\n\
    \   |\n33 |             strongest_extension = &extension;\n   |              \
    \                     ^^^^^^^^^^ borrowed value does not live long enough\n34\
    \ |         }\n35 |     }\n   |     - `extension` dropped here while still borrowed\n\
    36 |     format!(\"{}.{}\", class_name, strongest_extension)\n   |           \
    \                       ------------------- borrow later used here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0597`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut class_ext = String::from(\"\
    \");\n    let mut strongest_ext_strength = std::f64::NEG_INFINITY;\n    for extension\
    \ in extensions {\n        let cap_count = extension.matches(char::is_uppercase).count();\n\
    \        let small_count = extension.matches(char::is_lowercase).count();\n  \
    \      let curr_ext_strength = (cap_count - small_count) as f64;\n        if curr_ext_strength\
    \ > strongest_ext_strength {\n            strongest_ext_strength = curr_ext_strength;\n\
    \            class_ext = format!(\"{}.{}\", class_name, extension);\n        }\n\
    \    }\n    class_ext\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmphgvh74es.rs:23:33

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result = \"\".to_string();\n\
    \    let mut strength = 0;\n    for ext in extensions {\n        let cap = ext.clone().chars().filter(|x|\
    \ x.is_uppercase()).count();\n        let small = ext.clone().chars().filter(|x|\
    \ x.is_lowercase()).count();\n        let current_strength = cap - small;\n  \
    \      if current_strength > strength {\n            strength = current_strength;\n\
    \            result = ext.clone();\n        }\n    }\n    class_name + \".\" +\
    \ &result\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpd26wghdr.rs:23:32

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1.0;\n\
    \    let mut name = String::from(\"\");\n    for n in &extensions {\n        let\
    \ mut caps = 0;\n        let mut sm = 0;\n        for c in n.chars() {\n     \
    \       if c.is_uppercase() {\n                caps += 1;\n            } else\
    \ {\n                sm += 1;\n            }\n        }\n        let ext_strength\
    \ = caps as f64 - sm as f64;\n        if ext_strength > strength {\n         \
    \   strength = ext_strength;\n            name = n.clone();\n        }\n    }\n\
    \    let mut s = String::from(class_name);\n    s.push('.');\n    s.push_str(&name);\n\
    \    s\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpo_k8lo0o.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut caps = 0;\n    let\
    \ mut smalls = 0;\n    let mut extension_name = String::new();\n    let mut strongest_extension\
    \ = String::new();\n    let mut strength = 0;\n    let mut strongest_strength\
    \ = 0;\n    for e in extensions {\n        caps = 0;\n        smalls = 0;\n  \
    \      for c in e.chars() {\n            if c.is_uppercase() {\n             \
    \   caps += 1;\n            } else {\n                smalls += 1;\n         \
    \   }\n        }\n        strength = caps - smalls;\n        if strength > strongest_strength\
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = e;\n        }\n    }\n    extension_name = class_name + \".\" + &strongest_extension;\n\
    \    extension_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp50rnbfls.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Initialize the strongest\
    \ extension (se) with a strength of 0.\n    let mut se = String::from(\"\");\n\
    \    let mut strength = 0;\n    // Iterate through the vector of extensions.\n\
    \    for extension in extensions {\n        // Count the number of lowercase letters.\n\
    \        let mut lc_count = 0;\n        // Iterate through the extension.\n  \
    \      for c in extension.chars() {\n            // If the character is lowercase,\
    \ increment the counter.\n            if c.is_lowercase() {\n                lc_count\
    \ += 1;\n            }\n        }\n        // Count the number of uppercase letters.\n\
    \        let mut uc_count = 0;\n        // Iterate through the extension.\n  \
    \      for c in extension.chars() {\n            // If the character is uppercase,\
    \ increment the counter.\n            if c.is_uppercase() {\n                uc_count\
    \ += 1;\n            }\n        }\n        // Calculate the strength of the extension.\n\
    \        let st = uc_count - lc_count;\n        // If the strength is greater\
    \ than the current strength, set\n        // the extension to the current extension\
    \ and set the strength to\n        // the current strength.\n        if st > strength\
    \ {\n            se = extension;\n            strength = st;\n        }\n    }\n\
    \    // Return the class name and the strongest extension.\n    format!(\"{}.{}\"\
    , class_name, se)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmp2ddq7zno.rs:59:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let class_name_clone = class_name.clone();\n\
    \    let mut exts = extensions;\n    exts.sort_by(|a, b| {\n        match a.chars().filter(|x|\
    \ x.is_uppercase()).count().cmp(&b.chars().filter(|x| x.is_uppercase()).count())\
    \ {\n            std::cmp::Ordering::Equal => a.chars().filter(|x| x.is_lowercase()).count().cmp(&b.chars().filter(|x|\
    \ x.is_lowercase()).count()),\n            std::cmp::Ordering::Less => std::cmp::Ordering::Greater,\n\
    \            std::cmp::Ordering::Greater => std::cmp::Ordering::Less,\n      \
    \  }\n    });\n    class_name_clone + \".\" + &exts[0]\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.Tab\"`,\n right: `\"__HAHA.123\"`', /tmp/tmprdd24fpj.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n\tlet mut strongest_extension\
    \ = String::new();\n\tlet mut strongest_strength = 0.0;\n\tfor extension in extensions\
    \ {\n\t\tlet strength = extension.chars().filter(|c| c.is_ascii_uppercase()).count()\
    \ as f64 - extension.chars().filter(|c| c.is_ascii_lowercase()).count() as f64;\n\
    \t\tif strength > strongest_strength {\n\t\t\tstrongest_strength = strength;\n\
    \t\t\tstrongest_extension = extension;\n\t\t}\n\t}\n\tformat!(\"{}.{}\", class_name,\
    \ strongest_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpf_i3q2j7.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = String::new();\n    let mut strongest_extension_strength = 0.0;\n    for extension\
    \ in extensions {\n        let uppercase_letters = extension.chars().filter(|&x|\
    \ x.is_uppercase()).count();\n        let lowercase_letters = extension.chars().filter(|&x|\
    \ x.is_lowercase()).count();\n        let strength = uppercase_letters as f64\
    \ - lowercase_letters as f64;\n        if strength >= strongest_extension_strength\
    \ {\n            strongest_extension_name = extension;\n            strongest_extension_strength\
    \ = strength;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension_name)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.-_-\"`,\n right: `\"__HAHA.123\"`', /tmp/tmpkhqoh411.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // We will make sure to start\
    \ with the smallest strength and\n    // check if there is an extension with a\
    \ larger strength.\n    let mut strongest_str: f64 = 0.0;\n    let mut class_and_extension\
    \ = class_name;\n    for extension in extensions {\n        let extension_strength\
    \ = calculate_strength(&extension);\n        if extension_strength > strongest_str\
    \ {\n            class_and_extension = format!(\"{}.{}\", class_name, extension);\n\
    \            strongest_str = extension_strength;\n        }\n    }\n    class_and_extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `calculate_strength` in this scope\n\
    \  --> /tmp/tmpqry3bhme.rs:23:34\n   |\n23 |         let extension_strength =\
    \ calculate_strength(&extension);\n   |                                  ^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpl52f6mth.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976360
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut highest_strength = -1.0;\n    for ext in extensions\
    \ {\n        let strength = ext.chars().filter(|&c| c.is_uppercase()).count()\
    \ as f64 - ext.chars().filter(|&c| c.is_lowercase()).count() as f64;\n       \
    \ if strength >= highest_strength {\n            highest_strength = strength;\n\
    \            strongest_extension = ext;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.-_-\"`,\n right: `\"__HAHA.123\"`', /tmp/tmpj1k9487r.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code here\n    let\
    \ mut strongest_extension = \"\".to_string();\n    let mut max_strength = 0.0;\n\
    \    for i in extensions {\n        let cap = i.chars().filter(|&x| x.is_uppercase()).count();\n\
    \        let sm = i.chars().filter(|&x| x.is_lowercase()).count();\n        let\
    \ strength = ((cap as f64) - (sm as f64)) / (i.len() as f64);\n        if max_strength\
    \ < strength {\n            max_strength = strength;\n            strongest_extension\
    \ = i;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpwn5qrvca.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut highest_strength = std::f64::MIN;\n    for extension\
    \ in extensions {\n        let strength = extension.chars().filter(|&x| x.is_uppercase()).count()\
    \ as f64 - extension.chars().filter(|&x| x.is_lowercase()).count() as f64;\n \
    \       if strength > highest_strength {\n            highest_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut selected_extension:\
    \ String = class_name.clone();\n    let mut max_cap_sm: i32 = 0;\n    for extension\
    \ in extensions {\n        let mut cap: i32 = 0;\n        let mut sm: i32 = 0;\n\
    \        for character in extension.chars() {\n            if character.is_uppercase()\
    \ {\n                cap += 1;\n            } else {\n                sm += 1;\n\
    \            }\n        }\n        if (cap - sm) > max_cap_sm {\n            max_cap_sm\
    \ = cap - sm;\n            selected_extension = class_name.clone() + \".\" + &extension;\n\
    \        }\n    }\n    selected_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp0f049h4s.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension_name\
    \ = String::new();\n    let mut strongest_extension_strength = -1.0;\n    for\
    \ extension in extensions {\n        let mut cap = 0.0;\n        let mut sm =\
    \ 0.0;\n        for c in extension.chars() {\n            if c.is_uppercase()\
    \ {\n                cap += 1.0;\n            } else if c.is_lowercase() {\n \
    \               sm += 1.0;\n            }\n        }\n        let strength = cap\
    \ - sm;\n        if strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = strength;\n            strongest_extension_name = extension;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, strongest_extension_name)\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let extension_strength = |extension:\
    \ &String| -> f64 {\n        let mut upper_case = 0;\n        let mut lower_case\
    \ = 0;\n        for c in extension.chars() {\n            if c.is_uppercase()\
    \ {\n                upper_case += 1;\n            } else if c.is_lowercase()\
    \ {\n                lower_case += 1;\n            }\n        }\n        (upper_case\
    \ - lower_case) as f64\n    };\n    let mut max_strength = std::f64::NEG_INFINITY;\n\
    \    let mut strongest_extension = String::new();\n    for extension in extensions\
    \ {\n        let strength = extension_strength(&extension);\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = None;\n    let mut strongest_extension_strength = 0.0;\n    for ext in extensions\
    \ {\n        let extension_strength = get_extension_strength(&ext);\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = Some(ext);\n            strongest_extension_strength = extension_strength;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension.unwrap())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_extension_strength` in this scope\n\
    \  --> /tmp/tmpowvynr_2.rs:21:34\n   |\n21 |         let extension_strength =\
    \ get_extension_strength(&ext);\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `strongest_extension_strength`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = (0.0,\
    \ String::from(\"\"));\n    for s in extensions {\n        let (uc, lc) = count_letters(&s);\n\
    \        let strength = uc as f64 - lc as f64;\n        if strength > strongest.0\
    \ {\n            strongest = (strength, s);\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest.1)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_letters` in this scope\n  -->\
    \ /tmp/tmpbhmds_7a.rs:20:24\n   |\n20 |         let (uc, lc) = count_letters(&s);\n\
    \   |                        ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976361
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut power: Vec<(String,\
    \ i8)> = Vec::new();\n    for i in extensions {\n        let str_len = i.len();\n\
    \        let mut cap = 0;\n        let mut sm = 0;\n        for ch in i.chars()\
    \ {\n            if ch.is_uppercase() {\n                cap += 1;\n         \
    \   } else {\n                sm += 1;\n            }\n        }\n        power.push((i,\
    \ (cap - sm) as i8));\n    }\n    let mut pw = (String::from(\"\"), 0);\n    for\
    \ i in power {\n        if i.1 > pw.1 {\n            pw = i;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, pw.0)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp2l_ss_j2.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_extension_strength = std::f64::NEG_INFINITY;\n\
    \    for extension in extensions {\n        let strength = get_strength(extension);\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_strength` in this scope\n  -->\
    \ /tmp/tmp8f6gyr6f.rs:21:24\n   |\n21 |         let strength = get_strength(extension);\n\
    \   |                        ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut exts = extensions;\n\
    \    let mut strengths = exts.iter().map(|e| e.chars().filter(|c| c.is_uppercase()).count()\
    \ as i32 - e.chars().filter(|c| c.is_lowercase()).count() as i32).collect::<Vec<i32>>();\n\
    \    exts.sort_by(|a, b| strengths[extensions.iter().position(|e| e == a).unwrap()].cmp(&strengths[extensions.iter().position(|e|\
    \ e == b).unwrap()]));\n    let strongest_ext = exts.last().unwrap();\n    class_name\
    \ + \".\" + strongest_ext\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp15xv1mun.rs:19:9\n\
    \   |\n19 |     let mut strengths = exts.iter().map(|e| e.chars().filter(|c| c.is_uppercase()).count()\
    \ as i32 - e.chars().filter(|c| c.is_lowercase()...\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `extensions`\n  --> /tmp/tmp15xv1mun.rs:20:18\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                            ---------- move\
    \ occurs because `extensions` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n18 |     let mut exts = extensions;\n   |                \
    \    ---------- value moved here\n19 |     let mut strengths = exts.iter().map(|e|\
    \ e.chars().filter(|c| c.is_uppercase()).count() as i32 - e.chars().filter(|c|\
    \ c.is_lowercase()...\n20 |     exts.sort_by(|a, b| strengths[extensions.iter().position(|e|\
    \ e == a).unwrap()].cmp(&strengths[extensions.iter().position(|e| e == b)....\n\
    \   |                  ^^^^^^           ---------- borrow occurs due to use in\
    \ closure\n   |                  |\n   |                  value borrowed here\
    \ after move\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut class_name_clone =\
    \ class_name.clone();\n    class_name_clone.push_str(\".\");\n    let mut strongest_extension\
    \ = String::from(\"\");\n    let mut strongest_extension_strength = 0.0;\n   \
    \ for extension in extensions {\n        let mut strength = 0.0;\n        for\
    \ char in extension.chars() {\n            if char.is_uppercase() {\n        \
    \        strength += 1.0;\n            } else {\n                strength -= 1.0;\n\
    \            }\n        }\n        if strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    class_name_clone.push_str(&strongest_extension);\n\
    \    class_name_clone\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpcpwf0mds.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0;\n  \
    \  let mut strongest = String::new();\n    for ext in extensions {\n        let\
    \ mut cap = 0;\n        let mut sm = 0;\n        for c in ext.chars() {\n    \
    \        if c.is_uppercase() {\n                cap += 1;\n            } else\
    \ {\n                sm += 1;\n            }\n        }\n        let cur_strength\
    \ = cap - sm;\n        if cur_strength > strength {\n            strength = cur_strength;\n\
    \            strongest = ext;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ strongest)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp93q74oc2.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    use std::cmp::{max, min};\n\
    \    extensions.iter().fold(\n        (class_name.clone(), 0, 0),\n        |(class_name,\
    \ _, _), s| {\n            let mut upper_case = 0;\n            let mut lower_case\
    \ = 0;\n            for i in s.chars() {\n                match i {\n        \
    \            'A'..='Z' => upper_case += 1,\n                    'a'..='z' => lower_case\
    \ += 1,\n                    _ => continue,\n                }\n            }\n\
    \            let strength = upper_case - lower_case;\n            if strength\
    \ >= 0 {\n                let old_strength = min(upper_case, lower_case);\n  \
    \              if strength > old_strength {\n                    (format!(\"{}.{}\"\
    , class_name, s), strength, lower_case)\n                } else if strength ==\
    \ old_strength {\n                    if lower_case < old_strength {\n       \
    \                 (format!(\"{}.{}\", class_name, s), strength, lower_case)\n\
    \                    } else {\n                        (class_name, strength,\
    \ lower_case)\n                    }\n                } else {\n             \
    \       (class_name, strength, lower_case)\n                }\n            } else\
    \ {\n                let old_strength = max(upper_case, lower_case);\n       \
    \         if strength < old_strength {\n                    (format!(\"{}.{}\"\
    , class_name, s), strength, lower_case)\n                } else if strength ==\
    \ old_strength {\n                    if lower_case < old_strength {\n       \
    \                 (format!(\"{}.{}\", class_name, s), strength, lower_case)\n\
    \                    } else {\n                        (class_name, strength,\
    \ lower_case)\n                    }\n                } else {\n             \
    \       (class_name, strength, lower_case)\n                }\n            }\n\
    \        },\n    )\n    .0\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpklad5u4p.rs:66:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strength = 0;\n    for extension in extensions\
    \ {\n        let (upper, lower) = extension.chars().fold((0, 0), |mut acc, c|\
    \ {\n            if c.is_uppercase() {\n                acc.0 += 1;\n        \
    \    } else if c.is_lowercase() {\n                acc.1 += 1;\n            }\n\
    \            acc\n        });\n        let curr_strength = upper - lower;\n  \
    \      if strength == 0 || curr_strength > strength {\n            strength =\
    \ curr_strength;\n            strongest_extension = extension;\n        }\n  \
    \  }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.123NoooneB321\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpjtza92x5.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Get the strongest extension\n\
    \    let (strongest_extension, _) = extensions.iter().map(|e| {\n        // Compute\
    \ the strength of the extension\n        let strength = e.chars().fold((0, 0),\
    \ |(cap, sm), c| {\n            match c {\n                'A'...'Z' => (cap +\
    \ 1, sm),\n                'a'...'z' => (cap, sm + 1),\n                _ => (cap,\
    \ sm),\n            }\n        });\n        // Save the extension and its strength\n\
    \        (e, strength)\n    }).fold((String::new(), (0, 0)), |(strongest_extension,\
    \ (cap, sm)), (e, (cur_cap, cur_sm))| {\n        if cur_cap - cur_sm > cap - sm\
    \ {\n            (e.clone(), (cur_cap, cur_sm))\n        } else {\n          \
    \  (strongest_extension, (cap, sm))\n        }\n    });\n    // Return the strongest\
    \ extension\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpp7xw_64l.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = (0.0f64,\
    \ String::from(\"\"));\n    for ext in extensions {\n        let mut caps = 0;\n\
    \        let mut smalls = 0;\n        for ch in ext.chars() {\n            if\
    \ ch.is_uppercase() {\n                caps += 1;\n            } else {\n    \
    \            smalls += 1;\n            }\n        }\n        let strength = (caps\
    \ as f64) - (smalls as f64);\n        if strength > strongest.0 {\n          \
    \  strongest = (strength, ext);\n        }\n    }\n    return class_name + \"\
    .\" + &strongest.1;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpx9778my5.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strength = std::f64::MIN;\n    for extension in\
    \ extensions {\n        let (mut capital_count, mut small_count) = (0, 0);\n \
    \       for c in extension.chars() {\n            if c.is_ascii_uppercase() {\n\
    \                capital_count += 1;\n            } else if c.is_ascii_lowercase()\
    \ {\n                small_count += 1;\n            }\n        }\n        let\
    \ s = capital_count as f64 - small_count as f64;\n        if s > strength {\n\
    \            strength = s;\n            strongest_extension = extension;\n   \
    \     }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut res = String::from(class_name);\n\
    \    let mut strongest_ext = String::from(\"\");\n    let mut strength = 0;\n\
    \    for ext in extensions {\n        let (current_strength, _) = comp_strength(&ext);\n\
    \        if current_strength > strength {\n            strength = current_strength;\n\
    \            strongest_ext = ext;\n        }\n    }\n    res.push('.');\n    res.push_str(&strongest_ext);\n\
    \    res\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `comp_strength` in this scope\n  -->\
    \ /tmp/tmpeqrldugz.rs:22:37\n   |\n22 |         let (current_strength, _) = comp_strength(&ext);\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + &extensions.iter().max_by_key(|ext|\
    \ ext.chars().filter(|c| c.is_uppercase()).count() - ext.chars().filter(|c| c.is_lowercase()).count()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp5kdn9cpf.rs:18:60

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = (0,0,String::from(\"\
    \"));\n    for i in 0..extensions.len() {\n        let s = extensions[i].clone();\n\
    \        let count_caps = s.chars().filter(|x| x.is_uppercase()).count();\n  \
    \      let count_smalls = s.chars().filter(|x| x.is_lowercase()).count();\n  \
    \      let curr_strength = (count_caps as i32) - (count_smalls as i32);\n    \
    \    if curr_strength > strongest.0 {\n            strongest = (curr_strength,\
    \ i, s);\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest.2)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmp7dwhxmt9.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + extensions.iter().max_by_key(|x|\
    \ \n        x.chars().filter(|&c| c.is_uppercase()).count() as i32 - \n      \
    \  x.chars().filter(|&c| c.is_lowercase()).count() as i32\n    ).unwrap()\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__HAHA.-_-\"`,\n right: `\"__HAHA.123\"`', /tmp/tmphw99xk5o.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strong_ext = String::new();\n\
    \    let mut max_strength = 0;\n    for i in 0..extensions.len() {\n        let\
    \ mut caps = 0;\n        let mut lower = 0;\n        for j in 0..extensions[i].len()\
    \ {\n            let ch = extensions[i].chars().nth(j).unwrap();\n           \
    \ if ch.is_ascii_uppercase() {\n                caps += 1;\n            } else\
    \ {\n                lower += 1;\n            }\n        }\n        let strength\
    \ = caps - lower;\n        if strength > max_strength {\n            max_strength\
    \ = strength;\n            strong_ext = extensions[i].clone();\n        }\n  \
    \  }\n    format!(\"{}.{}\", class_name, strong_ext)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpgf96jgvi.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = \"\";\n    let mut strength = 0;\n    for extension in extensions {\n    \
    \    let extension_strength = extension.chars().fold((0, 0), |(cap, sm), ch|\n\
    \            match ch {\n                'A'...'Z' => (cap + 1, sm),\n       \
    \         'a'...'z' => (cap, sm + 1),\n                _ => (cap, sm),\n     \
    \       }\n        );\n        if extension_strength.0 - extension_strength.1\
    \ > strength {\n            strength = extension_strength.0 - extension_strength.1;\n\
    \            strongest_extension = &extension;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest_extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpel6ez55c.rs:23:20\n\
    \   |\n23 |                 'A'...'Z' => (cap + 1, sm),\n   |                \
    \    ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpel6ez55c.rs:24:20\n\
    \   |\n24 |                 'a'...'z' => (cap, sm + 1),\n   |                \
    \    ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted\
    \ in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note:\
    \ for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0597]: `extension` does not live long enough\n  --> /tmp/tmpel6ez55c.rs:30:35\n\
    \   |\n30 |             strongest_extension = &extension;\n   |              \
    \                     ^^^^^^^^^^ borrowed value does not live long enough\n31\
    \ |         }\n32 |     }\n   |     - `extension` dropped here while still borrowed\n\
    33 |     format!(\"{}.{}\", class_name, strongest_extension)\n   |           \
    \                       ------------------- borrow later used here\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0597`.\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + extension_strength(extensions).1.as_str()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `extension_strength` in this scope\n\
    \  --> /tmp/tmpv0n4axzk.rs:18:24\n   |\n18 |     class_name + \".\" + extension_strength(extensions).1.as_str()\n\
    \   |                        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    class_name + \".\" + (extensions.iter().max_by_key(|x|\
    \ x.as_str().matches(char::is_uppercase).count() - x.as_str().matches(char::is_lowercase).count()).unwrap()).as_str()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpe3kc1ale.rs:18:58

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut exts = HashMap::new();\n\
    \    for ext in extensions {\n        let mut cap = 0;\n        let mut sm = 0;\n\
    \        for c in ext.chars() {\n            if c.is_uppercase() {\n         \
    \       cap += 1;\n            } else {\n                sm += 1;\n          \
    \  }\n        }\n        exts.insert(ext, cap - sm);\n    }\n    let ext_str =\
    \ exts.iter().max_by_key(|x| x.1).unwrap().0;\n    format!(\"{}.{}\", class_name,\
    \ ext_str)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphx8helzz.rs:18:20\n   |\n18 |     let mut exts = HashMap::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_extension_strength = 0.0;\n    for extension\
    \ in extensions {\n        let cap = extension.chars().filter(|&c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|&c| c.is_lowercase()).count();\n \
    \       let strength = cap as f64 - sm as f64;\n        if strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpp_8q4vl3.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut res = class_name.clone();\n\
    \    let mut strength = std::f64::NEG_INFINITY;\n    for s in extensions {\n \
    \       let mut cap = 0;\n        let mut sm = 0;\n        for c in s.chars()\
    \ {\n            if c.is_uppercase() {\n                cap += 1;\n          \
    \  } else {\n                sm += 1;\n            }\n        }\n        let str_tmp\
    \ = (cap as f64) - (sm as f64);\n        if str_tmp > strength {\n           \
    \ strength = str_tmp;\n            res.push('.');\n            res.push_str(&s);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp_6evp63b.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = String::new();\n\
    \    let mut strength = 0;\n    for i in 0..extensions.len() {\n        let mut\
    \ cap = 0;\n        let mut sm = 0;\n        for c in extensions[i].chars() {\n\
    \            if c.is_uppercase() {\n                cap += 1;\n            } else\
    \ {\n                sm += 1;\n            }\n        }\n        if cap - sm >\
    \ strength {\n            strength = cap - sm;\n            strongest = extensions[i].clone();\n\
    \        }\n    }\n    return format!(\"{}.{}\", class_name, strongest);\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmppdtoa9lf.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut ext_strength = Vec::new();\n\
    \    for e in extensions {\n        let cap_num = e.chars().filter(|&c| c.is_uppercase()).count();\n\
    \        let sm_num = e.chars().filter(|&c| c.is_lowercase()).count();\n     \
    \   let strength = (cap_num as f64) / (sm_num as f64);\n        ext_strength.push((e,\
    \ strength));\n    }\n    let (max_index, _) = \n        ext_strength.iter().enumerate().max_by_key(|x|\
    \ x.1).unwrap();\n    format!(\"{}.{}\", class_name, ext_strength[max_index].0)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpcb6avpqm.rs:26:52\n\
    \     |\n26   |         ext_strength.iter().enumerate().max_by_key(|x| x.1).unwrap();\n\
    \     |                                         ---------- ^^^^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |                                       \
    \  |\n     |                                         required by a bound introduced\
    \ by this call\n     |\n     = help: the following other types implement trait\
    \ `Ord`:\n               i128\n               i16\n               i32\n      \
    \         i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `(String, f64)`\n     = note: 1\
    \ redundant requirement hidden\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&(String, f64)`\nnote: required by a bound in `std::iter::Iterator::max_by_key`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: f64 = std::f64::MIN;\n\
    \    let mut ext = String::new();\n    for i in extensions {\n        let mut\
    \ cap: f64 = 0.0;\n        let mut sm: f64 = 0.0;\n        for j in i.chars()\
    \ {\n            if j.is_uppercase() {\n                cap += 1.0;\n        \
    \    } else {\n                sm += 1.0;\n            }\n        }\n        let\
    \ current_strength = cap - sm;\n        if current_strength > strength {\n   \
    \         strength = current_strength;\n            ext = i;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, ext)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpsc8e6fk_.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = None;\n    let mut strength = None;\n    for extension in extensions {\n \
    \       let this_strength = Strength(extension);\n        if strength.is_none()\
    \ || this_strength > strength.unwrap() {\n            strength = Some(this_strength);\n\
    \            strongest_extension = Some(extension);\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, strongest_extension.unwrap())\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Strength`\
    \ in this scope\n  --> /tmp/tmpe1akrleq.rs:21:29\n   |\n21 |         let this_strength\
    \ = Strength(extension);\n   |                             ^^^^^^^^ help: a local\
    \ variable with a similar name exists (notice the capitalization): `strength`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: f64 = 0.0;\n\
    \    let mut strongest_extension: String = String::from(\"\");\n    for i in 0..extensions.len()\
    \ {\n        let extension = extensions[i].to_lowercase();\n        let uppercase_letters\
    \ = extension.matches(char::is_uppercase).count();\n        let lowercase_letters\
    \ = extension.matches(char::is_lowercase).count();\n        let current_strength\
    \ = (uppercase_letters as f64) - (lowercase_letters as f64);\n        if current_strength\
    \ > strength {\n            strength = current_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpqn4dpgsj.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut weakest_extension\
    \ = extensions[0].clone();\n    let mut weakest_extension_strength = 0;\n    for\
    \ i in extensions {\n        let strength = i.matches(char::is_uppercase).count()\
    \ - i.matches(char::is_lowercase).count();\n        if strength > weakest_extension_strength\
    \ {\n            weakest_extension_strength = strength;\n            weakest_extension\
    \ = i.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name, weakest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwwrtfd1o.rs:21:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strong_ext: String\
    \ = String::from(\"\");\n    let mut score: f64 = std::f64::NEG_INFINITY;\n  \
    \  for ext in extensions {\n        let mut num_lower: u32 = 0;\n        let mut\
    \ num_upper: u32 = 0;\n        for letter in ext.chars() {\n            if letter.is_uppercase()\
    \ {\n                num_upper += 1;\n            } else {\n                num_lower\
    \ += 1;\n            }\n        }\n        let curr_score: f64 = num_upper as\
    \ f64 - num_lower as f64;\n        if curr_score > score {\n            score\
    \ = curr_score;\n            strong_ext = ext;\n        }\n    }\n    return format!(\"\
    {}.{}\", class_name, strong_ext);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpw0uz6nce.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 0
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut res = \"\".to_string();\n\
    \    let mut strength = -100.0;\n    for ext in extensions {\n        let temp\
    \ = ext.chars().filter(|&c| c.is_uppercase()).count() as f64;\n        let temp1\
    \ = ext.chars().filter(|&c| c.is_lowercase()).count() as f64;\n        let temp_strength\
    \ = temp - temp1;\n        if temp_strength > strength {\n            strength\
    \ = temp_strength;\n            res = ext;\n        }\n    }\n    class_name +\
    \ \".\" + &res\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n \
    \   assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0.0;\n\
    \    let mut strongest_extension = String::new();\n    for extension in extensions\
    \ {\n        let mut caps = 0;\n        let mut smalls = 0;\n        for c in\
    \ extension.chars() {\n            if c.is_ascii_uppercase() {\n             \
    \   caps += 1;\n            } else {\n                smalls += 1;\n         \
    \   }\n        }\n        let s = caps as f64 - smalls as f64;\n        if s >\
    \ strength {\n            strength = s;\n            strongest_extension = extension;\n\
    \        }\n    }\n    let mut result = class_name.clone();\n    result.push('.');\n\
    \    result.push_str(&strongest_extension);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp8bx17d24.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976362
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strength = 0;\n    for extension in extensions\
    \ {\n        let caps = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let smalls = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let new_strength = caps - smalls;\n        if new_strength > strength\
    \ {\n            strength = new_strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return format!(\"{}.{}\", class_name, strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpxt_43aer.rs:23:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976362
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = vec![];\n\
    \    for extension in extensions {\n        let mut upper_chars = 0;\n       \
    \ let mut lower_chars = 0;\n        for ch in extension.chars() {\n          \
    \  if ch.is_ascii_uppercase() {\n                upper_chars += 1;\n         \
    \   } else {\n                lower_chars += 1;\n            }\n        }\n  \
    \      strength.push(upper_chars - lower_chars);\n    }\n    let mut max_strength\
    \ = strength[0];\n    let mut index = 0;\n    for (i, item) in strength.iter().enumerate()\
    \ {\n        if *item > max_strength {\n            max_strength = *item;\n  \
    \          index = i;\n        }\n    }\n    format!(\"{}.{}\", class_name, extensions[index])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `extensions`\n   --> /tmp/tmpn9j18a5t.rs:39:34\n\
    \    |\n17  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                            ---------- move\
    \ occurs because `extensions` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n18  |     let mut strength = vec![];\n19  |     for extension\
    \ in extensions {\n    |                      ---------- `extensions` moved due\
    \ to this implicit call to `.into_iter()`\n...\n39  |     format!(\"{}.{}\", class_name,\
    \ extensions[index])\n    |                                  ^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `extensions`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    19  |     for extension in &extensions {\n    |                      +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976362
