name: HumanEval_27_flip_case
language: rs
prompt: "/// For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n/// >>> flip_case(String::from(\"Hello\"))\n/// String::from(\"\
  hELLO\")\nfn flip_case(string: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\
  \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")),\
  \ String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent\
  \ delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\"));\n}\n"
completions: ["    string.chars().map(|c| match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n\
    \        'A'..='Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    string.chars().map(|ch| {\n        if ch.is_uppercase() {\n            ch.to_lowercase().next().unwrap()\n\
    \        } else {\n            ch.to_uppercase().next().unwrap()\n        }\n\
    \    }).collect()", "    string.chars().map(|c| if c.is_ascii_lowercase() {\n\
    \        c.to_ascii_uppercase()\n    } else {\n        c.to_ascii_lowercase()\n\
    \    }).collect()", "    string.chars().map(|c| match c {\n        x if x.is_ascii_lowercase()\
    \ => x.to_ascii_uppercase(),\n        x if x.is_ascii_uppercase() => x.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    // TODO\n    String::new()", "    let\
    \ mut flipped_string = String::new();\n    for c in string.chars() {\n       \
    \ let up_case = c.to_uppercase().to_string();\n        let lo_case = c.to_lowercase().to_string();\n\
    \        if c == up_case.chars().next().unwrap() {\n            flipped_string.push(lo_case.chars().next().unwrap());\n\
    \        } else {\n            flipped_string.push(up_case.chars().next().unwrap());\n\
    \        }\n    }\n    flipped_string", "    string.chars().map(|x| {\n      \
    \  if x.is_ascii_uppercase() {\n            x.to_ascii_lowercase()\n        }\
    \ else {\n            x.to_ascii_uppercase()\n        }\n    }).collect()", " \
    \   string.chars().map(|x| {\n        if x.is_ascii_uppercase() {\n          \
    \  x.to_ascii_lowercase()\n        } else {\n            x.to_ascii_uppercase()\n\
    \        }\n    }).collect()", "    string.chars().map(|c| match c {\n       \
    \ 'a' ... 'z' => c.to_ascii_uppercase(),\n        'A' ... 'Z' => c.to_ascii_lowercase(),\n\
    \        _ => c\n    }).collect()", "    let mut new_string = String::new();\n\
    \    for c in string.chars() {\n        if c.is_lowercase() {\n            new_string.push(c.to_uppercase().nth(0).unwrap());\n\
    \        } else if c.is_uppercase() {\n            new_string.push(c.to_lowercase().nth(0).unwrap());\n\
    \        } else {\n            new_string.push(c);\n        }\n    }\n    new_string",
  "    string.chars().map(|x| {\n        if x.is_uppercase() {\n            x.to_lowercase().next().unwrap()\n\
    \        } else {\n            x.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()", "    let mut flipped = String::new();\n    for ch in string.chars()\
    \ {\n        if ch.is_lowercase() {\n            flipped.push(ch.to_uppercase().next().unwrap());\n\
    \        } else if ch.is_uppercase() {\n            flipped.push(ch.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped.push(ch);\n        }\n    }\n    flipped",
  "    let mut result = String::new();\n    for c in string.chars() {\n        if\
    \ c.is_ascii_uppercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else {\n            result.push(c.to_ascii_uppercase());\n        }\n\
    \    }\n    result", '    unimplemented!()', "    let mut new_string = String::new();\n\
    \    for c in string.chars() {\n        if c.is_ascii_lowercase() {\n        \
    \    new_string.push(c.to_ascii_uppercase());\n        } else {\n            new_string.push(c.to_ascii_lowercase());\n\
    \        }\n    }\n    new_string", '    unimplemented!()', '    unimplemented!()',
  "    string.chars().map(|c| {\n        if c.is_lowercase() {\n            c.to_uppercase().collect::<String>()\n\
    \        } else {\n            c.to_lowercase().collect::<String>()\n        }\n\
    \    }).collect::<String>()", "    // TODO: Implement\n    string", '    unimplemented!()',
  '    string.chars().map(|c| if c.is_ascii_lowercase() { c.to_ascii_uppercase() }
    else { c.to_ascii_lowercase() }).collect()', "    string.chars().map(|c| match\
    \ c {\n        ch @ 'a'..='z' => ch.to_ascii_uppercase(),\n        ch @ 'A'..='Z'\
    \ => ch.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", "    let mut\
    \ flipped = String::new();\n    for c in string.chars() {\n        if c.is_uppercase()\
    \ {\n            flipped.push(c.to_lowercase().to_string());\n        } else {\n\
    \            flipped.push(c.to_uppercase().to_string());\n        }\n    }\n \
    \   flipped", '    unimplemented!();', '    unimplemented!();', '    unimplemented!()',
  "    string.chars().map(|ch| {\n        if ch.is_ascii_lowercase() {\n         \
    \   ch.to_ascii_uppercase()\n        } else {\n            ch.to_ascii_lowercase()\n\
    \        }\n    }).collect()", "    let mut return_string = String::new();\n \
    \   for c in string.chars() {\n        if c.is_ascii_uppercase() {\n         \
    \   return_string.push(c.to_ascii_lowercase());\n        } else {\n          \
    \  return_string.push(c.to_ascii_uppercase());\n        }\n    }\n    return_string",
  "    let mut output = String::with_capacity(string.len());\n    for c in string.chars()\
    \ {\n        output.push(c.toggle_case());\n    }\n    output", "    let mut char_array:\
    \ Vec<char> = string.chars().collect();\n    for c in char_array.iter_mut() {\n\
    \        if c.is_ascii_uppercase() {\n            *c = c.to_ascii_lowercase();\n\
    \        } else if c.is_ascii_lowercase() {\n            *c = c.to_ascii_uppercase();\n\
    \        }\n    }\n    char_array.into_iter().collect()", "  // Don't use map,\
    \ it will duplicate the string\n  let mut flipped_string = String::new();\n  for\
    \ c in string.chars() {\n    if c.is_uppercase() {\n      flipped_string.push(c.to_lowercase().next().unwrap());\n\
    \    } else {\n      flipped_string.push(c.to_uppercase().next().unwrap());\n\
    \    }\n  }\n  flipped_string", '    unimplemented!();', '    string.chars().map(|c|
    c.to_lowercase().next().unwrap()).collect()', '    unimplemented!();', "    let\
    \ mut output = String::new();\n    for c in string.chars() {\n        if c.is_lowercase()\
    \ {\n            output.push(c.to_uppercase().next().unwrap());\n        } else\
    \ if c.is_uppercase() {\n            output.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            output.push(c);\n        }\n    }\n    output",
  "    string.chars().map(|c| match c {\n        c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \        c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n        _ =>\
    \ c,\n    }).collect()", "    let mut flipped_string = String::new();\n    for\
    \ character in string.chars() {\n        if character.is_uppercase() {\n     \
    \       flipped_string.push(character.to_lowercase().next().unwrap());\n     \
    \   } else {\n            flipped_string.push(character.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    flipped_string", "    string.chars().map(|character| match\
    \ character {\n        character if character.is_lowercase() => character.to_ascii_uppercase(),\n\
    \        character if character.is_uppercase() => character.to_ascii_lowercase(),\n\
    \        _ => character,\n    }).collect()", "    string.chars().map(|c| {\n \
    \       if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        }\n \
    \   }).collect()", "    string.chars().map(|c| match c {\n        c if c.is_lowercase()\
    \ => c.to_uppercase().next().unwrap(),\n        c if c.is_uppercase() => c.to_lowercase().next().unwrap(),\n\
    \        _ => c,\n    }).collect()", "    let mut flipped_string = String::new();\n\
    \    for c in string.chars() {\n        if c.is_uppercase() {\n            flipped_string.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped_string.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    flipped_string", "    let mut flipped_string = String::new();\n\
    \    for character in string.chars() {\n        if character.is_lowercase() {\n\
    \            flipped_string.push(character.to_uppercase().next().unwrap());\n\
    \        } else if character.is_uppercase() {\n            flipped_string.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped_string.push(character);\n        }\n  \
    \  }\n    flipped_string", "    string.chars().map(|char| {\n        if char.is_lowercase()\
    \ {\n            char.to_uppercase().next().unwrap()\n        } else {\n     \
    \       char.to_lowercase().next().unwrap()\n        }\n    }).collect()", '    string.chars().map(|c|
    if c.is_ascii_lowercase() { c.to_ascii_uppercase() } else { c.to_ascii_lowercase()
    }).collect()', '    string.chars().map(|x| x.is_uppercase()? x.to_lowercase().next().unwrap():
    x.to_uppercase().next().unwrap()).collect()', "    let mut flipped = String::new();\n\
    \    for c in string.chars() {\n        if c.is_lowercase() {\n            flipped.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            flipped.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped.push(c);\n        }\n    }\n    flipped",
  '    unimplemented!();', '    unimplemented!();', "    string.chars().map(|c| {\n\
    \        match c {\n            'a'...'z' => c.to_ascii_uppercase(),\n       \
    \     'A'...'Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n \
    \   }).collect()", "    string.chars().map(|c| match c {\n        'a'...'z' =>\
    \ c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n    \
    \    _ => c,\n    }).collect()", "  let mut chars = string.chars();\n  let mut\
    \ flip_string = String::from(\"\");\n  for c in chars {\n    if c.is_uppercase()\
    \ {\n      flip_string.push(c.to_lowercase().to_string());\n    } else {\n   \
    \   flip_string.push(c.to_uppercase().to_string());\n    }\n  }\n  flip_string",
  "    // TODO: Implement this\n    string", "    let mut string = string;\n    string.make_ascii_lowercase();\n\
    \    string", "    string.chars().map(|ch| {\n        if ch.is_uppercase() {\n\
    \            ch.to_lowercase().to_string()\n        } else {\n            ch.to_uppercase().to_string()\n\
    \        }\n    }).collect()", "    string.chars().map(|c| if c.is_uppercase()\
    \ {\n        c.to_lowercase().next().unwrap()\n    } else {\n        c.to_uppercase().next().unwrap()\n\
    \    }).collect()", '    unimplemented!()', "    let mut chars = string.chars();\n\
    \    String::from_iter(chars.map(|c| c.to_ascii_uppercase()))", '    unimplemented!()',
  "    // create an empty vector to store the flipped characters\n    let mut result:\
    \ Vec<char> = Vec::new();\n    // loop through the string and flip the cases\n\
    \    for ch in string.chars() {\n        if ch.is_ascii_lowercase() {\n      \
    \      result.push(ch.to_ascii_uppercase());\n        } else {\n            result.push(ch.to_ascii_lowercase());\n\
    \        }\n    }\n    // collect the result into a string and return\n    result.into_iter().collect()",
  "    string.chars().map(|c| match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n\
    \        'A'..='Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  '    unimplemented!();', "    string.chars().map(|character| {\n        if character.is_uppercase()\
    \ {\n            character.to_lowercase().next().unwrap()\n        } else {\n\
    \            character.to_uppercase().next().unwrap()\n        }\n    }).collect()",
  "    let mut result = String::new();\n    for c in string.chars() {\n        if\
    \ c.is_uppercase() {\n            result.push(c.to_lowercase().to_string());\n\
    \        } else {\n            result.push(c.to_uppercase().to_string());\n  \
    \      }\n    }\n    result", '    unimplemented!();', "    let mut flipped =\
    \ String::new();\n    for c in string.chars() {\n        flipped.push(match c\
    \ {\n            'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' =>\
    \ c.to_ascii_lowercase(),\n            _ => c,\n        });\n    }\n    flipped",
  "    let mut flipped = String::new();\n    for character in string.chars() {\n \
    \       if character.is_uppercase() {\n            flipped.push(character.to_lowercase().to_string());\n\
    \        } else {\n            flipped.push(character.to_uppercase().to_string());\n\
    \        }\n    }\n    flipped", "    let mut flipped = String::new();\n    for\
    \ c in string.chars() {\n        let mut a = c.to_ascii_lowercase();\n       \
    \ let mut b = c.to_ascii_uppercase();\n        if c == a {\n            flipped.push(b);\n\
    \        } else {\n            flipped.push(a);\n        }\n    }\n    flipped",
  '    unimplemented!()', "    let mut flipped_case_string = String::new();\n    for\
    \ i in string.chars() {\n        if i.is_ascii_uppercase() {\n            flipped_case_string.push(i.to_ascii_lowercase());\n\
    \        } else {\n            flipped_case_string.push(i.to_ascii_uppercase());\n\
    \        }\n    }\n    flipped_case_string", '    unimplemented!();', '    unimplemented!();',
  '    unimplemented!()', '    string.chars().map(|char| if char.is_uppercase() {
    char.to_lowercase().next().unwrap() } else { char.to_uppercase().next().unwrap()
    }).collect()', "    // TODO: Add your code here\n    let mut new_string = String::new();\n\
    \    for c in string.chars() {\n        new_string.push(match c {\n          \
    \  'a'...'z' => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        });\n    }\n    new_string", "    let bytes = string.into_bytes();\n\
    \    bytes\n        .iter()\n        .map(|c| {\n            if c.is_ascii_uppercase()\
    \ {\n                c.to_ascii_lowercase()\n            } else {\n          \
    \      c.to_ascii_uppercase()\n            }\n        })\n        .collect()",
  '    unimplemented!()', "    let mut result = String::new();\n    for c in string.chars()\
    \ {\n        if c.is_lowercase() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    result", '    unimplemented!();', "    string.chars().map(|c|\
    \ match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n        'A'..='Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", '    unimplemented!()',
  '    unimplemented!()', "    // String implements FromIterator<char>, so this is\
    \ equivalent to\n    // string.chars().map(...).collect()\n    string.chars().map(|c|\
    \ if c.is_uppercase() {\n        c.to_lowercase().next().unwrap()\n    } else\
    \ {\n        c.to_uppercase().next().unwrap()\n    }).collect()", "    string.chars().map(|c|\
    \ match c {\n        'a'...'z' => (c as u8 + 'A' as u8 - 'a' as u8) as char,\n\
    \        'A'...'Z' => (c as u8 + 'a' as u8 - 'A' as u8) as char,\n        _ =>\
    \ c,\n    }).collect()", "    string.chars().map(|c| {\n        if c.is_ascii_uppercase()\
    \ {\n            c.to_ascii_lowercase()\n        } else {\n            c.to_ascii_uppercase()\n\
    \        }\n    }).collect()", "    let mut result = String::new();\n    for letter\
    \ in string.chars() {\n        match letter {\n            'a'...'z' => result.push(letter.to_ascii_uppercase()),\n\
    \            'A'...'Z' => result.push(letter.to_ascii_lowercase()),\n        \
    \    _ => result.push(letter),\n        }\n    }\n    result", '    string.chars().map(|c|
    if c.is_uppercase() { c.to_lowercase().next().unwrap() } else { c.to_uppercase().next().unwrap()
    }).collect()', "    string.chars().map(|c| {\n        match c {\n            'a'...'z'\
    \ => (c as u8 - b'a' + b'A') as char,\n            'A'...'Z' => (c as u8 - b'A'\
    \ + b'a') as char,\n            _ => c,\n        }\n    }).collect()", "    let\
    \ mut new_string = String::new();\n    for c in string.chars() {\n        if c.is_uppercase()\
    \ {\n            new_string.push(c.to_lowercase().next().unwrap());\n        }\
    \ else {\n            new_string.push(c.to_uppercase().next().unwrap());\n   \
    \     }\n    }\n    new_string", '    unimplemented!();', '    unimplemented!();',
  "    let mut flipped_case = String::from(\"\");\n    for c in string.chars() {\n\
    \        if c.is_lowercase() {\n            flipped_case.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            flipped_case.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped_case.push(c);\n        }\n    }\n    flipped_case",
  "    string.chars().map(|c| if c.is_uppercase() {\n        c.to_lowercase().collect::<String>()\n\
    \    } else {\n        c.to_uppercase().collect::<String>()\n    }).collect::<String>()",
  '    unimplemented!();', "    string.chars().map(|c| {\n        match c {\n    \
    \        'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()", "    string.chars().map(|c|\
    \ match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", '    string.chars().map(|c|
    if c.is_ascii_lowercase() { c.to_ascii_uppercase() } else { c.to_ascii_lowercase()
    }).collect()', "    let mut flipped = String::new();\n    for c in string.chars()\
    \ {\n        if c.is_lowercase() {\n            flipped.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            flipped.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped.push(c);\n        }\n    }\n    flipped",
  "    // Note that this code is ugly and can be made much simpler\n    let mut output\
    \ = String::new();\n    for c in string.chars() {\n        if c.is_lowercase()\
    \ {\n            output.push(c.to_uppercase().next().unwrap());\n        } else\
    \ if c.is_uppercase() {\n            output.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            output.push(c);\n        }\n    }\n    output",
  "    string.chars().map(|c| if c.is_uppercase() {\n        c.to_lowercase().next().unwrap()\n\
    \    } else {\n        c.to_uppercase().next().unwrap()\n    }).collect()", '    string.chars().map(|c|
    c.to_ascii_uppercase()).collect()', '    unimplemented!();', "    // For now,\
    \ only works for ASCII\n    string.chars().map(|c| {\n        if c.is_ascii_lowercase()\
    \ {\n            c.to_ascii_uppercase()\n        } else if c.is_ascii_uppercase()\
    \ {\n            c.to_ascii_lowercase()\n        } else {\n            c\n   \
    \     }\n    }).collect()", "    let mut result = String::new();\n    for c in\
    \ string.chars() {\n        if c.is_lowercase() {\n            result.push(c.to_uppercase().to_string());\n\
    \        } else {\n            result.push(c.to_lowercase().to_string());\n  \
    \      }\n    }\n    result", "    let mut flipped_string = String::new();\n \
    \   for c in string.chars() {\n        if c.is_ascii_lowercase() {\n         \
    \   flipped_string.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            flipped_string.push(c.to_ascii_lowercase());\n        } else\
    \ {\n            flipped_string.push(c);\n        }\n    }\n    flipped_string",
  "    let mut ret = String::new();\n    for c in string.chars() {\n        if c.is_ascii_uppercase()\
    \ {\n            ret.push(c.to_ascii_lowercase());\n        } else {\n       \
    \     ret.push(c.to_ascii_uppercase());\n        }\n    }\n    ret", "    string.chars().map(|c|\
    \ if c.is_uppercase() {\n        c.to_lowercase().next().unwrap()\n    } else\
    \ {\n        c.to_uppercase().next().unwrap()\n    }).collect()", '    string.chars().map(|x|
    x.to_lowercase().to_string()).collect()', "    let result = string.chars().map(|c|\
    \ {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   });\n    result.collect()", '    unimplemented!()', "    // string.into_bytes()\
    \ return Vec<u8>\n    // we can do .map() on Vec<u8> because .map() is implemented\
    \ for Vec<T>\n    // we need to return Vec<u8>\n    // Vec<u8> does not implement\
    \ Display but Vec<char> does\n    string\n        .into_bytes()\n        .map(|byte|\
    \ {\n            // byte is of type u8\n            if byte >= 65 && byte <= 90\
    \ {\n                byte + 32\n            } else if byte >= 97 && byte <= 122\
    \ {\n                byte - 32\n            } else {\n                byte\n \
    \           }\n        })\n        .collect::<Vec<u8>>()\n        .iter()\n  \
    \      .map(|byte| *byte as char)\n        .collect::<Vec<char>>()\n        .iter()\n\
    \        .collect::<String>()", "    let mut result = String::with_capacity(string.len());\n\
    \    for c in string.chars() {\n        if c.is_uppercase() {\n            result.push(c.to_lowercase().collect::<String>());\n\
    \        } else {\n            result.push(c.to_uppercase().collect::<String>());\n\
    \        }\n    }\n    result", "    let mut flipped = String::new();\n    for\
    \ ch in string.chars() {\n        if ch.is_lowercase() {\n            flipped.push(ch.to_uppercase().next().unwrap());\n\
    \        } else if ch.is_uppercase() {\n            flipped.push(ch.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped.push(ch);\n        }\n    }\n    flipped",
  "    string.chars().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    string.chars().map(|char| {\n        if char.is_ascii_lowercase() {\n     \
    \       char.to_ascii_uppercase()\n        } else {\n            char.to_ascii_lowercase()\n\
    \        }\n    }).collect()", "    string.chars().map(|character| {\n       \
    \ match character {\n            'a'...'z' => character.to_ascii_uppercase(),\n\
    \            'A'...'Z' => character.to_ascii_lowercase(),\n            _ => character,\n\
    \        }\n    }).collect()", '    string.chars().map(|c| if c.is_lowercase()
    { c.to_uppercase().next().unwrap() } else { c.to_lowercase().next().unwrap() }).collect()',
  '    unimplemented!()', "    // FILL THIS IN!\n    unimplemented!()", "    // Note\
    \ that for strings, ASCII characters may be encoded as two bytes. This function\n\
    \    // only works if all characters are ASCII characters.\n    string.chars().map(|ch|\
    \ match ch {\n        'a' ... 'z' => ch.to_ascii_uppercase(),\n        'A' ...\
    \ 'Z' => ch.to_ascii_lowercase(),\n        _ => ch,\n    }).collect()", "    string.chars().map(|c|\
    \ {\n        match c {\n            c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \            c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n        \
    \    _ => c,\n        }\n    }).collect()", "    let mut result = String::new();\n\
    \    for c in string.chars() {\n        if c.is_lowercase() {\n            result.push(c.to_uppercase().to_string());\n\
    \        } else {\n            result.push(c.to_lowercase().to_string());\n  \
    \      }\n    }\n    result", "    string.chars().map(|c| {\n        if c.is_ascii_lowercase()\
    \ {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        }\n    }).collect()", '    unimplemented!();', "    string.chars().map(|c|\
    \ {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()", "    let mut flipped = String::with_capacity(string.len());\n\
    \    for c in string.chars() {\n        if c.is_uppercase() {\n            flipped.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    flipped", "    // TODO: Complete this function\n    let\
    \ mut output = String::new();\n    for c in string.chars() {\n        if c.is_lowercase()\
    \ {\n            output.push(c.to_uppercase().next().unwrap());\n        } else\
    \ {\n            output.push(c.to_lowercase().next().unwrap());\n        }\n \
    \   }\n    output", "    // Place your code here\n    unimplemented!()", '    string.chars().map(|c|
    if c.is_lowercase() { c.to_uppercase().to_string() } else { c.to_lowercase().to_string()
    }).collect()', '    unimplemented!()', "    let mut new_string = String::new();\n\
    \    for ch in string.chars() {\n        if ch.is_lowercase() {\n            new_string.push(ch.to_uppercase().next().unwrap());\n\
    \        } else {\n            new_string.push(ch.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    new_string", '    unimplemented!()', '    unimplemented!()',
  "    string.chars().map(|x| {\n        if x.is_ascii_uppercase() {\n           \
    \ x.to_ascii_lowercase()\n        } else {\n            x.to_ascii_uppercase()\n\
    \        }\n    }).collect()", '    unimplemented!();', '    string.chars().map(|c|
    if c.is_uppercase() { c.to_lowercase().to_string() } else { c.to_uppercase().to_string()
    }).collect()', "    string.chars().map(|c| match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n\
    \        'A'..='Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    string.chars().map(|c| {\n        match c {\n            'a'..='z' => c.to_ascii_uppercase(),\n\
    \            'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n     \
    \   }\n    }).collect()", "    string.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().to_string()\n        } else {\n            c.to_lowercase().to_string()\n\
    \        }\n    }).collect()", "    return string.chars().map(|c| match c {\n\
    \        'a'..='z' => c.to_ascii_uppercase(),\n        'A'..='Z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect::<String>();", "    let mut flipped_string =\
    \ String::from(\"\");\n    for c in string.chars() {\n        if c.is_lowercase()\
    \ {\n            flipped_string.push(c.to_uppercase().next().unwrap());\n    \
    \    } else if c.is_uppercase() {\n            flipped_string.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped_string.push(c);\n        }\n    }\n   \
    \ flipped_string", "    let mut flipped = String::new();\n    for character in\
    \ string.chars() {\n        if character.is_ascii_lowercase() {\n            flipped.push(character.to_ascii_uppercase());\n\
    \        } else if character.is_ascii_uppercase() {\n            flipped.push(character.to_ascii_lowercase());\n\
    \        } else {\n            flipped.push(character);\n        }\n    }\n  \
    \  flipped", "    let mut flipped_case = String::new();\n    for c in string.chars()\
    \ {\n        match c {\n            'a'..='z' => flipped_case.push(c.to_ascii_uppercase()),\n\
    \            'A'..='Z' => flipped_case.push(c.to_ascii_lowercase()),\n       \
    \     _ => flipped_case.push(c),\n        }\n    }\n    flipped_case", '    unimplemented!();',
  '    unimplemented!()', "    // Make string mutable.\n    let mut flipped = String::from(\"\
    \");\n    for c in string.chars() {\n        match c {\n            // Flip case.\n\
    \            'a'...'z' => flipped.push(c.to_ascii_uppercase()),\n            'A'...'Z'\
    \ => flipped.push(c.to_ascii_lowercase()),\n            _ => flipped.push(c),\n\
    \        }\n    }\n    flipped", '    unimplemented!()', "    string.chars().map(|character|\
    \ match character {\n        'a'...'z' => character.to_ascii_uppercase(),\n  \
    \      'A'...'Z' => character.to_ascii_lowercase(),\n        _ => character,\n\
    \    }).collect()", "    string.chars().map(|character| {\n        if character.is_lowercase()\
    \ {\n            character.to_uppercase().collect::<String>()\n        } else\
    \ {\n            character.to_lowercase().collect::<String>()\n        }\n   \
    \ }).collect::<String>()", "    let mut new_string = String::new();\n    for ch\
    \ in string.chars() {\n        if ch.is_uppercase() {\n            new_string.push(ch.to_lowercase().to_string());\n\
    \        } else {\n            new_string.push(ch.to_uppercase().to_string());\n\
    \        }\n    }\n    new_string", "    string.chars().map(|c| {\n        match\
    \ c {\n            'a'...'z' => c.to_ascii_uppercase(),\n            'A'...'Z'\
    \ => c.to_ascii_lowercase(),\n            _ => c,\n        }\n    }).collect()",
  '    unimplemented!();', "    string.chars().map(|c| match c {\n        'a'...'z'\
    \ => (c as u8 - 'a' as u8 + 'A' as u8) as char,\n        'A'...'Z' => (c as u8\
    \ - 'A' as u8 + 'a' as u8) as char,\n        _ => c,\n    }).collect()", "   \
    \ string.chars().map(|c| {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()", "    let mut new_string = String::new();\n    for c in string.chars()\
    \ {\n        if c.is_uppercase() {\n            new_string.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            new_string.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    new_string", "    string.chars().map(|c| if c.is_uppercase()\
    \ {\n        c.to_lowercase().next().unwrap()\n    } else {\n        c.to_uppercase().next().unwrap()\n\
    \    }).collect()", "    let mut chars = string.chars();\n    let mut flipped\
    \ = String::new();\n    while let Some(c) = chars.next() {\n        flipped.push(if\
    \ c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n        }\
    \ else {\n            c.to_lowercase().next().unwrap()\n        });\n    }\n \
    \   flipped", '    unimplemented!()', "    string.chars().map(|c| if c.is_lowercase()\
    \ {\n        c.to_uppercase().collect::<String>()\n    } else {\n        c.to_lowercase().collect::<String>()\n\
    \    }).collect::<String>()", '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!();', '    unimplemented!();', '    unimplemented!();', '  unimplemented!()',
  "    let bytes = string.into_bytes();\n    let mut flipped = String::new();\n  \
    \  for byte in bytes {\n        if byte.is_ascii_uppercase() {\n            flipped.push_str(&byte.to_ascii_lowercase().to_string());\n\
    \        } else if byte.is_ascii_lowercase() {\n            flipped.push_str(&byte.to_ascii_uppercase().to_string());\n\
    \        } else {\n            flipped.push_str(&byte.to_string());\n        }\n\
    \    }\n    flipped", "    let mut flipped_case = String::new();\n    for ch in\
    \ string.chars() {\n        match ch.is_uppercase() {\n            true => flipped_case.push(ch.to_lowercase().next().unwrap()),\n\
    \            false => flipped_case.push(ch.to_uppercase().next().unwrap()),\n\
    \        }\n    }\n    flipped_case", '    unimplemented!()', "    string.chars().map(|c|\
    \ if c.is_lowercase() {\n        c.to_uppercase().next().unwrap()\n    } else\
    \ {\n        c.to_lowercase().next().unwrap()\n    }).collect()", "    string.chars().map(|ch|\
    \ {\n        match ch {\n            'a'...'z' => ch.to_ascii_uppercase(),\n \
    \           'A'...'Z' => ch.to_ascii_lowercase(),\n            _ => ch,\n    \
    \    }\n    }).collect()", '    unimplemented!()', "    string.chars().map(|c|\
    \ match c {\n        'a'...'z' => (c as u8 - b'a' + b'A') as char,\n        'A'...'Z'\
    \ => (c as u8 - b'A' + b'a') as char,\n        _ => c,\n    }).collect()", '    unimplemented!();',
  '    unimplemented!();', "    string.chars().map(|x| if x.is_ascii_lowercase() {\n\
    \        x.to_ascii_uppercase()\n    } else {\n        x.to_ascii_lowercase()\n\
    \    }).collect()", "    // TODO: Fill this in\n    unimplemented!()", '    unimplemented!()',
  '    unimplemented!()', "    // TODO!\n    unimplemented!()", "    string.chars().map(|char|\
    \ {\n        if char.is_lowercase() {\n            char.to_uppercase().next().unwrap()\n\
    \        } else {\n            char.to_lowercase().next().unwrap()\n        }\n\
    \    }).collect()", "    // unimplemented!()\n    string.chars().map(|c| {\n \
    \       if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        }\n \
    \   }).collect()", "    string.chars().map(|c| match c {\n        'a' ... 'z'\
    \ => (c as u8 + b'A' - b'a') as char,\n        'A' ... 'Z' => (c as u8 + b'a'\
    \ - b'A') as char,\n        _ => c,\n    }).collect()", '    unimplemented!();',
  "    string.chars().map(|c| if c.is_ascii_lowercase() {\n        c.to_ascii_uppercase()\n\
    \    } else {\n        c.to_ascii_lowercase()\n    }).collect()", "    string.chars().map(|c|\
    \ match c {\n        c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \        c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n        _ =>\
    \ c,\n    }).collect()", "    let chars: Vec<char> = string.chars().collect();\n\
    \    let mut result: String = String::new();\n    for c in chars {\n        if\
    \ c.is_ascii_uppercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else {\n            result.push(c.to_ascii_uppercase());\n        }\n\
    \    }\n    result", "    string.chars().map(|c| {\n        match c {\n      \
    \      // Flip from lowercase to uppercase\n            'a'...'z' => std::char::from_u32(c\
    \ as u32 - 32).unwrap(),\n            // Flip from uppercase to lowercase\n  \
    \          'A'...'Z' => std::char::from_u32(c as u32 + 32).unwrap(),\n       \
    \     // Leave unchanged\n            _ => c,\n        }\n    }).collect()", " \
    \   string.chars().map(|c| {\n        if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        }\n \
    \   }).collect()", "    string.chars().map(|c| {\n        if c.is_uppercase()\
    \ {\n            c.to_lowercase().collect::<String>()\n        } else {\n    \
    \        c.to_uppercase().collect::<String>()\n        }\n    }).collect::<String>()",
  '    string.chars().map(|x| x.to_ascii_uppercase()).collect()', '    unimplemented!();',
  "    string.chars().map(|x| match x {\n        x if x.is_lowercase() => x.to_uppercase().next().unwrap(),\n\
    \        x if x.is_uppercase() => x.to_lowercase().next().unwrap(),\n        _\
    \ => x,\n    }).collect()", '    unimplemented!()', '    unimplemented!()', '    unimplemented!()',
  "    string.chars().map(|c| {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()", '    unimplemented!()', "    return string\n        .chars()\n\
    \        .map(|x| match x {\n            'a'...'z' => x.to_ascii_uppercase(),\n\
    \            'A'...'Z' => x.to_ascii_lowercase(),\n            _ => x,\n     \
    \   })\n        .collect();", "    let mut string = string;\n    string.make_ascii_lowercase();\n\
    \    string", "    string.chars().map(|c| {\n        if c.is_ascii_uppercase()\
    \ {\n            c.to_ascii_lowercase()\n        } else {\n            c.to_ascii_uppercase()\n\
    \        }\n    }).collect()", "    let mut flipped = String::new();\n    for\
    \ c in string.chars() {\n        if c.is_lowercase() {\n            flipped.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            flipped.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped.push(c);\n        }\n    }\n    flipped"]
stop_tokens:
- "\n}"
